import {
  between,
  clamp,
  greaterThan,
  greaterThanOrEqualTo,
  lessThan,
  lessThanOrEqualTo,
  max,
  min,
  none,
  number,
  number3 as number2,
  some
} from "./chunk-PMMD7ZWW.js";
import {
  dual,
  isNumber
} from "./chunk-KURLOJT7.js";
import {
  __export
} from "./chunk-2LSFTFF7.js";

// ../node_modules/effect/dist/esm/Number.js
var Number_exports = {};
__export(Number_exports, {
  Equivalence: () => Equivalence,
  Order: () => Order,
  between: () => between2,
  clamp: () => clamp2,
  decrement: () => decrement,
  divide: () => divide,
  greaterThan: () => greaterThan2,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo2,
  increment: () => increment,
  isNumber: () => isNumber2,
  lessThan: () => lessThan2,
  lessThanOrEqualTo: () => lessThanOrEqualTo2,
  max: () => max2,
  min: () => min2,
  multiply: () => multiply,
  multiplyAll: () => multiplyAll,
  nextPow2: () => nextPow2,
  parse: () => parse,
  remainder: () => remainder,
  sign: () => sign,
  subtract: () => subtract,
  sum: () => sum,
  sumAll: () => sumAll,
  unsafeDivide: () => unsafeDivide
});
var isNumber2 = isNumber;
var sum = dual(2, (self, that) => self + that);
var multiply = dual(2, (self, that) => self * that);
var subtract = dual(2, (self, that) => self - that);
var divide = dual(2, (self, that) => that === 0 ? none : some(self / that));
var unsafeDivide = dual(2, (self, that) => self / that);
var increment = (n) => n + 1;
var decrement = (n) => n - 1;
var Equivalence = number;
var Order = number2;
var lessThan2 = lessThan(Order);
var lessThanOrEqualTo2 = lessThanOrEqualTo(Order);
var greaterThan2 = greaterThan(Order);
var greaterThanOrEqualTo2 = greaterThanOrEqualTo(Order);
var between2 = between(Order);
var clamp2 = clamp(Order);
var min2 = min(Order);
var max2 = max(Order);
var sign = (n) => Order(n, 0);
var sumAll = (collection) => {
  let out = 0;
  for (const n of collection) {
    out += n;
  }
  return out;
};
var multiplyAll = (collection) => {
  let out = 1;
  for (const n of collection) {
    if (n === 0) {
      return 0;
    }
    out *= n;
  }
  return out;
};
var remainder = dual(2, (self, divisor) => {
  const selfDecCount = (self.toString().split(".")[1] || "").length;
  const divisorDecCount = (divisor.toString().split(".")[1] || "").length;
  const decCount = selfDecCount > divisorDecCount ? selfDecCount : divisorDecCount;
  const selfInt = parseInt(self.toFixed(decCount).replace(".", ""));
  const divisorInt = parseInt(divisor.toFixed(decCount).replace(".", ""));
  return selfInt % divisorInt / Math.pow(10, decCount);
});
var nextPow2 = (n) => {
  const nextPow = Math.ceil(Math.log(n) / Math.log(2));
  return Math.max(Math.pow(2, nextPow), 2);
};
var parse = (s) => {
  if (s === "NaN") {
    return some(NaN);
  }
  if (s === "Infinity") {
    return some(Infinity);
  }
  if (s === "-Infinity") {
    return some(-Infinity);
  }
  if (s.trim() === "") {
    return none;
  }
  const n = Number(s);
  return Number.isNaN(n) ? none : some(n);
};

export {
  isNumber2 as isNumber,
  sum,
  multiply,
  subtract,
  divide,
  unsafeDivide,
  increment,
  decrement,
  Equivalence,
  Order,
  lessThan2 as lessThan,
  lessThanOrEqualTo2 as lessThanOrEqualTo,
  greaterThan2 as greaterThan,
  greaterThanOrEqualTo2 as greaterThanOrEqualTo,
  between2 as between,
  clamp2 as clamp,
  min2 as min,
  max2 as max,
  sign,
  sumAll,
  multiplyAll,
  remainder,
  nextPow2,
  parse,
  Number_exports
};
//# sourceMappingURL=chunk-ODPGYV6G.js.map
