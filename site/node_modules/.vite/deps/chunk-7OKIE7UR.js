import {
  $2baaea4c71418dea$export$294aa081a6c6f55d
} from "./chunk-5F7XF222.js";
import {
  $e6afbd83fe6ebbd2$export$4c014de7c8940b4c
} from "./chunk-TV3QWCX4.js";
import {
  $3ef42575df84b30b$export$9d1611c77c2fe928,
  $65484d02dcb7eb3e$export$457c3d6518dd4c6f
} from "./chunk-7VOPOBX3.js";
import {
  require_react
} from "./chunk-4BTUQGSU.js";
import {
  __toESM
} from "./chunk-2LSFTFF7.js";

// ../node_modules/@react-aria/textfield/dist/import.mjs
var import_react = __toESM(require_react(), 1);
function $2d73ec29415bd339$export$712718f7aec83d5(props, ref) {
  let { inputElementType = "input", isDisabled = false, isRequired = false, isReadOnly = false, validationState, type = "text", onChange = () => {
  } } = props;
  let { focusableProps } = (0, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c)(props, ref);
  let { labelProps, fieldProps, descriptionProps, errorMessageProps } = (0, $2baaea4c71418dea$export$294aa081a6c6f55d)(props);
  let domProps = (0, $65484d02dcb7eb3e$export$457c3d6518dd4c6f)(props, {
    labelable: true
  });
  const inputOnlyProps = {
    type,
    pattern: props.pattern
  };
  return {
    labelProps,
    inputProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(domProps, inputElementType === "input" && inputOnlyProps, {
      disabled: isDisabled,
      readOnly: isReadOnly,
      "aria-required": isRequired || void 0,
      "aria-invalid": validationState === "invalid" || void 0,
      "aria-errormessage": props["aria-errormessage"],
      "aria-activedescendant": props["aria-activedescendant"],
      "aria-autocomplete": props["aria-autocomplete"],
      "aria-haspopup": props["aria-haspopup"],
      value: props.value,
      defaultValue: props.value ? void 0 : props.defaultValue,
      onChange: (e) => onChange(e.target.value),
      autoComplete: props.autoComplete,
      maxLength: props.maxLength,
      minLength: props.minLength,
      name: props.name,
      placeholder: props.placeholder,
      inputMode: props.inputMode,
      // Clipboard events
      onCopy: props.onCopy,
      onCut: props.onCut,
      onPaste: props.onPaste,
      // Composition events
      onCompositionEnd: props.onCompositionEnd,
      onCompositionStart: props.onCompositionStart,
      onCompositionUpdate: props.onCompositionUpdate,
      // Selection events
      onSelect: props.onSelect,
      // Input events
      onBeforeInput: props.onBeforeInput,
      onInput: props.onInput,
      ...focusableProps,
      ...fieldProps
    }),
    descriptionProps,
    errorMessageProps
  };
}
function $d841c8010a73d545$var$supportsNativeBeforeInputEvent() {
  return typeof window !== "undefined" && window.InputEvent && // @ts-ignore
  typeof InputEvent.prototype.getTargetRanges === "function";
}
function $d841c8010a73d545$export$4f384c9210e583c3(props, state, inputRef) {
  let stateRef = (0, import_react.useRef)(state);
  stateRef.current = state;
  (0, import_react.useEffect)(() => {
    if (!$d841c8010a73d545$var$supportsNativeBeforeInputEvent())
      return;
    let input = inputRef.current;
    let onBeforeInput2 = (e) => {
      let state2 = stateRef.current;
      let nextValue;
      switch (e.inputType) {
        case "historyUndo":
        case "historyRedo":
          return;
        case "deleteContent":
        case "deleteByCut":
        case "deleteByDrag":
          nextValue = input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);
          break;
        case "deleteContentForward":
          nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd + 1) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);
          break;
        case "deleteContentBackward":
          nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart - 1) + input.value.slice(input.selectionStart) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);
          break;
        case "deleteSoftLineBackward":
        case "deleteHardLineBackward":
          nextValue = input.value.slice(input.selectionStart);
          break;
        default:
          if (e.data != null)
            nextValue = input.value.slice(0, input.selectionStart) + e.data + input.value.slice(input.selectionEnd);
          break;
      }
      if (nextValue == null || !state2.validate(nextValue))
        e.preventDefault();
    };
    input.addEventListener("beforeinput", onBeforeInput2, false);
    return () => {
      input.removeEventListener("beforeinput", onBeforeInput2, false);
    };
  }, [
    inputRef,
    stateRef
  ]);
  let onBeforeInput = !$d841c8010a73d545$var$supportsNativeBeforeInputEvent() ? (e) => {
    let nextValue = e.target.value.slice(0, e.target.selectionStart) + e.data + e.target.value.slice(e.target.selectionEnd);
    if (!state.validate(nextValue))
      e.preventDefault();
  } : null;
  let { labelProps, inputProps: textFieldProps, descriptionProps, errorMessageProps } = (0, $2d73ec29415bd339$export$712718f7aec83d5)(props, inputRef);
  let compositionStartState = (0, import_react.useRef)(null);
  return {
    inputProps: (0, $3ef42575df84b30b$export$9d1611c77c2fe928)(textFieldProps, {
      onBeforeInput,
      onCompositionStart() {
        let { value, selectionStart, selectionEnd } = inputRef.current;
        compositionStartState.current = {
          value,
          selectionStart,
          selectionEnd
        };
      },
      onCompositionEnd() {
        if (!state.validate(inputRef.current.value)) {
          let { value, selectionStart, selectionEnd } = compositionStartState.current;
          inputRef.current.value = value;
          inputRef.current.setSelectionRange(selectionStart, selectionEnd);
          state.setInputValue(value);
        }
      }
    }),
    labelProps,
    descriptionProps,
    errorMessageProps
  };
}

export {
  $2d73ec29415bd339$export$712718f7aec83d5,
  $d841c8010a73d545$export$4f384c9210e583c3
};
//# sourceMappingURL=chunk-7OKIE7UR.js.map
