import {
  String_exports,
  isNonEmpty
} from "./chunk-N4N7DAG5.js";
import {
  Array_exports,
  Iterable_exports,
  Tuple_exports,
  allocate,
  append,
  appendAll,
  contains as contains2,
  containsWith,
  dedupe,
  dedupeAdjacent,
  drop,
  empty,
  empty2,
  every,
  filter,
  filterMap,
  filterMapWhile,
  findFirst,
  findFirstIndex,
  findLast,
  findLastIndex,
  flatMap as flatMap2,
  flatten,
  fromIterable,
  getEquivalence,
  getSomes,
  head,
  headNonEmpty,
  intersection,
  isArray,
  isEmptyReadonlyArray,
  isNonEmptyArray,
  isNonEmptyReadonlyArray,
  join,
  last,
  lastNonEmpty,
  make as make3,
  make2 as make4,
  makeBy,
  map as map3,
  mapAccum,
  match as match3,
  modifyOption,
  of,
  partition,
  partitionMap,
  prepend,
  reduce,
  reduceRight,
  remove,
  reverse,
  separate,
  sort,
  span,
  splitAt,
  tailNonEmpty,
  unfold,
  union,
  unsafeGet,
  unzip,
  zip,
  zipWith
} from "./chunk-ZFGDRCSG.js";
import "./chunk-5OEZIP3U.js";
import {
  Number_exports,
  Order,
  nextPow2
} from "./chunk-ODPGYV6G.js";
import {
  Either_exports,
  Record_exports,
  all,
  fromOption,
  getOrThrowWith,
  isEither,
  isLeft,
  isRight,
  left,
  map,
  match,
  merge,
  right
} from "./chunk-PWOXME4P.js";
import {
  Option_exports,
  all as all2,
  contains,
  flatMap,
  fromNullable,
  getOrElse,
  getOrThrow,
  getOrThrowWith as getOrThrowWith2,
  getOrUndefined,
  getRight2 as getRight,
  isNone,
  isSome,
  liftPredicate,
  liftThrowable,
  map as map2,
  match as match2,
  none as none2,
  orElse,
  orElseSome,
  some as some2
} from "./chunk-GMICS55Q.js";
import {
  Base,
  ChannelTypeId,
  CommitPrototype,
  EffectPrototype,
  EffectTypeId,
  Equal_exports,
  Equivalence_exports,
  GlobalValue_exports,
  Hash_exports,
  Inspectable_exports,
  NodeInspectSymbol,
  OP_ASYNC,
  OP_COMMIT,
  OP_FAILURE,
  OP_ON_FAILURE,
  OP_ON_SUCCESS,
  OP_ON_SUCCESS_AND_FAILURE,
  OP_REVERT_FLAGS,
  OP_SUCCESS,
  OP_SYNC,
  OP_TAG,
  OP_UPDATE_RUNTIME_FLAGS,
  OP_WHILE,
  OP_WITH_RUNTIME,
  OP_YIELD,
  Order_exports,
  PCGRandom,
  Pipeable_exports,
  SinkTypeId,
  StreamTypeId,
  StructuralBase,
  StructuralCommitPrototype,
  StructuralPrototype,
  Utils_exports,
  array,
  array2,
  between,
  bigint,
  bigint2,
  boolean,
  boolean2,
  cached,
  clamp,
  combine,
  effectVariance,
  equals,
  format,
  getCurrentVersion,
  globalValue,
  greaterThan,
  greaterThanOrEqualTo,
  hash,
  isEqual,
  lessThan,
  lessThanOrEqualTo,
  make,
  make2,
  mapInput,
  mapInput2,
  max,
  min,
  none,
  number,
  number2,
  number3,
  pipeArguments,
  random,
  setCurrentVersion,
  some,
  string2 as string,
  stringifyCircular,
  struct,
  struct2,
  structure,
  symbol,
  symbol2,
  symbol3,
  toJSON,
  toStringUnknown,
  tuple2 as tuple
} from "./chunk-PMMD7ZWW.js";
import {
  Function_exports,
  Predicate_exports,
  absurd,
  constFalse,
  constTrue,
  constUndefined,
  constVoid,
  constant,
  dual,
  flow,
  hasProperty,
  hole,
  identity,
  isBigInt,
  isBoolean,
  isDate,
  isFunction2 as isFunction,
  isIterable,
  isNull,
  isNumber,
  isObject,
  isPromiseLike,
  isRecord,
  isString,
  isSymbol,
  isTagged,
  isUndefined,
  pipe,
  unsafeCoerce
} from "./chunk-KURLOJT7.js";
import {
  __export,
  __publicField
} from "./chunk-2LSFTFF7.js";

// ../node_modules/effect/dist/esm/BigDecimal.js
var BigDecimal_exports = {};
__export(BigDecimal_exports, {
  Equivalence: () => Equivalence,
  Order: () => Order2,
  TypeId: () => TypeId,
  abs: () => abs,
  between: () => between2,
  clamp: () => clamp2,
  divide: () => divide,
  equals: () => equals2,
  format: () => format2,
  fromBigInt: () => fromBigInt,
  fromNumber: () => fromNumber,
  fromString: () => fromString,
  greaterThan: () => greaterThan2,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo2,
  isBigDecimal: () => isBigDecimal,
  isInteger: () => isInteger,
  isNegative: () => isNegative,
  isPositive: () => isPositive,
  isZero: () => isZero,
  lessThan: () => lessThan2,
  lessThanOrEqualTo: () => lessThanOrEqualTo2,
  make: () => make5,
  max: () => max2,
  min: () => min2,
  multiply: () => multiply,
  negate: () => negate,
  normalize: () => normalize,
  remainder: () => remainder,
  roundTerminal: () => roundTerminal,
  scale: () => scale,
  sign: () => sign,
  subtract: () => subtract,
  sum: () => sum,
  unsafeDivide: () => unsafeDivide,
  unsafeFromString: () => unsafeFromString,
  unsafeMakeNormalized: () => unsafeMakeNormalized,
  unsafeRemainder: () => unsafeRemainder,
  unsafeToNumber: () => unsafeToNumber
});
var DEFAULT_PRECISION = 100;
var TypeId = Symbol.for("effect/BigDecimal");
var BigDecimalProto = {
  [TypeId]: TypeId,
  [symbol2]() {
    const normalized = normalize(this);
    return pipe(hash(normalized.value), combine(number2(normalized.scale)), cached(this));
  },
  [symbol3](that) {
    return isBigDecimal(that) && equals2(this, that);
  },
  toString() {
    return `BigDecimal(${format2(this)})`;
  },
  toJSON() {
    return {
      _id: "BigDecimal",
      value: String(this.value),
      scale: this.scale
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isBigDecimal = (u) => hasProperty(u, TypeId);
var make5 = (value8, scale2) => {
  const o = Object.create(BigDecimalProto);
  o.value = value8;
  o.scale = scale2;
  return o;
};
var unsafeMakeNormalized = (value8, scale2) => {
  if (value8 !== bigint0 && value8 % bigint10 === bigint0) {
    throw new RangeError("Value must be normalized");
  }
  const o = make5(value8, scale2);
  o.normalized = o;
  return o;
};
var bigint0 = BigInt(0);
var bigint1 = BigInt(1);
var bigint10 = BigInt(10);
var zero = unsafeMakeNormalized(bigint0, 0);
var normalize = (self) => {
  if (self.normalized === void 0) {
    if (self.value === bigint0) {
      self.normalized = zero;
    } else {
      const digits = `${self.value}`;
      let trail = 0;
      for (let i = digits.length - 1; i >= 0; i--) {
        if (digits[i] === "0") {
          trail++;
        } else {
          break;
        }
      }
      if (trail === 0) {
        self.normalized = self;
      }
      const value8 = BigInt(digits.substring(0, digits.length - trail));
      const scale2 = self.scale - trail;
      self.normalized = unsafeMakeNormalized(value8, scale2);
    }
  }
  return self.normalized;
};
var scale = (self, scale2) => {
  if (scale2 > self.scale) {
    return make5(self.value * bigint10 ** BigInt(scale2 - self.scale), scale2);
  }
  if (scale2 < self.scale) {
    return make5(self.value / bigint10 ** BigInt(self.scale - scale2), scale2);
  }
  return self;
};
var sum = dual(2, (self, that) => {
  if (that.value === bigint0) {
    return self;
  }
  if (self.value === bigint0) {
    return that;
  }
  if (self.scale > that.scale) {
    return make5(scale(that, self.scale).value + self.value, self.scale);
  }
  if (self.scale < that.scale) {
    return make5(scale(self, that.scale).value + that.value, that.scale);
  }
  return make5(self.value + that.value, self.scale);
});
var multiply = dual(2, (self, that) => {
  if (that.value === bigint0 || self.value === bigint0) {
    return zero;
  }
  return make5(self.value * that.value, self.scale + that.scale);
});
var subtract = dual(2, (self, that) => {
  if (that.value === bigint0) {
    return self;
  }
  if (self.value === bigint0) {
    return make5(-that.value, that.scale);
  }
  if (self.scale > that.scale) {
    return make5(self.value - scale(that, self.scale).value, self.scale);
  }
  if (self.scale < that.scale) {
    return make5(scale(self, that.scale).value - that.value, that.scale);
  }
  return make5(self.value - that.value, self.scale);
});
var divideWithPrecision = (num, den, scale2, precision) => {
  const numNegative = num < bigint0;
  const denNegative = den < bigint0;
  const negateResult = numNegative !== denNegative;
  num = numNegative ? -num : num;
  den = denNegative ? -den : den;
  while (num < den) {
    num *= bigint10;
    scale2++;
  }
  let quotient = num / den;
  let remainder2 = num % den;
  if (remainder2 === bigint0) {
    return make5(negateResult ? -quotient : quotient, scale2);
  }
  let count9 = `${quotient}`.length;
  remainder2 *= bigint10;
  while (remainder2 !== bigint0 && count9 < precision) {
    const q = remainder2 / den;
    const r = remainder2 % den;
    quotient = quotient * bigint10 + q;
    remainder2 = r * bigint10;
    count9++;
    scale2++;
  }
  if (remainder2 !== bigint0) {
    quotient += roundTerminal(remainder2 / den);
  }
  return make5(negateResult ? -quotient : quotient, scale2);
};
var roundTerminal = (n) => {
  const pos = n >= bigint0 ? 0 : 1;
  return Number(`${n}`[pos]) < 5 ? bigint0 : bigint1;
};
var divide = dual(2, (self, that) => {
  if (that.value === bigint0) {
    return none2();
  }
  if (self.value === bigint0) {
    return some2(zero);
  }
  const scale2 = self.scale - that.scale;
  if (self.value === that.value) {
    return some2(make5(bigint1, scale2));
  }
  return some2(divideWithPrecision(self.value, that.value, scale2, DEFAULT_PRECISION));
});
var unsafeDivide = dual(2, (self, that) => {
  if (that.value === bigint0) {
    throw new RangeError("Division by zero");
  }
  if (self.value === bigint0) {
    return zero;
  }
  const scale2 = self.scale - that.scale;
  if (self.value === that.value) {
    return make5(bigint1, scale2);
  }
  return divideWithPrecision(self.value, that.value, scale2, DEFAULT_PRECISION);
});
var Order2 = make2((self, that) => {
  const scmp = number3(sign(self), sign(that));
  if (scmp !== 0) {
    return scmp;
  }
  if (self.scale > that.scale) {
    return bigint2(self.value, scale(that, self.scale).value);
  }
  if (self.scale < that.scale) {
    return bigint2(scale(self, that.scale).value, that.value);
  }
  return bigint2(self.value, that.value);
});
var lessThan2 = lessThan(Order2);
var lessThanOrEqualTo2 = lessThanOrEqualTo(Order2);
var greaterThan2 = greaterThan(Order2);
var greaterThanOrEqualTo2 = greaterThanOrEqualTo(Order2);
var between2 = between(Order2);
var clamp2 = clamp(Order2);
var min2 = min(Order2);
var max2 = max(Order2);
var sign = (n) => n.value === bigint0 ? 0 : n.value < bigint0 ? -1 : 1;
var abs = (n) => n.value < bigint0 ? make5(-n.value, n.scale) : n;
var negate = (n) => make5(-n.value, n.scale);
var remainder = dual(2, (self, divisor) => {
  if (divisor.value === bigint0) {
    return none2();
  }
  const max9 = Math.max(self.scale, divisor.scale);
  return some2(make5(scale(self, max9).value % scale(divisor, max9).value, max9));
});
var unsafeRemainder = dual(2, (self, divisor) => {
  if (divisor.value === bigint0) {
    throw new RangeError("Division by zero");
  }
  const max9 = Math.max(self.scale, divisor.scale);
  return make5(scale(self, max9).value % scale(divisor, max9).value, max9);
});
var Equivalence = make((self, that) => {
  if (self.scale > that.scale) {
    return scale(that, self.scale).value === self.value;
  }
  if (self.scale < that.scale) {
    return scale(self, that.scale).value === that.value;
  }
  return self.value === that.value;
});
var equals2 = dual(2, (self, that) => Equivalence(self, that));
var fromBigInt = (n) => make5(n, 0);
var fromNumber = (n) => {
  const [lead, trail = ""] = `${n}`.split(".");
  return make5(BigInt(`${lead}${trail}`), trail.length);
};
var fromString = (s) => {
  let digits;
  let scale2;
  const dot = s.search(/\./);
  if (dot !== -1) {
    const lead = s.slice(0, dot);
    const trail = s.slice(dot + 1);
    digits = `${lead}${trail}`;
    scale2 = trail.length;
  } else {
    digits = s;
    scale2 = 0;
  }
  if (digits === "") {
    return some2(zero);
  }
  if (!/^(?:\+|-)?\d+$/.test(digits)) {
    return none2();
  }
  return some2(make5(BigInt(digits), scale2));
};
var unsafeFromString = (s) => getOrThrowWith2(fromString(s), () => new Error("Invalid numerical string"));
var format2 = (n) => {
  const negative = n.value < bigint0;
  const absolute = negative ? `${n.value}`.substring(1) : `${n.value}`;
  let before3;
  let after3;
  if (n.scale >= absolute.length) {
    before3 = "0";
    after3 = "0".repeat(n.scale - absolute.length) + absolute;
  } else {
    const location = absolute.length - n.scale;
    if (location > absolute.length) {
      const zeros = location - absolute.length;
      before3 = `${absolute}${"0".repeat(zeros)}`;
      after3 = "";
    } else {
      after3 = absolute.slice(location);
      before3 = absolute.slice(0, location);
    }
  }
  const complete6 = after3 === "" ? before3 : `${before3}.${after3}`;
  return negative ? `-${complete6}` : complete6;
};
var unsafeToNumber = (n) => Number(format2(n));
var isInteger = (n) => normalize(n).scale <= 0;
var isZero = (n) => n.value === bigint0;
var isNegative = (n) => n.value < bigint0;
var isPositive = (n) => n.value > bigint0;

// ../node_modules/effect/dist/esm/BigInt.js
var BigInt_exports = {};
__export(BigInt_exports, {
  Equivalence: () => Equivalence2,
  Order: () => Order3,
  abs: () => abs2,
  between: () => between3,
  clamp: () => clamp3,
  decrement: () => decrement,
  divide: () => divide2,
  fromNumber: () => fromNumber2,
  fromString: () => fromString2,
  gcd: () => gcd,
  greaterThan: () => greaterThan3,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo3,
  increment: () => increment,
  isBigInt: () => isBigInt2,
  lcm: () => lcm,
  lessThan: () => lessThan3,
  lessThanOrEqualTo: () => lessThanOrEqualTo3,
  max: () => max3,
  min: () => min3,
  multiply: () => multiply2,
  multiplyAll: () => multiplyAll,
  sign: () => sign2,
  sqrt: () => sqrt,
  subtract: () => subtract2,
  sum: () => sum2,
  sumAll: () => sumAll,
  toNumber: () => toNumber,
  unsafeDivide: () => unsafeDivide2,
  unsafeSqrt: () => unsafeSqrt
});
var bigint02 = BigInt(0);
var bigint12 = BigInt(1);
var bigint22 = BigInt(2);
var isBigInt2 = isBigInt;
var sum2 = dual(2, (self, that) => self + that);
var multiply2 = dual(2, (self, that) => self * that);
var subtract2 = dual(2, (self, that) => self - that);
var divide2 = dual(2, (self, that) => that === bigint02 ? none2() : some2(self / that));
var unsafeDivide2 = dual(2, (self, that) => self / that);
var increment = (n) => n + bigint12;
var decrement = (n) => n - bigint12;
var Equivalence2 = bigint;
var Order3 = bigint2;
var lessThan3 = lessThan(Order3);
var lessThanOrEqualTo3 = lessThanOrEqualTo(Order3);
var greaterThan3 = greaterThan(Order3);
var greaterThanOrEqualTo3 = greaterThanOrEqualTo(Order3);
var between3 = between(Order3);
var clamp3 = clamp(Order3);
var min3 = min(Order3);
var max3 = max(Order3);
var sign2 = (n) => Order3(n, bigint02);
var abs2 = (n) => n < bigint02 ? -n : n;
var gcd = dual(2, (self, that) => {
  while (that !== bigint02) {
    const t = that;
    that = self % that;
    self = t;
  }
  return self;
});
var lcm = dual(2, (self, that) => self * that / gcd(self, that));
var unsafeSqrt = (n) => {
  if (n < bigint02) {
    throw new RangeError("Cannot take the square root of a negative number");
  }
  if (n < bigint22) {
    return n;
  }
  let x = n / bigint22;
  while (x * x > n) {
    x = (n / x + x) / bigint22;
  }
  return x;
};
var sqrt = (n) => greaterThanOrEqualTo3(n, bigint02) ? some2(unsafeSqrt(n)) : none2();
var sumAll = (collection) => {
  let out = bigint02;
  for (const n of collection) {
    out += n;
  }
  return out;
};
var multiplyAll = (collection) => {
  let out = bigint12;
  for (const n of collection) {
    if (n === bigint02) {
      return bigint02;
    }
    out *= n;
  }
  return out;
};
var toNumber = (b) => {
  if (b > BigInt(Number.MAX_SAFE_INTEGER) || b < BigInt(Number.MIN_SAFE_INTEGER)) {
    return none2();
  }
  return some2(Number(b));
};
var fromString2 = (s) => {
  try {
    return s.trim() === "" ? none2() : some2(BigInt(s));
  } catch (_) {
    return none2();
  }
};
var fromNumber2 = (n) => {
  if (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER) {
    return none2();
  }
  try {
    return some2(BigInt(n));
  } catch (_) {
    return none2();
  }
};

// ../node_modules/effect/dist/esm/Boolean.js
var Boolean_exports = {};
__export(Boolean_exports, {
  Equivalence: () => Equivalence3,
  Order: () => Order4,
  and: () => and,
  eqv: () => eqv,
  every: () => every2,
  implies: () => implies,
  isBoolean: () => isBoolean2,
  match: () => match4,
  nand: () => nand,
  nor: () => nor,
  not: () => not,
  or: () => or,
  some: () => some3,
  xor: () => xor
});
var isBoolean2 = isBoolean;
var match4 = dual(2, (value8, options) => value8 ? options.onTrue() : options.onFalse());
var Equivalence3 = boolean;
var Order4 = boolean2;
var not = (self) => !self;
var and = dual(2, (self, that) => self && that);
var nand = dual(2, (self, that) => !(self && that));
var or = dual(2, (self, that) => self || that);
var nor = dual(2, (self, that) => !(self || that));
var xor = dual(2, (self, that) => !self && that || self && !that);
var eqv = dual(2, (self, that) => !xor(self, that));
var implies = dual(2, (self, that) => self ? that : true);
var every2 = (collection) => {
  for (const b of collection) {
    if (!b) {
      return false;
    }
  }
  return true;
};
var some3 = (collection) => {
  for (const b of collection) {
    if (b) {
      return true;
    }
  }
  return false;
};

// ../node_modules/effect/dist/esm/Brand.js
var Brand_exports = {};
__export(Brand_exports, {
  BrandTypeId: () => BrandTypeId,
  RefinedConstructorsTypeId: () => RefinedConstructorsTypeId,
  all: () => all3,
  error: () => error,
  errors: () => errors,
  nominal: () => nominal,
  refined: () => refined
});
var BrandTypeId = Symbol.for("effect/Brand");
var RefinedConstructorsTypeId = Symbol.for("effect/Brand/Refined");
var error = (message, meta) => [{
  message,
  meta
}];
var errors = (...errors2) => flatten(errors2);
function refined(...args) {
  const either13 = args.length === 2 ? (unbranded) => args[0](unbranded) ? right(unbranded) : left(args[1](unbranded)) : (unbranded) => {
    return match2(args[0](unbranded), {
      onNone: () => right(unbranded),
      onSome: left
    });
  };
  return Object.assign((unbranded) => getOrThrowWith(either13(unbranded), identity), {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: (args2) => getRight(either13(args2)),
    either: either13,
    is: (args2) => isRight(either13(args2))
  });
}
var nominal = () => {
  return Object.assign((args) => args, {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: (args) => some2(args),
    either: (args) => right(args),
    is: (_args) => true
  });
};
var all3 = (...brands) => {
  const either13 = (args) => {
    let result = right(args);
    for (const brand of brands) {
      const nextResult = brand.either(args);
      if (isLeft(result) && isLeft(nextResult)) {
        result = left([...result.left, ...nextResult.left]);
      } else {
        result = isLeft(result) ? result : nextResult;
      }
    }
    return result;
  };
  return Object.assign((args) => match(either13(args), {
    onLeft: (e) => {
      throw e;
    },
    onRight: identity
  }), {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: (args) => getRight(either13(args)),
    either: either13,
    is: (args) => isRight(either13(args))
  });
};

// ../node_modules/effect/dist/esm/Cache.js
var Cache_exports = {};
__export(Cache_exports, {
  CacheTypeId: () => CacheTypeId2,
  make: () => make49,
  makeCacheStats: () => makeCacheStats2,
  makeEntryStats: () => makeEntryStats2,
  makeWith: () => makeWith2
});

// ../node_modules/effect/dist/esm/Context.js
var Context_exports = {};
__export(Context_exports, {
  GenericTag: () => GenericTag,
  Tag: () => Tag2,
  add: () => add2,
  empty: () => empty4,
  get: () => get2,
  getOption: () => getOption2,
  isContext: () => isContext2,
  isTag: () => isTag2,
  make: () => make7,
  merge: () => merge3,
  omit: () => omit2,
  pick: () => pick2,
  unsafeGet: () => unsafeGet3,
  unsafeMake: () => unsafeMake
});

// ../node_modules/effect/dist/esm/internal/context.js
var TagTypeId = Symbol.for("effect/Context/Tag");
var STMSymbolKey = "effect/STM";
var STMTypeId = Symbol.for(STMSymbolKey);
var TagProto = {
  ...EffectPrototype,
  _tag: "Tag",
  _op: "Tag",
  [STMTypeId]: effectVariance,
  [TagTypeId]: {
    _Service: (_) => _,
    _Identifier: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Tag",
      key: this.key,
      stack: this.stack
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  of(self) {
    return self;
  },
  context(self) {
    return make6(this, self);
  }
};
var makeGenericTag = (key) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  const tag4 = Object.create(TagProto);
  Object.defineProperty(tag4, "stack", {
    get() {
      return creationError.stack;
    }
  });
  tag4.key = key;
  return tag4;
};
var Tag = (id3) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function TagClass() {
  }
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id3;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return TagClass;
};
var TypeId2 = Symbol.for("effect/Context");
var ContextProto = {
  [TypeId2]: {
    _Services: (_) => _
  },
  [symbol3](that) {
    if (isContext(that)) {
      if (this.unsafeMap.size === that.unsafeMap.size) {
        for (const k of this.unsafeMap.keys()) {
          if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  },
  [symbol2]() {
    return cached(this, number2(this.unsafeMap.size));
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Context",
      services: Array.from(this.unsafeMap).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var makeContext = (unsafeMap) => {
  const context13 = Object.create(ContextProto);
  context13.unsafeMap = unsafeMap;
  return context13;
};
var serviceNotFoundError = (tag4) => {
  const error4 = new Error(`Service not found${tag4.key ? `: ${String(tag4.key)}` : ""}`);
  if (tag4.stack) {
    const lines = tag4.stack.split("\n");
    if (lines.length > 2) {
      const afterAt = lines[2].match(/at (.*)/);
      if (afterAt) {
        error4.message = error4.message + ` (defined at ${afterAt[1]})`;
      }
    }
  }
  if (error4.stack) {
    const lines = error4.stack.split("\n");
    lines.splice(1, 3);
    error4.stack = lines.join("\n");
  }
  return error4;
};
var isContext = (u) => hasProperty(u, TypeId2);
var isTag = (u) => hasProperty(u, TagTypeId);
var _empty = makeContext(/* @__PURE__ */ new Map());
var empty3 = () => _empty;
var make6 = (tag4, service3) => makeContext(/* @__PURE__ */ new Map([[tag4.key, service3]]));
var add = dual(3, (self, tag4, service3) => {
  const map43 = new Map(self.unsafeMap);
  map43.set(tag4.key, service3);
  return makeContext(map43);
});
var unsafeGet2 = dual(2, (self, tag4) => {
  if (!self.unsafeMap.has(tag4.key)) {
    throw serviceNotFoundError(tag4);
  }
  return self.unsafeMap.get(tag4.key);
});
var get = unsafeGet2;
var getOption = dual(2, (self, tag4) => {
  if (!self.unsafeMap.has(tag4.key)) {
    return none;
  }
  return some(self.unsafeMap.get(tag4.key));
});
var merge2 = dual(2, (self, that) => {
  const map43 = new Map(self.unsafeMap);
  for (const [tag4, s] of that.unsafeMap) {
    map43.set(tag4, s);
  }
  return makeContext(map43);
});
var pick = (...tags3) => (self) => {
  const tagSet = new Set(tags3.map((_) => _.key));
  const newEnv = /* @__PURE__ */ new Map();
  for (const [tag4, s] of self.unsafeMap.entries()) {
    if (tagSet.has(tag4)) {
      newEnv.set(tag4, s);
    }
  }
  return makeContext(newEnv);
};
var omit = (...tags3) => (self) => {
  const newEnv = new Map(self.unsafeMap);
  for (const tag4 of tags3) {
    newEnv.delete(tag4.key);
  }
  return makeContext(newEnv);
};

// ../node_modules/effect/dist/esm/Context.js
var GenericTag = makeGenericTag;
var unsafeMake = makeContext;
var isContext2 = isContext;
var isTag2 = isTag;
var empty4 = empty3;
var make7 = make6;
var add2 = add;
var get2 = get;
var unsafeGet3 = unsafeGet2;
var getOption2 = getOption;
var merge3 = merge2;
var pick2 = pick;
var omit2 = omit;
var Tag2 = Tag;

// ../node_modules/effect/dist/esm/Deferred.js
var Deferred_exports = {};
__export(Deferred_exports, {
  DeferredTypeId: () => DeferredTypeId2,
  await: () => _await,
  complete: () => complete,
  completeWith: () => completeWith,
  die: () => die3,
  dieSync: () => dieSync2,
  done: () => done2,
  fail: () => fail3,
  failCause: () => failCause2,
  failCauseSync: () => failCauseSync2,
  failSync: () => failSync2,
  interrupt: () => interrupt3,
  interruptWith: () => interruptWith2,
  isDone: () => isDone,
  make: () => make23,
  makeAs: () => makeAs,
  poll: () => poll,
  succeed: () => succeed2,
  sync: () => sync2,
  unsafeDone: () => unsafeDone,
  unsafeMake: () => unsafeMake4
});

// ../node_modules/effect/dist/esm/Chunk.js
var Chunk_exports = {};
__export(Chunk_exports, {
  append: () => append2,
  appendAll: () => appendAll2,
  chunksOf: () => chunksOf,
  compact: () => compact,
  contains: () => contains3,
  containsWith: () => containsWith2,
  dedupe: () => dedupe2,
  dedupeAdjacent: () => dedupeAdjacent2,
  drop: () => drop2,
  dropRight: () => dropRight,
  dropWhile: () => dropWhile,
  empty: () => empty5,
  every: () => every3,
  filter: () => filter2,
  filterMap: () => filterMap2,
  filterMapWhile: () => filterMapWhile2,
  findFirst: () => findFirst2,
  findFirstIndex: () => findFirstIndex2,
  findLast: () => findLast2,
  findLastIndex: () => findLastIndex2,
  flatMap: () => flatMap3,
  flatten: () => flatten2,
  forEach: () => forEach,
  fromIterable: () => fromIterable2,
  get: () => get3,
  getEquivalence: () => getEquivalence2,
  head: () => head2,
  headNonEmpty: () => headNonEmpty2,
  intersection: () => intersection2,
  isChunk: () => isChunk,
  isEmpty: () => isEmpty,
  isNonEmpty: () => isNonEmpty2,
  join: () => join2,
  last: () => last2,
  make: () => make8,
  makeBy: () => makeBy2,
  map: () => map4,
  mapAccum: () => mapAccum2,
  modify: () => modify,
  modifyOption: () => modifyOption2,
  of: () => of2,
  partition: () => partition2,
  partitionMap: () => partitionMap2,
  prepend: () => prepend2,
  prependAll: () => prependAll,
  range: () => range,
  reduce: () => reduce2,
  reduceRight: () => reduceRight2,
  remove: () => remove2,
  replace: () => replace,
  replaceOption: () => replaceOption,
  reverse: () => reverse2,
  separate: () => separate2,
  size: () => size,
  some: () => some4,
  sort: () => sort2,
  sortWith: () => sortWith,
  split: () => split,
  splitAt: () => splitAt2,
  splitNonEmptyAt: () => splitNonEmptyAt,
  splitWhere: () => splitWhere,
  tail: () => tail,
  tailNonEmpty: () => tailNonEmpty2,
  take: () => take,
  takeRight: () => takeRight,
  takeWhile: () => takeWhile,
  toArray: () => toArray,
  toReadonlyArray: () => toReadonlyArray,
  union: () => union2,
  unsafeFromArray: () => unsafeFromArray,
  unsafeFromNonEmptyArray: () => unsafeFromNonEmptyArray,
  unsafeGet: () => unsafeGet4,
  unsafeHead: () => unsafeHead,
  unsafeLast: () => unsafeLast,
  unzip: () => unzip2,
  zip: () => zip2,
  zipWith: () => zipWith2
});
var TypeId3 = Symbol.for("effect/Chunk");
function copy(src, srcPos, dest, destPos, len) {
  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src[i];
  }
  return dest;
}
var emptyArray = [];
var getEquivalence2 = (isEquivalent) => make((self, that) => self.length === that.length && toReadonlyArray(self).every((value8, i) => isEquivalent(value8, unsafeGet4(that, i))));
var _equivalence = getEquivalence2(equals);
var ChunkProto = {
  [TypeId3]: {
    _A: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Chunk",
      values: toReadonlyArray(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol3](that) {
    return isChunk(that) && _equivalence(this, that);
  },
  [symbol2]() {
    return cached(this, array2(toReadonlyArray(this)));
  },
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray": {
        return this.backing.array[Symbol.iterator]();
      }
      case "IEmpty": {
        return emptyArray[Symbol.iterator]();
      }
      default: {
        return toReadonlyArray(this)[Symbol.iterator]();
      }
    }
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeChunk = (backing) => {
  const chunk7 = Object.create(ChunkProto);
  chunk7.backing = backing;
  switch (backing._tag) {
    case "IEmpty": {
      chunk7.length = 0;
      chunk7.depth = 0;
      chunk7.left = chunk7;
      chunk7.right = chunk7;
      break;
    }
    case "IConcat": {
      chunk7.length = backing.left.length + backing.right.length;
      chunk7.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
      chunk7.left = backing.left;
      chunk7.right = backing.right;
      break;
    }
    case "IArray": {
      chunk7.length = backing.array.length;
      chunk7.depth = 0;
      chunk7.left = _empty2;
      chunk7.right = _empty2;
      break;
    }
    case "ISingleton": {
      chunk7.length = 1;
      chunk7.depth = 0;
      chunk7.left = _empty2;
      chunk7.right = _empty2;
      break;
    }
    case "ISlice": {
      chunk7.length = backing.length;
      chunk7.depth = backing.chunk.depth + 1;
      chunk7.left = _empty2;
      chunk7.right = _empty2;
      break;
    }
  }
  return chunk7;
};
var isChunk = (u) => hasProperty(u, TypeId3);
var _empty2 = makeChunk({
  _tag: "IEmpty"
});
var empty5 = () => _empty2;
var make8 = (...as16) => as16.length === 1 ? of2(as16[0]) : unsafeFromNonEmptyArray(as16);
var of2 = (a) => makeChunk({
  _tag: "ISingleton",
  a
});
var fromIterable2 = (self) => isChunk(self) ? self : makeChunk({
  _tag: "IArray",
  array: fromIterable(self)
});
var copyToArray = (self, array6, initial) => {
  switch (self.backing._tag) {
    case "IArray": {
      copy(self.backing.array, 0, array6, initial, self.length);
      break;
    }
    case "IConcat": {
      copyToArray(self.left, array6, initial);
      copyToArray(self.right, array6, initial + self.left.length);
      break;
    }
    case "ISingleton": {
      array6[initial] = self.backing.a;
      break;
    }
    case "ISlice": {
      let i = 0;
      let j = initial;
      while (i < self.length) {
        array6[j] = unsafeGet4(self, i);
        i += 1;
        j += 1;
      }
      break;
    }
  }
};
var toArray = (self) => toReadonlyArray(self).slice();
var toReadonlyArray = (self) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      return emptyArray;
    }
    case "IArray": {
      return self.backing.array;
    }
    default: {
      const arr = new Array(self.length);
      copyToArray(self, arr, 0);
      self.backing = {
        _tag: "IArray",
        array: arr
      };
      self.left = _empty2;
      self.right = _empty2;
      self.depth = 0;
      return arr;
    }
  }
};
var reverse2 = (self) => {
  switch (self.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self;
    case "IArray": {
      return makeChunk({
        _tag: "IArray",
        array: reverse(self.backing.array)
      });
    }
    case "IConcat": {
      return makeChunk({
        _tag: "IConcat",
        left: reverse2(self.backing.right),
        right: reverse2(self.backing.left)
      });
    }
    case "ISlice":
      return unsafeFromArray(reverse(toReadonlyArray(self)));
  }
};
var get3 = dual(2, (self, index) => index < 0 || index >= self.length ? none2() : some2(unsafeGet4(self, index)));
var unsafeFromArray = (self) => makeChunk({
  _tag: "IArray",
  array: self
});
var unsafeFromNonEmptyArray = (self) => unsafeFromArray(self);
var unsafeGet4 = dual(2, (self, index) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      throw new Error(`Index out of bounds`);
    }
    case "ISingleton": {
      if (index !== 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.a;
    }
    case "IArray": {
      if (index >= self.length || index < 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.array[index];
    }
    case "IConcat": {
      return index < self.left.length ? unsafeGet4(self.left, index) : unsafeGet4(self.right, index - self.left.length);
    }
    case "ISlice": {
      return unsafeGet4(self.backing.chunk, index + self.backing.offset);
    }
  }
});
var append2 = dual(2, (self, a) => appendAll2(self, of2(a)));
var prepend2 = dual(2, (self, elem) => appendAll2(of2(elem), self));
var take = dual(2, (self, n) => {
  if (n <= 0) {
    return _empty2;
  } else if (n >= self.length) {
    return self;
  } else {
    switch (self.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self.backing.chunk,
          length: n,
          offset: self.backing.offset
        });
      }
      case "IConcat": {
        if (n > self.left.length) {
          return makeChunk({
            _tag: "IConcat",
            left: self.left,
            right: take(self.right, n - self.left.length)
          });
        }
        return take(self.left, n);
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self,
          offset: 0,
          length: n
        });
      }
    }
  }
});
var drop2 = dual(2, (self, n) => {
  if (n <= 0) {
    return self;
  } else if (n >= self.length) {
    return _empty2;
  } else {
    switch (self.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self.backing.chunk,
          offset: self.backing.offset + n,
          length: self.backing.length - n
        });
      }
      case "IConcat": {
        if (n > self.left.length) {
          return drop2(self.right, n - self.left.length);
        }
        return makeChunk({
          _tag: "IConcat",
          left: drop2(self.left, n),
          right: self.right
        });
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self,
          offset: n,
          length: self.length - n
        });
      }
    }
  }
});
var dropRight = dual(2, (self, n) => take(self, Math.max(0, self.length - n)));
var dropWhile = dual(2, (self, predicate) => {
  const arr = toReadonlyArray(self);
  const len = arr.length;
  let i = 0;
  while (i < len && predicate(arr[i])) {
    i++;
  }
  return drop2(self, i);
});
var prependAll = dual(2, (self, that) => appendAll2(that, self));
var appendAll2 = dual(2, (self, that) => {
  if (self.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self;
  }
  const diff13 = that.depth - self.depth;
  if (Math.abs(diff13) <= 1) {
    return makeChunk({
      _tag: "IConcat",
      left: self,
      right: that
    });
  } else if (diff13 < -1) {
    if (self.left.depth >= self.right.depth) {
      const nr = appendAll2(self.right, that);
      return makeChunk({
        _tag: "IConcat",
        left: self.left,
        right: nr
      });
    } else {
      const nrr = appendAll2(self.right.right, that);
      if (nrr.depth === self.depth - 3) {
        const nr = makeChunk({
          _tag: "IConcat",
          left: self.right.left,
          right: nrr
        });
        return makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: nr
        });
      } else {
        const nl = makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: self.right.left
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = appendAll2(self, that.left);
      return makeChunk({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = appendAll2(self, that.left.left);
      if (nll.depth === that.depth - 3) {
        const nl = makeChunk({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = makeChunk({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
var filterMap2 = dual(2, (self, f) => unsafeFromArray(filterMap(self, f)));
var filter2 = dual(2, (self, predicate) => unsafeFromArray(filterMap(self, liftPredicate(predicate))));
var filterMapWhile2 = dual(2, (self, f) => unsafeFromArray(filterMapWhile(self, f)));
var compact = (self) => filterMap2(self, identity);
var flatMap3 = dual(2, (self, f) => {
  if (self.backing._tag === "ISingleton") {
    return f(self.backing.a, 0);
  }
  let out = _empty2;
  let i = 0;
  for (const k of self) {
    out = appendAll2(out, f(k, i++));
  }
  return out;
});
var forEach = dual(2, (self, f) => toReadonlyArray(self).forEach(f));
var flatten2 = flatMap3(identity);
var chunksOf = dual(2, (self, n) => {
  const gr = [];
  let current2 = [];
  toReadonlyArray(self).forEach((a) => {
    current2.push(a);
    if (current2.length >= n) {
      gr.push(unsafeFromArray(current2));
      current2 = [];
    }
  });
  if (current2.length > 0) {
    gr.push(unsafeFromArray(current2));
  }
  return unsafeFromArray(gr);
});
var intersection2 = dual(2, (self, that) => unsafeFromArray(intersection(toReadonlyArray(self), toReadonlyArray(that))));
var isEmpty = (self) => self.length === 0;
var isNonEmpty2 = (self) => self.length > 0;
var head2 = get3(0);
var unsafeHead = (self) => unsafeGet4(self, 0);
var headNonEmpty2 = unsafeHead;
var last2 = (self) => get3(self, self.length - 1);
var unsafeLast = (self) => unsafeGet4(self, self.length - 1);
var map4 = dual(2, (self, f) => self.backing._tag === "ISingleton" ? of2(f(self.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self), map3((a, i) => f(a, i)))));
var mapAccum2 = dual(3, (self, s, f) => {
  const [s1, as16] = mapAccum(self, s, f);
  return [s1, unsafeFromArray(as16)];
});
var partition2 = dual(2, (self, predicate) => pipe(partition(toReadonlyArray(self), predicate), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));
var partitionMap2 = dual(2, (self, f) => pipe(partitionMap(toReadonlyArray(self), f), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));
var separate2 = (self) => pipe(separate(toReadonlyArray(self)), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]);
var size = (self) => self.length;
var sort2 = dual(2, (self, O) => unsafeFromArray(sort(toReadonlyArray(self), O)));
var sortWith = dual(3, (self, f, order) => sort2(self, mapInput2(order, f)));
var splitAt2 = dual(2, (self, n) => [take(self, n), drop2(self, n)]);
var splitNonEmptyAt = dual(2, (self, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self.length ? [self, empty5()] : [take(self, _n), drop2(self, _n)];
});
var split = dual(2, (self, n) => chunksOf(self, Math.ceil(self.length / Math.floor(n))));
var splitWhere = dual(2, (self, predicate) => {
  let i = 0;
  for (const a of toReadonlyArray(self)) {
    if (predicate(a)) {
      break;
    } else {
      i++;
    }
  }
  return splitAt2(self, i);
});
var tail = (self) => self.length > 0 ? some2(drop2(self, 1)) : none2();
var tailNonEmpty2 = (self) => drop2(self, 1);
var takeRight = dual(2, (self, n) => drop2(self, self.length - n));
var takeWhile = dual(2, (self, predicate) => {
  const out = [];
  for (const a of toReadonlyArray(self)) {
    if (predicate(a)) {
      out.push(a);
    } else {
      break;
    }
  }
  return unsafeFromArray(out);
});
var union2 = dual(2, (self, that) => unsafeFromArray(union(toReadonlyArray(self), toReadonlyArray(that))));
var dedupe2 = (self) => unsafeFromArray(dedupe(toReadonlyArray(self)));
var dedupeAdjacent2 = (self) => unsafeFromArray(dedupeAdjacent(self));
var unzip2 = (self) => {
  const [left2, right2] = unzip(self);
  return [unsafeFromArray(left2), unsafeFromArray(right2)];
};
var zipWith2 = dual(3, (self, that, f) => unsafeFromArray(zipWith(self, that, f)));
var zip2 = dual(2, (self, that) => zipWith2(self, that, (a, b) => [a, b]));
var remove2 = dual(2, (self, i) => unsafeFromArray(remove(toReadonlyArray(self), i)));
var modifyOption2 = dual(3, (self, i, f) => map2(modifyOption(toReadonlyArray(self), i, f), unsafeFromArray));
var modify = dual(3, (self, i, f) => getOrElse(modifyOption2(self, i, f), () => self));
var replace = dual(3, (self, i, b) => modify(self, i, () => b));
var replaceOption = dual(3, (self, i, b) => modifyOption2(self, i, () => b));
var makeBy2 = dual(2, (n, f) => fromIterable2(makeBy(n, f)));
var range = (start5, end7) => start5 <= end7 ? makeBy2(end7 - start5 + 1, (i) => start5 + i) : of2(start5);
var contains3 = contains2;
var containsWith2 = containsWith;
var findFirst2 = findFirst;
var findFirstIndex2 = findFirstIndex;
var findLast2 = findLast;
var findLastIndex2 = findLastIndex;
var every3 = dual(2, (self, refinement) => fromIterable(self).every(refinement));
var some4 = dual(2, (self, predicate) => fromIterable(self).some(predicate));
var join2 = join;
var reduce2 = reduce;
var reduceRight2 = reduceRight;

// ../node_modules/effect/dist/esm/FiberId.js
var FiberId_exports = {};
__export(FiberId_exports, {
  FiberIdTypeId: () => FiberIdTypeId2,
  combine: () => combine3,
  combineAll: () => combineAll2,
  composite: () => composite2,
  getOrElse: () => getOrElse3,
  ids: () => ids2,
  isComposite: () => isComposite2,
  isFiberId: () => isFiberId2,
  isNone: () => isNone3,
  isRuntime: () => isRuntime2,
  make: () => make15,
  none: () => none4,
  runtime: () => runtime2,
  threadName: () => threadName2,
  toOption: () => toOption2,
  toSet: () => toSet2,
  unsafeMake: () => unsafeMake3
});

// ../node_modules/effect/dist/esm/HashSet.js
var HashSet_exports = {};
__export(HashSet_exports, {
  add: () => add4,
  beginMutation: () => beginMutation3,
  difference: () => difference2,
  empty: () => empty8,
  endMutation: () => endMutation3,
  every: () => every5,
  filter: () => filter5,
  flatMap: () => flatMap6,
  forEach: () => forEach4,
  fromIterable: () => fromIterable5,
  has: () => has3,
  intersection: () => intersection4,
  isHashSet: () => isHashSet2,
  isSubset: () => isSubset2,
  make: () => make12,
  map: () => map7,
  mutate: () => mutate3,
  partition: () => partition4,
  reduce: () => reduce5,
  remove: () => remove5,
  size: () => size4,
  some: () => some6,
  toggle: () => toggle2,
  union: () => union5,
  values: () => values3
});

// ../node_modules/effect/dist/esm/internal/hashMap/config.js
var SIZE = 5;
var BUCKET_SIZE = Math.pow(2, SIZE);
var MASK = BUCKET_SIZE - 1;
var MAX_INDEX_NODE = BUCKET_SIZE / 2;
var MIN_ARRAY_NODE = BUCKET_SIZE / 4;

// ../node_modules/effect/dist/esm/internal/hashMap/bitwise.js
function popcount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function hashFragment(shift2, h) {
  return h >>> shift2 & MASK;
}
function toBitmap(x) {
  return 1 << x;
}
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
}

// ../node_modules/effect/dist/esm/internal/stack.js
var make9 = (value8, previous2) => ({
  value: value8,
  previous: previous2
});

// ../node_modules/effect/dist/esm/internal/hashMap/array.js
function arrayUpdate(mutate5, at3, v, arr) {
  let out = arr;
  if (!mutate5) {
    const len = arr.length;
    out = new Array(len);
    for (let i = 0; i < len; ++i)
      out[i] = arr[i];
  }
  out[at3] = v;
  return out;
}
function arraySpliceOut(mutate5, at3, arr) {
  const newLen = arr.length - 1;
  let i = 0;
  let g = 0;
  let out = arr;
  if (mutate5) {
    i = g = at3;
  } else {
    out = new Array(newLen);
    while (i < at3)
      out[g++] = arr[i++];
  }
  ;
  ++i;
  while (i <= newLen)
    out[g++] = arr[i++];
  if (mutate5) {
    out.length = newLen;
  }
  return out;
}
function arraySpliceIn(mutate5, at3, v, arr) {
  const len = arr.length;
  if (mutate5) {
    let i2 = len;
    while (i2 >= at3)
      arr[i2--] = arr[i2];
    arr[at3] = v;
    return arr;
  }
  let i = 0, g = 0;
  const out = new Array(len + 1);
  while (i < at3)
    out[g++] = arr[i++];
  out[at3] = v;
  while (i < len)
    out[++g] = arr[i++];
  return out;
}

// ../node_modules/effect/dist/esm/internal/hashMap/node.js
var EmptyNode = class _EmptyNode {
  constructor() {
    __publicField(this, "_tag", "EmptyNode");
  }
  modify(edit, _shift, f, hash3, key, size38) {
    const v = f(none2());
    if (isNone(v))
      return new _EmptyNode();
    ++size38.value;
    return new LeafNode(edit, hash3, key, v);
  }
};
function isEmptyNode(a) {
  return isTagged(a, "EmptyNode");
}
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}
var LeafNode = class _LeafNode {
  constructor(edit, hash3, key, value8) {
    __publicField(this, "edit");
    __publicField(this, "hash");
    __publicField(this, "key");
    __publicField(this, "value");
    __publicField(this, "_tag", "LeafNode");
    this.edit = edit;
    this.hash = hash3;
    this.key = key;
    this.value = value8;
  }
  modify(edit, shift2, f, hash3, key, size38) {
    if (equals(key, this.key)) {
      const v2 = f(this.value);
      if (v2 === this.value)
        return this;
      else if (isNone(v2)) {
        ;
        --size38.value;
        return new EmptyNode();
      }
      if (canEditNode(this, edit)) {
        this.value = v2;
        return this;
      }
      return new _LeafNode(edit, hash3, key, v2);
    }
    const v = f(none2());
    if (isNone(v))
      return this;
    ++size38.value;
    return mergeLeaves(edit, shift2, this.hash, this, hash3, new _LeafNode(edit, hash3, key, v));
  }
};
var CollisionNode = class _CollisionNode {
  constructor(edit, hash3, children3) {
    __publicField(this, "edit");
    __publicField(this, "hash");
    __publicField(this, "children");
    __publicField(this, "_tag", "CollisionNode");
    this.edit = edit;
    this.hash = hash3;
    this.children = children3;
  }
  modify(edit, shift2, f, hash3, key, size38) {
    if (hash3 === this.hash) {
      const canEdit = canEditNode(this, edit);
      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size38);
      if (list === this.children)
        return this;
      return list.length > 1 ? new _CollisionNode(edit, this.hash, list) : list[0];
    }
    const v = f(none2());
    if (isNone(v))
      return this;
    ++size38.value;
    return mergeLeaves(edit, shift2, this.hash, this, hash3, new LeafNode(edit, hash3, key, v));
  }
  updateCollisionList(mutate5, edit, hash3, list, f, key, size38) {
    const len = list.length;
    for (let i = 0; i < len; ++i) {
      const child = list[i];
      if ("key" in child && equals(key, child.key)) {
        const value8 = child.value;
        const newValue2 = f(value8);
        if (newValue2 === value8)
          return list;
        if (isNone(newValue2)) {
          ;
          --size38.value;
          return arraySpliceOut(mutate5, i, list);
        }
        return arrayUpdate(mutate5, i, new LeafNode(edit, hash3, key, newValue2), list);
      }
    }
    const newValue = f(none2());
    if (isNone(newValue))
      return list;
    ++size38.value;
    return arrayUpdate(mutate5, len, new LeafNode(edit, hash3, key, newValue), list);
  }
};
var IndexedNode = class _IndexedNode {
  constructor(edit, mask, children3) {
    __publicField(this, "edit");
    __publicField(this, "mask");
    __publicField(this, "children");
    __publicField(this, "_tag", "IndexedNode");
    this.edit = edit;
    this.mask = mask;
    this.children = children3;
  }
  modify(edit, shift2, f, hash3, key, size38) {
    const mask = this.mask;
    const children3 = this.children;
    const frag = hashFragment(shift2, hash3);
    const bit = toBitmap(frag);
    const indx = fromBitmap(mask, bit);
    const exists6 = mask & bit;
    const canEdit = canEditNode(this, edit);
    if (!exists6) {
      const _newChild = new EmptyNode().modify(edit, shift2 + SIZE, f, hash3, key, size38);
      if (!_newChild)
        return this;
      return children3.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children3) : new _IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children3));
    }
    const current2 = children3[indx];
    const child = current2.modify(edit, shift2 + SIZE, f, hash3, key, size38);
    if (current2 === child)
      return this;
    let bitmap = mask;
    let newChildren;
    if (isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap)
        return new EmptyNode();
      if (children3.length <= 2 && isLeafNode(children3[indx ^ 1])) {
        return children3[indx ^ 1];
      }
      newChildren = arraySpliceOut(canEdit, indx, children3);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children3);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new _IndexedNode(edit, bitmap, newChildren);
  }
};
var ArrayNode = class _ArrayNode {
  constructor(edit, size38, children3) {
    __publicField(this, "edit");
    __publicField(this, "size");
    __publicField(this, "children");
    __publicField(this, "_tag", "ArrayNode");
    this.edit = edit;
    this.size = size38;
    this.children = children3;
  }
  modify(edit, shift2, f, hash3, key, size38) {
    let count9 = this.size;
    const children3 = this.children;
    const frag = hashFragment(shift2, hash3);
    const child = children3[frag];
    const newChild = (child || new EmptyNode()).modify(edit, shift2 + SIZE, f, hash3, key, size38);
    if (child === newChild)
      return this;
    const canEdit = canEditNode(this, edit);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ;
      ++count9;
      newChildren = arrayUpdate(canEdit, frag, newChild, children3);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      ;
      --count9;
      if (count9 <= MIN_ARRAY_NODE) {
        return pack(edit, count9, frag, children3);
      }
      newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children3);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children3);
    }
    if (canEdit) {
      this.size = count9;
      this.children = newChildren;
      return this;
    }
    return new _ArrayNode(edit, count9, newChildren);
  }
};
function pack(edit, count9, removed, elements) {
  const children3 = new Array(count9 - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length; i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode(elem)) {
        children3[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children3);
}
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count9 = 0;
  for (let i = 0; bit; ++i) {
    if (bit & 1)
      arr[i] = subNodes[count9++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count9 + 1, arr);
}
function mergeLeavesInner(edit, shift2, h1, n1, h2, n2) {
  if (h1 === h2)
    return new CollisionNode(edit, h1, [n2, n1]);
  const subH1 = hashFragment(shift2, h1);
  const subH2 = hashFragment(shift2, h2);
  if (subH1 === subH2) {
    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children3 = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children3);
  }
}
function mergeLeaves(edit, shift2, h1, n1, h2, n2) {
  let stack = void 0;
  let currentShift = shift2;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
    if (typeof res === "function") {
      stack = make9(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}

// ../node_modules/effect/dist/esm/internal/hashMap.js
var HashMapSymbolKey = "effect/HashMap";
var HashMapTypeId = Symbol.for(HashMapSymbolKey);
var HashMapProto = {
  [HashMapTypeId]: HashMapTypeId,
  [Symbol.iterator]() {
    return new HashMapIterator(this, (k, v) => [k, v]);
  },
  [symbol2]() {
    let hash3 = hash(HashMapSymbolKey);
    for (const item of this) {
      hash3 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash3);
  },
  [symbol3](that) {
    if (isHashMap(that)) {
      if (that._size !== this._size) {
        return false;
      }
      for (const item of this) {
        const elem = pipe(that, getHash(item[0], hash(item[0])));
        if (isNone(elem)) {
          return false;
        } else {
          if (!equals(item[1], elem.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl = (editable, edit, root, size38) => {
  const map43 = Object.create(HashMapProto);
  map43._editable = editable;
  map43._edit = edit;
  map43._root = root;
  map43._size = size38;
  return map43;
};
var HashMapIterator = class _HashMapIterator {
  constructor(map43, f) {
    __publicField(this, "map");
    __publicField(this, "f");
    __publicField(this, "v");
    this.map = map43;
    this.f = f;
    this.v = visitLazy(this.map._root, this.f, void 0);
  }
  next() {
    if (isNone(this.v)) {
      return {
        done: true,
        value: void 0
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new _HashMapIterator(this.map, this.f);
  }
};
var applyCont = (cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none2();
var visitLazy = (node, f, cont = void 0) => {
  switch (node._tag) {
    case "LeafNode": {
      if (isSome(node.value)) {
        return some2({
          value: f(node.key, node.value.value),
          cont
        });
      }
      return applyCont(cont);
    }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode": {
      const children3 = node.children;
      return visitLazyChildren(children3.length, children3, 0, f, cont);
    }
    default: {
      return applyCont(cont);
    }
  }
};
var visitLazyChildren = (len, children3, i, f, cont) => {
  while (i < len) {
    const child = children3[i++];
    if (child && !isEmptyNode(child)) {
      return visitLazy(child, f, [len, children3, i, f, cont]);
    }
  }
  return applyCont(cont);
};
var _empty3 = makeImpl(false, 0, new EmptyNode(), 0);
var empty6 = () => _empty3;
var make10 = (...entries6) => fromIterable3(entries6);
var fromIterable3 = (entries6) => {
  const map43 = beginMutation(empty6());
  for (const entry of entries6) {
    set(map43, entry[0], entry[1]);
  }
  return endMutation(map43);
};
var isHashMap = (u) => hasProperty(u, HashMapTypeId);
var isEmpty2 = (self) => self && isEmptyNode(self._root);
var get4 = dual(2, (self, key) => getHash(self, key, hash(key)));
var getHash = dual(3, (self, key, hash3) => {
  let node = self._root;
  let shift2 = 0;
  while (true) {
    switch (node._tag) {
      case "LeafNode": {
        return equals(key, node.key) ? node.value : none2();
      }
      case "CollisionNode": {
        if (hash3 === node.hash) {
          const children3 = node.children;
          for (let i = 0, len = children3.length; i < len; ++i) {
            const child = children3[i];
            if ("key" in child && equals(key, child.key)) {
              return child.value;
            }
          }
        }
        return none2();
      }
      case "IndexedNode": {
        const frag = hashFragment(shift2, hash3);
        const bit = toBitmap(frag);
        if (node.mask & bit) {
          node = node.children[fromBitmap(node.mask, bit)];
          shift2 += SIZE;
          break;
        }
        return none2();
      }
      case "ArrayNode": {
        node = node.children[hashFragment(shift2, hash3)];
        if (node) {
          shift2 += SIZE;
          break;
        }
        return none2();
      }
      default:
        return none2();
    }
  }
});
var unsafeGet5 = dual(2, (self, key) => {
  const element = getHash(self, key, hash(key));
  if (isNone(element)) {
    throw new Error("Expected map to contain key");
  }
  return element.value;
});
var has = dual(2, (self, key) => isSome(getHash(self, key, hash(key))));
var hasHash = dual(3, (self, key, hash3) => isSome(getHash(self, key, hash3)));
var set = dual(3, (self, key, value8) => modifyAt(self, key, () => some2(value8)));
var setTree = dual(3, (self, newRoot, newSize) => {
  if (self._editable) {
    ;
    self._root = newRoot;
    self._size = newSize;
    return self;
  }
  return newRoot === self._root ? self : makeImpl(self._editable, self._edit, newRoot, newSize);
});
var keys = (self) => new HashMapIterator(self, (key) => key);
var values = (self) => new HashMapIterator(self, (_, value8) => value8);
var entries = (self) => new HashMapIterator(self, (key, value8) => [key, value8]);
var size2 = (self) => self._size;
var beginMutation = (self) => makeImpl(true, self._edit + 1, self._root, self._size);
var endMutation = (self) => {
  ;
  self._editable = false;
  return self;
};
var mutate = dual(2, (self, f) => {
  const transient = beginMutation(self);
  f(transient);
  return endMutation(transient);
});
var modifyAt = dual(3, (self, key, f) => modifyHash(self, key, hash(key), f));
var modifyHash = dual(4, (self, key, hash3, f) => {
  const size38 = {
    value: self._size
  };
  const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f, hash3, key, size38);
  return pipe(self, setTree(newRoot, size38.value));
});
var modify2 = dual(3, (self, key, f) => modifyAt(self, key, map2(f)));
var union3 = dual(2, (self, that) => {
  const result = beginMutation(self);
  forEach2(that, (v, k) => set(result, k, v));
  return endMutation(result);
});
var remove3 = dual(2, (self, key) => modifyAt(self, key, none2));
var removeMany = dual(2, (self, keys10) => mutate(self, (map43) => {
  for (const key of keys10) {
    remove3(key)(map43);
  }
}));
var map5 = dual(2, (self, f) => reduce3(self, empty6(), (map43, value8, key) => set(map43, key, f(value8, key))));
var flatMap4 = dual(2, (self, f) => reduce3(self, empty6(), (zero3, value8, key) => mutate(zero3, (map43) => forEach2(f(value8, key), (value9, key2) => set(map43, key2, value9)))));
var forEach2 = dual(2, (self, f) => reduce3(self, void 0, (_, value8, key) => f(value8, key)));
var reduce3 = dual(3, (self, zero3, f) => {
  const root = self._root;
  if (root._tag === "LeafNode") {
    return isSome(root.value) ? f(zero3, root.value.value, root.key) : zero3;
  }
  if (root._tag === "EmptyNode") {
    return zero3;
  }
  const toVisit = [root.children];
  let children3;
  while (children3 = toVisit.pop()) {
    for (let i = 0, len = children3.length; i < len; ) {
      const child = children3[i++];
      if (child && !isEmptyNode(child)) {
        if (child._tag === "LeafNode") {
          if (isSome(child.value)) {
            zero3 = f(zero3, child.value.value, child.key);
          }
        } else {
          toVisit.push(child.children);
        }
      }
    }
  }
  return zero3;
});
var filter3 = dual(2, (self, f) => mutate(empty6(), (map43) => {
  for (const [k, a] of self) {
    if (f(a, k)) {
      set(map43, k, a);
    }
  }
}));
var compact2 = (self) => filterMap3(self, identity);
var filterMap3 = dual(2, (self, f) => mutate(empty6(), (map43) => {
  for (const [k, a] of self) {
    const option9 = f(a, k);
    if (isSome(option9)) {
      set(map43, k, option9.value);
    }
  }
}));
var findFirst3 = dual(2, (self, predicate) => {
  for (const ka of self) {
    if (predicate(ka[1], ka[0])) {
      return some2(ka);
    }
  }
  return none2();
});

// ../node_modules/effect/dist/esm/internal/hashSet.js
var HashSetSymbolKey = "effect/HashSet";
var HashSetTypeId = Symbol.for(HashSetSymbolKey);
var HashSetProto = {
  [HashSetTypeId]: HashSetTypeId,
  [Symbol.iterator]() {
    return keys(this._keyMap);
  },
  [symbol2]() {
    return cached(this, combine(hash(this._keyMap))(hash(HashSetSymbolKey)));
  },
  [symbol3](that) {
    if (isHashSet(that)) {
      return size2(this._keyMap) === size2(that._keyMap) && equals(this._keyMap, that._keyMap);
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl2 = (keyMap) => {
  const set22 = Object.create(HashSetProto);
  set22._keyMap = keyMap;
  return set22;
};
var isHashSet = (u) => hasProperty(u, HashSetTypeId);
var _empty4 = makeImpl2(empty6());
var empty7 = () => _empty4;
var fromIterable4 = (elements) => {
  const set22 = beginMutation2(empty7());
  for (const value8 of elements) {
    add3(set22, value8);
  }
  return endMutation2(set22);
};
var make11 = (...elements) => {
  const set22 = beginMutation2(empty7());
  for (const value8 of elements) {
    add3(set22, value8);
  }
  return endMutation2(set22);
};
var has2 = dual(2, (self, value8) => has(self._keyMap, value8));
var some5 = dual(2, (self, f) => {
  let found = false;
  for (const value8 of self) {
    found = f(value8);
    if (found) {
      break;
    }
  }
  return found;
});
var every4 = dual(2, (self, refinement) => !some5(self, (a) => !refinement(a)));
var isSubset = dual(2, (self, that) => every4(self, (value8) => has2(that, value8)));
var values2 = (self) => keys(self._keyMap);
var size3 = (self) => size2(self._keyMap);
var beginMutation2 = (self) => makeImpl2(beginMutation(self._keyMap));
var endMutation2 = (self) => {
  ;
  self._keyMap._editable = false;
  return self;
};
var mutate2 = dual(2, (self, f) => {
  const transient = beginMutation2(self);
  f(transient);
  return endMutation2(transient);
});
var add3 = dual(2, (self, value8) => self._keyMap._editable ? (set(value8, true)(self._keyMap), self) : makeImpl2(set(value8, true)(self._keyMap)));
var remove4 = dual(2, (self, value8) => self._keyMap._editable ? (remove3(value8)(self._keyMap), self) : makeImpl2(remove3(value8)(self._keyMap)));
var difference = dual(2, (self, that) => mutate2(self, (set22) => {
  for (const value8 of that) {
    remove4(set22, value8);
  }
}));
var intersection3 = dual(2, (self, that) => mutate2(empty7(), (set22) => {
  for (const value8 of that) {
    if (has2(value8)(self)) {
      add3(value8)(set22);
    }
  }
}));
var union4 = dual(2, (self, that) => mutate2(empty7(), (set22) => {
  forEach3(self, (value8) => add3(set22, value8));
  for (const value8 of that) {
    add3(set22, value8);
  }
}));
var toggle = dual(2, (self, value8) => has2(self, value8) ? remove4(self, value8) : add3(self, value8));
var map6 = dual(2, (self, f) => mutate2(empty7(), (set22) => {
  forEach3(self, (a) => {
    const b = f(a);
    if (!has2(set22, b)) {
      add3(set22, b);
    }
  });
}));
var flatMap5 = dual(2, (self, f) => mutate2(empty7(), (set22) => {
  forEach3(self, (a) => {
    for (const b of f(a)) {
      if (!has2(set22, b)) {
        add3(set22, b);
      }
    }
  });
}));
var forEach3 = dual(2, (self, f) => forEach2(self._keyMap, (_, k) => f(k)));
var reduce4 = dual(3, (self, zero3, f) => reduce3(self._keyMap, zero3, (z, _, a) => f(z, a)));
var filter4 = dual(2, (self, f) => {
  return mutate2(empty7(), (set22) => {
    const iterator = values2(self);
    let next6;
    while (!(next6 = iterator.next()).done) {
      const value8 = next6.value;
      if (f(value8)) {
        add3(set22, value8);
      }
    }
  });
});
var partition3 = dual(2, (self, predicate) => {
  const iterator = values2(self);
  let next6;
  const right2 = beginMutation2(empty7());
  const left2 = beginMutation2(empty7());
  while (!(next6 = iterator.next()).done) {
    const value8 = next6.value;
    if (predicate(value8)) {
      add3(right2, value8);
    } else {
      add3(left2, value8);
    }
  }
  return [endMutation2(left2), endMutation2(right2)];
});

// ../node_modules/effect/dist/esm/HashSet.js
var isHashSet2 = isHashSet;
var empty8 = empty7;
var fromIterable5 = fromIterable4;
var make12 = make11;
var has3 = has2;
var some6 = some5;
var every5 = every4;
var isSubset2 = isSubset;
var values3 = values2;
var size4 = size3;
var beginMutation3 = beginMutation2;
var endMutation3 = endMutation2;
var mutate3 = mutate2;
var add4 = add3;
var remove5 = remove4;
var difference2 = difference;
var intersection4 = intersection3;
var union5 = union4;
var toggle2 = toggle;
var map7 = map6;
var flatMap6 = flatMap5;
var forEach4 = forEach3;
var reduce5 = reduce4;
var filter5 = filter4;
var partition4 = partition3;

// ../node_modules/effect/dist/esm/MutableRef.js
var MutableRef_exports = {};
__export(MutableRef_exports, {
  compareAndSet: () => compareAndSet,
  decrement: () => decrement2,
  decrementAndGet: () => decrementAndGet,
  get: () => get5,
  getAndDecrement: () => getAndDecrement,
  getAndIncrement: () => getAndIncrement,
  getAndSet: () => getAndSet,
  getAndUpdate: () => getAndUpdate,
  increment: () => increment2,
  incrementAndGet: () => incrementAndGet,
  make: () => make13,
  set: () => set2,
  setAndGet: () => setAndGet,
  toggle: () => toggle3,
  update: () => update,
  updateAndGet: () => updateAndGet
});
var TypeId4 = Symbol.for("effect/MutableRef");
var MutableRefProto = {
  [TypeId4]: TypeId4,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableRef",
      current: toJSON(this.current)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make13 = (value8) => {
  const ref = Object.create(MutableRefProto);
  ref.current = value8;
  return ref;
};
var compareAndSet = dual(3, (self, oldValue, newValue) => {
  if (equals(oldValue, self.current)) {
    self.current = newValue;
    return true;
  }
  return false;
});
var decrement2 = (self) => update(self, (n) => n - 1);
var decrementAndGet = (self) => updateAndGet(self, (n) => n - 1);
var get5 = (self) => self.current;
var getAndDecrement = (self) => getAndUpdate(self, (n) => n - 1);
var getAndIncrement = (self) => getAndUpdate(self, (n) => n + 1);
var getAndSet = dual(2, (self, value8) => {
  const ret = self.current;
  self.current = value8;
  return ret;
});
var getAndUpdate = dual(2, (self, f) => getAndSet(self, f(get5(self))));
var increment2 = (self) => update(self, (n) => n + 1);
var incrementAndGet = (self) => updateAndGet(self, (n) => n + 1);
var set2 = dual(2, (self, value8) => {
  self.current = value8;
  return self;
});
var setAndGet = dual(2, (self, value8) => {
  self.current = value8;
  return self.current;
});
var update = dual(2, (self, f) => set2(self, f(get5(self))));
var updateAndGet = dual(2, (self, f) => setAndGet(self, f(get5(self))));
var toggle3 = (self) => update(self, (_) => !_);

// ../node_modules/effect/dist/esm/internal/fiberId.js
var FiberIdSymbolKey = "effect/FiberId";
var FiberIdTypeId = Symbol.for(FiberIdSymbolKey);
var OP_NONE = "None";
var OP_RUNTIME = "Runtime";
var OP_COMPOSITE = "Composite";
var emptyHash = string(`${FiberIdSymbolKey}-${OP_NONE}`);
var _a;
var None = class {
  constructor() {
    __publicField(this, _a, FiberIdTypeId);
    __publicField(this, "_tag", OP_NONE);
    __publicField(this, "id", -1);
    __publicField(this, "startTimeMillis", -1);
  }
  [(_a = FiberIdTypeId, symbol2)]() {
    return emptyHash;
  }
  [symbol3](that) {
    return isFiberId(that) && that._tag === OP_NONE;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var _a2;
var Runtime = class {
  constructor(id3, startTimeMillis) {
    __publicField(this, "id");
    __publicField(this, "startTimeMillis");
    __publicField(this, _a2, FiberIdTypeId);
    __publicField(this, "_tag", OP_RUNTIME);
    this.id = id3;
    this.startTimeMillis = startTimeMillis;
  }
  [(_a2 = FiberIdTypeId, symbol2)]() {
    return cached(this, string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
  }
  [symbol3](that) {
    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      id: this.id,
      startTimeMillis: this.startTimeMillis
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var _a3;
var Composite = class {
  constructor(left2, right2) {
    __publicField(this, "left");
    __publicField(this, "right");
    __publicField(this, _a3, FiberIdTypeId);
    __publicField(this, "_tag", OP_COMPOSITE);
    __publicField(this, "_hash");
    this.left = left2;
    this.right = right2;
  }
  [(_a3 = FiberIdTypeId, symbol2)]() {
    return pipe(string(`${FiberIdSymbolKey}-${this._tag}`), combine(hash(this.left)), combine(hash(this.right)), cached(this));
  }
  [symbol3](that) {
    return isFiberId(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      left: toJSON(this.left),
      right: toJSON(this.right)
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var none3 = new None();
var runtime = (id3, startTimeMillis) => {
  return new Runtime(id3, startTimeMillis);
};
var composite = (left2, right2) => {
  return new Composite(left2, right2);
};
var isFiberId = (self) => hasProperty(self, FiberIdTypeId);
var isNone2 = (self) => {
  return self._tag === OP_NONE || pipe(toSet(self), every5((id3) => isNone2(id3)));
};
var isRuntime = (self) => {
  return self._tag === OP_RUNTIME;
};
var isComposite = (self) => {
  return self._tag === OP_COMPOSITE;
};
var combine2 = dual(2, (self, that) => {
  if (self._tag === OP_NONE) {
    return that;
  }
  if (that._tag === OP_NONE) {
    return self;
  }
  return new Composite(self, that);
});
var combineAll = (fiberIds) => {
  return pipe(fiberIds, reduce5(none3, (a, b) => combine2(b)(a)));
};
var getOrElse2 = dual(2, (self, that) => isNone2(self) ? that : self);
var ids = (self) => {
  switch (self._tag) {
    case OP_NONE: {
      return empty8();
    }
    case OP_RUNTIME: {
      return make12(self.id);
    }
    case OP_COMPOSITE: {
      return pipe(ids(self.left), union5(ids(self.right)));
    }
  }
};
var _fiberCounter = globalValue(Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make13(0));
var make14 = (id3, startTimeSeconds) => {
  return new Runtime(id3, startTimeSeconds);
};
var threadName = (self) => {
  const identifiers = Array.from(ids(self)).map((n) => `#${n}`).join(",");
  return identifiers;
};
var toOption = (self) => {
  const fiberIds = toSet(self);
  if (size4(fiberIds) === 0) {
    return none2();
  }
  let first5 = true;
  let acc;
  for (const fiberId5 of fiberIds) {
    if (first5) {
      acc = fiberId5;
      first5 = false;
    } else {
      acc = pipe(acc, combine2(fiberId5));
    }
  }
  return some2(acc);
};
var toSet = (self) => {
  switch (self._tag) {
    case OP_NONE: {
      return empty8();
    }
    case OP_RUNTIME: {
      return make12(self);
    }
    case OP_COMPOSITE: {
      return pipe(toSet(self.left), union5(toSet(self.right)));
    }
  }
};
var unsafeMake2 = () => {
  const id3 = get5(_fiberCounter);
  pipe(_fiberCounter, set2(id3 + 1));
  return new Runtime(id3, Date.now());
};

// ../node_modules/effect/dist/esm/FiberId.js
var FiberIdTypeId2 = FiberIdTypeId;
var none4 = none3;
var runtime2 = runtime;
var composite2 = composite;
var isFiberId2 = isFiberId;
var isNone3 = isNone2;
var isRuntime2 = isRuntime;
var isComposite2 = isComposite;
var combine3 = combine2;
var combineAll2 = combineAll;
var getOrElse3 = getOrElse2;
var ids2 = ids;
var make15 = make14;
var threadName2 = threadName;
var toOption2 = toOption;
var toSet2 = toSet;
var unsafeMake3 = unsafeMake2;

// ../node_modules/effect/dist/esm/HashMap.js
var HashMap_exports = {};
__export(HashMap_exports, {
  beginMutation: () => beginMutation4,
  compact: () => compact3,
  empty: () => empty9,
  endMutation: () => endMutation4,
  entries: () => entries2,
  filter: () => filter6,
  filterMap: () => filterMap4,
  findFirst: () => findFirst4,
  flatMap: () => flatMap7,
  forEach: () => forEach5,
  fromIterable: () => fromIterable6,
  get: () => get6,
  getHash: () => getHash2,
  has: () => has4,
  hasHash: () => hasHash2,
  isEmpty: () => isEmpty3,
  isHashMap: () => isHashMap2,
  keySet: () => keySet2,
  keys: () => keys2,
  make: () => make16,
  map: () => map8,
  modify: () => modify3,
  modifyAt: () => modifyAt2,
  modifyHash: () => modifyHash2,
  mutate: () => mutate4,
  reduce: () => reduce6,
  remove: () => remove6,
  removeMany: () => removeMany2,
  set: () => set3,
  size: () => size5,
  toEntries: () => toEntries,
  union: () => union6,
  unsafeGet: () => unsafeGet6,
  values: () => values4
});

// ../node_modules/effect/dist/esm/internal/hashMap/keySet.js
function keySet(self) {
  return makeImpl2(self);
}

// ../node_modules/effect/dist/esm/HashMap.js
var isHashMap2 = isHashMap;
var empty9 = empty6;
var make16 = make10;
var fromIterable6 = fromIterable3;
var isEmpty3 = isEmpty2;
var get6 = get4;
var getHash2 = getHash;
var unsafeGet6 = unsafeGet5;
var has4 = has;
var hasHash2 = hasHash;
var set3 = set;
var keys2 = keys;
var keySet2 = keySet;
var values4 = values;
var entries2 = entries;
var toEntries = (self) => Array.from(entries2(self));
var size5 = size2;
var beginMutation4 = beginMutation;
var endMutation4 = endMutation;
var mutate4 = mutate;
var modifyAt2 = modifyAt;
var modifyHash2 = modifyHash;
var modify3 = modify2;
var union6 = union3;
var remove6 = remove3;
var removeMany2 = removeMany;
var map8 = map5;
var flatMap7 = flatMap4;
var forEach5 = forEach2;
var reduce6 = reduce3;
var filter6 = filter3;
var compact3 = compact2;
var filterMap4 = filterMap3;
var findFirst4 = findFirst3;

// ../node_modules/effect/dist/esm/List.js
var List_exports = {};
__export(List_exports, {
  TypeId: () => TypeId5,
  append: () => append3,
  appendAll: () => appendAll3,
  compact: () => compact4,
  cons: () => cons,
  drop: () => drop3,
  empty: () => empty10,
  every: () => every6,
  filter: () => filter7,
  filterMap: () => filterMap5,
  findFirst: () => findFirst5,
  flatMap: () => flatMap8,
  forEach: () => forEach6,
  fromIterable: () => fromIterable7,
  getEquivalence: () => getEquivalence3,
  head: () => head3,
  isCons: () => isCons,
  isList: () => isList,
  isNil: () => isNil,
  last: () => last3,
  make: () => make17,
  map: () => map9,
  nil: () => nil,
  of: () => of3,
  partition: () => partition5,
  partitionMap: () => partitionMap3,
  prepend: () => prepend3,
  prependAll: () => prependAll2,
  prependAllReversed: () => prependAllReversed,
  reduce: () => reduce7,
  reduceRight: () => reduceRight3,
  reverse: () => reverse3,
  size: () => size6,
  some: () => some7,
  splitAt: () => splitAt3,
  tail: () => tail2,
  take: () => take2,
  toArray: () => toArray2,
  toChunk: () => toChunk,
  unsafeHead: () => unsafeHead2,
  unsafeLast: () => unsafeLast2,
  unsafeTail: () => unsafeTail
});
var TypeId5 = Symbol.for("effect/List");
var toArray2 = (self) => fromIterable(self);
var getEquivalence3 = (isEquivalent) => mapInput(getEquivalence(isEquivalent), toArray2);
var _equivalence2 = getEquivalence3(equals);
var ConsProto = {
  [TypeId5]: TypeId5,
  _tag: "Cons",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Cons",
      values: toArray2(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol3](that) {
    return isList(that) && this._tag === that._tag && _equivalence2(this, that);
  },
  [symbol2]() {
    return cached(this, array2(toArray2(this)));
  },
  [Symbol.iterator]() {
    let done17 = false;
    let self = this;
    return {
      next() {
        if (done17) {
          return this.return();
        }
        if (self._tag === "Nil") {
          done17 = true;
          return this.return();
        }
        const value8 = self.head;
        self = self.tail;
        return {
          done: done17,
          value: value8
        };
      },
      return(value8) {
        if (!done17) {
          done17 = true;
        }
        return {
          done: true,
          value: value8
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeCons = (head11, tail4) => {
  const cons2 = Object.create(ConsProto);
  cons2.head = head11;
  cons2.tail = tail4;
  return cons2;
};
var NilHash = string("Nil");
var NilProto = {
  [TypeId5]: TypeId5,
  _tag: "Nil",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Nil"
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2]() {
    return NilHash;
  },
  [symbol3](that) {
    return isList(that) && this._tag === that._tag;
  },
  [Symbol.iterator]() {
    return {
      next() {
        return {
          done: true,
          value: void 0
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _Nil = Object.create(NilProto);
var isList = (u) => hasProperty(u, TypeId5);
var isNil = (self) => self._tag === "Nil";
var isCons = (self) => self._tag === "Cons";
var size6 = (self) => {
  let these = self;
  let len = 0;
  while (!isNil(these)) {
    len += 1;
    these = these.tail;
  }
  return len;
};
var nil = () => _Nil;
var cons = (head11, tail4) => makeCons(head11, tail4);
var empty10 = nil;
var of3 = (value8) => makeCons(value8, _Nil);
var fromIterable7 = (prefix) => {
  const iterator = prefix[Symbol.iterator]();
  let next6;
  if ((next6 = iterator.next()) && !next6.done) {
    const result = makeCons(next6.value, _Nil);
    let curr = result;
    while ((next6 = iterator.next()) && !next6.done) {
      const temp = makeCons(next6.value, _Nil);
      curr.tail = temp;
      curr = temp;
    }
    return result;
  } else {
    return _Nil;
  }
};
var make17 = (...elements) => fromIterable7(elements);
var append3 = dual(2, (self, element) => appendAll3(self, of3(element)));
var appendAll3 = dual(2, (self, that) => prependAll2(that, self));
var prepend3 = dual(2, (self, element) => cons(element, self));
var prependAll2 = dual(2, (self, prefix) => {
  if (isNil(self)) {
    return prefix;
  } else if (isNil(prefix)) {
    return self;
  } else {
    const result = makeCons(prefix.head, self);
    let curr = result;
    let that = prefix.tail;
    while (!isNil(that)) {
      const temp = makeCons(that.head, self);
      curr.tail = temp;
      curr = temp;
      that = that.tail;
    }
    return result;
  }
});
var prependAllReversed = dual(2, (self, prefix) => {
  let out = self;
  let pres = prefix;
  while (isCons(pres)) {
    out = makeCons(pres.head, out);
    pres = pres.tail;
  }
  return out;
});
var drop3 = dual(2, (self, n) => {
  if (n <= 0) {
    return self;
  }
  if (n >= size6(self)) {
    return _Nil;
  }
  let these = self;
  let i = 0;
  while (!isNil(these) && i < n) {
    these = these.tail;
    i += 1;
  }
  return these;
});
var every6 = dual(2, (self, refinement) => {
  for (const a of self) {
    if (!refinement(a)) {
      return false;
    }
  }
  return true;
});
var some7 = dual(2, (self, predicate) => {
  let these = self;
  while (!isNil(these)) {
    if (predicate(these.head)) {
      return true;
    }
    these = these.tail;
  }
  return false;
});
var filter7 = dual(2, (self, predicate) => noneIn(self, predicate, false));
var noneIn = (self, predicate, isFlipped) => {
  while (true) {
    if (isNil(self)) {
      return _Nil;
    } else {
      if (predicate(self.head) !== isFlipped) {
        return allIn(self, self.tail, predicate, isFlipped);
      } else {
        self = self.tail;
      }
    }
  }
};
var allIn = (start5, remaining, predicate, isFlipped) => {
  while (true) {
    if (isNil(remaining)) {
      return start5;
    } else {
      if (predicate(remaining.head) !== isFlipped) {
        remaining = remaining.tail;
      } else {
        return partialFill(start5, remaining, predicate, isFlipped);
      }
    }
  }
};
var partialFill = (origStart, firstMiss, predicate, isFlipped) => {
  const newHead = makeCons(unsafeHead2(origStart), _Nil);
  let toProcess = unsafeTail(origStart);
  let currentLast = newHead;
  while (!(toProcess === firstMiss)) {
    const newElem = makeCons(unsafeHead2(toProcess), _Nil);
    currentLast.tail = newElem;
    currentLast = unsafeCoerce(newElem);
    toProcess = unsafeCoerce(toProcess.tail);
  }
  let next6 = firstMiss.tail;
  let nextToCopy = unsafeCoerce(next6);
  while (!isNil(next6)) {
    const head11 = unsafeHead2(next6);
    if (predicate(head11) !== isFlipped) {
      next6 = next6.tail;
    } else {
      while (!(nextToCopy === next6)) {
        const newElem = makeCons(unsafeHead2(nextToCopy), _Nil);
        currentLast.tail = newElem;
        currentLast = newElem;
        nextToCopy = unsafeCoerce(nextToCopy.tail);
      }
      nextToCopy = unsafeCoerce(next6.tail);
      next6 = next6.tail;
    }
  }
  if (!isNil(nextToCopy)) {
    currentLast.tail = nextToCopy;
  }
  return newHead;
};
var filterMap5 = dual(2, (self, f) => {
  const bs = [];
  for (const a of self) {
    const oa = f(a);
    if (isSome(oa)) {
      bs.push(oa.value);
    }
  }
  return fromIterable7(bs);
});
var compact4 = (self) => filterMap5(self, identity);
var findFirst5 = dual(2, (self, predicate) => {
  let these = self;
  while (!isNil(these)) {
    if (predicate(these.head)) {
      return some2(these.head);
    }
    these = these.tail;
  }
  return none2();
});
var flatMap8 = dual(2, (self, f) => {
  let rest = self;
  let head11 = void 0;
  let tail4 = void 0;
  while (!isNil(rest)) {
    let bs = f(rest.head);
    while (!isNil(bs)) {
      const next6 = makeCons(bs.head, _Nil);
      if (tail4 === void 0) {
        head11 = next6;
      } else {
        tail4.tail = next6;
      }
      tail4 = next6;
      bs = bs.tail;
    }
    rest = rest.tail;
  }
  if (head11 === void 0) {
    return _Nil;
  }
  return head11;
});
var forEach6 = dual(2, (self, f) => {
  let these = self;
  while (!isNil(these)) {
    f(these.head);
    these = these.tail;
  }
});
var head3 = (self) => isNil(self) ? none2() : some2(self.head);
var last3 = (self) => isNil(self) ? none2() : some2(unsafeLast2(self));
var map9 = dual(2, (self, f) => {
  if (isNil(self)) {
    return self;
  } else {
    let i = 0;
    const head11 = makeCons(f(self.head, i++), _Nil);
    let nextHead = head11;
    let rest = self.tail;
    while (!isNil(rest)) {
      const next6 = makeCons(f(rest.head, i++), _Nil);
      nextHead.tail = next6;
      nextHead = next6;
      rest = rest.tail;
    }
    return head11;
  }
});
var partition5 = dual(2, (self, predicate) => {
  const left2 = [];
  const right2 = [];
  for (const a of self) {
    if (predicate(a)) {
      right2.push(a);
    } else {
      left2.push(a);
    }
  }
  return [fromIterable7(left2), fromIterable7(right2)];
});
var partitionMap3 = dual(2, (self, f) => {
  const left2 = [];
  const right2 = [];
  for (const a of self) {
    const e = f(a);
    if (isLeft(e)) {
      left2.push(e.left);
    } else {
      right2.push(e.right);
    }
  }
  return [fromIterable7(left2), fromIterable7(right2)];
});
var reduce7 = dual(3, (self, zero3, f) => {
  let acc = zero3;
  let these = self;
  while (!isNil(these)) {
    acc = f(acc, these.head);
    these = these.tail;
  }
  return acc;
});
var reduceRight3 = dual(3, (self, zero3, f) => {
  let acc = zero3;
  let these = reverse3(self);
  while (!isNil(these)) {
    acc = f(acc, these.head);
    these = these.tail;
  }
  return acc;
});
var reverse3 = (self) => {
  let result = empty10();
  let these = self;
  while (!isNil(these)) {
    result = prepend3(result, these.head);
    these = these.tail;
  }
  return result;
};
var splitAt3 = dual(2, (self, n) => [take2(self, n), drop3(self, n)]);
var tail2 = (self) => isNil(self) ? none2() : some2(self.tail);
var take2 = dual(2, (self, n) => {
  if (n <= 0) {
    return _Nil;
  }
  if (n >= size6(self)) {
    return self;
  }
  let these = make17(unsafeHead2(self));
  let current2 = unsafeTail(self);
  for (let i = 1; i < n; i++) {
    these = makeCons(unsafeHead2(current2), these);
    current2 = unsafeTail(current2);
  }
  return reverse3(these);
});
var toChunk = (self) => fromIterable2(self);
var getExpectedListToBeNonEmptyErrorMessage = "Expected List to be non-empty";
var unsafeHead2 = (self) => {
  if (isNil(self)) {
    throw new Error(getExpectedListToBeNonEmptyErrorMessage);
  }
  return self.head;
};
var unsafeLast2 = (self) => {
  if (isNil(self)) {
    throw new Error(getExpectedListToBeNonEmptyErrorMessage);
  }
  let these = self;
  let scout = self.tail;
  while (!isNil(scout)) {
    these = scout;
    scout = scout.tail;
  }
  return these.head;
};
var unsafeTail = (self) => {
  if (isNil(self)) {
    throw new Error(getExpectedListToBeNonEmptyErrorMessage);
  }
  return self.tail;
};

// ../node_modules/effect/dist/esm/RuntimeFlagsPatch.js
var RuntimeFlagsPatch_exports = {};
__export(RuntimeFlagsPatch_exports, {
  andThen: () => andThen2,
  both: () => both2,
  disable: () => disable3,
  disabledSet: () => disabledSet2,
  either: () => either2,
  empty: () => empty18,
  enable: () => enable3,
  enabledSet: () => enabledSet2,
  exclude: () => exclude2,
  includes: () => includes,
  inverse: () => inverse2,
  isActive: () => isActive2,
  isDisabled: () => isDisabled3,
  isEmpty: () => isEmpty5,
  isEnabled: () => isEnabled3,
  make: () => make21,
  render: () => render2
});

// ../node_modules/effect/dist/esm/internal/data.js
var ArrayProto = Object.assign(Object.create(Array.prototype), {
  [symbol2]() {
    return cached(this, array2(this));
  },
  [symbol3](that) {
    if (Array.isArray(that) && this.length === that.length) {
      return this.every((v, i) => equals(v, that[i]));
    } else {
      return false;
    }
  }
});
var Structural = function() {
  function Structural3(args) {
    if (args) {
      Object.assign(this, args);
    }
  }
  Structural3.prototype = StructuralPrototype;
  return Structural3;
}();
var struct3 = (as16) => Object.assign(Object.create(StructuralPrototype), as16);

// ../node_modules/effect/dist/esm/internal/differ/chunkPatch.js
var ChunkPatchTypeId = Symbol.for("effect/DifferChunkPatch");
function variance(a) {
  return a;
}
var PatchProto = {
  ...Structural.prototype,
  [ChunkPatchTypeId]: {
    _Value: variance,
    _Patch: variance
  }
};
var EmptyProto = Object.assign(Object.create(PatchProto), {
  _tag: "Empty"
});
var _empty5 = Object.create(EmptyProto);
var empty11 = () => _empty5;
var AndThenProto = Object.assign(Object.create(PatchProto), {
  _tag: "AndThen"
});
var makeAndThen = (first5, second) => {
  const o = Object.create(AndThenProto);
  o.first = first5;
  o.second = second;
  return o;
};
var AppendProto = Object.assign(Object.create(PatchProto), {
  _tag: "Append"
});
var makeAppend = (values13) => {
  const o = Object.create(AppendProto);
  o.values = values13;
  return o;
};
var SliceProto = Object.assign(Object.create(PatchProto), {
  _tag: "Slice"
});
var makeSlice = (from, until) => {
  const o = Object.create(SliceProto);
  o.from = from;
  o.until = until;
  return o;
};
var UpdateProto = Object.assign(Object.create(PatchProto), {
  _tag: "Update"
});
var makeUpdate = (index, patch14) => {
  const o = Object.create(UpdateProto);
  o.index = index;
  o.patch = patch14;
  return o;
};
var diff = (options) => {
  let i = 0;
  let patch14 = empty11();
  while (i < options.oldValue.length && i < options.newValue.length) {
    const oldElement = unsafeGet4(i)(options.oldValue);
    const newElement = unsafeGet4(i)(options.newValue);
    const valuePatch = options.differ.diff(oldElement, newElement);
    if (!equals(valuePatch, options.differ.empty)) {
      patch14 = pipe(patch14, combine4(makeUpdate(i, valuePatch)));
    }
    i = i + 1;
  }
  if (i < options.oldValue.length) {
    patch14 = pipe(patch14, combine4(makeSlice(0, i)));
  }
  if (i < options.newValue.length) {
    patch14 = pipe(patch14, combine4(makeAppend(drop2(i)(options.newValue))));
  }
  return patch14;
};
var combine4 = dual(2, (self, that) => makeAndThen(self, that));
var patch = dual(3, (self, oldValue, differ4) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let chunk7 = oldValue;
  let patches = of2(self);
  while (isNonEmpty2(patches)) {
    const head11 = headNonEmpty2(patches);
    const tail4 = tailNonEmpty2(patches);
    switch (head11._tag) {
      case "Empty": {
        patches = tail4;
        break;
      }
      case "AndThen": {
        patches = prepend2(head11.first)(prepend2(head11.second)(tail4));
        break;
      }
      case "Append": {
        chunk7 = appendAll2(head11.values)(chunk7);
        patches = tail4;
        break;
      }
      case "Slice": {
        const array6 = toReadonlyArray(chunk7);
        chunk7 = unsafeFromArray(array6.slice(head11.from, head11.until));
        patches = tail4;
        break;
      }
      case "Update": {
        const array6 = toReadonlyArray(chunk7);
        array6[head11.index] = differ4.patch(head11.patch, array6[head11.index]);
        chunk7 = unsafeFromArray(array6);
        patches = tail4;
        break;
      }
    }
  }
  return chunk7;
});

// ../node_modules/effect/dist/esm/internal/differ/contextPatch.js
var ContextPatchTypeId = Symbol.for("effect/DifferContextPatch");
function variance2(a) {
  return a;
}
var PatchProto2 = {
  ...Structural.prototype,
  [ContextPatchTypeId]: {
    _Value: variance2,
    _Patch: variance2
  }
};
var EmptyProto2 = Object.assign(Object.create(PatchProto2), {
  _tag: "Empty"
});
var _empty6 = Object.create(EmptyProto2);
var empty12 = () => _empty6;
var AndThenProto2 = Object.assign(Object.create(PatchProto2), {
  _tag: "AndThen"
});
var makeAndThen2 = (first5, second) => {
  const o = Object.create(AndThenProto2);
  o.first = first5;
  o.second = second;
  return o;
};
var AddServiceProto = Object.assign(Object.create(PatchProto2), {
  _tag: "AddService"
});
var makeAddService = (key, service3) => {
  const o = Object.create(AddServiceProto);
  o.key = key;
  o.service = service3;
  return o;
};
var RemoveServiceProto = Object.assign(Object.create(PatchProto2), {
  _tag: "RemoveService"
});
var makeRemoveService = (key) => {
  const o = Object.create(RemoveServiceProto);
  o.key = key;
  return o;
};
var UpdateServiceProto = Object.assign(Object.create(PatchProto2), {
  _tag: "UpdateService"
});
var makeUpdateService = (key, update16) => {
  const o = Object.create(UpdateServiceProto);
  o.key = key;
  o.update = update16;
  return o;
};
var diff2 = (oldValue, newValue) => {
  const missingServices = new Map(oldValue.unsafeMap);
  let patch14 = empty12();
  for (const [tag4, newService] of newValue.unsafeMap.entries()) {
    if (missingServices.has(tag4)) {
      const old = missingServices.get(tag4);
      missingServices.delete(tag4);
      if (!equals(old, newService)) {
        patch14 = combine5(makeUpdateService(tag4, () => newService))(patch14);
      }
    } else {
      missingServices.delete(tag4);
      patch14 = combine5(makeAddService(tag4, newService))(patch14);
    }
  }
  for (const [tag4] of missingServices.entries()) {
    patch14 = combine5(makeRemoveService(tag4))(patch14);
  }
  return patch14;
};
var combine5 = dual(2, (self, that) => makeAndThen2(self, that));
var patch2 = dual(2, (self, context13) => {
  if (self._tag === "Empty") {
    return context13;
  }
  let wasServiceUpdated = false;
  let patches = of2(self);
  const updatedContext = new Map(context13.unsafeMap);
  while (isNonEmpty2(patches)) {
    const head11 = headNonEmpty2(patches);
    const tail4 = tailNonEmpty2(patches);
    switch (head11._tag) {
      case "Empty": {
        patches = tail4;
        break;
      }
      case "AddService": {
        updatedContext.set(head11.key, head11.service);
        patches = tail4;
        break;
      }
      case "AndThen": {
        patches = prepend2(prepend2(tail4, head11.second), head11.first);
        break;
      }
      case "RemoveService": {
        updatedContext.delete(head11.key);
        patches = tail4;
        break;
      }
      case "UpdateService": {
        updatedContext.set(head11.key, head11.update(updatedContext.get(head11.key)));
        wasServiceUpdated = true;
        patches = tail4;
        break;
      }
    }
  }
  if (!wasServiceUpdated) {
    return makeContext(updatedContext);
  }
  const map43 = /* @__PURE__ */ new Map();
  for (const [tag4] of context13.unsafeMap) {
    if (updatedContext.has(tag4)) {
      map43.set(tag4, updatedContext.get(tag4));
      updatedContext.delete(tag4);
    }
  }
  for (const [tag4, s] of updatedContext) {
    map43.set(tag4, s);
  }
  return makeContext(map43);
});

// ../node_modules/effect/dist/esm/internal/differ/hashMapPatch.js
var HashMapPatchTypeId = Symbol.for("effect/DifferHashMapPatch");
function variance3(a) {
  return a;
}
var PatchProto3 = {
  ...Structural.prototype,
  [HashMapPatchTypeId]: {
    _Value: variance3,
    _Key: variance3,
    _Patch: variance3
  }
};
var EmptyProto3 = Object.assign(Object.create(PatchProto3), {
  _tag: "Empty"
});
var _empty7 = Object.create(EmptyProto3);
var empty13 = () => _empty7;
var AndThenProto3 = Object.assign(Object.create(PatchProto3), {
  _tag: "AndThen"
});
var makeAndThen3 = (first5, second) => {
  const o = Object.create(AndThenProto3);
  o.first = first5;
  o.second = second;
  return o;
};
var AddProto = Object.assign(Object.create(PatchProto3), {
  _tag: "Add"
});
var makeAdd = (key, value8) => {
  const o = Object.create(AddProto);
  o.key = key;
  o.value = value8;
  return o;
};
var RemoveProto = Object.assign(Object.create(PatchProto3), {
  _tag: "Remove"
});
var makeRemove = (key) => {
  const o = Object.create(RemoveProto);
  o.key = key;
  return o;
};
var UpdateProto2 = Object.assign(Object.create(PatchProto3), {
  _tag: "Update"
});
var makeUpdate2 = (key, patch14) => {
  const o = Object.create(UpdateProto2);
  o.key = key;
  o.patch = patch14;
  return o;
};
var diff3 = (options) => {
  const [removed, patch14] = reduce6([options.oldValue, empty13()], ([map43, patch15], newValue, key) => {
    const option9 = get6(key)(map43);
    switch (option9._tag) {
      case "Some": {
        const valuePatch = options.differ.diff(option9.value, newValue);
        if (equals(valuePatch, options.differ.empty)) {
          return [remove6(key)(map43), patch15];
        }
        return [remove6(key)(map43), combine6(makeUpdate2(key, valuePatch))(patch15)];
      }
      case "None": {
        return [map43, combine6(makeAdd(key, newValue))(patch15)];
      }
    }
  })(options.newValue);
  return reduce6(patch14, (patch15, _, key) => combine6(makeRemove(key))(patch15))(removed);
};
var combine6 = dual(2, (self, that) => makeAndThen3(self, that));
var patch3 = dual(3, (self, oldValue, differ4) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let map43 = oldValue;
  let patches = of2(self);
  while (isNonEmpty2(patches)) {
    const head11 = headNonEmpty2(patches);
    const tail4 = tailNonEmpty2(patches);
    switch (head11._tag) {
      case "Empty": {
        patches = tail4;
        break;
      }
      case "AndThen": {
        patches = prepend2(head11.first)(prepend2(head11.second)(tail4));
        break;
      }
      case "Add": {
        map43 = set3(head11.key, head11.value)(map43);
        patches = tail4;
        break;
      }
      case "Remove": {
        map43 = remove6(head11.key)(map43);
        patches = tail4;
        break;
      }
      case "Update": {
        const option9 = get6(head11.key)(map43);
        if (option9._tag === "Some") {
          map43 = set3(head11.key, differ4.patch(head11.patch, option9.value))(map43);
        }
        patches = tail4;
        break;
      }
    }
  }
  return map43;
});

// ../node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
var HashSetPatchTypeId = Symbol.for("effect/DifferHashSetPatch");
function variance4(a) {
  return a;
}
var PatchProto4 = {
  ...Structural.prototype,
  [HashSetPatchTypeId]: {
    _Value: variance4,
    _Key: variance4,
    _Patch: variance4
  }
};
var EmptyProto4 = Object.assign(Object.create(PatchProto4), {
  _tag: "Empty"
});
var _empty8 = Object.create(EmptyProto4);
var empty14 = () => _empty8;
var AndThenProto4 = Object.assign(Object.create(PatchProto4), {
  _tag: "AndThen"
});
var makeAndThen4 = (first5, second) => {
  const o = Object.create(AndThenProto4);
  o.first = first5;
  o.second = second;
  return o;
};
var AddProto2 = Object.assign(Object.create(PatchProto4), {
  _tag: "Add"
});
var makeAdd2 = (value8) => {
  const o = Object.create(AddProto2);
  o.value = value8;
  return o;
};
var RemoveProto2 = Object.assign(Object.create(PatchProto4), {
  _tag: "Remove"
});
var makeRemove2 = (value8) => {
  const o = Object.create(RemoveProto2);
  o.value = value8;
  return o;
};
var diff4 = (oldValue, newValue) => {
  const [removed, patch14] = reduce5([oldValue, empty14()], ([set22, patch15], value8) => {
    if (has3(value8)(set22)) {
      return [remove5(value8)(set22), patch15];
    }
    return [set22, combine7(makeAdd2(value8))(patch15)];
  })(newValue);
  return reduce5(patch14, (patch15, value8) => combine7(makeRemove2(value8))(patch15))(removed);
};
var combine7 = dual(2, (self, that) => makeAndThen4(self, that));
var patch4 = dual(2, (self, oldValue) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let set22 = oldValue;
  let patches = of2(self);
  while (isNonEmpty2(patches)) {
    const head11 = headNonEmpty2(patches);
    const tail4 = tailNonEmpty2(patches);
    switch (head11._tag) {
      case "Empty": {
        patches = tail4;
        break;
      }
      case "AndThen": {
        patches = prepend2(head11.first)(prepend2(head11.second)(tail4));
        break;
      }
      case "Add": {
        set22 = add4(head11.value)(set22);
        patches = tail4;
        break;
      }
      case "Remove": {
        set22 = remove5(head11.value)(set22);
        patches = tail4;
      }
    }
  }
  return set22;
});

// ../node_modules/effect/dist/esm/internal/differ/orPatch.js
var OrPatchTypeId = Symbol.for("effect/DifferOrPatch");
function variance5(a) {
  return a;
}
var PatchProto5 = {
  ...Structural.prototype,
  [OrPatchTypeId]: {
    _Value: variance5,
    _Key: variance5,
    _Patch: variance5
  }
};
var EmptyProto5 = Object.assign(Object.create(PatchProto5), {
  _tag: "Empty"
});
var _empty9 = Object.create(EmptyProto5);
var empty15 = () => _empty9;
var AndThenProto5 = Object.assign(Object.create(PatchProto5), {
  _tag: "AndThen"
});
var makeAndThen5 = (first5, second) => {
  const o = Object.create(AndThenProto5);
  o.first = first5;
  o.second = second;
  return o;
};
var SetLeftProto = Object.assign(Object.create(PatchProto5), {
  _tag: "SetLeft"
});
var makeSetLeft = (value8) => {
  const o = Object.create(SetLeftProto);
  o.value = value8;
  return o;
};
var SetRightProto = Object.assign(Object.create(PatchProto5), {
  _tag: "SetRight"
});
var makeSetRight = (value8) => {
  const o = Object.create(SetRightProto);
  o.value = value8;
  return o;
};
var UpdateLeftProto = Object.assign(Object.create(PatchProto5), {
  _tag: "UpdateLeft"
});
var makeUpdateLeft = (patch14) => {
  const o = Object.create(UpdateLeftProto);
  o.patch = patch14;
  return o;
};
var UpdateRightProto = Object.assign(Object.create(PatchProto5), {
  _tag: "UpdateRight"
});
var makeUpdateRight = (patch14) => {
  const o = Object.create(UpdateRightProto);
  o.patch = patch14;
  return o;
};
var diff5 = (options) => {
  switch (options.oldValue._tag) {
    case "Left": {
      switch (options.newValue._tag) {
        case "Left": {
          const valuePatch = options.left.diff(options.oldValue.left, options.newValue.left);
          if (equals(valuePatch, options.left.empty)) {
            return empty15();
          }
          return makeUpdateLeft(valuePatch);
        }
        case "Right": {
          return makeSetRight(options.newValue.right);
        }
      }
    }
    case "Right": {
      switch (options.newValue._tag) {
        case "Left": {
          return makeSetLeft(options.newValue.left);
        }
        case "Right": {
          const valuePatch = options.right.diff(options.oldValue.right, options.newValue.right);
          if (equals(valuePatch, options.right.empty)) {
            return empty15();
          }
          return makeUpdateRight(valuePatch);
        }
      }
    }
  }
};
var combine8 = dual(2, (self, that) => makeAndThen5(self, that));
var patch5 = dual(2, (self, {
  left: left2,
  oldValue,
  right: right2
}) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let patches = of2(self);
  let result = oldValue;
  while (isNonEmpty2(patches)) {
    const head11 = headNonEmpty2(patches);
    const tail4 = tailNonEmpty2(patches);
    switch (head11._tag) {
      case "Empty": {
        patches = tail4;
        break;
      }
      case "AndThen": {
        patches = prepend2(head11.first)(prepend2(head11.second)(tail4));
        break;
      }
      case "UpdateLeft": {
        if (result._tag === "Left") {
          result = left(left2.patch(head11.patch, result.left));
        }
        patches = tail4;
        break;
      }
      case "UpdateRight": {
        if (result._tag === "Right") {
          result = right(right2.patch(head11.patch, result.right));
        }
        patches = tail4;
        break;
      }
      case "SetLeft": {
        result = left(head11.value);
        patches = tail4;
        break;
      }
      case "SetRight": {
        result = right(head11.value);
        patches = tail4;
        break;
      }
    }
  }
  return result;
});

// ../node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
var ReadonlyArrayPatchTypeId = Symbol.for("effect/DifferReadonlyArrayPatch");
function variance6(a) {
  return a;
}
var PatchProto6 = {
  ...Structural.prototype,
  [ReadonlyArrayPatchTypeId]: {
    _Value: variance6,
    _Patch: variance6
  }
};
var EmptyProto6 = Object.assign(Object.create(PatchProto6), {
  _tag: "Empty"
});
var _empty10 = Object.create(EmptyProto6);
var empty16 = () => _empty10;
var AndThenProto6 = Object.assign(Object.create(PatchProto6), {
  _tag: "AndThen"
});
var makeAndThen6 = (first5, second) => {
  const o = Object.create(AndThenProto6);
  o.first = first5;
  o.second = second;
  return o;
};
var AppendProto2 = Object.assign(Object.create(PatchProto6), {
  _tag: "Append"
});
var makeAppend2 = (values13) => {
  const o = Object.create(AppendProto2);
  o.values = values13;
  return o;
};
var SliceProto2 = Object.assign(Object.create(PatchProto6), {
  _tag: "Slice"
});
var makeSlice2 = (from, until) => {
  const o = Object.create(SliceProto2);
  o.from = from;
  o.until = until;
  return o;
};
var UpdateProto3 = Object.assign(Object.create(PatchProto6), {
  _tag: "Update"
});
var makeUpdate3 = (index, patch14) => {
  const o = Object.create(UpdateProto3);
  o.index = index;
  o.patch = patch14;
  return o;
};
var diff6 = (options) => {
  let i = 0;
  let patch14 = empty16();
  while (i < options.oldValue.length && i < options.newValue.length) {
    const oldElement = options.oldValue[i];
    const newElement = options.newValue[i];
    const valuePatch = options.differ.diff(oldElement, newElement);
    if (!equals(valuePatch, options.differ.empty)) {
      patch14 = combine9(patch14, makeUpdate3(i, valuePatch));
    }
    i = i + 1;
  }
  if (i < options.oldValue.length) {
    patch14 = combine9(patch14, makeSlice2(0, i));
  }
  if (i < options.newValue.length) {
    patch14 = combine9(patch14, makeAppend2(drop(i)(options.newValue)));
  }
  return patch14;
};
var combine9 = dual(2, (self, that) => makeAndThen6(self, that));
var patch6 = dual(3, (self, oldValue, differ4) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let readonlyArray3 = oldValue.slice();
  let patches = of(self);
  while (isNonEmptyArray(patches)) {
    const head11 = headNonEmpty(patches);
    const tail4 = tailNonEmpty(patches);
    switch (head11._tag) {
      case "Empty": {
        patches = tail4;
        break;
      }
      case "AndThen": {
        tail4.unshift(head11.first, head11.second);
        patches = tail4;
        break;
      }
      case "Append": {
        for (const value8 of head11.values) {
          readonlyArray3.push(value8);
        }
        patches = tail4;
        break;
      }
      case "Slice": {
        readonlyArray3 = readonlyArray3.slice(head11.from, head11.until);
        patches = tail4;
        break;
      }
      case "Update": {
        readonlyArray3[head11.index] = differ4.patch(head11.patch, readonlyArray3[head11.index]);
        patches = tail4;
        break;
      }
    }
  }
  return readonlyArray3;
});

// ../node_modules/effect/dist/esm/internal/differ.js
var DifferTypeId = Symbol.for("effect/Differ");
var DifferProto = {
  [DifferTypeId]: {
    _P: identity,
    _V: identity
  }
};
var make18 = (params) => {
  const differ4 = Object.create(DifferProto);
  differ4.empty = params.empty;
  differ4.diff = params.diff;
  differ4.combine = params.combine;
  differ4.patch = params.patch;
  return differ4;
};
var environment = () => make18({
  empty: empty12(),
  combine: (first5, second) => combine5(second)(first5),
  diff: (oldValue, newValue) => diff2(oldValue, newValue),
  patch: (patch14, oldValue) => patch2(oldValue)(patch14)
});
var chunk = (differ4) => make18({
  empty: empty11(),
  combine: (first5, second) => combine4(second)(first5),
  diff: (oldValue, newValue) => diff({
    oldValue,
    newValue,
    differ: differ4
  }),
  patch: (patch14, oldValue) => patch(oldValue, differ4)(patch14)
});
var hashMap = (differ4) => make18({
  empty: empty13(),
  combine: (first5, second) => combine6(second)(first5),
  diff: (oldValue, newValue) => diff3({
    oldValue,
    newValue,
    differ: differ4
  }),
  patch: (patch14, oldValue) => patch3(oldValue, differ4)(patch14)
});
var hashSet = () => make18({
  empty: empty14(),
  combine: (first5, second) => combine7(second)(first5),
  diff: (oldValue, newValue) => diff4(oldValue, newValue),
  patch: (patch14, oldValue) => patch4(oldValue)(patch14)
});
var orElseEither = dual(2, (self, that) => make18({
  empty: empty15(),
  combine: (first5, second) => combine8(first5, second),
  diff: (oldValue, newValue) => diff5({
    oldValue,
    newValue,
    left: self,
    right: that
  }),
  patch: (patch14, oldValue) => patch5(patch14, {
    oldValue,
    left: self,
    right: that
  })
}));
var readonlyArray = (differ4) => make18({
  empty: empty16(),
  combine: (first5, second) => combine9(first5, second),
  diff: (oldValue, newValue) => diff6({
    oldValue,
    newValue,
    differ: differ4
  }),
  patch: (patch14, oldValue) => patch6(patch14, oldValue, differ4)
});
var transform = dual(2, (self, {
  toNew,
  toOld
}) => make18({
  empty: self.empty,
  combine: (first5, second) => self.combine(first5, second),
  diff: (oldValue, newValue) => self.diff(toOld(oldValue), toOld(newValue)),
  patch: (patch14, oldValue) => toNew(self.patch(patch14, toOld(oldValue)))
}));
var update2 = () => updateWith((_, a) => a);
var updateWith = (f) => make18({
  empty: identity,
  combine: (first5, second) => {
    if (first5 === identity) {
      return second;
    }
    if (second === identity) {
      return first5;
    }
    return (a) => second(first5(a));
  },
  diff: (oldValue, newValue) => {
    if (equals(oldValue, newValue)) {
      return identity;
    }
    return constant(newValue);
  },
  patch: (patch14, oldValue) => f(oldValue, patch14(oldValue))
});
var zip3 = dual(2, (self, that) => make18({
  empty: [self.empty, that.empty],
  combine: (first5, second) => [self.combine(first5[0], second[0]), that.combine(first5[1], second[1])],
  diff: (oldValue, newValue) => [self.diff(oldValue[0], newValue[0]), that.diff(oldValue[1], newValue[1])],
  patch: (patch14, oldValue) => [self.patch(patch14[0], oldValue[0]), that.patch(patch14[1], oldValue[1])]
}));

// ../node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
var BIT_MASK = 255;
var BIT_SHIFT = 8;
var active = (patch14) => patch14 & BIT_MASK;
var enabled = (patch14) => patch14 >> BIT_SHIFT & BIT_MASK;
var make19 = (active2, enabled2) => (active2 & BIT_MASK) + ((enabled2 & active2 & BIT_MASK) << BIT_SHIFT);
var empty17 = make19(0, 0);
var enable = (flag) => make19(flag, flag);
var disable = (flag) => make19(flag, 0);
var isEmpty4 = (patch14) => patch14 === 0;
var isActive = dual(2, (self, flag) => (active(self) & flag) !== 0);
var isEnabled = dual(2, (self, flag) => (enabled(self) & flag) !== 0);
var isDisabled = dual(2, (self, flag) => (active(self) & flag) !== 0 && (enabled(self) & flag) === 0);
var exclude = dual(2, (self, flag) => make19(active(self) & ~flag, enabled(self)));
var both = dual(2, (self, that) => make19(active(self) | active(that), enabled(self) & enabled(that)));
var either = dual(2, (self, that) => make19(active(self) | active(that), enabled(self) | enabled(that)));
var andThen = dual(2, (self, that) => self | that);
var inverse = (patch14) => make19(enabled(patch14), invert(active(patch14)));
var invert = (n) => ~n >>> 0 & BIT_MASK;

// ../node_modules/effect/dist/esm/internal/runtimeFlags.js
var None2 = 0;
var Interruption = 1 << 0;
var OpSupervision = 1 << 1;
var RuntimeMetrics = 1 << 2;
var WindDown = 1 << 4;
var CooperativeYielding = 1 << 5;
var allFlags = [None2, Interruption, OpSupervision, RuntimeMetrics, WindDown, CooperativeYielding];
var print = (flag) => {
  switch (flag) {
    case CooperativeYielding: {
      return "CooperativeYielding";
    }
    case WindDown: {
      return "WindDown";
    }
    case RuntimeMetrics: {
      return "RuntimeMetrics";
    }
    case OpSupervision: {
      return "OpSupervision";
    }
    case Interruption: {
      return "Interruption";
    }
    case None2: {
      return "None";
    }
  }
};
var cooperativeYielding = (self) => isEnabled2(self, CooperativeYielding);
var disable2 = dual(2, (self, flag) => self & ~flag);
var disableAll = dual(2, (self, flags) => self & ~flags);
var enable2 = dual(2, (self, flag) => self | flag);
var enableAll = dual(2, (self, flags) => self | flags);
var interruptible = (self) => interruption(self) && !windDown(self);
var interruption = (self) => isEnabled2(self, Interruption);
var isDisabled2 = dual(2, (self, flag) => !isEnabled2(self, flag));
var isEnabled2 = dual(2, (self, flag) => (self & flag) !== 0);
var make20 = (...flags) => flags.reduce((a, b) => a | b, 0);
var none5 = make20(None2);
var opSupervision = (self) => isEnabled2(self, OpSupervision);
var render = (self) => {
  const active2 = [];
  allFlags.forEach((flag) => {
    if (isEnabled2(self, flag)) {
      active2.push(`${print(flag)}`);
    }
  });
  return `RuntimeFlags(${active2.join(", ")})`;
};
var runtimeMetrics = (self) => isEnabled2(self, RuntimeMetrics);
var toSet3 = (self) => new Set(allFlags.filter((flag) => isEnabled2(self, flag)));
var windDown = (self) => isEnabled2(self, WindDown);
var enabledSet = (self) => toSet3(active(self) & enabled(self));
var disabledSet = (self) => toSet3(active(self) & ~enabled(self));
var diff7 = dual(2, (self, that) => make19(self ^ that, that));
var patch7 = dual(2, (self, patch14) => self & (invert(active(patch14)) | enabled(patch14)) | active(patch14) & enabled(patch14));
var renderPatch = (self) => {
  const enabled2 = Array.from(enabledSet(self)).map((flag) => print(flag)).join(", ");
  const disabled = Array.from(disabledSet(self)).map((flag) => print(flag)).join(", ");
  return `RuntimeFlagsPatch(enabled = (${enabled2}), disabled = (${disabled}))`;
};
var differ = make18({
  empty: empty17,
  diff: (oldValue, newValue) => diff7(oldValue, newValue),
  combine: (first5, second) => andThen(second)(first5),
  patch: (_patch, oldValue) => patch7(oldValue, _patch)
});

// ../node_modules/effect/dist/esm/RuntimeFlagsPatch.js
var empty18 = empty17;
var make21 = make19;
var enable3 = enable;
var disable3 = disable;
var isEmpty5 = isEmpty4;
var isActive2 = isActive;
var isEnabled3 = isEnabled;
var isDisabled3 = isDisabled;
var includes = isActive;
var andThen2 = andThen;
var both2 = both;
var either2 = either;
var exclude2 = exclude;
var inverse2 = inverse;
var enabledSet2 = enabledSet;
var disabledSet2 = disabledSet;
var render2 = renderPatch;

// ../node_modules/effect/dist/esm/internal/blockedRequests.js
var empty19 = {
  _tag: "Empty"
};
var par = (self, that) => ({
  _tag: "Par",
  left: self,
  right: that
});
var seq = (self, that) => ({
  _tag: "Seq",
  left: self,
  right: that
});
var single = (dataSource, blockedRequest) => ({
  _tag: "Single",
  dataSource,
  blockedRequest
});
var MapRequestResolversReducer = (f) => ({
  emptyCase: () => empty19,
  parCase: (left2, right2) => par(left2, right2),
  seqCase: (left2, right2) => seq(left2, right2),
  singleCase: (dataSource, blockedRequest) => single(f(dataSource), blockedRequest)
});
var mapRequestResolvers = (self, f) => reduce8(self, MapRequestResolversReducer(f));
var reduce8 = (self, reducer) => {
  let input = of3(self);
  let output = empty10();
  while (isCons(input)) {
    const current2 = input.head;
    switch (current2._tag) {
      case "Empty": {
        output = cons(right(reducer.emptyCase()), output);
        input = input.tail;
        break;
      }
      case "Par": {
        output = cons(left({
          _tag: "ParCase"
        }), output);
        input = cons(current2.left, cons(current2.right, input.tail));
        break;
      }
      case "Seq": {
        output = cons(left({
          _tag: "SeqCase"
        }), output);
        input = cons(current2.left, cons(current2.right, input.tail));
        break;
      }
      case "Single": {
        const result2 = reducer.singleCase(current2.dataSource, current2.blockedRequest);
        output = cons(right(result2), output);
        input = input.tail;
        break;
      }
    }
  }
  const result = reduce7(output, empty10(), (acc, current2) => {
    switch (current2._tag) {
      case "Left": {
        const left2 = unsafeHead2(acc);
        const right2 = unsafeHead2(unsafeTail(acc));
        const tail4 = unsafeTail(unsafeTail(acc));
        switch (current2.left._tag) {
          case "ParCase": {
            return cons(reducer.parCase(left2, right2), tail4);
          }
          case "SeqCase": {
            return cons(reducer.seqCase(left2, right2), tail4);
          }
        }
      }
      case "Right": {
        return cons(current2.right, acc);
      }
    }
  });
  if (isNil(result)) {
    throw new Error("BUG: BlockedRequests.reduce - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return result.head;
};
var flatten3 = (self) => {
  let current2 = of3(self);
  let updated = empty10();
  while (1) {
    const [parallel6, sequential6] = reduce7(current2, [parallelCollectionEmpty(), empty10()], ([parallel7, sequential7], blockedRequest) => {
      const [par2, seq2] = step(blockedRequest);
      return [parallelCollectionCombine(parallel7, par2), appendAll3(sequential7, seq2)];
    });
    updated = merge4(updated, parallel6);
    if (isNil(sequential6)) {
      return reverse3(updated);
    }
    current2 = sequential6;
  }
  throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var step = (requests) => {
  let current2 = requests;
  let parallel6 = parallelCollectionEmpty();
  let stack = empty10();
  let sequential6 = empty10();
  while (1) {
    switch (current2._tag) {
      case "Empty": {
        if (isNil(stack)) {
          return [parallel6, sequential6];
        }
        current2 = stack.head;
        stack = stack.tail;
        break;
      }
      case "Par": {
        stack = cons(current2.right, stack);
        current2 = current2.left;
        break;
      }
      case "Seq": {
        const left2 = current2.left;
        const right2 = current2.right;
        switch (left2._tag) {
          case "Empty": {
            current2 = right2;
            break;
          }
          case "Par": {
            const l = left2.left;
            const r = left2.right;
            current2 = par(seq(l, right2), seq(r, right2));
            break;
          }
          case "Seq": {
            const l = left2.left;
            const r = left2.right;
            current2 = seq(l, seq(r, right2));
            break;
          }
          case "Single": {
            current2 = left2;
            sequential6 = cons(right2, sequential6);
            break;
          }
        }
        break;
      }
      case "Single": {
        parallel6 = parallelCollectionAdd(parallel6, current2);
        if (isNil(stack)) {
          return [parallel6, sequential6];
        }
        current2 = stack.head;
        stack = stack.tail;
        break;
      }
    }
  }
  throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var merge4 = (sequential6, parallel6) => {
  if (isNil(sequential6)) {
    return of3(parallelCollectionToSequentialCollection(parallel6));
  }
  if (parallelCollectionIsEmpty(parallel6)) {
    return sequential6;
  }
  const seqHeadKeys = sequentialCollectionKeys(sequential6.head);
  const parKeys = parallelCollectionKeys(parallel6);
  if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) {
    return cons(sequentialCollectionCombine(sequential6.head, parallelCollectionToSequentialCollection(parallel6)), sequential6.tail);
  }
  return cons(parallelCollectionToSequentialCollection(parallel6), sequential6);
};
var EntryTypeId = Symbol.for("effect/RequestBlock/Entry");
var _a4;
var EntryImpl = class {
  constructor(request2, result, listeners, ownerId, state) {
    __publicField(this, "request");
    __publicField(this, "result");
    __publicField(this, "listeners");
    __publicField(this, "ownerId");
    __publicField(this, "state");
    __publicField(this, _a4, blockedRequestVariance);
    this.request = request2;
    this.result = result;
    this.listeners = listeners;
    this.ownerId = ownerId;
    this.state = state;
  }
};
_a4 = EntryTypeId;
var blockedRequestVariance = {
  /* c8 ignore next */
  _R: (_) => _
};
var isEntry = (u) => hasProperty(u, EntryTypeId);
var makeEntry = (options) => new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state);
var RequestBlockParallelTypeId = Symbol.for("effect/RequestBlock/RequestBlockParallel");
var parallelVariance = {
  /* c8 ignore next */
  _R: (_) => _
};
var _a5;
var ParallelImpl = class {
  constructor(map43) {
    __publicField(this, "map");
    __publicField(this, _a5, parallelVariance);
    this.map = map43;
  }
};
_a5 = RequestBlockParallelTypeId;
var parallelCollectionEmpty = () => new ParallelImpl(empty9());
var parallelCollectionAdd = (self, blockedRequest) => new ParallelImpl(modifyAt2(self.map, blockedRequest.dataSource, (_) => orElseSome(map2(_, append2(blockedRequest.blockedRequest)), () => of2(blockedRequest.blockedRequest))));
var parallelCollectionCombine = (self, that) => new ParallelImpl(reduce6(self.map, that.map, (map43, value8, key) => set3(map43, key, match2(get6(map43, key), {
  onNone: () => value8,
  onSome: (other) => appendAll2(value8, other)
}))));
var parallelCollectionIsEmpty = (self) => isEmpty3(self.map);
var parallelCollectionKeys = (self) => Array.from(keys2(self.map));
var parallelCollectionToSequentialCollection = (self) => sequentialCollectionMake(map8(self.map, (x) => of2(x)));
var SequentialCollectionTypeId = Symbol.for("effect/RequestBlock/RequestBlockSequential");
var sequentialVariance = {
  /* c8 ignore next */
  _R: (_) => _
};
var _a6;
var SequentialImpl = class {
  constructor(map43) {
    __publicField(this, "map");
    __publicField(this, _a6, sequentialVariance);
    this.map = map43;
  }
};
_a6 = SequentialCollectionTypeId;
var sequentialCollectionMake = (map43) => new SequentialImpl(map43);
var sequentialCollectionCombine = (self, that) => new SequentialImpl(reduce6(that.map, self.map, (map43, value8, key) => set3(map43, key, match2(get6(map43, key), {
  onNone: () => empty5(),
  onSome: (a) => appendAll2(a, value8)
}))));
var sequentialCollectionKeys = (self) => Array.from(keys2(self.map));
var sequentialCollectionToChunk = (self) => Array.from(self.map);

// ../node_modules/effect/dist/esm/internal/errors.js
var getBugErrorMessage = (message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;

// ../node_modules/effect/dist/esm/internal/opCodes/cause.js
var OP_DIE = "Die";
var OP_EMPTY = "Empty";
var OP_FAIL = "Fail";
var OP_INTERRUPT = "Interrupt";
var OP_PARALLEL = "Parallel";
var OP_SEQUENTIAL = "Sequential";

// ../node_modules/effect/dist/esm/internal/cause.js
var CauseSymbolKey = "effect/Cause";
var CauseTypeId = Symbol.for(CauseSymbolKey);
var variance7 = {
  /* c8 ignore next */
  _E: (_) => _
};
var proto = {
  [CauseTypeId]: variance7,
  [symbol2]() {
    return pipe(hash(CauseSymbolKey), combine(hash(flattenCause(this))), cached(this));
  },
  [symbol3](that) {
    return isCause(that) && causeEquals(this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toJSON() {
    switch (this._tag) {
      case "Empty":
        return {
          _id: "Cause",
          _tag: this._tag
        };
      case "Die":
        return {
          _id: "Cause",
          _tag: this._tag,
          defect: toJSON(this.defect)
        };
      case "Interrupt":
        return {
          _id: "Cause",
          _tag: this._tag,
          fiberId: this.fiberId.toJSON()
        };
      case "Fail":
        return {
          _id: "Cause",
          _tag: this._tag,
          failure: toJSON(this.error)
        };
      case "Sequential":
      case "Parallel":
        return {
          _id: "Cause",
          _tag: this._tag,
          left: toJSON(this.left),
          right: toJSON(this.right)
        };
    }
  },
  toString() {
    return pretty(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var empty20 = (() => {
  const o = Object.create(proto);
  o._tag = OP_EMPTY;
  return o;
})();
var fail = (error4) => {
  const o = Object.create(proto);
  o._tag = OP_FAIL;
  o.error = error4;
  return o;
};
var die = (defect) => {
  const o = Object.create(proto);
  o._tag = OP_DIE;
  o.defect = defect;
  return o;
};
var interrupt = (fiberId5) => {
  const o = Object.create(proto);
  o._tag = OP_INTERRUPT;
  o.fiberId = fiberId5;
  return o;
};
var parallel = (left2, right2) => {
  const o = Object.create(proto);
  o._tag = OP_PARALLEL;
  o.left = left2;
  o.right = right2;
  return o;
};
var sequential = (left2, right2) => {
  const o = Object.create(proto);
  o._tag = OP_SEQUENTIAL;
  o.left = left2;
  o.right = right2;
  return o;
};
var isCause = (u) => hasProperty(u, CauseTypeId);
var isEmptyType = (self) => self._tag === OP_EMPTY;
var isFailType = (self) => self._tag === OP_FAIL;
var isDieType = (self) => self._tag === OP_DIE;
var isInterruptType = (self) => self._tag === OP_INTERRUPT;
var isSequentialType = (self) => self._tag === OP_SEQUENTIAL;
var isParallelType = (self) => self._tag === OP_PARALLEL;
var size7 = (self) => reduceWithContext(self, void 0, SizeCauseReducer);
var isEmpty6 = (self) => {
  if (self._tag === OP_EMPTY) {
    return true;
  }
  return reduce9(self, true, (acc, cause3) => {
    switch (cause3._tag) {
      case OP_EMPTY: {
        return some2(acc);
      }
      case OP_DIE:
      case OP_FAIL:
      case OP_INTERRUPT: {
        return some2(false);
      }
      default: {
        return none2();
      }
    }
  });
};
var isFailure = (self) => isSome(failureOption(self));
var isDie = (self) => isSome(dieOption(self));
var isInterrupted = (self) => isSome(interruptOption(self));
var isInterruptedOnly = (self) => reduceWithContext(void 0, IsInterruptedOnlyCauseReducer)(self);
var failures = (self) => reverse2(reduce9(self, empty5(), (list, cause3) => cause3._tag === OP_FAIL ? some2(pipe(list, prepend2(cause3.error))) : none2()));
var defects = (self) => reverse2(reduce9(self, empty5(), (list, cause3) => cause3._tag === OP_DIE ? some2(pipe(list, prepend2(cause3.defect))) : none2()));
var interruptors = (self) => reduce9(self, empty8(), (set22, cause3) => cause3._tag === OP_INTERRUPT ? some2(pipe(set22, add4(cause3.fiberId))) : none2());
var failureOption = (self) => find(self, (cause3) => cause3._tag === OP_FAIL ? some2(cause3.error) : none2());
var failureOrCause = (self) => {
  const option9 = failureOption(self);
  switch (option9._tag) {
    case "None": {
      return right(self);
    }
    case "Some": {
      return left(option9.value);
    }
  }
};
var dieOption = (self) => find(self, (cause3) => cause3._tag === OP_DIE ? some2(cause3.defect) : none2());
var flipCauseOption = (self) => match5(self, {
  onEmpty: some2(empty20),
  onFail: (failureOption3) => pipe(failureOption3, map2(fail)),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: (fiberId5) => some2(interrupt(fiberId5)),
  onSequential: (left2, right2) => {
    if (isSome(left2) && isSome(right2)) {
      return some2(sequential(left2.value, right2.value));
    }
    if (isNone(left2) && isSome(right2)) {
      return some2(right2.value);
    }
    if (isSome(left2) && isNone(right2)) {
      return some2(left2.value);
    }
    return none2();
  },
  onParallel: (left2, right2) => {
    if (isSome(left2) && isSome(right2)) {
      return some2(parallel(left2.value, right2.value));
    }
    if (isNone(left2) && isSome(right2)) {
      return some2(right2.value);
    }
    if (isSome(left2) && isNone(right2)) {
      return some2(left2.value);
    }
    return none2();
  }
});
var interruptOption = (self) => find(self, (cause3) => cause3._tag === OP_INTERRUPT ? some2(cause3.fiberId) : none2());
var keepDefects = (self) => match5(self, {
  onEmpty: none2(),
  onFail: () => none2(),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: () => none2(),
  onSequential: (left2, right2) => {
    if (isSome(left2) && isSome(right2)) {
      return some2(sequential(left2.value, right2.value));
    }
    if (isSome(left2) && isNone(right2)) {
      return some2(left2.value);
    }
    if (isNone(left2) && isSome(right2)) {
      return some2(right2.value);
    }
    return none2();
  },
  onParallel: (left2, right2) => {
    if (isSome(left2) && isSome(right2)) {
      return some2(parallel(left2.value, right2.value));
    }
    if (isSome(left2) && isNone(right2)) {
      return some2(left2.value);
    }
    if (isNone(left2) && isSome(right2)) {
      return some2(right2.value);
    }
    return none2();
  }
});
var keepDefectsAndElectFailures = (self) => match5(self, {
  onEmpty: none2(),
  onFail: (failure) => some2(die(failure)),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: () => none2(),
  onSequential: (left2, right2) => {
    if (isSome(left2) && isSome(right2)) {
      return some2(sequential(left2.value, right2.value));
    }
    if (isSome(left2) && isNone(right2)) {
      return some2(left2.value);
    }
    if (isNone(left2) && isSome(right2)) {
      return some2(right2.value);
    }
    return none2();
  },
  onParallel: (left2, right2) => {
    if (isSome(left2) && isSome(right2)) {
      return some2(parallel(left2.value, right2.value));
    }
    if (isSome(left2) && isNone(right2)) {
      return some2(left2.value);
    }
    if (isNone(left2) && isSome(right2)) {
      return some2(right2.value);
    }
    return none2();
  }
});
var linearize = (self) => match5(self, {
  onEmpty: empty8(),
  onFail: (error4) => make12(fail(error4)),
  onDie: (defect) => make12(die(defect)),
  onInterrupt: (fiberId5) => make12(interrupt(fiberId5)),
  onSequential: (leftSet, rightSet) => pipe(leftSet, flatMap6((leftCause) => pipe(rightSet, map7((rightCause) => sequential(leftCause, rightCause))))),
  onParallel: (leftSet, rightSet) => pipe(leftSet, flatMap6((leftCause) => pipe(rightSet, map7((rightCause) => parallel(leftCause, rightCause)))))
});
var stripFailures = (self) => match5(self, {
  onEmpty: empty20,
  onFail: () => empty20,
  onDie: (defect) => die(defect),
  onInterrupt: (fiberId5) => interrupt(fiberId5),
  onSequential: sequential,
  onParallel: parallel
});
var electFailures = (self) => match5(self, {
  onEmpty: empty20,
  onFail: (failure) => die(failure),
  onDie: (defect) => die(defect),
  onInterrupt: (fiberId5) => interrupt(fiberId5),
  onSequential: (left2, right2) => sequential(left2, right2),
  onParallel: (left2, right2) => parallel(left2, right2)
});
var stripSomeDefects = dual(2, (self, pf) => match5(self, {
  onEmpty: some2(empty20),
  onFail: (error4) => some2(fail(error4)),
  onDie: (defect) => {
    const option9 = pf(defect);
    return isSome(option9) ? none2() : some2(die(defect));
  },
  onInterrupt: (fiberId5) => some2(interrupt(fiberId5)),
  onSequential: (left2, right2) => {
    if (isSome(left2) && isSome(right2)) {
      return some2(sequential(left2.value, right2.value));
    }
    if (isSome(left2) && isNone(right2)) {
      return some2(left2.value);
    }
    if (isNone(left2) && isSome(right2)) {
      return some2(right2.value);
    }
    return none2();
  },
  onParallel: (left2, right2) => {
    if (isSome(left2) && isSome(right2)) {
      return some2(parallel(left2.value, right2.value));
    }
    if (isSome(left2) && isNone(right2)) {
      return some2(left2.value);
    }
    if (isNone(left2) && isSome(right2)) {
      return some2(right2.value);
    }
    return none2();
  }
}));
var as = dual(2, (self, error4) => map10(self, () => error4));
var map10 = dual(2, (self, f) => flatMap9(self, (e) => fail(f(e))));
var flatMap9 = dual(2, (self, f) => match5(self, {
  onEmpty: empty20,
  onFail: (error4) => f(error4),
  onDie: (defect) => die(defect),
  onInterrupt: (fiberId5) => interrupt(fiberId5),
  onSequential: (left2, right2) => sequential(left2, right2),
  onParallel: (left2, right2) => parallel(left2, right2)
}));
var flatten4 = (self) => flatMap9(self, identity);
var andThen3 = dual(2, (self, f) => isFunction(f) ? flatMap9(self, f) : flatMap9(self, () => f));
var contains4 = dual(2, (self, that) => {
  if (that._tag === OP_EMPTY || self === that) {
    return true;
  }
  return reduce9(self, false, (accumulator, cause3) => {
    return some2(accumulator || causeEquals(cause3, that));
  });
});
var causeEquals = (left2, right2) => {
  let leftStack = of2(left2);
  let rightStack = of2(right2);
  while (isNonEmpty2(leftStack) && isNonEmpty2(rightStack)) {
    const [leftParallel, leftSequential] = pipe(headNonEmpty2(leftStack), reduce9([empty8(), empty5()], ([parallel6, sequential6], cause3) => {
      const [par2, seq2] = evaluateCause(cause3);
      return some2([pipe(parallel6, union5(par2)), pipe(sequential6, appendAll2(seq2))]);
    }));
    const [rightParallel, rightSequential] = pipe(headNonEmpty2(rightStack), reduce9([empty8(), empty5()], ([parallel6, sequential6], cause3) => {
      const [par2, seq2] = evaluateCause(cause3);
      return some2([pipe(parallel6, union5(par2)), pipe(sequential6, appendAll2(seq2))]);
    }));
    if (!equals(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
};
var flattenCause = (cause3) => {
  return flattenCauseLoop(of2(cause3), empty5());
};
var flattenCauseLoop = (causes, flattened) => {
  while (1) {
    const [parallel6, sequential6] = pipe(causes, reduce([empty8(), empty5()], ([parallel7, sequential7], cause3) => {
      const [par2, seq2] = evaluateCause(cause3);
      return [pipe(parallel7, union5(par2)), pipe(sequential7, appendAll2(seq2))];
    }));
    const updated = size4(parallel6) > 0 ? pipe(flattened, prepend2(parallel6)) : flattened;
    if (isEmpty(sequential6)) {
      return reverse2(updated);
    }
    causes = sequential6;
    flattened = updated;
  }
  throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
};
var find = dual(2, (self, pf) => {
  const stack = [self];
  while (stack.length > 0) {
    const item = stack.pop();
    const option9 = pf(item);
    switch (option9._tag) {
      case "None": {
        switch (item._tag) {
          case OP_SEQUENTIAL:
          case OP_PARALLEL: {
            stack.push(item.right);
            stack.push(item.left);
            break;
          }
        }
        break;
      }
      case "Some": {
        return option9;
      }
    }
  }
  return none2();
});
var filter8 = dual(2, (self, predicate) => reduceWithContext(self, void 0, FilterCauseReducer(predicate)));
var evaluateCause = (self) => {
  let cause3 = self;
  const stack = [];
  let _parallel = empty8();
  let _sequential = empty5();
  while (cause3 !== void 0) {
    switch (cause3._tag) {
      case OP_EMPTY: {
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_FAIL: {
        _parallel = add4(_parallel, cause3.error);
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_DIE: {
        _parallel = add4(_parallel, cause3.defect);
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_INTERRUPT: {
        _parallel = add4(_parallel, cause3.fiberId);
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_SEQUENTIAL: {
        switch (cause3.left._tag) {
          case OP_EMPTY: {
            cause3 = cause3.right;
            break;
          }
          case OP_SEQUENTIAL: {
            cause3 = sequential(cause3.left.left, sequential(cause3.left.right, cause3.right));
            break;
          }
          case OP_PARALLEL: {
            cause3 = parallel(sequential(cause3.left.left, cause3.right), sequential(cause3.left.right, cause3.right));
            break;
          }
          default: {
            _sequential = prepend2(_sequential, cause3.right);
            cause3 = cause3.left;
            break;
          }
        }
        break;
      }
      case OP_PARALLEL: {
        stack.push(cause3.right);
        cause3 = cause3.left;
        break;
      }
    }
  }
  throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
};
var SizeCauseReducer = {
  emptyCase: () => 0,
  failCase: () => 1,
  dieCase: () => 1,
  interruptCase: () => 1,
  sequentialCase: (_, left2, right2) => left2 + right2,
  parallelCase: (_, left2, right2) => left2 + right2
};
var IsInterruptedOnlyCauseReducer = {
  emptyCase: constTrue,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: constTrue,
  sequentialCase: (_, left2, right2) => left2 && right2,
  parallelCase: (_, left2, right2) => left2 && right2
};
var FilterCauseReducer = (predicate) => ({
  emptyCase: () => empty20,
  failCase: (_, error4) => fail(error4),
  dieCase: (_, defect) => die(defect),
  interruptCase: (_, fiberId5) => interrupt(fiberId5),
  sequentialCase: (_, left2, right2) => {
    if (predicate(left2)) {
      if (predicate(right2)) {
        return sequential(left2, right2);
      }
      return left2;
    }
    if (predicate(right2)) {
      return right2;
    }
    return empty20;
  },
  parallelCase: (_, left2, right2) => {
    if (predicate(left2)) {
      if (predicate(right2)) {
        return parallel(left2, right2);
      }
      return left2;
    }
    if (predicate(right2)) {
      return right2;
    }
    return empty20;
  }
});
var OP_SEQUENTIAL_CASE = "SequentialCase";
var OP_PARALLEL_CASE = "ParallelCase";
var match5 = dual(2, (self, {
  onDie,
  onEmpty,
  onFail,
  onInterrupt: onInterrupt3,
  onParallel,
  onSequential
}) => {
  return reduceWithContext(self, void 0, {
    emptyCase: () => onEmpty,
    failCase: (_, error4) => onFail(error4),
    dieCase: (_, defect) => onDie(defect),
    interruptCase: (_, fiberId5) => onInterrupt3(fiberId5),
    sequentialCase: (_, left2, right2) => onSequential(left2, right2),
    parallelCase: (_, left2, right2) => onParallel(left2, right2)
  });
});
var reduce9 = dual(3, (self, zero3, pf) => {
  let accumulator = zero3;
  let cause3 = self;
  const causes = [];
  while (cause3 !== void 0) {
    const option9 = pf(accumulator, cause3);
    accumulator = isSome(option9) ? option9.value : accumulator;
    switch (cause3._tag) {
      case OP_SEQUENTIAL: {
        causes.push(cause3.right);
        cause3 = cause3.left;
        break;
      }
      case OP_PARALLEL: {
        causes.push(cause3.right);
        cause3 = cause3.left;
        break;
      }
      default: {
        cause3 = void 0;
        break;
      }
    }
    if (cause3 === void 0 && causes.length > 0) {
      cause3 = causes.pop();
    }
  }
  return accumulator;
});
var reduceWithContext = dual(3, (self, context13, reducer) => {
  const input = [self];
  const output = [];
  while (input.length > 0) {
    const cause3 = input.pop();
    switch (cause3._tag) {
      case OP_EMPTY: {
        output.push(right(reducer.emptyCase(context13)));
        break;
      }
      case OP_FAIL: {
        output.push(right(reducer.failCase(context13, cause3.error)));
        break;
      }
      case OP_DIE: {
        output.push(right(reducer.dieCase(context13, cause3.defect)));
        break;
      }
      case OP_INTERRUPT: {
        output.push(right(reducer.interruptCase(context13, cause3.fiberId)));
        break;
      }
      case OP_SEQUENTIAL: {
        input.push(cause3.right);
        input.push(cause3.left);
        output.push(left({
          _tag: OP_SEQUENTIAL_CASE
        }));
        break;
      }
      case OP_PARALLEL: {
        input.push(cause3.right);
        input.push(cause3.left);
        output.push(left({
          _tag: OP_PARALLEL_CASE
        }));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either13 = output.pop();
    switch (either13._tag) {
      case "Left": {
        switch (either13.left._tag) {
          case OP_SEQUENTIAL_CASE: {
            const left2 = accumulator.pop();
            const right2 = accumulator.pop();
            const value8 = reducer.sequentialCase(context13, left2, right2);
            accumulator.push(value8);
            break;
          }
          case OP_PARALLEL_CASE: {
            const left2 = accumulator.pop();
            const right2 = accumulator.pop();
            const value8 = reducer.parallelCase(context13, left2, right2);
            accumulator.push(value8);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either13.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var filterStack = (stack) => {
  const lines = stack.split("\n");
  const out = [];
  for (let i = 0; i < lines.length; i++) {
    out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1"));
    if (lines[i].includes("effect_instruction_i")) {
      return out.join("\n");
    }
  }
  return out.join("\n");
};
var pretty = (cause3) => {
  if (isInterruptedOnly(cause3)) {
    return "All fibers interrupted without errors.";
  }
  const final = prettyErrors(cause3).map((e) => {
    let message = e.message;
    if (e.stack) {
      message += `\r
${filterStack(e.stack)}`;
    }
    if (e.span) {
      let current2 = e.span;
      let i = 0;
      while (current2 && current2._tag === "Span" && i < 10) {
        message += `\r
    at ${current2.name}`;
        current2 = getOrUndefined(current2.parent);
        i++;
      }
    }
    return message;
  }).join("\r\n");
  return final;
};
var PrettyError = class {
  constructor(message, stack, span4) {
    __publicField(this, "message");
    __publicField(this, "stack");
    __publicField(this, "span");
    this.message = message;
    this.stack = stack;
    this.span = span4;
  }
  toJSON() {
    const out = {
      message: this.message
    };
    if (this.stack) {
      out.stack = this.stack;
    }
    if (this.span) {
      out.span = this.span;
    }
    return out;
  }
};
var prettyErrorMessage = (u) => {
  if (typeof u === "string") {
    return `Error: ${u}`;
  }
  try {
    if (hasProperty(u, "toString") && isFunction(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
      return u["toString"]();
    }
  } catch {
  }
  return `Error: ${JSON.stringify(u)}`;
};
var spanSymbol = Symbol.for("effect/SpanAnnotation");
var defaultRenderError = (error4) => {
  var _a91;
  const span4 = hasProperty(error4, spanSymbol) && error4[spanSymbol];
  if (error4 instanceof Error) {
    return new PrettyError(prettyErrorMessage(error4), (_a91 = error4.stack) == null ? void 0 : _a91.split("\n").filter((_) => _.match(/at (.*)/)).join("\n"), span4);
  }
  return new PrettyError(prettyErrorMessage(error4), void 0, span4);
};
var prettyErrors = (cause3) => reduceWithContext(cause3, void 0, {
  emptyCase: () => [],
  dieCase: (_, unknownError) => {
    return [defaultRenderError(unknownError)];
  },
  failCase: (_, error4) => {
    return [defaultRenderError(error4)];
  },
  interruptCase: () => [],
  parallelCase: (_, l, r) => [...l, ...r],
  sequentialCase: (_, l, r) => [...l, ...r]
});

// ../node_modules/effect/dist/esm/internal/opCodes/deferred.js
var OP_STATE_PENDING = "Pending";
var OP_STATE_DONE = "Done";

// ../node_modules/effect/dist/esm/internal/deferred.js
var DeferredSymbolKey = "effect/Deferred";
var DeferredTypeId = Symbol.for(DeferredSymbolKey);
var deferredVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var pending = (joiners) => {
  return {
    _tag: OP_STATE_PENDING,
    joiners
  };
};
var done = (effect4) => {
  return {
    _tag: OP_STATE_DONE,
    effect: effect4
  };
};

// ../node_modules/effect/dist/esm/internal/tracer.js
var TracerTypeId = Symbol.for("effect/Tracer");
var make22 = (options) => ({
  [TracerTypeId]: TracerTypeId,
  ...options
});
var tracerTag = GenericTag("effect/Tracer");
var spanTag = GenericTag("effect/ParentSpan");
var randomHexString = function() {
  const characters = "abcdef0123456789";
  const charactersLength = characters.length;
  return function(length3) {
    let result = "";
    for (let i = 0; i < length3; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  };
}();
var NativeSpan = class {
  constructor(name, parent, context13, links, startTime) {
    __publicField(this, "name");
    __publicField(this, "parent");
    __publicField(this, "context");
    __publicField(this, "links");
    __publicField(this, "startTime");
    __publicField(this, "_tag", "Span");
    __publicField(this, "spanId");
    __publicField(this, "traceId", "native");
    __publicField(this, "sampled", true);
    __publicField(this, "status");
    __publicField(this, "attributes");
    __publicField(this, "events", []);
    this.name = name;
    this.parent = parent;
    this.context = context13;
    this.links = links;
    this.startTime = startTime;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.attributes = /* @__PURE__ */ new Map();
    this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
    this.spanId = randomHexString(16);
  }
  end(endTime, exit3) {
    this.status = {
      _tag: "Ended",
      endTime,
      exit: exit3,
      startTime: this.status.startTime
    };
  }
  attribute(key, value8) {
    this.attributes.set(key, value8);
  }
  event(name, startTime, attributes) {
    this.events.push([name, startTime, attributes ?? {}]);
  }
};
var nativeTracer = make22({
  span: (name, parent, context13, links, startTime) => new NativeSpan(name, parent, context13, links, startTime),
  context: (f) => f()
});
var externalSpan = (options) => ({
  _tag: "ExternalSpan",
  spanId: options.spanId,
  traceId: options.traceId,
  sampled: options.sampled ?? true,
  context: options.context ?? empty4()
});

// ../node_modules/effect/dist/esm/internal/core.js
var EffectErrorSymbolKey = "effect/EffectError";
var EffectErrorTypeId = Symbol.for(EffectErrorSymbolKey);
var isEffectError = (u) => hasProperty(u, EffectErrorTypeId);
var makeEffectError = (cause3) => ({
  [EffectErrorTypeId]: EffectErrorTypeId,
  _tag: "EffectError",
  cause: cause3
});
var blocked = (blockedRequests, _continue3) => {
  const effect4 = new EffectPrimitive("Blocked");
  effect4.effect_instruction_i0 = blockedRequests;
  effect4.effect_instruction_i1 = _continue3;
  return effect4;
};
var runRequestBlock = (blockedRequests) => {
  const effect4 = new EffectPrimitive("RunBlocked");
  effect4.effect_instruction_i0 = blockedRequests;
  return effect4;
};
var EffectTypeId2 = Symbol.for("effect/Effect");
var RevertFlags = class {
  constructor(patch14, op) {
    __publicField(this, "patch");
    __publicField(this, "op");
    __publicField(this, "_op", OP_REVERT_FLAGS);
    this.patch = patch14;
    this.op = op;
  }
};
var _a7;
var EffectPrimitive = class {
  constructor(_op) {
    __publicField(this, "_op");
    __publicField(this, "effect_instruction_i0");
    __publicField(this, "effect_instruction_i1");
    __publicField(this, "effect_instruction_i2");
    __publicField(this, "trace");
    __publicField(this, _a7, effectVariance);
    this._op = _op;
  }
  [(_a7 = EffectTypeId2, symbol3)](that) {
    return this === that;
  }
  [symbol2]() {
    return cached(this, random(this));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Effect",
      _op: this._op,
      effect_instruction_i0: toJSON(this.effect_instruction_i0),
      effect_instruction_i1: toJSON(this.effect_instruction_i1),
      effect_instruction_i2: toJSON(this.effect_instruction_i2)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var _a8;
var EffectPrimitiveFailure = class {
  constructor(_op) {
    __publicField(this, "_op");
    __publicField(this, "effect_instruction_i0");
    __publicField(this, "effect_instruction_i1");
    __publicField(this, "effect_instruction_i2");
    __publicField(this, "trace");
    __publicField(this, _a8, effectVariance);
    this._op = _op;
    this._tag = _op;
  }
  [(_a8 = EffectTypeId2, symbol3)](that) {
    return this === that;
  }
  [symbol2]() {
    return cached(this, random(this));
  }
  get cause() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      cause: this.cause.toJSON()
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var _a9;
var EffectPrimitiveSuccess = class {
  constructor(_op) {
    __publicField(this, "_op");
    __publicField(this, "effect_instruction_i0");
    __publicField(this, "effect_instruction_i1");
    __publicField(this, "effect_instruction_i2");
    __publicField(this, "trace");
    __publicField(this, _a9, effectVariance);
    this._op = _op;
    this._tag = _op;
  }
  [(_a9 = EffectTypeId2, symbol3)](that) {
    return this === that;
  }
  [symbol2]() {
    return cached(this, random(this));
  }
  get value() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      value: toJSON(this.value)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var isEffect = (u) => hasProperty(u, EffectTypeId2);
var withFiberRuntime = (withRuntime) => {
  const effect4 = new EffectPrimitive(OP_WITH_RUNTIME);
  effect4.effect_instruction_i0 = withRuntime;
  return effect4;
};
var acquireUseRelease = dual(3, (acquire3, use2, release3) => uninterruptibleMask((restore) => flatMap10(acquire3, (a) => flatMap10(exit(suspend(() => restore(use2(a)))), (exit3) => {
  return suspend(() => release3(a, exit3)).pipe(matchCauseEffect({
    onFailure: (cause3) => {
      switch (exit3._tag) {
        case OP_FAILURE:
          return failCause(parallel(exit3.effect_instruction_i0, cause3));
        case OP_SUCCESS:
          return failCause(cause3);
      }
    },
    onSuccess: () => exit3
  }));
}))));
var as2 = dual(2, (self, value8) => flatMap10(self, () => succeed(value8)));
var asVoid = (self) => as2(self, void 0);
var custom = function() {
  const wrapper = new EffectPrimitive(OP_COMMIT);
  switch (arguments.length) {
    case 2: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.commit = arguments[1];
      break;
    }
    case 3: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.commit = arguments[2];
      break;
    }
    case 4: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.effect_instruction_i2 = arguments[2];
      wrapper.commit = arguments[3];
      break;
    }
    default: {
      throw new Error(getBugErrorMessage("you're not supposed to end up here"));
    }
  }
  return wrapper;
};
var async = (register, blockingOn = none4) => {
  return custom(register, function() {
    let backingResume = void 0;
    let pendingEffect = void 0;
    function proxyResume(effect5) {
      if (backingResume) {
        backingResume(effect5);
      } else if (pendingEffect === void 0) {
        pendingEffect = effect5;
      }
    }
    const effect4 = new EffectPrimitive(OP_ASYNC);
    effect4.effect_instruction_i0 = (resume2) => {
      backingResume = resume2;
      if (pendingEffect) {
        resume2(pendingEffect);
      }
    };
    effect4.effect_instruction_i1 = blockingOn;
    let cancelerRef = void 0;
    let controllerRef = void 0;
    if (this.effect_instruction_i0.length !== 1) {
      controllerRef = new AbortController();
      cancelerRef = this.effect_instruction_i0(proxyResume, controllerRef.signal);
    } else {
      cancelerRef = this.effect_instruction_i0(proxyResume);
    }
    return cancelerRef || controllerRef ? onInterrupt(effect4, (_) => {
      if (controllerRef) {
        controllerRef.abort();
      }
      return cancelerRef ?? void_;
    }) : effect4;
  });
};
var catchAllCause = dual(2, (self, f) => {
  const effect4 = new EffectPrimitive(OP_ON_FAILURE);
  effect4.effect_instruction_i0 = self;
  effect4.effect_instruction_i1 = f;
  return effect4;
});
var catchAll = dual(2, (self, f) => matchEffect(self, {
  onFailure: f,
  onSuccess: succeed
}));
var catchIf = dual(3, (self, predicate, f) => catchAllCause(self, (cause3) => {
  const either13 = failureOrCause(cause3);
  switch (either13._tag) {
    case "Left":
      return predicate(either13.left) ? f(either13.left) : failCause(cause3);
    case "Right":
      return failCause(either13.right);
  }
}));
var catchSome = dual(2, (self, pf) => catchAllCause(self, (cause3) => {
  const either13 = failureOrCause(cause3);
  switch (either13._tag) {
    case "Left":
      return pipe(pf(either13.left), getOrElse(() => failCause(cause3)));
    case "Right":
      return failCause(either13.right);
  }
}));
var checkInterruptible = (f) => withFiberRuntime((_, status3) => f(interruption(status3.runtimeFlags)));
var spanSymbol2 = Symbol.for("effect/SpanAnnotation");
var originalSymbol = Symbol.for("effect/OriginalAnnotation");
var originalInstance = (obj) => {
  if (hasProperty(obj, originalSymbol)) {
    return obj[originalSymbol];
  }
  return obj;
};
var capture = (obj, span4) => {
  if (isSome(span4)) {
    return new Proxy(obj, {
      has(target, p) {
        return p === spanSymbol2 || p === originalSymbol || p in target;
      },
      get(target, p) {
        if (p === spanSymbol2) {
          return span4.value;
        }
        if (p === originalSymbol) {
          return obj;
        }
        return target[p];
      }
    });
  }
  return obj;
};
var die2 = (defect) => isObject(defect) && !(spanSymbol2 in defect) ? withFiberRuntime((fiber) => failCause(die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(die(defect));
var dieMessage = (message) => failCauseSync(() => die(new RuntimeException(message)));
var dieSync = (evaluate3) => flatMap10(sync(evaluate3), die2);
var either3 = (self) => matchEffect(self, {
  onFailure: (e) => succeed(left(e)),
  onSuccess: (a) => succeed(right(a))
});
var exit = (self) => matchCause(self, {
  onFailure: exitFailCause,
  onSuccess: exitSucceed
});
var fail2 = (error4) => isObject(error4) && !(spanSymbol2 in error4) ? withFiberRuntime((fiber) => failCause(fail(capture(error4, currentSpanFromFiber(fiber))))) : failCause(fail(error4));
var failSync = (evaluate3) => flatMap10(sync(evaluate3), fail2);
var failCause = (cause3) => {
  const effect4 = new EffectPrimitiveFailure(OP_FAILURE);
  effect4.effect_instruction_i0 = cause3;
  return effect4;
};
var failCauseSync = (evaluate3) => flatMap10(sync(evaluate3), failCause);
var fiberId = withFiberRuntime((state) => succeed(state.id()));
var fiberIdWith = (f) => withFiberRuntime((state) => f(state.id()));
var flatMap10 = dual(2, (self, f) => {
  const effect4 = new EffectPrimitive(OP_ON_SUCCESS);
  effect4.effect_instruction_i0 = self;
  effect4.effect_instruction_i1 = f;
  return effect4;
});
var andThen4 = dual(2, (self, f) => flatMap10(self, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return b;
  } else if (isPromiseLike(b)) {
    return async((resume2) => {
      b.then((a2) => resume2(succeed(a2)), (e) => resume2(fail2(new UnknownException(e))));
    });
  }
  return succeed(b);
}));
var step2 = (self) => {
  const effect4 = new EffectPrimitive("OnStep");
  effect4.effect_instruction_i0 = self;
  return effect4;
};
var flatten5 = (self) => flatMap10(self, identity);
var flip = (self) => matchEffect(self, {
  onFailure: succeed,
  onSuccess: fail2
});
var matchCause = dual(2, (self, options) => matchCauseEffect(self, {
  onFailure: (cause3) => succeed(options.onFailure(cause3)),
  onSuccess: (a) => succeed(options.onSuccess(a))
}));
var matchCauseEffect = dual(2, (self, options) => {
  const effect4 = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
  effect4.effect_instruction_i0 = self;
  effect4.effect_instruction_i1 = options.onFailure;
  effect4.effect_instruction_i2 = options.onSuccess;
  return effect4;
});
var matchEffect = dual(2, (self, options) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const defects3 = defects(cause3);
    if (defects3.length > 0) {
      return failCause(electFailures(cause3));
    }
    const failures3 = failures(cause3);
    if (failures3.length > 0) {
      return options.onFailure(unsafeHead(failures3));
    }
    return failCause(cause3);
  },
  onSuccess: options.onSuccess
}));
var forEachSequential = dual(2, (self, f) => suspend(() => {
  const arr = fromIterable(self);
  const ret = allocate(arr.length);
  let i = 0;
  return as2(whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: (b) => {
      ret[i++] = b;
    }
  }), ret);
}));
var forEachSequentialDiscard = dual(2, (self, f) => suspend(() => {
  const arr = fromIterable(self);
  let i = 0;
  return whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: () => {
      i++;
    }
  });
}));
var if_ = dual((args) => typeof args[0] === "boolean" || isEffect(args[0]), (self, options) => isEffect(self) ? flatMap10(self, (b) => b ? options.onTrue() : options.onFalse()) : self ? options.onTrue() : options.onFalse());
var interrupt2 = flatMap10(fiberId, (fiberId5) => interruptWith(fiberId5));
var interruptWith = (fiberId5) => failCause(interrupt(fiberId5));
var interruptible2 = (self) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = enable3(Interruption);
  effect4.effect_instruction_i1 = () => self;
  return effect4;
};
var interruptibleMask = (f) => custom(f, function() {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = enable3(Interruption);
  effect4.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? this.effect_instruction_i0(interruptible2) : this.effect_instruction_i0(uninterruptible);
  return effect4;
});
var intoDeferred = dual(2, (self, deferred) => uninterruptibleMask((restore) => flatMap10(exit(restore(self)), (exit3) => deferredDone(deferred, exit3))));
var map11 = dual(2, (self, f) => flatMap10(self, (a) => sync(() => f(a))));
var mapBoth = dual(2, (self, options) => matchEffect(self, {
  onFailure: (e) => failSync(() => options.onFailure(e)),
  onSuccess: (a) => sync(() => options.onSuccess(a))
}));
var mapError = dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const either13 = failureOrCause(cause3);
    switch (either13._tag) {
      case "Left": {
        return failSync(() => f(either13.left));
      }
      case "Right": {
        return failCause(either13.right);
      }
    }
  },
  onSuccess: succeed
}));
var onError = dual(2, (self, cleanup) => onExit(self, (exit3) => exitIsSuccess(exit3) ? void_ : cleanup(exit3.effect_instruction_i0)));
var onExit = dual(2, (self, cleanup) => uninterruptibleMask((restore) => matchCauseEffect(restore(self), {
  onFailure: (cause1) => {
    const result = exitFailCause(cause1);
    return matchCauseEffect(cleanup(result), {
      onFailure: (cause22) => exitFailCause(sequential(cause1, cause22)),
      onSuccess: () => result
    });
  },
  onSuccess: (success) => {
    const result = exitSucceed(success);
    return zipRight(cleanup(result), result);
  }
})));
var onInterrupt = dual(2, (self, cleanup) => onExit(self, exitMatch({
  onFailure: (cause3) => isInterruptedOnly(cause3) ? asVoid(cleanup(interruptors(cause3))) : void_,
  onSuccess: () => void_
})));
var orElse2 = dual(2, (self, that) => attemptOrElse(self, that, succeed));
var orDie = (self) => orDieWith(self, identity);
var orDieWith = dual(2, (self, f) => matchEffect(self, {
  onFailure: (e) => die2(f(e)),
  onSuccess: succeed
}));
var partitionMap4 = (elements, f) => fromIterable(elements).reduceRight(([lefts, rights], current2) => {
  const either13 = f(current2);
  switch (either13._tag) {
    case "Left": {
      return [[either13.left, ...lefts], rights];
    }
    case "Right": {
      return [lefts, [either13.right, ...rights]];
    }
  }
}, [empty2(), empty2()]);
var runtimeFlags = withFiberRuntime((_, status3) => succeed(status3.runtimeFlags));
var succeed = (value8) => {
  const effect4 = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect4.effect_instruction_i0 = value8;
  return effect4;
};
var suspend = (effect4) => flatMap10(sync(effect4), identity);
var sync = (evaluate3) => {
  const effect4 = new EffectPrimitive(OP_SYNC);
  effect4.effect_instruction_i0 = evaluate3;
  return effect4;
};
var tap = dual(2, (self, f) => flatMap10(self, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return as2(b, a);
  } else if (isPromiseLike(b)) {
    return async((resume2) => {
      b.then((_) => resume2(succeed(a)), (e) => resume2(fail2(new UnknownException(e))));
    });
  }
  return succeed(a);
}));
var transplant = (f) => withFiberRuntime((state) => {
  const scopeOverride = state.getFiberRef(currentForkScopeOverride);
  const scope5 = pipe(scopeOverride, getOrElse(() => state.scope()));
  return f(fiberRefLocally(currentForkScopeOverride, some2(scope5)));
});
var attemptOrElse = dual(3, (self, that, onSuccess) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const defects3 = defects(cause3);
    if (defects3.length > 0) {
      return failCause(getOrThrow(keepDefectsAndElectFailures(cause3)));
    }
    return that();
  },
  onSuccess
}));
var uninterruptible = (self) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = disable3(Interruption);
  effect4.effect_instruction_i1 = () => self;
  return effect4;
};
var uninterruptibleMask = (f) => custom(f, function() {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = disable3(Interruption);
  effect4.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? this.effect_instruction_i0(interruptible2) : this.effect_instruction_i0(uninterruptible);
  return effect4;
});
var void_ = succeed(void 0);
var updateRuntimeFlags = (patch14) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = patch14;
  effect4.effect_instruction_i1 = void 0;
  return effect4;
};
var whenEffect = dual(2, (self, condition) => flatMap10(condition, (b) => {
  if (b) {
    return pipe(self, map11(some2));
  }
  return succeed(none2());
}));
var whileLoop = (options) => {
  const effect4 = new EffectPrimitive(OP_WHILE);
  effect4.effect_instruction_i0 = options.while;
  effect4.effect_instruction_i1 = options.body;
  effect4.effect_instruction_i2 = options.step;
  return effect4;
};
var withConcurrency = dual(2, (self, concurrency) => fiberRefLocally(self, currentConcurrency, concurrency));
var withRequestBatching = dual(2, (self, requestBatching) => fiberRefLocally(self, currentRequestBatching, requestBatching));
var withRuntimeFlags = dual(2, (self, update16) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = update16;
  effect4.effect_instruction_i1 = () => self;
  return effect4;
});
var withTracerEnabled = dual(2, (effect4, enabled2) => fiberRefLocally(effect4, currentTracerEnabled, enabled2));
var withTracerTiming = dual(2, (effect4, enabled2) => fiberRefLocally(effect4, currentTracerTimingEnabled, enabled2));
var yieldNow = (options) => {
  const effect4 = new EffectPrimitive(OP_YIELD);
  return typeof (options == null ? void 0 : options.priority) !== "undefined" ? withSchedulingPriority(effect4, options.priority) : effect4;
};
var zip4 = dual(2, (self, that) => flatMap10(self, (a) => map11(that, (b) => [a, b])));
var zipFlatten = dual(2, (self, that) => flatMap10(self, (a) => map11(that, (b) => [...a, b])));
var zipLeft = dual(2, (self, that) => flatMap10(self, (a) => as2(that, a)));
var zipRight = dual(2, (self, that) => flatMap10(self, () => that));
var zipWith3 = dual(3, (self, that, f) => flatMap10(self, (a) => map11(that, (b) => f(a, b))));
var never = async(() => {
  const interval = setInterval(() => {
  }, 2 ** 31 - 1);
  return sync(() => clearInterval(interval));
});
var interruptFiber = (self) => flatMap10(fiberId, (fiberId5) => pipe(self, interruptAsFiber(fiberId5)));
var interruptAsFiber = dual(2, (self, fiberId5) => flatMap10(self.interruptAsFork(fiberId5), () => self.await));
var logLevelAll = {
  _tag: "All",
  syslog: 0,
  label: "ALL",
  ordinal: Number.MIN_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelFatal = {
  _tag: "Fatal",
  syslog: 2,
  label: "FATAL",
  ordinal: 5e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelError = {
  _tag: "Error",
  syslog: 3,
  label: "ERROR",
  ordinal: 4e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelWarning = {
  _tag: "Warning",
  syslog: 4,
  label: "WARN",
  ordinal: 3e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelInfo = {
  _tag: "Info",
  syslog: 6,
  label: "INFO",
  ordinal: 2e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelDebug = {
  _tag: "Debug",
  syslog: 7,
  label: "DEBUG",
  ordinal: 1e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelTrace = {
  _tag: "Trace",
  syslog: 7,
  label: "TRACE",
  ordinal: 0,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelNone = {
  _tag: "None",
  syslog: 7,
  label: "OFF",
  ordinal: Number.MAX_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var allLogLevels = [logLevelAll, logLevelTrace, logLevelDebug, logLevelInfo, logLevelWarning, logLevelError, logLevelFatal, logLevelNone];
var FiberRefSymbolKey = "effect/FiberRef";
var FiberRefTypeId = Symbol.for(FiberRefSymbolKey);
var fiberRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var fiberRefGet = (self) => fiberRefModify(self, (a) => [a, a]);
var fiberRefGetAndSet = dual(2, (self, value8) => fiberRefModify(self, (v) => [v, value8]));
var fiberRefGetAndUpdate = dual(2, (self, f) => fiberRefModify(self, (v) => [v, f(v)]));
var fiberRefGetAndUpdateSome = dual(2, (self, pf) => fiberRefModify(self, (v) => [v, getOrElse(pf(v), () => v)]));
var fiberRefGetWith = dual(2, (self, f) => flatMap10(fiberRefGet(self), f));
var fiberRefSet = dual(2, (self, value8) => fiberRefModify(self, () => [void 0, value8]));
var fiberRefDelete = (self) => withFiberRuntime((state) => {
  state.unsafeDeleteFiberRef(self);
  return void_;
});
var fiberRefReset = (self) => fiberRefSet(self, self.initial);
var fiberRefModify = dual(2, (self, f) => withFiberRuntime((state) => {
  const [b, a] = f(state.getFiberRef(self));
  state.setFiberRef(self, a);
  return succeed(b);
}));
var fiberRefModifySome = (self, def, f) => fiberRefModify(self, (v) => getOrElse(f(v), () => [def, v]));
var fiberRefUpdate = dual(2, (self, f) => fiberRefModify(self, (v) => [void 0, f(v)]));
var fiberRefUpdateSome = dual(2, (self, pf) => fiberRefModify(self, (v) => [void 0, getOrElse(pf(v), () => v)]));
var fiberRefUpdateAndGet = dual(2, (self, f) => fiberRefModify(self, (v) => {
  const result = f(v);
  return [result, result];
}));
var fiberRefUpdateSomeAndGet = dual(2, (self, pf) => fiberRefModify(self, (v) => {
  const result = getOrElse(pf(v), () => v);
  return [result, result];
}));
var RequestResolverSymbolKey = "effect/RequestResolver";
var RequestResolverTypeId = Symbol.for(RequestResolverSymbolKey);
var requestResolverVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var _a10;
var RequestResolverImpl = class _RequestResolverImpl {
  constructor(runAll, target) {
    __publicField(this, "runAll");
    __publicField(this, "target");
    __publicField(this, _a10, requestResolverVariance);
    this.runAll = runAll;
    this.target = target;
    this.runAll = runAll;
  }
  [(_a10 = RequestResolverTypeId, symbol2)]() {
    return cached(this, this.target ? hash(this.target) : random(this));
  }
  [symbol3](that) {
    return this.target ? isRequestResolver(that) && equals(this.target, that.target) : this === that;
  }
  identified(...ids3) {
    return new _RequestResolverImpl(this.runAll, fromIterable2(ids3));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isRequestResolver = (u) => hasProperty(u, RequestResolverTypeId);
var resolverLocally = dual(3, (use2, self, value8) => new RequestResolverImpl((requests) => fiberRefLocally(use2.runAll(requests), self, value8), make8("Locally", use2, self, value8)));
var fiberRefLocally = dual(3, (use2, self, value8) => acquireUseRelease(zipLeft(fiberRefGet(self), fiberRefSet(self, value8)), () => use2, (oldValue) => fiberRefSet(self, oldValue)));
var fiberRefLocallyWith = dual(3, (use2, self, f) => fiberRefGetWith(self, (a) => fiberRefLocally(use2, self, f(a))));
var fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {
  differ: update2(),
  fork: (options == null ? void 0 : options.fork) ?? identity,
  join: options == null ? void 0 : options.join
});
var fiberRefUnsafeMakeHashSet = (initial) => {
  const differ4 = hashSet();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ4,
    fork: differ4.empty
  });
};
var fiberRefUnsafeMakeReadonlyArray = (initial) => {
  const differ4 = readonlyArray(update2());
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ4,
    fork: differ4.empty
  });
};
var fiberRefUnsafeMakeContext = (initial) => {
  const differ4 = environment();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ4,
    fork: differ4.empty
  });
};
var fiberRefUnsafeMakePatch = (initial, options) => ({
  [FiberRefTypeId]: fiberRefVariance,
  initial,
  diff: (oldValue, newValue) => options.differ.diff(oldValue, newValue),
  combine: (first5, second) => options.differ.combine(first5, second),
  patch: (patch14) => (oldValue) => options.differ.patch(patch14, oldValue),
  fork: options.fork,
  join: options.join ?? ((_, n) => n),
  pipe() {
    return pipeArguments(this, arguments);
  }
});
var fiberRefUnsafeMakeRuntimeFlags = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ,
  fork: differ.empty
});
var currentContext = globalValue(Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty4()));
var currentSchedulingPriority = globalValue(Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
var currentMaxOpsBeforeYield = globalValue(Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
var currentLogAnnotations = globalValue(Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty9()));
var currentLogLevel = globalValue(Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
var currentLogSpan = globalValue(Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty10()));
var withSchedulingPriority = dual(2, (self, scheduler) => fiberRefLocally(self, currentSchedulingPriority, scheduler));
var withMaxOpsBeforeYield = dual(2, (self, scheduler) => fiberRefLocally(self, currentMaxOpsBeforeYield, scheduler));
var currentConcurrency = globalValue(Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
var currentRequestBatching = globalValue(Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
var currentUnhandledErrorLogLevel = globalValue(Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelDebug)));
var withUnhandledErrorLogLevel = dual(2, (self, level) => fiberRefLocally(self, currentUnhandledErrorLogLevel, level));
var currentMetricLabels = globalValue(Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty2()));
var metricLabels = fiberRefGet(currentMetricLabels);
var currentForkScopeOverride = globalValue(Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none2(), {
  fork: () => none2(),
  join: (parent, _) => parent
}));
var currentInterruptedCause = globalValue(Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty20, {
  fork: () => empty20,
  join: (parent, _) => parent
}));
var currentTracerEnabled = globalValue(Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
var currentTracerTimingEnabled = globalValue(Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
var currentTracerSpanAnnotations = globalValue(Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty9()));
var currentTracerSpanLinks = globalValue(Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty5()));
var ScopeTypeId = Symbol.for("effect/Scope");
var CloseableScopeTypeId = Symbol.for("effect/CloseableScope");
var scopeAddFinalizer = (self, finalizer3) => self.addFinalizer(() => asVoid(finalizer3));
var scopeAddFinalizerExit = (self, finalizer3) => self.addFinalizer(finalizer3);
var scopeClose = (self, exit3) => self.close(exit3);
var scopeFork = (self, strategy) => self.fork(strategy);
var causeSquash = (self) => {
  return causeSquashWith(identity)(self);
};
var causeSquashWith = dual(2, (self, f) => {
  const option9 = pipe(self, failureOption, map2(f));
  switch (option9._tag) {
    case "None": {
      return pipe(defects(self), head2, match2({
        onNone: () => {
          const interrupts = fromIterable(interruptors(self)).flatMap((fiberId5) => fromIterable(ids2(fiberId5)).map((id3) => `#${id3}`));
          return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(", ")}` : void 0);
        },
        onSome: identity
      }));
    }
    case "Some": {
      return option9.value;
    }
  }
});
var YieldableError = function() {
  class YieldableError3 extends globalThis.Error {
    commit() {
      return fail2(this);
    }
    toString() {
      return this.message ? `${this.name}: ${this.message}` : this.name;
    }
    toJSON() {
      return {
        ...this
      };
    }
    [NodeInspectSymbol]() {
      const stack = this.stack;
      if (stack) {
        return `${this.toString()}
${stack.split("\n").slice(1).join("\n")}`;
      }
      return this.toString();
    }
  }
  Object.assign(YieldableError3.prototype, StructuralCommitPrototype);
  return YieldableError3;
}();
var makeException = (proto14, tag4) => {
  class Base3 extends YieldableError {
    constructor() {
      super(...arguments);
      __publicField(this, "_tag", tag4);
    }
  }
  Object.assign(Base3.prototype, proto14);
  Base3.prototype.name = tag4;
  return Base3;
};
var RuntimeExceptionTypeId = Symbol.for("effect/Cause/errors/RuntimeException");
var RuntimeException = makeException({
  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}, "RuntimeException");
var isRuntimeException = (u) => hasProperty(u, RuntimeExceptionTypeId);
var InterruptedExceptionTypeId = Symbol.for("effect/Cause/errors/InterruptedException");
var InterruptedException = makeException({
  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}, "InterruptedException");
var isInterruptedException = (u) => hasProperty(u, InterruptedExceptionTypeId);
var IllegalArgumentExceptionTypeId = Symbol.for("effect/Cause/errors/IllegalArgument");
var IllegalArgumentException = makeException({
  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
}, "IllegalArgumentException");
var isIllegalArgumentException = (u) => hasProperty(u, IllegalArgumentExceptionTypeId);
var NoSuchElementExceptionTypeId = Symbol.for("effect/Cause/errors/NoSuchElement");
var NoSuchElementException = makeException({
  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}, "NoSuchElementException");
var isNoSuchElementException = (u) => hasProperty(u, NoSuchElementExceptionTypeId);
var InvalidPubSubCapacityExceptionTypeId = Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
var InvalidPubSubCapacityException = makeException({
  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
}, "InvalidPubSubCapacityException");
var TimeoutExceptionTypeId = Symbol.for("effect/Cause/errors/Timeout");
var TimeoutException = makeException({
  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}, "TimeoutException");
var UnknownExceptionTypeId = Symbol.for("effect/Cause/errors/UnknownException");
var UnknownException = function() {
  class UnknownException3 extends YieldableError {
    constructor(error4, message) {
      super(message ?? (hasProperty(error4, "message") && isString(error4.message) ? error4.message : void 0));
      __publicField(this, "error");
      __publicField(this, "_tag", "UnknownException");
      this.error = error4;
    }
  }
  Object.assign(UnknownException3.prototype, {
    [UnknownExceptionTypeId]: UnknownExceptionTypeId,
    name: "UnknownException"
  });
  return UnknownException3;
}();
var isUnknownException = (u) => hasProperty(u, UnknownExceptionTypeId);
var exitIsExit = (u) => isEffect(u) && "_tag" in u && (u._tag === "Success" || u._tag === "Failure");
var exitIsFailure = (self) => self._tag === "Failure";
var exitIsSuccess = (self) => self._tag === "Success";
var exitIsInterrupted = (self) => {
  switch (self._tag) {
    case OP_FAILURE:
      return isInterrupted(self.effect_instruction_i0);
    case OP_SUCCESS:
      return false;
  }
};
var exitAs = dual(2, (self, value8) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return exitFailCause(self.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return exitSucceed(value8);
    }
  }
});
var exitAsVoid = (self) => exitAs(self, void 0);
var exitCauseOption = (self) => {
  switch (self._tag) {
    case OP_FAILURE:
      return some2(self.effect_instruction_i0);
    case OP_SUCCESS:
      return none2();
  }
};
var exitCollectAll = (exits, options) => exitCollectAllInternal(exits, (options == null ? void 0 : options.parallel) ? parallel : sequential);
var exitDie = (defect) => exitFailCause(die(defect));
var exitExists = dual(2, (self, refinement) => {
  switch (self._tag) {
    case OP_FAILURE:
      return false;
    case OP_SUCCESS:
      return refinement(self.effect_instruction_i0);
  }
});
var exitFail = (error4) => exitFailCause(fail(error4));
var exitFailCause = (cause3) => {
  const effect4 = new EffectPrimitiveFailure(OP_FAILURE);
  effect4.effect_instruction_i0 = cause3;
  return effect4;
};
var exitFlatMap = dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return exitFailCause(self.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return f(self.effect_instruction_i0);
    }
  }
});
var exitFlatMapEffect = dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return succeed(exitFailCause(self.effect_instruction_i0));
    }
    case OP_SUCCESS: {
      return f(self.effect_instruction_i0);
    }
  }
});
var exitFlatten = (self) => pipe(self, exitFlatMap(identity));
var exitForEachEffect = dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return succeed(exitFailCause(self.effect_instruction_i0));
    }
    case OP_SUCCESS: {
      return exit(f(self.effect_instruction_i0));
    }
  }
});
var exitFromEither = (either13) => {
  switch (either13._tag) {
    case "Left":
      return exitFail(either13.left);
    case "Right":
      return exitSucceed(either13.right);
  }
};
var exitFromOption = (option9) => {
  switch (option9._tag) {
    case "None":
      return exitFail(void 0);
    case "Some":
      return exitSucceed(option9.value);
  }
};
var exitGetOrElse = dual(2, (self, orElse22) => {
  switch (self._tag) {
    case OP_FAILURE:
      return orElse22(self.effect_instruction_i0);
    case OP_SUCCESS:
      return self.effect_instruction_i0;
  }
});
var exitInterrupt = (fiberId5) => exitFailCause(interrupt(fiberId5));
var exitMap = dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(self.effect_instruction_i0);
    case OP_SUCCESS:
      return exitSucceed(f(self.effect_instruction_i0));
  }
});
var exitMapBoth = dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(pipe(self.effect_instruction_i0, map10(onFailure)));
    case OP_SUCCESS:
      return exitSucceed(onSuccess(self.effect_instruction_i0));
  }
});
var exitMapError = dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(pipe(self.effect_instruction_i0, map10(f)));
    case OP_SUCCESS:
      return exitSucceed(self.effect_instruction_i0);
  }
});
var exitMapErrorCause = dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(f(self.effect_instruction_i0));
    case OP_SUCCESS:
      return exitSucceed(self.effect_instruction_i0);
  }
});
var exitMatch = dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
var exitMatchEffect = dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
var exitSucceed = (value8) => {
  const effect4 = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect4.effect_instruction_i0 = value8;
  return effect4;
};
var exitVoid = exitSucceed(void 0);
var exitZip = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, a2) => [a, a2],
  onFailure: sequential
}));
var exitZipLeft = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, _) => a,
  onFailure: sequential
}));
var exitZipRight = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (_, a2) => a2,
  onFailure: sequential
}));
var exitZipPar = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, a2) => [a, a2],
  onFailure: parallel
}));
var exitZipParLeft = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, _) => a,
  onFailure: parallel
}));
var exitZipParRight = dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (_, a2) => a2,
  onFailure: parallel
}));
var exitZipWith = dual(3, (self, that, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitFailCause(self.effect_instruction_i0);
        case OP_FAILURE: {
          return exitFailCause(onFailure(self.effect_instruction_i0, that.effect_instruction_i0));
        }
      }
    }
    case OP_SUCCESS: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitSucceed(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0));
        case OP_FAILURE:
          return exitFailCause(that.effect_instruction_i0);
      }
    }
  }
});
var exitCollectAllInternal = (exits, combineCauses) => {
  const list = fromIterable2(exits);
  if (!isNonEmpty2(list)) {
    return none2();
  }
  return pipe(tailNonEmpty2(list), reduce(pipe(headNonEmpty2(list), exitMap(of2)), (accumulator, current2) => pipe(accumulator, exitZipWith(current2, {
    onSuccess: (list2, value8) => pipe(list2, prepend2(value8)),
    onFailure: combineCauses
  }))), exitMap(reverse2), exitMap((chunk7) => toReadonlyArray(chunk7)), some2);
};
var deferredUnsafeMake = (fiberId5) => ({
  [DeferredTypeId]: deferredVariance,
  state: make13(pending([])),
  blockingOn: fiberId5,
  pipe() {
    return pipeArguments(this, arguments);
  }
});
var deferredMake = () => flatMap10(fiberId, (id3) => deferredMakeAs(id3));
var deferredMakeAs = (fiberId5) => sync(() => deferredUnsafeMake(fiberId5));
var deferredAwait = (self) => async((resume2) => {
  const state = get5(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return resume2(state.effect);
    }
    case OP_STATE_PENDING: {
      state.joiners.push(resume2);
      return deferredInterruptJoiner(self, resume2);
    }
  }
}, self.blockingOn);
var deferredComplete = dual(2, (self, effect4) => intoDeferred(effect4, self));
var deferredCompleteWith = dual(2, (self, effect4) => sync(() => {
  const state = get5(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return false;
    }
    case OP_STATE_PENDING: {
      set2(self.state, done(effect4));
      for (let i = 0, len = state.joiners.length; i < len; i++) {
        state.joiners[i](effect4);
      }
      return true;
    }
  }
}));
var deferredDone = dual(2, (self, exit3) => deferredCompleteWith(self, exit3));
var deferredFail = dual(2, (self, error4) => deferredCompleteWith(self, fail2(error4)));
var deferredFailSync = dual(2, (self, evaluate3) => deferredCompleteWith(self, failSync(evaluate3)));
var deferredFailCause = dual(2, (self, cause3) => deferredCompleteWith(self, failCause(cause3)));
var deferredFailCauseSync = dual(2, (self, evaluate3) => deferredCompleteWith(self, failCauseSync(evaluate3)));
var deferredDie = dual(2, (self, defect) => deferredCompleteWith(self, die2(defect)));
var deferredDieSync = dual(2, (self, evaluate3) => deferredCompleteWith(self, dieSync(evaluate3)));
var deferredInterrupt = (self) => flatMap10(fiberId, (fiberId5) => deferredCompleteWith(self, interruptWith(fiberId5)));
var deferredInterruptWith = dual(2, (self, fiberId5) => deferredCompleteWith(self, interruptWith(fiberId5)));
var deferredIsDone = (self) => sync(() => get5(self.state)._tag === OP_STATE_DONE);
var deferredPoll = (self) => sync(() => {
  const state = get5(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return some2(state.effect);
    }
    case OP_STATE_PENDING: {
      return none2();
    }
  }
});
var deferredSucceed = dual(2, (self, value8) => deferredCompleteWith(self, succeed(value8)));
var deferredSync = dual(2, (self, evaluate3) => deferredCompleteWith(self, sync(evaluate3)));
var deferredUnsafeDone = (self, effect4) => {
  const state = get5(self.state);
  if (state._tag === OP_STATE_PENDING) {
    set2(self.state, done(effect4));
    for (let i = 0, len = state.joiners.length; i < len; i++) {
      state.joiners[i](effect4);
    }
  }
};
var deferredInterruptJoiner = (self, joiner) => sync(() => {
  const state = get5(self.state);
  if (state._tag === OP_STATE_PENDING) {
    const index = state.joiners.indexOf(joiner);
    if (index >= 0) {
      state.joiners.splice(index, 1);
    }
  }
});
var constContext = fiberRefGet(currentContext);
var context = () => constContext;
var contextWithEffect = (f) => flatMap10(context(), f);
var provideContext = dual(2, (self, context13) => fiberRefLocally(currentContext, context13)(self));
var provideSomeContext = dual(2, (self, context13) => fiberRefLocallyWith(currentContext, (parent) => merge3(parent, context13))(self));
var mapInputContext = dual(2, (self, f) => contextWithEffect((context13) => provideContext(self, f(context13))));
var currentSpanFromFiber = (fiber) => {
  const span4 = fiber.getFiberRef(currentContext).unsafeMap.get(spanTag.key);
  return span4 !== void 0 && span4._tag === "Span" ? some2(span4) : none2();
};
var NoopSpanProto = {
  _tag: "Span",
  spanId: "noop",
  traceId: "noop",
  name: "noop",
  sampled: false,
  parent: none2(),
  context: empty4(),
  status: {
    _tag: "Ended",
    startTime: BigInt(0),
    endTime: BigInt(0),
    exit: exitVoid
  },
  attributes: /* @__PURE__ */ new Map(),
  links: [],
  attribute() {
  },
  event() {
  },
  end() {
  }
};
var noopSpan = (name) => {
  const span4 = Object.create(NoopSpanProto);
  span4.name = name;
  return span4;
};

// ../node_modules/effect/dist/esm/Deferred.js
var DeferredTypeId2 = DeferredTypeId;
var make23 = deferredMake;
var makeAs = deferredMakeAs;
var _await = deferredAwait;
var complete = deferredComplete;
var completeWith = deferredCompleteWith;
var done2 = deferredDone;
var fail3 = deferredFail;
var failSync2 = deferredFailSync;
var failCause2 = deferredFailCause;
var failCauseSync2 = deferredFailCauseSync;
var die3 = deferredDie;
var dieSync2 = deferredDieSync;
var interrupt3 = deferredInterrupt;
var interruptWith2 = deferredInterruptWith;
var isDone = deferredIsDone;
var poll = deferredPoll;
var succeed2 = deferredSucceed;
var sync2 = deferredSync;
var unsafeMake4 = deferredUnsafeMake;
var unsafeDone = deferredUnsafeDone;

// ../node_modules/effect/dist/esm/Duration.js
var Duration_exports = {};
__export(Duration_exports, {
  Equivalence: () => Equivalence4,
  Order: () => Order5,
  between: () => between4,
  clamp: () => clamp4,
  days: () => days,
  decode: () => decode,
  decodeUnknown: () => decodeUnknown,
  divide: () => divide3,
  equals: () => equals3,
  format: () => format3,
  greaterThan: () => greaterThan4,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo4,
  hours: () => hours,
  infinity: () => infinity,
  isDuration: () => isDuration,
  isFinite: () => isFinite,
  lessThan: () => lessThan4,
  lessThanOrEqualTo: () => lessThanOrEqualTo4,
  match: () => match6,
  matchWith: () => matchWith,
  max: () => max4,
  micros: () => micros,
  millis: () => millis,
  min: () => min4,
  minutes: () => minutes,
  nanos: () => nanos,
  seconds: () => seconds,
  subtract: () => subtract3,
  sum: () => sum3,
  times: () => times,
  toHrTime: () => toHrTime,
  toMillis: () => toMillis,
  toNanos: () => toNanos,
  toSeconds: () => toSeconds,
  unsafeDivide: () => unsafeDivide3,
  unsafeToNanos: () => unsafeToNanos,
  weeks: () => weeks,
  zero: () => zero2
});
var TypeId6 = Symbol.for("effect/Duration");
var bigint03 = BigInt(0);
var bigint24 = BigInt(24);
var bigint60 = BigInt(60);
var bigint1e3 = BigInt(1e3);
var bigint1e6 = BigInt(1e6);
var bigint1e9 = BigInt(1e9);
var DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
var decode = (input) => {
  if (isDuration(input)) {
    return input;
  } else if (isNumber(input)) {
    return millis(input);
  } else if (isBigInt(input)) {
    return nanos(input);
  } else if (Array.isArray(input)) {
    if (input.length === 2 && isNumber(input[0]) && isNumber(input[1])) {
      return nanos(BigInt(input[0]) * bigint1e9 + BigInt(input[1]));
    }
  } else if (isString(input)) {
    DURATION_REGEX.lastIndex = 0;
    const match38 = DURATION_REGEX.exec(input);
    if (match38) {
      const [_, valueStr, unit] = match38;
      const value8 = Number(valueStr);
      switch (unit) {
        case "nano":
        case "nanos":
          return nanos(BigInt(valueStr));
        case "micro":
        case "micros":
          return micros(BigInt(valueStr));
        case "milli":
        case "millis":
          return millis(value8);
        case "second":
        case "seconds":
          return seconds(value8);
        case "minute":
        case "minutes":
          return minutes(value8);
        case "hour":
        case "hours":
          return hours(value8);
        case "day":
        case "days":
          return days(value8);
        case "week":
        case "weeks":
          return weeks(value8);
      }
    }
  }
  throw new Error("Invalid DurationInput");
};
var decodeUnknown = liftThrowable(decode);
var zeroValue = {
  _tag: "Millis",
  millis: 0
};
var infinityValue = {
  _tag: "Infinity"
};
var DurationProto = {
  [TypeId6]: TypeId6,
  [symbol2]() {
    return cached(this, structure(this.value));
  },
  [symbol3](that) {
    return isDuration(that) && equals3(this, that);
  },
  toString() {
    return `Duration(${format3(this)})`;
  },
  toJSON() {
    switch (this.value._tag) {
      case "Millis":
        return {
          _id: "Duration",
          _tag: "Millis",
          millis: this.value.millis
        };
      case "Nanos":
        return {
          _id: "Duration",
          _tag: "Nanos",
          hrtime: toHrTime(this)
        };
      case "Infinity":
        return {
          _id: "Duration",
          _tag: "Infinity"
        };
    }
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make24 = (input) => {
  const duration5 = Object.create(DurationProto);
  if (isNumber(input)) {
    if (isNaN(input) || input <= 0) {
      duration5.value = zeroValue;
    } else if (!Number.isFinite(input)) {
      duration5.value = infinityValue;
    } else if (!Number.isInteger(input)) {
      duration5.value = {
        _tag: "Nanos",
        nanos: BigInt(Math.round(input * 1e6))
      };
    } else {
      duration5.value = {
        _tag: "Millis",
        millis: input
      };
    }
  } else if (input <= bigint03) {
    duration5.value = zeroValue;
  } else {
    duration5.value = {
      _tag: "Nanos",
      nanos: input
    };
  }
  return duration5;
};
var isDuration = (u) => hasProperty(u, TypeId6);
var isFinite = (self) => self.value._tag !== "Infinity";
var zero2 = make24(0);
var infinity = make24(Infinity);
var nanos = (nanos2) => make24(nanos2);
var micros = (micros2) => make24(micros2 * bigint1e3);
var millis = (millis2) => make24(millis2);
var seconds = (seconds2) => make24(seconds2 * 1e3);
var minutes = (minutes2) => make24(minutes2 * 6e4);
var hours = (hours2) => make24(hours2 * 36e5);
var days = (days2) => make24(days2 * 864e5);
var weeks = (weeks2) => make24(weeks2 * 6048e5);
var toMillis = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return Infinity;
    case "Nanos":
      return Number(_self.value.nanos) / 1e6;
    case "Millis":
      return _self.value.millis;
  }
};
var toSeconds = (self) => toMillis(self) / 1e3;
var toNanos = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return none2();
    case "Nanos":
      return some2(_self.value.nanos);
    case "Millis":
      return some2(BigInt(Math.round(_self.value.millis * 1e6)));
  }
};
var unsafeToNanos = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1e6));
  }
};
var toHrTime = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1e3), Math.round(_self.value.millis % 1e3 * 1e6)];
  }
};
var match6 = dual(2, (self, options) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Nanos":
      return options.onNanos(_self.value.nanos);
    case "Infinity":
      return options.onMillis(Infinity);
    case "Millis":
      return options.onMillis(_self.value.millis);
  }
});
var matchWith = dual(3, (self, that, options) => {
  const _self = decode(self);
  const _that = decode(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options.onMillis(toMillis(_self), toMillis(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
    return options.onNanos(selfNanos, thatNanos);
  }
  return options.onMillis(_self.value.millis, _that.value.millis);
});
var Order5 = make2((self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 < that2 ? -1 : self2 > that2 ? 1 : 0,
  onNanos: (self2, that2) => self2 < that2 ? -1 : self2 > that2 ? 1 : 0
}));
var between4 = between(mapInput2(Order5, decode));
var Equivalence4 = (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 === that2,
  onNanos: (self2, that2) => self2 === that2
});
var _min = min(Order5);
var min4 = dual(2, (self, that) => _min(decode(self), decode(that)));
var _max = max(Order5);
var max4 = dual(2, (self, that) => _max(decode(self), decode(that)));
var _clamp = clamp(Order5);
var clamp4 = dual(2, (self, options) => _clamp(decode(self), {
  minimum: decode(options.minimum),
  maximum: decode(options.maximum)
}));
var divide3 = dual(2, (self, by) => match6(self, {
  onMillis: (millis2) => {
    if (by === 0 || isNaN(by) || !Number.isFinite(by)) {
      return none2();
    }
    return some2(make24(millis2 / by));
  },
  onNanos: (nanos2) => {
    if (isNaN(by) || by <= 0 || !Number.isFinite(by)) {
      return none2();
    }
    try {
      return some2(make24(nanos2 / BigInt(by)));
    } catch (e) {
      return none2();
    }
  }
}));
var unsafeDivide3 = dual(2, (self, by) => match6(self, {
  onMillis: (millis2) => make24(millis2 / by),
  onNanos: (nanos2) => {
    if (isNaN(by) || by < 0 || Object.is(by, -0)) {
      return zero2;
    } else if (Object.is(by, 0) || !Number.isFinite(by)) {
      return infinity;
    }
    return make24(nanos2 / BigInt(by));
  }
}));
var times = dual(2, (self, times2) => match6(self, {
  onMillis: (millis2) => make24(millis2 * times2),
  onNanos: (nanos2) => make24(nanos2 * BigInt(times2))
}));
var subtract3 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => make24(self2 - that2),
  onNanos: (self2, that2) => make24(self2 - that2)
}));
var sum3 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => make24(self2 + that2),
  onNanos: (self2, that2) => make24(self2 + that2)
}));
var lessThan4 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 < that2,
  onNanos: (self2, that2) => self2 < that2
}));
var lessThanOrEqualTo4 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 <= that2,
  onNanos: (self2, that2) => self2 <= that2
}));
var greaterThan4 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 > that2,
  onNanos: (self2, that2) => self2 > that2
}));
var greaterThanOrEqualTo4 = dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 >= that2,
  onNanos: (self2, that2) => self2 >= that2
}));
var equals3 = dual(2, (self, that) => Equivalence4(decode(self), decode(that)));
var format3 = (self) => {
  const duration5 = decode(self);
  const parts = [];
  if (duration5.value._tag === "Infinity") {
    return "Infinity";
  }
  const nanos2 = unsafeToNanos(duration5);
  if (nanos2 % bigint1e6) {
    parts.push(`${nanos2 % bigint1e6}ns`);
  }
  const ms = nanos2 / bigint1e6;
  if (ms % bigint1e3 !== bigint03) {
    parts.push(`${ms % bigint1e3}ms`);
  }
  const sec = ms / bigint1e3;
  if (sec % bigint60 !== bigint03) {
    parts.push(`${sec % bigint60}s`);
  }
  const min7 = sec / bigint60;
  if (min7 % bigint60 !== bigint03) {
    parts.push(`${min7 % bigint60}m`);
  }
  const hr = min7 / bigint60;
  if (hr % bigint24 !== bigint03) {
    parts.push(`${hr % bigint24}h`);
  }
  const days2 = hr / bigint24;
  if (days2 !== bigint03) {
    parts.push(`${days2}d`);
  }
  return parts.reverse().join(" ");
};

// ../node_modules/effect/dist/esm/Exit.js
var Exit_exports = {};
__export(Exit_exports, {
  all: () => all4,
  as: () => as3,
  asVoid: () => asVoid2,
  causeOption: () => causeOption,
  die: () => die4,
  exists: () => exists,
  fail: () => fail4,
  failCause: () => failCause3,
  flatMap: () => flatMap11,
  flatMapEffect: () => flatMapEffect,
  flatten: () => flatten6,
  forEachEffect: () => forEachEffect,
  fromEither: () => fromEither,
  fromOption: () => fromOption2,
  getOrElse: () => getOrElse4,
  interrupt: () => interrupt4,
  isExit: () => isExit,
  isFailure: () => isFailure2,
  isInterrupted: () => isInterrupted2,
  isSuccess: () => isSuccess,
  map: () => map12,
  mapBoth: () => mapBoth2,
  mapError: () => mapError2,
  mapErrorCause: () => mapErrorCause,
  match: () => match7,
  matchEffect: () => matchEffect2,
  succeed: () => succeed3,
  void: () => void_2,
  zip: () => zip5,
  zipLeft: () => zipLeft2,
  zipPar: () => zipPar,
  zipParLeft: () => zipParLeft,
  zipParRight: () => zipParRight,
  zipRight: () => zipRight2,
  zipWith: () => zipWith4
});
var isExit = exitIsExit;
var isFailure2 = exitIsFailure;
var isSuccess = exitIsSuccess;
var isInterrupted2 = exitIsInterrupted;
var as3 = exitAs;
var asVoid2 = exitAsVoid;
var causeOption = exitCauseOption;
var all4 = exitCollectAll;
var die4 = exitDie;
var exists = exitExists;
var fail4 = exitFail;
var failCause3 = exitFailCause;
var flatMap11 = exitFlatMap;
var flatMapEffect = exitFlatMapEffect;
var flatten6 = exitFlatten;
var forEachEffect = exitForEachEffect;
var fromEither = exitFromEither;
var fromOption2 = exitFromOption;
var getOrElse4 = exitGetOrElse;
var interrupt4 = exitInterrupt;
var map12 = exitMap;
var mapBoth2 = exitMapBoth;
var mapError2 = exitMapError;
var mapErrorCause = exitMapErrorCause;
var match7 = exitMatch;
var matchEffect2 = exitMatchEffect;
var succeed3 = exitSucceed;
var void_2 = exitVoid;
var zip5 = exitZip;
var zipLeft2 = exitZipLeft;
var zipRight2 = exitZipRight;
var zipPar = exitZipPar;
var zipParLeft = exitZipParLeft;
var zipParRight = exitZipParRight;
var zipWith4 = exitZipWith;

// ../node_modules/effect/dist/esm/MutableHashMap.js
var MutableHashMap_exports = {};
__export(MutableHashMap_exports, {
  clear: () => clear,
  empty: () => empty21,
  fromIterable: () => fromIterable8,
  get: () => get7,
  has: () => has5,
  make: () => make25,
  modify: () => modify4,
  modifyAt: () => modifyAt3,
  remove: () => remove7,
  set: () => set4,
  size: () => size8
});
var TypeId7 = Symbol.for("effect/MutableHashMap");
var MutableHashMapProto = {
  [TypeId7]: TypeId7,
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MutableHashMapIterator = class _MutableHashMapIterator {
  constructor(self) {
    __publicField(this, "self");
    __publicField(this, "referentialIterator");
    __publicField(this, "bucketIterator");
    this.self = self;
    this.referentialIterator = self.referential[Symbol.iterator]();
  }
  next() {
    if (this.bucketIterator !== void 0) {
      return this.bucketIterator.next();
    }
    const result = this.referentialIterator.next();
    if (result.done) {
      this.bucketIterator = new BucketIterator(this.self.buckets.values());
      return this.next();
    }
    return result;
  }
  [Symbol.iterator]() {
    return new _MutableHashMapIterator(this.self);
  }
};
var BucketIterator = class {
  constructor(backing) {
    __publicField(this, "backing");
    __publicField(this, "currentBucket");
    this.backing = backing;
  }
  next() {
    if (this.currentBucket === void 0) {
      const result2 = this.backing.next();
      if (result2.done) {
        return result2;
      }
      this.currentBucket = result2.value[Symbol.iterator]();
    }
    const result = this.currentBucket.next();
    if (result.done) {
      this.currentBucket = void 0;
      return this.next();
    }
    return result;
  }
};
var empty21 = () => {
  const self = Object.create(MutableHashMapProto);
  self.referential = /* @__PURE__ */ new Map();
  self.buckets = /* @__PURE__ */ new Map();
  self.bucketsSize = 0;
  return self;
};
var make25 = (...entries6) => fromIterable8(entries6);
var fromIterable8 = (entries6) => {
  const self = empty21();
  for (const [key, value8] of entries6) {
    set4(self, key, value8);
  }
  return self;
};
var get7 = dual(2, (self, key) => {
  if (isEqual(key) === false) {
    return self.referential.has(key) ? some2(self.referential.get(key)) : none2();
  }
  const hash3 = key[symbol2]();
  const bucket = self.buckets.get(hash3);
  if (bucket === void 0) {
    return none2();
  }
  return getFromBucket(self, bucket, key);
});
var getFromBucket = (self, bucket, key, remove20 = false) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol3](bucket[i][0])) {
      const value8 = bucket[i][1];
      if (remove20) {
        bucket.splice(i, 1);
        self.bucketsSize--;
      }
      return some2(value8);
    }
  }
  return none2();
};
var has5 = dual(2, (self, key) => isSome(get7(self, key)));
var set4 = dual(3, (self, key, value8) => {
  if (isEqual(key) === false) {
    self.referential.set(key, value8);
    return self;
  }
  const hash3 = key[symbol2]();
  const bucket = self.buckets.get(hash3);
  if (bucket === void 0) {
    self.buckets.set(hash3, [[key, value8]]);
    self.bucketsSize++;
    return self;
  }
  removeFromBucket(self, bucket, key);
  bucket.push([key, value8]);
  self.bucketsSize++;
  return self;
});
var removeFromBucket = (self, bucket, key) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol3](bucket[i][0])) {
      bucket.splice(i, 1);
      self.bucketsSize--;
      return;
    }
  }
};
var modify4 = dual(3, (self, key, f) => {
  if (isEqual(key) === false) {
    if (self.referential.has(key)) {
      self.referential.set(key, f(self.referential.get(key)));
    }
    return self;
  }
  const hash3 = key[symbol2]();
  const bucket = self.buckets.get(hash3);
  if (bucket === void 0) {
    return self;
  }
  const value8 = getFromBucket(self, bucket, key, true);
  if (isNone(value8)) {
    return self;
  }
  bucket.push([key, f(value8.value)]);
  self.bucketsSize++;
  return self;
});
var modifyAt3 = dual(3, (self, key, f) => {
  if (isEqual(key) === false) {
    const result2 = f(get7(self, key));
    if (isSome(result2)) {
      set4(self, key, result2.value);
    } else {
      remove7(self, key);
    }
    return self;
  }
  const hash3 = key[symbol2]();
  const bucket = self.buckets.get(hash3);
  if (bucket === void 0) {
    const result2 = f(none2());
    return isSome(result2) ? set4(self, key, result2.value) : self;
  }
  const result = f(getFromBucket(self, bucket, key, true));
  if (isNone(result)) {
    if (bucket.length === 0) {
      self.buckets.delete(hash3);
    }
    return self;
  }
  bucket.push([key, result.value]);
  self.bucketsSize++;
  return self;
});
var remove7 = dual(2, (self, key) => {
  if (isEqual(key) === false) {
    self.referential.delete(key);
    return self;
  }
  const hash3 = key[symbol2]();
  const bucket = self.buckets.get(hash3);
  if (bucket === void 0) {
    return self;
  }
  removeFromBucket(self, bucket, key);
  if (bucket.length === 0) {
    self.buckets.delete(hash3);
  }
  return self;
});
var clear = (self) => {
  self.referential.clear();
  self.buckets.clear();
  self.bucketsSize = 0;
  return self;
};
var size8 = (self) => {
  return self.referential.size + self.bucketsSize;
};

// ../node_modules/effect/dist/esm/MutableQueue.js
var MutableQueue_exports = {};
__export(MutableQueue_exports, {
  EmptyMutableQueue: () => EmptyMutableQueue,
  bounded: () => bounded,
  capacity: () => capacity,
  isEmpty: () => isEmpty8,
  isFull: () => isFull,
  length: () => length2,
  offer: () => offer,
  offerAll: () => offerAll,
  poll: () => poll2,
  pollUpTo: () => pollUpTo,
  unbounded: () => unbounded
});

// ../node_modules/effect/dist/esm/MutableList.js
var MutableList_exports = {};
__export(MutableList_exports, {
  append: () => append4,
  empty: () => empty22,
  forEach: () => forEach7,
  fromIterable: () => fromIterable9,
  head: () => head4,
  isEmpty: () => isEmpty7,
  length: () => length,
  make: () => make26,
  pop: () => pop,
  prepend: () => prepend4,
  reset: () => reset,
  shift: () => shift,
  tail: () => tail3
});
var TypeId8 = Symbol.for("effect/MutableList");
var MutableListProto = {
  [TypeId8]: TypeId8,
  [Symbol.iterator]() {
    let done17 = false;
    let head11 = this.head;
    return {
      next() {
        if (done17) {
          return this.return();
        }
        if (head11 == null) {
          done17 = true;
          return this.return();
        }
        const value8 = head11.value;
        head11 = head11.next;
        return {
          done: done17,
          value: value8
        };
      },
      return(value8) {
        if (!done17) {
          done17 = true;
        }
        return {
          done: true,
          value: value8
        };
      }
    };
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableList",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeNode = (value8) => ({
  value: value8,
  removed: false,
  prev: void 0,
  next: void 0
});
var empty22 = () => {
  const list = Object.create(MutableListProto);
  list.head = void 0;
  list.tail = void 0;
  list._length = 0;
  return list;
};
var fromIterable9 = (iterable) => {
  const list = empty22();
  for (const element of iterable) {
    append4(list, element);
  }
  return list;
};
var make26 = (...elements) => fromIterable9(elements);
var isEmpty7 = (self) => length(self) === 0;
var length = (self) => self._length;
var tail3 = (self) => self.tail === void 0 ? void 0 : self.tail.value;
var head4 = (self) => self.head === void 0 ? void 0 : self.head.value;
var forEach7 = dual(2, (self, f) => {
  let current2 = self.head;
  while (current2 !== void 0) {
    f(current2.value);
    current2 = current2.next;
  }
});
var reset = (self) => {
  ;
  self._length = 0;
  self.head = void 0;
  self.tail = void 0;
  return self;
};
var append4 = dual(2, (self, value8) => {
  const node = makeNode(value8);
  if (self.head === void 0) {
    self.head = node;
  }
  if (self.tail === void 0) {
    self.tail = node;
  } else {
    self.tail.next = node;
    node.prev = self.tail;
    self.tail = node;
  }
  ;
  self._length += 1;
  return self;
});
var shift = (self) => {
  const head11 = self.head;
  if (head11 !== void 0) {
    remove8(self, head11);
    return head11.value;
  }
  return void 0;
};
var pop = (self) => {
  const tail4 = self.tail;
  if (tail4 !== void 0) {
    remove8(self, tail4);
    return tail4.value;
  }
  return void 0;
};
var prepend4 = dual(2, (self, value8) => {
  const node = makeNode(value8);
  node.next = self.head;
  if (self.head !== void 0) {
    self.head.prev = node;
  }
  self.head = node;
  if (self.tail === void 0) {
    self.tail = node;
  }
  ;
  self._length += 1;
  return self;
});
var remove8 = (self, node) => {
  if (node.removed) {
    return;
  }
  node.removed = true;
  if (node.prev !== void 0 && node.next !== void 0) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  } else if (node.prev !== void 0) {
    self.tail = node.prev;
    node.prev.next = void 0;
  } else if (node.next !== void 0) {
    self.head = node.next;
    node.next.prev = void 0;
  } else {
    self.tail = void 0;
    self.head = void 0;
  }
  if (self._length > 0) {
    ;
    self._length -= 1;
  }
};

// ../node_modules/effect/dist/esm/MutableQueue.js
var TypeId9 = Symbol.for("effect/MutableQueue");
var EmptyMutableQueue = Symbol.for("effect/mutable/MutableQueue/Empty");
var MutableQueueProto = {
  [TypeId9]: TypeId9,
  [Symbol.iterator]() {
    return Array.from(this.queue)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableQueue",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make27 = (capacity10) => {
  const queue = Object.create(MutableQueueProto);
  queue.queue = empty22();
  queue.capacity = capacity10;
  return queue;
};
var bounded = (capacity10) => make27(capacity10);
var unbounded = () => make27(void 0);
var length2 = (self) => length(self.queue);
var isEmpty8 = (self) => isEmpty7(self.queue);
var isFull = (self) => self.capacity === void 0 ? false : length(self.queue) === self.capacity;
var capacity = (self) => self.capacity === void 0 ? Infinity : self.capacity;
var offer = dual(2, (self, value8) => {
  const queueLength = length(self.queue);
  if (self.capacity !== void 0 && queueLength === self.capacity) {
    return false;
  }
  append4(value8)(self.queue);
  return true;
});
var offerAll = dual(2, (self, values13) => {
  const iterator = values13[Symbol.iterator]();
  let next6;
  let remainder2 = empty5();
  let offering = true;
  while (offering && (next6 = iterator.next()) && !next6.done) {
    offering = offer(next6.value)(self);
  }
  while (next6 != null && !next6.done) {
    remainder2 = prepend2(next6.value)(remainder2);
    next6 = iterator.next();
  }
  return reverse2(remainder2);
});
var poll2 = dual(2, (self, def) => {
  if (isEmpty7(self.queue)) {
    return def;
  }
  return shift(self.queue);
});
var pollUpTo = dual(2, (self, n) => {
  let result = empty5();
  let count9 = 0;
  while (count9 < n) {
    const element = poll2(EmptyMutableQueue)(self);
    if (element === EmptyMutableQueue) {
      break;
    }
    result = prepend2(element)(result);
    count9 += 1;
  }
  return reverse2(result);
});

// ../node_modules/effect/dist/esm/Clock.js
var Clock_exports = {};
__export(Clock_exports, {
  Clock: () => Clock,
  ClockTypeId: () => ClockTypeId2,
  clockWith: () => clockWith2,
  currentTimeMillis: () => currentTimeMillis2,
  currentTimeNanos: () => currentTimeNanos2,
  make: () => make31,
  sleep: () => sleep2
});

// ../node_modules/effect/dist/esm/internal/clock.js
var ClockSymbolKey = "effect/Clock";
var ClockTypeId = Symbol.for(ClockSymbolKey);
var clockTag = GenericTag("effect/Clock");
var MAX_TIMER_MILLIS = 2 ** 31 - 1;
var globalClockScheduler = {
  unsafeSchedule(task, duration5) {
    const millis2 = toMillis(duration5);
    if (millis2 > MAX_TIMER_MILLIS) {
      return constFalse;
    }
    let completed = false;
    const handle = setTimeout(() => {
      completed = true;
      task();
    }, millis2);
    return () => {
      clearTimeout(handle);
      return !completed;
    };
  }
};
var performanceNowNanos = function() {
  const bigint1e62 = BigInt(1e6);
  if (typeof performance === "undefined") {
    return () => BigInt(Date.now()) * bigint1e62;
  }
  const origin = "timeOrigin" in performance && typeof performance.timeOrigin === "number" ? BigInt(Math.round(performance.timeOrigin * 1e6)) : BigInt(Date.now()) * bigint1e62 - BigInt(Math.round(performance.now() * 1e6));
  return () => origin + BigInt(Math.round(performance.now() * 1e6));
}();
var processOrPerformanceNow = function() {
  const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : void 0;
  if (!processHrtime) {
    return performanceNowNanos;
  }
  const origin = performanceNowNanos() - processHrtime.bigint();
  return () => origin + processHrtime.bigint();
}();
var _a11;
var ClockImpl = class {
  constructor() {
    __publicField(this, _a11, ClockTypeId);
    __publicField(this, "currentTimeMillis", sync(() => this.unsafeCurrentTimeMillis()));
    __publicField(this, "currentTimeNanos", sync(() => this.unsafeCurrentTimeNanos()));
  }
  unsafeCurrentTimeMillis() {
    return Date.now();
  }
  unsafeCurrentTimeNanos() {
    return processOrPerformanceNow();
  }
  scheduler() {
    return succeed(globalClockScheduler);
  }
  sleep(duration5) {
    return async((resume2) => {
      const canceler = globalClockScheduler.unsafeSchedule(() => resume2(void_), duration5);
      return asVoid(sync(canceler));
    });
  }
};
_a11 = ClockTypeId;
var make28 = () => new ClockImpl();

// ../node_modules/effect/dist/esm/RegExp.js
var RegExp_exports = {};
__export(RegExp_exports, {
  escape: () => escape
});
var escape = (string5) => string5.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");

// ../node_modules/effect/dist/esm/internal/opCodes/configError.js
var OP_AND = "And";
var OP_OR = "Or";
var OP_INVALID_DATA = "InvalidData";
var OP_MISSING_DATA = "MissingData";
var OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
var OP_UNSUPPORTED = "Unsupported";

// ../node_modules/effect/dist/esm/internal/configError.js
var ConfigErrorSymbolKey = "effect/ConfigError";
var ConfigErrorTypeId = Symbol.for(ConfigErrorSymbolKey);
var proto2 = {
  _tag: "ConfigError",
  [ConfigErrorTypeId]: ConfigErrorTypeId
};
var And = (self, that) => {
  const error4 = Object.create(proto2);
  error4._op = OP_AND;
  error4.left = self;
  error4.right = that;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      return `${this.left} and ${this.right}`;
    }
  });
  return error4;
};
var Or = (self, that) => {
  const error4 = Object.create(proto2);
  error4._op = OP_OR;
  error4.left = self;
  error4.right = that;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      return `${this.left} or ${this.right}`;
    }
  });
  return error4;
};
var InvalidData = (path, message, options = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto2);
  error4._op = OP_INVALID_DATA;
  error4.path = path;
  error4.message = message;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Invalid data at ${path2}: "${this.message}")`;
    }
  });
  return error4;
};
var MissingData = (path, message, options = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto2);
  error4._op = OP_MISSING_DATA;
  error4.path = path;
  error4.message = message;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Missing data at ${path2}: "${this.message}")`;
    }
  });
  return error4;
};
var SourceUnavailable = (path, message, cause3, options = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto2);
  error4._op = OP_SOURCE_UNAVAILABLE;
  error4.path = path;
  error4.message = message;
  error4.cause = cause3;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Source unavailable at ${path2}: "${this.message}")`;
    }
  });
  return error4;
};
var Unsupported = (path, message, options = {
  pathDelim: "."
}) => {
  const error4 = Object.create(proto2);
  error4._op = OP_UNSUPPORTED;
  error4.path = path;
  error4.message = message;
  Object.defineProperty(error4, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Unsupported operation at ${path2}: "${this.message}")`;
    }
  });
  return error4;
};
var isConfigError = (u) => hasProperty(u, ConfigErrorTypeId);
var isAnd = (self) => self._op === OP_AND;
var isOr = (self) => self._op === OP_OR;
var isInvalidData = (self) => self._op === OP_INVALID_DATA;
var isMissingData = (self) => self._op === OP_MISSING_DATA;
var isSourceUnavailable = (self) => self._op === OP_SOURCE_UNAVAILABLE;
var isUnsupported = (self) => self._op === OP_UNSUPPORTED;
var prefixed = dual(2, (self, prefix) => {
  switch (self._op) {
    case OP_AND: {
      return And(prefixed(self.left, prefix), prefixed(self.right, prefix));
    }
    case OP_OR: {
      return Or(prefixed(self.left, prefix), prefixed(self.right, prefix));
    }
    case OP_INVALID_DATA: {
      return InvalidData([...prefix, ...self.path], self.message);
    }
    case OP_MISSING_DATA: {
      return MissingData([...prefix, ...self.path], self.message);
    }
    case OP_SOURCE_UNAVAILABLE: {
      return SourceUnavailable([...prefix, ...self.path], self.message, self.cause);
    }
    case OP_UNSUPPORTED: {
      return Unsupported([...prefix, ...self.path], self.message);
    }
  }
});
var IsMissingDataOnlyReducer = {
  andCase: (_, left2, right2) => left2 && right2,
  orCase: (_, left2, right2) => left2 && right2,
  invalidDataCase: constFalse,
  missingDataCase: constTrue,
  sourceUnavailableCase: constFalse,
  unsupportedCase: constFalse
};
var reduceWithContext2 = dual(3, (self, context13, reducer) => {
  const input = [self];
  const output = [];
  while (input.length > 0) {
    const error4 = input.pop();
    switch (error4._op) {
      case OP_AND: {
        input.push(error4.right);
        input.push(error4.left);
        output.push(left({
          _op: "AndCase"
        }));
        break;
      }
      case OP_OR: {
        input.push(error4.right);
        input.push(error4.left);
        output.push(left({
          _op: "OrCase"
        }));
        break;
      }
      case OP_INVALID_DATA: {
        output.push(right(reducer.invalidDataCase(context13, error4.path, error4.message)));
        break;
      }
      case OP_MISSING_DATA: {
        output.push(right(reducer.missingDataCase(context13, error4.path, error4.message)));
        break;
      }
      case OP_SOURCE_UNAVAILABLE: {
        output.push(right(reducer.sourceUnavailableCase(context13, error4.path, error4.message, error4.cause)));
        break;
      }
      case OP_UNSUPPORTED: {
        output.push(right(reducer.unsupportedCase(context13, error4.path, error4.message)));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either13 = output.pop();
    switch (either13._op) {
      case "Left": {
        switch (either13.left._op) {
          case "AndCase": {
            const left2 = accumulator.pop();
            const right2 = accumulator.pop();
            const value8 = reducer.andCase(context13, left2, right2);
            accumulator.push(value8);
            break;
          }
          case "OrCase": {
            const left2 = accumulator.pop();
            const right2 = accumulator.pop();
            const value8 = reducer.orCase(context13, left2, right2);
            accumulator.push(value8);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either13.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: ConfigError.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var isMissingDataOnly = (self) => reduceWithContext2(self, void 0, IsMissingDataOnlyReducer);

// ../node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
var empty23 = {
  _tag: "Empty"
};
var andThen5 = dual(2, (self, that) => ({
  _tag: "AndThen",
  first: self,
  second: that
}));
var mapName = dual(2, (self, f) => andThen5(self, {
  _tag: "MapName",
  f
}));
var nested = dual(2, (self, name) => andThen5(self, {
  _tag: "Nested",
  name
}));
var unnested = dual(2, (self, name) => andThen5(self, {
  _tag: "Unnested",
  name
}));
var patch8 = dual(2, (path, patch14) => {
  let input = of3(patch14);
  let output = path;
  while (isCons(input)) {
    const patch15 = input.head;
    switch (patch15._tag) {
      case "Empty": {
        input = input.tail;
        break;
      }
      case "AndThen": {
        input = cons(patch15.first, cons(patch15.second, input.tail));
        break;
      }
      case "MapName": {
        output = map3(output, patch15.f);
        input = input.tail;
        break;
      }
      case "Nested": {
        output = prepend(output, patch15.name);
        input = input.tail;
        break;
      }
      case "Unnested": {
        const containsName = pipe(head(output), contains(patch15.name));
        if (containsName) {
          output = tailNonEmpty(output);
          input = input.tail;
        } else {
          return left(MissingData(output, `Expected ${patch15.name} to be in path in ConfigProvider#unnested`));
        }
        break;
      }
    }
  }
  return right(output);
});

// ../node_modules/effect/dist/esm/internal/opCodes/config.js
var OP_CONSTANT = "Constant";
var OP_FAIL2 = "Fail";
var OP_FALLBACK = "Fallback";
var OP_DESCRIBED = "Described";
var OP_LAZY = "Lazy";
var OP_MAP_OR_FAIL = "MapOrFail";
var OP_NESTED = "Nested";
var OP_PRIMITIVE = "Primitive";
var OP_SEQUENCE = "Sequence";
var OP_HASHMAP = "HashMap";
var OP_ZIP_WITH = "ZipWith";

// ../node_modules/effect/dist/esm/internal/string-utils.js
var lowerCase = (str) => str.toLowerCase();
var upperCase = (str) => str.toUpperCase();
var replace2 = (input, re, value8) => re instanceof RegExp ? input.replace(re, value8) : re.reduce((input2, re2) => input2.replace(re2, value8), input);
var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
var noCase = (input, options = {}) => {
  const {
    delimiter = " ",
    splitRegexp = DEFAULT_SPLIT_REGEXP,
    stripRegexp = DEFAULT_STRIP_REGEXP,
    transform: transform9 = lowerCase
  } = options;
  const result = replace2(replace2(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
  let start5 = 0;
  let end7 = result.length;
  while (result.charAt(start5) === "\0") {
    start5++;
  }
  while (result.charAt(end7 - 1) === "\0") {
    end7--;
  }
  return result.slice(start5, end7).split("\0").map(transform9).join(delimiter);
};
var constantCase = (input, options) => noCase(input, {
  delimiter: "_",
  transform: upperCase,
  ...options
});
var kebabCase = (input, options) => noCase(input, {
  delimiter: "-",
  ...options
});
var snakeCase = (input, options) => noCase(input, {
  delimiter: "_",
  ...options
});

// ../node_modules/effect/dist/esm/internal/configProvider.js
var concat = (l, r) => [...l, ...r];
var ConfigProviderSymbolKey = "effect/ConfigProvider";
var ConfigProviderTypeId = Symbol.for(ConfigProviderSymbolKey);
var configProviderTag = GenericTag("effect/ConfigProvider");
var FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
var FlatConfigProviderTypeId = Symbol.for(FlatConfigProviderSymbolKey);
var make29 = (options) => ({
  [ConfigProviderTypeId]: ConfigProviderTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
var makeFlat = (options) => ({
  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
  patch: options.patch,
  load: (path, config2, split4 = true) => options.load(path, config2, split4),
  enumerateChildren: options.enumerateChildren
});
var fromFlat = (flat) => make29({
  load: (config2) => flatMap10(fromFlatLoop(flat, empty2(), config2, false), (chunk7) => match2(head(chunk7), {
    onNone: () => fail2(MissingData(empty2(), `Expected a single value having structure: ${config2}`)),
    onSome: succeed
  })),
  flattened: flat
});
var fromEnv = (config2) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({}, {
    pathDelim: "_",
    seqDelim: ","
  }, config2);
  const makePathString = (path) => pipe(path, join(pathDelim));
  const unmakePathString = (pathString) => pathString.split(pathDelim);
  const getEnv = () => typeof process !== "undefined" && "env" in process && typeof process.env === "object" ? process.env : {};
  const load = (path, primitive3, split4 = true) => {
    const pathString = makePathString(path);
    const current2 = getEnv();
    const valueOpt = pathString in current2 ? some2(current2[pathString]) : none2();
    return pipe(valueOpt, mapError(() => MissingData(path, `Expected ${pathString} to exist in the process context`)), flatMap10((value8) => parsePrimitive(value8, path, primitive3, seqDelim, split4)));
  };
  const enumerateChildren = (path) => sync(() => {
    const current2 = getEnv();
    const keys10 = Object.keys(current2);
    const keyPaths = keys10.map((value8) => unmakePathString(value8.toUpperCase()));
    const filteredKeyPaths = keyPaths.filter((keyPath) => {
      for (let i = 0; i < path.length; i++) {
        const pathComponent = pipe(path, unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === void 0 || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1));
    return fromIterable5(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: empty23
  }));
};
var fromMap = (map43, config2) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({
    seqDelim: ",",
    pathDelim: "."
  }, config2);
  const makePathString = (path) => pipe(path, join(pathDelim));
  const unmakePathString = (pathString) => pathString.split(pathDelim);
  const mapWithIndexSplit = splitIndexInKeys(map43, (str) => unmakePathString(str), makePathString);
  const load = (path, primitive3, split4 = true) => {
    const pathString = makePathString(path);
    const valueOpt = mapWithIndexSplit.has(pathString) ? some2(mapWithIndexSplit.get(pathString)) : none2();
    return pipe(valueOpt, mapError(() => MissingData(path, `Expected ${pathString} to exist in the provided map`)), flatMap10((value8) => parsePrimitive(value8, path, primitive3, seqDelim, split4)));
  };
  const enumerateChildren = (path) => sync(() => {
    const keyPaths = fromIterable(mapWithIndexSplit.keys()).map(unmakePathString);
    const filteredKeyPaths = keyPaths.filter((keyPath) => {
      for (let i = 0; i < path.length; i++) {
        const pathComponent = pipe(path, unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === void 0 || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1));
    return fromIterable5(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: empty23
  }));
};
var extend = (leftDef, rightDef, left2, right2) => {
  const leftPad = unfold(left2.length, (index) => index >= right2.length ? none2() : some2([leftDef(index), index + 1]));
  const rightPad = unfold(right2.length, (index) => index >= left2.length ? none2() : some2([rightDef(index), index + 1]));
  const leftExtension = concat(left2, leftPad);
  const rightExtension = concat(right2, rightPad);
  return [leftExtension, rightExtension];
};
var appendConfigPath = (path, config2) => {
  let op = config2;
  if (op._tag === "Nested") {
    const out = path.slice();
    while (op._tag === "Nested") {
      out.push(op.name);
      op = op.config;
    }
    return out;
  }
  return path;
};
var fromFlatLoop = (flat, prefix, config2, split4) => {
  const op = config2;
  switch (op._tag) {
    case OP_CONSTANT: {
      return succeed(of(op.value));
    }
    case OP_DESCRIBED: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config, split4));
    }
    case OP_FAIL2: {
      return fail2(MissingData(prefix, op.message));
    }
    case OP_FALLBACK: {
      return pipe(suspend(() => fromFlatLoop(flat, prefix, op.first, split4)), catchAll((error1) => {
        if (op.condition(error1)) {
          return pipe(fromFlatLoop(flat, prefix, op.second, split4), catchAll((error22) => fail2(Or(error1, error22))));
        }
        return fail2(error1);
      }));
    }
    case OP_LAZY: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config(), split4));
    }
    case OP_MAP_OR_FAIL: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.original, split4), flatMap10(forEachSequential((a) => pipe(op.mapOrFail(a), mapError(prefixed(appendConfigPath(prefix, op.original))))))));
    }
    case OP_NESTED: {
      return suspend(() => fromFlatLoop(flat, concat(prefix, of(op.name)), op.config, split4));
    }
    case OP_PRIMITIVE: {
      return pipe(patch8(prefix, flat.patch), flatMap10((prefix2) => pipe(flat.load(prefix2, op, split4), flatMap10((values13) => {
        if (values13.length === 0) {
          const name = pipe(last(prefix2), getOrElse(() => "<n/a>"));
          return fail2(MissingData([], `Expected ${op.description} with name ${name}`));
        }
        return succeed(values13);
      }))));
    }
    case OP_SEQUENCE: {
      return pipe(patch8(prefix, flat.patch), flatMap10((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap10(indicesFrom), flatMap10((indices) => {
        if (indices.length === 0) {
          return suspend(() => map11(fromFlatLoop(flat, patchedPrefix, op.config, true), of));
        }
        return pipe(forEachSequential(indices, (index) => fromFlatLoop(flat, append(prefix, `[${index}]`), op.config, true)), map11((chunkChunk) => {
          const flattened = flatten(chunkChunk);
          if (flattened.length === 0) {
            return of(empty2());
          }
          return of(flattened);
        }));
      }))));
    }
    case OP_HASHMAP: {
      return suspend(() => pipe(patch8(prefix, flat.patch), flatMap10((prefix2) => pipe(flat.enumerateChildren(prefix2), flatMap10((keys10) => {
        return pipe(keys10, forEachSequential((key) => fromFlatLoop(flat, concat(prefix2, of(key)), op.valueConfig, split4)), map11((matrix) => {
          if (matrix.length === 0) {
            return of(empty9());
          }
          return pipe(transpose(matrix), map3((values13) => fromIterable6(zip(fromIterable(keys10), values13))));
        }));
      })))));
    }
    case OP_ZIP_WITH: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.left, split4), either3, flatMap10((left2) => pipe(fromFlatLoop(flat, prefix, op.right, split4), either3, flatMap10((right2) => {
        if (isLeft(left2) && isLeft(right2)) {
          return fail2(And(left2.left, right2.left));
        }
        if (isLeft(left2) && isRight(right2)) {
          return fail2(left2.left);
        }
        if (isRight(left2) && isLeft(right2)) {
          return fail2(right2.left);
        }
        if (isRight(left2) && isRight(right2)) {
          const path = pipe(prefix, join("."));
          const fail28 = fromFlatLoopFail(prefix, path);
          const [lefts, rights] = extend(fail28, fail28, pipe(left2.right, map3(right)), pipe(right2.right, map3(right)));
          return pipe(lefts, zip(rights), forEachSequential(([left3, right3]) => pipe(zip4(left3, right3), map11(([left4, right4]) => op.zip(left4, right4)))));
        }
        throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
      })))));
    }
  }
};
var fromFlatLoopFail = (prefix, path) => (index) => left(MissingData(prefix, `The element at index ${index} in a sequence at path "${path}" was missing`));
var mapInputPath = dual(2, (self, f) => fromFlat(mapInputPathFlat(self.flattened, f)));
var mapInputPathFlat = (self, f) => makeFlat({
  load: (path, config2, split4 = true) => self.load(path, config2, split4),
  enumerateChildren: (path) => self.enumerateChildren(path),
  patch: mapName(self.patch, f)
});
var nested2 = dual(2, (self, name) => fromFlat(makeFlat({
  load: (path, config2) => self.flattened.load(path, config2, true),
  enumerateChildren: (path) => self.flattened.enumerateChildren(path),
  patch: nested(self.flattened.patch, name)
})));
var unnested2 = dual(2, (self, name) => fromFlat(makeFlat({
  load: (path, config2) => self.flattened.load(path, config2, true),
  enumerateChildren: (path) => self.flattened.enumerateChildren(path),
  patch: unnested(self.flattened.patch, name)
})));
var orElse3 = dual(2, (self, that) => fromFlat(orElseFlat(self.flattened, () => that().flattened)));
var orElseFlat = (self, that) => makeFlat({
  load: (path, config2, split4) => pipe(patch8(path, self.patch), flatMap10((patch14) => self.load(patch14, config2, split4)), catchAll((error1) => pipe(sync(that), flatMap10((that2) => pipe(patch8(path, that2.patch), flatMap10((patch14) => that2.load(patch14, config2, split4)), catchAll((error22) => fail2(Or(error1, error22)))))))),
  enumerateChildren: (path) => pipe(patch8(path, self.patch), flatMap10((patch14) => self.enumerateChildren(patch14)), either3, flatMap10((left2) => pipe(sync(that), flatMap10((that2) => pipe(patch8(path, that2.patch), flatMap10((patch14) => that2.enumerateChildren(patch14)), either3, flatMap10((right2) => {
    if (isLeft(left2) && isLeft(right2)) {
      return fail2(And(left2.left, right2.left));
    }
    if (isLeft(left2) && isRight(right2)) {
      return succeed(right2.right);
    }
    if (isRight(left2) && isLeft(right2)) {
      return succeed(left2.right);
    }
    if (isRight(left2) && isRight(right2)) {
      return succeed(pipe(left2.right, union5(right2.right)));
    }
    throw new Error("BUG: ConfigProvider.orElseFlat - please report an issue at https://github.com/Effect-TS/effect/issues");
  })))))),
  patch: empty23
});
var constantCase2 = (self) => mapInputPath(self, constantCase);
var kebabCase2 = (self) => mapInputPath(self, kebabCase);
var lowerCase2 = (self) => mapInputPath(self, lowerCase);
var snakeCase2 = (self) => mapInputPath(self, snakeCase);
var upperCase2 = (self) => mapInputPath(self, upperCase);
var within = dual(3, (self, path, f) => {
  const unnest = reduce(path, self, (provider, name) => unnested2(provider, name));
  const nest = reduceRight(path, f(unnest), (provider, name) => nested2(provider, name));
  return orElse3(nest, () => self);
});
var splitPathString = (text, delim) => {
  const split4 = text.split(new RegExp(`\\s*${escape(delim)}\\s*`));
  return split4;
};
var parsePrimitive = (text, path, primitive3, delimiter, split4) => {
  if (!split4) {
    return pipe(primitive3.parse(text), mapBoth({
      onFailure: prefixed(path),
      onSuccess: of
    }));
  }
  return pipe(splitPathString(text, delimiter), forEachSequential((char) => primitive3.parse(char.trim())), mapError(prefixed(path)));
};
var transpose = (array6) => {
  return Object.keys(array6[0]).map((column) => array6.map((row) => row[column]));
};
var indicesFrom = (quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth({
  onFailure: () => empty2(),
  onSuccess: sort(Order)
}), either3, map11(merge));
var STR_INDEX_REGEX = /(^.+)(\[(\d+)\])$/;
var QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
var parseQuotedIndex = (str) => {
  const match38 = str.match(QUOTED_INDEX_REGEX);
  if (match38 !== null) {
    const matchedIndex = match38[2];
    return pipe(matchedIndex !== void 0 && matchedIndex.length > 0 ? some2(matchedIndex) : none2(), flatMap(parseInteger));
  }
  return none2();
};
var splitIndexInKeys = (map43, unmakePathString, makePathString) => {
  const newMap = /* @__PURE__ */ new Map();
  for (const [pathString, value8] of map43) {
    const keyWithIndex = pipe(unmakePathString(pathString), flatMap2((key) => match2(splitIndexFrom(key), {
      onNone: () => of(key),
      onSome: ([key2, index]) => make4(key2, `[${index}]`)
    })));
    newMap.set(makePathString(keyWithIndex), value8);
  }
  return newMap;
};
var splitIndexFrom = (key) => {
  const match38 = key.match(STR_INDEX_REGEX);
  if (match38 !== null) {
    const matchedString = match38[1];
    const matchedIndex = match38[3];
    const optionalString = matchedString !== void 0 && matchedString.length > 0 ? some2(matchedString) : none2();
    const optionalIndex = pipe(matchedIndex !== void 0 && matchedIndex.length > 0 ? some2(matchedIndex) : none2(), flatMap(parseInteger));
    return all2([optionalString, optionalIndex]);
  }
  return none2();
};
var parseInteger = (str) => {
  const parsedIndex = Number.parseInt(str);
  return Number.isNaN(parsedIndex) ? none2() : some2(parsedIndex);
};
var keyName = (name) => ({
  _tag: "KeyName",
  name
});
var keyIndex = (index) => ({
  _tag: "KeyIndex",
  index
});
var fromJson = (json2) => {
  const hiddenDelimiter = "\uFEFF";
  const indexedEntries = map3(getIndexedEntries(json2), ([key, value8]) => [configPathToString(key).join(hiddenDelimiter), value8]);
  return fromMap(new Map(indexedEntries), {
    pathDelim: hiddenDelimiter,
    seqDelim: hiddenDelimiter
  });
};
var configPathToString = (path) => {
  const output = [];
  let i = 0;
  while (i < path.length) {
    const component = path[i];
    if (component._tag === "KeyName") {
      if (i + 1 < path.length) {
        const nextComponent = path[i + 1];
        if (nextComponent._tag === "KeyIndex") {
          output.push(`${component.name}[${nextComponent.index}]`);
          i += 2;
        } else {
          output.push(component.name);
          i += 1;
        }
      } else {
        output.push(component.name);
        i += 1;
      }
    }
  }
  return output;
};
var getIndexedEntries = (config2) => {
  const loopAny = (path, value8) => {
    if (typeof value8 === "string") {
      return make4([path, value8]);
    }
    if (typeof value8 === "number" || typeof value8 === "boolean") {
      return make4([path, String(value8)]);
    }
    if (isArray(value8)) {
      return loopArray(path, value8);
    }
    if (typeof value8 === "object" && value8 !== null) {
      return loopObject(path, value8);
    }
    return empty2();
  };
  const loopArray = (path, values13) => match3(values13, {
    onEmpty: () => make4([path, "<nil>"]),
    onNonEmpty: flatMap2((value8, index) => loopAny(append(path, keyIndex(index)), value8))
  });
  const loopObject = (path, value8) => Object.entries(value8).flatMap(([key, value9]) => {
    const newPath = append(path, keyName(key));
    const result = loopAny(newPath, value9);
    if (isEmptyReadonlyArray(result)) {
      return make4([newPath, ""]);
    }
    return result;
  });
  return loopObject(empty2(), config2);
};

// ../node_modules/effect/dist/esm/internal/defaultServices/console.js
var TypeId10 = Symbol.for("effect/Console");
var consoleTag = GenericTag("effect/Console");
var defaultConsole = {
  [TypeId10]: TypeId10,
  assert(condition, ...args) {
    return sync(() => {
      console.assert(condition, ...args);
    });
  },
  clear: sync(() => {
    console.clear();
  }),
  count(label) {
    return sync(() => {
      console.count(label);
    });
  },
  countReset(label) {
    return sync(() => {
      console.countReset(label);
    });
  },
  debug(...args) {
    return sync(() => {
      console.debug(...args);
    });
  },
  dir(item, options) {
    return sync(() => {
      console.dir(item, options);
    });
  },
  dirxml(...args) {
    return sync(() => {
      console.dirxml(...args);
    });
  },
  error(...args) {
    return sync(() => {
      console.error(...args);
    });
  },
  group(options) {
    return (options == null ? void 0 : options.collapsed) ? sync(() => console.groupCollapsed(options == null ? void 0 : options.label)) : sync(() => console.group(options == null ? void 0 : options.label));
  },
  groupEnd: sync(() => {
    console.groupEnd();
  }),
  info(...args) {
    return sync(() => {
      console.info(...args);
    });
  },
  log(...args) {
    return sync(() => {
      console.log(...args);
    });
  },
  table(tabularData, properties) {
    return sync(() => {
      console.table(tabularData, properties);
    });
  },
  time(label) {
    return sync(() => console.time(label));
  },
  timeEnd(label) {
    return sync(() => console.timeEnd(label));
  },
  timeLog(label, ...args) {
    return sync(() => {
      console.timeLog(label, ...args);
    });
  },
  trace(...args) {
    return sync(() => {
      console.trace(...args);
    });
  },
  warn(...args) {
    return sync(() => {
      console.warn(...args);
    });
  },
  unsafe: console
};

// ../node_modules/effect/dist/esm/internal/random.js
var RandomSymbolKey = "effect/Random";
var RandomTypeId = Symbol.for(RandomSymbolKey);
var randomTag = GenericTag("effect/Random");
var _a12;
var RandomImpl = class {
  constructor(seed) {
    __publicField(this, "seed");
    __publicField(this, _a12, RandomTypeId);
    __publicField(this, "PRNG");
    this.seed = seed;
    this.PRNG = new PCGRandom(seed);
  }
  get next() {
    return sync(() => this.PRNG.number());
  }
  get nextBoolean() {
    return map11(this.next, (n) => n > 0.5);
  }
  get nextInt() {
    return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
  }
  nextRange(min7, max9) {
    return map11(this.next, (n) => (max9 - min7) * n + min7);
  }
  nextIntBetween(min7, max9) {
    return sync(() => this.PRNG.integer(max9 - min7) + min7);
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
};
_a12 = RandomTypeId;
var shuffleWith = (elements, nextIntBounded) => {
  return suspend(() => pipe(sync(() => Array.from(elements)), flatMap10((buffer5) => {
    const numbers = [];
    for (let i = buffer5.length; i >= 2; i = i - 1) {
      numbers.push(i);
    }
    return pipe(numbers, forEachSequentialDiscard((n) => pipe(nextIntBounded(n), map11((k) => swap(buffer5, n - 1, k)))), as2(fromIterable2(buffer5)));
  })));
};
var swap = (buffer5, index1, index2) => {
  const tmp = buffer5[index1];
  buffer5[index1] = buffer5[index2];
  buffer5[index2] = tmp;
  return buffer5;
};
var make30 = (seed) => new RandomImpl(seed);

// ../node_modules/effect/dist/esm/internal/defaultServices.js
var liveServices = pipe(empty4(), add2(clockTag, make28()), add2(consoleTag, defaultConsole), add2(randomTag, make30(Math.random() * 4294967296 >>> 0)), add2(configProviderTag, fromEnv()), add2(tracerTag, nativeTracer));
var currentServices = globalValue(Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
var sleep = (duration5) => {
  const decodedDuration = decode(duration5);
  return clockWith((clock3) => clock3.sleep(decodedDuration));
};
var clockWith = (f) => fiberRefGetWith(currentServices, (services) => f(get2(services, clockTag)));
var currentTimeMillis = clockWith((clock3) => clock3.currentTimeMillis);
var currentTimeNanos = clockWith((clock3) => clock3.currentTimeNanos);
var withClock = dual(2, (effect4, value8) => fiberRefLocallyWith(currentServices, add2(clockTag, value8))(effect4));
var withConfigProvider = dual(2, (effect4, value8) => fiberRefLocallyWith(currentServices, add2(configProviderTag, value8))(effect4));
var configProviderWith = (f) => fiberRefGetWith(currentServices, (services) => f(get2(services, configProviderTag)));
var config = (config2) => configProviderWith((_) => _.load(config2));
var randomWith = (f) => fiberRefGetWith(currentServices, (services) => f(get2(services, randomTag)));
var withRandom = dual(2, (effect4, value8) => fiberRefLocallyWith(currentServices, add2(randomTag, value8))(effect4));
var next = randomWith((random4) => random4.next);
var nextInt = randomWith((random4) => random4.nextInt);
var nextBoolean = randomWith((random4) => random4.nextBoolean);
var nextRange = (min7, max9) => randomWith((random4) => random4.nextRange(min7, max9));
var nextIntBetween = (min7, max9) => randomWith((random4) => random4.nextIntBetween(min7, max9));
var shuffle = (elements) => randomWith((random4) => random4.shuffle(elements));
var tracerWith = (f) => fiberRefGetWith(currentServices, (services) => f(get2(services, tracerTag)));
var withTracer = dual(2, (effect4, value8) => fiberRefLocallyWith(currentServices, add2(tracerTag, value8))(effect4));

// ../node_modules/effect/dist/esm/Clock.js
var ClockTypeId2 = ClockTypeId;
var make31 = make28;
var sleep2 = sleep;
var currentTimeMillis2 = currentTimeMillis;
var currentTimeNanos2 = currentTimeNanos;
var clockWith2 = clockWith;
var Clock = clockTag;

// ../node_modules/effect/dist/esm/FiberRefs.js
var FiberRefs_exports = {};
__export(FiberRefs_exports, {
  FiberRefsSym: () => FiberRefsSym2,
  delete: () => delete_2,
  empty: () => empty25,
  fiberRefs: () => fiberRefs2,
  forkAs: () => forkAs2,
  get: () => get9,
  getOrDefault: () => getOrDefault2,
  joinAs: () => joinAs2,
  setAll: () => setAll2,
  unsafeMake: () => unsafeMake6,
  updateAs: () => updateAs2,
  updateManyAs: () => updateManyAs2
});

// ../node_modules/effect/dist/esm/internal/fiberRefs.js
function unsafeMake5(fiberRefLocals) {
  return new FiberRefsImpl(fiberRefLocals);
}
function empty24() {
  return unsafeMake5(/* @__PURE__ */ new Map());
}
var FiberRefsSym = Symbol.for("effect/FiberRefs");
var _a13;
var FiberRefsImpl = class {
  constructor(locals) {
    __publicField(this, "locals");
    __publicField(this, _a13, FiberRefsSym);
    this.locals = locals;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
_a13 = FiberRefsSym;
var findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {
  const ref = _ref;
  let parentStack = _parentStack;
  let childStack = _childStack;
  let childModified = _childModified;
  let ret = void 0;
  while (ret === void 0) {
    if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
      const parentFiberId = headNonEmpty(parentStack)[0];
      const parentAncestors = tailNonEmpty(parentStack);
      const childFiberId = headNonEmpty(childStack)[0];
      const childRefValue = headNonEmpty(childStack)[1];
      const childAncestors = tailNonEmpty(childStack);
      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
        childStack = childAncestors;
        childModified = true;
      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
        parentStack = parentAncestors;
      } else {
        if (parentFiberId.id < childFiberId.id) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.id > childFiberId.id) {
          parentStack = parentAncestors;
        } else {
          ret = [childRefValue, childModified];
        }
      }
    } else {
      ret = [ref.initial, true];
    }
  }
  return ret;
};
var joinAs = dual(3, (self, fiberId5, that) => {
  const parentFiberRefs = new Map(self.locals);
  that.locals.forEach((childStack, fiberRef) => {
    const childValue = childStack[0][1];
    if (!childStack[0][0][symbol3](fiberId5)) {
      if (!parentFiberRefs.has(fiberRef)) {
        if (equals(childValue, fiberRef.initial)) {
          return;
        }
        parentFiberRefs.set(fiberRef, [[fiberId5, fiberRef.join(fiberRef.initial, childValue)]]);
        return;
      }
      const parentStack = parentFiberRefs.get(fiberRef);
      const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
      if (wasModified) {
        const patch14 = fiberRef.diff(ancestor, childValue);
        const oldValue = parentStack[0][1];
        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch14)(oldValue));
        if (!equals(oldValue, newValue)) {
          let newStack;
          const parentFiberId = parentStack[0][0];
          if (parentFiberId[symbol3](fiberId5)) {
            newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
          } else {
            newStack = [[fiberId5, newValue], ...parentStack];
          }
          parentFiberRefs.set(fiberRef, newStack);
        }
      }
    }
  });
  return new FiberRefsImpl(parentFiberRefs);
});
var forkAs = dual(2, (self, childId) => {
  const map43 = /* @__PURE__ */ new Map();
  unsafeForkAs(self, map43, childId);
  return new FiberRefsImpl(map43);
});
var unsafeForkAs = (self, map43, fiberId5) => {
  self.locals.forEach((stack, fiberRef) => {
    const oldValue = stack[0][1];
    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
    if (equals(oldValue, newValue)) {
      map43.set(fiberRef, stack);
    } else {
      map43.set(fiberRef, [[fiberId5, newValue], ...stack]);
    }
  });
};
var fiberRefs = (self) => fromIterable5(self.locals.keys());
var setAll = (self) => forEachSequentialDiscard(fiberRefs(self), (fiberRef) => fiberRefSet(fiberRef, getOrDefault(self, fiberRef)));
var delete_ = dual(2, (self, fiberRef) => {
  const locals = new Map(self.locals);
  locals.delete(fiberRef);
  return new FiberRefsImpl(locals);
});
var get8 = dual(2, (self, fiberRef) => {
  if (!self.locals.has(fiberRef)) {
    return none2();
  }
  return some2(headNonEmpty(self.locals.get(fiberRef))[1]);
});
var getOrDefault = dual(2, (self, fiberRef) => pipe(get8(self, fiberRef), getOrElse(() => fiberRef.initial)));
var updateAs = dual(2, (self, {
  fiberId: fiberId5,
  fiberRef,
  value: value8
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl(/* @__PURE__ */ new Map([[fiberRef, [[fiberId5, value8]]]]));
  }
  const locals = new Map(self.locals);
  unsafeUpdateAs(locals, fiberId5, fiberRef, value8);
  return new FiberRefsImpl(locals);
});
var unsafeUpdateAs = (locals, fiberId5, fiberRef, value8) => {
  const oldStack = locals.get(fiberRef) ?? [];
  let newStack;
  if (isNonEmptyReadonlyArray(oldStack)) {
    const [currentId, currentValue] = headNonEmpty(oldStack);
    if (currentId[symbol3](fiberId5)) {
      if (equals(currentValue, value8)) {
        return;
      } else {
        newStack = [[fiberId5, value8], ...oldStack.slice(1)];
      }
    } else {
      newStack = [[fiberId5, value8], ...oldStack];
    }
  } else {
    newStack = [[fiberId5, value8]];
  }
  locals.set(fiberRef, newStack);
};
var updateManyAs = dual(2, (self, {
  entries: entries6,
  forkAs: forkAs3
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl(new Map(entries6));
  }
  const locals = new Map(self.locals);
  if (forkAs3 !== void 0) {
    unsafeForkAs(self, locals, forkAs3);
  }
  entries6.forEach(([fiberRef, values13]) => {
    if (values13.length === 1) {
      unsafeUpdateAs(locals, values13[0][0], fiberRef, values13[0][1]);
    } else {
      values13.forEach(([fiberId5, value8]) => {
        unsafeUpdateAs(locals, fiberId5, fiberRef, value8);
      });
    }
  });
  return new FiberRefsImpl(locals);
});

// ../node_modules/effect/dist/esm/FiberRefs.js
var FiberRefsSym2 = FiberRefsSym;
var delete_2 = delete_;
var fiberRefs2 = fiberRefs;
var forkAs2 = forkAs;
var get9 = get8;
var getOrDefault2 = getOrDefault;
var joinAs2 = joinAs;
var setAll2 = setAll;
var updateAs2 = updateAs;
var updateManyAs2 = updateManyAs;
var unsafeMake6 = unsafeMake5;
var empty25 = empty24;

// ../node_modules/effect/dist/esm/LogLevel.js
var LogLevel_exports = {};
__export(LogLevel_exports, {
  All: () => All,
  Debug: () => Debug,
  Error: () => Error2,
  Fatal: () => Fatal,
  Info: () => Info,
  None: () => None3,
  Order: () => Order6,
  Trace: () => Trace,
  Warning: () => Warning,
  allLevels: () => allLevels,
  fromLiteral: () => fromLiteral,
  greaterThan: () => greaterThan5,
  greaterThanEqual: () => greaterThanEqual,
  lessThan: () => lessThan5,
  lessThanEqual: () => lessThanEqual,
  locally: () => locally
});
var All = logLevelAll;
var Fatal = logLevelFatal;
var Error2 = logLevelError;
var Warning = logLevelWarning;
var Info = logLevelInfo;
var Debug = logLevelDebug;
var Trace = logLevelTrace;
var None3 = logLevelNone;
var allLevels = allLogLevels;
var locally = dual(2, (use2, self) => fiberRefLocally(use2, currentLogLevel, self));
var Order6 = pipe(Order, mapInput2((level) => level.ordinal));
var lessThan5 = lessThan(Order6);
var lessThanEqual = lessThanOrEqualTo(Order6);
var greaterThan5 = greaterThan(Order6);
var greaterThanEqual = greaterThanOrEqualTo(Order6);
var fromLiteral = (literal3) => {
  switch (literal3) {
    case "All":
      return All;
    case "Debug":
      return Debug;
    case "Error":
      return Error2;
    case "Fatal":
      return Fatal;
    case "Info":
      return Info;
    case "Trace":
      return Trace;
    case "None":
      return None3;
    case "Warning":
      return Warning;
  }
};

// ../node_modules/effect/dist/esm/LogSpan.js
var LogSpan_exports = {};
__export(LogSpan_exports, {
  make: () => make33,
  render: () => render4
});

// ../node_modules/effect/dist/esm/internal/logSpan.js
var make32 = (label, startTime) => ({
  label,
  startTime
});
var render3 = (now) => (self) => {
  const label = self.label.replace(/[\s="]/g, "_");
  return `${label}=${now - self.startTime}ms`;
};

// ../node_modules/effect/dist/esm/LogSpan.js
var make33 = make32;
var render4 = render3;

// ../node_modules/effect/dist/esm/Ref.js
var Ref_exports = {};
__export(Ref_exports, {
  RefTypeId: () => RefTypeId2,
  get: () => get11,
  getAndSet: () => getAndSet3,
  getAndUpdate: () => getAndUpdate3,
  getAndUpdateSome: () => getAndUpdateSome2,
  make: () => make36,
  modify: () => modify6,
  modifySome: () => modifySome2,
  set: () => set6,
  setAndGet: () => setAndGet3,
  unsafeMake: () => unsafeMake8,
  update: () => update4,
  updateAndGet: () => updateAndGet3,
  updateSome: () => updateSome2,
  updateSomeAndGet: () => updateSomeAndGet2
});

// ../node_modules/effect/dist/esm/Readable.js
var Readable_exports = {};
__export(Readable_exports, {
  TypeId: () => TypeId11,
  isReadable: () => isReadable,
  make: () => make34,
  map: () => map13,
  mapEffect: () => mapEffect,
  unwrap: () => unwrap
});
var TypeId11 = Symbol.for("effect/Readable");
var isReadable = (u) => hasProperty(u, TypeId11);
var Proto = {
  [TypeId11]: TypeId11,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make34 = (get40) => {
  const self = Object.create(Proto);
  self.get = get40;
  return self;
};
var map13 = dual(2, (self, f) => make34(map11(self.get, f)));
var mapEffect = dual(2, (self, f) => make34(flatMap10(self.get, f)));
var unwrap = (effect4) => make34(flatMap10(effect4, (s) => s.get));

// ../node_modules/effect/dist/esm/internal/ref.js
var RefTypeId = Symbol.for("effect/Ref");
var refVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var _a14, _b;
var RefImpl = class {
  constructor(ref) {
    __publicField(this, "ref");
    __publicField(this, _a14, refVariance);
    __publicField(this, _b);
    __publicField(this, "get");
    this.ref = ref;
    this[TypeId11] = TypeId11;
    this.get = sync(() => get5(this.ref));
  }
  modify(f) {
    return sync(() => {
      const current2 = get5(this.ref);
      const [b, a] = f(current2);
      if (current2 !== a) {
        set2(a)(this.ref);
      }
      return b;
    });
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
_a14 = RefTypeId, _b = TypeId11;
var unsafeMake7 = (value8) => new RefImpl(make13(value8));
var make35 = (value8) => sync(() => unsafeMake7(value8));
var get10 = (self) => self.get;
var set5 = dual(2, (self, value8) => self.modify(() => [void 0, value8]));
var getAndSet2 = dual(2, (self, value8) => self.modify((a) => [a, value8]));
var getAndUpdate2 = dual(2, (self, f) => self.modify((a) => [a, f(a)]));
var getAndUpdateSome = dual(2, (self, pf) => self.modify((value8) => {
  const option9 = pf(value8);
  switch (option9._tag) {
    case "None": {
      return [value8, value8];
    }
    case "Some": {
      return [value8, option9.value];
    }
  }
}));
var setAndGet2 = dual(2, (self, value8) => self.modify(() => [value8, value8]));
var modify5 = dual(2, (self, f) => self.modify(f));
var modifySome = dual(3, (self, fallback, pf) => self.modify((value8) => {
  const option9 = pf(value8);
  switch (option9._tag) {
    case "None": {
      return [fallback, value8];
    }
    case "Some": {
      return option9.value;
    }
  }
}));
var update3 = dual(2, (self, f) => self.modify((a) => [void 0, f(a)]));
var updateAndGet2 = dual(2, (self, f) => self.modify((a) => {
  const result = f(a);
  return [result, result];
}));
var updateSome = dual(2, (self, f) => self.modify((a) => [void 0, match2(f(a), {
  onNone: () => a,
  onSome: (b) => b
})]));
var updateSomeAndGet = dual(2, (self, pf) => self.modify((value8) => {
  const option9 = pf(value8);
  switch (option9._tag) {
    case "None": {
      return [value8, value8];
    }
    case "Some": {
      return [option9.value, option9.value];
    }
  }
}));
var unsafeGet7 = (self) => get5(self.ref);

// ../node_modules/effect/dist/esm/Ref.js
var RefTypeId2 = RefTypeId;
var make36 = make35;
var get11 = get10;
var getAndSet3 = getAndSet2;
var getAndUpdate3 = getAndUpdate2;
var getAndUpdateSome2 = getAndUpdateSome;
var modify6 = modify5;
var modifySome2 = modifySome;
var set6 = set5;
var setAndGet3 = setAndGet2;
var update4 = update3;
var updateAndGet3 = updateAndGet2;
var updateSome2 = updateSome;
var updateSomeAndGet2 = updateSomeAndGet;
var unsafeMake8 = unsafeMake7;

// ../node_modules/effect/dist/esm/Tracer.js
var Tracer_exports = {};
__export(Tracer_exports, {
  ParentSpan: () => ParentSpan,
  Tracer: () => Tracer,
  TracerTypeId: () => TracerTypeId2,
  externalSpan: () => externalSpan2,
  make: () => make37,
  tracerWith: () => tracerWith2
});
var TracerTypeId2 = TracerTypeId;
var ParentSpan = spanTag;
var Tracer = tracerTag;
var make37 = make22;
var externalSpan2 = externalSpan;
var tracerWith2 = tracerWith;

// ../node_modules/effect/dist/esm/internal/fiberRefs/patch.js
var OP_EMPTY2 = "Empty";
var OP_ADD = "Add";
var OP_REMOVE = "Remove";
var OP_UPDATE = "Update";
var OP_AND_THEN = "AndThen";
var empty26 = {
  _tag: OP_EMPTY2
};
var diff8 = (oldValue, newValue) => {
  const missingLocals = new Map(oldValue.locals);
  let patch14 = empty26;
  for (const [fiberRef, pairs] of newValue.locals.entries()) {
    const newValue2 = headNonEmpty(pairs)[1];
    const old = missingLocals.get(fiberRef);
    if (old !== void 0) {
      const oldValue2 = headNonEmpty(old)[1];
      if (!equals(oldValue2, newValue2)) {
        patch14 = combine10({
          _tag: OP_UPDATE,
          fiberRef,
          patch: fiberRef.diff(oldValue2, newValue2)
        })(patch14);
      }
    } else {
      patch14 = combine10({
        _tag: OP_ADD,
        fiberRef,
        value: newValue2
      })(patch14);
    }
    missingLocals.delete(fiberRef);
  }
  for (const [fiberRef] of missingLocals.entries()) {
    patch14 = combine10({
      _tag: OP_REMOVE,
      fiberRef
    })(patch14);
  }
  return patch14;
};
var combine10 = dual(2, (self, that) => ({
  _tag: OP_AND_THEN,
  first: self,
  second: that
}));
var patch9 = dual(3, (self, fiberId5, oldValue) => {
  let fiberRefs4 = oldValue;
  let patches = of(self);
  while (isNonEmptyReadonlyArray(patches)) {
    const head11 = headNonEmpty(patches);
    const tail4 = tailNonEmpty(patches);
    switch (head11._tag) {
      case OP_EMPTY2: {
        patches = tail4;
        break;
      }
      case OP_ADD: {
        fiberRefs4 = updateAs(fiberRefs4, {
          fiberId: fiberId5,
          fiberRef: head11.fiberRef,
          value: head11.value
        });
        patches = tail4;
        break;
      }
      case OP_REMOVE: {
        fiberRefs4 = delete_(fiberRefs4, head11.fiberRef);
        patches = tail4;
        break;
      }
      case OP_UPDATE: {
        const value8 = getOrDefault(fiberRefs4, head11.fiberRef);
        fiberRefs4 = updateAs(fiberRefs4, {
          fiberId: fiberId5,
          fiberRef: head11.fiberRef,
          value: head11.fiberRef.patch(head11.patch)(value8)
        });
        patches = tail4;
        break;
      }
      case OP_AND_THEN: {
        patches = prepend(head11.first)(prepend(head11.second)(tail4));
        break;
      }
    }
  }
  return fiberRefs4;
});

// ../node_modules/effect/dist/esm/internal/metric/label.js
var MetricLabelSymbolKey = "effect/MetricLabel";
var MetricLabelTypeId = Symbol.for(MetricLabelSymbolKey);
var _a15;
var MetricLabelImpl = class {
  constructor(key, value8) {
    __publicField(this, "key");
    __publicField(this, "value");
    __publicField(this, _a15, MetricLabelTypeId);
    __publicField(this, "_hash");
    this.key = key;
    this.value = value8;
    this._hash = string(MetricLabelSymbolKey + this.key + this.value);
  }
  [(_a15 = MetricLabelTypeId, symbol2)]() {
    return this._hash;
  }
  [symbol3](that) {
    return isMetricLabel(that) && this.key === that.key && this.value === that.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make38 = (key, value8) => {
  return new MetricLabelImpl(key, value8);
};
var isMetricLabel = (u) => hasProperty(u, MetricLabelTypeId);

// ../node_modules/effect/dist/esm/internal/singleShotGen.js
var SingleShotGen = class _SingleShotGen {
  constructor(self) {
    __publicField(this, "self");
    __publicField(this, "called", false);
    this.self = self;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};

// ../node_modules/effect/dist/esm/internal/core-effect.js
var annotateLogs = dual((args) => isEffect(args[0]), function() {
  const args = arguments;
  return fiberRefLocallyWith(args[0], currentLogAnnotations, typeof args[1] === "string" ? set3(args[1], args[2]) : (annotations2) => Object.entries(args[1]).reduce((acc, [key, value8]) => set3(acc, key, value8), annotations2));
});
var asSome = (self) => map11(self, some2);
var asSomeError = (self) => mapError(self, some2);
var try_ = (arg) => {
  let evaluate3;
  let onFailure = void 0;
  if (typeof arg === "function") {
    evaluate3 = arg;
  } else {
    evaluate3 = arg.try;
    onFailure = arg.catch;
  }
  return sync(() => {
    try {
      return evaluate3();
    } catch (error4) {
      throw makeEffectError(fail(onFailure ? onFailure(error4) : new UnknownException(error4)));
    }
  });
};
var _catch = dual(3, (self, tag4, options) => catchAll(self, (e) => {
  if (hasProperty(e, tag4) && e[tag4] === options.failure) {
    return options.onFailure(e);
  }
  return fail2(e);
}));
var catchAllDefect = dual(2, (self, f) => catchAllCause(self, (cause3) => {
  const option9 = find(cause3, (_) => isDieType(_) ? some2(_) : none2());
  switch (option9._tag) {
    case "None": {
      return failCause(cause3);
    }
    case "Some": {
      return f(option9.value.defect);
    }
  }
}));
var catchSomeCause = dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const option9 = f(cause3);
    switch (option9._tag) {
      case "None": {
        return failCause(cause3);
      }
      case "Some": {
        return option9.value;
      }
    }
  },
  onSuccess: succeed
}));
var catchSomeDefect = dual(2, (self, pf) => catchAllCause(self, (cause3) => {
  const option9 = find(cause3, (_) => isDieType(_) ? some2(_) : none2());
  switch (option9._tag) {
    case "None": {
      return failCause(cause3);
    }
    case "Some": {
      const optionEffect = pf(option9.value.defect);
      return optionEffect._tag === "Some" ? optionEffect.value : failCause(cause3);
    }
  }
}));
var catchTag = dual(3, (self, k, f) => catchIf(self, isTagged(k), f));
var catchTags = dual(2, (self, cases) => {
  let keys10;
  return catchIf(self, (e) => {
    keys10 ?? (keys10 = Object.keys(cases));
    return hasProperty(e, "_tag") && isString(e["_tag"]) && keys10.includes(e["_tag"]);
  }, (e) => cases[e["_tag"]](e));
});
var cause = (self) => matchCause(self, {
  onFailure: identity,
  onSuccess: () => empty20
});
var clockWith3 = clockWith2;
var clock = clockWith3(succeed);
var delay = dual(2, (self, duration5) => zipRight(sleep2(duration5), self));
var descriptorWith = (f) => withFiberRuntime((state, status3) => f({
  id: state.id(),
  status: status3,
  interruptors: interruptors(state.getFiberRef(currentInterruptedCause))
}));
var allowInterrupt = descriptorWith((descriptor3) => size4(descriptor3.interruptors) > 0 ? interrupt2 : void_);
var descriptor = descriptorWith(succeed);
var diffFiberRefs = (self) => summarized(self, fiberRefs3, diff8);
var diffFiberRefsAndRuntimeFlags = (self) => summarized(self, zip4(fiberRefs3, runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [diff8(refs, refsNew), diff7(flags, flagsNew)]);
var Do = succeed({});
var bind = dual(3, (self, tag4, f) => flatMap10(self, (k) => map11(f(k), (a) => ({
  ...k,
  [tag4]: a
}))));
var bindTo = dual(2, (self, tag4) => map11(self, (a) => ({
  [tag4]: a
})));
var let_ = dual(3, (self, tag4, f) => map11(self, (k) => ({
  ...k,
  [tag4]: f(k)
})));
var dropUntil = dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next6;
  let dropping9 = succeed(false);
  let i = 0;
  while ((next6 = iterator.next()) && !next6.done) {
    const a = next6.value;
    const index = i++;
    dropping9 = flatMap10(dropping9, (bool) => {
      if (bool) {
        builder.push(a);
        return succeed(true);
      }
      return predicate(a, index);
    });
  }
  return map11(dropping9, () => builder);
}));
var dropWhile2 = dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next6;
  let dropping9 = succeed(true);
  let i = 0;
  while ((next6 = iterator.next()) && !next6.done) {
    const a = next6.value;
    const index = i++;
    dropping9 = flatMap10(dropping9, (d) => map11(d ? predicate(a, index) : succeed(false), (b) => {
      if (!b) {
        builder.push(a);
      }
      return b;
    }));
  }
  return map11(dropping9, () => builder);
}));
var contextWith = (f) => map11(context(), f);
var eventually = (self) => orElse2(self, () => flatMap10(yieldNow(), () => eventually(self)));
var filterMap6 = dual(2, (elements, pf) => map11(forEachSequential(elements, identity), filterMap(pf)));
var filterOrDie = dual(3, (self, predicate, orDieWith9) => filterOrElse(self, predicate, (a) => dieSync(() => orDieWith9(a))));
var filterOrDieMessage = dual(3, (self, predicate, message) => filterOrElse(self, predicate, () => dieMessage(message)));
var filterOrElse = dual(3, (self, predicate, orElse22) => flatMap10(self, (a) => predicate(a) ? succeed(a) : orElse22(a)));
var filterOrFail = dual((args) => isEffect(args[0]), (self, predicate, orFailWith) => filterOrElse(self, predicate, (a) => orFailWith === void 0 ? fail2(new NoSuchElementException()) : failSync(() => orFailWith(a))));
var findFirst6 = dual(2, (elements, f) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const next6 = iterator.next();
  if (!next6.done) {
    return findLoop(iterator, 0, f, next6.value);
  }
  return succeed(none2());
}));
var findLoop = (iterator, index, f, value8) => flatMap10(f(value8, index), (result) => {
  if (result) {
    return succeed(some2(value8));
  }
  const next6 = iterator.next();
  if (!next6.done) {
    return findLoop(iterator, index + 1, f, next6.value);
  }
  return succeed(none2());
});
var firstSuccessOf = (effects) => suspend(() => {
  const list = fromIterable2(effects);
  if (!isNonEmpty2(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  return pipe(tailNonEmpty2(list), reduce(headNonEmpty2(list), (left2, right2) => orElse2(left2, () => right2)));
});
var flipWith = dual(2, (self, f) => flip(f(flip(self))));
var match8 = dual(2, (self, options) => matchEffect(self, {
  onFailure: (e) => succeed(options.onFailure(e)),
  onSuccess: (a) => succeed(options.onSuccess(a))
}));
var every7 = dual(2, (elements, f) => suspend(() => forAllLoop(elements[Symbol.iterator](), 0, f)));
var forAllLoop = (iterator, index, f) => {
  const next6 = iterator.next();
  return next6.done ? succeed(true) : flatMap10(f(next6.value, index), (b) => b ? forAllLoop(iterator, index + 1, f) : succeed(b));
};
var forever = (self) => {
  const loop5 = flatMap10(flatMap10(self, () => yieldNow()), () => loop5);
  return loop5;
};
var EffectGen = class {
  constructor(value8) {
    __publicField(this, "value");
    this.value = value8;
  }
  [Symbol.iterator]() {
    return new SingleShotGen(this);
  }
};
var adapter = function() {
  let x = arguments[0];
  for (let i = 1; i < arguments.length; i++) {
    x = arguments[i](x);
  }
  return new EffectGen(x);
};
var gen = function() {
  let f;
  if (arguments.length === 1) {
    f = arguments[0];
  } else {
    f = arguments[1].bind(arguments[0]);
  }
  return suspend(() => {
    const iterator = f(adapter);
    const state = iterator.next();
    const run11 = (state2) => state2.done ? succeed(state2.value) : pipe(state2.value.value, flatMap10((val) => run11(iterator.next(val))));
    return run11(state);
  });
};
var fiberRefs3 = withFiberRuntime((state) => succeed(state.getFiberRefs()));
var head5 = (self) => flatMap10(self, (as16) => {
  const iterator = as16[Symbol.iterator]();
  const next6 = iterator.next();
  if (next6.done) {
    return fail2(new NoSuchElementException());
  }
  return succeed(next6.value);
});
var ignore = (self) => match8(self, {
  onFailure: constVoid,
  onSuccess: constVoid
});
var ignoreLogged = (self) => matchCauseEffect(self, {
  onFailure: (cause3) => logDebug(cause3, "An error was silently ignored because it is not anticipated to be useful"),
  onSuccess: () => void_
});
var inheritFiberRefs = (childFiberRefs) => updateFiberRefs((parentFiberId, parentFiberRefs) => joinAs2(parentFiberRefs, parentFiberId, childFiberRefs));
var isFailure3 = (self) => match8(self, {
  onFailure: constTrue,
  onSuccess: constFalse
});
var isSuccess2 = (self) => match8(self, {
  onFailure: constFalse,
  onSuccess: constTrue
});
var iterate = (initial, options) => suspend(() => {
  if (options.while(initial)) {
    return flatMap10(options.body(initial), (z2) => iterate(z2, options));
  }
  return succeed(initial);
});
var logWithLevel = (level) => (...message) => {
  const levelOption = fromNullable(level);
  let cause3 = void 0;
  for (let i = 0, len = message.length; i < len; i++) {
    const msg = message[i];
    if (isCause(msg)) {
      if (cause3 !== void 0) {
        cause3 = sequential(cause3, msg);
      } else {
        cause3 = msg;
      }
      message = [...message.slice(0, i), ...message.slice(i + 1)];
      i--;
    }
  }
  if (message.length === 0) {
    message = "";
  } else if (message.length === 1) {
    message = message[0];
  }
  if (cause3 === void 0) {
    cause3 = empty20;
  }
  return withFiberRuntime((fiberState) => {
    fiberState.log(message, cause3, levelOption);
    return void_;
  });
};
var log = logWithLevel();
var logTrace = logWithLevel(Trace);
var logDebug = logWithLevel(Debug);
var logInfo = logWithLevel(Info);
var logWarning = logWithLevel(Warning);
var logError = logWithLevel(Error2);
var logFatal = logWithLevel(Fatal);
var withLogSpan = dual(2, (effect4, label) => flatMap10(currentTimeMillis2, (now) => fiberRefLocallyWith(effect4, currentLogSpan, prepend3(make33(label, now)))));
var logAnnotations = fiberRefGet(currentLogAnnotations);
var loop = (initial, options) => options.discard ? loopDiscard(initial, options.while, options.step, options.body) : map11(loopInternal(initial, options.while, options.step, options.body), fromIterable);
var loopInternal = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap10(body(initial), (a) => map11(loopInternal(inc(initial), cont, inc, body), prepend3(a))) : sync(() => empty10()));
var loopDiscard = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap10(body(initial), () => loopDiscard(inc(initial), cont, inc, body)) : void_);
var mapAccum3 = dual(3, (elements, zero3, f) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let result = succeed(zero3);
  let next6;
  let i = 0;
  while (!(next6 = iterator.next()).done) {
    const index = i++;
    const value8 = next6.value;
    result = flatMap10(result, (state) => map11(f(state, value8, index), ([z, b]) => {
      builder.push(b);
      return z;
    }));
  }
  return map11(result, (z) => [z, builder]);
}));
var mapErrorCause2 = dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (c) => failCauseSync(() => f(c)),
  onSuccess: succeed
}));
var memoize = (self) => pipe(deferredMake(), flatMap10((deferred) => pipe(diffFiberRefsAndRuntimeFlags(self), intoDeferred(deferred), once, map11((complete6) => zipRight(complete6, pipe(deferredAwait(deferred), flatMap10(([patch14, a]) => as2(zip4(patchFiberRefs(patch14[0]), updateRuntimeFlags(patch14[1])), a))))))));
var merge5 = (self) => matchEffect(self, {
  onFailure: (e) => succeed(e),
  onSuccess: succeed
});
var negate2 = (self) => map11(self, (b) => !b);
var none6 = (self) => flatMap10(self, (option9) => {
  switch (option9._tag) {
    case "None":
      return void_;
    case "Some":
      return fail2(new NoSuchElementException());
  }
});
var once = (self) => map11(make36(true), (ref) => asVoid(whenEffect(self, getAndSet3(ref, false))));
var option = (self) => matchEffect(self, {
  onFailure: () => succeed(none2()),
  onSuccess: (a) => succeed(some2(a))
});
var orElseFail = dual(2, (self, evaluate3) => orElse2(self, () => failSync(evaluate3)));
var orElseSucceed = dual(2, (self, evaluate3) => orElse2(self, () => sync(evaluate3)));
var parallelErrors = (self) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const errors2 = fromIterable(failures(cause3));
    return errors2.length === 0 ? failCause(cause3) : fail2(errors2);
  },
  onSuccess: succeed
});
var patchFiberRefs = (patch14) => updateFiberRefs((fiberId5, fiberRefs4) => pipe(patch14, patch9(fiberId5, fiberRefs4)));
var promise = (evaluate3) => evaluate3.length >= 1 ? async((resolve, signal) => {
  evaluate3(signal).then((a) => resolve(exitSucceed(a)), (e) => resolve(exitDie(e)));
}) : async((resolve) => {
  ;
  evaluate3().then((a) => resolve(exitSucceed(a)), (e) => resolve(exitDie(e)));
});
var provideService = dual(3, (self, tag4, service3) => contextWithEffect((env) => provideContext(self, add2(env, tag4, service3))));
var provideServiceEffect = dual(3, (self, tag4, effect4) => contextWithEffect((env) => flatMap10(effect4, (service3) => provideContext(self, pipe(env, add2(tag4, service3))))));
var random2 = randomWith(succeed);
var reduce10 = dual(3, (elements, zero3, f) => fromIterable(elements).reduce((acc, el, i) => flatMap10(acc, (a) => f(a, el, i)), succeed(zero3)));
var reduceRight4 = dual(3, (elements, zero3, f) => fromIterable(elements).reduceRight((acc, el, i) => flatMap10(acc, (a) => f(el, a, i)), succeed(zero3)));
var reduceWhile = dual(3, (elements, zero3, options) => flatMap10(sync(() => elements[Symbol.iterator]()), (iterator) => reduceWhileLoop(iterator, 0, zero3, options.while, options.body)));
var reduceWhileLoop = (iterator, index, state, predicate, f) => {
  const next6 = iterator.next();
  if (!next6.done && predicate(state)) {
    return flatMap10(f(state, next6.value, index), (nextState) => reduceWhileLoop(iterator, index + 1, nextState, predicate, f));
  }
  return succeed(state);
};
var repeatN = dual(2, (self, n) => suspend(() => repeatNLoop(self, n)));
var repeatNLoop = (self, n) => flatMap10(self, (a) => n <= 0 ? succeed(a) : zipRight(yieldNow(), repeatNLoop(self, n - 1)));
var sandbox = (self) => matchCauseEffect(self, {
  onFailure: fail2,
  onSuccess: succeed
});
var setFiberRefs = (fiberRefs4) => suspend(() => setAll2(fiberRefs4));
var sleep3 = sleep2;
var succeedNone = succeed(none2());
var succeedSome = (value8) => succeed(some2(value8));
var summarized = dual(3, (self, summary11, f) => flatMap10(summary11, (start5) => flatMap10(self, (value8) => map11(summary11, (end7) => [f(start5, end7), value8]))));
var tagMetrics = dual((args) => isEffect(args[0]), function() {
  return labelMetrics(arguments[0], typeof arguments[1] === "string" ? [make38(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k, v]) => make38(k, v)));
});
var labelMetrics = dual(2, (self, labels) => fiberRefLocallyWith(self, currentMetricLabels, (old) => union(old, labels)));
var takeUntil = dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next6;
  let effect4 = succeed(false);
  let i = 0;
  while ((next6 = iterator.next()) && !next6.done) {
    const a = next6.value;
    const index = i++;
    effect4 = flatMap10(effect4, (bool) => {
      if (bool) {
        return succeed(true);
      }
      builder.push(a);
      return predicate(a, index);
    });
  }
  return map11(effect4, () => builder);
}));
var takeWhile2 = dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next6;
  let taking = succeed(true);
  let i = 0;
  while ((next6 = iterator.next()) && !next6.done) {
    const a = next6.value;
    const index = i++;
    taking = flatMap10(taking, (taking2) => pipe(taking2 ? predicate(a, index) : succeed(false), map11((bool) => {
      if (bool) {
        builder.push(a);
      }
      return bool;
    })));
  }
  return map11(taking, () => builder);
}));
var tapBoth = dual(2, (self, {
  onFailure,
  onSuccess
}) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const either13 = failureOrCause(cause3);
    switch (either13._tag) {
      case "Left": {
        return zipRight(onFailure(either13.left), failCause(cause3));
      }
      case "Right": {
        return failCause(cause3);
      }
    }
  },
  onSuccess: (a) => as2(onSuccess(a), a)
}));
var tapDefect = dual(2, (self, f) => catchAllCause(self, (cause3) => match2(keepDefects(cause3), {
  onNone: () => failCause(cause3),
  onSome: (a) => zipRight(f(a), failCause(cause3))
})));
var tapError = dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const either13 = failureOrCause(cause3);
    switch (either13._tag) {
      case "Left":
        return zipRight(f(either13.left), failCause(cause3));
      case "Right":
        return failCause(cause3);
    }
  },
  onSuccess: succeed
}));
var tapErrorTag = dual(3, (self, k, f) => tapError(self, (e) => {
  if (isTagged(e, k)) {
    return f(e);
  }
  return void_;
}));
var tapErrorCause = dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (cause3) => zipRight(f(cause3), failCause(cause3)),
  onSuccess: succeed
}));
var timed = (self) => timedWith(self, currentTimeNanos2);
var timedWith = dual(2, (self, nanos2) => summarized(self, nanos2, (start5, end7) => nanos(end7 - start5)));
var tracerWith3 = tracerWith2;
var tracer = tracerWith3(succeed);
var tryPromise = (arg) => {
  let evaluate3;
  let catcher = void 0;
  if (typeof arg === "function") {
    evaluate3 = arg;
  } else {
    evaluate3 = arg.try;
    catcher = arg.catch;
  }
  if (evaluate3.length >= 1) {
    return async((resolve, signal) => {
      try {
        evaluate3(signal).then((a) => resolve(exitSucceed(a)), (e) => resolve(fail2(catcher ? catcher(e) : new UnknownException(e))));
      } catch (e) {
        resolve(fail2(catcher ? catcher(e) : new UnknownException(e)));
      }
    });
  }
  return async((resolve) => {
    try {
      evaluate3().then((a) => resolve(exitSucceed(a)), (e) => resolve(fail2(catcher ? catcher(e) : new UnknownException(e))));
    } catch (e) {
      resolve(fail2(catcher ? catcher(e) : new UnknownException(e)));
    }
  });
};
var tryMap = dual(2, (self, options) => flatMap10(self, (a) => try_({
  try: () => options.try(a),
  catch: options.catch
})));
var tryMapPromise = dual(2, (self, options) => flatMap10(self, (a) => tryPromise({
  try: options.try.length >= 1 ? (signal) => options.try(a, signal) : () => options.try(a),
  catch: options.catch
})));
var unless = dual(2, (self, condition) => suspend(() => condition() ? succeedNone : asSome(self)));
var unlessEffect = dual(2, (self, condition) => flatMap10(condition, (b) => b ? succeedNone : asSome(self)));
var unsandbox = (self) => mapErrorCause2(self, flatten4);
var updateFiberRefs = (f) => withFiberRuntime((state) => {
  state.setFiberRefs(f(state.id(), state.getFiberRefs()));
  return void_;
});
var updateService = dual(3, (self, tag4, f) => mapInputContext(self, (context13) => add2(context13, tag4, f(unsafeGet3(context13, tag4)))));
var when = dual(2, (self, condition) => suspend(() => condition() ? map11(self, some2) : succeed(none2())));
var whenFiberRef = dual(3, (self, fiberRef, predicate) => flatMap10(fiberRefGet(fiberRef), (s) => predicate(s) ? map11(self, (a) => [s, some2(a)]) : succeed([s, none2()])));
var whenRef = dual(3, (self, ref, predicate) => flatMap10(get11(ref), (s) => predicate(s) ? map11(self, (a) => [s, some2(a)]) : succeed([s, none2()])));
var withMetric = dual(2, (self, metric) => metric(self));
var serviceFunctionEffect = (getService, f) => (...args) => flatMap10(getService, (a) => f(a)(...args));
var serviceFunction = (getService, f) => (...args) => map11(getService, (a) => f(a)(...args));
var serviceFunctions = (getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return (...args) => flatMap10(getService, (s) => s[prop](...args));
  }
});
var serviceConstants = (getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return flatMap10(getService, (s) => isEffect(s[prop]) ? s[prop] : succeed(s[prop]));
  }
});
var serviceMembers = (getService) => ({
  functions: serviceFunctions(getService),
  constants: serviceConstants(getService)
});
var serviceOption = (tag4) => map11(context(), getOption2(tag4));
var serviceOptional = (tag4) => flatMap10(context(), getOption2(tag4));
var annotateCurrentSpan = function() {
  const args = arguments;
  return ignore(flatMap10(currentSpan, (span4) => sync(() => {
    if (typeof args[0] === "string") {
      span4.attribute(args[0], args[1]);
    } else {
      for (const key in args[0]) {
        span4.attribute(key, args[0][key]);
      }
    }
  })));
};
var annotateSpans = dual((args) => isEffect(args[0]), function() {
  const args = arguments;
  return fiberRefLocallyWith(args[0], currentTracerSpanAnnotations, typeof args[1] === "string" ? set3(args[1], args[2]) : (annotations2) => Object.entries(args[1]).reduce((acc, [key, value8]) => set3(acc, key, value8), annotations2));
});
var currentParentSpan = serviceOptional(spanTag);
var currentSpan = flatMap10(context(), (context13) => {
  const span4 = context13.unsafeMap.get(spanTag.key);
  return span4 !== void 0 && span4._tag === "Span" ? succeed(span4) : fail2(new NoSuchElementException());
});
var linkSpans = dual((args) => isEffect(args[0]), (self, span4, attributes) => fiberRefLocallyWith(self, currentTracerSpanLinks, append2({
  _tag: "SpanLink",
  span: span4,
  attributes: attributes ?? {}
})));
var bigint04 = BigInt(0);
var unsafeMakeSpan = (fiber, name, options) => {
  const enabled2 = fiber.getFiberRef(currentTracerEnabled);
  if (enabled2 === false) {
    return noopSpan(name);
  }
  const context13 = fiber.getFiberRef(currentContext);
  const services = fiber.getFiberRef(currentServices);
  const tracer3 = get2(services, tracerTag);
  const clock3 = get2(services, Clock);
  const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
  const fiberRefs4 = fiber.getFiberRefs();
  const annotationsFromEnv = get9(fiberRefs4, currentTracerSpanAnnotations);
  const linksFromEnv = get9(fiberRefs4, currentTracerSpanLinks);
  const parent = (options == null ? void 0 : options.parent) ? some2(options.parent) : (options == null ? void 0 : options.root) ? none2() : getOption2(context13, spanTag);
  const links = linksFromEnv._tag === "Some" ? (options == null ? void 0 : options.links) !== void 0 ? [...toReadonlyArray(linksFromEnv.value), ...(options == null ? void 0 : options.links) ?? []] : toReadonlyArray(linksFromEnv.value) : (options == null ? void 0 : options.links) ?? empty2();
  const span4 = tracer3.span(name, parent, (options == null ? void 0 : options.context) ?? empty4(), links, timingEnabled ? clock3.unsafeCurrentTimeNanos() : bigint04);
  if (annotationsFromEnv._tag === "Some") {
    forEach5(annotationsFromEnv.value, (value8, key) => span4.attribute(key, value8));
  }
  if ((options == null ? void 0 : options.attributes) !== void 0) {
    Object.entries(options.attributes).forEach(([k, v]) => span4.attribute(k, v));
  }
  return span4;
};
var makeSpan = (name, options) => withFiberRuntime((fiber) => succeed(unsafeMakeSpan(fiber, name, options)));
var spanAnnotations = fiberRefGet(currentTracerSpanAnnotations);
var spanLinks = fiberRefGet(currentTracerSpanLinks);
var useSpan = (name, ...args) => {
  const options = args.length === 1 ? void 0 : args[0];
  const evaluate3 = args[args.length - 1];
  return withFiberRuntime((fiber) => {
    const span4 = unsafeMakeSpan(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock3 = get2(fiber.getFiberRef(currentServices), clockTag);
    return onExit(evaluate3(span4), (exit3) => sync(() => {
      if (span4.status._tag === "Ended") {
        return;
      }
      span4.end(timingEnabled ? clock3.unsafeCurrentTimeNanos() : bigint04, exit3);
    }));
  });
};
var withParentSpan = dual(2, (self, span4) => provideService(self, spanTag, span4));
var withSpan = dual((args) => typeof args[0] !== "string", (self, name, options) => useSpan(name, options ?? {}, (span4) => withParentSpan(self, span4)));
var fromNullable2 = (value8) => value8 == null ? fail2(new NoSuchElementException()) : succeed(value8);
var optionFromOptional = (self) => catchAll(map11(self, some2), (error4) => isNoSuchElementException(error4) ? succeedNone : fail2(error4));

// ../node_modules/effect/dist/esm/Effectable.js
var Effectable_exports = {};
__export(Effectable_exports, {
  ChannelTypeId: () => ChannelTypeId2,
  Class: () => Class,
  CommitPrototype: () => CommitPrototype2,
  EffectPrototype: () => EffectPrototype2,
  EffectTypeId: () => EffectTypeId3,
  SinkTypeId: () => SinkTypeId2,
  StreamTypeId: () => StreamTypeId2,
  StructuralClass: () => StructuralClass,
  StructuralCommitPrototype: () => StructuralCommitPrototype2
});
var EffectTypeId3 = EffectTypeId;
var StreamTypeId2 = StreamTypeId;
var SinkTypeId2 = SinkTypeId;
var ChannelTypeId2 = ChannelTypeId;
var EffectPrototype2 = EffectPrototype;
var CommitPrototype2 = CommitPrototype;
var StructuralCommitPrototype2 = StructuralCommitPrototype;
var Base2 = Base;
var StructuralBase2 = StructuralBase;
var Class = class extends Base2 {
};
var StructuralClass = class extends StructuralBase2 {
};

// ../node_modules/effect/dist/esm/ExecutionStrategy.js
var ExecutionStrategy_exports = {};
__export(ExecutionStrategy_exports, {
  isParallel: () => isParallel2,
  isParallelN: () => isParallelN2,
  isSequential: () => isSequential2,
  match: () => match10,
  parallel: () => parallel3,
  parallelN: () => parallelN2,
  sequential: () => sequential3
});

// ../node_modules/effect/dist/esm/internal/executionStrategy.js
var OP_SEQUENTIAL2 = "Sequential";
var OP_PARALLEL2 = "Parallel";
var OP_PARALLEL_N = "ParallelN";
var sequential2 = {
  _tag: OP_SEQUENTIAL2
};
var parallel2 = {
  _tag: OP_PARALLEL2
};
var parallelN = (parallelism) => ({
  _tag: OP_PARALLEL_N,
  parallelism
});
var isSequential = (self) => self._tag === OP_SEQUENTIAL2;
var isParallel = (self) => self._tag === OP_PARALLEL2;
var isParallelN = (self) => self._tag === OP_PARALLEL_N;
var match9 = dual(2, (self, options) => {
  switch (self._tag) {
    case OP_SEQUENTIAL2: {
      return options.onSequential();
    }
    case OP_PARALLEL2: {
      return options.onParallel();
    }
    case OP_PARALLEL_N: {
      return options.onParallelN(self.parallelism);
    }
  }
});

// ../node_modules/effect/dist/esm/ExecutionStrategy.js
var sequential3 = sequential2;
var parallel3 = parallel2;
var parallelN2 = parallelN;
var isSequential2 = isSequential;
var isParallel2 = isParallel;
var isParallelN2 = isParallelN;
var match10 = match9;

// ../node_modules/effect/dist/esm/FiberRefsPatch.js
var FiberRefsPatch_exports = {};
__export(FiberRefsPatch_exports, {
  combine: () => combine11,
  diff: () => diff9,
  empty: () => empty27,
  patch: () => patch10
});
var empty27 = empty26;
var diff9 = diff8;
var combine11 = combine10;
var patch10 = patch9;

// ../node_modules/effect/dist/esm/FiberStatus.js
var FiberStatus_exports = {};
__export(FiberStatus_exports, {
  FiberStatusTypeId: () => FiberStatusTypeId2,
  done: () => done4,
  isDone: () => isDone3,
  isFiberStatus: () => isFiberStatus2,
  isRunning: () => isRunning2,
  isSuspended: () => isSuspended2,
  running: () => running2,
  suspended: () => suspended2
});

// ../node_modules/effect/dist/esm/internal/fiberStatus.js
var FiberStatusSymbolKey = "effect/FiberStatus";
var FiberStatusTypeId = Symbol.for(FiberStatusSymbolKey);
var OP_DONE = "Done";
var OP_RUNNING = "Running";
var OP_SUSPENDED = "Suspended";
var DoneHash = string(`${FiberStatusSymbolKey}-${OP_DONE}`);
var _a16;
var Done = class {
  constructor() {
    __publicField(this, _a16, FiberStatusTypeId);
    __publicField(this, "_tag", OP_DONE);
  }
  [(_a16 = FiberStatusTypeId, symbol2)]() {
    return DoneHash;
  }
  [symbol3](that) {
    return isFiberStatus(that) && that._tag === OP_DONE;
  }
};
var _a17;
var Running = class {
  constructor(runtimeFlags2) {
    __publicField(this, "runtimeFlags");
    __publicField(this, _a17, FiberStatusTypeId);
    __publicField(this, "_tag", OP_RUNNING);
    this.runtimeFlags = runtimeFlags2;
  }
  [(_a17 = FiberStatusTypeId, symbol2)]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), cached(this));
  }
  [symbol3](that) {
    return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
  }
};
var _a18;
var Suspended = class {
  constructor(runtimeFlags2, blockingOn) {
    __publicField(this, "runtimeFlags");
    __publicField(this, "blockingOn");
    __publicField(this, _a18, FiberStatusTypeId);
    __publicField(this, "_tag", OP_SUSPENDED);
    this.runtimeFlags = runtimeFlags2;
    this.blockingOn = blockingOn;
  }
  [(_a18 = FiberStatusTypeId, symbol2)]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), combine(hash(this.blockingOn)), cached(this));
  }
  [symbol3](that) {
    return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
  }
};
var done3 = new Done();
var running = (runtimeFlags2) => new Running(runtimeFlags2);
var suspended = (runtimeFlags2, blockingOn) => new Suspended(runtimeFlags2, blockingOn);
var isFiberStatus = (u) => hasProperty(u, FiberStatusTypeId);
var isDone2 = (self) => self._tag === OP_DONE;
var isRunning = (self) => self._tag === OP_RUNNING;
var isSuspended = (self) => self._tag === OP_SUSPENDED;

// ../node_modules/effect/dist/esm/FiberStatus.js
var FiberStatusTypeId2 = FiberStatusTypeId;
var done4 = done3;
var running2 = running;
var suspended2 = suspended;
var isFiberStatus2 = isFiberStatus;
var isDone3 = isDone2;
var isRunning2 = isRunning;
var isSuspended2 = isSuspended;

// ../node_modules/effect/dist/esm/Scheduler.js
var Scheduler_exports = {};
__export(Scheduler_exports, {
  ControlledScheduler: () => ControlledScheduler,
  MixedScheduler: () => MixedScheduler,
  PriorityBuckets: () => PriorityBuckets,
  SyncScheduler: () => SyncScheduler,
  currentScheduler: () => currentScheduler,
  defaultScheduler: () => defaultScheduler,
  defaultShouldYield: () => defaultShouldYield,
  make: () => make39,
  makeBatched: () => makeBatched,
  makeMatrix: () => makeMatrix,
  timer: () => timer,
  timerBatched: () => timerBatched,
  withScheduler: () => withScheduler
});
var PriorityBuckets = class {
  constructor() {
    /**
     * @since 2.0.0
     */
    __publicField(this, "buckets", []);
  }
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    let bucket = void 0;
    let index;
    for (index = 0; index < this.buckets.length; index++) {
      if (this.buckets[index][0] <= priority) {
        bucket = this.buckets[index];
      } else {
        break;
      }
    }
    if (bucket) {
      bucket[1].push(task);
    } else {
      const newBuckets = [];
      for (let i = 0; i < index; i++) {
        newBuckets.push(this.buckets[i]);
      }
      newBuckets.push([priority, [task]]);
      for (let i = index; i < this.buckets.length; i++) {
        newBuckets.push(this.buckets[i]);
      }
      this.buckets = newBuckets;
    }
  }
};
var MixedScheduler = class {
  constructor(maxNextTickBeforeTimer) {
    __publicField(this, "maxNextTickBeforeTimer");
    /**
     * @since 2.0.0
     */
    __publicField(this, "running", false);
    /**
     * @since 2.0.0
     */
    __publicField(this, "tasks", new PriorityBuckets());
    this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
  }
  /**
   * @since 2.0.0
   */
  starveInternal(depth) {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (this.tasks.buckets.length === 0) {
      this.running = false;
    } else {
      this.starve(depth);
    }
  }
  /**
   * @since 2.0.0
   */
  starve(depth = 0) {
    if (depth >= this.maxNextTickBeforeTimer) {
      setTimeout(() => this.starveInternal(0), 0);
    } else {
      Promise.resolve(void 0).then(() => this.starveInternal(depth + 1));
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    this.tasks.scheduleTask(task, priority);
    if (!this.running) {
      this.running = true;
      this.starve();
    }
  }
};
var defaultScheduler = globalValue(Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));
var SyncScheduler = class {
  constructor() {
    /**
     * @since 2.0.0
     */
    __publicField(this, "tasks", new PriorityBuckets());
    /**
     * @since 2.0.0
     */
    __publicField(this, "deferred", false);
  }
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  flush() {
    while (this.tasks.buckets.length > 0) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_, toRun] of tasks) {
        for (let i = 0; i < toRun.length; i++) {
          toRun[i]();
        }
      }
    }
    this.deferred = true;
  }
};
var ControlledScheduler = class {
  constructor() {
    /**
     * @since 2.0.0
     */
    __publicField(this, "tasks", new PriorityBuckets());
    /**
     * @since 2.0.0
     */
    __publicField(this, "deferred", false);
  }
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  step() {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
  }
};
var makeMatrix = (...record2) => {
  const index = record2.sort(([p0], [p1]) => p0 < p1 ? -1 : p0 > p1 ? 1 : 0);
  return {
    shouldYield(fiber) {
      for (const scheduler of record2) {
        const priority = scheduler[1].shouldYield(fiber);
        if (priority !== false) {
          return priority;
        }
      }
      return false;
    },
    scheduleTask(task, priority) {
      let scheduler = void 0;
      for (const i of index) {
        if (priority >= i[0]) {
          scheduler = i[1];
        } else {
          return (scheduler ?? defaultScheduler).scheduleTask(task, priority);
        }
      }
      return (scheduler ?? defaultScheduler).scheduleTask(task, priority);
    }
  };
};
var defaultShouldYield = (fiber) => {
  return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
};
var make39 = (scheduleTask, shouldYield = defaultShouldYield) => ({
  scheduleTask,
  shouldYield
});
var makeBatched = (callback, shouldYield = defaultShouldYield) => {
  let running4 = false;
  const tasks = new PriorityBuckets();
  const starveInternal = () => {
    const tasksToRun = tasks.buckets;
    tasks.buckets = [];
    for (const [_, toRun] of tasksToRun) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (tasks.buckets.length === 0) {
      running4 = false;
    } else {
      starve();
    }
  };
  const starve = () => callback(starveInternal);
  return make39((task, priority) => {
    tasks.scheduleTask(task, priority);
    if (!running4) {
      running4 = true;
      starve();
    }
  }, shouldYield);
};
var timer = (ms, shouldYield = defaultShouldYield) => make39((task) => setTimeout(task, ms), shouldYield);
var timerBatched = (ms, shouldYield = defaultShouldYield) => makeBatched((task) => setTimeout(task, ms), shouldYield);
var currentScheduler = globalValue(Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));
var withScheduler = dual(2, (self, scheduler) => fiberRefLocally(self, currentScheduler, scheduler));

// ../node_modules/effect/dist/esm/internal/completedRequestMap.js
var currentRequestMap = globalValue(Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(/* @__PURE__ */ new Map()));

// ../node_modules/effect/dist/esm/internal/concurrency.js
var match11 = (concurrency, sequential6, unbounded10, bounded10) => {
  switch (concurrency) {
    case void 0:
      return sequential6();
    case "unbounded":
      return unbounded10();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" ? unbounded10() : concurrency2 > 1 ? bounded10(concurrency2) : sequential6());
    default:
      return concurrency > 1 ? bounded10(concurrency) : sequential6();
  }
};
var matchSimple = (concurrency, sequential6, concurrent) => {
  switch (concurrency) {
    case void 0:
      return sequential6();
    case "unbounded":
      return concurrent();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" || concurrency2 > 1 ? concurrent() : sequential6());
    default:
      return concurrency > 1 ? concurrent() : sequential6();
  }
};

// ../node_modules/effect/dist/esm/internal/fiberMessage.js
var OP_INTERRUPT_SIGNAL = "InterruptSignal";
var OP_STATEFUL = "Stateful";
var OP_RESUME = "Resume";
var OP_YIELD_NOW = "YieldNow";
var interruptSignal = (cause3) => ({
  _tag: OP_INTERRUPT_SIGNAL,
  cause: cause3
});
var stateful = (onFiber) => ({
  _tag: OP_STATEFUL,
  onFiber
});
var resume = (effect4) => ({
  _tag: OP_RESUME,
  effect: effect4
});
var yieldNow2 = () => ({
  _tag: OP_YIELD_NOW
});

// ../node_modules/effect/dist/esm/internal/fiberScope.js
var FiberScopeSymbolKey = "effect/FiberScope";
var FiberScopeTypeId = Symbol.for(FiberScopeSymbolKey);
var _a19;
var Global = class {
  constructor() {
    __publicField(this, _a19, FiberScopeTypeId);
    __publicField(this, "fiberId", none4);
    __publicField(this, "roots", /* @__PURE__ */ new Set());
  }
  add(_runtimeFlags, child) {
    this.roots.add(child);
    child.addObserver(() => {
      this.roots.delete(child);
    });
  }
};
_a19 = FiberScopeTypeId;
var _a20;
var Local = class {
  constructor(fiberId5, parent) {
    __publicField(this, "fiberId");
    __publicField(this, "parent");
    __publicField(this, _a20, FiberScopeTypeId);
    this.fiberId = fiberId5;
    this.parent = parent;
  }
  add(_runtimeFlags, child) {
    this.parent.tell(stateful((parentFiber) => {
      parentFiber.addChild(child);
      child.addObserver(() => {
        parentFiber.removeChild(child);
      });
    }));
  }
};
_a20 = FiberScopeTypeId;
var unsafeMake9 = (fiber) => {
  return new Local(fiber.id(), fiber);
};
var globalScope = globalValue(Symbol.for("effect/FiberScope/Global"), () => new Global());

// ../node_modules/effect/dist/esm/internal/fiber.js
var FiberSymbolKey = "effect/Fiber";
var FiberTypeId = Symbol.for(FiberSymbolKey);
var fiberVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var fiberProto = {
  [FiberTypeId]: fiberVariance,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var RuntimeFiberSymbolKey = "effect/Fiber";
var RuntimeFiberTypeId = Symbol.for(RuntimeFiberSymbolKey);
var Order7 = pipe(tuple(Order, Order), mapInput2((fiber) => [fiber.id().startTimeMillis, fiber.id().id]));
var isFiber = (u) => hasProperty(u, FiberTypeId);
var isRuntimeFiber = (self) => RuntimeFiberTypeId in self;
var _await2 = (self) => self.await;
var children = (self) => self.children;
var done5 = (exit3) => ({
  ...fiberProto,
  id: () => none4,
  await: succeed(exit3),
  children: succeed([]),
  inheritAll: void_,
  poll: succeed(some2(exit3)),
  interruptAsFork: () => void_
});
var dump = (self) => map11(self.status, (status3) => ({
  id: self.id(),
  status: status3
}));
var dumpAll = (fibers2) => forEachSequential(fibers2, dump);
var fail5 = (error4) => done5(fail4(error4));
var failCause4 = (cause3) => done5(failCause3(cause3));
var fromEffect = (effect4) => map11(exit(effect4), done5);
var id = (self) => self.id();
var inheritAll = (self) => self.inheritAll;
var interrupted = (fiberId5) => done5(interrupt4(fiberId5));
var interruptAll = (fibers2) => flatMap10(fiberId, (fiberId5) => pipe(fibers2, interruptAllAs(fiberId5)));
var interruptAllAs = dual(2, (fibers2, fiberId5) => pipe(forEachSequentialDiscard(fibers2, interruptAsFork(fiberId5)), zipRight(pipe(fibers2, forEachSequentialDiscard(_await2)))));
var interruptAsFork = dual(2, (self, fiberId5) => self.interruptAsFork(fiberId5));
var join3 = (self) => zipLeft(flatten5(self.await), self.inheritAll);
var map14 = dual(2, (self, f) => mapEffect2(self, (a) => sync(() => f(a))));
var mapEffect2 = dual(2, (self, f) => ({
  ...fiberProto,
  id: () => self.id(),
  await: flatMap10(self.await, forEachEffect(f)),
  children: self.children,
  inheritAll: self.inheritAll,
  poll: flatMap10(self.poll, (result) => {
    switch (result._tag) {
      case "None":
        return succeed(none2());
      case "Some":
        return pipe(forEachEffect(result.value, f), map11(some2));
    }
  }),
  interruptAsFork: (id3) => self.interruptAsFork(id3)
}));
var mapFiber = dual(2, (self, f) => map11(self.await, match7({
  onFailure: (cause3) => failCause4(cause3),
  onSuccess: (a) => f(a)
})));
var match12 = dual(2, (self, {
  onFiber,
  onRuntimeFiber
}) => {
  if (isRuntimeFiber(self)) {
    return onRuntimeFiber(self);
  }
  return onFiber(self);
});
var never2 = {
  ...fiberProto,
  id: () => none4,
  await: never,
  children: succeed([]),
  inheritAll: never,
  poll: succeed(none2()),
  interruptAsFork: () => never
};
var orElse4 = dual(2, (self, that) => ({
  ...fiberProto,
  id: () => getOrElse3(self.id(), that.id()),
  await: zipWith3(self.await, that.await, (exit1, exit22) => isSuccess(exit1) ? exit1 : exit22),
  children: self.children,
  inheritAll: zipRight(that.inheritAll, self.inheritAll),
  poll: zipWith3(self.poll, that.poll, (option1, option22) => {
    switch (option1._tag) {
      case "None": {
        return none2();
      }
      case "Some": {
        return isSuccess(option1.value) ? option1 : option22;
      }
    }
  }),
  interruptAsFork: (id3) => pipe(interruptAsFiber(self, id3), zipRight(pipe(that, interruptAsFiber(id3))), asVoid)
}));
var orElseEither2 = dual(2, (self, that) => orElse4(map14(self, left), map14(that, right)));
var poll3 = (self) => self.poll;
var parseMs = (milliseconds) => {
  const roundTowardsZero = milliseconds > 0 ? Math.floor : Math.ceil;
  return {
    days: roundTowardsZero(milliseconds / 864e5),
    hours: roundTowardsZero(milliseconds / 36e5) % 24,
    minutes: roundTowardsZero(milliseconds / 6e4) % 60,
    seconds: roundTowardsZero(milliseconds / 1e3) % 60,
    milliseconds: roundTowardsZero(milliseconds) % 1e3,
    microseconds: roundTowardsZero(milliseconds * 1e3) % 1e3,
    nanoseconds: roundTowardsZero(milliseconds * 1e6) % 1e3
  };
};
var renderStatus = (status3) => {
  if (isDone3(status3)) {
    return "Done";
  }
  if (isRunning2(status3)) {
    return "Running";
  }
  const isInterruptible = interruptible(status3.runtimeFlags) ? "interruptible" : "uninterruptible";
  return `Suspended(${isInterruptible})`;
};
var pretty2 = (self) => flatMap10(currentTimeMillis2, (now) => map11(dump(self), (dump3) => {
  const time3 = now - dump3.id.startTimeMillis;
  const {
    days: days2,
    hours: hours2,
    milliseconds,
    minutes: minutes2,
    seconds: seconds2
  } = parseMs(time3);
  const lifeMsg = (days2 === 0 ? "" : `${days2}d`) + (days2 === 0 && hours2 === 0 ? "" : `${hours2}h`) + (days2 === 0 && hours2 === 0 && minutes2 === 0 ? "" : `${minutes2}m`) + (days2 === 0 && hours2 === 0 && minutes2 === 0 && seconds2 === 0 ? "" : `${seconds2}s`) + `${milliseconds}ms`;
  const waitMsg = isSuspended2(dump3.status) ? (() => {
    const ids3 = ids2(dump3.status.blockingOn);
    return size4(ids3) > 0 ? `waiting on ` + Array.from(ids3).map((id3) => `${id3}`).join(", ") : "";
  })() : "";
  const statusMsg = renderStatus(dump3.status);
  return `[Fiber](#${dump3.id.id}) (${lifeMsg}) ${waitMsg}
   Status: ${statusMsg}`;
}));
var unsafeRoots = () => Array.from(globalScope.roots);
var roots = sync(unsafeRoots);
var status = (self) => self.status;
var succeed4 = (value8) => done5(succeed3(value8));
var void_3 = succeed4(void 0);
var currentFiberURI = "effect/FiberCurrent";
var getCurrentFiber = () => fromNullable(globalThis[currentFiberURI]);

// ../node_modules/effect/dist/esm/internal/logger.js
var LoggerSymbolKey = "effect/Logger";
var LoggerTypeId = Symbol.for(LoggerSymbolKey);
var loggerVariance = {
  /* c8 ignore next */
  _Message: (_) => _,
  /* c8 ignore next */
  _Output: (_) => _
};
var makeLogger = (log5) => ({
  [LoggerTypeId]: loggerVariance,
  log: log5,
  pipe() {
    return pipeArguments(this, arguments);
  }
});
var mapInput3 = dual(2, (self, f) => makeLogger((options) => self.log({
  ...options,
  message: f(options.message)
})));
var mapInputOptions = dual(2, (self, f) => makeLogger((options) => self.log(f(options))));
var filterLogLevel = dual(2, (self, f) => makeLogger((options) => f(options.logLevel) ? some2(self.log(options)) : none2()));
var map15 = dual(2, (self, f) => makeLogger((options) => f(self.log(options))));
var none7 = {
  [LoggerTypeId]: loggerVariance,
  log: constVoid,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var simple = (log5) => ({
  [LoggerTypeId]: loggerVariance,
  log: ({
    message
  }) => log5(message),
  pipe() {
    return pipeArguments(this, arguments);
  }
});
var succeed5 = (value8) => {
  return simple(() => value8);
};
var sync3 = (evaluate3) => {
  return simple(evaluate3);
};
var zip6 = dual(2, (self, that) => makeLogger((options) => [self.log(options), that.log(options)]));
var zipLeft3 = dual(2, (self, that) => map15(zip6(self, that), (tuple4) => tuple4[0]));
var zipRight3 = dual(2, (self, that) => map15(zip6(self, that), (tuple4) => tuple4[1]));
var stringLogger = makeLogger(({
  annotations: annotations2,
  cause: cause3,
  date: date4,
  fiberId: fiberId5,
  logLevel: logLevel3,
  message,
  spans
}) => {
  const nowMillis = date4.getTime();
  const outputArray = [`timestamp=${date4.toISOString()}`, `level=${logLevel3.label}`, `fiber=${threadName(fiberId5)}`];
  let output = outputArray.join(" ");
  if (Array.isArray(message)) {
    for (let i = 0; i < message.length; i++) {
      const stringMessage = toStringUnknown(message[i]);
      if (stringMessage.length > 0) {
        output = output + " message=";
        output = appendQuoted(stringMessage, output);
      }
    }
  } else {
    const stringMessage = toStringUnknown(message);
    if (stringMessage.length > 0) {
      output = output + " message=";
      output = appendQuoted(stringMessage, output);
    }
  }
  if (cause3 != null && cause3._tag !== "Empty") {
    output = output + " cause=";
    output = appendQuoted(pretty(cause3), output);
  }
  if (isCons(spans)) {
    output = output + " ";
    let first5 = true;
    for (const span4 of spans) {
      if (first5) {
        first5 = false;
      } else {
        output = output + " ";
      }
      output = output + pipe(span4, render4(nowMillis));
    }
  }
  if (pipe(annotations2, size5) > 0) {
    output = output + " ";
    let first5 = true;
    for (const [key, value8] of annotations2) {
      if (first5) {
        first5 = false;
      } else {
        output = output + " ";
      }
      output = output + filterKeyName(key);
      output = output + "=";
      output = appendQuoted(toStringUnknown(value8), output);
    }
  }
  return output;
});
var escapeDoubleQuotes = (str) => `"${str.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
var textOnly = /^[^\s"=]+$/;
var appendQuoted = (label, output) => output + (label.match(textOnly) ? label : escapeDoubleQuotes(label));
var logfmtLogger = makeLogger(({
  annotations: annotations2,
  cause: cause3,
  date: date4,
  fiberId: fiberId5,
  logLevel: logLevel3,
  message,
  spans
}) => {
  const nowMillis = date4.getTime();
  const outputArray = [`timestamp=${date4.toISOString()}`, `level=${logLevel3.label}`, `fiber=${threadName(fiberId5)}`];
  let output = outputArray.join(" ");
  if (Array.isArray(message)) {
    for (let i = 0; i < message.length; i++) {
      const stringMessage = toStringUnknown(message[i], 0);
      if (stringMessage.length > 0) {
        output = output + " message=";
        output = appendQuotedLogfmt(stringMessage, output);
      }
    }
  } else {
    const stringMessage = toStringUnknown(message, 0);
    if (stringMessage.length > 0) {
      output = output + " message=";
      output = appendQuotedLogfmt(stringMessage, output);
    }
  }
  if (cause3 != null && cause3._tag !== "Empty") {
    output = output + " cause=";
    output = appendQuotedLogfmt(pretty(cause3), output);
  }
  if (isCons(spans)) {
    output = output + " ";
    let first5 = true;
    for (const span4 of spans) {
      if (first5) {
        first5 = false;
      } else {
        output = output + " ";
      }
      output = output + pipe(span4, renderLogSpanLogfmt(nowMillis));
    }
  }
  if (pipe(annotations2, size5) > 0) {
    output = output + " ";
    let first5 = true;
    for (const [key, value8] of annotations2) {
      if (first5) {
        first5 = false;
      } else {
        output = output + " ";
      }
      output = output + filterKeyName(key);
      output = output + "=";
      output = appendQuotedLogfmt(toStringUnknown(value8, 0), output);
    }
  }
  return output;
});
var structuredLogger = makeLogger(({
  annotations: annotations2,
  cause: cause3,
  date: date4,
  fiberId: fiberId5,
  logLevel: logLevel3,
  message,
  spans
}) => {
  const now = date4.getTime();
  const annotationsObj = {};
  const spansObj = {};
  if (size5(annotations2) > 0) {
    for (const [k, v] of annotations2) {
      annotationsObj[k] = structuredMessage(v);
    }
  }
  if (isCons(spans)) {
    for (const span4 of spans) {
      spansObj[span4.label] = now - span4.startTime;
    }
  }
  return {
    message: structuredMessage(message),
    logLevel: logLevel3.label,
    timestamp: date4.toISOString(),
    cause: isEmpty6(cause3) ? void 0 : pretty(cause3),
    annotations: annotationsObj,
    spans: spansObj,
    fiberId: threadName(fiberId5)
  };
});
var structuredMessage = (u) => {
  switch (typeof u) {
    case "bigint":
    case "function":
    case "symbol": {
      return String(u);
    }
    default: {
      return u;
    }
  }
};
var jsonLogger = map15(structuredLogger, stringifyCircular);
var filterKeyName = (key) => key.replace(/[\s="]/g, "_");
var escapeDoubleQuotesLogfmt = (str) => JSON.stringify(str);
var appendQuotedLogfmt = (label, output) => output + (label.match(textOnly) ? label : escapeDoubleQuotesLogfmt(label));
var renderLogSpanLogfmt = (now) => (self) => {
  const label = filterKeyName(self.label);
  return `${label}=${now - self.startTime}ms`;
};
var isLogger = (u) => {
  return typeof u === "object" && u != null && LoggerTypeId in u;
};

// ../node_modules/effect/dist/esm/internal/metric/boundaries.js
var MetricBoundariesSymbolKey = "effect/MetricBoundaries";
var MetricBoundariesTypeId = Symbol.for(MetricBoundariesSymbolKey);
var _a21;
var MetricBoundariesImpl = class {
  constructor(values13) {
    __publicField(this, "values");
    __publicField(this, _a21, MetricBoundariesTypeId);
    __publicField(this, "_hash");
    this.values = values13;
    this._hash = pipe(string(MetricBoundariesSymbolKey), combine(array2(this.values)));
  }
  [(_a21 = MetricBoundariesTypeId, symbol2)]() {
    return this._hash;
  }
  [symbol3](u) {
    return isMetricBoundaries(u) && equals(this.values, u.values);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isMetricBoundaries = (u) => hasProperty(u, MetricBoundariesTypeId);
var fromIterable10 = (iterable) => {
  const values13 = pipe(iterable, appendAll(of2(Number.POSITIVE_INFINITY)), dedupe);
  return new MetricBoundariesImpl(values13);
};
var linear = (options) => pipe(makeBy(options.count - 1, (i) => options.start + i * options.width), unsafeFromArray, fromIterable10);
var exponential = (options) => pipe(makeBy(options.count - 1, (i) => options.start * Math.pow(options.factor, i)), unsafeFromArray, fromIterable10);

// ../node_modules/effect/dist/esm/internal/metric/keyType.js
var MetricKeyTypeSymbolKey = "effect/MetricKeyType";
var MetricKeyTypeTypeId = Symbol.for(MetricKeyTypeSymbolKey);
var CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
var CounterKeyTypeTypeId = Symbol.for(CounterKeyTypeSymbolKey);
var FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
var FrequencyKeyTypeTypeId = Symbol.for(FrequencyKeyTypeSymbolKey);
var GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
var GaugeKeyTypeTypeId = Symbol.for(GaugeKeyTypeSymbolKey);
var HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
var HistogramKeyTypeTypeId = Symbol.for(HistogramKeyTypeSymbolKey);
var SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
var SummaryKeyTypeTypeId = Symbol.for(SummaryKeyTypeSymbolKey);
var metricKeyTypeVariance = {
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _Out: (_) => _
};
var _a22, _b2;
var CounterKeyType = class {
  constructor(incremental, bigint4) {
    __publicField(this, "incremental");
    __publicField(this, "bigint");
    __publicField(this, _a22, metricKeyTypeVariance);
    __publicField(this, _b2, CounterKeyTypeTypeId);
    __publicField(this, "_hash");
    this.incremental = incremental;
    this.bigint = bigint4;
    this._hash = string(CounterKeyTypeSymbolKey);
  }
  [(_a22 = MetricKeyTypeTypeId, _b2 = CounterKeyTypeTypeId, symbol2)]() {
    return this._hash;
  }
  [symbol3](that) {
    return isCounterKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var FrequencyKeyTypeHash = string(FrequencyKeyTypeSymbolKey);
var _a23, _b3;
var FrequencyKeyType = class {
  constructor(preregisteredWords) {
    __publicField(this, "preregisteredWords");
    __publicField(this, _a23, metricKeyTypeVariance);
    __publicField(this, _b3, FrequencyKeyTypeTypeId);
    this.preregisteredWords = preregisteredWords;
  }
  [(_a23 = MetricKeyTypeTypeId, _b3 = FrequencyKeyTypeTypeId, symbol2)]() {
    return FrequencyKeyTypeHash;
  }
  [symbol3](that) {
    return isFrequencyKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var GaugeKeyTypeHash = string(GaugeKeyTypeSymbolKey);
var _a24, _b4;
var GaugeKeyType = class {
  constructor(bigint4) {
    __publicField(this, "bigint");
    __publicField(this, _a24, metricKeyTypeVariance);
    __publicField(this, _b4, GaugeKeyTypeTypeId);
    this.bigint = bigint4;
  }
  [(_a24 = MetricKeyTypeTypeId, _b4 = GaugeKeyTypeTypeId, symbol2)]() {
    return GaugeKeyTypeHash;
  }
  [symbol3](that) {
    return isGaugeKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _a25, _b5;
var HistogramKeyType = class {
  constructor(boundaries) {
    __publicField(this, "boundaries");
    __publicField(this, _a25, metricKeyTypeVariance);
    __publicField(this, _b5, HistogramKeyTypeTypeId);
    __publicField(this, "_hash");
    this.boundaries = boundaries;
    this._hash = pipe(string(HistogramKeyTypeSymbolKey), combine(hash(this.boundaries)));
  }
  [(_a25 = MetricKeyTypeTypeId, _b5 = HistogramKeyTypeTypeId, symbol2)]() {
    return this._hash;
  }
  [symbol3](that) {
    return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _a26, _b6;
var SummaryKeyType = class {
  constructor(maxAge, maxSize, error4, quantiles) {
    __publicField(this, "maxAge");
    __publicField(this, "maxSize");
    __publicField(this, "error");
    __publicField(this, "quantiles");
    __publicField(this, _a26, metricKeyTypeVariance);
    __publicField(this, _b6, SummaryKeyTypeTypeId);
    __publicField(this, "_hash");
    this.maxAge = maxAge;
    this.maxSize = maxSize;
    this.error = error4;
    this.quantiles = quantiles;
    this._hash = pipe(string(SummaryKeyTypeSymbolKey), combine(hash(this.maxAge)), combine(hash(this.maxSize)), combine(hash(this.error)), combine(array2(this.quantiles)));
  }
  [(_a26 = MetricKeyTypeTypeId, _b6 = SummaryKeyTypeTypeId, symbol2)]() {
    return this._hash;
  }
  [symbol3](that) {
    return isSummaryKey(that) && equals(this.maxAge, that.maxAge) && this.maxSize === that.maxSize && this.error === that.error && equals(this.quantiles, that.quantiles);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var counter = (options) => new CounterKeyType((options == null ? void 0 : options.incremental) ?? false, (options == null ? void 0 : options.bigint) ?? false);
var frequency = (options) => new FrequencyKeyType((options == null ? void 0 : options.preregisteredWords) ?? []);
var gauge = (options) => new GaugeKeyType((options == null ? void 0 : options.bigint) ?? false);
var histogram = (boundaries) => {
  return new HistogramKeyType(boundaries);
};
var summary = (options) => {
  return new SummaryKeyType(decode(options.maxAge), options.maxSize, options.error, options.quantiles);
};
var isMetricKeyType = (u) => hasProperty(u, MetricKeyTypeTypeId);
var isCounterKey = (u) => hasProperty(u, CounterKeyTypeTypeId);
var isFrequencyKey = (u) => hasProperty(u, FrequencyKeyTypeTypeId);
var isGaugeKey = (u) => hasProperty(u, GaugeKeyTypeTypeId);
var isHistogramKey = (u) => hasProperty(u, HistogramKeyTypeTypeId);
var isSummaryKey = (u) => hasProperty(u, SummaryKeyTypeTypeId);

// ../node_modules/effect/dist/esm/internal/metric/key.js
var MetricKeySymbolKey = "effect/MetricKey";
var MetricKeyTypeId = Symbol.for(MetricKeySymbolKey);
var metricKeyVariance = {
  /* c8 ignore next */
  _Type: (_) => _
};
var arrayEquivilence = getEquivalence(equals);
var _a27;
var MetricKeyImpl = class {
  constructor(name, keyType, description, tags3 = []) {
    __publicField(this, "name");
    __publicField(this, "keyType");
    __publicField(this, "description");
    __publicField(this, "tags");
    __publicField(this, _a27, metricKeyVariance);
    __publicField(this, "_hash");
    this.name = name;
    this.keyType = keyType;
    this.description = description;
    this.tags = tags3;
    this._hash = pipe(string(this.name + this.description), combine(hash(this.keyType)), combine(array2(this.tags)));
  }
  [(_a27 = MetricKeyTypeId, symbol2)]() {
    return this._hash;
  }
  [symbol3](u) {
    return isMetricKey(u) && this.name === u.name && equals(this.keyType, u.keyType) && equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isMetricKey = (u) => hasProperty(u, MetricKeyTypeId);
var counter2 = (name, options) => new MetricKeyImpl(name, counter(options), fromNullable(options == null ? void 0 : options.description));
var frequency2 = (name, options) => new MetricKeyImpl(name, frequency(options), fromNullable(options == null ? void 0 : options.description));
var gauge2 = (name, options) => new MetricKeyImpl(name, gauge(options), fromNullable(options == null ? void 0 : options.description));
var histogram2 = (name, boundaries, description) => new MetricKeyImpl(name, histogram(boundaries), fromNullable(description));
var summary2 = (options) => new MetricKeyImpl(options.name, summary(options), fromNullable(options.description));
var tagged = dual(3, (self, key, value8) => taggedWithLabels(self, [make38(key, value8)]));
var taggedWithLabels = dual(2, (self, extraTags) => extraTags.length === 0 ? self : new MetricKeyImpl(self.name, self.keyType, self.description, union(self.tags, extraTags)));

// ../node_modules/effect/dist/esm/internal/metric/state.js
var MetricStateSymbolKey = "effect/MetricState";
var MetricStateTypeId = Symbol.for(MetricStateSymbolKey);
var CounterStateSymbolKey = "effect/MetricState/Counter";
var CounterStateTypeId = Symbol.for(CounterStateSymbolKey);
var FrequencyStateSymbolKey = "effect/MetricState/Frequency";
var FrequencyStateTypeId = Symbol.for(FrequencyStateSymbolKey);
var GaugeStateSymbolKey = "effect/MetricState/Gauge";
var GaugeStateTypeId = Symbol.for(GaugeStateSymbolKey);
var HistogramStateSymbolKey = "effect/MetricState/Histogram";
var HistogramStateTypeId = Symbol.for(HistogramStateSymbolKey);
var SummaryStateSymbolKey = "effect/MetricState/Summary";
var SummaryStateTypeId = Symbol.for(SummaryStateSymbolKey);
var metricStateVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var _a28, _b7;
var CounterState = class {
  constructor(count9) {
    __publicField(this, "count");
    __publicField(this, _a28, metricStateVariance);
    __publicField(this, _b7, CounterStateTypeId);
    this.count = count9;
  }
  [(_a28 = MetricStateTypeId, _b7 = CounterStateTypeId, symbol2)]() {
    return pipe(hash(CounterStateSymbolKey), combine(hash(this.count)), cached(this));
  }
  [symbol3](that) {
    return isCounterState(that) && this.count === that.count;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var arrayEquals = getEquivalence(equals);
var _a29, _b8;
var FrequencyState = class {
  constructor(occurrences) {
    __publicField(this, "occurrences");
    __publicField(this, _a29, metricStateVariance);
    __publicField(this, _b8, FrequencyStateTypeId);
    __publicField(this, "_hash");
    this.occurrences = occurrences;
  }
  [(_a29 = MetricStateTypeId, _b8 = FrequencyStateTypeId, symbol2)]() {
    return pipe(string(FrequencyStateSymbolKey), combine(array2(fromIterable(this.occurrences.entries()))), cached(this));
  }
  [symbol3](that) {
    return isFrequencyState(that) && arrayEquals(fromIterable(this.occurrences.entries()), fromIterable(that.occurrences.entries()));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _a30, _b9;
var GaugeState = class {
  constructor(value8) {
    __publicField(this, "value");
    __publicField(this, _a30, metricStateVariance);
    __publicField(this, _b9, GaugeStateTypeId);
    this.value = value8;
  }
  [(_a30 = MetricStateTypeId, _b9 = GaugeStateTypeId, symbol2)]() {
    return pipe(hash(GaugeStateSymbolKey), combine(hash(this.value)), cached(this));
  }
  [symbol3](u) {
    return isGaugeState(u) && this.value === u.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _a31, _b10;
var HistogramState = class {
  constructor(buckets, count9, min7, max9, sum6) {
    __publicField(this, "buckets");
    __publicField(this, "count");
    __publicField(this, "min");
    __publicField(this, "max");
    __publicField(this, "sum");
    __publicField(this, _a31, metricStateVariance);
    __publicField(this, _b10, HistogramStateTypeId);
    this.buckets = buckets;
    this.count = count9;
    this.min = min7;
    this.max = max9;
    this.sum = sum6;
  }
  [(_a31 = MetricStateTypeId, _b10 = HistogramStateTypeId, symbol2)]() {
    return pipe(hash(HistogramStateSymbolKey), combine(hash(this.buckets)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol3](that) {
    return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _a32, _b11;
var SummaryState = class {
  constructor(error4, quantiles, count9, min7, max9, sum6) {
    __publicField(this, "error");
    __publicField(this, "quantiles");
    __publicField(this, "count");
    __publicField(this, "min");
    __publicField(this, "max");
    __publicField(this, "sum");
    __publicField(this, _a32, metricStateVariance);
    __publicField(this, _b11, SummaryStateTypeId);
    this.error = error4;
    this.quantiles = quantiles;
    this.count = count9;
    this.min = min7;
    this.max = max9;
    this.sum = sum6;
  }
  [(_a32 = MetricStateTypeId, _b11 = SummaryStateTypeId, symbol2)]() {
    return pipe(hash(SummaryStateSymbolKey), combine(hash(this.error)), combine(hash(this.quantiles)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol3](that) {
    return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var counter3 = (count9) => new CounterState(count9);
var frequency3 = (occurrences) => {
  return new FrequencyState(occurrences);
};
var gauge3 = (count9) => new GaugeState(count9);
var histogram3 = (options) => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum);
var summary3 = (options) => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum);
var isMetricState = (u) => hasProperty(u, MetricStateTypeId);
var isCounterState = (u) => hasProperty(u, CounterStateTypeId);
var isFrequencyState = (u) => hasProperty(u, FrequencyStateTypeId);
var isGaugeState = (u) => hasProperty(u, GaugeStateTypeId);
var isHistogramState = (u) => hasProperty(u, HistogramStateTypeId);
var isSummaryState = (u) => hasProperty(u, SummaryStateTypeId);

// ../node_modules/effect/dist/esm/internal/metric/hook.js
var MetricHookSymbolKey = "effect/MetricHook";
var MetricHookTypeId = Symbol.for(MetricHookSymbolKey);
var metricHookVariance = {
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _Out: (_) => _
};
var make40 = (options) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
var onUpdate = dual(2, (self, f) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  get: self.get,
  update: (input) => {
    self.update(input);
    return f(input);
  }
}));
var bigint05 = BigInt(0);
var counter4 = (key) => {
  let sum6 = key.keyType.bigint ? bigint05 : 0;
  const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value8) => value8 >= bigint05 : (value8) => value8 >= 0 : (_value) => true;
  return make40({
    get: () => counter3(sum6),
    update: (value8) => {
      if (canUpdate(value8)) {
        sum6 = sum6 + value8;
      }
    }
  });
};
var frequency4 = (key) => {
  const values13 = /* @__PURE__ */ new Map();
  for (const word of key.keyType.preregisteredWords) {
    values13.set(word, 0);
  }
  const update16 = (word) => {
    const slotCount = values13.get(word) ?? 0;
    values13.set(word, slotCount + 1);
  };
  return make40({
    get: () => frequency3(values13),
    update: update16
  });
};
var gauge4 = (_key, startAt) => {
  let value8 = startAt;
  return make40({
    get: () => gauge3(value8),
    update: (v) => {
      value8 = v;
    }
  });
};
var histogram4 = (key) => {
  const bounds = key.keyType.boundaries.values;
  const size38 = bounds.length;
  const values13 = new Uint32Array(size38 + 1);
  const boundaries = new Float32Array(size38);
  let count9 = 0;
  let sum6 = 0;
  let min7 = Number.MAX_VALUE;
  let max9 = Number.MIN_VALUE;
  pipe(bounds, sort(Order), map3((n, i) => {
    boundaries[i] = n;
  }));
  const update16 = (value8) => {
    let from = 0;
    let to = size38;
    while (from !== to) {
      const mid = Math.floor(from + (to - from) / 2);
      const boundary = boundaries[mid];
      if (value8 <= boundary) {
        to = mid;
      } else {
        from = mid;
      }
      if (to === from + 1) {
        if (value8 <= boundaries[from]) {
          to = from;
        } else {
          from = to;
        }
      }
    }
    values13[from] = values13[from] + 1;
    count9 = count9 + 1;
    sum6 = sum6 + value8;
    if (value8 < min7) {
      min7 = value8;
    }
    if (value8 > max9) {
      max9 = value8;
    }
  };
  const getBuckets = () => {
    const builder = allocate(size38);
    let cumulated = 0;
    for (let i = 0; i < size38; i++) {
      const boundary = boundaries[i];
      const value8 = values13[i];
      cumulated = cumulated + value8;
      builder[i] = [boundary, cumulated];
    }
    return builder;
  };
  return make40({
    get: () => histogram3({
      buckets: getBuckets(),
      count: count9,
      min: min7,
      max: max9,
      sum: sum6
    }),
    update: update16
  });
};
var summary4 = (key) => {
  const {
    error: error4,
    maxAge,
    maxSize,
    quantiles
  } = key.keyType;
  const sortedQuantiles = pipe(quantiles, sort(Order));
  const values13 = allocate(maxSize);
  let head11 = 0;
  let count9 = 0;
  let sum6 = 0;
  let min7 = Number.MAX_VALUE;
  let max9 = Number.MIN_VALUE;
  const snapshot3 = (now) => {
    const builder = [];
    let i = 0;
    while (i !== maxSize - 1) {
      const item = values13[i];
      if (item != null) {
        const [t, v] = item;
        const age = millis(now - t);
        if (greaterThanOrEqualTo4(age, zero2) && age <= maxAge) {
          builder.push(v);
        }
      }
      i = i + 1;
    }
    return calculateQuantiles(error4, sortedQuantiles, sort(builder, Order));
  };
  const observe = (value8, timestamp) => {
    if (maxSize > 0) {
      head11 = head11 + 1;
      const target = head11 % maxSize;
      values13[target] = [timestamp, value8];
    }
    count9 = count9 + 1;
    sum6 = sum6 + value8;
    if (value8 < min7) {
      min7 = value8;
    }
    if (value8 > max9) {
      max9 = value8;
    }
  };
  return make40({
    get: () => summary3({
      error: error4,
      quantiles: snapshot3(Date.now()),
      count: count9,
      min: min7,
      max: max9,
      sum: sum6
    }),
    update: ([value8, timestamp]) => observe(value8, timestamp)
  });
};
var calculateQuantiles = (error4, sortedQuantiles, sortedSamples) => {
  const sampleCount = sortedSamples.length;
  if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
    return empty2();
  }
  const head11 = sortedQuantiles[0];
  const tail4 = sortedQuantiles.slice(1);
  const resolvedHead = resolveQuantile(error4, sampleCount, none2(), 0, head11, sortedSamples);
  const resolved = of(resolvedHead);
  tail4.forEach((quantile) => {
    resolved.push(resolveQuantile(error4, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
  });
  return map3(resolved, (rq) => [rq.quantile, rq.value]);
};
var resolveQuantile = (error4, sampleCount, current2, consumed, quantile, rest) => {
  let error_1 = error4;
  let sampleCount_1 = sampleCount;
  let current_1 = current2;
  let consumed_1 = consumed;
  let quantile_1 = quantile;
  let rest_1 = rest;
  let error_2 = error4;
  let sampleCount_2 = sampleCount;
  let current_2 = current2;
  let consumed_2 = consumed;
  let quantile_2 = quantile;
  let rest_2 = rest;
  while (1) {
    if (!isNonEmptyReadonlyArray(rest_1)) {
      return {
        quantile: quantile_1,
        value: none2(),
        consumed: consumed_1,
        rest: []
      };
    }
    if (quantile_1 === 1) {
      return {
        quantile: quantile_1,
        value: some2(lastNonEmpty(rest_1)),
        consumed: consumed_1 + rest_1.length,
        rest: []
      };
    }
    const sameHead = span(rest_1, (n) => n <= rest_1[0]);
    const desired = quantile_1 * sampleCount_1;
    const allowedError = error_1 / 2 * desired;
    const candConsumed = consumed_1 + sameHead[0].length;
    const candError = Math.abs(candConsumed - desired);
    if (candConsumed < desired - allowedError) {
      error_2 = error_1;
      sampleCount_2 = sampleCount_1;
      current_2 = head(rest_1);
      consumed_2 = candConsumed;
      quantile_2 = quantile_1;
      rest_2 = sameHead[1];
      error_1 = error_2;
      sampleCount_1 = sampleCount_2;
      current_1 = current_2;
      consumed_1 = consumed_2;
      quantile_1 = quantile_2;
      rest_1 = rest_2;
      continue;
    }
    if (candConsumed > desired + allowedError) {
      return {
        quantile: quantile_1,
        value: current_1,
        consumed: consumed_1,
        rest: rest_1
      };
    }
    switch (current_1._tag) {
      case "None": {
        error_2 = error_1;
        sampleCount_2 = sampleCount_1;
        current_2 = head(rest_1);
        consumed_2 = candConsumed;
        quantile_2 = quantile_1;
        rest_2 = sameHead[1];
        error_1 = error_2;
        sampleCount_1 = sampleCount_2;
        current_1 = current_2;
        consumed_1 = consumed_2;
        quantile_1 = quantile_2;
        rest_1 = rest_2;
        continue;
      }
      case "Some": {
        const prevError = Math.abs(desired - current_1.value);
        if (candError < prevError) {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
        return {
          quantile: quantile_1,
          value: some2(current_1.value),
          consumed: consumed_1,
          rest: rest_1
        };
      }
    }
  }
  throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
};

// ../node_modules/effect/dist/esm/internal/metric/pair.js
var MetricPairSymbolKey = "effect/MetricPair";
var MetricPairTypeId = Symbol.for(MetricPairSymbolKey);
var metricPairVariance = {
  /* c8 ignore next */
  _Type: (_) => _
};
var make41 = (metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
};
var unsafeMake10 = (metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
};

// ../node_modules/effect/dist/esm/internal/metric/registry.js
var MetricRegistrySymbolKey = "effect/MetricRegistry";
var MetricRegistryTypeId = Symbol.for(MetricRegistrySymbolKey);
var _a33;
var MetricRegistryImpl = class {
  constructor() {
    __publicField(this, _a33, MetricRegistryTypeId);
    __publicField(this, "map", empty21());
  }
  snapshot() {
    const result = [];
    for (const [key, hook] of this.map) {
      result.push(unsafeMake10(key, hook.get()));
    }
    return result;
  }
  get(key) {
    const hook = pipe(this.map, get7(key), getOrUndefined);
    if (hook == null) {
      if (isCounterKey(key.keyType)) {
        return this.getCounter(key);
      }
      if (isGaugeKey(key.keyType)) {
        return this.getGauge(key);
      }
      if (isFrequencyKey(key.keyType)) {
        return this.getFrequency(key);
      }
      if (isHistogramKey(key.keyType)) {
        return this.getHistogram(key);
      }
      if (isSummaryKey(key.keyType)) {
        return this.getSummary(key);
      }
      throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
    } else {
      return hook;
    }
  }
  getCounter(key) {
    let value8 = pipe(this.map, get7(key), getOrUndefined);
    if (value8 == null) {
      const counter11 = counter4(key);
      if (!pipe(this.map, has5(key))) {
        pipe(this.map, set4(key, counter11));
      }
      value8 = counter11;
    }
    return value8;
  }
  getFrequency(key) {
    let value8 = pipe(this.map, get7(key), getOrUndefined);
    if (value8 == null) {
      const frequency11 = frequency4(key);
      if (!pipe(this.map, has5(key))) {
        pipe(this.map, set4(key, frequency11));
      }
      value8 = frequency11;
    }
    return value8;
  }
  getGauge(key) {
    let value8 = pipe(this.map, get7(key), getOrUndefined);
    if (value8 == null) {
      const gauge11 = gauge4(key, key.keyType.bigint ? BigInt(0) : 0);
      if (!pipe(this.map, has5(key))) {
        pipe(this.map, set4(key, gauge11));
      }
      value8 = gauge11;
    }
    return value8;
  }
  getHistogram(key) {
    let value8 = pipe(this.map, get7(key), getOrUndefined);
    if (value8 == null) {
      const histogram11 = histogram4(key);
      if (!pipe(this.map, has5(key))) {
        pipe(this.map, set4(key, histogram11));
      }
      value8 = histogram11;
    }
    return value8;
  }
  getSummary(key) {
    let value8 = pipe(this.map, get7(key), getOrUndefined);
    if (value8 == null) {
      const summary11 = summary4(key);
      if (!pipe(this.map, has5(key))) {
        pipe(this.map, set4(key, summary11));
      }
      value8 = summary11;
    }
    return value8;
  }
};
_a33 = MetricRegistryTypeId;
var make42 = () => {
  return new MetricRegistryImpl();
};

// ../node_modules/effect/dist/esm/internal/metric.js
var MetricSymbolKey = "effect/Metric";
var MetricTypeId = Symbol.for(MetricSymbolKey);
var metricVariance = {
  /* c8 ignore next */
  _Type: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _Out: (_) => _
};
var globalMetricRegistry = globalValue(Symbol.for("effect/Metric/globalMetricRegistry"), () => make42());
var make43 = function(keyType, unsafeUpdate, unsafeValue) {
  const metric = Object.assign((effect4) => tap(effect4, (a) => update5(metric, a)), {
    [MetricTypeId]: metricVariance,
    keyType,
    unsafeUpdate,
    unsafeValue,
    register() {
      this.unsafeValue([]);
      return this;
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  });
  return metric;
};
var mapInput4 = dual(2, (self, f) => make43(self.keyType, (input, extraTags) => self.unsafeUpdate(f(input), extraTags), self.unsafeValue));
var counter5 = (name, options) => fromMetricKey(counter2(name, options));
var frequency5 = (name, options) => fromMetricKey(frequency2(name, options));
var withConstantInput = dual(2, (self, input) => mapInput4(self, () => input));
var fromMetricKey = (key) => {
  let untaggedHook;
  const hookCache = /* @__PURE__ */ new WeakMap();
  const hook = (extraTags) => {
    if (extraTags.length === 0) {
      if (untaggedHook !== void 0) {
        return untaggedHook;
      }
      untaggedHook = globalMetricRegistry.get(key);
      return untaggedHook;
    }
    let hook2 = hookCache.get(extraTags);
    if (hook2 !== void 0) {
      return hook2;
    }
    hook2 = globalMetricRegistry.get(taggedWithLabels(key, extraTags));
    hookCache.set(extraTags, hook2);
    return hook2;
  };
  return make43(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get());
};
var gauge5 = (name, options) => fromMetricKey(gauge2(name, options));
var histogram5 = (name, boundaries, description) => fromMetricKey(histogram2(name, boundaries, description));
var increment3 = (self) => update5(self, self.keyType.bigint ? BigInt(1) : 1);
var incrementBy = dual(2, (self, amount) => update5(self, amount));
var map16 = dual(2, (self, f) => make43(self.keyType, self.unsafeUpdate, (extraTags) => f(self.unsafeValue(extraTags))));
var mapType = dual(2, (self, f) => make43(f(self.keyType), self.unsafeUpdate, self.unsafeValue));
var set7 = dual(2, (self, value8) => update5(self, value8));
var succeed6 = (out) => make43(void 0, constVoid, () => out);
var sync4 = (evaluate3) => make43(void 0, constVoid, evaluate3);
var summary5 = (options) => withNow(summaryTimestamp(options));
var summaryTimestamp = (options) => fromMetricKey(summary2(options));
var tagged2 = dual(3, (self, key, value8) => taggedWithLabels2(self, [make38(key, value8)]));
var taggedWithLabelsInput = dual(2, (self, f) => map16(make43(self.keyType, (input, extraTags) => self.unsafeUpdate(input, union(f(input), extraTags)), self.unsafeValue), constVoid));
var taggedWithLabels2 = dual(2, (self, extraTags) => {
  return make43(self.keyType, (input, extraTags1) => self.unsafeUpdate(input, union(extraTags, extraTags1)), (extraTags1) => self.unsafeValue(union(extraTags, extraTags1)));
});
var timer2 = (name, description) => {
  const boundaries = exponential({
    start: 0.5,
    factor: 2,
    count: 35
  });
  const base = pipe(histogram5(name, boundaries, description), tagged2("time_unit", "milliseconds"));
  return mapInput4(base, toMillis);
};
var timerWithBoundaries = (name, boundaries, description) => {
  const base = pipe(histogram5(name, fromIterable10(boundaries), description), tagged2("time_unit", "milliseconds"));
  return mapInput4(base, toMillis);
};
var trackAll = dual(2, (self, input) => (effect4) => matchCauseEffect(effect4, {
  onFailure: (cause3) => zipRight(update5(self, input), failCause(cause3)),
  onSuccess: (value8) => zipRight(update5(self, input), succeed(value8))
}));
var trackDefect = dual(2, (self, metric) => trackDefectWith(self, metric, identity));
var trackDefectWith = dual(3, (self, metric, f) => {
  const updater = (defect) => update5(metric, f(defect));
  return tapDefect(self, (cause3) => forEachSequentialDiscard(defects(cause3), updater));
});
var trackDuration = dual(2, (self, metric) => trackDurationWith(self, metric, identity));
var trackDurationWith = dual(3, (self, metric, f) => clockWith2((clock3) => {
  const startTime = clock3.unsafeCurrentTimeNanos();
  return tap(self, (_) => {
    const endTime = clock3.unsafeCurrentTimeNanos();
    const duration5 = nanos(endTime - startTime);
    return update5(metric, f(duration5));
  });
}));
var trackError = dual(2, (self, metric) => trackErrorWith(self, metric, (a) => a));
var trackErrorWith = dual(3, (self, metric, f) => {
  const updater = (error4) => update5(metric, f(error4));
  return tapError(self, updater);
});
var trackSuccess = dual(2, (self, metric) => trackSuccessWith(self, metric, (a) => a));
var trackSuccessWith = dual(3, (self, metric, f) => {
  const updater = (value8) => update5(metric, f(value8));
  return tap(self, updater);
});
var update5 = dual(2, (self, input) => fiberRefGetWith(currentMetricLabels, (tags3) => sync(() => self.unsafeUpdate(input, tags3))));
var value = (self) => fiberRefGetWith(currentMetricLabels, (tags3) => sync(() => self.unsafeValue(tags3)));
var withNow = (self) => mapInput4(self, (input) => [input, Date.now()]);
var zip7 = dual(2, (self, that) => make43([self.keyType, that.keyType], (input, extraTags) => {
  const [l, r] = input;
  self.unsafeUpdate(l, extraTags);
  that.unsafeUpdate(r, extraTags);
}, (extraTags) => [self.unsafeValue(extraTags), that.unsafeValue(extraTags)]));
var unsafeSnapshot = () => globalMetricRegistry.snapshot();
var snapshot = sync(unsafeSnapshot);

// ../node_modules/effect/dist/esm/internal/request.js
var RequestSymbolKey = "effect/Request";
var RequestTypeId = Symbol.for(RequestSymbolKey);
var requestVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var RequestPrototype = {
  ...StructuralPrototype,
  [RequestTypeId]: requestVariance
};
var isRequest = (u) => hasProperty(u, RequestTypeId);
var of4 = () => (args) => Object.assign(Object.create(RequestPrototype), args);
var tagged3 = (tag4) => (args) => {
  const request2 = Object.assign(Object.create(RequestPrototype), args);
  request2._tag = tag4;
  return request2;
};
var Class2 = function() {
  function Class6(args) {
    if (args) {
      Object.assign(this, args);
    }
  }
  Class6.prototype = RequestPrototype;
  return Class6;
}();
var TaggedClass = (tag4) => {
  return class TaggedClass extends Class2 {
    constructor() {
      super(...arguments);
      __publicField(this, "_tag", tag4);
    }
  };
};
var complete2 = dual(2, (self, result) => fiberRefGetWith(currentRequestMap, (map43) => sync(() => {
  if (map43.has(self)) {
    const entry = map43.get(self);
    if (!entry.state.completed) {
      entry.state.completed = true;
      deferredUnsafeDone(entry.result, result);
    }
  }
})));
var completeEffect = dual(2, (self, effect4) => matchEffect(effect4, {
  onFailure: (error4) => complete2(self, exitFail(error4)),
  onSuccess: (value8) => complete2(self, exitSucceed(value8))
}));
var fail6 = dual(2, (self, error4) => complete2(self, exitFail(error4)));
var failCause5 = dual(2, (self, cause3) => complete2(self, exitFailCause(cause3)));
var succeed7 = dual(2, (self, value8) => complete2(self, exitSucceed(value8)));
var Listeners = class {
  constructor() {
    __publicField(this, "count", 0);
    __publicField(this, "observers", /* @__PURE__ */ new Set());
    __publicField(this, "interrupted", false);
  }
  addObserver(f) {
    this.observers.add(f);
  }
  removeObserver(f) {
    this.observers.delete(f);
  }
  increment() {
    this.count++;
    this.observers.forEach((f) => f(this.count));
  }
  decrement() {
    this.count--;
    this.observers.forEach((f) => f(this.count));
  }
};

// ../node_modules/effect/dist/esm/SortedSet.js
var SortedSet_exports = {};
__export(SortedSet_exports, {
  add: () => add5,
  difference: () => difference3,
  empty: () => empty30,
  every: () => every8,
  filter: () => filter9,
  flatMap: () => flatMap12,
  forEach: () => forEach10,
  fromIterable: () => fromIterable13,
  getEquivalence: () => getEquivalence4,
  has: () => has8,
  intersection: () => intersection5,
  isSortedSet: () => isSortedSet,
  isSubset: () => isSubset3,
  make: () => make46,
  map: () => map17,
  partition: () => partition6,
  remove: () => remove9,
  size: () => size11,
  some: () => some8,
  toggle: () => toggle4,
  union: () => union7,
  values: () => values7
});

// ../node_modules/effect/dist/esm/RedBlackTree.js
var RedBlackTree_exports = {};
__export(RedBlackTree_exports, {
  Direction: () => Direction2,
  at: () => at2,
  atReversed: () => atReversed,
  empty: () => empty29,
  findAll: () => findAll2,
  findFirst: () => findFirst8,
  first: () => first2,
  forEach: () => forEach9,
  forEachBetween: () => forEachBetween2,
  forEachGreaterThanEqual: () => forEachGreaterThanEqual2,
  forEachLessThan: () => forEachLessThan2,
  fromIterable: () => fromIterable12,
  getAt: () => getAt2,
  getOrder: () => getOrder2,
  greaterThan: () => greaterThan7,
  greaterThanEqual: () => greaterThanEqual3,
  greaterThanEqualReversed: () => greaterThanEqualReversed,
  greaterThanReversed: () => greaterThanReversed,
  has: () => has7,
  insert: () => insert2,
  isRedBlackTree: () => isRedBlackTree2,
  keys: () => keys4,
  keysReversed: () => keysReversed,
  last: () => last5,
  lessThan: () => lessThan7,
  lessThanEqual: () => lessThanEqual3,
  lessThanEqualReversed: () => lessThanEqualReversed,
  lessThanReversed: () => lessThanReversed,
  make: () => make45,
  reduce: () => reduce12,
  removeFirst: () => removeFirst2,
  reversed: () => reversed2,
  size: () => size10,
  values: () => values6,
  valuesReversed: () => valuesReversed
});

// ../node_modules/effect/dist/esm/internal/redBlackTree/iterator.js
var Direction = {
  Forward: 0,
  Backward: 1 << 0
};
var RedBlackTreeIterator = class _RedBlackTreeIterator {
  constructor(self, stack, direction) {
    __publicField(this, "self");
    __publicField(this, "stack");
    __publicField(this, "direction");
    __publicField(this, "count", 0);
    this.self = self;
    this.stack = stack;
    this.direction = direction;
  }
  /**
   * Clones the iterator
   */
  clone() {
    return new _RedBlackTreeIterator(this.self, this.stack.slice(), this.direction);
  }
  /**
   * Reverse the traversal direction
   */
  reversed() {
    return new _RedBlackTreeIterator(this.self, this.stack.slice(), this.direction === Direction.Forward ? Direction.Backward : Direction.Forward);
  }
  /**
   * Iterator next
   */
  next() {
    const entry = this.entry;
    this.count++;
    if (this.direction === Direction.Forward) {
      this.moveNext();
    } else {
      this.movePrev();
    }
    switch (entry._tag) {
      case "None": {
        return {
          done: true,
          value: this.count
        };
      }
      case "Some": {
        return {
          done: false,
          value: entry.value
        };
      }
    }
  }
  /**
   * Returns the key
   */
  get key() {
    if (this.stack.length > 0) {
      return some2(this.stack[this.stack.length - 1].key);
    }
    return none2();
  }
  /**
   * Returns the value
   */
  get value() {
    if (this.stack.length > 0) {
      return some2(this.stack[this.stack.length - 1].value);
    }
    return none2();
  }
  /**
   * Returns the key
   */
  get entry() {
    return map2(last(this.stack), (node) => [node.key, node.value]);
  }
  /**
   * Returns the position of this iterator in the sorted list
   */
  get index() {
    let idx = 0;
    const stack = this.stack;
    if (stack.length === 0) {
      const r = this.self._root;
      if (r != null) {
        return r.count;
      }
      return 0;
    } else if (stack[stack.length - 1].left != null) {
      idx = stack[stack.length - 1].left.count;
    }
    for (let s = stack.length - 2; s >= 0; --s) {
      if (stack[s + 1] === stack[s].right) {
        ;
        ++idx;
        if (stack[s].left != null) {
          idx += stack[s].left.count;
        }
      }
    }
    return idx;
  }
  /**
   * Advances iterator to next element in list
   */
  moveNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n.right != null) {
      n = n.right;
      while (n != null) {
        stack.push(n);
        n = n.left;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].right === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  /**
   * Checks if there is a next element
   */
  get hasNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].right != null) {
      return true;
    }
    for (let s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].left === stack[s]) {
        return true;
      }
    }
    return false;
  }
  /**
   * Advances iterator to previous element in list
   */
  movePrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n != null && n.left != null) {
      n = n.left;
      while (n != null) {
        stack.push(n);
        n = n.right;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].left === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  /**
   * Checks if there is a previous element
   */
  get hasPrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].left != null) {
      return true;
    }
    for (let s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].right === stack[s]) {
        return true;
      }
    }
    return false;
  }
};

// ../node_modules/effect/dist/esm/internal/redBlackTree/node.js
var Color = {
  Red: 0,
  Black: 1 << 0
};
var clone = ({
  color,
  count: count9,
  key,
  left: left2,
  right: right2,
  value: value8
}) => ({
  color,
  key,
  value: value8,
  left: left2,
  right: right2,
  count: count9
});
function swap2(n, v) {
  n.key = v.key;
  n.value = v.value;
  n.left = v.left;
  n.right = v.right;
  n.color = v.color;
  n.count = v.count;
}
var repaint = ({
  count: count9,
  key,
  left: left2,
  right: right2,
  value: value8
}, color) => ({
  color,
  key,
  value: value8,
  left: left2,
  right: right2,
  count: count9
});
var recount = (node) => {
  var _a91, _b22;
  node.count = 1 + (((_a91 = node.left) == null ? void 0 : _a91.count) ?? 0) + (((_b22 = node.right) == null ? void 0 : _b22.count) ?? 0);
};

// ../node_modules/effect/dist/esm/internal/redBlackTree.js
var RedBlackTreeSymbolKey = "effect/RedBlackTree";
var RedBlackTreeTypeId = Symbol.for(RedBlackTreeSymbolKey);
var redBlackTreeVariance = {
  /* c8 ignore next */
  _Key: (_) => _,
  /* c8 ignore next */
  _Value: (_) => _
};
var RedBlackTreeProto = {
  [RedBlackTreeTypeId]: redBlackTreeVariance,
  [symbol2]() {
    let hash3 = hash(RedBlackTreeSymbolKey);
    for (const item of this) {
      hash3 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash3);
  },
  [symbol3](that) {
    var _a91, _b22;
    if (isRedBlackTree(that)) {
      if ((((_a91 = this._root) == null ? void 0 : _a91.count) ?? 0) !== (((_b22 = that._root) == null ? void 0 : _b22.count) ?? 0)) {
        return false;
      }
      const entries6 = Array.from(that);
      return Array.from(this).every((itemSelf, i) => {
        const itemThat = entries6[i];
        return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  [Symbol.iterator]() {
    const stack = [];
    let n = this._root;
    while (n != null) {
      stack.push(n);
      n = n.left;
    }
    return new RedBlackTreeIterator(this, stack, Direction.Forward);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "RedBlackTree",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl3 = (ord, root) => {
  const tree = Object.create(RedBlackTreeProto);
  tree._ord = ord;
  tree._root = root;
  return tree;
};
var isRedBlackTree = (u) => hasProperty(u, RedBlackTreeTypeId);
var empty28 = (ord) => makeImpl3(ord, void 0);
var fromIterable11 = dual(2, (entries6, ord) => {
  let tree = empty28(ord);
  for (const [key, value8] of entries6) {
    tree = insert(tree, key, value8);
  }
  return tree;
});
var make44 = (ord) => (...entries6) => {
  return fromIterable11(entries6, ord);
};
var atBackwards = dual(2, (self, index) => at(self, index, Direction.Backward));
var atForwards = dual(2, (self, index) => at(self, index, Direction.Forward));
var at = (self, index, direction) => {
  return {
    [Symbol.iterator]: () => {
      if (index < 0) {
        return new RedBlackTreeIterator(self, [], direction);
      }
      let node = self._root;
      const stack = [];
      while (node !== void 0) {
        stack.push(node);
        if (node.left !== void 0) {
          if (index < node.left.count) {
            node = node.left;
            continue;
          }
          index -= node.left.count;
        }
        if (!index) {
          return new RedBlackTreeIterator(self, stack, direction);
        }
        index -= 1;
        if (node.right !== void 0) {
          if (index >= node.right.count) {
            break;
          }
          node = node.right;
        } else {
          break;
        }
      }
      return new RedBlackTreeIterator(self, [], direction);
    }
  };
};
var findAll = dual(2, (self, key) => {
  const stack = [];
  let node = self._root;
  let result = empty5();
  while (node !== void 0 || stack.length > 0) {
    if (node) {
      stack.push(node);
      node = node.left;
    } else {
      const current2 = stack.pop();
      if (equals(key, current2.key)) {
        result = prepend2(current2.value)(result);
      }
      node = current2.right;
    }
  }
  return result;
});
var findFirst7 = dual(2, (self, key) => {
  const cmp = self._ord;
  let node = self._root;
  while (node !== void 0) {
    const d = cmp(key, node.key);
    if (equals(key, node.key)) {
      return some2(node.value);
    }
    if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  return none2();
});
var first = (self) => {
  let node = self._root;
  let current2 = self._root;
  while (node !== void 0) {
    current2 = node;
    node = node.left;
  }
  return current2 ? some2([current2.key, current2.value]) : none2();
};
var getAt = dual(2, (self, index) => {
  if (index < 0) {
    return none2();
  }
  let root = self._root;
  let node = void 0;
  while (root !== void 0) {
    node = root;
    if (root.left) {
      if (index < root.left.count) {
        root = root.left;
        continue;
      }
      index -= root.left.count;
    }
    if (!index) {
      return some2([node.key, node.value]);
    }
    index -= 1;
    if (root.right) {
      if (index >= root.right.count) {
        break;
      }
      root = root.right;
    } else {
      break;
    }
  }
  return none2();
});
var getOrder = (tree) => tree._ord;
var has6 = dual(2, (self, key) => isSome(findFirst7(self, key)));
var insert = dual(3, (self, key, value8) => {
  const cmp = self._ord;
  let n = self._root;
  const n_stack = [];
  const d_stack = [];
  while (n != null) {
    const d = cmp(key, n.key);
    n_stack.push(n);
    d_stack.push(d);
    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  n_stack.push({
    color: Color.Red,
    key,
    value: value8,
    left: void 0,
    right: void 0,
    count: 1
  });
  for (let s = n_stack.length - 2; s >= 0; --s) {
    const n2 = n_stack[s];
    if (d_stack[s] <= 0) {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n_stack[s + 1],
        right: n2.right,
        count: n2.count + 1
      };
    } else {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n2.left,
        right: n_stack[s + 1],
        count: n2.count + 1
      };
    }
  }
  for (let s = n_stack.length - 1; s > 1; --s) {
    const p = n_stack[s - 1];
    const n3 = n_stack[s];
    if (p.color === Color.Black || n3.color === Color.Black) {
      break;
    }
    const pp = n_stack[s - 2];
    if (pp.left === p) {
      if (p.left === n3) {
        const y = pp.right;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.right = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          pp.color = Color.Red;
          pp.left = p.right;
          p.color = Color.Black;
          p.right = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n3;
          recount(pp);
          recount(p);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = p;
            } else {
              ppp.right = p;
            }
          }
          break;
        }
      } else {
        const y = pp.right;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.right = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          p.right = n3.left;
          pp.color = Color.Red;
          pp.left = n3.right;
          n3.color = Color.Black;
          n3.left = p;
          n3.right = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = n3;
            } else {
              ppp.right = n3;
            }
          }
          break;
        }
      }
    } else {
      if (p.right === n3) {
        const y = pp.left;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.left = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          pp.color = Color.Red;
          pp.right = p.left;
          p.color = Color.Black;
          p.left = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n3;
          recount(pp);
          recount(p);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = p;
            } else {
              ppp.left = p;
            }
          }
          break;
        }
      } else {
        const y = pp.left;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.left = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          p.left = n3.right;
          pp.color = Color.Red;
          pp.right = n3.left;
          n3.color = Color.Black;
          n3.right = p;
          n3.left = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = n3;
            } else {
              ppp.left = n3;
            }
          }
          break;
        }
      }
    }
  }
  n_stack[0].color = Color.Black;
  return makeImpl3(self._ord, n_stack[0]);
});
var keysForward = (self) => keys3(self, Direction.Forward);
var keysBackward = (self) => keys3(self, Direction.Backward);
var keys3 = (self, direction) => {
  const begin = self[Symbol.iterator]();
  let count9 = 0;
  return {
    [Symbol.iterator]: () => keys3(self, direction),
    next: () => {
      count9++;
      const entry = begin.key;
      if (direction === Direction.Forward) {
        begin.moveNext();
      } else {
        begin.movePrev();
      }
      switch (entry._tag) {
        case "None": {
          return {
            done: true,
            value: count9
          };
        }
        case "Some": {
          return {
            done: false,
            value: entry.value
          };
        }
      }
    }
  };
};
var last4 = (self) => {
  let node = self._root;
  let current2 = self._root;
  while (node !== void 0) {
    current2 = node;
    node = node.right;
  }
  return current2 ? some2([current2.key, current2.value]) : none2();
};
var reversed = (self) => {
  return {
    [Symbol.iterator]: () => {
      const stack = [];
      let node = self._root;
      while (node !== void 0) {
        stack.push(node);
        node = node.right;
      }
      return new RedBlackTreeIterator(self, stack, Direction.Backward);
    }
  };
};
var greaterThanBackwards = dual(2, (self, key) => greaterThan6(self, key, Direction.Backward));
var greaterThanForwards = dual(2, (self, key) => greaterThan6(self, key, Direction.Forward));
var greaterThan6 = (self, key, direction) => {
  return {
    [Symbol.iterator]: () => {
      const cmp = self._ord;
      let node = self._root;
      const stack = [];
      let last_ptr = 0;
      while (node !== void 0) {
        const d = cmp(key, node.key);
        stack.push(node);
        if (d < 0) {
          last_ptr = stack.length;
        }
        if (d < 0) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(self, stack, direction);
    }
  };
};
var greaterThanEqualBackwards = dual(2, (self, key) => greaterThanEqual2(self, key, Direction.Backward));
var greaterThanEqualForwards = dual(2, (self, key) => greaterThanEqual2(self, key, Direction.Forward));
var greaterThanEqual2 = (self, key, direction = Direction.Forward) => {
  return {
    [Symbol.iterator]: () => {
      const cmp = self._ord;
      let node = self._root;
      const stack = [];
      let last_ptr = 0;
      while (node !== void 0) {
        const d = cmp(key, node.key);
        stack.push(node);
        if (d <= 0) {
          last_ptr = stack.length;
        }
        if (d <= 0) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(self, stack, direction);
    }
  };
};
var lessThanBackwards = dual(2, (self, key) => lessThan6(self, key, Direction.Backward));
var lessThanForwards = dual(2, (self, key) => lessThan6(self, key, Direction.Forward));
var lessThan6 = (self, key, direction) => {
  return {
    [Symbol.iterator]: () => {
      const cmp = self._ord;
      let node = self._root;
      const stack = [];
      let last_ptr = 0;
      while (node !== void 0) {
        const d = cmp(key, node.key);
        stack.push(node);
        if (d > 0) {
          last_ptr = stack.length;
        }
        if (d <= 0) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(self, stack, direction);
    }
  };
};
var lessThanEqualBackwards = dual(2, (self, key) => lessThanEqual2(self, key, Direction.Backward));
var lessThanEqualForwards = dual(2, (self, key) => lessThanEqual2(self, key, Direction.Forward));
var lessThanEqual2 = (self, key, direction) => {
  return {
    [Symbol.iterator]: () => {
      const cmp = self._ord;
      let node = self._root;
      const stack = [];
      let last_ptr = 0;
      while (node !== void 0) {
        const d = cmp(key, node.key);
        stack.push(node);
        if (d >= 0) {
          last_ptr = stack.length;
        }
        if (d < 0) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(self, stack, direction);
    }
  };
};
var forEach8 = dual(2, (self, f) => {
  const root = self._root;
  if (root !== void 0) {
    visitFull(root, (key, value8) => {
      f(key, value8);
      return none2();
    });
  }
});
var forEachGreaterThanEqual = dual(3, (self, min7, f) => {
  const root = self._root;
  const ord = self._ord;
  if (root !== void 0) {
    visitGreaterThanEqual(root, min7, ord, (key, value8) => {
      f(key, value8);
      return none2();
    });
  }
});
var forEachLessThan = dual(3, (self, max9, f) => {
  const root = self._root;
  const ord = self._ord;
  if (root !== void 0) {
    visitLessThan(root, max9, ord, (key, value8) => {
      f(key, value8);
      return none2();
    });
  }
});
var forEachBetween = dual(2, (self, {
  body,
  max: max9,
  min: min7
}) => {
  const root = self._root;
  const ord = self._ord;
  if (root) {
    visitBetween(root, min7, max9, ord, (key, value8) => {
      body(key, value8);
      return none2();
    });
  }
});
var reduce11 = dual(3, (self, zero3, f) => {
  let accumulator = zero3;
  for (const entry of self) {
    accumulator = f(accumulator, entry[1], entry[0]);
  }
  return accumulator;
});
var removeFirst = dual(2, (self, key) => {
  if (!has6(self, key)) {
    return self;
  }
  const ord = self._ord;
  const cmp = ord;
  let node = self._root;
  const stack = [];
  while (node !== void 0) {
    const d = cmp(key, node.key);
    stack.push(node);
    if (equals(key, node.key)) {
      node = void 0;
    } else if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  if (stack.length === 0) {
    return self;
  }
  const cstack = new Array(stack.length);
  let n = stack[stack.length - 1];
  cstack[cstack.length - 1] = {
    color: n.color,
    key: n.key,
    value: n.value,
    left: n.left,
    right: n.right,
    count: n.count
  };
  for (let i = stack.length - 2; i >= 0; --i) {
    n = stack[i];
    if (n.left === stack[i + 1]) {
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: cstack[i + 1],
        right: n.right,
        count: n.count
      };
    } else {
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: cstack[i + 1],
        count: n.count
      };
    }
  }
  n = cstack[cstack.length - 1];
  if (n.left !== void 0 && n.right !== void 0) {
    const split4 = cstack.length;
    n = n.left;
    while (n.right != null) {
      cstack.push(n);
      n = n.right;
    }
    const v = cstack[split4 - 1];
    cstack.push({
      color: n.color,
      key: v.key,
      value: v.value,
      left: n.left,
      right: n.right,
      count: n.count
    });
    cstack[split4 - 1].key = n.key;
    cstack[split4 - 1].value = n.value;
    for (let i = cstack.length - 2; i >= split4; --i) {
      n = cstack[i];
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: cstack[i + 1],
        count: n.count
      };
    }
    cstack[split4 - 1].left = cstack[split4];
  }
  n = cstack[cstack.length - 1];
  if (n.color === Color.Red) {
    const p = cstack[cstack.length - 2];
    if (p.left === n) {
      p.left = void 0;
    } else if (p.right === n) {
      p.right = void 0;
    }
    cstack.pop();
    for (let i = 0; i < cstack.length; ++i) {
      cstack[i].count--;
    }
    return makeImpl3(ord, cstack[0]);
  } else {
    if (n.left !== void 0 || n.right !== void 0) {
      if (n.left !== void 0) {
        swap2(n, n.left);
      } else if (n.right !== void 0) {
        swap2(n, n.right);
      }
      n.color = Color.Black;
      for (let i = 0; i < cstack.length - 1; ++i) {
        cstack[i].count--;
      }
      return makeImpl3(ord, cstack[0]);
    } else if (cstack.length === 1) {
      return makeImpl3(ord, void 0);
    } else {
      for (let i = 0; i < cstack.length; ++i) {
        cstack[i].count--;
      }
      const parent = cstack[cstack.length - 2];
      fixDoubleBlack(cstack);
      if (parent.left === n) {
        parent.left = void 0;
      } else {
        parent.right = void 0;
      }
    }
  }
  return makeImpl3(ord, cstack[0]);
});
var size9 = (self) => {
  var _a91;
  return ((_a91 = self._root) == null ? void 0 : _a91.count) ?? 0;
};
var valuesForward = (self) => values5(self, Direction.Forward);
var valuesBackward = (self) => values5(self, Direction.Backward);
var values5 = (self, direction) => {
  const begin = self[Symbol.iterator]();
  let count9 = 0;
  return {
    [Symbol.iterator]: () => values5(self, direction),
    next: () => {
      count9++;
      const entry = begin.value;
      if (direction === Direction.Forward) {
        begin.moveNext();
      } else {
        begin.movePrev();
      }
      switch (entry._tag) {
        case "None": {
          return {
            done: true,
            value: count9
          };
        }
        case "Some": {
          return {
            done: false,
            value: entry.value
          };
        }
      }
    }
  };
};
var visitFull = (node, visit) => {
  let current2 = node;
  let stack = void 0;
  let done17 = false;
  while (!done17) {
    if (current2 != null) {
      stack = make9(current2, stack);
      current2 = current2.left;
    } else if (stack != null) {
      const value8 = visit(stack.value.key, stack.value.value);
      if (isSome(value8)) {
        return value8;
      }
      current2 = stack.value.right;
      stack = stack.previous;
    } else {
      done17 = true;
    }
  }
  return none2();
};
var visitGreaterThanEqual = (node, min7, ord, visit) => {
  let current2 = node;
  let stack = void 0;
  let done17 = false;
  while (!done17) {
    if (current2 !== void 0) {
      stack = make9(current2, stack);
      if (ord(min7, current2.key) <= 0) {
        current2 = current2.left;
      } else {
        current2 = void 0;
      }
    } else if (stack !== void 0) {
      if (ord(min7, stack.value.key) <= 0) {
        const value8 = visit(stack.value.key, stack.value.value);
        if (isSome(value8)) {
          return value8;
        }
      }
      current2 = stack.value.right;
      stack = stack.previous;
    } else {
      done17 = true;
    }
  }
  return none2();
};
var visitLessThan = (node, max9, ord, visit) => {
  let current2 = node;
  let stack = void 0;
  let done17 = false;
  while (!done17) {
    if (current2 !== void 0) {
      stack = make9(current2, stack);
      current2 = current2.left;
    } else if (stack !== void 0 && ord(max9, stack.value.key) > 0) {
      const value8 = visit(stack.value.key, stack.value.value);
      if (isSome(value8)) {
        return value8;
      }
      current2 = stack.value.right;
      stack = stack.previous;
    } else {
      done17 = true;
    }
  }
  return none2();
};
var visitBetween = (node, min7, max9, ord, visit) => {
  let current2 = node;
  let stack = void 0;
  let done17 = false;
  while (!done17) {
    if (current2 !== void 0) {
      stack = make9(current2, stack);
      if (ord(min7, current2.key) <= 0) {
        current2 = current2.left;
      } else {
        current2 = void 0;
      }
    } else if (stack !== void 0 && ord(max9, stack.value.key) > 0) {
      if (ord(min7, stack.value.key) <= 0) {
        const value8 = visit(stack.value.key, stack.value.value);
        if (isSome(value8)) {
          return value8;
        }
      }
      current2 = stack.value.right;
      stack = stack.previous;
    } else {
      done17 = true;
    }
  }
  return none2();
};
var fixDoubleBlack = (stack) => {
  let n, p, s, z;
  for (let i = stack.length - 1; i >= 0; --i) {
    n = stack[i];
    if (i === 0) {
      n.color = Color.Black;
      return;
    }
    p = stack[i - 1];
    if (p.left === n) {
      s = p.right;
      if (s !== void 0 && s.right !== void 0 && s.right.color === Color.Red) {
        s = p.right = clone(s);
        z = s.right = clone(s.right);
        p.right = s.left;
        s.left = p;
        s.right = z;
        s.color = p.color;
        n.color = Color.Black;
        p.color = Color.Black;
        z.color = Color.Black;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s !== void 0 && s.left !== void 0 && s.left.color === Color.Red) {
        s = p.right = clone(s);
        z = s.left = clone(s.left);
        p.right = z.left;
        s.left = z.right;
        z.left = p;
        z.right = s;
        z.color = p.color;
        p.color = Color.Black;
        s.color = Color.Black;
        n.color = Color.Black;
        recount(p);
        recount(s);
        recount(z);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = z;
          } else {
            pp.right = z;
          }
        }
        stack[i - 1] = z;
        return;
      }
      if (s !== void 0 && s.color === Color.Black) {
        if (p.color === Color.Red) {
          p.color = Color.Black;
          p.right = repaint(s, Color.Red);
          return;
        } else {
          p.right = repaint(s, Color.Red);
          continue;
        }
      } else if (s !== void 0) {
        s = clone(s);
        p.right = s.left;
        s.left = p;
        s.color = p.color;
        p.color = Color.Red;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    } else {
      s = p.left;
      if (s !== void 0 && s.left !== void 0 && s.left.color === Color.Red) {
        s = p.left = clone(s);
        z = s.left = clone(s.left);
        p.left = s.right;
        s.right = p;
        s.left = z;
        s.color = p.color;
        n.color = Color.Black;
        p.color = Color.Black;
        z.color = Color.Black;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s !== void 0 && s.right !== void 0 && s.right.color === Color.Red) {
        s = p.left = clone(s);
        z = s.right = clone(s.right);
        p.left = z.right;
        s.right = z.left;
        z.right = p;
        z.left = s;
        z.color = p.color;
        p.color = Color.Black;
        s.color = Color.Black;
        n.color = Color.Black;
        recount(p);
        recount(s);
        recount(z);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = z;
          } else {
            pp.left = z;
          }
        }
        stack[i - 1] = z;
        return;
      }
      if (s !== void 0 && s.color === Color.Black) {
        if (p.color === Color.Red) {
          p.color = Color.Black;
          p.left = repaint(s, Color.Red);
          return;
        } else {
          p.left = repaint(s, Color.Red);
          continue;
        }
      } else if (s !== void 0) {
        s = clone(s);
        p.left = s.right;
        s.right = p;
        s.color = p.color;
        p.color = Color.Red;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    }
  }
};

// ../node_modules/effect/dist/esm/RedBlackTree.js
var Direction2 = Direction;
var isRedBlackTree2 = isRedBlackTree;
var empty29 = empty28;
var fromIterable12 = fromIterable11;
var make45 = make44;
var at2 = atForwards;
var atReversed = atBackwards;
var findAll2 = findAll;
var findFirst8 = findFirst7;
var first2 = first;
var getAt2 = getAt;
var getOrder2 = getOrder;
var greaterThan7 = greaterThanForwards;
var greaterThanReversed = greaterThanBackwards;
var greaterThanEqual3 = greaterThanEqualForwards;
var greaterThanEqualReversed = greaterThanEqualBackwards;
var has7 = has6;
var insert2 = insert;
var keys4 = keysForward;
var keysReversed = keysBackward;
var last5 = last4;
var lessThan7 = lessThanForwards;
var lessThanReversed = lessThanBackwards;
var lessThanEqual3 = lessThanEqualForwards;
var lessThanEqualReversed = lessThanEqualBackwards;
var forEach9 = forEach8;
var forEachGreaterThanEqual2 = forEachGreaterThanEqual;
var forEachLessThan2 = forEachLessThan;
var forEachBetween2 = forEachBetween;
var reduce12 = reduce11;
var removeFirst2 = removeFirst;
var reversed2 = reversed;
var size10 = size9;
var values6 = valuesForward;
var valuesReversed = valuesBackward;

// ../node_modules/effect/dist/esm/SortedSet.js
var TypeId12 = Symbol.for("effect/SortedSet");
var SortedSetProto = {
  [TypeId12]: {
    _A: (_) => _
  },
  [symbol2]() {
    return pipe(hash(this.keyTree), combine(hash(TypeId12)), cached(this));
  },
  [symbol3](that) {
    return isSortedSet(that) && equals(this.keyTree, that.keyTree);
  },
  [Symbol.iterator]() {
    return keys4(this.keyTree);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var fromTree = (keyTree) => {
  const a = Object.create(SortedSetProto);
  a.keyTree = keyTree;
  return a;
};
var isSortedSet = (u) => hasProperty(u, TypeId12);
var empty30 = (O) => fromTree(empty29(O));
var fromIterable13 = dual(2, (iterable, ord) => fromTree(fromIterable12(Array.from(iterable).map((k) => [k, true]), ord)));
var make46 = (ord) => (...entries6) => fromIterable13(entries6, ord);
var add5 = dual(2, (self, value8) => has7(self.keyTree, value8) ? self : fromTree(insert2(self.keyTree, value8, true)));
var difference3 = dual(2, (self, that) => {
  let out = self;
  for (const value8 of that) {
    out = remove9(out, value8);
  }
  return out;
});
var every8 = dual(2, (self, predicate) => {
  for (const value8 of self) {
    if (!predicate(value8)) {
      return false;
    }
  }
  return true;
});
var filter9 = dual(2, (self, predicate) => {
  const ord = getOrder2(self.keyTree);
  let out = empty30(ord);
  for (const value8 of self) {
    if (predicate(value8)) {
      out = add5(out, value8);
    }
  }
  return out;
});
var flatMap12 = dual(3, (self, O, f) => {
  let out = empty30(O);
  forEach10(self, (a) => {
    for (const b of f(a)) {
      out = add5(out, b);
    }
  });
  return out;
});
var forEach10 = dual(2, (self, f) => forEach9(self.keyTree, f));
var has8 = dual(2, (self, value8) => has7(self.keyTree, value8));
var intersection5 = dual(2, (self, that) => {
  const ord = getOrder2(self.keyTree);
  let out = empty30(ord);
  for (const value8 of that) {
    if (has8(self, value8)) {
      out = add5(out, value8);
    }
  }
  return out;
});
var isSubset3 = dual(2, (self, that) => every8(self, (a) => has8(that, a)));
var map17 = dual(3, (self, O, f) => {
  let out = empty30(O);
  forEach10(self, (a) => {
    const b = f(a);
    if (!has8(out, b)) {
      out = add5(out, b);
    }
  });
  return out;
});
var partition6 = dual(2, (self, predicate) => {
  const ord = getOrder2(self.keyTree);
  let right2 = empty30(ord);
  let left2 = empty30(ord);
  for (const value8 of self) {
    if (predicate(value8)) {
      right2 = add5(right2, value8);
    } else {
      left2 = add5(left2, value8);
    }
  }
  return [left2, right2];
});
var remove9 = dual(2, (self, value8) => fromTree(removeFirst2(self.keyTree, value8)));
var size11 = (self) => size10(self.keyTree);
var some8 = dual(2, (self, predicate) => {
  for (const value8 of self) {
    if (predicate(value8)) {
      return true;
    }
  }
  return false;
});
var toggle4 = dual(2, (self, value8) => has8(self, value8) ? remove9(self, value8) : add5(self, value8));
var union7 = dual(2, (self, that) => {
  const ord = getOrder2(self.keyTree);
  let out = empty30(ord);
  for (const value8 of self) {
    out = add5(value8)(out);
  }
  for (const value8 of that) {
    out = add5(value8)(out);
  }
  return out;
});
var values7 = (self) => keys4(self.keyTree);
var getEquivalence4 = () => (a, b) => isSubset3(a, b) && isSubset3(b, a);

// ../node_modules/effect/dist/esm/internal/supervisor.js
var SupervisorSymbolKey = "effect/Supervisor";
var SupervisorTypeId = Symbol.for(SupervisorSymbolKey);
var supervisorVariance = {
  /* c8 ignore next */
  _T: (_) => _
};
var _a34;
var _ProxySupervisor = class _ProxySupervisor {
  constructor(underlying, value0) {
    __publicField(this, "underlying");
    __publicField(this, "value0");
    __publicField(this, _a34, supervisorVariance);
    this.underlying = underlying;
    this.value0 = value0;
  }
  get value() {
    return this.value0;
  }
  onStart(context13, effect4, parent, fiber) {
    this.underlying.onStart(context13, effect4, parent, fiber);
  }
  onEnd(value8, fiber) {
    this.underlying.onEnd(value8, fiber);
  }
  onEffect(fiber, effect4) {
    this.underlying.onEffect(fiber, effect4);
  }
  onSuspend(fiber) {
    this.underlying.onSuspend(fiber);
  }
  onResume(fiber) {
    this.underlying.onResume(fiber);
  }
  map(f) {
    return new _ProxySupervisor(this, pipe(this.value, map11(f)));
  }
  zip(right2) {
    return new Zip(this, right2);
  }
};
_a34 = SupervisorTypeId;
var ProxySupervisor = _ProxySupervisor;
var _a35;
var _Zip = class _Zip {
  constructor(left2, right2) {
    __publicField(this, "left");
    __publicField(this, "right");
    __publicField(this, "_tag", "Zip");
    __publicField(this, _a35, supervisorVariance);
    this.left = left2;
    this.right = right2;
  }
  get value() {
    return zip4(this.left.value, this.right.value);
  }
  onStart(context13, effect4, parent, fiber) {
    this.left.onStart(context13, effect4, parent, fiber);
    this.right.onStart(context13, effect4, parent, fiber);
  }
  onEnd(value8, fiber) {
    this.left.onEnd(value8, fiber);
    this.right.onEnd(value8, fiber);
  }
  onEffect(fiber, effect4) {
    this.left.onEffect(fiber, effect4);
    this.right.onEffect(fiber, effect4);
  }
  onSuspend(fiber) {
    this.left.onSuspend(fiber);
    this.right.onSuspend(fiber);
  }
  onResume(fiber) {
    this.left.onResume(fiber);
    this.right.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map11(f)));
  }
  zip(right2) {
    return new _Zip(this, right2);
  }
};
_a35 = SupervisorTypeId;
var Zip = _Zip;
var isZip = (self) => hasProperty(self, SupervisorTypeId) && isTagged(self, "Zip");
var _a36;
var Track = class {
  constructor() {
    __publicField(this, _a36, supervisorVariance);
    __publicField(this, "fibers", /* @__PURE__ */ new Set());
  }
  get value() {
    return sync(() => Array.from(this.fibers));
  }
  onStart(_context, _effect, _parent, fiber) {
    this.fibers.add(fiber);
  }
  onEnd(_value, fiber) {
    this.fibers.delete(fiber);
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map11(f)));
  }
  zip(right2) {
    return new Zip(this, right2);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
_a36 = SupervisorTypeId;
var _a37;
var Const = class {
  constructor(effect4) {
    __publicField(this, "effect");
    __publicField(this, _a37, supervisorVariance);
    this.effect = effect4;
  }
  get value() {
    return this.effect;
  }
  onStart(_context, _effect, _parent, _fiber) {
  }
  onEnd(_value, _fiber) {
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map11(f)));
  }
  zip(right2) {
    return new Zip(this, right2);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
_a37 = SupervisorTypeId;
var _a38;
var FibersIn = class {
  constructor(ref) {
    __publicField(this, "ref");
    __publicField(this, _a38, supervisorVariance);
    this.ref = ref;
  }
  get value() {
    return sync(() => get5(this.ref));
  }
  onStart(_context, _effect, _parent, fiber) {
    pipe(this.ref, set2(pipe(get5(this.ref), add5(fiber))));
  }
  onEnd(_value, fiber) {
    pipe(this.ref, set2(pipe(get5(this.ref), remove9(fiber))));
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map11(f)));
  }
  zip(right2) {
    return new Zip(this, right2);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
_a38 = SupervisorTypeId;
var unsafeTrack = () => {
  return new Track();
};
var track = sync(unsafeTrack);
var fromEffect2 = (effect4) => {
  return new Const(effect4);
};
var none8 = globalValue("effect/Supervisor/none", () => fromEffect2(void_));
var fibersIn = (ref) => sync(() => new FibersIn(ref));

// ../node_modules/effect/dist/esm/Differ.js
var Differ_exports = {};
__export(Differ_exports, {
  TypeId: () => TypeId13,
  chunk: () => chunk2,
  combine: () => combine12,
  diff: () => diff10,
  empty: () => empty31,
  environment: () => environment2,
  hashMap: () => hashMap2,
  hashSet: () => hashSet2,
  make: () => make47,
  orElseEither: () => orElseEither3,
  patch: () => patch11,
  readonlyArray: () => readonlyArray2,
  transform: () => transform2,
  update: () => update6,
  updateWith: () => updateWith2,
  zip: () => zip8
});
var TypeId13 = DifferTypeId;
var empty31 = (self) => self.empty;
var diff10 = dual(3, (self, oldValue, newValue) => self.diff(oldValue, newValue));
var combine12 = dual(3, (self, first5, second) => self.combine(first5, second));
var patch11 = dual(3, (self, patch14, oldValue) => self.patch(patch14, oldValue));
var make47 = make18;
var environment2 = environment;
var chunk2 = chunk;
var hashMap2 = hashMap;
var hashSet2 = hashSet;
var orElseEither3 = orElseEither;
var readonlyArray2 = readonlyArray;
var transform2 = transform;
var update6 = update2;
var updateWith2 = updateWith;
var zip8 = zip3;

// ../node_modules/effect/dist/esm/internal/supervisor/patch.js
var OP_EMPTY3 = "Empty";
var OP_ADD_SUPERVISOR = "AddSupervisor";
var OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
var OP_AND_THEN2 = "AndThen";
var empty32 = {
  _tag: OP_EMPTY3
};
var combine13 = (self, that) => {
  return {
    _tag: OP_AND_THEN2,
    first: self,
    second: that
  };
};
var patch12 = (self, supervisor) => {
  return patchLoop(supervisor, of2(self));
};
var patchLoop = (_supervisor, _patches) => {
  let supervisor = _supervisor;
  let patches = _patches;
  while (isNonEmpty2(patches)) {
    const head11 = headNonEmpty2(patches);
    switch (head11._tag) {
      case OP_EMPTY3: {
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_ADD_SUPERVISOR: {
        supervisor = supervisor.zip(head11.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_REMOVE_SUPERVISOR: {
        supervisor = removeSupervisor(supervisor, head11.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_AND_THEN2: {
        patches = prepend2(head11.first)(prepend2(head11.second)(tailNonEmpty2(patches)));
        break;
      }
    }
  }
  return supervisor;
};
var removeSupervisor = (self, that) => {
  if (equals(self, that)) {
    return none8;
  } else {
    if (isZip(self)) {
      return removeSupervisor(self.left, that).zip(removeSupervisor(self.right, that));
    } else {
      return self;
    }
  }
};
var toSet4 = (self) => {
  if (equals(self, none8)) {
    return empty8();
  } else {
    if (isZip(self)) {
      return pipe(toSet4(self.left), union5(toSet4(self.right)));
    } else {
      return make12(self);
    }
  }
};
var diff11 = (oldValue, newValue) => {
  if (equals(oldValue, newValue)) {
    return empty32;
  }
  const oldSupervisors = toSet4(oldValue);
  const newSupervisors = toSet4(newValue);
  const added = pipe(newSupervisors, difference2(oldSupervisors), reduce5(empty32, (patch14, supervisor) => combine13(patch14, {
    _tag: OP_ADD_SUPERVISOR,
    supervisor
  })));
  const removed = pipe(oldSupervisors, difference2(newSupervisors), reduce5(empty32, (patch14, supervisor) => combine13(patch14, {
    _tag: OP_REMOVE_SUPERVISOR,
    supervisor
  })));
  return combine13(added, removed);
};
var differ2 = make47({
  empty: empty32,
  patch: patch12,
  combine: combine13,
  diff: diff11
});

// ../node_modules/effect/dist/esm/internal/fiberRuntime.js
var fiberStarted = counter5("effect_fiber_started", {
  incremental: true
});
var fiberActive = counter5("effect_fiber_active");
var fiberSuccesses = counter5("effect_fiber_successes", {
  incremental: true
});
var fiberFailures = counter5("effect_fiber_failures", {
  incremental: true
});
var fiberLifetimes = tagged2(histogram5("effect_fiber_lifetimes", exponential({
  start: 0.5,
  factor: 2,
  count: 35
})), "time_unit", "milliseconds");
var EvaluationSignalContinue = "Continue";
var EvaluationSignalDone = "Done";
var EvaluationSignalYieldNow = "Yield";
var runtimeFiberVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var absurd2 = (_) => {
  throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
};
var YieldedOp = Symbol.for("effect/internal/fiberRuntime/YieldedOp");
var yieldedOpChannel = globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
  currentOp: null
}));
var contOpSuccess = {
  [OP_ON_SUCCESS]: (_, cont, value8) => {
    return cont.effect_instruction_i1(value8);
  },
  ["OnStep"]: (_, _cont, value8) => {
    return exitSucceed(exitSucceed(value8));
  },
  [OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value8) => {
    return cont.effect_instruction_i2(value8);
  },
  [OP_REVERT_FLAGS]: (self, cont, value8) => {
    self.patchRuntimeFlags(self._runtimeFlags, cont.patch);
    if (interruptible(self._runtimeFlags) && self.isInterrupted()) {
      return exitFailCause(self.getInterruptedCause());
    } else {
      return exitSucceed(value8);
    }
  },
  [OP_WHILE]: (self, cont, value8) => {
    cont.effect_instruction_i2(value8);
    if (cont.effect_instruction_i0()) {
      self.pushStack(cont);
      return cont.effect_instruction_i1();
    } else {
      return void_;
    }
  }
};
var drainQueueWhileRunningTable = {
  [OP_INTERRUPT_SIGNAL]: (self, runtimeFlags2, cur, message) => {
    self.processNewInterruptSignal(message.cause);
    return interruptible(runtimeFlags2) ? exitFailCause(message.cause) : cur;
  },
  [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
    throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
  },
  [OP_STATEFUL]: (self, runtimeFlags2, cur, message) => {
    message.onFiber(self, running2(runtimeFlags2));
    return cur;
  },
  [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
    return flatMap10(yieldNow(), () => cur);
  }
};
var runBlockedRequests = (self) => forEachSequentialDiscard(flatten3(self), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential6]) => {
  const map43 = /* @__PURE__ */ new Map();
  const arr = [];
  for (const block of sequential6) {
    arr.push(toReadonlyArray(block));
    for (const entry of block) {
      map43.set(entry.request, entry);
    }
  }
  const flat = arr.flat();
  return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
    entry.listeners.interrupted = true;
  })), currentRequestMap, map43);
}, false, false));
var _a39, _b12;
var FiberRuntime = class {
  constructor(fiberId5, fiberRefs0, runtimeFlags0) {
    __publicField(this, _a39, fiberVariance);
    __publicField(this, _b12, runtimeFiberVariance);
    __publicField(this, "_fiberRefs");
    __publicField(this, "_fiberId");
    __publicField(this, "_runtimeFlags");
    __publicField(this, "_queue", new Array());
    __publicField(this, "_children", null);
    __publicField(this, "_observers", new Array());
    __publicField(this, "_running", false);
    __publicField(this, "_stack", []);
    __publicField(this, "_asyncInterruptor", null);
    __publicField(this, "_asyncBlockingOn", null);
    __publicField(this, "_exitValue", null);
    __publicField(this, "_steps", []);
    __publicField(this, "_supervisor");
    __publicField(this, "_scheduler");
    __publicField(this, "_tracer");
    __publicField(this, "currentOpCount", 0);
    __publicField(this, "isYielding", false);
    __publicField(this, "run", () => {
      this.drainQueueOnCurrentThread();
    });
    this._runtimeFlags = runtimeFlags0;
    this._fiberId = fiberId5;
    this._fiberRefs = fiberRefs0;
    this._supervisor = this.getFiberRef(currentSupervisor);
    this._scheduler = this.getFiberRef(currentScheduler);
    if (runtimeMetrics(runtimeFlags0)) {
      const tags3 = this.getFiberRef(currentMetricLabels);
      fiberStarted.unsafeUpdate(1, tags3);
      fiberActive.unsafeUpdate(1, tags3);
    }
    this._tracer = get2(this.getFiberRef(currentServices), tracerTag);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  /**
   * The identity of the fiber.
   */
  id() {
    return this._fiberId;
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background. This can be called to "kick off" execution of a fiber after
   * it has been created.
   */
  resume(effect4) {
    this.tell(resume(effect4));
  }
  /**
   * The status of the fiber.
   */
  get status() {
    return this.ask((_, status3) => status3);
  }
  /**
   * Gets the fiber runtime flags.
   */
  get runtimeFlags() {
    return this.ask((state, status3) => {
      if (isDone3(status3)) {
        return state._runtimeFlags;
      }
      return status3.runtimeFlags;
    });
  }
  /**
   * Returns the current `FiberScope` for the fiber.
   */
  scope() {
    return unsafeMake9(this);
  }
  /**
   * Retrieves the immediate children of the fiber.
   */
  get children() {
    return this.ask((fiber) => Array.from(fiber.getChildren()));
  }
  /**
   * Gets the fiber's set of children.
   */
  getChildren() {
    if (this._children === null) {
      this._children = /* @__PURE__ */ new Set();
    }
    return this._children;
  }
  /**
   * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`
   * if the fiber has not been interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getInterruptedCause() {
    return this.getFiberRef(currentInterruptedCause);
  }
  /**
   * Retrieves the whole set of fiber refs.
   */
  fiberRefs() {
    return this.ask((fiber) => fiber.getFiberRefs());
  }
  /**
   * Returns an effect that will contain information computed from the fiber
   * state and status while running on the fiber.
   *
   * This allows the outside world to interact safely with mutable fiber state
   * without locks or immutable data.
   */
  ask(f) {
    return suspend(() => {
      const deferred = deferredUnsafeMake(this._fiberId);
      this.tell(stateful((fiber, status3) => {
        deferredUnsafeDone(deferred, sync(() => f(fiber, status3)));
      }));
      return deferredAwait(deferred);
    });
  }
  /**
   * Adds a message to be processed by the fiber on the fiber.
   */
  tell(message) {
    this._queue.push(message);
    if (!this._running) {
      this._running = true;
      this.drainQueueLaterOnExecutor();
    }
  }
  get await() {
    return async((resume2) => {
      const cb = (exit3) => resume2(succeed(exit3));
      this.tell(stateful((fiber, _) => {
        if (fiber._exitValue !== null) {
          cb(this._exitValue);
        } else {
          fiber.addObserver(cb);
        }
      }));
      return sync(() => this.tell(stateful((fiber, _) => {
        fiber.removeObserver(cb);
      })));
    }, this.id());
  }
  get inheritAll() {
    return withFiberRuntime((parentFiber, parentStatus) => {
      const parentFiberId = parentFiber.id();
      const parentFiberRefs = parentFiber.getFiberRefs();
      const parentRuntimeFlags = parentStatus.runtimeFlags;
      const childFiberRefs = this.getFiberRefs();
      const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
      parentFiber.setFiberRefs(updatedFiberRefs);
      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
      const patch14 = pipe(
        diff7(parentRuntimeFlags, updatedRuntimeFlags),
        // Do not inherit WindDown or Interruption!
        exclude2(Interruption),
        exclude2(WindDown)
      );
      return updateRuntimeFlags(patch14);
    });
  }
  /**
   * Tentatively observes the fiber, but returns immediately if it is not
   * already done.
   */
  get poll() {
    return sync(() => fromNullable(this._exitValue));
  }
  /**
   * Unsafely observes the fiber, but returns immediately if it is not
   * already done.
   */
  unsafePoll() {
    return this._exitValue;
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  interruptAsFork(fiberId5) {
    return sync(() => this.tell(interruptSignal(interrupt(fiberId5))));
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  unsafeInterruptAsFork(fiberId5) {
    this.tell(interruptSignal(interrupt(fiberId5)));
  }
  /**
   * Adds an observer to the list of observers.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addObserver(observer) {
    if (this._exitValue !== null) {
      observer(this._exitValue);
    } else {
      this._observers.push(observer);
    }
  }
  /**
   * Removes the specified observer from the list of observers that will be
   * notified when the fiber exits.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeObserver(observer) {
    this._observers = this._observers.filter((o) => o !== observer);
  }
  /**
   * Retrieves all fiber refs of the fiber.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRefs() {
    this.setFiberRef(currentRuntimeFlags, this._runtimeFlags);
    return this._fiberRefs;
  }
  /**
   * Deletes the specified fiber ref.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  unsafeDeleteFiberRef(fiberRef) {
    this._fiberRefs = delete_(this._fiberRefs, fiberRef);
  }
  /**
   * Retrieves the state of the fiber ref, or else its initial value.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRef(fiberRef) {
    if (this._fiberRefs.locals.has(fiberRef)) {
      return this._fiberRefs.locals.get(fiberRef)[0][1];
    }
    return fiberRef.initial;
  }
  /**
   * Sets the fiber ref to the specified value.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRef(fiberRef, value8) {
    this._fiberRefs = updateAs(this._fiberRefs, {
      fiberId: this._fiberId,
      fiberRef,
      value: value8
    });
    this.refreshRefCache();
  }
  refreshRefCache() {
    this._tracer = get2(this.getFiberRef(currentServices), tracerTag);
    this._supervisor = this.getFiberRef(currentSupervisor);
    this._scheduler = this.getFiberRef(currentScheduler);
  }
  /**
   * Wholesale replaces all fiber refs of this fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRefs(fiberRefs4) {
    this._fiberRefs = fiberRefs4;
    this.refreshRefCache();
  }
  /**
   * Adds a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addChild(child) {
    this.getChildren().add(child);
  }
  /**
   * Removes a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeChild(child) {
    this.getChildren().delete(child);
  }
  /**
   * On the current thread, executes all messages in the fiber's inbox. This
   * method may return before all work is done, in the event the fiber executes
   * an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueOnCurrentThread() {
    let recurse = true;
    while (recurse) {
      let evaluationSignal = EvaluationSignalContinue;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        while (evaluationSignal === EvaluationSignalContinue) {
          evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
        }
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
      }
      if (this._queue.length > 0 && !this._running) {
        this._running = true;
        if (evaluationSignal === EvaluationSignalYieldNow) {
          this.drainQueueLaterOnExecutor();
          recurse = false;
        } else {
          recurse = true;
        }
      } else {
        recurse = false;
      }
    }
  }
  /**
   * Schedules the execution of all messages in the fiber's inbox.
   *
   * This method will return immediately after the scheduling
   * operation is completed, but potentially before such messages have been
   * executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueLaterOnExecutor() {
    this._scheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
  }
  /**
   * Drains the fiber's message queue while the fiber is actively running,
   * returning the next effect to execute, which may be the input effect if no
   * additional effect needs to be executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueWhileRunning(runtimeFlags2, cur0) {
    let cur = cur0;
    while (this._queue.length > 0) {
      const message = this._queue.splice(0, 1)[0];
      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags2, cur, message);
    }
    return cur;
  }
  /**
   * Determines if the fiber is interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  isInterrupted() {
    return !isEmpty6(this.getFiberRef(currentInterruptedCause));
  }
  /**
   * Adds an interruptor to the set of interruptors that are interrupting this
   * fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addInterruptedCause(cause3) {
    const oldSC = this.getFiberRef(currentInterruptedCause);
    this.setFiberRef(currentInterruptedCause, sequential(oldSC, cause3));
  }
  /**
   * Processes a new incoming interrupt signal.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  processNewInterruptSignal(cause3) {
    this.addInterruptedCause(cause3);
    this.sendInterruptSignalToAllChildren();
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  sendInterruptSignalToAllChildren() {
    if (this._children === null || this._children.size === 0) {
      return false;
    }
    let told = false;
    for (const child of this._children) {
      child.tell(interruptSignal(interrupt(this.id())));
      told = true;
    }
    return told;
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  interruptAllChildren() {
    if (this.sendInterruptSignalToAllChildren()) {
      const it = this._children.values();
      this._children = null;
      let isDone9 = false;
      const body = () => {
        const next6 = it.next();
        if (!next6.done) {
          return asVoid(next6.value.await);
        } else {
          return sync(() => {
            isDone9 = true;
          });
        }
      };
      return whileLoop({
        while: () => !isDone9,
        body,
        step: () => {
        }
      });
    }
    return null;
  }
  reportExitValue(exit3) {
    if (runtimeMetrics(this._runtimeFlags)) {
      const tags3 = this.getFiberRef(currentMetricLabels);
      const startTimeMillis = this.id().startTimeMillis;
      const endTimeMillis = Date.now();
      fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags3);
      fiberActive.unsafeUpdate(-1, tags3);
      switch (exit3._tag) {
        case OP_SUCCESS: {
          fiberSuccesses.unsafeUpdate(1, tags3);
          break;
        }
        case OP_FAILURE: {
          fiberFailures.unsafeUpdate(1, tags3);
          break;
        }
      }
    }
    if (exit3._tag === "Failure") {
      const level = this.getFiberRef(currentUnhandledErrorLogLevel);
      if (!isInterruptedOnly(exit3.cause) && level._tag === "Some") {
        this.log("Fiber terminated with an unhandled error", exit3.cause, level);
      }
    }
  }
  setExitValue(exit3) {
    this._exitValue = exit3;
    this.reportExitValue(exit3);
    for (let i = this._observers.length - 1; i >= 0; i--) {
      this._observers[i](exit3);
    }
  }
  getLoggers() {
    return this.getFiberRef(currentLoggers);
  }
  log(message, cause3, overrideLogLevel) {
    const logLevel3 = isSome(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
    const minimumLogLevel3 = this.getFiberRef(currentMinimumLogLevel);
    if (greaterThan5(minimumLogLevel3, logLevel3)) {
      return;
    }
    const spans = this.getFiberRef(currentLogSpan);
    const annotations2 = this.getFiberRef(currentLogAnnotations);
    const loggers = this.getLoggers();
    const contextMap = this.getFiberRefs();
    if (size4(loggers) > 0) {
      const clockService = get2(this.getFiberRef(currentServices), clockTag);
      const date4 = new Date(clockService.unsafeCurrentTimeMillis());
      for (const logger of loggers) {
        logger.log({
          fiberId: this.id(),
          logLevel: logLevel3,
          message,
          cause: cause3,
          context: contextMap,
          spans,
          annotations: annotations2,
          date: date4
        });
      }
    }
  }
  /**
   * Evaluates a single message on the current thread, while the fiber is
   * suspended. This method should only be called while evaluation of the
   * fiber's effect is suspended due to an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateMessageWhileSuspended(message) {
    switch (message._tag) {
      case OP_YIELD_NOW: {
        return EvaluationSignalYieldNow;
      }
      case OP_INTERRUPT_SIGNAL: {
        this.processNewInterruptSignal(message.cause);
        if (this._asyncInterruptor !== null) {
          this._asyncInterruptor(exitFailCause(message.cause));
          this._asyncInterruptor = null;
        }
        return EvaluationSignalContinue;
      }
      case OP_RESUME: {
        this._asyncInterruptor = null;
        this._asyncBlockingOn = null;
        this.evaluateEffect(message.effect);
        return EvaluationSignalContinue;
      }
      case OP_STATEFUL: {
        message.onFiber(this, this._exitValue !== null ? done4 : suspended2(this._runtimeFlags, this._asyncBlockingOn));
        return EvaluationSignalContinue;
      }
      default: {
        return absurd2(message);
      }
    }
  }
  /**
   * Evaluates an effect until completion, potentially asynchronously.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateEffect(effect0) {
    this._supervisor.onResume(this);
    try {
      let effect4 = interruptible(this._runtimeFlags) && this.isInterrupted() ? exitFailCause(this.getInterruptedCause()) : effect0;
      while (effect4 !== null) {
        const eff = effect4;
        const exit3 = this.runLoop(eff);
        if (exit3 === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          yieldedOpChannel.currentOp = null;
          if (op._op === OP_YIELD) {
            if (cooperativeYielding(this._runtimeFlags)) {
              this.tell(yieldNow2());
              this.tell(resume(exitVoid));
              effect4 = null;
            } else {
              effect4 = exitVoid;
            }
          } else if (op._op === OP_ASYNC) {
            effect4 = null;
          }
        } else {
          this._runtimeFlags = pipe(this._runtimeFlags, enable2(WindDown));
          const interruption3 = this.interruptAllChildren();
          if (interruption3 !== null) {
            effect4 = flatMap10(interruption3, () => exit3);
          } else {
            if (this._queue.length === 0) {
              this.setExitValue(exit3);
            } else {
              this.tell(resume(exit3));
            }
            effect4 = null;
          }
        }
      }
    } finally {
      this._supervisor.onSuspend(this);
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on the current
   * thread. This can be called to "kick off" execution of a fiber after it has
   * been created, in hopes that the effect can be executed synchronously.
   *
   * This is not the normal way of starting a fiber, but it is useful when the
   * express goal of executing the fiber is to synchronously produce its exit.
   */
  start(effect4) {
    if (!this._running) {
      this._running = true;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        this.evaluateEffect(effect4);
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
        if (this._queue.length > 0) {
          this.drainQueueLaterOnExecutor();
        }
      }
    } else {
      this.tell(resume(effect4));
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background, and on the correct thread pool. This can be called to "kick
   * off" execution of a fiber after it has been created, in hopes that the
   * effect can be executed synchronously.
   */
  startFork(effect4) {
    this.tell(resume(effect4));
  }
  /**
   * Takes the current runtime flags, patches them to return the new runtime
   * flags, and then makes any changes necessary to fiber state based on the
   * specified patch.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  patchRuntimeFlags(oldRuntimeFlags, patch14) {
    const newRuntimeFlags = patch7(oldRuntimeFlags, patch14);
    globalThis[currentFiberURI] = this;
    this._runtimeFlags = newRuntimeFlags;
    return newRuntimeFlags;
  }
  /**
   * Initiates an asynchronous operation, by building a callback that will
   * resume execution, and then feeding that callback to the registration
   * function, handling error cases and repeated resumptions appropriately.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  initiateAsync(runtimeFlags2, asyncRegister) {
    let alreadyCalled = false;
    const callback = (effect4) => {
      if (!alreadyCalled) {
        alreadyCalled = true;
        this.tell(resume(effect4));
      }
    };
    if (interruptible(runtimeFlags2)) {
      this._asyncInterruptor = callback;
    }
    try {
      asyncRegister(callback);
    } catch (e) {
      callback(failCause(die(e)));
    }
  }
  pushStack(cont) {
    this._stack.push(cont);
    if (cont._op === "OnStep") {
      this._steps.push({
        refs: this.getFiberRefs(),
        flags: this._runtimeFlags
      });
    }
  }
  popStack() {
    const item = this._stack.pop();
    if (item) {
      if (item._op === "OnStep") {
        this._steps.pop();
      }
      return item;
    }
    return;
  }
  getNextSuccessCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_FAILURE) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  getNextFailCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  [(_a39 = FiberTypeId, _b12 = RuntimeFiberTypeId, OP_TAG)](op) {
    return map11(fiberRefGet(currentContext), (context13) => unsafeGet3(context13, op));
  }
  ["Left"](op) {
    return fail2(op.left);
  }
  ["None"](_) {
    return fail2(new NoSuchElementException());
  }
  ["Right"](op) {
    return exitSucceed(op.right);
  }
  ["Some"](op) {
    return exitSucceed(op.value);
  }
  [OP_SYNC](op) {
    const value8 = op.effect_instruction_i0();
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess)) {
        absurd2(cont);
      }
      return contOpSuccess[cont._op](this, cont, value8);
    } else {
      yieldedOpChannel.currentOp = exitSucceed(value8);
      return YieldedOp;
    }
  }
  [OP_SUCCESS](op) {
    const oldCur = op;
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess)) {
        absurd2(cont);
      }
      return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
    } else {
      yieldedOpChannel.currentOp = oldCur;
      return YieldedOp;
    }
  }
  [OP_FAILURE](op) {
    const cause3 = op.effect_instruction_i0;
    const cont = this.getNextFailCont();
    if (cont !== void 0) {
      switch (cont._op) {
        case OP_ON_FAILURE:
        case OP_ON_SUCCESS_AND_FAILURE: {
          if (!(interruptible(this._runtimeFlags) && this.isInterrupted())) {
            return cont.effect_instruction_i1(cause3);
          } else {
            return exitFailCause(stripFailures(cause3));
          }
        }
        case "OnStep": {
          if (!(interruptible(this._runtimeFlags) && this.isInterrupted())) {
            return exitSucceed(exitFailCause(cause3));
          } else {
            return exitFailCause(stripFailures(cause3));
          }
        }
        case OP_REVERT_FLAGS: {
          this.patchRuntimeFlags(this._runtimeFlags, cont.patch);
          if (interruptible(this._runtimeFlags) && this.isInterrupted()) {
            return exitFailCause(sequential(cause3, this.getInterruptedCause()));
          } else {
            return exitFailCause(cause3);
          }
        }
        default: {
          absurd2(cont);
        }
      }
    } else {
      yieldedOpChannel.currentOp = exitFailCause(cause3);
      return YieldedOp;
    }
  }
  [OP_WITH_RUNTIME](op) {
    return op.effect_instruction_i0(this, running2(this._runtimeFlags));
  }
  ["Blocked"](op) {
    const refs = this.getFiberRefs();
    const flags = this._runtimeFlags;
    if (this._steps.length > 0) {
      const frames = [];
      const snap = this._steps[this._steps.length - 1];
      let frame = this.popStack();
      while (frame && frame._op !== "OnStep") {
        frames.push(frame);
        frame = this.popStack();
      }
      this.setFiberRefs(snap.refs);
      this._runtimeFlags = snap.flags;
      const patchRefs = diff9(snap.refs, refs);
      const patchFlags = diff7(snap.flags, flags);
      return exitSucceed(blocked(op.effect_instruction_i0, withFiberRuntime((newFiber) => {
        while (frames.length > 0) {
          newFiber.pushStack(frames.pop());
        }
        newFiber.setFiberRefs(patch10(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
        newFiber._runtimeFlags = patch7(patchFlags)(newFiber._runtimeFlags);
        return op.effect_instruction_i1;
      })));
    }
    return uninterruptibleMask((restore) => flatMap10(forkDaemon(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
  }
  ["RunBlocked"](op) {
    return runBlockedRequests(op.effect_instruction_i0);
  }
  [OP_UPDATE_RUNTIME_FLAGS](op) {
    const updateFlags = op.effect_instruction_i0;
    const oldRuntimeFlags = this._runtimeFlags;
    const newRuntimeFlags = patch7(oldRuntimeFlags, updateFlags);
    if (interruptible(newRuntimeFlags) && this.isInterrupted()) {
      return exitFailCause(this.getInterruptedCause());
    } else {
      this.patchRuntimeFlags(this._runtimeFlags, updateFlags);
      if (op.effect_instruction_i1) {
        const revertFlags = diff7(newRuntimeFlags, oldRuntimeFlags);
        this.pushStack(new RevertFlags(revertFlags, op));
        return op.effect_instruction_i1(oldRuntimeFlags);
      } else {
        return exitVoid;
      }
    }
  }
  [OP_ON_SUCCESS](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  ["OnStep"](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_SUCCESS_AND_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ASYNC](op) {
    this._asyncBlockingOn = op.effect_instruction_i1;
    this.initiateAsync(this._runtimeFlags, op.effect_instruction_i0);
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_YIELD](op) {
    this.isYielding = false;
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_WHILE](op) {
    const check5 = op.effect_instruction_i0;
    const body = op.effect_instruction_i1;
    if (check5()) {
      this.pushStack(op);
      return body();
    } else {
      return exitVoid;
    }
  }
  [OP_COMMIT](op) {
    return op.commit();
  }
  /**
   * The main run-loop for evaluating effects.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  runLoop(effect0) {
    let cur = effect0;
    this.currentOpCount = 0;
    while (true) {
      if ((this._runtimeFlags & OpSupervision) !== 0) {
        this._supervisor.onEffect(this, cur);
      }
      if (this._queue.length > 0) {
        cur = this.drainQueueWhileRunning(this._runtimeFlags, cur);
      }
      if (!this.isYielding) {
        this.currentOpCount += 1;
        const shouldYield = this._scheduler.shouldYield(this);
        if (shouldYield !== false) {
          this.isYielding = true;
          this.currentOpCount = 0;
          const oldCur = cur;
          cur = flatMap10(yieldNow({
            priority: shouldYield
          }), () => oldCur);
        }
      }
      try {
        if (!("_op" in cur) || !(cur._op in this)) {
          absurd2(cur);
        }
        cur = this._tracer.context(() => {
          if (getCurrentVersion() !== cur[EffectTypeId3]._V) {
            return dieMessage(`Cannot execute an Effect versioned ${cur[EffectTypeId3]._V} with a Runtime of version ${getCurrentVersion()}`);
          }
          return this[cur._op](cur);
        }, this);
        if (cur === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          if (op._op === OP_YIELD || op._op === OP_ASYNC) {
            return YieldedOp;
          }
          yieldedOpChannel.currentOp = null;
          return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause(die(op));
        }
      } catch (e) {
        if (isEffectError(e)) {
          cur = exitFailCause(e.cause);
        } else if (isInterruptedException(e)) {
          cur = exitFailCause(sequential(die(e), interrupt(none4)));
        } else {
          cur = exitFailCause(die(e));
        }
      }
    }
  }
};
var currentMinimumLogLevel = globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
var loggerWithConsoleLog = (self) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  get2(services, consoleTag).unsafe.log(self.log(opts));
});
var loggerWithConsoleError = (self) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  get2(services, consoleTag).unsafe.error(self.log(opts));
});
var defaultLogger = globalValue(Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
var jsonLogger2 = globalValue(Symbol.for("effect/Logger/jsonLogger"), () => loggerWithConsoleLog(jsonLogger));
var logFmtLogger = globalValue(Symbol.for("effect/Logger/logFmtLogger"), () => loggerWithConsoleLog(logfmtLogger));
var structuredLogger2 = globalValue(Symbol.for("effect/Logger/structuredLogger"), () => loggerWithConsoleLog(structuredLogger));
var tracerLogger = globalValue(Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
  annotations: annotations2,
  cause: cause3,
  context: context13,
  fiberId: fiberId5,
  logLevel: logLevel3,
  message
}) => {
  const span4 = flatMap(get8(context13, currentContext), getOption2(spanTag));
  const clockService = map2(get8(context13, currentServices), (_) => get2(_, clockTag));
  if (span4._tag === "None" || span4.value._tag === "ExternalSpan" || clockService._tag === "None") {
    return;
  }
  const attributes = Object.fromEntries(map8(annotations2, toStringUnknown));
  attributes["effect.fiberId"] = threadName2(fiberId5);
  attributes["effect.logLevel"] = logLevel3.label;
  if (cause3 !== null && cause3._tag !== "Empty") {
    attributes["effect.cause"] = pretty(cause3);
  }
  span4.value.event(String(message), clockService.value.unsafeCurrentTimeNanos(), attributes);
}));
var loggerWithSpanAnnotations = (self) => mapInputOptions(self, (options) => {
  const span4 = flatMap(get8(options.context, currentContext), getOption2(spanTag));
  if (span4._tag === "None") {
    return options;
  }
  return {
    ...options,
    annotations: pipe(options.annotations, set3("effect.traceId", span4.value.traceId), set3("effect.spanId", span4.value.spanId), span4.value._tag === "Span" ? set3("effect.spanName", span4.value.name) : identity)
  };
});
var currentLoggers = globalValue(Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make12(defaultLogger, tracerLogger)));
var batchedLogger = dual(3, (self, window, f) => flatMap10(scope, (scope5) => {
  let buffer5 = [];
  const flush = suspend(() => {
    if (buffer5.length === 0) {
      return void_;
    }
    const arr = buffer5;
    buffer5 = [];
    return f(arr);
  });
  return uninterruptibleMask((restore) => pipe(sleep3(window), zipRight(flush), forever, restore, forkDaemon, flatMap10((fiber) => scopeAddFinalizer(scope5, interruptFiber(fiber))), zipRight(addFinalizer(() => flush)), as2(makeLogger((options) => {
    buffer5.push(self.log(options));
  }))));
}));
var acquireRelease = dual((args) => isEffect(args[0]), (acquire3, release3) => uninterruptible(tap(acquire3, (a) => addFinalizer((exit3) => release3(a, exit3)))));
var acquireReleaseInterruptible = dual((args) => isEffect(args[0]), (acquire3, release3) => ensuring(acquire3, addFinalizer((exit3) => release3(exit3))));
var addFinalizer = (finalizer3) => withFiberRuntime((runtime8) => {
  const acquireRefs = runtime8.getFiberRefs();
  const acquireFlags = runtime8._runtimeFlags;
  return flatMap10(scope, (scope5) => scopeAddFinalizerExit(scope5, (exit3) => withFiberRuntime((runtimeFinalizer) => {
    const preRefs = runtimeFinalizer.getFiberRefs();
    const preFlags = runtimeFinalizer._runtimeFlags;
    const patchRefs = diff9(preRefs, acquireRefs);
    const patchFlags = diff7(preFlags, acquireFlags);
    const inverseRefs = diff9(acquireRefs, preRefs);
    runtimeFinalizer.setFiberRefs(patch10(patchRefs, runtimeFinalizer.id(), acquireRefs));
    return ensuring(withRuntimeFlags(finalizer3(exit3), patchFlags), sync(() => {
      runtimeFinalizer.setFiberRefs(patch10(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
    }));
  })));
});
var daemonChildren = (self) => {
  const forkScope = fiberRefLocally(currentForkScopeOverride, some2(globalScope));
  return forkScope(self);
};
var _existsParFound = Symbol.for("effect/Effect/existsPar/found");
var exists2 = dual((args) => isIterable(args[0]), (elements, f, options) => matchSimple(options == null ? void 0 : options.concurrency, () => suspend(() => existsLoop(elements[Symbol.iterator](), 0, f)), () => matchEffect(forEach11(elements, (a, i) => if_(f(a, i), {
  onTrue: () => fail2(_existsParFound),
  onFalse: () => void_
}), options), {
  onFailure: (e) => e === _existsParFound ? succeed(true) : fail2(e),
  onSuccess: () => succeed(false)
})));
var existsLoop = (iterator, index, f) => {
  const next6 = iterator.next();
  if (next6.done) {
    return succeed(false);
  }
  return pipe(flatMap10(f(next6.value, index), (b) => b ? succeed(b) : existsLoop(iterator, index + 1, f)));
};
var filter10 = dual((args) => isIterable(args[0]), (elements, f, options) => {
  const predicate = (options == null ? void 0 : options.negate) ? (a, i) => map11(f(a, i), not) : f;
  return matchSimple(options == null ? void 0 : options.concurrency, () => suspend(() => fromIterable(elements).reduceRight((effect4, a, i) => zipWith3(effect4, suspend(() => predicate(a, i)), (list, b) => b ? [a, ...list] : list), sync(() => new Array()))), () => map11(forEach11(elements, (a, i) => map11(predicate(a, i), (b) => b ? some2(a) : none2()), options), getSomes));
});
var allResolveInput = (input) => {
  if (Array.isArray(input) || isIterable(input)) {
    return [input, none2()];
  }
  const keys10 = Object.keys(input);
  const size38 = keys10.length;
  return [keys10.map((k) => input[k]), some2((values13) => {
    const res = {};
    for (let i = 0; i < size38; i++) {
      ;
      res[keys10[i]] = values13[i];
    }
    return res;
  })];
};
var allValidate = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect4 of effects) {
    eitherEffects.push(either3(effect4));
  }
  return flatMap10(forEach11(eitherEffects, identity, {
    concurrency: options == null ? void 0 : options.concurrency,
    batching: options == null ? void 0 : options.batching
  }), (eithers) => {
    const none15 = none2();
    const size38 = eithers.length;
    const errors2 = new Array(size38);
    const successes = new Array(size38);
    let errored = false;
    for (let i = 0; i < size38; i++) {
      const either13 = eithers[i];
      if (either13._tag === "Left") {
        errors2[i] = some2(either13.left);
        errored = true;
      } else {
        successes[i] = either13.right;
        errors2[i] = none15;
      }
    }
    if (errored) {
      return reconcile._tag === "Some" ? fail2(reconcile.value(errors2)) : fail2(errors2);
    } else if (options == null ? void 0 : options.discard) {
      return void_;
    }
    return reconcile._tag === "Some" ? succeed(reconcile.value(successes)) : succeed(successes);
  });
};
var allEither = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect4 of effects) {
    eitherEffects.push(either3(effect4));
  }
  if (options == null ? void 0 : options.discard) {
    return forEach11(eitherEffects, identity, {
      concurrency: options == null ? void 0 : options.concurrency,
      batching: options == null ? void 0 : options.batching,
      discard: true
    });
  }
  return map11(forEach11(eitherEffects, identity, {
    concurrency: options == null ? void 0 : options.concurrency,
    batching: options == null ? void 0 : options.batching
  }), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
};
var all5 = (arg, options) => {
  const [effects, reconcile] = allResolveInput(arg);
  if ((options == null ? void 0 : options.mode) === "validate") {
    return allValidate(effects, reconcile, options);
  } else if ((options == null ? void 0 : options.mode) === "either") {
    return allEither(effects, reconcile, options);
  }
  return reconcile._tag === "Some" ? map11(forEach11(effects, identity, options), reconcile.value) : forEach11(effects, identity, options);
};
var allWith = (options) => (arg) => all5(arg, options);
var allSuccesses = (elements, options) => map11(all5(fromIterable(elements).map(exit), options), filterMap((exit3) => exitIsSuccess(exit3) ? some2(exit3.effect_instruction_i0) : none2()));
var replicate = dual(2, (self, n) => Array.from({
  length: n
}, () => self));
var replicateEffect = dual((args) => isEffect(args[0]), (self, n, options) => all5(replicate(self, n), options));
var forEach11 = dual((args) => isIterable(args[0]), (self, f, options) => withFiberRuntime((r) => {
  const isRequestBatchingEnabled = (options == null ? void 0 : options.batching) === true || (options == null ? void 0 : options.batching) === "inherit" && r.getFiberRef(currentRequestBatching);
  if (options == null ? void 0 : options.discard) {
    return match11(options.concurrency, () => finalizersMask(sequential3)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), true, false, 1) : forEachSequentialDiscard(self, (a, i) => restore(f(a, i)))), () => finalizersMask(parallel3)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), (n) => finalizersMask(parallelN2(n))((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));
  }
  return match11(options == null ? void 0 : options.concurrency, () => finalizersMask(sequential3)((restore) => isRequestBatchingEnabled ? forEachParN(self, 1, (a, i) => restore(f(a, i)), true) : forEachSequential(self, (a, i) => restore(f(a, i)))), () => finalizersMask(parallel3)((restore) => forEachParUnbounded(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), (n) => finalizersMask(parallelN2(n))((restore) => forEachParN(self, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));
}));
var forEachParUnbounded = (self, f, batching) => suspend(() => {
  const as16 = fromIterable(self);
  const array6 = new Array(as16.length);
  const fn = (a, i) => flatMap10(f(a, i), (b) => sync(() => array6[i] = b));
  return zipRight(forEachConcurrentDiscard(as16, fn, batching, false), succeed(array6));
});
var forEachConcurrentDiscard = (self, f, batching, processAll, n) => uninterruptibleMask((restore) => transplant((graft) => withFiberRuntime((parent) => {
  let todos = Array.from(self).reverse();
  let target = todos.length;
  if (target === 0) {
    return void_;
  }
  let counter11 = 0;
  let interrupted4 = false;
  const fibersCount = n ? Math.min(todos.length, n) : todos.length;
  const fibers2 = /* @__PURE__ */ new Set();
  const results = new Array();
  const interruptAll3 = () => fibers2.forEach((fiber) => {
    fiber._scheduler.scheduleTask(() => {
      fiber.unsafeInterruptAsFork(parent.id());
    }, 0);
  });
  const startOrder = new Array();
  const joinOrder = new Array();
  const residual = new Array();
  const collectExits = () => {
    const exits = results.filter(({
      exit: exit3
    }) => exit3._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({
      exit: exit3
    }) => exit3);
    if (exits.length === 0) {
      exits.push(exitVoid);
    }
    return exits;
  };
  const runFiber = (eff, interruptImmediately = false) => {
    const runnable = uninterruptible(graft(eff));
    const fiber = unsafeForkUnstarted(runnable, parent, parent._runtimeFlags, globalScope);
    parent._scheduler.scheduleTask(() => {
      if (interruptImmediately) {
        fiber.unsafeInterruptAsFork(parent.id());
      }
      fiber.resume(runnable);
    }, 0);
    return fiber;
  };
  const onInterruptSignal = () => {
    if (!processAll) {
      target -= todos.length;
      todos = [];
    }
    interrupted4 = true;
    interruptAll3();
  };
  const stepOrExit = batching ? step2 : exit;
  const processingFiber = runFiber(async((resume2) => {
    const pushResult = (res, index) => {
      if (res._op === "Blocked") {
        residual.push(res);
      } else {
        results.push({
          index,
          exit: res
        });
        if (res._op === "Failure" && !interrupted4) {
          onInterruptSignal();
        }
      }
    };
    const next6 = () => {
      if (todos.length > 0) {
        const a = todos.pop();
        let index = counter11++;
        const returnNextElement = () => {
          const a2 = todos.pop();
          index = counter11++;
          return flatMap10(yieldNow(), () => flatMap10(stepOrExit(restore(f(a2, index))), onRes));
        };
        const onRes = (res) => {
          if (todos.length > 0) {
            pushResult(res, index);
            if (todos.length > 0) {
              return returnNextElement();
            }
          }
          return succeed(res);
        };
        const todo = flatMap10(stepOrExit(restore(f(a, index))), onRes);
        const fiber = runFiber(todo);
        startOrder.push(fiber);
        fibers2.add(fiber);
        if (interrupted4) {
          fiber._scheduler.scheduleTask(() => {
            fiber.unsafeInterruptAsFork(parent.id());
          }, 0);
        }
        fiber.addObserver((wrapped) => {
          let exit3;
          if (wrapped._op === "Failure") {
            exit3 = wrapped;
          } else {
            exit3 = wrapped.effect_instruction_i0;
          }
          joinOrder.push(fiber);
          fibers2.delete(fiber);
          pushResult(exit3, index);
          if (results.length === target) {
            resume2(succeed(getOrElse(exitCollectAll(collectExits(), {
              parallel: true
            }), () => exitVoid)));
          } else if (residual.length + results.length === target) {
            const requests = residual.map((blocked3) => blocked3.effect_instruction_i0).reduce(par);
            resume2(succeed(blocked(requests, forEachConcurrentDiscard([getOrElse(exitCollectAll(collectExits(), {
              parallel: true
            }), () => exitVoid), ...residual.map((blocked3) => blocked3.effect_instruction_i1)], (i) => i, batching, true, n))));
          } else {
            next6();
          }
        });
      }
    };
    for (let i = 0; i < fibersCount; i++) {
      next6();
    }
  }));
  return asVoid(onExit(flatten5(restore(join3(processingFiber))), exitMatch({
    onFailure: () => {
      onInterruptSignal();
      const target2 = residual.length + 1;
      const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
      const toPop = Array.from(residual);
      return async((cb) => {
        const exits = [];
        let count9 = 0;
        let index = 0;
        const check5 = (index2, hitNext) => (exit3) => {
          exits[index2] = exit3;
          count9++;
          if (count9 === target2) {
            cb(getOrThrow(exitCollectAll(exits, {
              parallel: true
            })));
          }
          if (toPop.length > 0 && hitNext) {
            next6();
          }
        };
        const next6 = () => {
          runFiber(toPop.pop(), true).addObserver(check5(index, true));
          index++;
        };
        processingFiber.addObserver(check5(index, false));
        index++;
        for (let i = 0; i < concurrency; i++) {
          next6();
        }
      });
    },
    onSuccess: () => forEachSequential(joinOrder, (f2) => f2.inheritAll)
  })));
})));
var forEachParN = (self, n, f, batching) => suspend(() => {
  const as16 = fromIterable(self);
  const array6 = new Array(as16.length);
  const fn = (a, i) => map11(f(a, i), (b) => array6[i] = b);
  return zipRight(forEachConcurrentDiscard(as16, fn, batching, false, n), succeed(array6));
});
var fork = (self) => withFiberRuntime((state, status3) => succeed(unsafeFork(self, state, status3.runtimeFlags)));
var forkDaemon = (self) => forkWithScopeOverride(self, globalScope);
var forkWithErrorHandler = dual(2, (self, handler) => fork(onError(self, (cause3) => {
  const either13 = failureOrCause(cause3);
  switch (either13._tag) {
    case "Left":
      return handler(either13.left);
    case "Right":
      return failCause(either13.right);
  }
})));
var unsafeFork = (effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect4, parentFiber, parentRuntimeFlags, overrideScope);
  childFiber.resume(effect4);
  return childFiber;
};
var unsafeForkUnstarted = (effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect4, parentFiber, parentRuntimeFlags, overrideScope);
  return childFiber;
};
var unsafeMakeChildFiber = (effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childId = unsafeMake3();
  const parentFiberRefs = parentFiber.getFiberRefs();
  const childFiberRefs = forkAs(parentFiberRefs, childId);
  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
  const childContext = getOrDefault(childFiberRefs, currentContext);
  const supervisor = childFiber._supervisor;
  supervisor.onStart(childContext, effect4, some2(parentFiber), childFiber);
  childFiber.addObserver((exit3) => supervisor.onEnd(exit3, childFiber));
  const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse(() => parentFiber.scope()));
  parentScope.add(parentRuntimeFlags, childFiber);
  return childFiber;
};
var forkWithScopeOverride = (self, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed(unsafeFork(self, parentFiber, parentStatus.runtimeFlags, scopeOverride)));
var mergeAll = dual((args) => isFunction(args[2]), (elements, zero3, f, options) => matchSimple(options == null ? void 0 : options.concurrency, () => fromIterable(elements).reduce((acc, a, i) => zipWith3(acc, a, (acc2, a2) => f(acc2, a2, i)), succeed(zero3)), () => flatMap10(make36(zero3), (acc) => flatMap10(forEach11(elements, (effect4, i) => flatMap10(effect4, (a) => update4(acc, (b) => f(b, a, i))), options), () => get11(acc)))));
var partition7 = dual((args) => isIterable(args[0]), (elements, f, options) => pipe(forEach11(elements, (a, i) => either3(f(a, i)), options), map11((chunk7) => partitionMap4(chunk7, identity))));
var validateAll = dual((args) => isIterable(args[0]), (elements, f, options) => flatMap10(partition7(elements, f, {
  concurrency: options == null ? void 0 : options.concurrency,
  batching: options == null ? void 0 : options.batching
}), ([es, bs]) => es.length === 0 ? (options == null ? void 0 : options.discard) ? void_ : succeed(bs) : fail2(es)));
var raceAll = (all12) => {
  const list = fromIterable2(all12);
  if (!isNonEmpty2(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  const self = headNonEmpty2(list);
  const effects = tailNonEmpty2(list);
  const inheritAll3 = (res) => pipe(inheritAll(res[1]), as2(res[0]));
  return pipe(deferredMake(), flatMap10((done17) => pipe(make36(effects.length), flatMap10((fails) => uninterruptibleMask((restore) => pipe(fork(interruptible2(self)), flatMap10((head11) => pipe(effects, forEachSequential((effect4) => fork(interruptible2(effect4))), map11((fibers2) => unsafeFromArray(fibers2)), map11((tail4) => pipe(tail4, prepend2(head11))), tap((fibers2) => pipe(fibers2, reduce(void_, (effect4, fiber) => pipe(effect4, zipRight(pipe(_await2(fiber), flatMap10(raceAllArbiter(fibers2, fiber, done17, fails)), fork, asVoid)))))), flatMap10((fibers2) => pipe(restore(pipe(_await(done17), flatMap10(inheritAll3))), onInterrupt(() => pipe(fibers2, reduce(void_, (effect4, fiber) => pipe(effect4, zipLeft(interruptFiber(fiber))))))))))))))));
};
var raceAllArbiter = (fibers2, winner, deferred, fails) => (exit3) => exitMatchEffect(exit3, {
  onFailure: (cause3) => pipe(modify6(fails, (fails2) => [fails2 === 0 ? pipe(deferredFailCause(deferred, cause3), asVoid) : void_, fails2 - 1]), flatten5),
  onSuccess: (value8) => pipe(deferredSucceed(deferred, [value8, winner]), flatMap10((set22) => set22 ? pipe(fromIterable2(fibers2), reduce(void_, (effect4, fiber) => fiber === winner ? effect4 : pipe(effect4, zipLeft(interruptFiber(fiber))))) : void_))
});
var reduceEffect = dual((args) => isIterable(args[0]), (elements, zero3, f, options) => matchSimple(options == null ? void 0 : options.concurrency, () => fromIterable(elements).reduce((acc, a, i) => zipWith3(acc, a, (acc2, a2) => f(acc2, a2, i)), zero3), () => suspend(() => pipe(mergeAll([zero3, ...elements], none2(), (acc, elem, i) => {
  switch (acc._tag) {
    case "None": {
      return some2(elem);
    }
    case "Some": {
      return some2(f(acc.value, elem, i));
    }
  }
}, options), map11((option9) => {
  switch (option9._tag) {
    case "None": {
      throw new Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    case "Some": {
      return option9.value;
    }
  }
})))));
var parallelFinalizers = (self) => contextWithEffect((context13) => match2(getOption2(context13, scopeTag), {
  onNone: () => self,
  onSome: (scope5) => {
    switch (scope5.strategy._tag) {
      case "Parallel":
        return self;
      case "Sequential":
      case "ParallelN":
        return flatMap10(scopeFork(scope5, parallel3), (inner) => scopeExtend(self, inner));
    }
  }
}));
var parallelNFinalizers = (parallelism) => (self) => contextWithEffect((context13) => match2(getOption2(context13, scopeTag), {
  onNone: () => self,
  onSome: (scope5) => {
    if (scope5.strategy._tag === "ParallelN" && scope5.strategy.parallelism === parallelism) {
      return self;
    }
    return flatMap10(scopeFork(scope5, parallelN2(parallelism)), (inner) => scopeExtend(self, inner));
  }
}));
var finalizersMask = (strategy) => (self) => contextWithEffect((context13) => match2(getOption2(context13, scopeTag), {
  onNone: () => self(identity),
  onSome: (scope5) => {
    const patch14 = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
    switch (scope5.strategy._tag) {
      case "Parallel":
        return patch14(self(parallelFinalizers));
      case "Sequential":
        return patch14(self(sequentialFinalizers));
      case "ParallelN":
        return patch14(self(parallelNFinalizers(scope5.strategy.parallelism)));
    }
  }
}));
var scopeWith = (f) => flatMap10(scopeTag, f);
var scopedEffect = (effect4) => flatMap10(scopeMake(), (scope5) => scopeUse(effect4, scope5));
var sequentialFinalizers = (self) => contextWithEffect((context13) => match2(getOption2(context13, scopeTag), {
  onNone: () => self,
  onSome: (scope5) => {
    switch (scope5.strategy._tag) {
      case "Sequential":
        return self;
      case "Parallel":
      case "ParallelN":
        return flatMap10(scopeFork(scope5, sequential3), (inner) => scopeExtend(self, inner));
    }
  }
}));
var tagMetricsScoped = (key, value8) => labelMetricsScoped([make38(key, value8)]);
var labelMetricsScoped = (labels) => fiberRefLocallyScopedWith(currentMetricLabels, (old) => union(old, labels));
var using = dual(2, (self, use2) => acquireUseRelease(scopeMake(), (scope5) => flatMap10(scopeExtend(self, scope5), use2), (scope5, exit3) => scopeClose(scope5, exit3)));
var validate = dual((args) => isEffect(args[1]), (self, that, options) => validateWith(self, that, (a, b) => [a, b], options));
var validateWith = dual((args) => isEffect(args[1]), (self, that, f, options) => flatten5(zipWithOptions(exit(self), exit(that), (ea, eb) => exitZipWith(ea, eb, {
  onSuccess: f,
  onFailure: (ca, cb) => (options == null ? void 0 : options.concurrent) ? parallel(ca, cb) : sequential(ca, cb)
}), options)));
var validateAllPar = dual(2, (elements, f) => flatMap10(partition7(elements, f), ([es, bs]) => es.length === 0 ? succeed(bs) : fail2(es)));
var validateAllParDiscard = dual(2, (elements, f) => flatMap10(partition7(elements, f), ([es, _]) => es.length === 0 ? void_ : fail2(es)));
var validateFirst = dual((args) => isIterable(args[0]), (elements, f, options) => flip(forEach11(elements, (a, i) => flip(f(a, i)), options)));
var withClockScoped = (value8) => fiberRefLocallyScopedWith(currentServices, add2(clockTag, value8));
var withRandomScoped = (value8) => fiberRefLocallyScopedWith(currentServices, add2(randomTag, value8));
var withConfigProviderScoped = (value8) => fiberRefLocallyScopedWith(currentServices, add2(configProviderTag, value8));
var withEarlyRelease = (self) => scopeWith((parent) => flatMap10(scopeFork(parent, sequential2), (child) => pipe(self, scopeExtend(child), map11((value8) => [fiberIdWith((fiberId5) => scopeClose(child, exitInterrupt(fiberId5))), value8]))));
var zipOptions = dual((args) => isEffect(args[1]), (self, that, options) => zipWithOptions(self, that, (a, b) => [a, b], options));
var zipLeftOptions = dual((args) => isEffect(args[1]), (self, that, options) => {
  if ((options == null ? void 0 : options.concurrent) !== true && ((options == null ? void 0 : options.batching) === void 0 || options.batching === false)) {
    return zipLeft(self, that);
  }
  return zipWithOptions(self, that, (a, _) => a, options);
});
var zipRightOptions = dual((args) => isEffect(args[1]), (self, that, options) => {
  if ((options == null ? void 0 : options.concurrent) !== true && ((options == null ? void 0 : options.batching) === void 0 || options.batching === false)) {
    return zipRight(self, that);
  }
  return zipWithOptions(self, that, (_, b) => b, options);
});
var zipWithOptions = dual((args) => isEffect(args[1]), (self, that, f, options) => map11(all5([self, that], {
  concurrency: (options == null ? void 0 : options.concurrent) ? 2 : 1,
  batching: options == null ? void 0 : options.batching
}), ([a, a2]) => f(a, a2)));
var withRuntimeFlagsScoped = (update16) => {
  if (update16 === empty18) {
    return void_;
  }
  return pipe(runtimeFlags, flatMap10((runtimeFlags2) => {
    const updatedRuntimeFlags = patch7(runtimeFlags2, update16);
    const revertRuntimeFlags = diff7(updatedRuntimeFlags, runtimeFlags2);
    return pipe(updateRuntimeFlags(update16), zipRight(addFinalizer(() => updateRuntimeFlags(revertRuntimeFlags))), asVoid);
  }), uninterruptible);
};
var scopeTag = GenericTag("effect/Scope");
var scope = scopeTag;
var scopeUnsafeAddFinalizer = (scope5, fin) => {
  if (scope5.state._tag === "Open") {
    scope5.state.finalizers.add(fin);
  }
};
var ScopeImplProto = {
  [ScopeTypeId]: ScopeTypeId,
  [CloseableScopeTypeId]: CloseableScopeTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  fork(strategy) {
    return sync(() => {
      const newScope = scopeUnsafeMake(strategy);
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      const fin = (exit3) => newScope.close(exit3);
      this.state.finalizers.add(fin);
      scopeUnsafeAddFinalizer(newScope, (_) => sync(() => {
        if (this.state._tag === "Open") {
          this.state.finalizers.delete(fin);
        }
      }));
      return newScope;
    });
  },
  close(exit3) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return void_;
      }
      const finalizers = Array.from(this.state.finalizers.values()).reverse();
      this.state = {
        _tag: "Closed",
        exit: exit3
      };
      if (finalizers.length === 0) {
        return void_;
      }
      return isSequential(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit(fin(exit3))), flatMap10((results) => pipe(exitCollectAll(results), map2(exitAsVoid), getOrElse(() => exitVoid)))) : isParallel(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit(fin(exit3)), false), flatMap10((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse(() => exitVoid)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit(fin(exit3)), false), flatMap10((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse(() => exitVoid))));
    });
  },
  addFinalizer(fin) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return fin(this.state.exit);
      }
      this.state.finalizers.add(fin);
      return void_;
    });
  }
};
var scopeUnsafeMake = (strategy = sequential2) => {
  const scope5 = Object.create(ScopeImplProto);
  scope5.strategy = strategy;
  scope5.state = {
    _tag: "Open",
    finalizers: /* @__PURE__ */ new Set()
  };
  return scope5;
};
var scopeMake = (strategy = sequential2) => sync(() => scopeUnsafeMake(strategy));
var scopeExtend = dual(2, (effect4, scope5) => mapInputContext(
  effect4,
  // @ts-expect-error
  merge3(make7(scopeTag, scope5))
));
var scopeUse = dual(2, (effect4, scope5) => pipe(effect4, scopeExtend(scope5), onExit((exit3) => scope5.close(exit3))));
var fiberRefUnsafeMakeSupervisor = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ: differ2,
  fork: empty32
});
var fiberRefLocallyScoped = dual(2, (self, value8) => asVoid(acquireRelease(flatMap10(fiberRefGet(self), (oldValue) => as2(fiberRefSet(self, value8), oldValue)), (oldValue) => fiberRefSet(self, oldValue))));
var fiberRefLocallyScopedWith = dual(2, (self, f) => fiberRefGetWith(self, (a) => fiberRefLocallyScoped(self, f(a))));
var fiberRefMake = (initial, options) => fiberRefMakeWith(() => fiberRefUnsafeMake(initial, options));
var fiberRefMakeWith = (ref) => acquireRelease(tap(sync(ref), (ref2) => fiberRefUpdate(ref2, identity)), (fiberRef) => fiberRefDelete(fiberRef));
var fiberRefMakeContext = (initial) => fiberRefMakeWith(() => fiberRefUnsafeMakeContext(initial));
var fiberRefMakeRuntimeFlags = (initial) => fiberRefMakeWith(() => fiberRefUnsafeMakeRuntimeFlags(initial));
var currentRuntimeFlags = fiberRefUnsafeMakeRuntimeFlags(none5);
var currentSupervisor = fiberRefUnsafeMakeSupervisor(none8);
var fiberAwaitAll = (fibers2) => asVoid(_await2(fiberAll(fibers2)));
var fiberAll = (fibers2) => ({
  [FiberTypeId]: fiberVariance,
  id: () => fromIterable(fibers2).reduce((id3, fiber) => combine3(id3, fiber.id()), none4),
  await: exit(forEachParUnbounded(fibers2, (fiber) => flatten5(fiber.await), false)),
  children: map11(forEachParUnbounded(fibers2, (fiber) => fiber.children, false), flatten),
  inheritAll: forEachSequentialDiscard(fibers2, (fiber) => fiber.inheritAll),
  poll: map11(forEachSequential(fibers2, (fiber) => fiber.poll), reduceRight(some2(exitSucceed(new Array())), (optionB, optionA) => {
    switch (optionA._tag) {
      case "None": {
        return none2();
      }
      case "Some": {
        switch (optionB._tag) {
          case "None": {
            return none2();
          }
          case "Some": {
            return some2(exitZipWith(optionA.value, optionB.value, {
              onSuccess: (a, chunk7) => [a, ...chunk7],
              onFailure: parallel
            }));
          }
        }
      }
    }
  })),
  interruptAsFork: (fiberId5) => forEachSequentialDiscard(fibers2, (fiber) => fiber.interruptAsFork(fiberId5)),
  pipe() {
    return pipeArguments(this, arguments);
  }
});
var fiberInterruptFork = (self) => asVoid(forkDaemon(interruptFiber(self)));
var fiberJoinAll = (fibers2) => join3(fiberAll(fibers2));
var fiberScoped = (self) => acquireRelease(succeed(self), interruptFiber);
var raceWith = dual(3, (self, other, options) => raceFibersWith(self, other, {
  onSelfWin: (winner, loser) => flatMap10(winner.await, (exit3) => {
    switch (exit3._tag) {
      case OP_SUCCESS: {
        return flatMap10(winner.inheritAll, () => options.onSelfDone(exit3, loser));
      }
      case OP_FAILURE: {
        return options.onSelfDone(exit3, loser);
      }
    }
  }),
  onOtherWin: (winner, loser) => flatMap10(winner.await, (exit3) => {
    switch (exit3._tag) {
      case OP_SUCCESS: {
        return flatMap10(winner.inheritAll, () => options.onOtherDone(exit3, loser));
      }
      case OP_FAILURE: {
        return options.onOtherDone(exit3, loser);
      }
    }
  })
}));
var disconnect = (self) => uninterruptibleMask((restore) => fiberIdWith((fiberId5) => flatMap10(forkDaemon(restore(self)), (fiber) => pipe(restore(join3(fiber)), onInterrupt(() => pipe(fiber, interruptAsFork(fiberId5)))))));
var race = dual(2, (self, that) => fiberIdWith((parentFiberId) => raceWith(self, that, {
  onSelfDone: (exit3, right2) => exitMatchEffect(exit3, {
    onFailure: (cause3) => pipe(join3(right2), mapErrorCause2((cause22) => parallel(cause3, cause22))),
    onSuccess: (value8) => pipe(right2, interruptAsFiber(parentFiberId), as2(value8))
  }),
  onOtherDone: (exit3, left2) => exitMatchEffect(exit3, {
    onFailure: (cause3) => pipe(join3(left2), mapErrorCause2((cause22) => parallel(cause22, cause3))),
    onSuccess: (value8) => pipe(left2, interruptAsFiber(parentFiberId), as2(value8))
  })
})));
var raceFibersWith = dual(3, (self, other, options) => withFiberRuntime((parentFiber, parentStatus) => {
  const parentRuntimeFlags = parentStatus.runtimeFlags;
  const raceIndicator = make13(true);
  const leftFiber = unsafeMakeChildFiber(self, parentFiber, parentRuntimeFlags, options.selfScope);
  const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);
  return async((cb) => {
    leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));
    rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));
    leftFiber.startFork(self);
    rightFiber.startFork(other);
  }, combine3(leftFiber.id(), rightFiber.id()));
}));
var completeRace = (winner, loser, cont, ab, cb) => {
  if (compareAndSet(true, false)(ab)) {
    cb(cont(winner, loser));
  }
};
var ensuring = dual(2, (self, finalizer3) => uninterruptibleMask((restore) => matchCauseEffect(restore(self), {
  onFailure: (cause1) => matchCauseEffect(finalizer3, {
    onFailure: (cause22) => failCause(sequential(cause1, cause22)),
    onSuccess: () => failCause(cause1)
  }),
  onSuccess: (a) => as2(finalizer3, a)
})));
var invokeWithInterrupt = (self, entries6, onInterrupt3) => fiberIdWith((id3) => flatMap10(flatMap10(forkDaemon(interruptible2(self)), (processing) => async((cb) => {
  const counts = entries6.map((_) => _.listeners.count);
  const checkDone = () => {
    if (counts.every((count9) => count9 === 0)) {
      cleanup.forEach((f) => f());
      onInterrupt3 == null ? void 0 : onInterrupt3();
      cb(interruptFiber(processing));
    }
  };
  processing.addObserver((exit3) => {
    cleanup.forEach((f) => f());
    cb(exit3);
  });
  const cleanup = entries6.map((r, i) => {
    const observer = (count9) => {
      counts[i] = count9;
      checkDone();
    };
    r.listeners.addObserver(observer);
    return () => r.listeners.removeObserver(observer);
  });
  checkDone();
  return sync(() => {
    cleanup.forEach((f) => f());
  });
})), () => suspend(() => {
  const residual = entries6.flatMap((entry) => {
    if (!entry.state.completed) {
      return [entry];
    }
    return [];
  });
  return forEachSequentialDiscard(residual, (entry) => complete2(entry.request, exitInterrupt(id3)));
})));
var interruptWhenPossible = dual(2, (self, all12) => fiberRefGetWith(currentRequestMap, (map43) => suspend(() => {
  const entries6 = fromIterable(all12).flatMap((_) => map43.has(_) ? [map43.get(_)] : []);
  return invokeWithInterrupt(self, entries6);
})));
var makeSpanScoped = (name, options) => uninterruptible(withFiberRuntime((fiber) => {
  const scope5 = unsafeGet3(fiber.getFiberRef(currentContext), scopeTag);
  const span4 = unsafeMakeSpan(fiber, name, options);
  const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
  const clock_ = get2(fiber.getFiberRef(currentServices), clockTag);
  return as2(scopeAddFinalizerExit(scope5, (exit3) => sync(() => {
    if (span4.status._tag === "Ended") {
      return;
    }
    span4.end(timingEnabled ? clock_.unsafeCurrentTimeNanos() : BigInt(0), exit3);
  })), span4);
}));
var withTracerScoped = (value8) => fiberRefLocallyScopedWith(currentServices, add2(tracerTag, value8));
var withSpanScoped = dual((args) => typeof args[0] !== "string", (self, name, options) => flatMap10(makeSpanScoped(name, options), (span4) => provideService(self, spanTag, span4)));

// ../node_modules/effect/dist/esm/internal/cache.js
var complete3 = (key, exit3, entryStats, timeToLiveMillis) => struct3({
  _tag: "Complete",
  key,
  exit: exit3,
  entryStats,
  timeToLiveMillis
});
var pending2 = (key, deferred) => struct3({
  _tag: "Pending",
  key,
  deferred
});
var refreshing = (deferred, complete6) => struct3({
  _tag: "Refreshing",
  deferred,
  complete: complete6
});
var MapKeyTypeId = Symbol.for("effect/Cache/MapKey");
var _a40;
var MapKeyImpl = class {
  constructor(current2) {
    __publicField(this, "current");
    __publicField(this, _a40, MapKeyTypeId);
    __publicField(this, "previous");
    __publicField(this, "next");
    this.current = current2;
  }
  [(_a40 = MapKeyTypeId, symbol2)]() {
    return pipe(hash(this.current), combine(hash(this.previous)), combine(hash(this.next)), cached(this));
  }
  [symbol3](that) {
    if (this === that) {
      return true;
    }
    return isMapKey(that) && equals(this.current, that.current) && equals(this.previous, that.previous) && equals(this.next, that.next);
  }
};
var makeMapKey = (current2) => new MapKeyImpl(current2);
var isMapKey = (u) => hasProperty(u, MapKeyTypeId);
var KeySetImpl = class {
  constructor() {
    __publicField(this, "head");
    __publicField(this, "tail");
  }
  add(key) {
    if (key !== this.tail) {
      if (this.tail === void 0) {
        this.head = key;
        this.tail = key;
      } else {
        const previous2 = key.previous;
        const next6 = key.next;
        if (next6 !== void 0) {
          key.next = void 0;
          if (previous2 !== void 0) {
            previous2.next = next6;
            next6.previous = previous2;
          } else {
            this.head = next6;
            this.head.previous = void 0;
          }
        }
        this.tail.next = key;
        key.previous = this.tail;
        this.tail = key;
      }
    }
  }
  remove() {
    const key = this.head;
    if (key !== void 0) {
      const next6 = key.next;
      if (next6 !== void 0) {
        key.next = void 0;
        this.head = next6;
        this.head.previous = void 0;
      } else {
        this.head = void 0;
        this.tail = void 0;
      }
    }
    return key;
  }
};
var makeKeySet = () => new KeySetImpl();
var makeCacheState = (map43, keys10, accesses, updating, hits, misses) => ({
  map: map43,
  keys: keys10,
  accesses,
  updating,
  hits,
  misses
});
var initialCacheState = () => makeCacheState(empty21(), makeKeySet(), unbounded(), make13(false), 0, 0);
var CacheSymbolKey = "effect/Cache";
var CacheTypeId = Symbol.for(CacheSymbolKey);
var cacheVariance = {
  /* c8 ignore next */
  _Key: (_) => _,
  /* c8 ignore next */
  _Error: (_) => _,
  /* c8 ignore next */
  _Value: (_) => _
};
var makeCacheStats = (options) => options;
var makeEntryStats = (loadedMillis) => ({
  loadedMillis
});
var _a41;
var CacheImpl = class {
  constructor(capacity10, context13, fiberId5, lookup, timeToLive) {
    __publicField(this, "capacity");
    __publicField(this, "context");
    __publicField(this, "fiberId");
    __publicField(this, "lookup");
    __publicField(this, "timeToLive");
    __publicField(this, _a41, cacheVariance);
    __publicField(this, "cacheState");
    this.capacity = capacity10;
    this.context = context13;
    this.fiberId = fiberId5;
    this.lookup = lookup;
    this.timeToLive = timeToLive;
    this.cacheState = initialCacheState();
  }
  get(key) {
    return map11(this.getEither(key), merge);
  }
  get cacheStats() {
    return sync(() => makeCacheStats({
      hits: this.cacheState.hits,
      misses: this.cacheState.misses,
      size: size8(this.cacheState.map)
    }));
  }
  getOption(key) {
    return suspend(() => match2(get7(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      },
      onSome: (value8) => this.resolveMapValue(value8)
    }));
  }
  getOptionComplete(key) {
    return suspend(() => match2(get7(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      },
      onSome: (value8) => this.resolveMapValue(value8, true)
    }));
  }
  contains(key) {
    return sync(() => has5(this.cacheState.map, key));
  }
  entryStats(key) {
    return sync(() => {
      const option9 = get7(this.cacheState.map, key);
      if (isSome(option9)) {
        switch (option9.value._tag) {
          case "Complete": {
            const loaded = option9.value.entryStats.loadedMillis;
            return some2(makeEntryStats(loaded));
          }
          case "Pending": {
            return none2();
          }
          case "Refreshing": {
            const loaded = option9.value.complete.entryStats.loadedMillis;
            return some2(makeEntryStats(loaded));
          }
        }
      }
      return none2();
    });
  }
  getEither(key) {
    return suspend(() => {
      const k = key;
      let mapKey = void 0;
      let deferred = void 0;
      let value8 = getOrUndefined(get7(this.cacheState.map, k));
      if (value8 === void 0) {
        deferred = unsafeMake4(this.fiberId);
        mapKey = makeMapKey(k);
        if (has5(this.cacheState.map, k)) {
          value8 = getOrUndefined(get7(this.cacheState.map, k));
        } else {
          set4(this.cacheState.map, k, pending2(mapKey, deferred));
        }
      }
      if (value8 === void 0) {
        this.trackAccess(mapKey);
        this.trackMiss();
        return map11(this.lookupValueOf(key, deferred), right);
      } else {
        return flatMap10(this.resolveMapValue(value8), match2({
          onNone: () => this.getEither(key),
          onSome: (value9) => succeed(left(value9))
        }));
      }
    });
  }
  invalidate(key) {
    return sync(() => {
      remove7(this.cacheState.map, key);
    });
  }
  invalidateWhen(key, when9) {
    return sync(() => {
      const value8 = get7(this.cacheState.map, key);
      if (isSome(value8) && value8.value._tag === "Complete") {
        if (value8.value.exit._tag === "Success") {
          if (when9(value8.value.exit.value)) {
            remove7(this.cacheState.map, key);
          }
        }
      }
    });
  }
  get invalidateAll() {
    return sync(() => {
      this.cacheState.map = empty21();
    });
  }
  refresh(key) {
    return clockWith3((clock3) => suspend(() => {
      const k = key;
      const deferred = unsafeMake4(this.fiberId);
      let value8 = getOrUndefined(get7(this.cacheState.map, k));
      if (value8 === void 0) {
        if (has5(this.cacheState.map, k)) {
          value8 = getOrUndefined(get7(this.cacheState.map, k));
        } else {
          set4(this.cacheState.map, k, pending2(makeMapKey(k), deferred));
        }
      }
      if (value8 === void 0) {
        return asVoid(this.lookupValueOf(key, deferred));
      } else {
        switch (value8._tag) {
          case "Complete": {
            if (this.hasExpired(clock3, value8.timeToLiveMillis)) {
              const found = getOrUndefined(get7(this.cacheState.map, k));
              if (equals(found, value8)) {
                remove7(this.cacheState.map, k);
              }
              return asVoid(this.get(key));
            }
            return pipe(this.lookupValueOf(key, deferred), when(() => {
              const current2 = getOrUndefined(get7(this.cacheState.map, k));
              if (equals(current2, value8)) {
                const mapValue = refreshing(deferred, value8);
                set4(this.cacheState.map, k, mapValue);
                return true;
              }
              return false;
            }), asVoid);
          }
          case "Pending": {
            return _await(value8.deferred);
          }
          case "Refreshing": {
            return _await(value8.deferred);
          }
        }
      }
    }));
  }
  set(key, value8) {
    return clockWith3((clock3) => sync(() => {
      const now = clock3.unsafeCurrentTimeMillis();
      const k = key;
      const lookupResult = succeed3(value8);
      const mapValue = complete3(makeMapKey(k), lookupResult, makeEntryStats(now), now + toMillis(decode(this.timeToLive(lookupResult))));
      set4(this.cacheState.map, k, mapValue);
    }));
  }
  get size() {
    return sync(() => {
      return size8(this.cacheState.map);
    });
  }
  get values() {
    return sync(() => {
      const values13 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values13.push(entry[1].exit.value);
        }
      }
      return values13;
    });
  }
  get entries() {
    return sync(() => {
      const values13 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values13.push([entry[0], entry[1].exit.value]);
        }
      }
      return values13;
    });
  }
  get keys() {
    return sync(() => {
      const keys10 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          keys10.push(entry[0]);
        }
      }
      return keys10;
    });
  }
  resolveMapValue(value8, ignorePending = false) {
    return clockWith3((clock3) => {
      switch (value8._tag) {
        case "Complete": {
          this.trackAccess(value8.key);
          if (this.hasExpired(clock3, value8.timeToLiveMillis)) {
            remove7(this.cacheState.map, value8.key.current);
            return succeed(none2());
          }
          this.trackHit();
          return map11(value8.exit, some2);
        }
        case "Pending": {
          this.trackAccess(value8.key);
          this.trackHit();
          if (ignorePending) {
            return succeed(none2());
          }
          return map11(_await(value8.deferred), some2);
        }
        case "Refreshing": {
          this.trackAccess(value8.complete.key);
          this.trackHit();
          if (this.hasExpired(clock3, value8.complete.timeToLiveMillis)) {
            if (ignorePending) {
              return succeed(none2());
            }
            return map11(_await(value8.deferred), some2);
          }
          return map11(value8.complete.exit, some2);
        }
      }
    });
  }
  trackHit() {
    this.cacheState.hits = this.cacheState.hits + 1;
  }
  trackMiss() {
    this.cacheState.misses = this.cacheState.misses + 1;
  }
  trackAccess(key) {
    offer(this.cacheState.accesses, key);
    if (compareAndSet(this.cacheState.updating, false, true)) {
      let loop5 = true;
      while (loop5) {
        const key2 = poll2(this.cacheState.accesses, EmptyMutableQueue);
        if (key2 === EmptyMutableQueue) {
          loop5 = false;
        } else {
          this.cacheState.keys.add(key2);
        }
      }
      let size38 = size8(this.cacheState.map);
      loop5 = size38 > this.capacity;
      while (loop5) {
        const key2 = this.cacheState.keys.remove();
        if (key2 !== void 0) {
          if (has5(this.cacheState.map, key2.current)) {
            remove7(this.cacheState.map, key2.current);
            size38 = size38 - 1;
            loop5 = size38 > this.capacity;
          }
        } else {
          loop5 = false;
        }
      }
      set2(this.cacheState.updating, false);
    }
  }
  hasExpired(clock3, timeToLiveMillis) {
    return clock3.unsafeCurrentTimeMillis() > timeToLiveMillis;
  }
  lookupValueOf(input, deferred) {
    return clockWith3((clock3) => suspend(() => {
      const key = input;
      return pipe(this.lookup(input), provideContext(this.context), exit, flatMap10((exit3) => {
        const now = clock3.unsafeCurrentTimeMillis();
        const stats = makeEntryStats(now);
        const value8 = complete3(makeMapKey(key), exit3, stats, now + toMillis(decode(this.timeToLive(exit3))));
        set4(this.cacheState.map, key, value8);
        return zipRight(done2(deferred, exit3), exit3);
      }), onInterrupt(() => zipRight(interrupt3(deferred), sync(() => {
        remove7(this.cacheState.map, key);
      }))));
    }));
  }
};
_a41 = CacheTypeId;
var make48 = (options) => {
  const timeToLive = decode(options.timeToLive);
  return makeWith({
    capacity: options.capacity,
    lookup: options.lookup,
    timeToLive: () => timeToLive
  });
};
var makeWith = (options) => map11(all5([context(), fiberId]), ([context13, fiberId5]) => new CacheImpl(options.capacity, context13, fiberId5, options.lookup, (exit3) => decode(options.timeToLive(exit3))));
var unsafeMakeWith = (capacity10, lookup, timeToLive) => new CacheImpl(capacity10, empty4(), none3, lookup, (exit3) => decode(timeToLive(exit3)));

// ../node_modules/effect/dist/esm/Cache.js
var CacheTypeId2 = CacheTypeId;
var make49 = make48;
var makeWith2 = makeWith;
var makeCacheStats2 = makeCacheStats;
var makeEntryStats2 = makeEntryStats;

// ../node_modules/effect/dist/esm/Cause.js
var Cause_exports = {};
__export(Cause_exports, {
  CauseTypeId: () => CauseTypeId2,
  IllegalArgumentException: () => IllegalArgumentException2,
  IllegalArgumentExceptionTypeId: () => IllegalArgumentExceptionTypeId2,
  InterruptedException: () => InterruptedException2,
  InterruptedExceptionTypeId: () => InterruptedExceptionTypeId2,
  InvalidPubSubCapacityExceptionTypeId: () => InvalidPubSubCapacityExceptionTypeId2,
  NoSuchElementException: () => NoSuchElementException2,
  NoSuchElementExceptionTypeId: () => NoSuchElementExceptionTypeId2,
  RuntimeException: () => RuntimeException2,
  RuntimeExceptionTypeId: () => RuntimeExceptionTypeId2,
  TimeoutException: () => TimeoutException2,
  TimeoutExceptionTypeId: () => TimeoutExceptionTypeId2,
  UnknownException: () => UnknownException2,
  UnknownExceptionTypeId: () => UnknownExceptionTypeId2,
  YieldableError: () => YieldableError2,
  andThen: () => andThen6,
  as: () => as4,
  contains: () => contains5,
  defects: () => defects2,
  die: () => die5,
  dieOption: () => dieOption2,
  empty: () => empty33,
  fail: () => fail7,
  failureOption: () => failureOption2,
  failureOrCause: () => failureOrCause2,
  failures: () => failures2,
  filter: () => filter11,
  find: () => find2,
  flatMap: () => flatMap13,
  flatten: () => flatten7,
  flipCauseOption: () => flipCauseOption2,
  interrupt: () => interrupt5,
  interruptOption: () => interruptOption2,
  interruptors: () => interruptors2,
  isCause: () => isCause2,
  isDie: () => isDie2,
  isDieType: () => isDieType2,
  isEmpty: () => isEmpty9,
  isEmptyType: () => isEmptyType2,
  isFailType: () => isFailType2,
  isFailure: () => isFailure4,
  isIllegalArgumentException: () => isIllegalArgumentException2,
  isInterruptType: () => isInterruptType2,
  isInterrupted: () => isInterrupted3,
  isInterruptedException: () => isInterruptedException2,
  isInterruptedOnly: () => isInterruptedOnly2,
  isNoSuchElementException: () => isNoSuchElementException2,
  isParallelType: () => isParallelType2,
  isRuntimeException: () => isRuntimeException2,
  isSequentialType: () => isSequentialType2,
  isUnknownException: () => isUnknownException2,
  keepDefects: () => keepDefects2,
  linearize: () => linearize2,
  map: () => map18,
  match: () => match13,
  originalError: () => originalError,
  parallel: () => parallel4,
  pretty: () => pretty3,
  reduce: () => reduce13,
  reduceWithContext: () => reduceWithContext3,
  sequential: () => sequential4,
  size: () => size12,
  squash: () => squash,
  squashWith: () => squashWith,
  stripFailures: () => stripFailures2,
  stripSomeDefects: () => stripSomeDefects2
});
var CauseTypeId2 = CauseTypeId;
var RuntimeExceptionTypeId2 = RuntimeExceptionTypeId;
var InterruptedExceptionTypeId2 = InterruptedExceptionTypeId;
var IllegalArgumentExceptionTypeId2 = IllegalArgumentExceptionTypeId;
var NoSuchElementExceptionTypeId2 = NoSuchElementExceptionTypeId;
var InvalidPubSubCapacityExceptionTypeId2 = InvalidPubSubCapacityExceptionTypeId;
var TimeoutExceptionTypeId2 = TimeoutExceptionTypeId;
var UnknownExceptionTypeId2 = UnknownExceptionTypeId;
var YieldableError2 = YieldableError;
var empty33 = empty20;
var fail7 = fail;
var die5 = die;
var interrupt5 = interrupt;
var parallel4 = parallel;
var sequential4 = sequential;
var isCause2 = isCause;
var isEmptyType2 = isEmptyType;
var isFailType2 = isFailType;
var isDieType2 = isDieType;
var isInterruptType2 = isInterruptType;
var isSequentialType2 = isSequentialType;
var isParallelType2 = isParallelType;
var size12 = size7;
var isEmpty9 = isEmpty6;
var isFailure4 = isFailure;
var isDie2 = isDie;
var isInterrupted3 = isInterrupted;
var isInterruptedOnly2 = isInterruptedOnly;
var failures2 = failures;
var defects2 = defects;
var interruptors2 = interruptors;
var failureOption2 = failureOption;
var failureOrCause2 = failureOrCause;
var flipCauseOption2 = flipCauseOption;
var dieOption2 = dieOption;
var interruptOption2 = interruptOption;
var keepDefects2 = keepDefects;
var linearize2 = linearize;
var stripFailures2 = stripFailures;
var stripSomeDefects2 = stripSomeDefects;
var as4 = as;
var map18 = map10;
var flatMap13 = flatMap9;
var andThen6 = andThen3;
var flatten7 = flatten4;
var contains5 = contains4;
var squash = causeSquash;
var squashWith = causeSquashWith;
var find2 = find;
var filter11 = filter8;
var match13 = match5;
var reduce13 = reduce9;
var reduceWithContext3 = reduceWithContext;
var InterruptedException2 = InterruptedException;
var isInterruptedException2 = isInterruptedException;
var IllegalArgumentException2 = IllegalArgumentException;
var isIllegalArgumentException2 = isIllegalArgumentException;
var NoSuchElementException2 = NoSuchElementException;
var isNoSuchElementException2 = isNoSuchElementException;
var RuntimeException2 = RuntimeException;
var isRuntimeException2 = isRuntimeException;
var TimeoutException2 = TimeoutException;
var UnknownException2 = UnknownException;
var isUnknownException2 = isUnknownException;
var pretty3 = pretty;
var originalError = originalInstance;

// ../node_modules/effect/dist/esm/Channel.js
var Channel_exports = {};
__export(Channel_exports, {
  ChannelException: () => ChannelException2,
  ChannelExceptionTypeId: () => ChannelExceptionTypeId2,
  ChannelTypeId: () => ChannelTypeId4,
  acquireReleaseOut: () => acquireReleaseOut2,
  acquireUseRelease: () => acquireUseRelease4,
  as: () => as11,
  asVoid: () => asVoid7,
  buffer: () => buffer3,
  bufferChunk: () => bufferChunk2,
  catchAll: () => catchAll7,
  catchAllCause: () => catchAllCause7,
  collect: () => collect2,
  concatAll: () => concatAll3,
  concatAllWith: () => concatAllWith2,
  concatMap: () => concatMap2,
  concatMapWith: () => concatMapWith2,
  concatMapWithCustom: () => concatMapWithCustom2,
  concatOut: () => concatOut2,
  context: () => context8,
  contextWith: () => contextWith6,
  contextWithChannel: () => contextWithChannel2,
  contextWithEffect: () => contextWithEffect6,
  doneCollect: () => doneCollect2,
  drain: () => drain4,
  embedInput: () => embedInput2,
  emitCollect: () => emitCollect2,
  ensuring: () => ensuring8,
  ensuringWith: () => ensuringWith4,
  fail: () => fail17,
  failCause: () => failCause16,
  failCauseSync: () => failCauseSync9,
  failSync: () => failSync9,
  flatMap: () => flatMap20,
  flatten: () => flatten13,
  foldCauseChannel: () => foldCauseChannel2,
  foldChannel: () => foldChannel2,
  fromEffect: () => fromEffect10,
  fromEither: () => fromEither3,
  fromInput: () => fromInput4,
  fromOption: () => fromOption4,
  fromPubSub: () => fromPubSub4,
  fromPubSubScoped: () => fromPubSubScoped2,
  fromQueue: () => fromQueue4,
  identity: () => identity4,
  interruptWhen: () => interruptWhen3,
  interruptWhenDeferred: () => interruptWhenDeferred3,
  isChannelException: () => isChannelException2,
  map: () => map29,
  mapEffect: () => mapEffect8,
  mapError: () => mapError9,
  mapErrorCause: () => mapErrorCause6,
  mapInput: () => mapInput9,
  mapInputContext: () => mapInputContext7,
  mapInputEffect: () => mapInputEffect5,
  mapInputError: () => mapInputError2,
  mapInputErrorEffect: () => mapInputErrorEffect2,
  mapInputIn: () => mapInputIn2,
  mapInputInEffect: () => mapInputInEffect2,
  mapOut: () => mapOut2,
  mapOutEffect: () => mapOutEffect2,
  mapOutEffectPar: () => mapOutEffectPar2,
  mergeAll: () => mergeAll7,
  mergeAllUnbounded: () => mergeAllUnbounded2,
  mergeAllUnboundedWith: () => mergeAllUnboundedWith2,
  mergeAllWith: () => mergeAllWith2,
  mergeMap: () => mergeMap2,
  mergeOut: () => mergeOut2,
  mergeOutWith: () => mergeOutWith2,
  mergeWith: () => mergeWith3,
  never: () => never8,
  orDie: () => orDie7,
  orDieWith: () => orDieWith5,
  orElse: () => orElse12,
  pipeTo: () => pipeTo2,
  pipeToOrFail: () => pipeToOrFail2,
  provideContext: () => provideContext7,
  provideLayer: () => provideLayer3,
  provideService: () => provideService9,
  provideSomeLayer: () => provideSomeLayer4,
  read: () => read2,
  readOrFail: () => readOrFail2,
  readWith: () => readWith2,
  readWithCause: () => readWithCause2,
  repeated: () => repeated2,
  run: () => run6,
  runCollect: () => runCollect3,
  runDrain: () => runDrain3,
  scoped: () => scoped7,
  splitLines: () => splitLines3,
  succeed: () => succeed18,
  suspend: () => suspend8,
  sync: () => sync13,
  toPubSub: () => toPubSub3,
  toPull: () => toPull3,
  toQueue: () => toQueue3,
  toSink: () => toSink,
  toStream: () => toStream,
  unwrap: () => unwrap5,
  unwrapScoped: () => unwrapScoped6,
  updateService: () => updateService5,
  void: () => void_7,
  withSpan: () => withSpan7,
  write: () => write2,
  writeAll: () => writeAll2,
  writeChunk: () => writeChunk2,
  zip: () => zip14,
  zipLeft: () => zipLeft11,
  zipRight: () => zipRight11
});

// ../node_modules/effect/dist/esm/Effect.js
var Effect_exports = {};
__export(Effect_exports, {
  Do: () => Do2,
  EffectTypeId: () => EffectTypeId4,
  Tag: () => Tag3,
  acquireRelease: () => acquireRelease2,
  acquireReleaseInterruptible: () => acquireReleaseInterruptible2,
  acquireUseRelease: () => acquireUseRelease2,
  addFinalizer: () => addFinalizer3,
  all: () => all7,
  allSuccesses: () => allSuccesses2,
  allWith: () => allWith2,
  allowInterrupt: () => allowInterrupt2,
  andThen: () => andThen8,
  annotateCurrentSpan: () => annotateCurrentSpan2,
  annotateLogs: () => annotateLogs2,
  annotateSpans: () => annotateSpans2,
  ap: () => ap,
  as: () => as6,
  asSome: () => asSome2,
  asSomeError: () => asSomeError2,
  asVoid: () => asVoid4,
  async: () => async2,
  asyncEffect: () => asyncEffect2,
  awaitAllChildren: () => awaitAllChildren2,
  bind: () => bind2,
  bindTo: () => bindTo2,
  blocked: () => blocked2,
  cacheRequestResult: () => cacheRequestResult,
  cached: () => cached3,
  cachedFunction: () => cachedFunction2,
  cachedInvalidateWithTTL: () => cachedInvalidateWithTTL2,
  cachedWithTTL: () => cachedWithTTL,
  catch: () => _catch2,
  catchAll: () => catchAll3,
  catchAllCause: () => catchAllCause3,
  catchAllDefect: () => catchAllDefect2,
  catchIf: () => catchIf2,
  catchSome: () => catchSome2,
  catchSomeCause: () => catchSomeCause2,
  catchSomeDefect: () => catchSomeDefect2,
  catchTag: () => catchTag2,
  catchTags: () => catchTags2,
  cause: () => cause2,
  checkInterruptible: () => checkInterruptible2,
  clock: () => clock2,
  clockWith: () => clockWith4,
  configProviderWith: () => configProviderWith2,
  console: () => console3,
  consoleWith: () => consoleWith2,
  context: () => context3,
  contextWith: () => contextWith2,
  contextWithEffect: () => contextWithEffect2,
  currentParentSpan: () => currentParentSpan2,
  currentSpan: () => currentSpan2,
  custom: () => custom2,
  daemonChildren: () => daemonChildren2,
  delay: () => delay2,
  descriptor: () => descriptor2,
  descriptorWith: () => descriptorWith2,
  die: () => die7,
  dieMessage: () => dieMessage2,
  dieSync: () => dieSync4,
  diffFiberRefs: () => diffFiberRefs2,
  disconnect: () => disconnect2,
  dropUntil: () => dropUntil2,
  dropWhile: () => dropWhile3,
  either: () => either5,
  ensuring: () => ensuring3,
  ensuringChild: () => ensuringChild2,
  ensuringChildren: () => ensuringChildren2,
  eventually: () => eventually2,
  every: () => every9,
  exists: () => exists3,
  exit: () => exit2,
  fail: () => fail11,
  failCause: () => failCause9,
  failCauseSync: () => failCauseSync4,
  failSync: () => failSync4,
  fiberId: () => fiberId2,
  fiberIdWith: () => fiberIdWith2,
  filter: () => filter12,
  filterMap: () => filterMap7,
  filterOrDie: () => filterOrDie2,
  filterOrDieMessage: () => filterOrDieMessage2,
  filterOrElse: () => filterOrElse2,
  filterOrFail: () => filterOrFail2,
  finalizersMask: () => finalizersMask2,
  findFirst: () => findFirst9,
  firstSuccessOf: () => firstSuccessOf2,
  flatMap: () => flatMap15,
  flatten: () => flatten9,
  flip: () => flip2,
  flipWith: () => flipWith2,
  forEach: () => forEach12,
  forever: () => forever3,
  fork: () => fork3,
  forkAll: () => forkAll2,
  forkDaemon: () => forkDaemon2,
  forkIn: () => forkIn2,
  forkScoped: () => forkScoped2,
  forkWithErrorHandler: () => forkWithErrorHandler2,
  fromFiber: () => fromFiber2,
  fromFiberEffect: () => fromFiberEffect2,
  fromNullable: () => fromNullable3,
  gen: () => gen2,
  getFiberRefs: () => getFiberRefs,
  getRuntimeFlags: () => getRuntimeFlags,
  head: () => head6,
  if: () => if_2,
  ignore: () => ignore2,
  ignoreLogged: () => ignoreLogged2,
  inheritFiberRefs: () => inheritFiberRefs2,
  interrupt: () => interrupt7,
  interruptWith: () => interruptWith3,
  interruptible: () => interruptible3,
  interruptibleMask: () => interruptibleMask2,
  intoDeferred: () => intoDeferred2,
  isEffect: () => isEffect2,
  isFailure: () => isFailure5,
  isSuccess: () => isSuccess3,
  iterate: () => iterate2,
  labelMetrics: () => labelMetrics2,
  labelMetricsScoped: () => labelMetricsScoped2,
  let: () => let_2,
  linkSpans: () => linkSpans2,
  locally: () => locally2,
  locallyScoped: () => locallyScoped,
  locallyScopedWith: () => locallyScopedWith,
  locallyWith: () => locallyWith,
  log: () => log3,
  logAnnotations: () => logAnnotations2,
  logDebug: () => logDebug2,
  logError: () => logError2,
  logFatal: () => logFatal2,
  logInfo: () => logInfo2,
  logTrace: () => logTrace2,
  logWarning: () => logWarning2,
  logWithLevel: () => logWithLevel2,
  loop: () => loop2,
  makeSemaphore: () => makeSemaphore2,
  makeSpan: () => makeSpan2,
  makeSpanScoped: () => makeSpanScoped2,
  map: () => map22,
  mapAccum: () => mapAccum4,
  mapBoth: () => mapBoth4,
  mapError: () => mapError4,
  mapErrorCause: () => mapErrorCause3,
  mapInputContext: () => mapInputContext3,
  match: () => match17,
  matchCause: () => matchCause3,
  matchCauseEffect: () => matchCauseEffect2,
  matchEffect: () => matchEffect3,
  merge: () => merge7,
  mergeAll: () => mergeAll3,
  metricLabels: () => metricLabels2,
  negate: () => negate3,
  never: () => never4,
  none: () => none9,
  onError: () => onError2,
  onExit: () => onExit2,
  onInterrupt: () => onInterrupt2,
  once: () => once3,
  option: () => option2,
  optionFromOptional: () => optionFromOptional2,
  orDie: () => orDie3,
  orDieWith: () => orDieWith2,
  orElse: () => orElse7,
  orElseFail: () => orElseFail2,
  orElseSucceed: () => orElseSucceed2,
  parallelErrors: () => parallelErrors2,
  parallelFinalizers: () => parallelFinalizers2,
  partition: () => partition8,
  patchFiberRefs: () => patchFiberRefs2,
  patchRuntimeFlags: () => patchRuntimeFlags,
  promise: () => promise2,
  provide: () => provide2,
  provideService: () => provideService4,
  provideServiceEffect: () => provideServiceEffect2,
  race: () => race2,
  raceAll: () => raceAll2,
  raceFirst: () => raceFirst2,
  raceWith: () => raceWith2,
  random: () => random3,
  randomWith: () => randomWith3,
  reduce: () => reduce15,
  reduceEffect: () => reduceEffect3,
  reduceRight: () => reduceRight5,
  reduceWhile: () => reduceWhile2,
  repeat: () => repeat,
  repeatN: () => repeatN2,
  repeatOrElse: () => repeatOrElse,
  replicate: () => replicate2,
  replicateEffect: () => replicateEffect2,
  request: () => request,
  retry: () => retry2,
  retryOrElse: () => retryOrElse,
  runCallback: () => runCallback,
  runFork: () => runFork,
  runPromise: () => runPromise,
  runPromiseExit: () => runPromiseExit,
  runRequestBlock: () => runRequestBlock2,
  runSync: () => runSync,
  runSyncExit: () => runSyncExit,
  runtime: () => runtime4,
  sandbox: () => sandbox2,
  schedule: () => schedule,
  scheduleForked: () => scheduleForked2,
  scheduleFrom: () => scheduleFrom,
  scope: () => scope3,
  scopeWith: () => scopeWith2,
  scoped: () => scoped3,
  sequentialFinalizers: () => sequentialFinalizers2,
  serviceConstants: () => serviceConstants2,
  serviceFunction: () => serviceFunction2,
  serviceFunctionEffect: () => serviceFunctionEffect2,
  serviceFunctions: () => serviceFunctions2,
  serviceMembers: () => serviceMembers2,
  serviceOption: () => serviceOption2,
  serviceOptional: () => serviceOptional2,
  setFiberRefs: () => setFiberRefs2,
  sleep: () => sleep4,
  spanAnnotations: () => spanAnnotations2,
  spanLinks: () => spanLinks2,
  step: () => step3,
  succeed: () => succeed12,
  succeedNone: () => succeedNone2,
  succeedSome: () => succeedSome2,
  summarized: () => summarized2,
  supervised: () => supervised2,
  suspend: () => suspend3,
  sync: () => sync7,
  tagMetrics: () => tagMetrics2,
  tagMetricsScoped: () => tagMetricsScoped2,
  takeUntil: () => takeUntil2,
  takeWhile: () => takeWhile3,
  tap: () => tap3,
  tapBoth: () => tapBoth2,
  tapDefect: () => tapDefect2,
  tapError: () => tapError3,
  tapErrorCause: () => tapErrorCause3,
  tapErrorTag: () => tapErrorTag2,
  timed: () => timed2,
  timedWith: () => timedWith2,
  timeout: () => timeout2,
  timeoutFail: () => timeoutFail2,
  timeoutFailCause: () => timeoutFailCause2,
  timeoutTo: () => timeoutTo2,
  tracer: () => tracer2,
  tracerWith: () => tracerWith4,
  transplant: () => transplant2,
  try: () => try_2,
  tryMap: () => tryMap2,
  tryMapPromise: () => tryMapPromise2,
  tryPromise: () => tryPromise2,
  uninterruptible: () => uninterruptible2,
  uninterruptibleMask: () => uninterruptibleMask2,
  unless: () => unless2,
  unlessEffect: () => unlessEffect2,
  unsafeMakeSemaphore: () => unsafeMakeSemaphore2,
  unsandbox: () => unsandbox2,
  updateFiberRefs: () => updateFiberRefs3,
  updateService: () => updateService2,
  useSpan: () => useSpan2,
  using: () => using2,
  validate: () => validate2,
  validateAll: () => validateAll2,
  validateFirst: () => validateFirst2,
  validateWith: () => validateWith2,
  void: () => _void,
  when: () => when2,
  whenEffect: () => whenEffect2,
  whenFiberRef: () => whenFiberRef2,
  whenRef: () => whenRef2,
  whileLoop: () => whileLoop2,
  withClock: () => withClock2,
  withClockScoped: () => withClockScoped2,
  withConcurrency: () => withConcurrency2,
  withConfigProvider: () => withConfigProvider2,
  withConfigProviderScoped: () => withConfigProviderScoped2,
  withConsole: () => withConsole2,
  withConsoleScoped: () => withConsoleScoped2,
  withEarlyRelease: () => withEarlyRelease2,
  withFiberRuntime: () => withFiberRuntime2,
  withLogSpan: () => withLogSpan2,
  withMaxOpsBeforeYield: () => withMaxOpsBeforeYield2,
  withMetric: () => withMetric2,
  withParentSpan: () => withParentSpan3,
  withRandom: () => withRandom2,
  withRandomScoped: () => withRandomScoped2,
  withRequestBatching: () => withRequestBatching2,
  withRequestCache: () => withRequestCache2,
  withRequestCaching: () => withRequestCaching2,
  withRuntimeFlagsPatch: () => withRuntimeFlagsPatch,
  withRuntimeFlagsPatchScoped: () => withRuntimeFlagsPatchScoped,
  withScheduler: () => withScheduler2,
  withSchedulingPriority: () => withSchedulingPriority2,
  withSpan: () => withSpan3,
  withSpanScoped: () => withSpanScoped2,
  withTracer: () => withTracer2,
  withTracerEnabled: () => withTracerEnabled2,
  withTracerScoped: () => withTracerScoped2,
  withTracerTiming: () => withTracerTiming2,
  withUnhandledErrorLogLevel: () => withUnhandledErrorLogLevel2,
  yieldNow: () => yieldNow3,
  zip: () => zip10,
  zipLeft: () => zipLeft6,
  zipRight: () => zipRight6,
  zipWith: () => zipWith8
});

// ../node_modules/effect/dist/esm/ScheduleDecision.js
var ScheduleDecision_exports = {};
__export(ScheduleDecision_exports, {
  continue: () => _continue2,
  continueWith: () => continueWith2,
  done: () => done7,
  isContinue: () => isContinue2,
  isDone: () => isDone5
});

// ../node_modules/effect/dist/esm/ScheduleIntervals.js
var ScheduleIntervals_exports = {};
__export(ScheduleIntervals_exports, {
  IntervalsTypeId: () => IntervalsTypeId2,
  empty: () => empty37,
  end: () => end2,
  fromIterable: () => fromIterable15,
  intersect: () => intersect4,
  isNonEmpty: () => isNonEmpty6,
  lessThan: () => lessThan11,
  make: () => make53,
  max: () => max8,
  start: () => start2,
  union: () => union11
});

// ../node_modules/effect/dist/esm/ScheduleInterval.js
var ScheduleInterval_exports = {};
__export(ScheduleInterval_exports, {
  IntervalTypeId: () => IntervalTypeId2,
  after: () => after2,
  before: () => before2,
  empty: () => empty35,
  intersect: () => intersect2,
  isEmpty: () => isEmpty11,
  isNonEmpty: () => isNonEmpty4,
  lessThan: () => lessThan9,
  make: () => make51,
  max: () => max6,
  min: () => min6,
  size: () => size14,
  union: () => union9
});

// ../node_modules/effect/dist/esm/internal/schedule/interval.js
var IntervalSymbolKey = "effect/ScheduleInterval";
var IntervalTypeId = Symbol.for(IntervalSymbolKey);
var empty34 = {
  [IntervalTypeId]: IntervalTypeId,
  startMillis: 0,
  endMillis: 0
};
var make50 = (startMillis, endMillis) => {
  if (startMillis > endMillis) {
    return empty34;
  }
  return {
    [IntervalTypeId]: IntervalTypeId,
    startMillis,
    endMillis
  };
};
var lessThan8 = dual(2, (self, that) => min5(self, that) === self);
var min5 = dual(2, (self, that) => {
  if (self.endMillis <= that.startMillis)
    return self;
  if (that.endMillis <= self.startMillis)
    return that;
  if (self.startMillis < that.startMillis)
    return self;
  if (that.startMillis < self.startMillis)
    return that;
  if (self.endMillis <= that.endMillis)
    return self;
  return that;
});
var max5 = dual(2, (self, that) => min5(self, that) === self ? that : self);
var isEmpty10 = (self) => {
  return self.startMillis >= self.endMillis;
};
var isNonEmpty3 = (self) => {
  return !isEmpty10(self);
};
var intersect = dual(2, (self, that) => {
  const start5 = Math.max(self.startMillis, that.startMillis);
  const end7 = Math.min(self.endMillis, that.endMillis);
  return make50(start5, end7);
});
var size13 = (self) => {
  return millis(self.endMillis - self.startMillis);
};
var union8 = dual(2, (self, that) => {
  const start5 = Math.max(self.startMillis, that.startMillis);
  const end7 = Math.min(self.endMillis, that.endMillis);
  return start5 < end7 ? none2() : some2(make50(start5, end7));
});
var after = (startMilliseconds) => {
  return make50(startMilliseconds, Number.POSITIVE_INFINITY);
};
var before = (endMilliseconds) => {
  return make50(Number.NEGATIVE_INFINITY, endMilliseconds);
};

// ../node_modules/effect/dist/esm/ScheduleInterval.js
var IntervalTypeId2 = IntervalTypeId;
var make51 = make50;
var empty35 = empty34;
var lessThan9 = lessThan8;
var min6 = min5;
var max6 = max5;
var isEmpty11 = isEmpty10;
var isNonEmpty4 = isNonEmpty3;
var intersect2 = intersect;
var size14 = size13;
var union9 = union8;
var after2 = after;
var before2 = before;

// ../node_modules/effect/dist/esm/internal/schedule/intervals.js
var IntervalsSymbolKey = "effect/ScheduleIntervals";
var IntervalsTypeId = Symbol.for(IntervalsSymbolKey);
var make52 = (intervals) => {
  return {
    [IntervalsTypeId]: IntervalsTypeId,
    intervals
  };
};
var empty36 = make52(empty5());
var fromIterable14 = (intervals) => Array.from(intervals).reduce((intervals2, interval) => pipe(intervals2, union10(make52(of2(interval)))), empty36);
var union10 = dual(2, (self, that) => {
  if (!isNonEmpty2(that.intervals)) {
    return self;
  }
  if (!isNonEmpty2(self.intervals)) {
    return that;
  }
  if (headNonEmpty2(self.intervals).startMillis < headNonEmpty2(that.intervals).startMillis) {
    return unionLoop(tailNonEmpty2(self.intervals), that.intervals, headNonEmpty2(self.intervals), empty5());
  }
  return unionLoop(self.intervals, tailNonEmpty2(that.intervals), headNonEmpty2(that.intervals), empty5());
});
var unionLoop = (_self, _that, _interval, _acc) => {
  let self = _self;
  let that = _that;
  let interval = _interval;
  let acc = _acc;
  while (isNonEmpty2(self) || isNonEmpty2(that)) {
    if (!isNonEmpty2(self) && isNonEmpty2(that)) {
      if (interval.endMillis < headNonEmpty2(that).startMillis) {
        acc = pipe(acc, prepend2(interval));
        interval = headNonEmpty2(that);
        that = tailNonEmpty2(that);
        self = empty5();
      } else {
        interval = make51(interval.startMillis, headNonEmpty2(that).endMillis);
        that = tailNonEmpty2(that);
        self = empty5();
      }
    } else if (isNonEmpty2(self) && isEmpty(that)) {
      if (interval.endMillis < headNonEmpty2(self).startMillis) {
        acc = pipe(acc, prepend2(interval));
        interval = headNonEmpty2(self);
        that = empty5();
        self = tailNonEmpty2(self);
      } else {
        interval = make51(interval.startMillis, headNonEmpty2(self).endMillis);
        that = empty5();
        self = tailNonEmpty2(self);
      }
    } else if (isNonEmpty2(self) && isNonEmpty2(that)) {
      if (headNonEmpty2(self).startMillis < headNonEmpty2(that).startMillis) {
        if (interval.endMillis < headNonEmpty2(self).startMillis) {
          acc = pipe(acc, prepend2(interval));
          interval = headNonEmpty2(self);
          self = tailNonEmpty2(self);
        } else {
          interval = make51(interval.startMillis, headNonEmpty2(self).endMillis);
          self = tailNonEmpty2(self);
        }
      } else if (interval.endMillis < headNonEmpty2(that).startMillis) {
        acc = pipe(acc, prepend2(interval));
        interval = headNonEmpty2(that);
        that = tailNonEmpty2(that);
      } else {
        interval = make51(interval.startMillis, headNonEmpty2(that).endMillis);
        that = tailNonEmpty2(that);
      }
    } else {
      throw new Error(getBugErrorMessage("Intervals.unionLoop"));
    }
  }
  return make52(pipe(acc, prepend2(interval), reverse2));
};
var intersect3 = dual(2, (self, that) => intersectLoop(self.intervals, that.intervals, empty5()));
var intersectLoop = (_left, _right, _acc) => {
  let left2 = _left;
  let right2 = _right;
  let acc = _acc;
  while (isNonEmpty2(left2) && isNonEmpty2(right2)) {
    const interval = pipe(headNonEmpty2(left2), intersect2(headNonEmpty2(right2)));
    const intervals = isEmpty11(interval) ? acc : pipe(acc, prepend2(interval));
    if (pipe(headNonEmpty2(left2), lessThan9(headNonEmpty2(right2)))) {
      left2 = tailNonEmpty2(left2);
    } else {
      right2 = tailNonEmpty2(right2);
    }
    acc = intervals;
  }
  return make52(reverse2(acc));
};
var start = (self) => {
  return pipe(self.intervals, head2, getOrElse(() => empty35)).startMillis;
};
var end = (self) => {
  return pipe(self.intervals, head2, getOrElse(() => empty35)).endMillis;
};
var lessThan10 = dual(2, (self, that) => start(self) < start(that));
var isNonEmpty5 = (self) => {
  return isNonEmpty2(self.intervals);
};
var max7 = dual(2, (self, that) => lessThan10(self, that) ? that : self);

// ../node_modules/effect/dist/esm/ScheduleIntervals.js
var IntervalsTypeId2 = IntervalsTypeId;
var make53 = make52;
var empty37 = empty36;
var fromIterable15 = fromIterable14;
var union11 = union10;
var intersect4 = intersect3;
var start2 = start;
var end2 = end;
var lessThan11 = lessThan10;
var isNonEmpty6 = isNonEmpty5;
var max8 = max7;

// ../node_modules/effect/dist/esm/internal/schedule/decision.js
var OP_CONTINUE = "Continue";
var OP_DONE2 = "Done";
var _continue = (intervals) => {
  return {
    _tag: OP_CONTINUE,
    intervals
  };
};
var continueWith = (interval) => {
  return {
    _tag: OP_CONTINUE,
    intervals: make53(of2(interval))
  };
};
var done6 = {
  _tag: OP_DONE2
};
var isContinue = (self) => {
  return self._tag === OP_CONTINUE;
};
var isDone4 = (self) => {
  return self._tag === OP_DONE2;
};

// ../node_modules/effect/dist/esm/ScheduleDecision.js
var _continue2 = _continue;
var continueWith2 = continueWith;
var done7 = done6;
var isContinue2 = isContinue;
var isDone5 = isDone4;

// ../node_modules/effect/dist/esm/Scope.js
var Scope_exports = {};
__export(Scope_exports, {
  CloseableScopeTypeId: () => CloseableScopeTypeId2,
  Scope: () => Scope,
  ScopeTypeId: () => ScopeTypeId2,
  addFinalizer: () => addFinalizer2,
  addFinalizerExit: () => addFinalizerExit,
  close: () => close,
  extend: () => extend2,
  fork: () => fork2,
  make: () => make54,
  use: () => use
});
var ScopeTypeId2 = ScopeTypeId;
var CloseableScopeTypeId2 = CloseableScopeTypeId;
var Scope = scopeTag;
var addFinalizer2 = scopeAddFinalizer;
var addFinalizerExit = scopeAddFinalizerExit;
var close = scopeClose;
var extend2 = scopeExtend;
var fork2 = scopeFork;
var use = scopeUse;
var make54 = scopeMake;

// ../node_modules/effect/dist/esm/Cron.js
var Cron_exports = {};
__export(Cron_exports, {
  Equivalence: () => Equivalence5,
  ParseErrorTypeId: () => ParseErrorTypeId,
  TypeId: () => TypeId14,
  equals: () => equals4,
  isCron: () => isCron,
  isParseError: () => isParseError,
  make: () => make55,
  match: () => match14,
  next: () => next2,
  parse: () => parse,
  sequence: () => sequence
});
var TypeId14 = Symbol.for("effect/Cron");
var CronProto = {
  [TypeId14]: TypeId14,
  [symbol3](that) {
    return isCron(that) && equals4(this, that);
  },
  [symbol2]() {
    return pipe(array2(fromIterable(this.minutes)), combine(array2(fromIterable(this.hours))), combine(array2(fromIterable(this.days))), combine(array2(fromIterable(this.months))), combine(array2(fromIterable(this.weekdays))), cached(this));
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Cron",
      minutes: fromIterable(this.minutes),
      hours: fromIterable(this.hours),
      days: fromIterable(this.days),
      months: fromIterable(this.months),
      weekdays: fromIterable(this.weekdays)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isCron = (u) => hasProperty(u, TypeId14);
var make55 = ({
  days: days2,
  hours: hours2,
  minutes: minutes2,
  months,
  weekdays
}) => {
  const o = Object.create(CronProto);
  o.minutes = new Set(sort(minutes2, Order));
  o.hours = new Set(sort(hours2, Order));
  o.days = new Set(sort(days2, Order));
  o.months = new Set(sort(months, Order));
  o.weekdays = new Set(sort(weekdays, Order));
  return o;
};
var ParseErrorTypeId = Symbol.for("effect/Cron/errors/ParseError");
var ParseErrorProto = {
  _tag: "ParseError",
  [ParseErrorTypeId]: ParseErrorTypeId
};
var ParseError = (message, input) => {
  const o = Object.create(ParseErrorProto);
  o.message = message;
  if (input !== void 0) {
    o.input = input;
  }
  return o;
};
var isParseError = (u) => hasProperty(u, ParseErrorTypeId);
var parse = (cron3) => {
  const segments = cron3.split(" ").filter(isNonEmpty);
  if (segments.length !== 5) {
    return left(ParseError(`Invalid number of segments in cron expression`, cron3));
  }
  const [minutes2, hours2, days2, months, weekdays] = segments;
  return all({
    minutes: parseSegment(minutes2, minuteOptions),
    hours: parseSegment(hours2, hourOptions),
    days: parseSegment(days2, dayOptions),
    months: parseSegment(months, monthOptions),
    weekdays: parseSegment(weekdays, weekdayOptions)
  }).pipe(map((segments2) => make55(segments2)));
};
var match14 = (cron3, date4) => {
  const {
    days: days2,
    hours: hours2,
    minutes: minutes2,
    months,
    weekdays
  } = cron3;
  const minute = date4.getMinutes();
  if (minutes2.size !== 0 && !minutes2.has(minute)) {
    return false;
  }
  const hour = date4.getHours();
  if (hours2.size !== 0 && !hours2.has(hour)) {
    return false;
  }
  const month = date4.getMonth() + 1;
  if (months.size !== 0 && !months.has(month)) {
    return false;
  }
  if (days2.size === 0 && weekdays.size === 0) {
    return true;
  }
  const day = date4.getDate();
  if (weekdays.size === 0) {
    return days2.has(day);
  }
  const weekday = date4.getDay();
  if (days2.size === 0) {
    return weekdays.has(weekday);
  }
  return days2.has(day) || weekdays.has(weekday);
};
var next2 = (cron3, now) => {
  const {
    days: days2,
    hours: hours2,
    minutes: minutes2,
    months,
    weekdays
  } = cron3;
  const restrictMinutes = minutes2.size !== 0;
  const restrictHours = hours2.size !== 0;
  const restrictDays = days2.size !== 0;
  const restrictMonths = months.size !== 0;
  const restrictWeekdays = weekdays.size !== 0;
  const current2 = now ? new Date(now.getTime()) : /* @__PURE__ */ new Date();
  current2.setMinutes(current2.getMinutes() + 1);
  current2.setSeconds(0);
  current2.setMilliseconds(0);
  const limit = new Date(current2).setFullYear(current2.getFullYear() + 8);
  while (current2.getTime() <= limit) {
    if (restrictMonths && !months.has(current2.getMonth() + 1)) {
      current2.setMonth(current2.getMonth() + 1);
      current2.setDate(1);
      current2.setHours(0);
      current2.setMinutes(0);
      continue;
    }
    if (restrictDays && restrictWeekdays) {
      if (!days2.has(current2.getDate()) && !weekdays.has(current2.getDay())) {
        current2.setDate(current2.getDate() + 1);
        current2.setHours(0);
        current2.setMinutes(0);
        continue;
      }
    } else if (restrictDays) {
      if (!days2.has(current2.getDate())) {
        current2.setDate(current2.getDate() + 1);
        current2.setHours(0);
        current2.setMinutes(0);
        continue;
      }
    } else if (restrictWeekdays) {
      if (!weekdays.has(current2.getDay())) {
        current2.setDate(current2.getDate() + 1);
        current2.setHours(0);
        current2.setMinutes(0);
        continue;
      }
    }
    if (restrictHours && !hours2.has(current2.getHours())) {
      current2.setHours(current2.getHours() + 1);
      current2.setMinutes(0);
      continue;
    }
    if (restrictMinutes && !minutes2.has(current2.getMinutes())) {
      current2.setMinutes(current2.getMinutes() + 1);
      continue;
    }
    return current2;
  }
  throw new Error("Unable to find next cron date");
};
var sequence = function* (cron3, now) {
  while (true) {
    yield now = next2(cron3, now);
  }
};
var Equivalence5 = make((self, that) => restrictionsEquals(self.minutes, that.minutes) && restrictionsEquals(self.hours, that.hours) && restrictionsEquals(self.days, that.days) && restrictionsEquals(self.months, that.months) && restrictionsEquals(self.weekdays, that.weekdays));
var restrictionsArrayEquals = array(number);
var restrictionsEquals = (self, that) => restrictionsArrayEquals(fromIterable(self), fromIterable(that));
var equals4 = dual(2, (self, that) => Equivalence5(self, that));
var minuteOptions = {
  segment: "minute",
  min: 0,
  max: 59
};
var hourOptions = {
  segment: "hour",
  min: 0,
  max: 23
};
var dayOptions = {
  segment: "day",
  min: 1,
  max: 31
};
var monthOptions = {
  segment: "month",
  min: 1,
  max: 12,
  aliases: {
    jan: 1,
    feb: 2,
    mar: 3,
    apr: 4,
    may: 5,
    jun: 6,
    jul: 7,
    aug: 8,
    sep: 9,
    oct: 10,
    nov: 11,
    dec: 12
  }
};
var weekdayOptions = {
  segment: "weekday",
  min: 0,
  max: 6,
  aliases: {
    sun: 0,
    mon: 1,
    tue: 2,
    wed: 3,
    thu: 4,
    fri: 5,
    sat: 6
  }
};
var parseSegment = (input, options) => {
  const capacity10 = options.max - options.min + 1;
  const values13 = /* @__PURE__ */ new Set();
  const fields = input.split(",");
  for (const field of fields) {
    const [raw, step4] = splitStep(field);
    if (raw === "*" && step4 === void 0) {
      return right(/* @__PURE__ */ new Set());
    }
    if (step4 !== void 0) {
      if (!Number.isInteger(step4)) {
        return left(ParseError(`Expected step value to be a positive integer`, input));
      }
      if (step4 < 1) {
        return left(ParseError(`Expected step value to be greater than 0`, input));
      }
      if (step4 > options.max) {
        return left(ParseError(`Expected step value to be less than ${options.max}`, input));
      }
    }
    if (raw === "*") {
      for (let i = options.min; i <= options.max; i += step4 ?? 1) {
        values13.add(i);
      }
    } else {
      const [left2, right2] = splitRange(raw, options.aliases);
      if (!Number.isInteger(left2)) {
        return left(ParseError(`Expected a positive integer`, input));
      }
      if (left2 < options.min || left2 > options.max) {
        return left(ParseError(`Expected a value between ${options.min} and ${options.max}`, input));
      }
      if (right2 === void 0) {
        values13.add(left2);
      } else {
        if (!Number.isInteger(right2)) {
          return left(ParseError(`Expected a positive integer`, input));
        }
        if (right2 < options.min || right2 > options.max) {
          return left(ParseError(`Expected a value between ${options.min} and ${options.max}`, input));
        }
        if (left2 > right2) {
          return left(ParseError(`Invalid value range`, input));
        }
        for (let i = left2; i <= right2; i += step4 ?? 1) {
          values13.add(i);
        }
      }
    }
    if (values13.size >= capacity10) {
      return right(/* @__PURE__ */ new Set());
    }
  }
  return right(values13);
};
var splitStep = (input) => {
  const seperator = input.indexOf("/");
  if (seperator !== -1) {
    return [input.slice(0, seperator), Number(input.slice(seperator + 1))];
  }
  return [input, void 0];
};
var splitRange = (input, aliases) => {
  const seperator = input.indexOf("-");
  if (seperator !== -1) {
    return [aliasOrValue(input.slice(0, seperator), aliases), aliasOrValue(input.slice(seperator + 1), aliases)];
  }
  return [aliasOrValue(input, aliases), void 0];
};
function aliasOrValue(field, aliases) {
  return (aliases == null ? void 0 : aliases[field.toLocaleLowerCase()]) ?? Number(field);
}

// ../node_modules/effect/dist/esm/Random.js
var Random_exports = {};
__export(Random_exports, {
  Random: () => Random,
  RandomTypeId: () => RandomTypeId2,
  next: () => next3,
  nextBoolean: () => nextBoolean2,
  nextInt: () => nextInt2,
  nextIntBetween: () => nextIntBetween2,
  nextRange: () => nextRange2,
  randomWith: () => randomWith2,
  shuffle: () => shuffle2
});
var RandomTypeId2 = RandomTypeId;
var next3 = next;
var nextInt2 = nextInt;
var nextBoolean2 = nextBoolean;
var nextRange2 = nextRange;
var nextIntBetween2 = nextIntBetween;
var shuffle2 = shuffle;
var randomWith2 = randomWith;
var Random = randomTag;

// ../node_modules/effect/dist/esm/internal/schedule.js
var ScheduleSymbolKey = "effect/Schedule";
var ScheduleTypeId = Symbol.for(ScheduleSymbolKey);
var isSchedule = (u) => hasProperty(u, ScheduleTypeId);
var ScheduleDriverSymbolKey = "effect/ScheduleDriver";
var ScheduleDriverTypeId = Symbol.for(ScheduleDriverSymbolKey);
var scheduleVariance = {
  /* c8 ignore next */
  _Out: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var scheduleDriverVariance = {
  /* c8 ignore next */
  _Out: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var _a42;
var ScheduleImpl = class {
  constructor(initial, step4) {
    __publicField(this, "initial");
    __publicField(this, "step");
    __publicField(this, _a42, scheduleVariance);
    this.initial = initial;
    this.step = step4;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
_a42 = ScheduleTypeId;
var _a43;
var ScheduleDriverImpl = class {
  constructor(schedule4, ref) {
    __publicField(this, "schedule");
    __publicField(this, "ref");
    __publicField(this, _a43, scheduleDriverVariance);
    this.schedule = schedule4;
    this.ref = ref;
  }
  get state() {
    return map11(get10(this.ref), (tuple4) => tuple4[1]);
  }
  get last() {
    return flatMap10(get10(this.ref), ([element, _]) => {
      switch (element._tag) {
        case "None": {
          return failSync(() => new NoSuchElementException());
        }
        case "Some": {
          return succeed(element.value);
        }
      }
    });
  }
  get reset() {
    return set5(this.ref, [none2(), this.schedule.initial]);
  }
  next(input) {
    return pipe(map11(get10(this.ref), (tuple4) => tuple4[1]), flatMap10((state) => pipe(currentTimeMillis2, flatMap10((now) => pipe(suspend(() => this.schedule.step(now, input, state)), flatMap10(([state2, out, decision]) => {
      const setState = set5(this.ref, [some2(out), state2]);
      if (isDone5(decision)) {
        return zipRight(setState, fail2(none2()));
      }
      const millis2 = start2(decision.intervals) - now;
      if (millis2 <= 0) {
        return as2(setState, out);
      }
      return pipe(setState, zipRight(sleep3(millis(millis2))), as2(out));
    }))))));
  }
};
_a43 = ScheduleDriverTypeId;
var makeWithState = (initial, step4) => new ScheduleImpl(initial, step4);
var addDelay = dual(2, (self, f) => addDelayEffect(self, (out) => sync(() => f(out))));
var addDelayEffect = dual(2, (self, f) => modifyDelayEffect(self, (out, duration5) => map11(f(out), (delay3) => sum3(duration5, decode(delay3)))));
var andThen7 = dual(2, (self, that) => map19(andThenEither(self, that), merge));
var andThenEither = dual(2, (self, that) => makeWithState([self.initial, that.initial, true], (now, input, state) => state[2] ? flatMap10(self.step(now, input, state[0]), ([lState, out, decision]) => {
  if (isDone5(decision)) {
    return map11(that.step(now, input, state[1]), ([rState, out2, decision2]) => [[lState, rState, false], right(out2), decision2]);
  }
  return succeed([[lState, state[1], true], left(out), decision]);
}) : map11(that.step(now, input, state[1]), ([rState, out, decision]) => [[state[0], rState, false], right(out), decision])));
var as5 = dual(2, (self, out) => map19(self, () => out));
var asVoid3 = (self) => map19(self, constVoid);
var bothInOut = dual(2, (self, that) => makeWithState([self.initial, that.initial], (now, [in1, in2], state) => zipWith3(self.step(now, in1, state[0]), that.step(now, in2, state[1]), ([lState, out, lDecision], [rState, out2, rDecision]) => {
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    const interval = pipe(lDecision.intervals, union11(rDecision.intervals));
    return [[lState, rState], [out, out2], _continue2(interval)];
  }
  return [[lState, rState], [out, out2], done7];
})));
var check = dual(2, (self, test3) => checkEffect(self, (input, out) => sync(() => test3(input, out))));
var checkEffect = dual(2, (self, test3) => makeWithState(self.initial, (now, input, state) => flatMap10(self.step(now, input, state), ([state2, out, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, out, done7]);
  }
  return map11(test3(input, out), (cont) => cont ? [state2, out, decision] : [state2, out, done7]);
})));
var collectAllInputs = () => collectAllOutputs(identity2());
var collectAllOutputs = (self) => reduce14(self, empty5(), (outs, out) => pipe(outs, append2(out)));
var collectUntil = (f) => collectAllOutputs(recurUntil(f));
var collectUntilEffect = (f) => collectAllOutputs(recurUntilEffect(f));
var collectWhile = (f) => collectAllOutputs(recurWhile(f));
var collectWhileEffect = (f) => collectAllOutputs(recurWhileEffect(f));
var compose = dual(2, (self, that) => makeWithState([self.initial, that.initial], (now, input, state) => flatMap10(self.step(now, input, state[0]), ([lState, out, lDecision]) => map11(that.step(now, out, state[1]), ([rState, out2, rDecision]) => isDone5(lDecision) ? [[lState, rState], out2, done7] : isDone5(rDecision) ? [[lState, rState], out2, done7] : [[lState, rState], out2, _continue2(pipe(lDecision.intervals, max8(rDecision.intervals)))]))));
var mapInput5 = dual(2, (self, f) => mapInputEffect(self, (input2) => sync(() => f(input2))));
var mapInputContext2 = dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => mapInputContext(self.step(now, input, state), f)));
var mapInputEffect = dual(2, (self, f) => makeWithState(self.initial, (now, input2, state) => flatMap10(f(input2), (input) => self.step(now, input, state))));
var cron = (expression) => {
  const parsed = isCron(expression) ? right(expression) : parse(expression);
  return makeWithState([true, [Number.MIN_SAFE_INTEGER, 0, 0]], (now, _, [initial, previous2]) => {
    if (now < previous2[0]) {
      return succeed([[false, previous2], [previous2[1], previous2[2]], continueWith2(make51(previous2[1], previous2[2]))]);
    }
    if (isLeft(parsed)) {
      return die2(parsed.left);
    }
    const cron3 = parsed.right;
    const date4 = new Date(now);
    let next6;
    if (initial && match14(cron3, date4)) {
      next6 = now;
    } else {
      const result = next2(cron3, date4);
      next6 = result.getTime();
    }
    const start5 = beginningOfMinute(next6);
    const end7 = endOfMinute(next6);
    const interval = make51(start5, end7);
    return succeed([[false, [next6, start5, end7]], [start5, end7], continueWith2(interval)]);
  });
};
var dayOfMonth = (day) => {
  return makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state) => {
    if (!Number.isInteger(day) || day < 1 || 31 < day) {
      return dieSync(() => new IllegalArgumentException(`Invalid argument in: dayOfMonth(${day}). Must be in range 1...31`));
    }
    const n = state[1];
    const initial = n === 0;
    const day0 = nextDayOfMonth(now, day, initial);
    const start5 = beginningOfDay(day0);
    const end7 = endOfDay(day0);
    const interval = make51(start5, end7);
    return succeed([[end7, n + 1], n, continueWith2(interval)]);
  });
};
var dayOfWeek = (day) => {
  return makeWithState([Number.MIN_SAFE_INTEGER, 0], (now, _, state) => {
    if (!Number.isInteger(day) || day < 1 || 7 < day) {
      return dieSync(() => new IllegalArgumentException(`Invalid argument in: dayOfWeek(${day}). Must be in range 1 (Monday)...7 (Sunday)`));
    }
    const n = state[1];
    const initial = n === 0;
    const day0 = nextDay(now, day, initial);
    const start5 = beginningOfDay(day0);
    const end7 = endOfDay(day0);
    const interval = make51(start5, end7);
    return succeed([[end7, n + 1], n, continueWith2(interval)]);
  });
};
var delayed = dual(2, (self, f) => delayedEffect(self, (duration5) => sync(() => f(duration5))));
var delayedEffect = dual(2, (self, f) => modifyDelayEffect(self, (_, delay3) => f(delay3)));
var delayedSchedule = (schedule4) => addDelay(schedule4, (x) => x);
var delays = (self) => makeWithState(self.initial, (now, input, state) => pipe(self.step(now, input, state), flatMap10(([state2, _, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, zero2, decision]);
  }
  return succeed([state2, millis(start2(decision.intervals) - now), decision]);
})));
var mapBoth3 = dual(2, (self, {
  onInput,
  onOutput
}) => map19(mapInput5(self, onInput), onOutput));
var mapBothEffect = dual(2, (self, {
  onInput,
  onOutput
}) => mapEffect3(mapInputEffect(self, onInput), onOutput));
var driver = (self) => pipe(make35([none2(), self.initial]), map11((ref) => new ScheduleDriverImpl(self, ref)));
var duration = (durationInput) => {
  const duration5 = decode(durationInput);
  const durationMillis = toMillis(duration5);
  return makeWithState(true, (now, _, state) => succeed(state ? [false, duration5, continueWith2(after2(now + durationMillis))] : [false, zero2, done7]));
};
var either4 = dual(2, (self, that) => union12(self, that));
var eitherWith = dual(3, (self, that, f) => unionWith(self, that, f));
var ensuring2 = dual(2, (self, finalizer3) => makeWithState(self.initial, (now, input, state) => flatMap10(self.step(now, input, state), ([state2, out, decision]) => isDone5(decision) ? as2(finalizer3, [state2, out, decision]) : succeed([state2, out, decision]))));
var exponential2 = (baseInput, factor = 2) => {
  const base = decode(baseInput);
  return delayedSchedule(map19(forever2, (i) => times(base, Math.pow(factor, i))));
};
var fibonacci = (oneInput) => {
  const one = decode(oneInput);
  return delayedSchedule(pipe(unfold2([one, one], ([a, b]) => [b, sum3(a, b)]), map19((out) => out[0])));
};
var fixed = (intervalInput) => {
  const interval = decode(intervalInput);
  const intervalMillis = toMillis(interval);
  return makeWithState([none2(), 0], (now, _, [option9, n]) => sync(() => {
    switch (option9._tag) {
      case "None": {
        return [[some2([now, now + intervalMillis]), n + 1], n, continueWith2(after2(now + intervalMillis))];
      }
      case "Some": {
        const [startMillis, lastRun] = option9.value;
        const runningBehind = now > lastRun + intervalMillis;
        const boundary = equals(interval, zero2) ? interval : millis(intervalMillis - (now - startMillis) % intervalMillis);
        const sleepTime = equals(boundary, zero2) ? interval : boundary;
        const nextRun = runningBehind ? now : now + toMillis(sleepTime);
        return [[some2([startMillis, nextRun]), n + 1], n, continueWith2(after2(nextRun))];
      }
    }
  }));
};
var fromDelay = (delay3) => duration(delay3);
var fromDelays = (delay3, ...delays3) => makeWithState([[delay3, ...delays3].map((_) => decode(_)), true], (now, _, [durations, cont]) => sync(() => {
  if (cont) {
    const x = durations[0];
    const interval = after2(now + toMillis(x));
    if (durations.length >= 2) {
      return [[durations.slice(1), true], x, continueWith2(interval)];
    }
    const y = durations.slice(1);
    return [[[x, ...y], false], x, continueWith2(interval)];
  }
  return [[durations, false], zero2, done7];
}));
var fromFunction = (f) => map19(identity2(), f);
var hourOfDay = (hour) => makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state) => {
  if (!Number.isInteger(hour) || hour < 0 || 23 < hour) {
    return dieSync(() => new IllegalArgumentException(`Invalid argument in: hourOfDay(${hour}). Must be in range 0...23`));
  }
  const n = state[1];
  const initial = n === 0;
  const hour0 = nextHour(now, hour, initial);
  const start5 = beginningOfHour(hour0);
  const end7 = endOfHour(hour0);
  const interval = make51(start5, end7);
  return succeed([[end7, n + 1], n, continueWith2(interval)]);
});
var identity2 = () => makeWithState(void 0, (now, input, state) => succeed([state, input, continueWith2(after2(now))]));
var intersect5 = dual(2, (self, that) => intersectWith(self, that, intersect4));
var intersectWith = dual(3, (self, that, f) => makeWithState([self.initial, that.initial], (now, input, state) => pipe(zipWith3(self.step(now, input, state[0]), that.step(now, input, state[1]), (a, b) => [a, b]), flatMap10(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    return intersectWithLoop(self, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);
  }
  return succeed([[lState, rState], [out, out2], done7]);
}))));
var intersectWithLoop = (self, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {
  const combined = f(lInterval, rInterval);
  if (isNonEmpty6(combined)) {
    return succeed([[lState, rState], [out, out2], _continue2(combined)]);
  }
  if (pipe(lInterval, lessThan11(rInterval))) {
    return flatMap10(self.step(end2(lInterval), input, lState), ([lState2, out3, decision]) => {
      if (isDone5(decision)) {
        return succeed([[lState2, rState], [out3, out2], done7]);
      }
      return intersectWithLoop(self, that, input, lState2, out3, decision.intervals, rState, out2, rInterval, f);
    });
  }
  return flatMap10(that.step(end2(rInterval), input, rState), ([rState2, out22, decision]) => {
    if (isDone5(decision)) {
      return succeed([[lState, rState2], [out, out22], done7]);
    }
    return intersectWithLoop(self, that, input, lState, out, lInterval, rState2, out22, decision.intervals, f);
  });
};
var jittered = (self) => jitteredWith(self, {
  min: 0.8,
  max: 1.2
});
var jitteredWith = dual(2, (self, options) => {
  const {
    max: max9,
    min: min7
  } = Object.assign({
    min: 0.8,
    max: 1.2
  }, options);
  return delayedEffect(self, (duration5) => map11(next3, (random4) => {
    const d = toMillis(duration5);
    const jittered3 = d * min7 * (1 - random4) + d * max9 * random4;
    return millis(jittered3);
  }));
});
var linear2 = (baseInput) => {
  const base = decode(baseInput);
  return delayedSchedule(map19(forever2, (i) => times(base, i + 1)));
};
var map19 = dual(2, (self, f) => mapEffect3(self, (out) => sync(() => f(out))));
var mapEffect3 = dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => flatMap10(self.step(now, input, state), ([state2, out, decision]) => map11(f(out), (out2) => [state2, out2, decision]))));
var minuteOfHour = (minute) => makeWithState([Number.MIN_SAFE_INTEGER, 0], (now, _, state) => {
  if (!Number.isInteger(minute) || minute < 0 || 59 < minute) {
    return dieSync(() => new IllegalArgumentException(`Invalid argument in: minuteOfHour(${minute}). Must be in range 0...59`));
  }
  const n = state[1];
  const initial = n === 0;
  const minute0 = nextMinute(now, minute, initial);
  const start5 = beginningOfMinute(minute0);
  const end7 = endOfMinute(minute0);
  const interval = make51(start5, end7);
  return succeed([[end7, n + 1], n, continueWith2(interval)]);
});
var modifyDelay = dual(2, (self, f) => modifyDelayEffect(self, (out, duration5) => sync(() => f(out, duration5))));
var modifyDelayEffect = dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => flatMap10(self.step(now, input, state), ([state2, out, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, out, decision]);
  }
  const intervals = decision.intervals;
  const delay3 = size14(make51(now, start2(intervals)));
  return map11(f(out, delay3), (durationInput) => {
    const duration5 = decode(durationInput);
    const oldStart = start2(intervals);
    const newStart = now + toMillis(duration5);
    const delta = newStart - oldStart;
    const newEnd = Math.min(Math.max(0, end2(intervals) + delta), Number.MAX_SAFE_INTEGER);
    const newInterval = make51(newStart, newEnd);
    return [state2, out, continueWith2(newInterval)];
  });
})));
var onDecision = dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => flatMap10(self.step(now, input, state), ([state2, out, decision]) => as2(f(out, decision), [state2, out, decision]))));
var passthrough = (self) => makeWithState(self.initial, (now, input, state) => pipe(self.step(now, input, state), map11(([state2, _, decision]) => [state2, input, decision])));
var provideContext2 = dual(2, (self, context13) => makeWithState(self.initial, (now, input, state) => provideContext(self.step(now, input, state), context13)));
var provideService2 = dual(3, (self, tag4, service3) => makeWithState(self.initial, (now, input, state) => contextWithEffect((env) => provideContext(
  // @ts-expect-error
  self.step(now, input, state),
  add2(env, tag4, service3)
))));
var recurUntil = (f) => untilInput(identity2(), f);
var recurUntilEffect = (f) => untilInputEffect(identity2(), f);
var recurUntilOption = (pf) => untilOutput(map19(identity2(), pf), isSome);
var recurUpTo = (durationInput) => {
  const duration5 = decode(durationInput);
  return whileOutput(elapsed, (elapsed3) => lessThan4(elapsed3, duration5));
};
var recurWhile = (f) => whileInput(identity2(), f);
var recurWhileEffect = (f) => whileInputEffect(identity2(), f);
var recurs = (n) => whileOutput(forever2, (out) => out < n);
var reduce14 = dual(3, (self, zero3, f) => reduceEffect2(self, zero3, (z, out) => sync(() => f(z, out))));
var reduceEffect2 = dual(3, (self, zero3, f) => makeWithState([self.initial, zero3], (now, input, [s, z]) => flatMap10(self.step(now, input, s), ([s2, out, decision]) => isDone5(decision) ? succeed([[s2, z], z, decision]) : map11(f(z, out), (z2) => [[s2, z2], z, decision]))));
var repetitions = (self) => reduce14(self, 0, (n, _) => n + 1);
var resetAfter = dual(2, (self, durationInput) => {
  const duration5 = decode(durationInput);
  return pipe(self, intersect5(elapsed), resetWhen(([, time3]) => greaterThanOrEqualTo4(time3, duration5)), map19((out) => out[0]));
});
var resetWhen = dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => flatMap10(self.step(now, input, state), ([state2, out, decision]) => f(out) ? self.step(now, input, self.initial) : succeed([state2, out, decision]))));
var run = dual(3, (self, now, input) => pipe(runLoop(self, now, fromIterable2(input), self.initial, empty5()), map11((list) => reverse2(list))));
var runLoop = (self, now, inputs, state, acc) => {
  if (!isNonEmpty2(inputs)) {
    return succeed(acc);
  }
  const input = headNonEmpty2(inputs);
  const nextInputs = tailNonEmpty2(inputs);
  return flatMap10(self.step(now, input, state), ([state2, out, decision]) => {
    if (isDone5(decision)) {
      return sync(() => pipe(acc, prepend2(out)));
    }
    return runLoop(self, start2(decision.intervals), nextInputs, state2, prepend2(acc, out));
  });
};
var secondOfMinute = (second) => makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state) => {
  if (!Number.isInteger(second) || second < 0 || 59 < second) {
    return dieSync(() => new IllegalArgumentException(`Invalid argument in: secondOfMinute(${second}). Must be in range 0...59`));
  }
  const n = state[1];
  const initial = n === 0;
  const second0 = nextSecond(now, second, initial);
  const start5 = beginningOfSecond(second0);
  const end7 = endOfSecond(second0);
  const interval = make51(start5, end7);
  return succeed([[end7, n + 1], n, continueWith2(interval)]);
});
var spaced = (duration5) => addDelay(forever2, () => duration5);
var succeed8 = (value8) => map19(forever2, () => value8);
var sync5 = (evaluate3) => map19(forever2, evaluate3);
var tapInput = dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => zipRight(f(input), self.step(now, input, state))));
var tapOutput = dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => tap(self.step(now, input, state), ([, out]) => f(out))));
var unfold2 = (initial, f) => makeWithState(initial, (now, _, state) => sync(() => [f(state), state, continueWith2(after2(now))]));
var union12 = dual(2, (self, that) => unionWith(self, that, union11));
var unionWith = dual(3, (self, that, f) => makeWithState([self.initial, that.initial], (now, input, state) => zipWith3(self.step(now, input, state[0]), that.step(now, input, state[1]), ([lState, l, lDecision], [rState, r, rDecision]) => {
  if (isDone5(lDecision) && isDone5(rDecision)) {
    return [[lState, rState], [l, r], done7];
  }
  if (isDone5(lDecision) && isContinue2(rDecision)) {
    return [[lState, rState], [l, r], _continue2(rDecision.intervals)];
  }
  if (isContinue2(lDecision) && isDone5(rDecision)) {
    return [[lState, rState], [l, r], _continue2(lDecision.intervals)];
  }
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    const combined = f(lDecision.intervals, rDecision.intervals);
    return [[lState, rState], [l, r], _continue2(combined)];
  }
  throw new Error("BUG: Schedule.unionWith - please report an issue at https://github.com/Effect-TS/effect/issues");
})));
var untilInput = dual(2, (self, f) => check(self, (input, _) => !f(input)));
var untilInputEffect = dual(2, (self, f) => checkEffect(self, (input, _) => negate2(f(input))));
var untilOutput = dual(2, (self, f) => check(self, (_, out) => !f(out)));
var untilOutputEffect = dual(2, (self, f) => checkEffect(self, (_, out) => negate2(f(out))));
var upTo = dual(2, (self, duration5) => zipLeft4(self, recurUpTo(duration5)));
var whileInput = dual(2, (self, f) => check(self, (input, _) => f(input)));
var whileInputEffect = dual(2, (self, f) => checkEffect(self, (input, _) => f(input)));
var whileOutput = dual(2, (self, f) => check(self, (_, out) => f(out)));
var whileOutputEffect = dual(2, (self, f) => checkEffect(self, (_, out) => f(out)));
var windowed = (intervalInput) => {
  const interval = decode(intervalInput);
  const millis2 = toMillis(interval);
  return makeWithState([none2(), 0], (now, _, [option9, n]) => {
    switch (option9._tag) {
      case "None": {
        return succeed([[some2(now), n + 1], n, continueWith2(after2(now + millis2))]);
      }
      case "Some": {
        return succeed([[some2(option9.value), n + 1], n, continueWith2(after2(now + (millis2 - (now - option9.value) % millis2)))]);
      }
    }
  });
};
var zipLeft4 = dual(2, (self, that) => map19(intersect5(self, that), (out) => out[0]));
var zipRight4 = dual(2, (self, that) => map19(intersect5(self, that), (out) => out[1]));
var zipWith5 = dual(3, (self, that, f) => map19(intersect5(self, that), ([out, out2]) => f(out, out2)));
var beginningOfSecond = (now) => {
  const date4 = new Date(now);
  return new Date(date4.getFullYear(), date4.getMonth(), date4.getDate(), date4.getHours(), date4.getMinutes(), date4.getSeconds(), 0).getTime();
};
var endOfSecond = (now) => {
  const date4 = new Date(beginningOfSecond(now));
  return date4.setSeconds(date4.getSeconds() + 1);
};
var nextSecond = (now, second, initial) => {
  const date4 = new Date(now);
  if (date4.getSeconds() === second && initial) {
    return now;
  }
  if (date4.getSeconds() < second) {
    return date4.setSeconds(second);
  }
  const newDate = new Date(date4.setSeconds(second));
  return newDate.setTime(newDate.getTime() + 1e3 * 60);
};
var beginningOfMinute = (now) => {
  const date4 = new Date(now);
  return new Date(date4.getFullYear(), date4.getMonth(), date4.getDate(), date4.getHours(), date4.getMinutes(), 0, 0).getTime();
};
var endOfMinute = (now) => {
  const date4 = new Date(beginningOfMinute(now));
  return date4.setMinutes(date4.getMinutes() + 1);
};
var nextMinute = (now, minute, initial) => {
  const date4 = new Date(now);
  if (date4.getMinutes() === minute && initial) {
    return now;
  }
  if (date4.getMinutes() < minute) {
    return date4.setMinutes(minute);
  }
  const newDate = new Date(date4.setMinutes(minute));
  return newDate.setTime(newDate.getTime() + 1e3 * 60 * 60);
};
var beginningOfHour = (now) => {
  const date4 = new Date(now);
  return new Date(date4.getFullYear(), date4.getMonth(), date4.getDate(), date4.getHours(), 0, 0, 0).getTime();
};
var endOfHour = (now) => {
  const date4 = new Date(beginningOfHour(now));
  return date4.setHours(date4.getHours() + 1);
};
var nextHour = (now, hour, initial) => {
  const date4 = new Date(now);
  if (date4.getHours() === hour && initial) {
    return now;
  }
  if (date4.getHours() < hour) {
    return date4.setHours(hour);
  }
  const newDate = new Date(date4.setHours(hour));
  return newDate.setTime(newDate.getTime() + 1e3 * 60 * 60 * 24);
};
var beginningOfDay = (now) => {
  const date4 = new Date(now);
  return new Date(date4.getFullYear(), date4.getMonth(), date4.getDate(), 0, 0, 0, 0).getTime();
};
var endOfDay = (now) => {
  const date4 = new Date(beginningOfDay(now));
  return date4.setDate(date4.getDate() + 1);
};
var nextDay = (now, dayOfWeek3, initial) => {
  const date4 = new Date(now);
  if (date4.getDay() === dayOfWeek3 && initial) {
    return now;
  }
  const nextDayOfWeek = (7 + dayOfWeek3 - date4.getDay()) % 7;
  return date4.setDate(date4.getDate() + (nextDayOfWeek === 0 ? 7 : nextDayOfWeek));
};
var nextDayOfMonth = (now, day, initial) => {
  const date4 = new Date(now);
  if (date4.getDate() === day && initial) {
    return now;
  }
  if (date4.getDate() < day) {
    return date4.setDate(day);
  }
  return findNextMonth(now, day, 1);
};
var findNextMonth = (now, day, months) => {
  const d = new Date(now);
  const tmp1 = new Date(d.setDate(day));
  const tmp2 = new Date(tmp1.setMonth(tmp1.getMonth() + months));
  if (tmp2.getDate() === day) {
    const d2 = new Date(now);
    const tmp3 = new Date(d2.setDate(day));
    return tmp3.setMonth(tmp3.getMonth() + months);
  }
  return findNextMonth(now, day, months + 1);
};
var ScheduleDefectTypeId = Symbol.for("effect/Schedule/ScheduleDefect");
var _a44;
var ScheduleDefect = class {
  constructor(error4) {
    __publicField(this, "error");
    __publicField(this, _a44);
    this.error = error4;
    this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
  }
};
_a44 = ScheduleDefectTypeId;
var isScheduleDefect = (u) => hasProperty(u, ScheduleDefectTypeId);
var scheduleDefectWrap = (self) => catchAll(self, (e) => die2(new ScheduleDefect(e)));
var scheduleDefectRefail = (self) => catchAllCause(self, (cause3) => match2(find(cause3, (_) => isDieType(_) && isScheduleDefect(_.defect) ? some2(_.defect) : none2()), {
  onNone: () => failCause(cause3),
  onSome: (error4) => fail2(error4.error)
}));
var repeat_Effect = dual(2, (self, schedule4) => repeatOrElse_Effect(self, schedule4, (e, _) => fail2(e)));
var repeat_combined = dual(2, (self, options) => {
  if (isSchedule(options)) {
    return repeat_Effect(self, options);
  }
  const base = options.schedule ?? passthrough(forever2);
  const withWhile = options.while ? whileInputEffect(base, (a) => {
    const applied = options.while(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (a) => {
    const applied = options.until(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  const withTimes = options.times ? intersect5(withUntil, recurs(options.times)) : withUntil;
  return scheduleDefectRefail(repeat_Effect(self, withTimes));
});
var repeatOrElse_Effect = dual(3, (self, schedule4, orElse22) => flatMap10(driver(schedule4), (driver3) => matchEffect(self, {
  onFailure: (error4) => orElse22(error4, none2()),
  onSuccess: (value8) => repeatOrElseEffectLoop(self, driver3, orElse22, value8)
})));
var repeatOrElseEffectLoop = (self, driver3, orElse22, value8) => {
  return matchEffect(driver3.next(value8), {
    onFailure: () => orDie(driver3.last),
    onSuccess: (b) => matchEffect(self, {
      onFailure: (error4) => orElse22(error4, some2(b)),
      onSuccess: (value9) => repeatOrElseEffectLoop(self, driver3, orElse22, value9)
    })
  });
};
var retry_Effect = dual(2, (self, policy) => retryOrElse_Effect(self, policy, (e, _) => fail2(e)));
var retry_combined = dual(2, (self, options) => {
  if (isSchedule(options)) {
    return retry_Effect(self, options);
  }
  const base = options.schedule ?? forever2;
  const withWhile = options.while ? whileInputEffect(base, (e) => {
    const applied = options.while(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (e) => {
    const applied = options.until(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  const withTimes = options.times ? intersect5(withUntil, recurs(options.times)) : withUntil;
  return scheduleDefectRefail(retry_Effect(self, withTimes));
});
var retryOrElse_Effect = dual(3, (self, policy, orElse22) => flatMap10(driver(policy), (driver3) => retryOrElse_EffectLoop(self, driver3, orElse22)));
var retryOrElse_EffectLoop = (self, driver3, orElse22) => {
  return catchAll(self, (e) => matchEffect(driver3.next(e), {
    onFailure: () => pipe(driver3.last, orDie, flatMap10((out) => orElse22(e, out))),
    onSuccess: () => retryOrElse_EffectLoop(self, driver3, orElse22)
  }));
};
var schedule_Effect = dual(2, (self, schedule4) => scheduleFrom_Effect(self, void 0, schedule4));
var scheduleFrom_Effect = dual(3, (self, initial, schedule4) => flatMap10(driver(schedule4), (driver3) => scheduleFrom_EffectLoop(self, initial, driver3)));
var scheduleFrom_EffectLoop = (self, initial, driver3) => matchEffect(driver3.next(initial), {
  onFailure: () => orDie(driver3.last),
  onSuccess: () => flatMap10(self, (a) => scheduleFrom_EffectLoop(self, a, driver3))
});
var count = unfold2(0, (n) => n + 1);
var elapsed = makeWithState(none2(), (now, _, state) => {
  switch (state._tag) {
    case "None": {
      return succeed([some2(now), zero2, continueWith2(after2(now))]);
    }
    case "Some": {
      return succeed([some2(state.value), millis(now - state.value), continueWith2(after2(now))]);
    }
  }
});
var forever2 = unfold2(0, (n) => n + 1);
var once2 = asVoid3(recurs(1));
var stop = asVoid3(recurs(0));

// ../node_modules/effect/dist/esm/internal/effect/circular.js
var Semaphore = class {
  constructor(permits) {
    __publicField(this, "permits");
    __publicField(this, "waiters", /* @__PURE__ */ new Set());
    __publicField(this, "taken", 0);
    __publicField(this, "take", (n) => async((resume2) => {
      if (this.free < n) {
        const observer = () => {
          if (this.free < n) {
            return;
          }
          this.waiters.delete(observer);
          this.taken += n;
          resume2(succeed(n));
        };
        this.waiters.add(observer);
        return sync(() => {
          this.waiters.delete(observer);
        });
      }
      this.taken += n;
      return resume2(succeed(n));
    }));
    __publicField(this, "updateTaken", (f) => withFiberRuntime((fiber) => {
      this.taken = f(this.taken);
      if (this.waiters.size > 0) {
        fiber.getFiberRef(currentScheduler).scheduleTask(() => {
          const iter = this.waiters.values();
          let item = iter.next();
          while (item.done === false && this.free > 0) {
            item.value();
            item = iter.next();
          }
        }, fiber.getFiberRef(currentSchedulingPriority));
      }
      return succeed(this.free);
    }));
    __publicField(this, "release", (n) => this.updateTaken((taken) => taken - n));
    __publicField(this, "releaseAll", this.updateTaken((_) => 0));
    __publicField(this, "withPermits", (n) => (self) => uninterruptibleMask((restore) => flatMap10(restore(this.take(n)), (permits) => ensuring(restore(self), this.release(permits)))));
    this.permits = permits;
  }
  get free() {
    return this.permits - this.taken;
  }
};
var unsafeMakeSemaphore = (permits) => new Semaphore(permits);
var makeSemaphore = (permits) => sync(() => unsafeMakeSemaphore(permits));
var awaitAllChildren = (self) => ensuringChildren(self, fiberAwaitAll);
var cached2 = dual(2, (self, timeToLive) => map11(cachedInvalidateWithTTL(self, timeToLive), (tuple4) => tuple4[0]));
var cachedInvalidateWithTTL = dual(2, (self, timeToLive) => {
  const duration5 = decode(timeToLive);
  return flatMap10(context(), (env) => map11(makeSynchronized(none2()), (cache) => [provideContext(getCachedValue(self, duration5, cache), env), invalidateCache(cache)]));
});
var computeCachedValue = (self, timeToLive, start5) => {
  const timeToLiveMillis = toMillis(decode(timeToLive));
  return pipe(deferredMake(), tap((deferred) => intoDeferred(self, deferred)), map11((deferred) => some2([start5 + timeToLiveMillis, deferred])));
};
var getCachedValue = (self, timeToLive, cache) => uninterruptibleMask((restore) => pipe(clockWith3((clock3) => clock3.currentTimeMillis), flatMap10((time3) => updateSomeAndGetEffectSynchronized(cache, (option9) => {
  switch (option9._tag) {
    case "None": {
      return some2(computeCachedValue(self, timeToLive, time3));
    }
    case "Some": {
      const [end7] = option9.value;
      return end7 - time3 <= 0 ? some2(computeCachedValue(self, timeToLive, time3)) : none2();
    }
  }
})), flatMap10((option9) => isNone(option9) ? dieMessage("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(deferredAwait(option9.value[1])))));
var invalidateCache = (cache) => set5(cache, none2());
var ensuringChild = dual(2, (self, f) => ensuringChildren(self, (children3) => f(fiberAll(children3))));
var ensuringChildren = dual(2, (self, children3) => flatMap10(track, (supervisor) => pipe(supervised(self, supervisor), ensuring(flatMap10(supervisor.value, children3)))));
var forkAll = dual((args) => isIterable(args[0]), (effects, options) => (options == null ? void 0 : options.discard) ? forEachSequentialDiscard(effects, fork) : map11(forEachSequential(effects, fork), fiberAll));
var forkIn = dual(2, (self, scope5) => uninterruptibleMask((restore) => flatMap10(scope5.fork(sequential2), (child) => pipe(restore(self), onExit((exit3) => child.close(exit3)), forkDaemon, tap((fiber) => child.addFinalizer(() => fiberIdWith((fiberId5) => equals(fiberId5, fiber.id()) ? void_ : asVoid(interruptFiber(fiber)))))))));
var forkScoped = (self) => scopeWith((scope5) => forkIn(self, scope5));
var fromFiber = (fiber) => join3(fiber);
var fromFiberEffect = (fiber) => suspend(() => flatMap10(fiber, join3));
var memoKeySymbol = Symbol.for("effect/Effect/memoizeFunction.key");
var _a45;
var Key = class {
  constructor(a, eq) {
    __publicField(this, "a");
    __publicField(this, "eq");
    __publicField(this, _a45, memoKeySymbol);
    this.a = a;
    this.eq = eq;
  }
  [(_a45 = memoKeySymbol, symbol3)](that) {
    if (hasProperty(that, memoKeySymbol)) {
      if (this.eq) {
        return this.eq(this.a, that.a);
      } else {
        return equals(this.a, that.a);
      }
    }
    return false;
  }
  [symbol2]() {
    return this.eq ? 0 : cached(this, hash(this.a));
  }
};
var cachedFunction = (f, eq) => {
  return pipe(sync(() => empty21()), flatMap10(makeSynchronized), map11((ref) => (a) => pipe(ref.modifyEffect((map43) => {
    const result = pipe(map43, get7(new Key(a, eq)));
    if (isNone(result)) {
      return pipe(deferredMake(), tap((deferred) => pipe(diffFiberRefs(f(a)), intoDeferred(deferred), fork)), map11((deferred) => [deferred, pipe(map43, set4(new Key(a, eq), deferred))]));
    }
    return succeed([result.value, map43]);
  }), flatMap10(deferredAwait), flatMap10(([patch14, b]) => pipe(patchFiberRefs(patch14), as2(b))))));
};
var raceFirst = dual(2, (self, that) => pipe(exit(self), race(exit(that)), (effect4) => flatten5(effect4)));
var scheduleForked = dual(2, (self, schedule4) => pipe(self, schedule_Effect(schedule4), forkScoped));
var supervised = dual(2, (self, supervisor) => {
  const supervise = fiberRefLocallyWith(currentSupervisor, (s) => s.zip(supervisor));
  return supervise(self);
});
var timeout = dual(2, (self, duration5) => timeoutFail(self, {
  onTimeout: () => new TimeoutException(),
  duration: duration5
}));
var timeoutFail = dual(2, (self, {
  duration: duration5,
  onTimeout
}) => flatten5(timeoutTo(self, {
  onTimeout: () => failSync(onTimeout),
  onSuccess: succeed,
  duration: duration5
})));
var timeoutFailCause = dual(2, (self, {
  duration: duration5,
  onTimeout
}) => flatten5(timeoutTo(self, {
  onTimeout: () => failCauseSync(onTimeout),
  onSuccess: succeed,
  duration: duration5
})));
var timeoutTo = dual(2, (self, {
  duration: duration5,
  onSuccess,
  onTimeout
}) => fiberIdWith((parentFiberId) => raceFibersWith(self, interruptible2(sleep3(duration5)), {
  onSelfWin: (winner, loser) => flatMap10(winner.await, (exit3) => {
    if (exit3._tag === "Success") {
      return flatMap10(winner.inheritAll, () => as2(interruptAsFiber(loser, parentFiberId), onSuccess(exit3.value)));
    } else {
      return flatMap10(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit3.cause));
    }
  }),
  onOtherWin: (winner, loser) => flatMap10(winner.await, (exit3) => {
    if (exit3._tag === "Success") {
      return flatMap10(winner.inheritAll, () => as2(interruptAsFiber(loser, parentFiberId), onTimeout()));
    } else {
      return flatMap10(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit3.cause));
    }
  }),
  otherScope: globalScope
})));
var SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
var SynchronizedTypeId = Symbol.for(SynchronizedSymbolKey);
var synchronizedVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var _a46, _b13, _c;
var SynchronizedImpl = class {
  constructor(ref, withLock3) {
    __publicField(this, "ref");
    __publicField(this, "withLock");
    __publicField(this, _a46, synchronizedVariance);
    __publicField(this, _b13, refVariance);
    __publicField(this, _c);
    __publicField(this, "get");
    this.ref = ref;
    this.withLock = withLock3;
    this[TypeId11] = TypeId11;
    this.get = get10(this.ref);
  }
  modify(f) {
    return this.modifyEffect((a) => succeed(f(a)));
  }
  modifyEffect(f) {
    return this.withLock(pipe(flatMap10(get10(this.ref), f), flatMap10(([b, a]) => as2(set5(this.ref, a), b))));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
_a46 = SynchronizedTypeId, _b13 = RefTypeId, _c = TypeId11;
var makeSynchronized = (value8) => sync(() => unsafeMakeSynchronized(value8));
var unsafeMakeSynchronized = (value8) => {
  const ref = unsafeMake7(value8);
  const sem = unsafeMakeSemaphore(1);
  return new SynchronizedImpl(ref, sem.withPermits(1));
};
var updateSomeAndGetEffectSynchronized = dual(2, (self, pf) => self.modifyEffect((value8) => {
  const result = pf(value8);
  switch (result._tag) {
    case "None": {
      return succeed([value8, value8]);
    }
    case "Some": {
      return map11(result.value, (a) => [a, a]);
    }
  }
}));
var zipFiber = dual(2, (self, that) => zipWithFiber(self, that, (a, b) => [a, b]));
var zipLeftFiber = dual(2, (self, that) => zipWithFiber(self, that, (a, _) => a));
var zipRightFiber = dual(2, (self, that) => zipWithFiber(self, that, (_, b) => b));
var zipWithFiber = dual(3, (self, that, f) => ({
  [FiberTypeId]: fiberVariance,
  id: () => pipe(self.id(), getOrElse3(that.id())),
  await: pipe(self.await, flatten5, zipWithOptions(flatten5(that.await), f, {
    concurrent: true
  }), exit),
  children: self.children,
  inheritAll: zipRight(that.inheritAll, self.inheritAll),
  poll: zipWith3(self.poll, that.poll, (optionA, optionB) => pipe(optionA, flatMap((exitA) => pipe(optionB, map2((exitB) => zipWith4(exitA, exitB, {
    onSuccess: f,
    onFailure: parallel
  })))))),
  interruptAsFork: (id3) => zipRight(self.interruptAsFork(id3), that.interruptAsFork(id3)),
  pipe() {
    return pipeArguments(this, arguments);
  }
}));

// ../node_modules/effect/dist/esm/internal/opCodes/layer.js
var OP_EXTEND_SCOPE = "ExtendScope";
var OP_FOLD = "Fold";
var OP_FRESH = "Fresh";
var OP_FROM_EFFECT = "FromEffect";
var OP_SCOPED = "Scoped";
var OP_SUSPEND = "Suspend";
var OP_PROVIDE = "Provide";
var OP_PROVIDE_MERGE = "ProvideMerge";
var OP_ZIP_WITH2 = "ZipWith";

// ../node_modules/effect/dist/esm/Fiber.js
var Fiber_exports = {};
__export(Fiber_exports, {
  FiberTypeId: () => FiberTypeId2,
  Order: () => Order8,
  RuntimeFiberTypeId: () => RuntimeFiberTypeId2,
  all: () => all6,
  await: () => _await3,
  awaitAll: () => awaitAll,
  children: () => children2,
  done: () => done8,
  dump: () => dump2,
  dumpAll: () => dumpAll2,
  fail: () => fail8,
  failCause: () => failCause6,
  fromEffect: () => fromEffect3,
  getCurrentFiber: () => getCurrentFiber2,
  id: () => id2,
  inheritAll: () => inheritAll2,
  interrupt: () => interrupt6,
  interruptAll: () => interruptAll2,
  interruptAllAs: () => interruptAllAs2,
  interruptAs: () => interruptAs,
  interruptAsFork: () => interruptAsFork2,
  interruptFork: () => interruptFork,
  interrupted: () => interrupted2,
  isFiber: () => isFiber2,
  isRuntimeFiber: () => isRuntimeFiber2,
  join: () => join4,
  joinAll: () => joinAll,
  map: () => map20,
  mapEffect: () => mapEffect4,
  mapFiber: () => mapFiber2,
  match: () => match15,
  never: () => never3,
  orElse: () => orElse5,
  orElseEither: () => orElseEither4,
  poll: () => poll4,
  pretty: () => pretty4,
  roots: () => roots2,
  scoped: () => scoped,
  status: () => status2,
  succeed: () => succeed9,
  unsafeRoots: () => unsafeRoots2,
  void: () => void_4,
  zip: () => zip9,
  zipLeft: () => zipLeft5,
  zipRight: () => zipRight5,
  zipWith: () => zipWith6
});
var FiberTypeId2 = FiberTypeId;
var RuntimeFiberTypeId2 = RuntimeFiberTypeId;
var Order8 = Order7;
var isFiber2 = isFiber;
var isRuntimeFiber2 = isRuntimeFiber;
var id2 = id;
var _await3 = _await2;
var awaitAll = fiberAwaitAll;
var children2 = children;
var all6 = fiberAll;
var done8 = done5;
var dump2 = dump;
var dumpAll2 = dumpAll;
var fail8 = fail5;
var failCause6 = failCause4;
var fromEffect3 = fromEffect;
var getCurrentFiber2 = getCurrentFiber;
var inheritAll2 = inheritAll;
var interrupt6 = interruptFiber;
var interrupted2 = interrupted;
var interruptAs = interruptAsFiber;
var interruptAsFork2 = interruptAsFork;
var interruptAll2 = interruptAll;
var interruptAllAs2 = interruptAllAs;
var interruptFork = fiberInterruptFork;
var join4 = join3;
var joinAll = fiberJoinAll;
var map20 = map14;
var mapEffect4 = mapEffect2;
var mapFiber2 = mapFiber;
var match15 = match12;
var never3 = never2;
var orElse5 = orElse4;
var orElseEither4 = orElseEither2;
var poll4 = poll3;
var pretty4 = pretty2;
var roots2 = roots;
var unsafeRoots2 = unsafeRoots;
var scoped = fiberScoped;
var status2 = status;
var succeed9 = succeed4;
var void_4 = void_3;
var zip9 = zipFiber;
var zipLeft5 = zipLeftFiber;
var zipRight5 = zipRightFiber;
var zipWith6 = zipWithFiber;

// ../node_modules/effect/dist/esm/internal/runtime.js
var unsafeFork2 = (runtime8) => (self, options) => {
  const fiberId5 = unsafeMake3();
  const fiberRefUpdates = [[currentContext, [[fiberId5, runtime8.context]]]];
  if (options == null ? void 0 : options.scheduler) {
    fiberRefUpdates.push([currentScheduler, [[fiberId5, options.scheduler]]]);
  }
  let fiberRefs4 = updateManyAs2(runtime8.fiberRefs, {
    entries: fiberRefUpdates,
    forkAs: fiberId5
  });
  if (options == null ? void 0 : options.updateRefs) {
    fiberRefs4 = options.updateRefs(fiberRefs4, fiberId5);
  }
  const fiberRuntime = new FiberRuntime(fiberId5, fiberRefs4, runtime8.runtimeFlags);
  let effect4 = self;
  if (options == null ? void 0 : options.scope) {
    effect4 = flatMap10(fork2(options.scope, sequential2), (closeableScope) => zipRight(scopeAddFinalizer(closeableScope, fiberIdWith((id3) => equals(id3, fiberRuntime.id()) ? void_ : interruptAsFiber(fiberRuntime, id3))), onExit(self, (exit3) => close(closeableScope, exit3))));
  }
  const supervisor = fiberRuntime._supervisor;
  if (supervisor !== none8) {
    supervisor.onStart(runtime8.context, effect4, none2(), fiberRuntime);
    fiberRuntime.addObserver((exit3) => supervisor.onEnd(exit3, fiberRuntime));
  }
  globalScope.add(runtime8.runtimeFlags, fiberRuntime);
  if ((options == null ? void 0 : options.immediate) === false) {
    fiberRuntime.resume(effect4);
  } else {
    fiberRuntime.start(effect4);
  }
  return fiberRuntime;
};
var unsafeRunCallback = (runtime8) => (effect4, options = {}) => {
  const fiberRuntime = unsafeFork2(runtime8)(effect4, options);
  if (options.onExit) {
    fiberRuntime.addObserver((exit3) => {
      options.onExit(exit3);
    });
  }
  return (id3, cancelOptions) => unsafeRunCallback(runtime8)(pipe(fiberRuntime, interruptAs(id3 ?? none4)), {
    ...cancelOptions,
    onExit: (cancelOptions == null ? void 0 : cancelOptions.onExit) ? (exit3) => cancelOptions.onExit(flatten6(exit3)) : void 0
  });
};
var unsafeRunSync = (runtime8) => (effect4) => {
  const result = unsafeRunSyncExit(runtime8)(effect4);
  if (result._tag === "Failure") {
    throw fiberFailure(result.effect_instruction_i0);
  } else {
    return result.effect_instruction_i0;
  }
};
var AsyncFiberExceptionImpl = class extends Error {
  constructor(fiber) {
    super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
    __publicField(this, "fiber");
    __publicField(this, "_tag", "AsyncFiberException");
    this.fiber = fiber;
    this.name = this._tag;
    this.stack = this.message;
  }
};
var asyncFiberException = (fiber) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error4 = new AsyncFiberExceptionImpl(fiber);
  Error.stackTraceLimit = limit;
  return error4;
};
var isAsyncFiberException = (u) => isTagged(u, "AsyncFiberException") && "fiber" in u;
var FiberFailureId = Symbol.for("effect/Runtime/FiberFailure");
var FiberFailureCauseId = Symbol.for("effect/Runtime/FiberFailure/Cause");
var _a47, _b14;
var FiberFailureImpl = class extends Error {
  constructor(cause3) {
    super();
    __publicField(this, _a47);
    __publicField(this, _b14);
    this[FiberFailureId] = FiberFailureId;
    this[FiberFailureCauseId] = cause3;
    const prettyErrors2 = prettyErrors(cause3);
    if (prettyErrors2.length > 0) {
      const head11 = prettyErrors2[0];
      this.name = head11.message.split(":")[0];
      this.message = head11.message.substring(this.name.length + 2);
      this.stack = pretty(cause3);
    }
    this.name = `(FiberFailure) ${this.name}`;
  }
  toJSON() {
    return {
      _id: "FiberFailure",
      cause: this[FiberFailureCauseId].toJSON()
    };
  }
  toString() {
    return "(FiberFailure) " + pretty(this[FiberFailureCauseId]);
  }
  [(_a47 = FiberFailureId, _b14 = FiberFailureCauseId, NodeInspectSymbol)]() {
    return this.toString();
  }
};
var fiberFailure = (cause3) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error4 = new FiberFailureImpl(cause3);
  Error.stackTraceLimit = limit;
  return error4;
};
var isFiberFailure = (u) => hasProperty(u, FiberFailureId);
var fastPath = (effect4) => {
  const op = effect4;
  switch (op._op) {
    case "Failure":
    case "Success": {
      return op;
    }
    case "Left": {
      return exitFail(op.left);
    }
    case "Right": {
      return exitSucceed(op.right);
    }
    case "Some": {
      return exitSucceed(op.value);
    }
    case "None": {
      return exitFail(NoSuchElementException());
    }
  }
};
var unsafeRunSyncExit = (runtime8) => (effect4) => {
  const op = fastPath(effect4);
  if (op) {
    return op;
  }
  const scheduler = new SyncScheduler();
  const fiberRuntime = unsafeFork2(runtime8)(effect4, {
    scheduler
  });
  scheduler.flush();
  const result = fiberRuntime.unsafePoll();
  if (result) {
    return result;
  }
  throw asyncFiberException(fiberRuntime);
};
var unsafeRunPromise = (runtime8) => (effect4, options) => unsafeRunPromiseExit(runtime8)(effect4, options).then((result) => {
  switch (result._tag) {
    case OP_SUCCESS: {
      return result.effect_instruction_i0;
    }
    case OP_FAILURE: {
      throw fiberFailure(result.effect_instruction_i0);
    }
  }
});
var unsafeRunPromiseExit = (runtime8) => (effect4, options) => new Promise((resolve) => {
  const op = fastPath(effect4);
  if (op) {
    resolve(op);
  }
  const fiber = unsafeFork2(runtime8)(effect4);
  fiber.addObserver((exit3) => {
    resolve(exit3);
  });
  if ((options == null ? void 0 : options.signal) !== void 0) {
    if (options.signal.aborted) {
      fiber.unsafeInterruptAsFork(fiber.id());
    } else {
      options.signal.addEventListener("abort", () => {
        fiber.unsafeInterruptAsFork(fiber.id());
      });
    }
  }
});
var RuntimeImpl = class {
  constructor(context13, runtimeFlags2, fiberRefs4) {
    __publicField(this, "context");
    __publicField(this, "runtimeFlags");
    __publicField(this, "fiberRefs");
    this.context = context13;
    this.runtimeFlags = runtimeFlags2;
    this.fiberRefs = fiberRefs4;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make56 = (options) => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs);
var runtime3 = () => withFiberRuntime((state, status3) => succeed(new RuntimeImpl(state.getFiberRef(currentContext), status3.runtimeFlags, state.getFiberRefs())));
var defaultRuntimeFlags = make20(Interruption, CooperativeYielding, RuntimeMetrics);
var defaultRuntime = make56({
  context: empty4(),
  runtimeFlags: defaultRuntimeFlags,
  fiberRefs: empty25()
});
var updateRuntimeFlags2 = dual(2, (self, f) => make56({
  context: self.context,
  runtimeFlags: f(self.runtimeFlags),
  fiberRefs: self.fiberRefs
}));
var disableRuntimeFlag = dual(2, (self, flag) => updateRuntimeFlags2(self, disable2(flag)));
var enableRuntimeFlag = dual(2, (self, flag) => updateRuntimeFlags2(self, enable2(flag)));
var updateContext = dual(2, (self, f) => make56({
  context: f(self.context),
  runtimeFlags: self.runtimeFlags,
  fiberRefs: self.fiberRefs
}));
var provideService3 = dual(3, (self, tag4, service3) => updateContext(self, add2(tag4, service3)));
var updateFiberRefs2 = dual(2, (self, f) => make56({
  context: self.context,
  runtimeFlags: self.runtimeFlags,
  fiberRefs: f(self.fiberRefs)
}));
var setFiberRef = dual(3, (self, fiberRef, value8) => updateFiberRefs2(self, updateAs2({
  fiberId: none4,
  fiberRef,
  value: value8
})));
var deleteFiberRef = dual(2, (self, fiberRef) => updateFiberRefs2(self, delete_2(fiberRef)));
var unsafeRunEffect = unsafeRunCallback(defaultRuntime);
var unsafeForkEffect = unsafeFork2(defaultRuntime);
var unsafeRunPromiseEffect = unsafeRunPromise(defaultRuntime);
var unsafeRunPromiseExitEffect = unsafeRunPromiseExit(defaultRuntime);
var unsafeRunSyncEffect = unsafeRunSync(defaultRuntime);
var unsafeRunSyncExitEffect = unsafeRunSyncExit(defaultRuntime);
var asyncEffect = (register) => suspend(() => {
  let cleanup = void 0;
  return flatMap10(deferredMake(), (deferred) => flatMap10(runtime3(), (runtime8) => uninterruptibleMask((restore) => zipRight(fork(restore(matchCauseEffect(register((cb) => unsafeRunCallback(runtime8)(intoDeferred(cb, deferred))), {
    onFailure: (cause3) => deferredFailCause(deferred, cause3),
    onSuccess: (cleanup_) => {
      cleanup = cleanup_;
      return void_;
    }
  }))), restore(onInterrupt(deferredAwait(deferred), () => cleanup ?? void_))))));
});

// ../node_modules/effect/dist/esm/internal/synchronizedRef.js
var getAndUpdateEffect = dual(2, (self, f) => self.modifyEffect((value8) => map11(f(value8), (result) => [value8, result])));
var getAndUpdateSomeEffect = dual(2, (self, pf) => self.modifyEffect((value8) => {
  const result = pf(value8);
  switch (result._tag) {
    case "None": {
      return succeed([value8, value8]);
    }
    case "Some": {
      return map11(result.value, (newValue) => [value8, newValue]);
    }
  }
}));
var modify7 = dual(2, (self, f) => self.modify(f));
var modifyEffect = dual(2, (self, f) => self.modifyEffect(f));
var modifySomeEffect = dual(3, (self, fallback, pf) => self.modifyEffect((value8) => pipe(pf(value8), getOrElse(() => succeed([fallback, value8])))));
var updateEffect = dual(2, (self, f) => self.modifyEffect((value8) => map11(f(value8), (result) => [void 0, result])));
var updateAndGetEffect = dual(2, (self, f) => self.modifyEffect((value8) => map11(f(value8), (result) => [result, result])));
var updateSomeEffect = dual(2, (self, pf) => self.modifyEffect((value8) => {
  const result = pf(value8);
  switch (result._tag) {
    case "None": {
      return succeed([void 0, value8]);
    }
    case "Some": {
      return map11(result.value, (a) => [void 0, a]);
    }
  }
}));

// ../node_modules/effect/dist/esm/internal/layer.js
var LayerSymbolKey = "effect/Layer";
var LayerTypeId = Symbol.for(LayerSymbolKey);
var layerVariance = {
  /* c8 ignore next */
  _RIn: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _ROut: (_) => _
};
var proto3 = {
  [LayerTypeId]: layerVariance,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MemoMapTypeIdKey = "effect/Layer/MemoMap";
var MemoMapTypeId = Symbol.for(MemoMapTypeIdKey);
var isLayer = (u) => hasProperty(u, LayerTypeId);
var isFresh = (self) => {
  return self._tag === OP_FRESH;
};
var _a48;
var MemoMapImpl = class {
  constructor(ref) {
    __publicField(this, "ref");
    __publicField(this, _a48);
    this.ref = ref;
    this[MemoMapTypeId] = MemoMapTypeId;
  }
  /**
   * Checks the memo map to see if a layer exists. If it is, immediately
   * returns it. Otherwise, obtains the layer, stores it in the memo map,
   * and adds a finalizer to the `Scope`.
   */
  getOrElseMemoize(layer, scope5) {
    return pipe(modifyEffect(this.ref, (map43) => {
      const inMap = map43.get(layer);
      if (inMap !== void 0) {
        const [acquire3, release3] = inMap;
        const cached4 = pipe(acquire3, flatMap10(([patch14, b]) => pipe(patchFiberRefs(patch14), as2(b))), onExit(exitMatch({
          onFailure: () => void_,
          onSuccess: () => scopeAddFinalizerExit(scope5, release3)
        })));
        return succeed([cached4, map43]);
      }
      return pipe(make35(0), flatMap10((observers) => pipe(deferredMake(), flatMap10((deferred) => pipe(make35(() => void_), map11((finalizerRef) => {
        const resource = uninterruptibleMask((restore) => pipe(scopeMake(), flatMap10((innerScope) => pipe(restore(flatMap10(makeBuilder(layer, innerScope, true), (f) => diffFiberRefs(f(this)))), exit, flatMap10((exit3) => {
          switch (exit3._tag) {
            case OP_FAILURE: {
              return pipe(deferredFailCause(deferred, exit3.effect_instruction_i0), zipRight(scopeClose(innerScope, exit3)), zipRight(failCause(exit3.effect_instruction_i0)));
            }
            case OP_SUCCESS: {
              return pipe(set5(finalizerRef, (exit4) => pipe(scopeClose(innerScope, exit4), whenEffect(modify5(observers, (n) => [n === 1, n - 1])), asVoid)), zipRight(update3(observers, (n) => n + 1)), zipRight(scopeAddFinalizerExit(scope5, (exit4) => pipe(sync(() => map43.delete(layer)), zipRight(get10(finalizerRef)), flatMap10((finalizer3) => finalizer3(exit4))))), zipRight(deferredSucceed(deferred, exit3.effect_instruction_i0)), as2(exit3.effect_instruction_i0[1]));
            }
          }
        })))));
        const memoized = [pipe(deferredAwait(deferred), onExit(exitMatchEffect({
          onFailure: () => void_,
          onSuccess: () => update3(observers, (n) => n + 1)
        }))), (exit3) => pipe(get10(finalizerRef), flatMap10((finalizer3) => finalizer3(exit3)))];
        return [resource, isFresh(layer) ? map43 : map43.set(layer, memoized)];
      }))))));
    }), flatten5);
  }
};
_a48 = MemoMapTypeId;
var makeMemoMap = suspend(() => map11(makeSynchronized(/* @__PURE__ */ new Map()), (ref) => new MemoMapImpl(ref)));
var unsafeMakeMemoMap = () => new MemoMapImpl(unsafeMakeSynchronized(/* @__PURE__ */ new Map()));
var build = (self) => scopeWith((scope5) => buildWithScope(self, scope5));
var buildWithScope = dual(2, (self, scope5) => flatMap10(makeMemoMap, (memoMap) => flatMap10(makeBuilder(self, scope5), (run11) => run11(memoMap))));
var buildWithMemoMap = dual(3, (self, memoMap, scope5) => flatMap10(makeBuilder(self, scope5), (run11) => run11(memoMap)));
var makeBuilder = (self, scope5, inMemoMap = false) => {
  const op = self;
  switch (op._tag) {
    case "Locally": {
      return sync(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope5)));
    }
    case "ExtendScope": {
      return sync(() => (memoMap) => scopeWith((scope6) => memoMap.getOrElseMemoize(op.layer, scope6)));
    }
    case "Fold": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope5), matchCauseEffect({
        onFailure: (cause3) => memoMap.getOrElseMemoize(op.failureK(cause3), scope5),
        onSuccess: (value8) => memoMap.getOrElseMemoize(op.successK(value8), scope5)
      })));
    }
    case "Fresh": {
      return sync(() => (_) => pipe(op.layer, buildWithScope(scope5)));
    }
    case "FromEffect": {
      return inMemoMap ? sync(() => (_) => op.effect) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self, scope5));
    }
    case "Provide": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope5), flatMap10((env) => pipe(memoMap.getOrElseMemoize(op.second, scope5), provideContext(env)))));
    }
    case "Scoped": {
      return inMemoMap ? sync(() => (_) => scopeExtend(op.effect, scope5)) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self, scope5));
    }
    case "Suspend": {
      return sync(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope5));
    }
    case "ProvideMerge": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope5), zipWith3(memoMap.getOrElseMemoize(op.second, scope5), op.zipK)));
    }
    case "ZipWith": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope5), zipWithOptions(memoMap.getOrElseMemoize(op.second, scope5), op.zipK, {
        concurrent: true
      })));
    }
  }
};
var catchAll2 = dual(2, (self, onFailure) => match16(self, {
  onFailure,
  onSuccess: succeedContext
}));
var catchAllCause2 = dual(2, (self, onFailure) => matchCause2(self, {
  onFailure,
  onSuccess: succeedContext
}));
var die6 = (defect) => failCause7(die5(defect));
var dieSync3 = (evaluate3) => failCauseSync3(() => die5(evaluate3()));
var discard = (self) => map21(self, () => empty4());
var context2 = () => fromEffectContext(context());
var extendScope = (self) => {
  const extendScope3 = Object.create(proto3);
  extendScope3._tag = OP_EXTEND_SCOPE;
  extendScope3.layer = self;
  return extendScope3;
};
var fail9 = (error4) => failCause7(fail7(error4));
var failSync3 = (evaluate3) => failCauseSync3(() => fail7(evaluate3()));
var failCause7 = (cause3) => fromEffectContext(failCause(cause3));
var failCauseSync3 = (evaluate3) => fromEffectContext(failCauseSync(evaluate3));
var flatMap14 = dual(2, (self, f) => match16(self, {
  onFailure: fail9,
  onSuccess: f
}));
var flatten8 = dual(2, (self, tag4) => flatMap14(self, get2(tag4)));
var fresh = (self) => {
  const fresh3 = Object.create(proto3);
  fresh3._tag = OP_FRESH;
  fresh3.layer = self;
  return fresh3;
};
var fromEffect4 = dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag4 = tagFirst ? a : b;
  const effect4 = tagFirst ? b : a;
  return fromEffectContext(map11(effect4, (service3) => make7(tag4, service3)));
});
var fromEffectDiscard = (effect4) => fromEffectContext(map11(effect4, () => empty4()));
function fromEffectContext(effect4) {
  const fromEffect17 = Object.create(proto3);
  fromEffect17._tag = OP_FROM_EFFECT;
  fromEffect17.effect = effect4;
  return fromEffect17;
}
var fiberRefLocally2 = dual(3, (self, ref, value8) => locallyEffect(self, fiberRefLocally(ref, value8)));
var locallyEffect = dual(2, (self, f) => {
  const locally5 = Object.create(proto3);
  locally5._tag = "Locally";
  locally5.self = self;
  locally5.f = f;
  return locally5;
});
var fiberRefLocallyWith2 = dual(3, (self, ref, value8) => locallyEffect(self, fiberRefLocallyWith(ref, value8)));
var fiberRefLocallyScoped2 = (self, value8) => scopedDiscard(fiberRefLocallyScoped(self, value8));
var fiberRefLocallyScopedWith2 = (self, value8) => scopedDiscard(fiberRefLocallyScopedWith(self, value8));
var fromFunction2 = (tagA, tagB, f) => fromEffectContext(map11(tagA, (a) => make7(tagB, f(a))));
var launch = (self) => scopedEffect(zipRight(scopeWith((scope5) => pipe(self, buildWithScope(scope5))), never));
var map21 = dual(2, (self, f) => flatMap14(self, (context13) => succeedContext(f(context13))));
var mapError3 = dual(2, (self, f) => catchAll2(self, (error4) => failSync3(() => f(error4))));
var matchCause2 = dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  const fold3 = Object.create(proto3);
  fold3._tag = OP_FOLD;
  fold3.layer = self;
  fold3.failureK = onFailure;
  fold3.successK = onSuccess;
  return fold3;
});
var match16 = dual(2, (self, {
  onFailure,
  onSuccess
}) => matchCause2(self, {
  onFailure: (cause3) => {
    const failureOrCause3 = failureOrCause2(cause3);
    switch (failureOrCause3._tag) {
      case "Left": {
        return onFailure(failureOrCause3.left);
      }
      case "Right": {
        return failCause7(failureOrCause3.right);
      }
    }
  },
  onSuccess
}));
var memoize2 = (self) => scopeWith((scope5) => map11(memoize(buildWithScope(self, scope5)), fromEffectContext));
var merge6 = dual(2, (self, that) => zipWith7(self, that, (a, b) => merge3(a, b)));
var mergeAll2 = (...layers) => {
  let final = layers[0];
  for (let i = 1; i < layers.length; i++) {
    final = merge6(final, layers[i]);
  }
  return final;
};
var orDie2 = (self) => catchAll2(self, (defect) => die6(defect));
var orElse6 = dual(2, (self, that) => catchAll2(self, that));
var passthrough2 = (self) => merge6(context2(), self);
var project = dual(4, (self, tagA, tagB, f) => map21(self, (context13) => make7(tagB, f(unsafeGet3(context13, tagA)))));
var retry = dual(2, (self, schedule4) => suspend2(() => {
  const stateTag = GenericTag("effect/Layer/retry/{ state: unknown }");
  return pipe(succeed10(stateTag, {
    state: schedule4.initial
  }), flatMap14((env) => retryLoop(self, schedule4, stateTag, pipe(env, get2(stateTag)).state)));
}));
var retryLoop = (self, schedule4, stateTag, state) => {
  return pipe(self, catchAll2((error4) => pipe(retryUpdate(schedule4, stateTag, error4, state), flatMap14((env) => fresh(retryLoop(self, schedule4, stateTag, pipe(env, get2(stateTag)).state))))));
};
var retryUpdate = (schedule4, stateTag, error4, state) => {
  return fromEffect4(stateTag, pipe(currentTimeMillis2, flatMap10((now) => pipe(schedule4.step(now, error4, state), flatMap10(([state2, _, decision]) => isDone5(decision) ? fail2(error4) : pipe(sleep2(millis(start2(decision.intervals) - now)), as2({
    state: state2
  })))))));
};
var scoped2 = dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag4 = tagFirst ? a : b;
  const effect4 = tagFirst ? b : a;
  return scopedContext(map11(effect4, (service3) => make7(tag4, service3)));
});
var scopedDiscard = (effect4) => scopedContext(pipe(effect4, as2(empty4())));
var scopedContext = (effect4) => {
  const scoped9 = Object.create(proto3);
  scoped9._tag = OP_SCOPED;
  scoped9.effect = effect4;
  return scoped9;
};
var scope2 = scopedContext(map11(acquireRelease(scopeMake(), (scope5, exit3) => scope5.close(exit3)), (scope5) => make7(Scope, scope5)));
var service = (tag4) => fromEffect4(tag4, tag4);
var succeed10 = dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag4 = tagFirst ? a : b;
  const resource = tagFirst ? b : a;
  return fromEffectContext(succeed(make7(tag4, resource)));
});
var succeedContext = (context13) => {
  return fromEffectContext(succeed(context13));
};
var empty38 = succeedContext(empty4());
var suspend2 = (evaluate3) => {
  const suspend16 = Object.create(proto3);
  suspend16._tag = OP_SUSPEND;
  suspend16.evaluate = evaluate3;
  return suspend16;
};
var sync6 = dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag4 = tagFirst ? a : b;
  const evaluate3 = tagFirst ? b : a;
  return fromEffectContext(sync(() => make7(tag4, evaluate3())));
});
var syncContext = (evaluate3) => {
  return fromEffectContext(sync(evaluate3));
};
var tap2 = dual(2, (self, f) => flatMap14(self, (context13) => fromEffectContext(as2(f(context13), context13))));
var tapError2 = dual(2, (self, f) => catchAll2(self, (e) => fromEffectContext(flatMap10(f(e), () => fail2(e)))));
var tapErrorCause2 = dual(2, (self, f) => catchAllCause2(self, (cause3) => fromEffectContext(flatMap10(f(cause3), () => failCause(cause3)))));
var toRuntime = (self) => pipe(scopeWith((scope5) => buildWithScope(self, scope5)), flatMap10((context13) => pipe(runtime3(), provideContext(context13))));
var toRuntimeWithMemoMap = dual(2, (self, memoMap) => flatMap10(scopeWith((scope5) => buildWithMemoMap(self, memoMap, scope5)), (context13) => pipe(runtime3(), provideContext(context13))));
var provide = dual(2, (that, self) => suspend2(() => {
  const provideTo = Object.create(proto3);
  provideTo._tag = OP_PROVIDE;
  provideTo.first = Object.create(proto3, {
    _tag: {
      value: OP_PROVIDE_MERGE,
      enumerable: true
    },
    first: {
      value: context2(),
      enumerable: true
    },
    second: {
      value: self
    },
    zipK: {
      value: (a, b) => pipe(a, merge3(b))
    }
  });
  provideTo.second = that;
  return provideTo;
}));
var provideMerge = dual(2, (that, self) => {
  const zipWith19 = Object.create(proto3);
  zipWith19._tag = OP_PROVIDE_MERGE;
  zipWith19.first = self;
  zipWith19.second = provide(that, self);
  zipWith19.zipK = (a, b) => {
    return pipe(a, merge3(b));
  };
  return zipWith19;
});
var zipWith7 = dual(3, (self, that, f) => suspend2(() => {
  const zipWith19 = Object.create(proto3);
  zipWith19._tag = OP_ZIP_WITH2;
  zipWith19.first = self;
  zipWith19.second = that;
  zipWith19.zipK = f;
  return zipWith19;
}));
var unwrapEffect = (self) => {
  const tag4 = GenericTag("effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>");
  return flatMap14(fromEffect4(tag4, self), (context13) => get2(context13, tag4));
};
var unwrapScoped = (self) => {
  const tag4 = GenericTag("effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>");
  return flatMap14(scoped2(tag4, self), (context13) => get2(context13, tag4));
};
var withSpan2 = dual((args) => isLayer(args[0]), (self, name, options) => unwrapScoped(map11((options == null ? void 0 : options.onEnd) ? tap(makeSpanScoped(name, options), (span4) => addFinalizer((exit3) => options.onEnd(span4, exit3))) : makeSpanScoped(name, options), (span4) => withParentSpan2(self, span4))));
var withParentSpan2 = dual(2, (self, span4) => provide(self, succeedContext(make7(spanTag, span4))));
var provideSomeLayer = dual(2, (self, layer) => acquireUseRelease(scopeMake(), (scope5) => flatMap10(buildWithScope(layer, scope5), (context13) => provideSomeContext(self, context13)), (scope5, exit3) => scopeClose(scope5, exit3)));
var provideSomeRuntime = dual(2, (self, rt) => {
  const patchRefs = diff9(defaultRuntime.fiberRefs, rt.fiberRefs);
  const patchFlags = diff7(defaultRuntime.runtimeFlags, rt.runtimeFlags);
  return uninterruptibleMask((restore) => withFiberRuntime((fiber) => {
    const oldRefs = fiber.getFiberRefs();
    const newRefs = patch10(fiber.id(), oldRefs)(patchRefs);
    const oldFlags = fiber._runtimeFlags;
    const newFlags = patch7(patchFlags)(oldFlags);
    const rollbackRefs = diff9(newRefs, oldRefs);
    const rollbackFlags = diff7(newFlags, oldFlags);
    fiber.setFiberRefs(newRefs);
    fiber._runtimeFlags = newFlags;
    return ensuring(provideSomeContext(restore(self), rt.context), withFiberRuntime((fiber2) => {
      fiber2.setFiberRefs(patch10(fiber2.id(), fiber2.getFiberRefs())(rollbackRefs));
      fiber2._runtimeFlags = patch7(rollbackFlags)(fiber2._runtimeFlags);
      return void_;
    }));
  }));
});
var effect_provide = dual(2, (self, source) => isLayer(source) ? provideSomeLayer(self, source) : isContext2(source) ? provideSomeContext(self, source) : provideSomeRuntime(self, source));

// ../node_modules/effect/dist/esm/internal/console.js
var console2 = map11(fiberRefGet(currentServices), get2(consoleTag));
var consoleWith = (f) => fiberRefGetWith(currentServices, (services) => f(get2(services, consoleTag)));
var withConsole = dual(2, (effect4, value8) => fiberRefLocallyWith(effect4, currentServices, add2(consoleTag, value8)));
var withConsoleScoped = (console4) => fiberRefLocallyScopedWith(currentServices, add2(consoleTag, console4));
var setConsole = (console4) => scopedDiscard(fiberRefLocallyScopedWith(currentServices, add2(consoleTag, console4)));
var assert = (condition, ...args) => consoleWith((_) => _.assert(condition, ...args));
var clear2 = consoleWith((_) => _.clear);
var count2 = (label) => consoleWith((_) => _.count(label));
var countReset = (label) => consoleWith((_) => _.countReset(label));
var debug = (...args) => consoleWith((_) => _.debug(...args));
var dir = (item, options) => consoleWith((_) => _.dir(item, options));
var dirxml = (...args) => consoleWith((_) => _.dirxml(...args));
var error2 = (...args) => consoleWith((_) => _.error(...args));
var group = (options) => consoleWith((_) => acquireRelease(_.group(options), () => _.groupEnd));
var info = (...args) => consoleWith((_) => _.info(...args));
var log2 = (...args) => consoleWith((_) => _.log(...args));
var table = (tabularData, properties) => consoleWith((_) => _.table(tabularData, properties));
var time = (label) => consoleWith((_) => acquireRelease(_.time(label), () => _.timeEnd(label)));
var timeLog = (label, ...args) => consoleWith((_) => _.timeLog(label, ...args));
var trace = (...args) => consoleWith((_) => _.trace(...args));
var warn = (...args) => consoleWith((_) => _.warn(...args));
var withGroup = dual((args) => isEffect(args[0]), (self, options) => consoleWith((_) => acquireUseRelease(_.group(options), () => self, () => _.groupEnd)));
var withTime = dual((args) => isEffect(args[0]), (self, label) => consoleWith((_) => acquireUseRelease(_.time(label), () => self, () => _.timeEnd(label))));

// ../node_modules/effect/dist/esm/internal/query.js
var currentCache = globalValue(Symbol.for("effect/FiberRef/currentCache"), () => fiberRefUnsafeMake(unsafeMakeWith(65536, () => map11(deferredMake(), (handle) => ({
  listeners: new Listeners(),
  handle
})), () => seconds(60))));
var currentCacheEnabled = globalValue(Symbol.for("effect/FiberRef/currentCacheEnabled"), () => fiberRefUnsafeMake(false));
var fromRequest = (request2, dataSource) => flatMap10(isEffect(dataSource) ? dataSource : succeed(dataSource), (ds) => fiberIdWith((id3) => {
  const proxy = new Proxy(request2, {});
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      const cached4 = fiberRefGetWith(currentCache, (cache) => flatMap10(cache.getEither(proxy), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            if (orNew.left.listeners.interrupted) {
              return flatMap10(cache.invalidateWhen(proxy, (entry) => entry.handle === orNew.left.handle), () => cached4);
            }
            orNew.left.listeners.increment();
            return uninterruptibleMask((restore) => flatMap10(exit(blocked(empty19, restore(deferredAwait(orNew.left.handle)))), (exit3) => {
              orNew.left.listeners.decrement();
              return exit3;
            }));
          }
          case "Right": {
            orNew.right.listeners.increment();
            return uninterruptibleMask((restore) => flatMap10(exit(blocked(single(ds, makeEntry({
              request: proxy,
              result: orNew.right.handle,
              listeners: orNew.right.listeners,
              ownerId: id3,
              state: {
                completed: false
              }
            })), restore(deferredAwait(orNew.right.handle)))), () => {
              orNew.right.listeners.decrement();
              return deferredAwait(orNew.right.handle);
            }));
          }
        }
      }));
      return cached4;
    }
    const listeners = new Listeners();
    listeners.increment();
    return flatMap10(deferredMake(), (ref) => ensuring(blocked(single(ds, makeEntry({
      request: proxy,
      result: ref,
      listeners,
      ownerId: id3,
      state: {
        completed: false
      }
    })), deferredAwait(ref)), sync(() => listeners.decrement())));
  });
}));
var cacheRequest = (request2, result) => {
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      return fiberRefGetWith(currentCache, (cache) => flatMap10(cache.getEither(request2), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            return void_;
          }
          case "Right": {
            return deferredComplete(orNew.right.handle, result);
          }
        }
      }));
    }
    return void_;
  });
};
var withRequestCaching = dual(2, (self, strategy) => fiberRefLocally(self, currentCacheEnabled, strategy));
var withRequestCache = dual(
  2,
  // @ts-expect-error
  (self, cache) => fiberRefLocally(self, currentCache, cache)
);

// ../node_modules/effect/dist/esm/Request.js
var Request_exports = {};
__export(Request_exports, {
  Class: () => Class3,
  EntryTypeId: () => EntryTypeId2,
  RequestTypeId: () => RequestTypeId2,
  TaggedClass: () => TaggedClass2,
  complete: () => complete4,
  completeEffect: () => completeEffect2,
  fail: () => fail10,
  failCause: () => failCause8,
  interruptWhenPossible: () => interruptWhenPossible2,
  isEntry: () => isEntry2,
  isRequest: () => isRequest2,
  makeCache: () => makeCache,
  makeEntry: () => makeEntry2,
  of: () => of5,
  succeed: () => succeed11,
  tagged: () => tagged4
});
var RequestTypeId2 = RequestTypeId;
var isRequest2 = isRequest;
var of5 = of4;
var tagged4 = tagged3;
var Class3 = Class2;
var TaggedClass2 = TaggedClass;
var complete4 = complete2;
var interruptWhenPossible2 = interruptWhenPossible;
var completeEffect2 = completeEffect;
var fail10 = fail6;
var failCause8 = failCause5;
var succeed11 = succeed7;
var makeCache = (options) => make48({
  ...options,
  lookup: () => map11(deferredMake(), (handle) => ({
    listeners: new Listeners(),
    handle
  }))
});
var EntryTypeId2 = Symbol.for("effect/RequestBlock.Entry");
var isEntry2 = isEntry;
var makeEntry2 = makeEntry;

// ../node_modules/effect/dist/esm/Effect.js
var EffectTypeId4 = EffectTypeId2;
var isEffect2 = isEffect;
var cachedWithTTL = cached2;
var cachedInvalidateWithTTL2 = cachedInvalidateWithTTL;
var cached3 = memoize;
var cachedFunction2 = cachedFunction;
var once3 = once;
var all7 = all5;
var allWith2 = allWith;
var allSuccesses2 = allSuccesses;
var dropUntil2 = dropUntil;
var dropWhile3 = dropWhile2;
var every9 = every7;
var exists3 = exists2;
var filter12 = filter10;
var filterMap7 = filterMap6;
var findFirst9 = findFirst6;
var firstSuccessOf2 = firstSuccessOf;
var forEach12 = forEach11;
var head6 = head5;
var mergeAll3 = mergeAll;
var partition8 = partition7;
var reduce15 = reduce10;
var reduceEffect3 = reduceEffect;
var reduceRight5 = reduceRight4;
var reduceWhile2 = reduceWhile;
var replicate2 = replicate;
var replicateEffect2 = replicateEffect;
var takeUntil2 = takeUntil;
var takeWhile3 = takeWhile2;
var validateAll2 = validateAll;
var validateFirst2 = validateFirst;
var async2 = async;
var asyncEffect2 = asyncEffect;
var custom2 = custom;
var withFiberRuntime2 = withFiberRuntime;
var fail11 = fail2;
var failSync4 = failSync;
var failCause9 = failCause;
var failCauseSync4 = failCauseSync;
var die7 = die2;
var dieMessage2 = dieMessage;
var dieSync4 = dieSync;
var gen2 = gen;
var never4 = never;
var none9 = none6;
var promise2 = promise;
var succeed12 = succeed;
var succeedNone2 = succeedNone;
var succeedSome2 = succeedSome;
var suspend3 = suspend;
var sync7 = sync;
var _void = void_;
var yieldNow3 = yieldNow;
var _catch2 = _catch;
var catchAll3 = catchAll;
var catchAllCause3 = catchAllCause;
var catchAllDefect2 = catchAllDefect;
var catchIf2 = catchIf;
var catchSome2 = catchSome;
var catchSomeCause2 = catchSomeCause;
var catchSomeDefect2 = catchSomeDefect;
var catchTag2 = catchTag;
var catchTags2 = catchTags;
var cause2 = cause;
var eventually2 = eventually;
var ignore2 = ignore;
var ignoreLogged2 = ignoreLogged;
var parallelErrors2 = parallelErrors;
var sandbox2 = sandbox;
var retry2 = retry_combined;
var retryOrElse = retryOrElse_Effect;
var try_2 = try_;
var tryMap2 = tryMap;
var tryMapPromise2 = tryMapPromise;
var tryPromise2 = tryPromise;
var unsandbox2 = unsandbox;
var allowInterrupt2 = allowInterrupt;
var checkInterruptible2 = checkInterruptible;
var disconnect2 = disconnect;
var interrupt7 = interrupt2;
var interruptWith3 = interruptWith;
var interruptible3 = interruptible2;
var interruptibleMask2 = interruptibleMask;
var onInterrupt2 = onInterrupt;
var uninterruptible2 = uninterruptible;
var uninterruptibleMask2 = uninterruptibleMask;
var as6 = as2;
var asSome2 = asSome;
var asSomeError2 = asSomeError;
var asVoid4 = asVoid;
var flip2 = flip;
var flipWith2 = flipWith;
var map22 = map11;
var mapAccum4 = mapAccum3;
var mapBoth4 = mapBoth;
var mapError4 = mapError;
var mapErrorCause3 = mapErrorCause2;
var merge7 = merge5;
var negate3 = negate2;
var acquireRelease2 = acquireRelease;
var acquireReleaseInterruptible2 = acquireReleaseInterruptible;
var acquireUseRelease2 = acquireUseRelease;
var addFinalizer3 = addFinalizer;
var ensuring3 = ensuring;
var onError2 = onError;
var onExit2 = onExit;
var parallelFinalizers2 = parallelFinalizers;
var finalizersMask2 = finalizersMask;
var sequentialFinalizers2 = sequentialFinalizers;
var scope3 = scope;
var scopeWith2 = scopeWith;
var scoped3 = scopedEffect;
var using2 = using;
var withEarlyRelease2 = withEarlyRelease;
var awaitAllChildren2 = awaitAllChildren;
var daemonChildren2 = daemonChildren;
var descriptor2 = descriptor;
var descriptorWith2 = descriptorWith;
var diffFiberRefs2 = diffFiberRefs;
var ensuringChild2 = ensuringChild;
var ensuringChildren2 = ensuringChildren;
var fiberId2 = fiberId;
var fiberIdWith2 = fiberIdWith;
var fork3 = fork;
var forkDaemon2 = forkDaemon;
var forkAll2 = forkAll;
var forkIn2 = forkIn;
var forkScoped2 = forkScoped;
var forkWithErrorHandler2 = forkWithErrorHandler;
var fromFiber2 = fromFiber;
var fromFiberEffect2 = fromFiberEffect;
var supervised2 = supervised;
var transplant2 = transplant;
var withConcurrency2 = withConcurrency;
var withScheduler2 = withScheduler;
var withSchedulingPriority2 = withSchedulingPriority;
var withMaxOpsBeforeYield2 = withMaxOpsBeforeYield;
var clock2 = clock;
var clockWith4 = clockWith3;
var withClockScoped2 = withClockScoped;
var withClock2 = withClock;
var console3 = console2;
var consoleWith2 = consoleWith;
var withConsoleScoped2 = withConsoleScoped;
var withConsole2 = withConsole;
var delay2 = delay;
var sleep4 = sleep3;
var timed2 = timed;
var timedWith2 = timedWith;
var timeout2 = timeout;
var timeoutFail2 = timeoutFail;
var timeoutFailCause2 = timeoutFailCause;
var timeoutTo2 = timeoutTo;
var configProviderWith2 = configProviderWith;
var withConfigProvider2 = withConfigProvider;
var withConfigProviderScoped2 = withConfigProviderScoped;
var context3 = context;
var contextWith2 = contextWith;
var contextWithEffect2 = contextWithEffect;
var mapInputContext3 = mapInputContext;
var provide2 = effect_provide;
var provideService4 = provideService;
var provideServiceEffect2 = provideServiceEffect;
var serviceFunction2 = serviceFunction;
var serviceFunctionEffect2 = serviceFunctionEffect;
var serviceFunctions2 = serviceFunctions;
var serviceConstants2 = serviceConstants;
var serviceMembers2 = serviceMembers;
var serviceOption2 = serviceOption;
var serviceOptional2 = serviceOptional;
var updateService2 = updateService;
var Do2 = Do;
var bind2 = bind;
var bindTo2 = bindTo;
var let_2 = let_;
var either5 = either3;
var exit2 = exit;
var intoDeferred2 = intoDeferred;
var option2 = option;
var if_2 = if_;
var filterOrDie2 = filterOrDie;
var filterOrDieMessage2 = filterOrDieMessage;
var filterOrElse2 = filterOrElse;
var filterOrFail2 = filterOrFail;
var unless2 = unless;
var unlessEffect2 = unlessEffect;
var when2 = when;
var whenEffect2 = whenEffect;
var whenFiberRef2 = whenFiberRef;
var whenRef2 = whenRef;
var flatMap15 = flatMap10;
var andThen8 = andThen4;
var flatten9 = flatten5;
var raceAll2 = raceAll;
var race2 = race;
var raceFirst2 = raceFirst;
var raceWith2 = raceWith;
var summarized2 = summarized;
var tap3 = tap;
var tapBoth2 = tapBoth;
var tapDefect2 = tapDefect;
var tapError3 = tapError;
var tapErrorTag2 = tapErrorTag;
var tapErrorCause3 = tapErrorCause;
var forever3 = forever;
var iterate2 = iterate;
var loop2 = loop;
var repeat = repeat_combined;
var repeatN2 = repeatN;
var repeatOrElse = repeatOrElse_Effect;
var schedule = schedule_Effect;
var scheduleForked2 = scheduleForked;
var scheduleFrom = scheduleFrom_Effect;
var whileLoop2 = whileLoop;
var getFiberRefs = fiberRefs3;
var inheritFiberRefs2 = inheritFiberRefs;
var locally2 = fiberRefLocally;
var locallyWith = fiberRefLocallyWith;
var locallyScoped = fiberRefLocallyScoped;
var locallyScopedWith = fiberRefLocallyScopedWith;
var patchFiberRefs2 = patchFiberRefs;
var setFiberRefs2 = setFiberRefs;
var updateFiberRefs3 = updateFiberRefs;
var isFailure5 = isFailure3;
var isSuccess3 = isSuccess2;
var match17 = match8;
var matchCause3 = matchCause;
var matchCauseEffect2 = matchCauseEffect;
var matchEffect3 = matchEffect;
var log3 = log;
var logWithLevel2 = (level, ...message) => logWithLevel(level)(...message);
var logTrace2 = logTrace;
var logDebug2 = logDebug;
var logInfo2 = logInfo;
var logWarning2 = logWarning;
var logError2 = logError;
var logFatal2 = logFatal;
var withLogSpan2 = withLogSpan;
var annotateLogs2 = annotateLogs;
var logAnnotations2 = logAnnotations;
var withUnhandledErrorLogLevel2 = withUnhandledErrorLogLevel;
var orDie3 = orDie;
var orDieWith2 = orDieWith;
var orElse7 = orElse2;
var orElseFail2 = orElseFail;
var orElseSucceed2 = orElseSucceed;
var random3 = random2;
var randomWith3 = randomWith;
var withRandom2 = withRandom;
var withRandomScoped2 = withRandomScoped;
var runtime4 = runtime3;
var getRuntimeFlags = runtimeFlags;
var patchRuntimeFlags = updateRuntimeFlags;
var withRuntimeFlagsPatch = withRuntimeFlags;
var withRuntimeFlagsPatchScoped = withRuntimeFlagsScoped;
var tagMetrics2 = tagMetrics;
var labelMetrics2 = labelMetrics;
var tagMetricsScoped2 = tagMetricsScoped;
var labelMetricsScoped2 = labelMetricsScoped;
var metricLabels2 = metricLabels;
var withMetric2 = withMetric;
var unsafeMakeSemaphore2 = unsafeMakeSemaphore;
var makeSemaphore2 = makeSemaphore;
var runFork = unsafeForkEffect;
var runCallback = unsafeRunEffect;
var runPromise = unsafeRunPromiseEffect;
var runPromiseExit = unsafeRunPromiseExitEffect;
var runSync = unsafeRunSyncEffect;
var runSyncExit = unsafeRunSyncExitEffect;
var validate2 = validate;
var validateWith2 = validateWith;
var zip10 = zipOptions;
var zipLeft6 = zipLeftOptions;
var zipRight6 = zipRightOptions;
var zipWith8 = zipWithOptions;
var ap = dual(2, (self, that) => zipWith8(self, that, (f, a) => f(a)));
var blocked2 = blocked;
var runRequestBlock2 = runRequestBlock;
var step3 = step2;
var request = dual((args) => isRequest2(args[0]), fromRequest);
var cacheRequestResult = cacheRequest;
var withRequestBatching2 = withRequestBatching;
var withRequestCaching2 = withRequestCaching;
var withRequestCache2 = withRequestCache;
var tracer2 = tracer;
var tracerWith4 = tracerWith;
var withTracer2 = withTracer;
var withTracerScoped2 = withTracerScoped;
var withTracerEnabled2 = withTracerEnabled;
var withTracerTiming2 = withTracerTiming;
var annotateSpans2 = annotateSpans;
var annotateCurrentSpan2 = annotateCurrentSpan;
var currentSpan2 = currentSpan;
var currentParentSpan2 = currentParentSpan;
var spanAnnotations2 = spanAnnotations;
var spanLinks2 = spanLinks;
var linkSpans2 = linkSpans;
var makeSpan2 = makeSpan;
var makeSpanScoped2 = makeSpanScoped;
var useSpan2 = useSpan;
var withSpan3 = withSpan;
var withSpanScoped2 = withSpanScoped;
var withParentSpan3 = withParentSpan;
var fromNullable3 = fromNullable2;
var optionFromOptional2 = optionFromOptional;
var Tag3 = (id3) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function TagClass() {
  }
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id3;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  const cache = /* @__PURE__ */ new Map();
  const done17 = new Proxy(TagClass, {
    get(_target, prop, _receiver) {
      if (prop === "use") {
        return (body) => andThen4(TagClass, body);
      }
      if (prop in TagClass) {
        return TagClass[prop];
      }
      if (cache.has(prop)) {
        return cache.get(prop);
      }
      const fn = (...args) => (
        // @ts-expect-error
        andThen4(TagClass, (s) => {
          if (typeof s[prop] === "function") {
            cache.set(prop, (...args2) => andThen4(TagClass, (s2) => s2[prop](...args2)));
            return s[prop](...args);
          }
          cache.set(prop, andThen4(TagClass, (s2) => s2[prop]));
          return s[prop];
        })
      );
      const cn = andThen4(TagClass, (s) => s[prop]);
      Object.assign(fn, cn);
      Object.setPrototypeOf(fn, Object.getPrototypeOf(cn));
      cache.set(prop, fn);
      return fn;
    }
  });
  return done17;
};

// ../node_modules/effect/dist/esm/Layer.js
var Layer_exports = {};
__export(Layer_exports, {
  LayerTypeId: () => LayerTypeId2,
  MemoMapTypeId: () => MemoMapTypeId2,
  build: () => build2,
  buildWithMemoMap: () => buildWithMemoMap2,
  buildWithScope: () => buildWithScope2,
  catchAll: () => catchAll4,
  catchAllCause: () => catchAllCause4,
  context: () => context4,
  die: () => die8,
  dieSync: () => dieSync5,
  discard: () => discard2,
  effect: () => effect,
  effectContext: () => effectContext,
  effectDiscard: () => effectDiscard,
  empty: () => empty39,
  extendScope: () => extendScope2,
  fail: () => fail12,
  failCause: () => failCause10,
  failCauseSync: () => failCauseSync5,
  failSync: () => failSync5,
  fiberRefLocallyScopedWith: () => fiberRefLocallyScopedWith3,
  flatMap: () => flatMap16,
  flatten: () => flatten10,
  fresh: () => fresh2,
  function: () => fromFunction3,
  isFresh: () => isFresh2,
  isLayer: () => isLayer2,
  launch: () => launch2,
  locally: () => locally3,
  locallyEffect: () => locallyEffect2,
  locallyScoped: () => locallyScoped2,
  locallyWith: () => locallyWith2,
  makeMemoMap: () => makeMemoMap2,
  map: () => map23,
  mapError: () => mapError5,
  match: () => match18,
  matchCause: () => matchCause4,
  memoize: () => memoize3,
  merge: () => merge8,
  mergeAll: () => mergeAll4,
  orDie: () => orDie4,
  orElse: () => orElse8,
  parentSpan: () => parentSpan2,
  passthrough: () => passthrough3,
  project: () => project2,
  provide: () => provide3,
  provideMerge: () => provideMerge2,
  retry: () => retry3,
  scope: () => scope4,
  scoped: () => scoped4,
  scopedContext: () => scopedContext2,
  scopedDiscard: () => scopedDiscard2,
  service: () => service2,
  setClock: () => setClock,
  setConfigProvider: () => setConfigProvider2,
  setRequestBatching: () => setRequestBatching,
  setRequestCache: () => setRequestCache,
  setRequestCaching: () => setRequestCaching,
  setScheduler: () => setScheduler,
  setTracer: () => setTracer2,
  setTracerEnabled: () => setTracerEnabled,
  setTracerTiming: () => setTracerTiming,
  setUnhandledErrorLogLevel: () => setUnhandledErrorLogLevel,
  span: () => span3,
  succeed: () => succeed13,
  succeedContext: () => succeedContext2,
  suspend: () => suspend4,
  sync: () => sync8,
  syncContext: () => syncContext2,
  tap: () => tap4,
  tapError: () => tapError4,
  tapErrorCause: () => tapErrorCause4,
  toRuntime: () => toRuntime2,
  toRuntimeWithMemoMap: () => toRuntimeWithMemoMap2,
  unwrapEffect: () => unwrapEffect2,
  unwrapScoped: () => unwrapScoped2,
  withParentSpan: () => withParentSpan4,
  withSpan: () => withSpan4,
  zipWith: () => zipWith9
});

// ../node_modules/effect/dist/esm/internal/layer/circular.js
var minimumLogLevel = (level) => scopedDiscard(fiberRefLocallyScoped(currentMinimumLogLevel, level));
var withMinimumLogLevel = dual(2, (self, level) => fiberRefLocally(currentMinimumLogLevel, level)(self));
var addLogger = (logger) => scopedDiscard(fiberRefLocallyScopedWith(currentLoggers, add4(logger)));
var addLoggerEffect = (effect4) => unwrapEffect(map11(effect4, addLogger));
var addLoggerScoped = (effect4) => unwrapScoped(map11(effect4, addLogger));
var removeLogger = (logger) => scopedDiscard(fiberRefLocallyScopedWith(currentLoggers, remove5(logger)));
var replaceLogger = dual(2, (self, that) => flatMap14(removeLogger(self), () => addLogger(that)));
var replaceLoggerEffect = dual(2, (self, that) => flatMap14(removeLogger(self), () => addLoggerEffect(that)));
var replaceLoggerScoped = dual(2, (self, that) => flatMap14(removeLogger(self), () => addLoggerScoped(that)));
var addSupervisor = (supervisor) => scopedDiscard(fiberRefLocallyScopedWith(currentSupervisor, (current2) => new Zip(current2, supervisor)));
var enableCooperativeYielding = scopedDiscard(withRuntimeFlagsScoped(enable(CooperativeYielding)));
var enableInterruption = scopedDiscard(withRuntimeFlagsScoped(enable(Interruption)));
var enableOpSupervision = scopedDiscard(withRuntimeFlagsScoped(enable(OpSupervision)));
var enableRuntimeMetrics = scopedDiscard(withRuntimeFlagsScoped(enable(RuntimeMetrics)));
var enableWindDown = scopedDiscard(withRuntimeFlagsScoped(enable(WindDown)));
var disableCooperativeYielding = scopedDiscard(withRuntimeFlagsScoped(disable(CooperativeYielding)));
var disableInterruption = scopedDiscard(withRuntimeFlagsScoped(disable(Interruption)));
var disableOpSupervision = scopedDiscard(withRuntimeFlagsScoped(disable(OpSupervision)));
var disableRuntimeMetrics = scopedDiscard(withRuntimeFlagsScoped(disable(RuntimeMetrics)));
var disableWindDown = scopedDiscard(withRuntimeFlagsScoped(disable(WindDown)));
var setConfigProvider = (configProvider) => scopedDiscard(withConfigProviderScoped(configProvider));
var parentSpan = (span4) => succeedContext(make7(spanTag, span4));
var span2 = (name, options) => scoped2(spanTag, (options == null ? void 0 : options.onEnd) ? tap(makeSpanScoped(name, options), (span4) => addFinalizer((exit3) => options.onEnd(span4, exit3))) : makeSpanScoped(name, options));
var setTracer = (tracer3) => scopedDiscard(withTracerScoped(tracer3));

// ../node_modules/effect/dist/esm/Layer.js
var LayerTypeId2 = LayerTypeId;
var MemoMapTypeId2 = MemoMapTypeId;
var isLayer2 = isLayer;
var isFresh2 = isFresh;
var build2 = build;
var buildWithScope2 = buildWithScope;
var catchAll4 = catchAll2;
var catchAllCause4 = catchAllCause2;
var context4 = context2;
var die8 = die6;
var dieSync5 = dieSync3;
var discard2 = discard;
var effect = fromEffect4;
var effectDiscard = fromEffectDiscard;
var effectContext = fromEffectContext;
var empty39 = empty38;
var extendScope2 = extendScope;
var fail12 = fail9;
var failSync5 = failSync3;
var failCause10 = failCause7;
var failCauseSync5 = failCauseSync3;
var flatMap16 = flatMap14;
var flatten10 = flatten8;
var fresh2 = fresh;
var fromFunction3 = fromFunction2;
var launch2 = launch;
var map23 = map21;
var mapError5 = mapError3;
var match18 = match16;
var matchCause4 = matchCause2;
var memoize3 = memoize2;
var merge8 = merge6;
var mergeAll4 = mergeAll2;
var orDie4 = orDie2;
var orElse8 = orElse6;
var passthrough3 = passthrough2;
var project2 = project;
var locallyEffect2 = locallyEffect;
var locally3 = fiberRefLocally2;
var locallyWith2 = fiberRefLocallyWith2;
var locallyScoped2 = fiberRefLocallyScoped2;
var fiberRefLocallyScopedWith3 = fiberRefLocallyScopedWith2;
var retry3 = retry;
var scope4 = scope2;
var scoped4 = scoped2;
var scopedDiscard2 = scopedDiscard;
var scopedContext2 = scopedContext;
var service2 = service;
var succeed13 = succeed10;
var succeedContext2 = succeedContext;
var suspend4 = suspend2;
var sync8 = sync6;
var syncContext2 = syncContext;
var tap4 = tap2;
var tapError4 = tapError2;
var tapErrorCause4 = tapErrorCause2;
var toRuntime2 = toRuntime;
var toRuntimeWithMemoMap2 = toRuntimeWithMemoMap;
var provide3 = provide;
var provideMerge2 = provideMerge;
var zipWith9 = zipWith7;
var unwrapEffect2 = unwrapEffect;
var unwrapScoped2 = unwrapScoped;
var setClock = (clock3) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add2(clockTag, clock3)));
var setConfigProvider2 = setConfigProvider;
var parentSpan2 = parentSpan;
var setRequestBatching = (requestBatching) => scopedDiscard2(fiberRefLocallyScoped(currentRequestBatching, requestBatching));
var setRequestCaching = (requestCaching) => scopedDiscard2(fiberRefLocallyScoped(currentCacheEnabled, requestCaching));
var setRequestCache = (cache) => scopedDiscard2(isEffect(cache) ? flatMap10(cache, (x) => fiberRefLocallyScoped(currentCache, x)) : fiberRefLocallyScoped(currentCache, cache));
var setScheduler = (scheduler) => scopedDiscard2(fiberRefLocallyScoped(currentScheduler, scheduler));
var span3 = span2;
var setTracer2 = setTracer;
var setTracerEnabled = (enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerEnabled, enabled2));
var setTracerTiming = (enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerTimingEnabled, enabled2));
var setUnhandledErrorLogLevel = (level) => scopedDiscard2(fiberRefLocallyScoped(currentUnhandledErrorLogLevel, level));
var withSpan4 = withSpan2;
var withParentSpan4 = withParentSpan2;
var makeMemoMap2 = makeMemoMap;
var buildWithMemoMap2 = buildWithMemoMap;

// ../node_modules/effect/dist/esm/PubSub.js
var PubSub_exports = {};
__export(PubSub_exports, {
  awaitShutdown: () => awaitShutdown3,
  bounded: () => bounded4,
  capacity: () => capacity4,
  dropping: () => dropping3,
  isEmpty: () => isEmpty14,
  isFull: () => isFull4,
  isShutdown: () => isShutdown3,
  publish: () => publish2,
  publishAll: () => publishAll2,
  shutdown: () => shutdown3,
  size: () => size17,
  sliding: () => sliding3,
  subscribe: () => subscribe2,
  unbounded: () => unbounded4
});

// ../node_modules/effect/dist/esm/internal/queue.js
var EnqueueSymbolKey = "effect/QueueEnqueue";
var EnqueueTypeId = Symbol.for(EnqueueSymbolKey);
var DequeueSymbolKey = "effect/QueueDequeue";
var DequeueTypeId = Symbol.for(DequeueSymbolKey);
var QueueStrategySymbolKey = "effect/QueueStrategy";
var QueueStrategyTypeId = Symbol.for(QueueStrategySymbolKey);
var BackingQueueSymbolKey = "effect/BackingQueue";
var BackingQueueTypeId = Symbol.for(BackingQueueSymbolKey);
var queueStrategyVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var backingQueueVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var enqueueVariance = {
  /* c8 ignore next */
  _In: (_) => _
};
var dequeueVariance = {
  /* c8 ignore next */
  _Out: (_) => _
};
var _a49, _b15;
var QueueImpl = class {
  constructor(queue, takers, shutdownHook, shutdownFlag, strategy) {
    __publicField(this, "queue");
    __publicField(this, "takers");
    __publicField(this, "shutdownHook");
    __publicField(this, "shutdownFlag");
    __publicField(this, "strategy");
    __publicField(this, _a49, enqueueVariance);
    __publicField(this, _b15, dequeueVariance);
    this.queue = queue;
    this.takers = takers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  capacity() {
    return this.queue.capacity();
  }
  get size() {
    return suspend(() => catchAll(this.unsafeSize(), () => interrupt2));
  }
  unsafeSize() {
    if (get5(this.shutdownFlag)) {
      return none2();
    }
    return some2(this.queue.length() - length2(this.takers) + this.strategy.surplusSize());
  }
  get isEmpty() {
    return map11(this.size, (size38) => size38 <= 0);
  }
  get isFull() {
    return map11(this.size, (size38) => size38 >= this.capacity());
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      pipe(this.shutdownFlag, set2(true));
      return pipe(forEachConcurrentDiscard(unsafePollAll(this.takers), (d) => deferredInterruptWith(d, state.id()), false, false), zipRight(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid);
    }));
  }
  get isShutdown() {
    return sync(() => get5(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  isActive() {
    return !get5(this.shutdownFlag);
  }
  unsafeOffer(value8) {
    if (get5(this.shutdownFlag)) {
      return false;
    }
    let noRemaining;
    if (this.queue.length() === 0) {
      const taker = pipe(this.takers, poll2(EmptyMutableQueue));
      if (taker !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, value8);
        noRemaining = true;
      } else {
        noRemaining = false;
      }
    } else {
      noRemaining = false;
    }
    if (noRemaining) {
      return true;
    }
    const succeeded = this.queue.offer(value8);
    unsafeCompleteTakers(this.strategy, this.queue, this.takers);
    return succeeded;
  }
  offer(value8) {
    return suspend(() => {
      if (get5(this.shutdownFlag)) {
        return interrupt2;
      }
      let noRemaining;
      if (this.queue.length() === 0) {
        const taker = pipe(this.takers, poll2(EmptyMutableQueue));
        if (taker !== EmptyMutableQueue) {
          unsafeCompleteDeferred(taker, value8);
          noRemaining = true;
        } else {
          noRemaining = false;
        }
      } else {
        noRemaining = false;
      }
      if (noRemaining) {
        return succeed(true);
      }
      const succeeded = this.queue.offer(value8);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return succeeded ? succeed(true) : this.strategy.handleSurplus([value8], this.queue, this.takers, this.shutdownFlag);
    });
  }
  offerAll(iterable) {
    return suspend(() => {
      if (get5(this.shutdownFlag)) {
        return interrupt2;
      }
      const values13 = fromIterable(iterable);
      const pTakers = this.queue.length() === 0 ? fromIterable(unsafePollN(this.takers, values13.length)) : empty2;
      const [forTakers, remaining] = pipe(values13, splitAt(pTakers.length));
      for (let i = 0; i < pTakers.length; i++) {
        const taker = pTakers[i];
        const item = forTakers[i];
        unsafeCompleteDeferred(taker, item);
      }
      if (remaining.length === 0) {
        return succeed(true);
      }
      const surplus = this.queue.offerAll(remaining);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return isEmpty(surplus) ? succeed(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);
    });
  }
  get take() {
    return withFiberRuntime((state) => {
      if (get5(this.shutdownFlag)) {
        return interrupt2;
      }
      const item = this.queue.poll(EmptyMutableQueue);
      if (item !== EmptyMutableQueue) {
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return succeed(item);
      } else {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          pipe(this.takers, offer(deferred));
          unsafeCompleteTakers(this.strategy, this.queue, this.takers);
          return get5(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => {
          return sync(() => unsafeRemove(this.takers, deferred));
        }));
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      return get5(this.shutdownFlag) ? interrupt2 : sync(() => {
        const values13 = this.queue.pollUpTo(Number.POSITIVE_INFINITY);
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return fromIterable2(values13);
      });
    });
  }
  takeUpTo(max9) {
    return suspend(() => get5(this.shutdownFlag) ? interrupt2 : sync(() => {
      const values13 = this.queue.pollUpTo(max9);
      this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
      return fromIterable2(values13);
    }));
  }
  takeBetween(min7, max9) {
    return suspend(() => takeRemainderLoop(this, min7, max9, empty5()));
  }
};
_a49 = EnqueueTypeId, _b15 = DequeueTypeId;
var takeRemainderLoop = (self, min7, max9, acc) => {
  if (max9 < min7) {
    return succeed(acc);
  }
  return pipe(takeUpTo(self, max9), flatMap10((bs) => {
    const remaining = min7 - bs.length;
    if (remaining === 1) {
      return pipe(take3(self), map11((b) => pipe(acc, appendAll2(bs), append2(b))));
    }
    if (remaining > 1) {
      return pipe(take3(self), flatMap10((b) => takeRemainderLoop(self, remaining - 1, max9 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
    }
    return succeed(pipe(acc, appendAll2(bs)));
  }));
};
var isQueue = (u) => isEnqueue(u) && isDequeue(u);
var isEnqueue = (u) => hasProperty(u, EnqueueTypeId);
var isDequeue = (u) => hasProperty(u, DequeueTypeId);
var bounded2 = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap10((queue) => make57(backingQueueFromMutableQueue(queue), backPressureStrategy())));
var dropping = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap10((queue) => make57(backingQueueFromMutableQueue(queue), droppingStrategy())));
var sliding = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap10((queue) => make57(backingQueueFromMutableQueue(queue), slidingStrategy())));
var unbounded2 = () => pipe(sync(() => unbounded()), flatMap10((queue) => make57(backingQueueFromMutableQueue(queue), droppingStrategy())));
var unsafeMake11 = (queue, takers, shutdownHook, shutdownFlag, strategy) => {
  return new QueueImpl(queue, takers, shutdownHook, shutdownFlag, strategy);
};
var make57 = (queue, strategy) => pipe(deferredMake(), map11((deferred) => unsafeMake11(queue, unbounded(), deferred, make13(false), strategy)));
var _a50;
var BackingQueueFromMutableQueue = class {
  constructor(mutable) {
    __publicField(this, "mutable");
    __publicField(this, _a50, backingQueueVariance);
    this.mutable = mutable;
  }
  poll(def) {
    return poll2(this.mutable, def);
  }
  pollUpTo(limit) {
    return pollUpTo(this.mutable, limit);
  }
  offerAll(elements) {
    return offerAll(this.mutable, elements);
  }
  offer(element) {
    return offer(this.mutable, element);
  }
  capacity() {
    return capacity(this.mutable);
  }
  length() {
    return length2(this.mutable);
  }
};
_a50 = BackingQueueTypeId;
var backingQueueFromMutableQueue = (mutable) => new BackingQueueFromMutableQueue(mutable);
var capacity2 = (self) => self.capacity();
var size15 = (self) => self.size;
var isFull2 = (self) => self.isFull;
var isEmpty12 = (self) => self.isEmpty;
var isShutdown = (self) => self.isShutdown;
var awaitShutdown = (self) => self.awaitShutdown;
var shutdown = (self) => self.shutdown;
var offer2 = dual(2, (self, value8) => self.offer(value8));
var unsafeOffer = dual(2, (self, value8) => self.unsafeOffer(value8));
var offerAll2 = dual(2, (self, iterable) => self.offerAll(iterable));
var poll5 = (self) => map11(self.takeUpTo(1), head2);
var take3 = (self) => self.take;
var takeAll = (self) => self.takeAll;
var takeUpTo = dual(2, (self, max9) => self.takeUpTo(max9));
var takeBetween = dual(3, (self, min7, max9) => self.takeBetween(min7, max9));
var takeN = dual(2, (self, n) => self.takeBetween(n, n));
var backPressureStrategy = () => new BackPressureStrategy();
var droppingStrategy = () => new DroppingStrategy();
var slidingStrategy = () => new SlidingStrategy();
var _a51;
var BackPressureStrategy = class {
  constructor() {
    __publicField(this, _a51, queueStrategyVariance);
    __publicField(this, "putters", unbounded());
  }
  surplusSize() {
    return length2(this.putters);
  }
  onCompleteTakersWithEmptyQueue(takers) {
    while (!isEmpty8(this.putters) && !isEmpty8(takers)) {
      const taker = poll2(takers, void 0);
      const putter = poll2(this.putters, void 0);
      if (putter[2]) {
        unsafeCompleteDeferred(putter[1], true);
      }
      unsafeCompleteDeferred(taker, putter[0]);
    }
  }
  get shutdown() {
    return pipe(fiberId, flatMap10((fiberId5) => pipe(sync(() => unsafePollAll(this.putters)), flatMap10((putters) => forEachConcurrentDiscard(putters, ([_, deferred, isLastItem]) => isLastItem ? pipe(deferredInterruptWith(deferred, fiberId5), asVoid) : void_, false, false)))));
  }
  handleSurplus(iterable, queue, takers, isShutdown9) {
    return withFiberRuntime((state) => {
      const deferred = deferredUnsafeMake(state.id());
      return pipe(suspend(() => {
        this.unsafeOffer(iterable, deferred);
        this.unsafeOnQueueEmptySpace(queue, takers);
        unsafeCompleteTakers(this, queue, takers);
        return get5(isShutdown9) ? interrupt2 : deferredAwait(deferred);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnQueueEmptySpace(queue, takers) {
    let keepPolling = true;
    while (keepPolling && (queue.capacity() === Number.POSITIVE_INFINITY || queue.length() < queue.capacity())) {
      const putter = pipe(this.putters, poll2(EmptyMutableQueue));
      if (putter === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const offered = queue.offer(putter[0]);
        if (offered && putter[2]) {
          unsafeCompleteDeferred(putter[1], true);
        } else if (!offered) {
          unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), prepend2(putter)));
        }
        unsafeCompleteTakers(this, queue, takers);
      }
    }
  }
  unsafeOffer(iterable, deferred) {
    const stuff = fromIterable(iterable);
    for (let i = 0; i < stuff.length; i++) {
      const value8 = stuff[i];
      if (i === stuff.length - 1) {
        pipe(this.putters, offer([value8, deferred, true]));
      } else {
        pipe(this.putters, offer([value8, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), filter2(([, _]) => _ !== deferred)));
  }
};
_a51 = QueueStrategyTypeId;
var _a52;
var DroppingStrategy = class {
  constructor() {
    __publicField(this, _a52, queueStrategyVariance);
  }
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_;
  }
  onCompleteTakersWithEmptyQueue() {
  }
  handleSurplus(_iterable, _queue, _takers, _isShutdown) {
    return succeed(false);
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
  }
};
_a52 = QueueStrategyTypeId;
var _a53;
var SlidingStrategy = class {
  constructor() {
    __publicField(this, _a53, queueStrategyVariance);
  }
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_;
  }
  onCompleteTakersWithEmptyQueue() {
  }
  handleSurplus(iterable, queue, takers, _isShutdown) {
    return sync(() => {
      this.unsafeOffer(queue, iterable);
      unsafeCompleteTakers(this, queue, takers);
      return true;
    });
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
  }
  unsafeOffer(queue, iterable) {
    const iterator = iterable[Symbol.iterator]();
    let next6;
    let offering = true;
    while (!(next6 = iterator.next()).done && offering) {
      if (queue.capacity() === 0) {
        return;
      }
      queue.poll(EmptyMutableQueue);
      offering = queue.offer(next6.value);
    }
  }
};
_a53 = QueueStrategyTypeId;
var unsafeCompleteDeferred = (deferred, a) => {
  return deferredUnsafeDone(deferred, succeed(a));
};
var unsafeOfferAll = (queue, as16) => {
  return pipe(queue, offerAll(as16));
};
var unsafePollAll = (queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
};
var unsafePollN = (queue, max9) => {
  return pipe(queue, pollUpTo(max9));
};
var unsafeRemove = (queue, a) => {
  unsafeOfferAll(queue, pipe(unsafePollAll(queue), filter2((b) => a !== b)));
};
var unsafeCompleteTakers = (strategy, queue, takers) => {
  let keepPolling = true;
  while (keepPolling && queue.length() !== 0) {
    const taker = pipe(takers, poll2(EmptyMutableQueue));
    if (taker !== EmptyMutableQueue) {
      const element = queue.poll(EmptyMutableQueue);
      if (element !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, element);
        strategy.unsafeOnQueueEmptySpace(queue, takers);
      } else {
        unsafeOfferAll(takers, pipe(unsafePollAll(takers), prepend2(taker)));
      }
      keepPolling = true;
    } else {
      keepPolling = false;
    }
  }
  if (keepPolling && queue.length() === 0 && !isEmpty8(takers)) {
    strategy.onCompleteTakersWithEmptyQueue(takers);
  }
};

// ../node_modules/effect/dist/esm/internal/pubsub.js
var AbsentValue = Symbol.for("effect/PubSub/AbsentValue");
var addSubscribers = (subscription, pollers) => (subscribers) => {
  if (!subscribers.has(subscription)) {
    subscribers.set(subscription, /* @__PURE__ */ new Set());
  }
  const set22 = subscribers.get(subscription);
  set22.add(pollers);
};
var removeSubscribers = (subscription, pollers) => (subscribers) => {
  if (!subscribers.has(subscription)) {
    return;
  }
  const set22 = subscribers.get(subscription);
  set22.delete(pollers);
  if (set22.size === 0) {
    subscribers.delete(subscription);
  }
};
var bounded3 = (requestedCapacity) => pipe(sync(() => makeBoundedPubSub(requestedCapacity)), flatMap10((atomicPubSub) => makePubSub(atomicPubSub, new BackPressureStrategy2())));
var dropping2 = (requestedCapacity) => pipe(sync(() => makeBoundedPubSub(requestedCapacity)), flatMap10((atomicPubSub) => makePubSub(atomicPubSub, new DroppingStrategy2())));
var sliding2 = (requestedCapacity) => pipe(sync(() => makeBoundedPubSub(requestedCapacity)), flatMap10((atomicPubSub) => makePubSub(atomicPubSub, new SlidingStrategy2())));
var unbounded3 = () => pipe(sync(() => makeUnboundedPubSub()), flatMap10((atomicPubSub) => makePubSub(atomicPubSub, new DroppingStrategy2())));
var capacity3 = (self) => self.capacity();
var size16 = (self) => self.size;
var isFull3 = (self) => self.isFull;
var isEmpty13 = (self) => self.isEmpty;
var shutdown2 = (self) => self.shutdown;
var isShutdown2 = (self) => self.isShutdown;
var awaitShutdown2 = (self) => self.awaitShutdown;
var publish = dual(2, (self, value8) => self.publish(value8));
var publishAll = dual(2, (self, elements) => self.publishAll(elements));
var subscribe = (self) => self.subscribe;
var makeBoundedPubSub = (requestedCapacity) => {
  ensureCapacity(requestedCapacity);
  if (requestedCapacity === 1) {
    return new BoundedPubSubSingle();
  } else if (nextPow2(requestedCapacity) === requestedCapacity) {
    return new BoundedPubSubPow2(requestedCapacity);
  } else {
    return new BoundedPubSubArb(requestedCapacity);
  }
};
var makeUnboundedPubSub = () => {
  return new UnboundedPubSub();
};
var makeSubscription = (pubsub, subscribers, strategy) => map11(deferredMake(), (deferred) => unsafeMakeSubscription(pubsub, subscribers, pubsub.subscribe(), unbounded(), deferred, make13(false), strategy));
var unsafeMakeSubscription = (pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) => {
  return new SubscriptionImpl(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy);
};
var BoundedPubSubArb = class {
  constructor(requestedCapacity) {
    __publicField(this, "array");
    __publicField(this, "publisherIndex", 0);
    __publicField(this, "subscribers");
    __publicField(this, "subscriberCount", 0);
    __publicField(this, "subscribersIndex", 0);
    __publicField(this, "capacity");
    this.array = Array.from({
      length: requestedCapacity
    });
    this.subscribers = Array.from({
      length: requestedCapacity
    });
    this.capacity = requestedCapacity;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value8) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index = this.publisherIndex % this.capacity;
      this.array[index] = value8;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    return true;
  }
  publishAll(elements) {
    const chunk7 = fromIterable2(elements);
    const n = chunk7.length;
    const size38 = this.publisherIndex - this.subscribersIndex;
    const available3 = this.capacity - size38;
    const forPubSub = Math.min(n, available3);
    if (forPubSub === 0) {
      return chunk7;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const a = unsafeGet4(chunk7, iteratorIndex++);
      const index = this.publisherIndex % this.capacity;
      this.array[index] = a;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    return drop2(chunk7, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index = this.subscribersIndex % this.capacity;
      this.array[index] = AbsentValue;
      this.subscribers[index] = 0;
      this.subscribersIndex += 1;
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubArbSubscription(this, this.publisherIndex, false);
  }
};
var BoundedPubSubArbSubscription = class {
  constructor(self, subscriberIndex, unsubscribed) {
    __publicField(this, "self");
    __publicField(this, "subscriberIndex");
    __publicField(this, "unsubscribed");
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index = this.subscriberIndex % this.self.capacity;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n) {
    if (this.unsubscribed) {
      return empty5();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size38 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n, size38);
    if (toPoll <= 0) {
      return empty5();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index = this.subscriberIndex % this.self.capacity;
      const a = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(a);
      this.subscriberIndex += 1;
    }
    return fromIterable2(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index = this.subscriberIndex % this.self.capacity;
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
};
var BoundedPubSubPow2 = class {
  constructor(requestedCapacity) {
    __publicField(this, "array");
    __publicField(this, "mask");
    __publicField(this, "publisherIndex", 0);
    __publicField(this, "subscribers");
    __publicField(this, "subscriberCount", 0);
    __publicField(this, "subscribersIndex", 0);
    __publicField(this, "capacity");
    this.array = Array.from({
      length: requestedCapacity
    });
    this.mask = requestedCapacity - 1;
    this.subscribers = Array.from({
      length: requestedCapacity
    });
    this.capacity = requestedCapacity;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value8) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index = this.publisherIndex & this.mask;
      this.array[index] = value8;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    return true;
  }
  publishAll(elements) {
    const chunk7 = fromIterable2(elements);
    const n = chunk7.length;
    const size38 = this.publisherIndex - this.subscribersIndex;
    const available3 = this.capacity - size38;
    const forPubSub = Math.min(n, available3);
    if (forPubSub === 0) {
      return chunk7;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const elem = unsafeGet4(chunk7, iteratorIndex++);
      const index = this.publisherIndex & this.mask;
      this.array[index] = elem;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    return drop2(chunk7, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index = this.subscribersIndex & this.mask;
      this.array[index] = AbsentValue;
      this.subscribers[index] = 0;
      this.subscribersIndex += 1;
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubPow2Subscription(this, this.publisherIndex, false);
  }
};
var BoundedPubSubPow2Subscription = class {
  constructor(self, subscriberIndex, unsubscribed) {
    __publicField(this, "self");
    __publicField(this, "subscriberIndex");
    __publicField(this, "unsubscribed");
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n) {
    if (this.unsubscribed) {
      return empty5();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size38 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n, size38);
    if (toPoll <= 0) {
      return empty5();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(elem);
      this.subscriberIndex += 1;
    }
    return fromIterable2(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index = this.subscriberIndex & this.self.mask;
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
};
var BoundedPubSubSingle = class {
  constructor() {
    __publicField(this, "publisherIndex", 0);
    __publicField(this, "subscriberCount", 0);
    __publicField(this, "subscribers", 0);
    __publicField(this, "value", AbsentValue);
    __publicField(this, "capacity", 1);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  isEmpty() {
    return this.subscribers === 0;
  }
  isFull() {
    return !this.isEmpty();
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  publish(value8) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      this.value = value8;
      this.subscribers = this.subscriberCount;
      this.publisherIndex += 1;
    }
    return true;
  }
  publishAll(elements) {
    const chunk7 = fromIterable2(elements);
    if (isEmpty(chunk7)) {
      return chunk7;
    }
    if (this.publish(unsafeHead(chunk7))) {
      return drop2(chunk7, 1);
    } else {
      return chunk7;
    }
  }
  slide() {
    if (this.isFull()) {
      this.subscribers = 0;
      this.value = AbsentValue;
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubSingleSubscription(this, this.publisherIndex, false);
  }
};
var BoundedPubSubSingleSubscription = class {
  constructor(self, subscriberIndex, unsubscribed) {
    __publicField(this, "self");
    __publicField(this, "subscriberIndex");
    __publicField(this, "unsubscribed");
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.subscribers === 0 || this.subscriberIndex === this.self.publisherIndex;
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  poll(default_) {
    if (this.isEmpty()) {
      return default_;
    }
    const elem = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return elem;
  }
  pollUpTo(n) {
    if (this.isEmpty() || n < 1) {
      return empty5();
    }
    const a = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return of2(a);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      if (this.subscriberIndex !== this.self.publisherIndex) {
        this.self.subscribers -= 1;
        if (this.self.subscribers === 0) {
          this.self.value = AbsentValue;
        }
      }
    }
  }
};
var UnboundedPubSub = class {
  constructor() {
    __publicField(this, "publisherHead", {
      value: AbsentValue,
      subscribers: 0,
      next: null
    });
    __publicField(this, "publisherTail", this.publisherHead);
    __publicField(this, "publisherIndex", 0);
    __publicField(this, "subscribersIndex", 0);
    __publicField(this, "capacity", Number.MAX_SAFE_INTEGER);
  }
  isEmpty() {
    return this.publisherHead === this.publisherTail;
  }
  isFull() {
    return false;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value8) {
    const subscribers = this.publisherTail.subscribers;
    if (subscribers !== 0) {
      this.publisherTail.next = {
        value: value8,
        subscribers,
        next: null
      };
      this.publisherTail = this.publisherTail.next;
      this.publisherIndex += 1;
    }
    return true;
  }
  publishAll(elements) {
    for (const a of elements) {
      this.publish(a);
    }
    return empty5();
  }
  slide() {
    if (this.publisherHead !== this.publisherTail) {
      this.publisherHead = this.publisherHead.next;
      this.publisherHead.value = AbsentValue;
      this.subscribersIndex += 1;
    }
  }
  subscribe() {
    this.publisherTail.subscribers += 1;
    return new UnboundedPubSubSubscription(this, this.publisherTail, this.publisherIndex, false);
  }
};
var UnboundedPubSubSubscription = class {
  constructor(self, subscriberHead, subscriberIndex, unsubscribed) {
    __publicField(this, "self");
    __publicField(this, "subscriberHead");
    __publicField(this, "subscriberIndex");
    __publicField(this, "unsubscribed");
    this.self = self;
    this.subscriberHead = subscriberHead;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    if (this.unsubscribed) {
      return true;
    }
    let empty57 = true;
    let loop5 = true;
    while (loop5) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop5 = false;
      } else {
        if (this.subscriberHead.next.value !== AbsentValue) {
          empty57 = false;
          loop5 = false;
        } else {
          this.subscriberHead = this.subscriberHead.next;
          this.subscriberIndex += 1;
        }
      }
    }
    return empty57;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    let loop5 = true;
    let polled = default_;
    while (loop5) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop5 = false;
      } else {
        const elem = this.subscriberHead.next.value;
        if (elem !== AbsentValue) {
          polled = elem;
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          loop5 = false;
        }
        this.subscriberHead = this.subscriberHead.next;
        this.subscriberIndex += 1;
      }
    }
    return polled;
  }
  pollUpTo(n) {
    const builder = [];
    const default_ = AbsentValue;
    let i = 0;
    while (i !== n) {
      const a = this.poll(default_);
      if (a === default_) {
        i = n;
      } else {
        builder.push(a);
        i += 1;
      }
    }
    return fromIterable2(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.publisherTail.subscribers -= 1;
      while (this.subscriberHead !== this.self.publisherTail) {
        if (this.subscriberHead.next.value !== AbsentValue) {
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
        }
        this.subscriberHead = this.subscriberHead.next;
      }
    }
  }
};
var _a54;
var SubscriptionImpl = class {
  constructor(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) {
    __publicField(this, "pubsub");
    __publicField(this, "subscribers");
    __publicField(this, "subscription");
    __publicField(this, "pollers");
    __publicField(this, "shutdownHook");
    __publicField(this, "shutdownFlag");
    __publicField(this, "strategy");
    __publicField(this, _a54, dequeueVariance);
    this.pubsub = pubsub;
    this.subscribers = subscribers;
    this.subscription = subscription;
    this.pollers = pollers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  capacity() {
    return this.pubsub.capacity;
  }
  isActive() {
    return !get5(this.shutdownFlag);
  }
  get size() {
    return suspend(() => get5(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size()));
  }
  unsafeSize() {
    if (get5(this.shutdownFlag)) {
      return none2();
    }
    return some2(this.subscription.size());
  }
  get isFull() {
    return map11(this.size, (size38) => size38 === this.capacity());
  }
  get isEmpty() {
    return map11(this.size, (size38) => size38 === 0);
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      set2(this.shutdownFlag, true);
      return pipe(forEachParUnbounded(unsafePollAllQueue(this.pollers), (d) => deferredInterruptWith(d, state.id()), false), zipRight(sync(() => {
        this.subscribers.delete(this.subscription);
        this.subscription.unsubscribe();
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      })), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid);
    }));
  }
  get isShutdown() {
    return sync(() => get5(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  get take() {
    return withFiberRuntime((state) => {
      if (get5(this.shutdownFlag)) {
        return interrupt2;
      }
      const message = isEmpty8(this.pollers) ? this.subscription.poll(EmptyMutableQueue) : EmptyMutableQueue;
      if (message === EmptyMutableQueue) {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          pipe(this.pollers, offer(deferred));
          pipe(this.subscribers, addSubscribers(this.subscription, this.pollers));
          this.strategy.unsafeCompletePollers(this.pubsub, this.subscribers, this.subscription, this.pollers);
          return get5(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => sync(() => unsafeRemove2(this.pollers, deferred))));
      } else {
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        return succeed(message);
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      if (get5(this.shutdownFlag)) {
        return interrupt2;
      }
      const as16 = isEmpty8(this.pollers) ? unsafePollAllSubscription(this.subscription) : empty5();
      this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      return succeed(as16);
    });
  }
  takeUpTo(max9) {
    return suspend(() => {
      if (get5(this.shutdownFlag)) {
        return interrupt2;
      }
      const as16 = isEmpty8(this.pollers) ? unsafePollN2(this.subscription, max9) : empty5();
      this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      return succeed(as16);
    });
  }
  takeBetween(min7, max9) {
    return suspend(() => takeRemainderLoop2(this, min7, max9, empty5()));
  }
};
_a54 = DequeueTypeId;
var takeRemainderLoop2 = (self, min7, max9, acc) => {
  if (max9 < min7) {
    return succeed(acc);
  }
  return pipe(self.takeUpTo(max9), flatMap10((bs) => {
    const remaining = min7 - bs.length;
    if (remaining === 1) {
      return pipe(self.take, map11((b) => pipe(acc, appendAll2(bs), append2(b))));
    }
    if (remaining > 1) {
      return pipe(self.take, flatMap10((b) => takeRemainderLoop2(self, remaining - 1, max9 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
    }
    return succeed(pipe(acc, appendAll2(bs)));
  }));
};
var _a55, _b16;
var PubSubImpl = class {
  constructor(pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy) {
    __publicField(this, "pubsub");
    __publicField(this, "subscribers");
    __publicField(this, "scope");
    __publicField(this, "shutdownHook");
    __publicField(this, "shutdownFlag");
    __publicField(this, "strategy");
    __publicField(this, _a55, enqueueVariance);
    __publicField(this, _b16, dequeueVariance);
    this.pubsub = pubsub;
    this.subscribers = subscribers;
    this.scope = scope5;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  capacity() {
    return this.pubsub.capacity;
  }
  get size() {
    return suspend(() => get5(this.shutdownFlag) ? interrupt2 : sync(() => this.pubsub.size()));
  }
  unsafeSize() {
    if (get5(this.shutdownFlag)) {
      return none2();
    }
    return some2(this.pubsub.size());
  }
  get isFull() {
    return map11(this.size, (size38) => size38 === this.capacity());
  }
  get isEmpty() {
    return map11(this.size, (size38) => size38 === 0);
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  get isShutdown() {
    return sync(() => get5(this.shutdownFlag));
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      pipe(this.shutdownFlag, set2(true));
      return pipe(this.scope.close(exitInterrupt(state.id())), zipRight(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid);
    }));
  }
  publish(value8) {
    return suspend(() => {
      if (get5(this.shutdownFlag)) {
        return interrupt2;
      }
      if (this.pubsub.publish(value8)) {
        this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
        return succeed(true);
      }
      return this.strategy.handleSurplus(this.pubsub, this.subscribers, of2(value8), this.shutdownFlag);
    });
  }
  isActive() {
    return !get5(this.shutdownFlag);
  }
  unsafeOffer(value8) {
    if (get5(this.shutdownFlag)) {
      return false;
    }
    if (this.pubsub.publish(value8)) {
      this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
      return true;
    }
    return false;
  }
  publishAll(elements) {
    return suspend(() => {
      if (get5(this.shutdownFlag)) {
        return interrupt2;
      }
      const surplus = unsafePublishAll(this.pubsub, elements);
      this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
      if (isEmpty(surplus)) {
        return succeed(true);
      }
      return this.strategy.handleSurplus(this.pubsub, this.subscribers, surplus, this.shutdownFlag);
    });
  }
  get subscribe() {
    const acquire3 = tap(all5([this.scope.fork(sequential2), makeSubscription(this.pubsub, this.subscribers, this.strategy)]), (tuple4) => tuple4[0].addFinalizer(() => tuple4[1].shutdown));
    return map11(acquireRelease(acquire3, (tuple4, exit3) => tuple4[0].close(exit3)), (tuple4) => tuple4[1]);
  }
  offer(value8) {
    return this.publish(value8);
  }
  offerAll(elements) {
    return this.publishAll(elements);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
_a55 = EnqueueTypeId, _b16 = DequeueTypeId;
var makePubSub = (pubsub, strategy) => flatMap10(scopeMake(), (scope5) => map11(deferredMake(), (deferred) => unsafeMakePubSub(pubsub, /* @__PURE__ */ new Map(), scope5, deferred, make13(false), strategy)));
var unsafeMakePubSub = (pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy) => {
  return new PubSubImpl(pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy);
};
var ensureCapacity = (capacity10) => {
  if (capacity10 <= 0) {
    throw new InvalidPubSubCapacityException(`Cannot construct PubSub with capacity of ${capacity10}`);
  }
};
var unsafeCompleteDeferred2 = (deferred, a) => {
  deferredUnsafeDone(deferred, succeed(a));
};
var unsafeOfferAll2 = (queue, as16) => {
  return pipe(queue, offerAll(as16));
};
var unsafePollAllQueue = (queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
};
var unsafePollAllSubscription = (subscription) => {
  return subscription.pollUpTo(Number.POSITIVE_INFINITY);
};
var unsafePollN2 = (subscription, max9) => {
  return subscription.pollUpTo(max9);
};
var unsafePublishAll = (pubsub, as16) => {
  return pubsub.publishAll(as16);
};
var unsafeRemove2 = (queue, value8) => {
  unsafeOfferAll2(queue, pipe(unsafePollAllQueue(queue), filter2((elem) => elem !== value8)));
};
var BackPressureStrategy2 = class {
  constructor() {
    __publicField(this, "publishers", unbounded());
  }
  get shutdown() {
    return flatMap10(fiberId, (fiberId5) => flatMap10(sync(() => unsafePollAllQueue(this.publishers)), (publishers) => forEachConcurrentDiscard(publishers, ([_, deferred, last8]) => last8 ? pipe(deferredInterruptWith(deferred, fiberId5), asVoid) : void_, false, false)));
  }
  handleSurplus(pubsub, subscribers, elements, isShutdown9) {
    return withFiberRuntime((state) => {
      const deferred = deferredUnsafeMake(state.id());
      return pipe(suspend(() => {
        this.unsafeOffer(elements, deferred);
        this.unsafeOnPubSubEmptySpace(pubsub, subscribers);
        this.unsafeCompleteSubscribers(pubsub, subscribers);
        return get5(isShutdown9) ? interrupt2 : deferredAwait(deferred);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnPubSubEmptySpace(pubsub, subscribers) {
    let keepPolling = true;
    while (keepPolling && !pubsub.isFull()) {
      const publisher = pipe(this.publishers, poll2(EmptyMutableQueue));
      if (publisher === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const published = pubsub.publish(publisher[0]);
        if (published && publisher[2]) {
          unsafeCompleteDeferred2(publisher[1], true);
        } else if (!published) {
          unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), prepend2(publisher)));
        }
        this.unsafeCompleteSubscribers(pubsub, subscribers);
      }
    }
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeOffer(elements, deferred) {
    const iterator = elements[Symbol.iterator]();
    let next6 = iterator.next();
    if (!next6.done) {
      while (1) {
        const value8 = next6.value;
        next6 = iterator.next();
        if (next6.done) {
          pipe(this.publishers, offer([value8, deferred, true]));
          break;
        }
        pipe(this.publishers, offer([value8, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), filter2(([_, a]) => a !== deferred)));
  }
};
var DroppingStrategy2 = class {
  get shutdown() {
    return void_;
  }
  handleSurplus(_pubsub, _subscribers, _elements, _isShutdown) {
    return succeed(false);
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
};
var SlidingStrategy2 = class {
  get shutdown() {
    return void_;
  }
  handleSurplus(pubsub, subscribers, elements, _isShutdown) {
    return sync(() => {
      this.unsafeSlidingPublish(pubsub, elements);
      this.unsafeCompleteSubscribers(pubsub, subscribers);
      return true;
    });
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeSlidingPublish(pubsub, elements) {
    const it = elements[Symbol.iterator]();
    let next6 = it.next();
    if (!next6.done && pubsub.capacity > 0) {
      let a = next6.value;
      let loop5 = true;
      while (loop5) {
        pubsub.slide();
        const pub = pubsub.publish(a);
        if (pub && (next6 = it.next()) && !next6.done) {
          a = next6.value;
        } else if (pub) {
          loop5 = false;
        }
      }
    }
  }
};
var unsafeStrategyCompletePollers = (strategy, pubsub, subscribers, subscription, pollers) => {
  let keepPolling = true;
  while (keepPolling && !subscription.isEmpty()) {
    const poller = pipe(pollers, poll2(EmptyMutableQueue));
    if (poller === EmptyMutableQueue) {
      pipe(subscribers, removeSubscribers(subscription, pollers));
      if (isEmpty8(pollers)) {
        keepPolling = false;
      } else {
        pipe(subscribers, addSubscribers(subscription, pollers));
      }
    } else {
      const pollResult = subscription.poll(EmptyMutableQueue);
      if (pollResult === EmptyMutableQueue) {
        unsafeOfferAll2(pollers, pipe(unsafePollAllQueue(pollers), prepend2(poller)));
      } else {
        unsafeCompleteDeferred2(poller, pollResult);
        strategy.unsafeOnPubSubEmptySpace(pubsub, subscribers);
      }
    }
  }
};
var unsafeStrategyCompleteSubscribers = (strategy, pubsub, subscribers) => {
  for (const [subscription, pollersSet] of subscribers) {
    for (const pollers of pollersSet) {
      strategy.unsafeCompletePollers(pubsub, subscribers, subscription, pollers);
    }
  }
};

// ../node_modules/effect/dist/esm/PubSub.js
var bounded4 = bounded3;
var dropping3 = dropping2;
var sliding3 = sliding2;
var unbounded4 = unbounded3;
var capacity4 = capacity3;
var size17 = size16;
var isFull4 = isFull3;
var isEmpty14 = isEmpty13;
var shutdown3 = shutdown2;
var isShutdown3 = isShutdown2;
var awaitShutdown3 = awaitShutdown2;
var publish2 = publish;
var publishAll2 = publishAll;
var subscribe2 = subscribe;

// ../node_modules/effect/dist/esm/Queue.js
var Queue_exports = {};
__export(Queue_exports, {
  BackingQueueTypeId: () => BackingQueueTypeId2,
  DequeueTypeId: () => DequeueTypeId2,
  EnqueueTypeId: () => EnqueueTypeId2,
  QueueStrategyTypeId: () => QueueStrategyTypeId2,
  awaitShutdown: () => awaitShutdown4,
  backPressureStrategy: () => backPressureStrategy2,
  bounded: () => bounded5,
  capacity: () => capacity5,
  dropping: () => dropping4,
  droppingStrategy: () => droppingStrategy2,
  isDequeue: () => isDequeue2,
  isEmpty: () => isEmpty15,
  isEnqueue: () => isEnqueue2,
  isFull: () => isFull5,
  isQueue: () => isQueue2,
  isShutdown: () => isShutdown4,
  make: () => make58,
  offer: () => offer3,
  offerAll: () => offerAll3,
  poll: () => poll6,
  shutdown: () => shutdown4,
  size: () => size18,
  sliding: () => sliding4,
  slidingStrategy: () => slidingStrategy2,
  take: () => take4,
  takeAll: () => takeAll2,
  takeBetween: () => takeBetween2,
  takeN: () => takeN2,
  takeUpTo: () => takeUpTo2,
  unbounded: () => unbounded5,
  unsafeOffer: () => unsafeOffer2
});
var EnqueueTypeId2 = EnqueueTypeId;
var DequeueTypeId2 = DequeueTypeId;
var QueueStrategyTypeId2 = QueueStrategyTypeId;
var BackingQueueTypeId2 = BackingQueueTypeId;
var isQueue2 = isQueue;
var isDequeue2 = isDequeue;
var isEnqueue2 = isEnqueue;
var backPressureStrategy2 = backPressureStrategy;
var droppingStrategy2 = droppingStrategy;
var slidingStrategy2 = slidingStrategy;
var make58 = make57;
var bounded5 = bounded2;
var dropping4 = dropping;
var sliding4 = sliding;
var unbounded5 = unbounded2;
var capacity5 = capacity2;
var size18 = size15;
var isEmpty15 = isEmpty12;
var isFull5 = isFull2;
var isShutdown4 = isShutdown;
var awaitShutdown4 = awaitShutdown;
var shutdown4 = shutdown;
var offer3 = offer2;
var unsafeOffer2 = unsafeOffer;
var offerAll3 = offerAll2;
var poll6 = poll5;
var take4 = take3;
var takeAll2 = takeAll;
var takeUpTo2 = takeUpTo;
var takeBetween2 = takeBetween;
var takeN2 = takeN;

// ../node_modules/effect/dist/esm/internal/opCodes/channelChildExecutorDecision.js
var OP_CONTINUE2 = "Continue";
var OP_CLOSE = "Close";
var OP_YIELD2 = "Yield";

// ../node_modules/effect/dist/esm/internal/channel/childExecutorDecision.js
var ChildExecutorDecisionSymbolKey = "effect/ChannelChildExecutorDecision";
var ChildExecutorDecisionTypeId = Symbol.for(ChildExecutorDecisionSymbolKey);
var proto4 = {
  [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId
};
var Continue = (_) => {
  const op = Object.create(proto4);
  op._tag = OP_CONTINUE2;
  return op;
};
var Close = (value8) => {
  const op = Object.create(proto4);
  op._tag = OP_CLOSE;
  op.value = value8;
  return op;
};
var Yield = (_) => {
  const op = Object.create(proto4);
  op._tag = OP_YIELD2;
  return op;
};
var isChildExecutorDecision = (u) => hasProperty(u, ChildExecutorDecisionTypeId);
var isContinue3 = (self) => self._tag === OP_CONTINUE2;
var isClose = (self) => self._tag === OP_CLOSE;
var isYield = (self) => self._tag === OP_YIELD2;
var match19 = dual(2, (self, {
  onClose,
  onContinue,
  onYield
}) => {
  switch (self._tag) {
    case OP_CONTINUE2: {
      return onContinue();
    }
    case OP_CLOSE: {
      return onClose(self.value);
    }
    case OP_YIELD2: {
      return onYield();
    }
  }
});

// ../node_modules/effect/dist/esm/internal/opCodes/continuation.js
var OP_CONTINUATION_K = "ContinuationK";
var OP_CONTINUATION_FINALIZER = "ContinuationFinalizer";

// ../node_modules/effect/dist/esm/internal/channel/continuation.js
var ContinuationTypeId = Symbol.for("effect/ChannelContinuation");
var continuationVariance = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _,
  /* c8 ignore next */
  _OutErr2: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone2: (_) => _
};
var _a56;
var ContinuationKImpl = class {
  constructor(onSuccess, onHalt) {
    __publicField(this, "onSuccess");
    __publicField(this, "onHalt");
    __publicField(this, "_tag", OP_CONTINUATION_K);
    __publicField(this, _a56, continuationVariance);
    this.onSuccess = onSuccess;
    this.onHalt = onHalt;
  }
  onExit(exit3) {
    return isFailure2(exit3) ? this.onHalt(exit3.cause) : this.onSuccess(exit3.value);
  }
};
_a56 = ContinuationTypeId;
var _a57;
var ContinuationFinalizerImpl = class {
  constructor(finalizer3) {
    __publicField(this, "finalizer");
    __publicField(this, "_tag", OP_CONTINUATION_FINALIZER);
    __publicField(this, _a57, continuationVariance);
    this.finalizer = finalizer3;
  }
};
_a57 = ContinuationTypeId;

// ../node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullStrategy.js
var OP_PULL_AFTER_NEXT = "PullAfterNext";
var OP_PULL_AFTER_ALL_ENQUEUED = "PullAfterAllEnqueued";

// ../node_modules/effect/dist/esm/internal/channel/upstreamPullStrategy.js
var UpstreamPullStrategySymbolKey = "effect/ChannelUpstreamPullStrategy";
var UpstreamPullStrategyTypeId = Symbol.for(UpstreamPullStrategySymbolKey);
var upstreamPullStrategyVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto5 = {
  [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance
};
var PullAfterNext = (emitSeparator) => {
  const op = Object.create(proto5);
  op._tag = OP_PULL_AFTER_NEXT;
  op.emitSeparator = emitSeparator;
  return op;
};
var PullAfterAllEnqueued = (emitSeparator) => {
  const op = Object.create(proto5);
  op._tag = OP_PULL_AFTER_ALL_ENQUEUED;
  op.emitSeparator = emitSeparator;
  return op;
};
var isUpstreamPullStrategy = (u) => hasProperty(u, UpstreamPullStrategyTypeId);
var isPullAfterNext = (self) => self._tag === OP_PULL_AFTER_NEXT;
var isPullAfterAllEnqueued = (self) => self._tag === OP_PULL_AFTER_ALL_ENQUEUED;
var match20 = dual(2, (self, {
  onAllEnqueued,
  onNext
}) => {
  switch (self._tag) {
    case OP_PULL_AFTER_NEXT: {
      return onNext(self.emitSeparator);
    }
    case OP_PULL_AFTER_ALL_ENQUEUED: {
      return onAllEnqueued(self.emitSeparator);
    }
  }
});

// ../node_modules/effect/dist/esm/internal/opCodes/channel.js
var OP_BRACKET_OUT = "BracketOut";
var OP_BRIDGE = "Bridge";
var OP_CONCAT_ALL = "ConcatAll";
var OP_EMIT = "Emit";
var OP_ENSURING = "Ensuring";
var OP_FAIL3 = "Fail";
var OP_FOLD2 = "Fold";
var OP_FROM_EFFECT2 = "FromEffect";
var OP_PIPE_TO = "PipeTo";
var OP_PROVIDE2 = "Provide";
var OP_READ = "Read";
var OP_SUCCEED = "Succeed";
var OP_SUCCEED_NOW = "SucceedNow";
var OP_SUSPEND2 = "Suspend";

// ../node_modules/effect/dist/esm/internal/core-stream.js
var ChannelSymbolKey = "effect/Channel";
var ChannelTypeId3 = Symbol.for(ChannelSymbolKey);
var channelVariance = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _
};
var proto6 = {
  [ChannelTypeId3]: channelVariance,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isChannel = (u) => hasProperty(u, ChannelTypeId3) || isEffect2(u);
var acquireReleaseOut = dual(2, (self, release3) => {
  const op = Object.create(proto6);
  op._tag = OP_BRACKET_OUT;
  op.acquire = () => self;
  op.finalizer = release3;
  return op;
});
var catchAllCause5 = dual(2, (self, f) => {
  const op = Object.create(proto6);
  op._tag = OP_FOLD2;
  op.channel = self;
  op.k = new ContinuationKImpl(succeed14, f);
  return op;
});
var collectElements = (self) => {
  return suspend5(() => {
    const builder = [];
    return flatMap17(pipeTo(self, collectElementsReader(builder)), (value8) => sync9(() => [fromIterable2(builder), value8]));
  });
};
var collectElementsReader = (builder) => readWith({
  onInput: (outElem) => flatMap17(sync9(() => {
    builder.push(outElem);
  }), () => collectElementsReader(builder)),
  onFailure: fail13,
  onDone: succeedNow
});
var concatAll = (channels) => concatAllWith(channels, constVoid, constVoid);
var concatAllWith = (channels, f, g) => {
  const op = Object.create(proto6);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = f;
  op.combineAll = g;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => channels;
  op.k = identity;
  return op;
};
var concatMapWith = dual(4, (self, f, g, h) => {
  const op = Object.create(proto6);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = g;
  op.combineAll = h;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => self;
  op.k = f;
  return op;
});
var concatMapWithCustom = dual(6, (self, f, g, h, onPull, onEmit) => {
  const op = Object.create(proto6);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = g;
  op.combineAll = h;
  op.onPull = onPull;
  op.onEmit = onEmit;
  op.value = () => self;
  op.k = f;
  return op;
});
var embedInput = dual(2, (self, input) => {
  const op = Object.create(proto6);
  op._tag = OP_BRIDGE;
  op.input = input;
  op.channel = self;
  return op;
});
var ensuringWith = dual(2, (self, finalizer3) => {
  const op = Object.create(proto6);
  op._tag = OP_ENSURING;
  op.channel = self;
  op.finalizer = finalizer3;
  return op;
});
var fail13 = (error4) => failCause11(fail7(error4));
var failSync6 = (evaluate3) => failCauseSync6(() => fail7(evaluate3()));
var failCause11 = (cause3) => failCauseSync6(() => cause3);
var failCauseSync6 = (evaluate3) => {
  const op = Object.create(proto6);
  op._tag = OP_FAIL3;
  op.error = evaluate3;
  return op;
};
var flatMap17 = dual(2, (self, f) => {
  const op = Object.create(proto6);
  op._tag = OP_FOLD2;
  op.channel = self;
  op.k = new ContinuationKImpl(f, failCause11);
  return op;
});
var foldCauseChannel = dual(2, (self, options) => {
  const op = Object.create(proto6);
  op._tag = OP_FOLD2;
  op.channel = self;
  op.k = new ContinuationKImpl(options.onSuccess, options.onFailure);
  return op;
});
var fromEffect5 = (effect4) => {
  const op = Object.create(proto6);
  op._tag = OP_FROM_EFFECT2;
  op.effect = () => effect4;
  return op;
};
var pipeTo = dual(2, (self, that) => {
  const op = Object.create(proto6);
  op._tag = OP_PIPE_TO;
  op.left = () => self;
  op.right = () => that;
  return op;
});
var provideContext3 = dual(2, (self, env) => {
  const op = Object.create(proto6);
  op._tag = OP_PROVIDE2;
  op.context = () => env;
  op.inner = self;
  return op;
});
var readOrFail = (error4) => {
  const op = Object.create(proto6);
  op._tag = OP_READ;
  op.more = succeed14;
  op.done = new ContinuationKImpl(() => fail13(error4), () => fail13(error4));
  return op;
};
var readWith = (options) => readWithCause({
  onInput: options.onInput,
  onFailure: (cause3) => match(failureOrCause2(cause3), {
    onLeft: options.onFailure,
    onRight: failCause11
  }),
  onDone: options.onDone
});
var readWithCause = (options) => {
  const op = Object.create(proto6);
  op._tag = OP_READ;
  op.more = options.onInput;
  op.done = new ContinuationKImpl(options.onDone, options.onFailure);
  return op;
};
var succeed14 = (value8) => sync9(() => value8);
var succeedNow = (result) => {
  const op = Object.create(proto6);
  op._tag = OP_SUCCEED_NOW;
  op.terminal = result;
  return op;
};
var suspend5 = (evaluate3) => {
  const op = Object.create(proto6);
  op._tag = OP_SUSPEND2;
  op.channel = evaluate3;
  return op;
};
var sync9 = (evaluate3) => {
  const op = Object.create(proto6);
  op._tag = OP_SUCCEED;
  op.evaluate = evaluate3;
  return op;
};
var void_5 = succeedNow(void 0);
var write = (out) => {
  const op = Object.create(proto6);
  op._tag = OP_EMIT;
  op.out = out;
  return op;
};

// ../node_modules/effect/dist/esm/internal/opCodes/channelState.js
var OP_DONE3 = "Done";
var OP_EMIT2 = "Emit";
var OP_FROM_EFFECT3 = "FromEffect";
var OP_READ2 = "Read";

// ../node_modules/effect/dist/esm/internal/channel/channelState.js
var ChannelStateTypeId = Symbol.for("effect/ChannelState");
var channelStateVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var proto7 = {
  [ChannelStateTypeId]: channelStateVariance
};
var Done2 = () => {
  const op = Object.create(proto7);
  op._tag = OP_DONE3;
  return op;
};
var Emit = () => {
  const op = Object.create(proto7);
  op._tag = OP_EMIT2;
  return op;
};
var fromEffect6 = (effect4) => {
  const op = Object.create(proto7);
  op._tag = OP_FROM_EFFECT3;
  op.effect = effect4;
  return op;
};
var Read = (upstream, onEffect, onEmit, onDone3) => {
  const op = Object.create(proto7);
  op._tag = OP_READ2;
  op.upstream = upstream;
  op.onEffect = onEffect;
  op.onEmit = onEmit;
  op.onDone = onDone3;
  return op;
};
var isFromEffect = (self) => self._tag === OP_FROM_EFFECT3;
var effect2 = (self) => isFromEffect(self) ? self.effect : _void;
var effectOrUndefinedIgnored = (self) => isFromEffect(self) ? ignore2(self.effect) : void 0;

// ../node_modules/effect/dist/esm/internal/channel/subexecutor.js
var OP_PULL_FROM_CHILD = "PullFromChild";
var OP_PULL_FROM_UPSTREAM = "PullFromUpstream";
var OP_DRAIN_CHILD_EXECUTORS = "DrainChildExecutors";
var OP_EMIT3 = "Emit";
var PullFromChild = class {
  constructor(childExecutor, parentSubexecutor, onEmit) {
    __publicField(this, "childExecutor");
    __publicField(this, "parentSubexecutor");
    __publicField(this, "onEmit");
    __publicField(this, "_tag", OP_PULL_FROM_CHILD);
    this.childExecutor = childExecutor;
    this.parentSubexecutor = parentSubexecutor;
    this.onEmit = onEmit;
  }
  close(exit3) {
    const fin1 = this.childExecutor.close(exit3);
    const fin2 = this.parentSubexecutor.close(exit3);
    if (fin1 !== void 0 && fin2 !== void 0) {
      return zipWith8(exit2(fin1), exit2(fin2), (exit1, exit22) => pipe(exit1, zipRight2(exit22)));
    } else if (fin1 !== void 0) {
      return fin1;
    } else if (fin2 !== void 0) {
      return fin2;
    } else {
      return void 0;
    }
  }
  enqueuePullFromChild(_child) {
    return this;
  }
};
var PullFromUpstream = class _PullFromUpstream {
  constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit) {
    __publicField(this, "upstreamExecutor");
    __publicField(this, "createChild");
    __publicField(this, "lastDone");
    __publicField(this, "activeChildExecutors");
    __publicField(this, "combineChildResults");
    __publicField(this, "combineWithChildResult");
    __publicField(this, "onPull");
    __publicField(this, "onEmit");
    __publicField(this, "_tag", OP_PULL_FROM_UPSTREAM);
    this.upstreamExecutor = upstreamExecutor;
    this.createChild = createChild;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
    this.onEmit = onEmit;
  }
  close(exit3) {
    const fin1 = this.upstreamExecutor.close(exit3);
    const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit3) : void 0), fin1];
    const result = fins.reduce((acc, next6) => {
      if (acc !== void 0 && next6 !== void 0) {
        return zipWith8(acc, exit2(next6), (exit1, exit22) => zipRight2(exit1, exit22));
      } else if (acc !== void 0) {
        return acc;
      } else if (next6 !== void 0) {
        return exit2(next6);
      } else {
        return void 0;
      }
    }, void 0);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(child) {
    return new _PullFromUpstream(this.upstreamExecutor, this.createChild, this.lastDone, [...this.activeChildExecutors, child], this.combineChildResults, this.combineWithChildResult, this.onPull, this.onEmit);
  }
};
var DrainChildExecutors = class _DrainChildExecutors {
  constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull) {
    __publicField(this, "upstreamExecutor");
    __publicField(this, "lastDone");
    __publicField(this, "activeChildExecutors");
    __publicField(this, "upstreamDone");
    __publicField(this, "combineChildResults");
    __publicField(this, "combineWithChildResult");
    __publicField(this, "onPull");
    __publicField(this, "_tag", OP_DRAIN_CHILD_EXECUTORS);
    this.upstreamExecutor = upstreamExecutor;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.upstreamDone = upstreamDone;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
  }
  close(exit3) {
    const fin1 = this.upstreamExecutor.close(exit3);
    const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit3) : void 0), fin1];
    const result = fins.reduce((acc, next6) => {
      if (acc !== void 0 && next6 !== void 0) {
        return zipWith8(acc, exit2(next6), (exit1, exit22) => zipRight2(exit1, exit22));
      } else if (acc !== void 0) {
        return acc;
      } else if (next6 !== void 0) {
        return exit2(next6);
      } else {
        return void 0;
      }
    }, void 0);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(child) {
    return new _DrainChildExecutors(this.upstreamExecutor, this.lastDone, [...this.activeChildExecutors, child], this.upstreamDone, this.combineChildResults, this.combineWithChildResult, this.onPull);
  }
};
var Emit2 = class {
  constructor(value8, next6) {
    __publicField(this, "value");
    __publicField(this, "next");
    __publicField(this, "_tag", OP_EMIT3);
    this.value = value8;
    this.next = next6;
  }
  close(exit3) {
    const result = this.next.close(exit3);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(_child) {
    return this;
  }
};

// ../node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullRequest.js
var OP_PULLED = "Pulled";
var OP_NO_UPSTREAM = "NoUpstream";

// ../node_modules/effect/dist/esm/internal/channel/upstreamPullRequest.js
var UpstreamPullRequestSymbolKey = "effect/ChannelUpstreamPullRequest";
var UpstreamPullRequestTypeId = Symbol.for(UpstreamPullRequestSymbolKey);
var upstreamPullRequestVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto8 = {
  [UpstreamPullRequestTypeId]: upstreamPullRequestVariance
};
var Pulled = (value8) => {
  const op = Object.create(proto8);
  op._tag = OP_PULLED;
  op.value = value8;
  return op;
};
var NoUpstream = (activeDownstreamCount) => {
  const op = Object.create(proto8);
  op._tag = OP_NO_UPSTREAM;
  op.activeDownstreamCount = activeDownstreamCount;
  return op;
};
var isUpstreamPullRequest = (u) => hasProperty(u, UpstreamPullRequestTypeId);
var isPulled = (self) => self._tag === OP_PULLED;
var isNoUpstream = (self) => self._tag === OP_NO_UPSTREAM;
var match21 = dual(2, (self, {
  onNoUpstream,
  onPulled
}) => {
  switch (self._tag) {
    case OP_PULLED: {
      return onPulled(self.value);
    }
    case OP_NO_UPSTREAM: {
      return onNoUpstream(self.activeDownstreamCount);
    }
  }
});

// ../node_modules/effect/dist/esm/internal/channel/channelExecutor.js
var ChannelExecutor = class _ChannelExecutor {
  constructor(initialChannel, providedEnv, executeCloseLastSubstream) {
    __publicField(this, "_activeSubexecutor");
    __publicField(this, "_cancelled");
    __publicField(this, "_closeLastSubstream");
    __publicField(this, "_currentChannel");
    __publicField(this, "_done");
    __publicField(this, "_doneStack", []);
    __publicField(this, "_emitted");
    __publicField(this, "_executeCloseLastSubstream");
    __publicField(this, "_input");
    __publicField(this, "_inProgressFinalizer");
    __publicField(this, "_providedEnv");
    this._currentChannel = initialChannel;
    this._executeCloseLastSubstream = executeCloseLastSubstream;
    this._providedEnv = providedEnv;
  }
  run() {
    let result = void 0;
    while (result === void 0) {
      if (this._cancelled !== void 0) {
        result = this.processCancellation();
      } else if (this._activeSubexecutor !== void 0) {
        result = this.runSubexecutor();
      } else {
        try {
          if (this._currentChannel === void 0) {
            result = Done2();
          } else {
            if (isEffect2(this._currentChannel)) {
              this._currentChannel = fromEffect5(this._currentChannel);
            } else {
              switch (this._currentChannel._tag) {
                case OP_BRACKET_OUT: {
                  result = this.runBracketOut(this._currentChannel);
                  break;
                }
                case OP_BRIDGE: {
                  const bridgeInput = this._currentChannel.input;
                  this._currentChannel = this._currentChannel.channel;
                  if (this._input !== void 0) {
                    const inputExecutor = this._input;
                    this._input = void 0;
                    const drainer = () => flatMap15(bridgeInput.awaitRead(), () => suspend3(() => {
                      const state = inputExecutor.run();
                      switch (state._tag) {
                        case OP_DONE3: {
                          return match7(inputExecutor.getDone(), {
                            onFailure: (cause3) => bridgeInput.error(cause3),
                            onSuccess: (value8) => bridgeInput.done(value8)
                          });
                        }
                        case OP_EMIT2: {
                          return flatMap15(bridgeInput.emit(inputExecutor.getEmit()), () => drainer());
                        }
                        case OP_FROM_EFFECT3: {
                          return matchCauseEffect2(state.effect, {
                            onFailure: (cause3) => bridgeInput.error(cause3),
                            onSuccess: () => drainer()
                          });
                        }
                        case OP_READ2: {
                          return readUpstream(state, () => drainer(), (cause3) => bridgeInput.error(cause3));
                        }
                      }
                    }));
                    result = fromEffect6(flatMap15(forkDaemon2(drainer()), (fiber) => sync7(() => this.addFinalizer((exit3) => flatMap15(interrupt6(fiber), () => suspend3(() => {
                      const effect4 = this.restorePipe(exit3, inputExecutor);
                      return effect4 !== void 0 ? effect4 : _void;
                    }))))));
                  }
                  break;
                }
                case OP_CONCAT_ALL: {
                  const executor = new _ChannelExecutor(this._currentChannel.value(), this._providedEnv, (effect4) => sync7(() => {
                    const prevLastClose = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
                    this._closeLastSubstream = pipe(prevLastClose, zipRight6(effect4));
                  }));
                  executor._input = this._input;
                  const channel = this._currentChannel;
                  this._activeSubexecutor = new PullFromUpstream(executor, (value8) => channel.k(value8), void 0, [], (x, y) => channel.combineInners(x, y), (x, y) => channel.combineAll(x, y), (request2) => channel.onPull(request2), (value8) => channel.onEmit(value8));
                  this._closeLastSubstream = void 0;
                  this._currentChannel = void 0;
                  break;
                }
                case OP_EMIT: {
                  this._emitted = this._currentChannel.out;
                  this._currentChannel = this._activeSubexecutor !== void 0 ? void 0 : void_5;
                  result = Emit();
                  break;
                }
                case OP_ENSURING: {
                  this.runEnsuring(this._currentChannel);
                  break;
                }
                case OP_FAIL3: {
                  result = this.doneHalt(this._currentChannel.error());
                  break;
                }
                case OP_FOLD2: {
                  this._doneStack.push(this._currentChannel.k);
                  this._currentChannel = this._currentChannel.channel;
                  break;
                }
                case OP_FROM_EFFECT2: {
                  const effect4 = this._providedEnv === void 0 ? this._currentChannel.effect() : pipe(this._currentChannel.effect(), provide2(this._providedEnv));
                  result = fromEffect6(matchCauseEffect2(effect4, {
                    onFailure: (cause3) => {
                      const state = this.doneHalt(cause3);
                      return state !== void 0 && isFromEffect(state) ? state.effect : _void;
                    },
                    onSuccess: (value8) => {
                      const state = this.doneSucceed(value8);
                      return state !== void 0 && isFromEffect(state) ? state.effect : _void;
                    }
                  }));
                  break;
                }
                case OP_PIPE_TO: {
                  const previousInput = this._input;
                  const leftExec = new _ChannelExecutor(this._currentChannel.left(), this._providedEnv, (effect4) => this._executeCloseLastSubstream(effect4));
                  leftExec._input = previousInput;
                  this._input = leftExec;
                  this.addFinalizer((exit3) => {
                    const effect4 = this.restorePipe(exit3, previousInput);
                    return effect4 !== void 0 ? effect4 : _void;
                  });
                  this._currentChannel = this._currentChannel.right();
                  break;
                }
                case OP_PROVIDE2: {
                  const previousEnv = this._providedEnv;
                  this._providedEnv = this._currentChannel.context();
                  this._currentChannel = this._currentChannel.inner;
                  this.addFinalizer(() => sync7(() => {
                    this._providedEnv = previousEnv;
                  }));
                  break;
                }
                case OP_READ: {
                  const read3 = this._currentChannel;
                  result = Read(this._input, identity, (emitted) => {
                    try {
                      this._currentChannel = read3.more(emitted);
                    } catch (error4) {
                      this._currentChannel = read3.done.onExit(die4(error4));
                    }
                    return void 0;
                  }, (exit3) => {
                    const onExit3 = (exit4) => {
                      return read3.done.onExit(exit4);
                    };
                    this._currentChannel = onExit3(exit3);
                    return void 0;
                  });
                  break;
                }
                case OP_SUCCEED: {
                  result = this.doneSucceed(this._currentChannel.evaluate());
                  break;
                }
                case OP_SUCCEED_NOW: {
                  result = this.doneSucceed(this._currentChannel.terminal);
                  break;
                }
                case OP_SUSPEND2: {
                  this._currentChannel = this._currentChannel.channel();
                  break;
                }
                default: {
                  this._currentChannel._tag;
                }
              }
            }
          }
        } catch (error4) {
          this._currentChannel = failCause11(die5(error4));
        }
      }
    }
    return result;
  }
  getDone() {
    return this._done;
  }
  getEmit() {
    return this._emitted;
  }
  cancelWith(exit3) {
    this._cancelled = exit3;
  }
  clearInProgressFinalizer() {
    this._inProgressFinalizer = void 0;
  }
  storeInProgressFinalizer(finalizer3) {
    this._inProgressFinalizer = finalizer3;
  }
  popAllFinalizers(exit3) {
    const finalizers = [];
    let next6 = this._doneStack.pop();
    while (next6) {
      if (next6._tag === "ContinuationFinalizer") {
        finalizers.push(next6.finalizer);
      }
      next6 = this._doneStack.pop();
    }
    const effect4 = finalizers.length === 0 ? _void : runFinalizers(finalizers, exit3);
    this.storeInProgressFinalizer(effect4);
    return effect4;
  }
  popNextFinalizers() {
    const builder = [];
    while (this._doneStack.length !== 0) {
      const cont = this._doneStack[this._doneStack.length - 1];
      if (cont._tag === OP_CONTINUATION_K) {
        return builder;
      }
      builder.push(cont);
      this._doneStack.pop();
    }
    return builder;
  }
  restorePipe(exit3, prev) {
    const currInput = this._input;
    this._input = prev;
    if (currInput !== void 0) {
      const effect4 = currInput.close(exit3);
      return effect4;
    }
    return _void;
  }
  close(exit3) {
    let runInProgressFinalizers = void 0;
    const finalizer3 = this._inProgressFinalizer;
    if (finalizer3 !== void 0) {
      runInProgressFinalizers = pipe(finalizer3, ensuring3(sync7(() => this.clearInProgressFinalizer())));
    }
    let closeSelf = void 0;
    const selfFinalizers = this.popAllFinalizers(exit3);
    if (selfFinalizers !== void 0) {
      closeSelf = pipe(selfFinalizers, ensuring3(sync7(() => this.clearInProgressFinalizer())));
    }
    const closeSubexecutors = this._activeSubexecutor === void 0 ? void 0 : this._activeSubexecutor.close(exit3);
    if (closeSubexecutors === void 0 && runInProgressFinalizers === void 0 && closeSelf === void 0) {
      return void 0;
    }
    return pipe(
      exit2(ifNotNull(closeSubexecutors)),
      zip10(exit2(ifNotNull(runInProgressFinalizers))),
      zip10(exit2(ifNotNull(closeSelf))),
      map22(([[exit1, exit22], exit32]) => pipe(exit1, zipRight2(exit22), zipRight2(exit32))),
      uninterruptible2,
      // TODO: remove
      flatMap15((exit4) => suspend3(() => exit4))
    );
  }
  doneSucceed(value8) {
    if (this._doneStack.length === 0) {
      this._done = succeed3(value8);
      this._currentChannel = void 0;
      return Done2();
    }
    const head11 = this._doneStack[this._doneStack.length - 1];
    if (head11._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      this._currentChannel = head11.onSuccess(value8);
      return void 0;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = succeed3(value8);
      this._currentChannel = void 0;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), succeed3(value8));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect4 = pipe(finalizerEffect, ensuring3(sync7(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap15(() => sync7(() => this.doneSucceed(value8))));
    return fromEffect6(effect4);
  }
  doneHalt(cause3) {
    if (this._doneStack.length === 0) {
      this._done = failCause3(cause3);
      this._currentChannel = void 0;
      return Done2();
    }
    const head11 = this._doneStack[this._doneStack.length - 1];
    if (head11._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      this._currentChannel = head11.onHalt(cause3);
      return void 0;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = failCause3(cause3);
      this._currentChannel = void 0;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), failCause3(cause3));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect4 = pipe(finalizerEffect, ensuring3(sync7(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap15(() => sync7(() => this.doneHalt(cause3))));
    return fromEffect6(effect4);
  }
  processCancellation() {
    this._currentChannel = void 0;
    this._done = this._cancelled;
    this._cancelled = void 0;
    return Done2();
  }
  runBracketOut(bracketOut) {
    const effect4 = uninterruptible2(matchCauseEffect2(this.provide(bracketOut.acquire()), {
      onFailure: (cause3) => sync7(() => {
        this._currentChannel = failCause11(cause3);
      }),
      onSuccess: (out) => sync7(() => {
        this.addFinalizer((exit3) => this.provide(bracketOut.finalizer(out, exit3)));
        this._currentChannel = write(out);
      })
    }));
    return fromEffect6(effect4);
  }
  provide(effect4) {
    if (this._providedEnv === void 0) {
      return effect4;
    }
    return pipe(effect4, provide2(this._providedEnv));
  }
  runEnsuring(ensuring13) {
    this.addFinalizer(ensuring13.finalizer);
    this._currentChannel = ensuring13.channel;
  }
  addFinalizer(f) {
    this._doneStack.push(new ContinuationFinalizerImpl(f));
  }
  runSubexecutor() {
    const subexecutor = this._activeSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_CHILD: {
        return this.pullFromChild(subexecutor.childExecutor, subexecutor.parentSubexecutor, subexecutor.onEmit, subexecutor);
      }
      case OP_PULL_FROM_UPSTREAM: {
        return this.pullFromUpstream(subexecutor);
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        return this.drainChildExecutors(subexecutor);
      }
      case OP_EMIT3: {
        this._emitted = subexecutor.value;
        this._activeSubexecutor = subexecutor.next;
        return Emit();
      }
    }
  }
  replaceSubexecutor(nextSubExec) {
    this._currentChannel = void 0;
    this._activeSubexecutor = nextSubExec;
  }
  finishWithExit(exit3) {
    const state = match7(exit3, {
      onFailure: (cause3) => this.doneHalt(cause3),
      onSuccess: (value8) => this.doneSucceed(value8)
    });
    this._activeSubexecutor = void 0;
    return state === void 0 ? _void : effect2(state);
  }
  finishSubexecutorWithCloseEffect(subexecutorDone, ...closeFuncs) {
    this.addFinalizer(() => pipe(closeFuncs, forEach12((closeFunc) => pipe(sync7(() => closeFunc(subexecutorDone)), flatMap15((closeEffect) => closeEffect !== void 0 ? closeEffect : _void)), {
      discard: true
    })));
    const state = pipe(subexecutorDone, match7({
      onFailure: (cause3) => this.doneHalt(cause3),
      onSuccess: (value8) => this.doneSucceed(value8)
    }));
    this._activeSubexecutor = void 0;
    return state;
  }
  applyUpstreamPullStrategy(upstreamFinished, queue, strategy) {
    switch (strategy._tag) {
      case OP_PULL_AFTER_NEXT: {
        const shouldPrepend = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
        return [strategy.emitSeparator, shouldPrepend ? [void 0, ...queue] : queue];
      }
      case OP_PULL_AFTER_ALL_ENQUEUED: {
        const shouldEnqueue = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
        return [strategy.emitSeparator, shouldEnqueue ? [...queue, void 0] : queue];
      }
    }
  }
  pullFromChild(childExecutor, parentSubexecutor, onEmitted, subexecutor) {
    return Read(childExecutor, identity, (emitted) => {
      const childExecutorDecision = onEmitted(emitted);
      switch (childExecutorDecision._tag) {
        case OP_CONTINUE2: {
          break;
        }
        case OP_CLOSE: {
          this.finishWithDoneValue(childExecutor, parentSubexecutor, childExecutorDecision.value);
          break;
        }
        case OP_YIELD2: {
          const modifiedParent = parentSubexecutor.enqueuePullFromChild(subexecutor);
          this.replaceSubexecutor(modifiedParent);
          break;
        }
      }
      this._activeSubexecutor = new Emit2(emitted, this._activeSubexecutor);
      return void 0;
    }, match7({
      onFailure: (cause3) => {
        const state = this.handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3);
        return state === void 0 ? void 0 : effectOrUndefinedIgnored(state);
      },
      onSuccess: (doneValue) => {
        this.finishWithDoneValue(childExecutor, parentSubexecutor, doneValue);
        return void 0;
      }
    }));
  }
  finishWithDoneValue(childExecutor, parentSubexecutor, doneValue) {
    const subexecutor = parentSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_UPSTREAM: {
        const modifiedParent = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
        this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        const modifiedParent = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      default: {
        break;
      }
    }
  }
  handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3) {
    return this.finishSubexecutorWithCloseEffect(failCause3(cause3), (exit3) => parentSubexecutor.close(exit3), (exit3) => childExecutor.close(exit3));
  }
  pullFromUpstream(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      return this.performPullFromUpstream(subexecutor);
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const parentSubexecutor = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, subexecutor.activeChildExecutors.slice(1), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
    if (activeChild === void 0) {
      return this.performPullFromUpstream(parentSubexecutor);
    }
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return void 0;
  }
  performPullFromUpstream(subexecutor) {
    return Read(subexecutor.upstreamExecutor, (effect4) => {
      const closeLastSubstream = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
      this._closeLastSubstream = void 0;
      return pipe(this._executeCloseLastSubstream(closeLastSubstream), zipRight6(effect4));
    }, (emitted) => {
      if (this._closeLastSubstream !== void 0) {
        const closeLastSubstream = this._closeLastSubstream;
        this._closeLastSubstream = void 0;
        return pipe(this._executeCloseLastSubstream(closeLastSubstream), map22(() => {
          const childExecutor2 = new _ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
          childExecutor2._input = this._input;
          const [emitSeparator2, updatedChildExecutors2] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
          this._activeSubexecutor = new PullFromChild(childExecutor2, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors2, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
          if (isSome(emitSeparator2)) {
            this._activeSubexecutor = new Emit2(emitSeparator2.value, this._activeSubexecutor);
          }
          return void 0;
        }));
      }
      const childExecutor = new _ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
      childExecutor._input = this._input;
      const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
      this._activeSubexecutor = new PullFromChild(childExecutor, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
      if (isSome(emitSeparator)) {
        this._activeSubexecutor = new Emit2(emitSeparator.value, this._activeSubexecutor);
      }
      return void 0;
    }, (exit3) => {
      if (subexecutor.activeChildExecutors.some((subexecutor2) => subexecutor2 !== void 0)) {
        const drain7 = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, [void 0, ...subexecutor.activeChildExecutors], subexecutor.upstreamExecutor.getDone(), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        if (this._closeLastSubstream !== void 0) {
          const closeLastSubstream2 = this._closeLastSubstream;
          this._closeLastSubstream = void 0;
          return pipe(this._executeCloseLastSubstream(closeLastSubstream2), map22(() => this.replaceSubexecutor(drain7)));
        }
        this.replaceSubexecutor(drain7);
        return void 0;
      }
      const closeLastSubstream = this._closeLastSubstream;
      const state = this.finishSubexecutorWithCloseEffect(pipe(exit3, map12((a) => subexecutor.combineWithChildResult(subexecutor.lastDone, a))), () => closeLastSubstream, (exit4) => subexecutor.upstreamExecutor.close(exit4));
      return state === void 0 ? void 0 : (
        // NOTE: assuming finalizers cannot fail
        effectOrUndefinedIgnored(state)
      );
    });
  }
  drainChildExecutors(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      const lastClose = this._closeLastSubstream;
      if (lastClose !== void 0) {
        this.addFinalizer(() => succeed12(lastClose));
      }
      return this.finishSubexecutorWithCloseEffect(subexecutor.upstreamDone, () => lastClose, (exit3) => subexecutor.upstreamExecutor.close(exit3));
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const rest = subexecutor.activeChildExecutors.slice(1);
    if (activeChild === void 0) {
      const [emitSeparator, remainingExecutors] = this.applyUpstreamPullStrategy(true, rest, subexecutor.onPull(NoUpstream(rest.reduce((n, curr) => curr !== void 0 ? n + 1 : n, 0))));
      this.replaceSubexecutor(new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, remainingExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull));
      if (isSome(emitSeparator)) {
        this._emitted = emitSeparator.value;
        return Emit();
      }
      return void 0;
    }
    const parentSubexecutor = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, rest, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return void 0;
  }
};
var ifNotNull = (effect4) => effect4 !== void 0 ? effect4 : _void;
var runFinalizers = (finalizers, exit3) => {
  return pipe(forEach12(finalizers, (fin) => exit2(fin(exit3))), map22((exits) => pipe(all4(exits), getOrElse(() => void_2))), flatMap15((exit4) => suspend3(() => exit4)));
};
var readUpstream = (r, onSuccess, onFailure) => {
  const readStack = [r];
  const read3 = () => {
    const current2 = readStack.pop();
    if (current2 === void 0 || current2.upstream === void 0) {
      return dieMessage2("Unexpected end of input for channel execution");
    }
    const state = current2.upstream.run();
    switch (state._tag) {
      case OP_EMIT2: {
        const emitEffect = current2.onEmit(current2.upstream.getEmit());
        if (readStack.length === 0) {
          if (emitEffect === void 0) {
            return suspend3(onSuccess);
          }
          return pipe(emitEffect, matchCauseEffect2({
            onFailure,
            onSuccess
          }));
        }
        if (emitEffect === void 0) {
          return suspend3(() => read3());
        }
        return pipe(emitEffect, matchCauseEffect2({
          onFailure,
          onSuccess: () => read3()
        }));
      }
      case OP_DONE3: {
        const doneEffect = current2.onDone(current2.upstream.getDone());
        if (readStack.length === 0) {
          if (doneEffect === void 0) {
            return suspend3(onSuccess);
          }
          return pipe(doneEffect, matchCauseEffect2({
            onFailure,
            onSuccess
          }));
        }
        if (doneEffect === void 0) {
          return suspend3(() => read3());
        }
        return pipe(doneEffect, matchCauseEffect2({
          onFailure,
          onSuccess: () => read3()
        }));
      }
      case OP_FROM_EFFECT3: {
        readStack.push(current2);
        return pipe(current2.onEffect(state.effect), catchAllCause3((cause3) => suspend3(() => {
          const doneEffect = current2.onDone(failCause3(cause3));
          return doneEffect === void 0 ? _void : doneEffect;
        })), matchCauseEffect2({
          onFailure,
          onSuccess: () => read3()
        }));
      }
      case OP_READ2: {
        readStack.push(current2);
        readStack.push(state);
        return suspend3(() => read3());
      }
    }
  };
  return read3();
};
var run2 = (self) => pipe(runScoped(self), scoped3);
var runScoped = (self) => {
  const run11 = (channelDeferred, scopeDeferred, scope5) => acquireUseRelease2(sync7(() => new ChannelExecutor(self, void 0, identity)), (exec) => suspend3(() => pipe(runScopedInterpret(exec.run(), exec), intoDeferred2(channelDeferred), zipRight6(_await(channelDeferred)), zipLeft6(_await(scopeDeferred)))), (exec, exit3) => {
    const finalize = exec.close(exit3);
    if (finalize === void 0) {
      return _void;
    }
    return tapErrorCause3(finalize, (cause3) => addFinalizer2(scope5, failCause9(cause3)));
  });
  return uninterruptibleMask2((restore) => flatMap15(scope3, (parent) => pipe(all7([fork2(parent, sequential3), make23(), make23()]), flatMap15(([child, channelDeferred, scopeDeferred]) => pipe(forkScoped2(restore(run11(channelDeferred, scopeDeferred, child))), flatMap15((fiber) => pipe(addFinalizer3(() => succeed2(scopeDeferred, void 0)), zipRight6(restore(_await(channelDeferred))), zipLeft6(inheritAll2(fiber)))))))));
};
var runScopedInterpret = (channelState, exec) => {
  const op = channelState;
  switch (op._tag) {
    case OP_FROM_EFFECT3: {
      return pipe(op.effect, flatMap15(() => runScopedInterpret(exec.run(), exec)));
    }
    case OP_EMIT2: {
      return runScopedInterpret(exec.run(), exec);
    }
    case OP_DONE3: {
      return suspend3(() => exec.getDone());
    }
    case OP_READ2: {
      return readUpstream(op, () => runScopedInterpret(exec.run(), exec), failCause9);
    }
  }
};

// ../node_modules/effect/dist/esm/internal/opCodes/channelMergeDecision.js
var OP_DONE4 = "Done";
var OP_AWAIT = "Await";

// ../node_modules/effect/dist/esm/internal/channel/mergeDecision.js
var MergeDecisionSymbolKey = "effect/ChannelMergeDecision";
var MergeDecisionTypeId = Symbol.for(MergeDecisionSymbolKey);
var proto9 = {
  [MergeDecisionTypeId]: {
    _R: (_) => _,
    _E0: (_) => _,
    _Z0: (_) => _,
    _E: (_) => _,
    _Z: (_) => _
  }
};
var Done3 = (effect4) => {
  const op = Object.create(proto9);
  op._tag = OP_DONE4;
  op.effect = effect4;
  return op;
};
var Await = (f) => {
  const op = Object.create(proto9);
  op._tag = OP_AWAIT;
  op.f = f;
  return op;
};
var AwaitConst = (effect4) => Await(() => effect4);
var isMergeDecision = (u) => hasProperty(u, MergeDecisionTypeId);
var match22 = dual(2, (self, {
  onAwait,
  onDone: onDone3
}) => {
  const op = self;
  switch (op._tag) {
    case OP_DONE4:
      return onDone3(op.effect);
    case OP_AWAIT:
      return onAwait(op.f);
  }
});

// ../node_modules/effect/dist/esm/internal/opCodes/channelMergeState.js
var OP_BOTH_RUNNING = "BothRunning";
var OP_LEFT_DONE = "LeftDone";
var OP_RIGHT_DONE = "RightDone";

// ../node_modules/effect/dist/esm/internal/channel/mergeState.js
var MergeStateSymbolKey = "effect/ChannelMergeState";
var MergeStateTypeId = Symbol.for(MergeStateSymbolKey);
var proto10 = {
  [MergeStateTypeId]: MergeStateTypeId
};
var BothRunning = (left2, right2) => {
  const op = Object.create(proto10);
  op._tag = OP_BOTH_RUNNING;
  op.left = left2;
  op.right = right2;
  return op;
};
var LeftDone = (f) => {
  const op = Object.create(proto10);
  op._tag = OP_LEFT_DONE;
  op.f = f;
  return op;
};
var RightDone = (f) => {
  const op = Object.create(proto10);
  op._tag = OP_RIGHT_DONE;
  op.f = f;
  return op;
};
var isMergeState = (u) => hasProperty(u, MergeStateTypeId);
var isBothRunning = (self) => {
  return self._tag === OP_BOTH_RUNNING;
};
var isLeftDone = (self) => {
  return self._tag === OP_LEFT_DONE;
};
var isRightDone = (self) => {
  return self._tag === OP_RIGHT_DONE;
};
var match23 = dual(2, (self, {
  onBothRunning,
  onLeftDone,
  onRightDone
}) => {
  switch (self._tag) {
    case OP_BOTH_RUNNING: {
      return onBothRunning(self.left, self.right);
    }
    case OP_LEFT_DONE: {
      return onLeftDone(self.f);
    }
    case OP_RIGHT_DONE: {
      return onRightDone(self.f);
    }
  }
});

// ../node_modules/effect/dist/esm/internal/opCodes/channelMergeStrategy.js
var OP_BACK_PRESSURE = "BackPressure";
var OP_BUFFER_SLIDING = "BufferSliding";

// ../node_modules/effect/dist/esm/internal/channel/mergeStrategy.js
var MergeStrategySymbolKey = "effect/ChannelMergeStrategy";
var MergeStrategyTypeId = Symbol.for(MergeStrategySymbolKey);
var proto11 = {
  [MergeStrategyTypeId]: MergeStrategyTypeId
};
var BackPressure = (_) => {
  const op = Object.create(proto11);
  op._tag = OP_BACK_PRESSURE;
  return op;
};
var BufferSliding = (_) => {
  const op = Object.create(proto11);
  op._tag = OP_BUFFER_SLIDING;
  return op;
};
var isMergeStrategy = (u) => hasProperty(u, MergeStrategyTypeId);
var isBackPressure = (self) => self._tag === OP_BACK_PRESSURE;
var isBufferSliding = (self) => self._tag === OP_BUFFER_SLIDING;
var match24 = dual(2, (self, {
  onBackPressure,
  onBufferSliding
}) => {
  switch (self._tag) {
    case OP_BACK_PRESSURE: {
      return onBackPressure();
    }
    case OP_BUFFER_SLIDING: {
      return onBufferSliding();
    }
  }
});

// ../node_modules/effect/dist/esm/internal/channel/singleProducerAsyncInput.js
var OP_STATE_EMPTY = "Empty";
var OP_STATE_EMIT = "Emit";
var OP_STATE_ERROR = "Error";
var OP_STATE_DONE2 = "Done";
var stateEmpty = (notifyProducer) => ({
  _tag: OP_STATE_EMPTY,
  notifyProducer
});
var stateEmit = (notifyConsumers) => ({
  _tag: OP_STATE_EMIT,
  notifyConsumers
});
var stateError = (cause3) => ({
  _tag: OP_STATE_ERROR,
  cause: cause3
});
var stateDone = (done17) => ({
  _tag: OP_STATE_DONE2,
  done: done17
});
var SingleProducerAsyncInputImpl = class {
  constructor(ref) {
    __publicField(this, "ref");
    this.ref = ref;
  }
  awaitRead() {
    return flatten9(modify6(this.ref, (state) => state._tag === OP_STATE_EMPTY ? [_await(state.notifyProducer), state] : [_void, state]));
  }
  get close() {
    return fiberIdWith2((fiberId5) => this.error(interrupt5(fiberId5)));
  }
  done(value8) {
    return flatten9(modify6(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach12(state.notifyConsumers, (deferred) => succeed2(deferred, left(value8)), {
            discard: true
          }), stateDone(value8)];
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    }));
  }
  emit(element) {
    return flatMap15(make23(), (deferred) => flatten9(modify6(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          const notifyConsumer = state.notifyConsumers[0];
          const notifyConsumers = state.notifyConsumers.slice(1);
          if (notifyConsumer !== void 0) {
            return [succeed2(notifyConsumer, right(element)), notifyConsumers.length === 0 ? stateEmpty(deferred) : stateEmit(notifyConsumers)];
          }
          throw new Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! please report an issue at https://github.com/Effect-TS/effect/issues");
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    })));
  }
  error(cause3) {
    return flatten9(modify6(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach12(state.notifyConsumers, (deferred) => failCause2(deferred, cause3), {
            discard: true
          }), stateError(cause3)];
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    }));
  }
  get take() {
    return this.takeWith((cause3) => failCause3(map18(cause3, left)), (elem) => succeed3(elem), (done17) => fail4(right(done17)));
  }
  takeWith(onError5, onElement, onDone3) {
    return flatMap15(make23(), (deferred) => flatten9(modify6(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [zipRight6(succeed2(state.notifyProducer, void 0), matchCause3(_await(deferred), {
            onFailure: onError5,
            onSuccess: match({
              onLeft: onDone3,
              onRight: onElement
            })
          })), stateEmit([deferred])];
        }
        case OP_STATE_EMIT: {
          return [matchCause3(_await(deferred), {
            onFailure: onError5,
            onSuccess: match({
              onLeft: onDone3,
              onRight: onElement
            })
          }), stateEmit([...state.notifyConsumers, deferred])];
        }
        case OP_STATE_ERROR: {
          return [succeed12(onError5(state.cause)), state];
        }
        case OP_STATE_DONE2: {
          return [succeed12(onDone3(state.done)), state];
        }
      }
    })));
  }
};
var make59 = () => pipe(make23(), flatMap15((deferred) => make36(stateEmpty(deferred))), map22((ref) => new SingleProducerAsyncInputImpl(ref)));

// ../node_modules/effect/dist/esm/internal/channel.js
var acquireUseRelease3 = (acquire3, use2, release3) => flatMap17(fromEffect5(make36(() => _void)), (ref) => pipe(fromEffect5(uninterruptible2(tap3(acquire3, (a) => set6(ref, (exit3) => release3(a, exit3))))), flatMap17(use2), ensuringWith((exit3) => flatMap15(get11(ref), (f) => f(exit3)))));
var as7 = dual(2, (self, value8) => map24(self, () => value8));
var asVoid5 = (self) => map24(self, constVoid);
var buffer = (options) => suspend5(() => {
  const doBuffer = (empty57, isEmpty29, ref) => unwrap2(modify6(ref, (inElem) => isEmpty29(inElem) ? [readWith({
    onInput: (input) => flatMap17(write(input), () => doBuffer(empty57, isEmpty29, ref)),
    onFailure: (error4) => fail13(error4),
    onDone: (done17) => succeedNow(done17)
  }), inElem] : [flatMap17(write(inElem), () => doBuffer(empty57, isEmpty29, ref)), empty57]));
  return doBuffer(options.empty, options.isEmpty, options.ref);
});
var bufferChunk = (ref) => buffer({
  empty: empty5(),
  isEmpty,
  ref
});
var catchAll5 = dual(2, (self, f) => catchAllCause5(self, (cause3) => match(failureOrCause2(cause3), {
  onLeft: f,
  onRight: failCause11
})));
var concatMap = dual(2, (self, f) => concatMapWith(self, f, () => void 0, () => void 0));
var collect = dual(2, (self, pf) => {
  const collector = readWith({
    onInput: (out) => match2(pf(out), {
      onNone: () => collector,
      onSome: (out2) => flatMap17(write(out2), () => collector)
    }),
    onFailure: fail13,
    onDone: succeedNow
  });
  return pipeTo(self, collector);
});
var concatOut = (self) => concatAll(self);
var mapInput6 = dual(2, (self, f) => {
  const reader = readWith({
    onInput: (inElem) => flatMap17(write(inElem), () => reader),
    onFailure: fail13,
    onDone: (done17) => succeedNow(f(done17))
  });
  return pipeTo(reader, self);
});
var mapInputEffect2 = dual(2, (self, f) => {
  const reader = readWith({
    onInput: (inElem) => flatMap17(write(inElem), () => reader),
    onFailure: fail13,
    onDone: (done17) => fromEffect5(f(done17))
  });
  return pipeTo(reader, self);
});
var mapInputError = dual(2, (self, f) => {
  const reader = readWith({
    onInput: (inElem) => flatMap17(write(inElem), () => reader),
    onFailure: (error4) => fail13(f(error4)),
    onDone: succeedNow
  });
  return pipeTo(reader, self);
});
var mapInputErrorEffect = dual(2, (self, f) => {
  const reader = readWith({
    onInput: (inElem) => flatMap17(write(inElem), () => reader),
    onFailure: (error4) => fromEffect5(f(error4)),
    onDone: succeedNow
  });
  return pipeTo(reader, self);
});
var mapInputIn = dual(2, (self, f) => {
  const reader = readWith({
    onInput: (inElem) => flatMap17(write(f(inElem)), () => reader),
    onFailure: fail13,
    onDone: succeedNow
  });
  return pipeTo(reader, self);
});
var mapInputInEffect = dual(2, (self, f) => {
  const reader = readWith({
    onInput: (inElem) => flatMap17(flatMap17(fromEffect5(f(inElem)), write), () => reader),
    onFailure: fail13,
    onDone: succeedNow
  });
  return pipeTo(reader, self);
});
var doneCollect = (self) => suspend5(() => {
  const builder = [];
  return pipe(pipeTo(self, doneCollectReader(builder)), flatMap17((outDone) => succeed14([unsafeFromArray(builder), outDone])));
});
var doneCollectReader = (builder) => {
  return readWith({
    onInput: (outElem) => flatMap17(sync9(() => {
      builder.push(outElem);
    }), () => doneCollectReader(builder)),
    onFailure: fail13,
    onDone: succeed14
  });
};
var drain = (self) => {
  const drainer = readWithCause({
    onInput: () => drainer,
    onFailure: failCause11,
    onDone: succeed14
  });
  return pipeTo(self, drainer);
};
var emitCollect = (self) => flatMap17(doneCollect(self), write);
var ensuring4 = dual(2, (self, finalizer3) => ensuringWith(self, () => finalizer3));
var context5 = () => fromEffect5(context3());
var contextWith3 = (f) => map24(context5(), f);
var contextWithChannel = (f) => flatMap17(context5(), f);
var contextWithEffect3 = (f) => mapEffect5(context5(), f);
var flatten11 = (self) => flatMap17(self, identity);
var foldChannel = dual(2, (self, options) => foldCauseChannel(self, {
  onFailure: (cause3) => {
    const either13 = failureOrCause2(cause3);
    switch (either13._tag) {
      case "Left": {
        return options.onFailure(either13.left);
      }
      case "Right": {
        return failCause11(either13.right);
      }
    }
  },
  onSuccess: options.onSuccess
}));
var fromEither2 = (either13) => suspend5(() => match(either13, {
  onLeft: fail13,
  onRight: succeed14
}));
var fromInput = (input) => unwrap2(input.takeWith(failCause11, (elem) => flatMap17(write(elem), () => fromInput(input)), succeed14));
var fromPubSub = (pubsub) => unwrapScoped3(map22(subscribe2(pubsub), fromQueue));
var fromPubSubScoped = (pubsub) => map22(subscribe2(pubsub), fromQueue);
var fromOption3 = (option9) => suspend5(() => match2(option9, {
  onNone: () => fail13(none2()),
  onSome: succeed14
}));
var fromQueue = (queue) => suspend5(() => fromQueueInternal(queue));
var fromQueueInternal = (queue) => pipe(fromEffect5(take4(queue)), flatMap17(match({
  onLeft: match7({
    onFailure: failCause11,
    onSuccess: succeedNow
  }),
  onRight: (elem) => flatMap17(write(elem), () => fromQueueInternal(queue))
})));
var identityChannel = () => readWith({
  onInput: (input) => flatMap17(write(input), () => identityChannel()),
  onFailure: fail13,
  onDone: succeedNow
});
var interruptWhen = dual(2, (self, effect4) => mergeWith(self, {
  other: fromEffect5(effect4),
  onSelfDone: (selfDone) => Done3(suspend3(() => selfDone)),
  onOtherDone: (effectDone) => Done3(suspend3(() => effectDone))
}));
var interruptWhenDeferred = dual(2, (self, deferred) => interruptWhen(self, _await(deferred)));
var map24 = dual(2, (self, f) => flatMap17(self, (a) => sync9(() => f(a))));
var mapEffect5 = dual(2, (self, f) => flatMap17(self, (z) => fromEffect5(f(z))));
var mapError6 = dual(2, (self, f) => mapErrorCause4(self, map18(f)));
var mapErrorCause4 = dual(2, (self, f) => catchAllCause5(self, (cause3) => failCause11(f(cause3))));
var mapOut = dual(2, (self, f) => {
  const reader = readWith({
    onInput: (outElem) => flatMap17(write(f(outElem)), () => reader),
    onFailure: fail13,
    onDone: succeedNow
  });
  return pipeTo(self, reader);
});
var mapOutEffect = dual(2, (self, f) => {
  const reader = readWithCause({
    onInput: (outElem) => pipe(fromEffect5(f(outElem)), flatMap17(write), flatMap17(() => reader)),
    onFailure: failCause11,
    onDone: succeedNow
  });
  return pipeTo(self, reader);
});
var mapOutEffectPar = dual(3, (self, f, n) => pipe(gen2(function* ($) {
  const queue = yield* $(acquireRelease2(bounded5(n), (queue2) => shutdown4(queue2)));
  const errorSignal = yield* $(make23());
  const withPermits3 = n === Number.POSITIVE_INFINITY ? (_) => identity : (yield* $(makeSemaphore2(n))).withPermits;
  const pull = yield* $(toPull(self));
  yield* $(matchCauseEffect2(pull, {
    onFailure: (cause3) => offer3(queue, failCause9(cause3)),
    onSuccess: (either13) => match(either13, {
      onLeft: (outDone) => {
        const lock3 = withPermits3(n);
        return zipRight6(interruptible3(lock3(_void)), asVoid4(offer3(queue, succeed12(left(outDone)))));
      },
      onRight: (outElem) => gen2(function* ($2) {
        const deferred = yield* $2(make23());
        const latch = yield* $2(make23());
        yield* $2(asVoid4(offer3(queue, map22(_await(deferred), right))));
        yield* $2(succeed2(latch, void 0), zipRight6(pipe(uninterruptibleMask2((restore) => pipe(
          exit2(restore(_await(errorSignal))),
          raceFirst2(exit2(restore(f(outElem)))),
          // TODO: remove
          flatMap15((exit3) => suspend3(() => exit3))
        )), tapErrorCause3((cause3) => failCause2(errorSignal, cause3)), intoDeferred2(deferred))), withPermits3(1), forkScoped2);
        yield* $2(_await(latch));
      })
    })
  }), forever3, interruptible3, forkScoped2);
  return queue;
}), map22((queue) => {
  const consumer = unwrap2(matchCause3(flatten9(take4(queue)), {
    onFailure: failCause11,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: (outElem) => flatMap17(write(outElem), () => consumer)
    })
  }));
  return consumer;
}), unwrapScoped3));
var mergeAll5 = (options) => {
  return (channels) => mergeAllWith(options)(channels, constVoid);
};
var mergeAllUnbounded = (channels) => mergeAllWith({
  concurrency: "unbounded"
})(channels, constVoid);
var mergeAllUnboundedWith = (channels, f) => mergeAllWith({
  concurrency: "unbounded"
})(channels, f);
var mergeAllWith = ({
  bufferSize = 16,
  concurrency,
  mergeStrategy = BackPressure()
}) => (channels, f) => pipe(gen2(function* ($) {
  const concurrencyN = concurrency === "unbounded" ? Number.MAX_SAFE_INTEGER : concurrency;
  const input = yield* $(make59());
  const queueReader = fromInput(input);
  const queue = yield* $(acquireRelease2(bounded5(bufferSize), (queue2) => shutdown4(queue2)));
  const cancelers = yield* $(acquireRelease2(unbounded5(), (queue2) => shutdown4(queue2)));
  const lastDone = yield* $(make36(none2()));
  const errorSignal = yield* $(make23());
  const withPermits3 = (yield* $(makeSemaphore2(concurrencyN))).withPermits;
  const pull = yield* $(toPull(channels));
  const evaluatePull = (pull2) => pipe(flatMap15(pull2, match({
    onLeft: (done17) => succeed12(some2(done17)),
    onRight: (outElem) => as6(offer3(queue, succeed12(right(outElem))), none2())
  })), repeat({
    until: (_) => isSome(_)
  }), flatMap15((outDone) => update4(lastDone, match2({
    onNone: () => some2(outDone.value),
    onSome: (lastDone2) => some2(f(lastDone2, outDone.value))
  }))), catchAllCause3((cause3) => isInterrupted3(cause3) ? failCause9(cause3) : pipe(offer3(queue, failCause9(cause3)), zipRight6(succeed2(errorSignal, void 0)), asVoid4)));
  yield* $(matchCauseEffect2(pull, {
    onFailure: (cause3) => pipe(offer3(queue, failCause9(cause3)), zipRight6(succeed12(false))),
    onSuccess: match({
      onLeft: (outDone) => raceWith2(interruptible3(_await(errorSignal)), interruptible3(withPermits3(concurrencyN)(_void)), {
        onSelfDone: (_, permitAcquisition) => as6(interrupt6(permitAcquisition), false),
        onOtherDone: (_, failureAwait) => zipRight6(interrupt6(failureAwait), pipe(get11(lastDone), flatMap15(match2({
          onNone: () => offer3(queue, succeed12(left(outDone))),
          onSome: (lastDone2) => offer3(queue, succeed12(left(f(lastDone2, outDone))))
        })), as6(false)))
      }),
      onRight: (channel) => match24(mergeStrategy, {
        onBackPressure: () => gen2(function* ($2) {
          const latch = yield* $2(make23());
          const raceEffects = pipe(queueReader, pipeTo(channel), toPull, flatMap15((pull2) => race2(evaluatePull(pull2), interruptible3(_await(errorSignal)))), scoped3);
          yield* $2(succeed2(latch, void 0), zipRight6(raceEffects), withPermits3(1), forkScoped2);
          yield* $2(_await(latch));
          const errored = yield* $2(isDone(errorSignal));
          return !errored;
        }),
        onBufferSliding: () => gen2(function* ($2) {
          const canceler = yield* $2(make23());
          const latch = yield* $2(make23());
          const size38 = yield* $2(size18(cancelers));
          yield* $2(take4(cancelers), flatMap15((_) => succeed2(_, void 0)), when2(() => size38 >= concurrencyN));
          yield* $2(offer3(cancelers, canceler));
          const raceEffects = pipe(queueReader, pipeTo(channel), toPull, flatMap15((pull2) => pipe(evaluatePull(pull2), race2(interruptible3(_await(errorSignal))), race2(interruptible3(_await(canceler))))), scoped3);
          yield* $2(succeed2(latch, void 0), zipRight6(raceEffects), withPermits3(1), forkScoped2);
          yield* $2(_await(latch));
          const errored = yield* $2(isDone(errorSignal));
          return !errored;
        })
      })
    })
  }), repeat({
    while: (_) => _
  }), forkScoped2);
  return [queue, input];
}), map22(([queue, input]) => {
  const consumer = pipe(take4(queue), flatten9, matchCause3({
    onFailure: failCause11,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: (outElem) => flatMap17(write(outElem), () => consumer)
    })
  }), unwrap2);
  return embedInput(consumer, input);
}), unwrapScoped3);
var mergeMap = dual(3, (self, f, options) => mergeAll5(options)(mapOut(self, f)));
var mergeOut = dual(2, (self, n) => mergeAll5({
  concurrency: n
})(mapOut(self, identity)));
var mergeOutWith = dual(3, (self, n, f) => mergeAllWith({
  concurrency: n
})(mapOut(self, identity), f));
var mergeWith = dual(2, (self, options) => unwrapScoped3(flatMap15(make59(), (input) => {
  const queueReader = fromInput(input);
  return map22(zip10(toPull(pipeTo(queueReader, self)), toPull(pipeTo(queueReader, options.other))), ([pullL, pullR]) => {
    const handleSide = (exit3, fiber, pull) => (done17, both3, single3) => {
      const onDecision3 = (decision) => {
        const op = decision;
        if (op._tag === OP_DONE4) {
          return succeed12(fromEffect5(zipRight6(interrupt6(fiber), op.effect)));
        }
        return map22(_await3(fiber), match7({
          onFailure: (cause3) => fromEffect5(op.f(failCause3(cause3))),
          onSuccess: match({
            onLeft: (done18) => fromEffect5(op.f(succeed3(done18))),
            onRight: (elem) => zipRight7(write(elem), go(single3(op.f)))
          })
        }));
      };
      return match7(exit3, {
        onFailure: (cause3) => onDecision3(done17(failCause3(cause3))),
        onSuccess: match({
          onLeft: (z) => onDecision3(done17(succeed3(z))),
          onRight: (elem) => succeed12(flatMap17(write(elem), () => flatMap17(fromEffect5(forkDaemon2(pull)), (leftFiber) => go(both3(leftFiber, fiber)))))
        })
      });
    };
    const go = (state) => {
      switch (state._tag) {
        case OP_BOTH_RUNNING: {
          const leftJoin = interruptible3(join4(state.left));
          const rightJoin = interruptible3(join4(state.right));
          return unwrap2(raceWith2(leftJoin, rightJoin, {
            onSelfDone: (leftExit, rf) => zipRight6(interrupt6(rf), handleSide(leftExit, state.right, pullL)(options.onSelfDone, BothRunning, (f) => LeftDone(f))),
            onOtherDone: (rightExit, lf) => zipRight6(interrupt6(lf), handleSide(rightExit, state.left, pullR)(options.onOtherDone, (left2, right2) => BothRunning(right2, left2), (f) => RightDone(f)))
          }));
        }
        case OP_LEFT_DONE: {
          return unwrap2(map22(exit2(pullR), match7({
            onFailure: (cause3) => fromEffect5(state.f(failCause3(cause3))),
            onSuccess: match({
              onLeft: (done17) => fromEffect5(state.f(succeed3(done17))),
              onRight: (elem) => flatMap17(write(elem), () => go(LeftDone(state.f)))
            })
          })));
        }
        case OP_RIGHT_DONE: {
          return unwrap2(map22(exit2(pullL), match7({
            onFailure: (cause3) => fromEffect5(state.f(failCause3(cause3))),
            onSuccess: match({
              onLeft: (done17) => fromEffect5(state.f(succeed3(done17))),
              onRight: (elem) => flatMap17(write(elem), () => go(RightDone(state.f)))
            })
          })));
        }
      }
    };
    return pipe(fromEffect5(zipWith8(forkDaemon2(pullL), forkDaemon2(pullR), (left2, right2) => BothRunning(left2, right2))), flatMap17(go), embedInput(input));
  });
})));
var never5 = fromEffect5(never4);
var orDie5 = dual(2, (self, error4) => orDieWith3(self, error4));
var orDieWith3 = dual(2, (self, f) => catchAll5(self, (e) => {
  throw f(e);
}));
var orElse9 = dual(2, (self, that) => catchAll5(self, that));
var pipeToOrFail = dual(2, (self, that) => suspend5(() => {
  let channelException = void 0;
  const reader = readWith({
    onInput: (outElem) => flatMap17(write(outElem), () => reader),
    onFailure: (outErr) => {
      channelException = ChannelException(outErr);
      return failCause11(die5(channelException));
    },
    onDone: succeedNow
  });
  const writer = readWithCause({
    onInput: (outElem) => pipe(write(outElem), flatMap17(() => writer)),
    onFailure: (cause3) => isDieType2(cause3) && isChannelException(cause3.defect) && equals(cause3.defect, channelException) ? fail13(cause3.defect.error) : failCause11(cause3),
    onDone: succeedNow
  });
  return pipeTo(pipeTo(pipeTo(self, reader), that), writer);
}));
var provideService5 = dual(3, (self, tag4, service3) => {
  return flatMap17(context5(), (context13) => provideContext3(self, add2(context13, tag4, service3)));
});
var provideLayer = dual(2, (self, layer) => unwrapScoped3(map22(build2(layer), (env) => provideContext3(self, env))));
var mapInputContext4 = dual(2, (self, f) => contextWithChannel((context13) => provideContext3(self, f(context13))));
var provideSomeLayer2 = dual(2, (self, layer) => (
  // @ts-expect-error
  provideLayer(self, merge8(context4(), layer))
));
var read = () => readOrFail(none2());
var repeated = (self) => flatMap17(self, () => repeated(self));
var run3 = (self) => scoped3(runScoped(self));
var runCollect = (self) => run2(collectElements(self));
var runDrain = (self) => run2(drain(self));
var scoped5 = (effect4) => unwrap2(uninterruptibleMask2((restore) => map22(make54(), (scope5) => acquireReleaseOut(tapErrorCause3(restore(extend2(effect4, scope5)), (cause3) => close(scope5, failCause3(cause3))), (_, exit3) => close(scope5, exit3)))));
var splitLines = () => suspend5(() => {
  let stringBuilder = "";
  let midCRLF = false;
  const splitLinesChunk = (chunk7) => {
    const chunkBuilder = [];
    map4(chunk7, (str) => {
      if (str.length !== 0) {
        let from = 0;
        let indexOfCR = str.indexOf("\r");
        let indexOfLF = str.indexOf("\n");
        if (midCRLF) {
          if (indexOfLF === 0) {
            chunkBuilder.push(stringBuilder);
            stringBuilder = "";
            from = 1;
            indexOfLF = str.indexOf("\n", from);
          } else {
            stringBuilder = stringBuilder + "\r";
          }
          midCRLF = false;
        }
        while (indexOfCR !== -1 || indexOfLF !== -1) {
          if (indexOfCR === -1 || indexOfLF !== -1 && indexOfLF < indexOfCR) {
            if (stringBuilder.length === 0) {
              chunkBuilder.push(str.substring(from, indexOfLF));
            } else {
              chunkBuilder.push(stringBuilder + str.substring(from, indexOfLF));
              stringBuilder = "";
            }
            from = indexOfLF + 1;
            indexOfLF = str.indexOf("\n", from);
          } else {
            if (str.length === indexOfCR + 1) {
              midCRLF = true;
              indexOfCR = -1;
            } else {
              if (indexOfLF === indexOfCR + 1) {
                if (stringBuilder.length === 0) {
                  chunkBuilder.push(str.substring(from, indexOfCR));
                } else {
                  stringBuilder = stringBuilder + str.substring(from, indexOfCR);
                  chunkBuilder.push(stringBuilder);
                  stringBuilder = "";
                }
                from = indexOfCR + 2;
                indexOfCR = str.indexOf("\r", from);
                indexOfLF = str.indexOf("\n", from);
              } else {
                indexOfCR = str.indexOf("\r", indexOfCR + 1);
              }
            }
          }
        }
        if (midCRLF) {
          stringBuilder = stringBuilder + str.substring(from, str.length - 1);
        } else {
          stringBuilder = stringBuilder + str.substring(from, str.length);
        }
      }
    });
    return unsafeFromArray(chunkBuilder);
  };
  const loop5 = readWithCause({
    onInput: (input) => {
      const out = splitLinesChunk(input);
      return isEmpty(out) ? loop5 : flatMap17(write(out), () => loop5);
    },
    onFailure: (cause3) => stringBuilder.length === 0 ? failCause11(cause3) : flatMap17(write(of2(stringBuilder)), () => failCause11(cause3)),
    onDone: (done17) => stringBuilder.length === 0 ? succeed14(done17) : flatMap17(write(of2(stringBuilder)), () => succeed14(done17))
  });
  return loop5;
});
var toPubSub = (pubsub) => toQueue(pubsub);
var toPull = (self) => map22(acquireRelease2(sync7(() => new ChannelExecutor(self, void 0, identity)), (exec, exit3) => {
  const finalize = exec.close(exit3);
  return finalize === void 0 ? _void : finalize;
}), (exec) => suspend3(() => interpretToPull(exec.run(), exec)));
var interpretToPull = (channelState, exec) => {
  const state = channelState;
  switch (state._tag) {
    case OP_DONE3: {
      return match7(exec.getDone(), {
        onFailure: failCause9,
        onSuccess: (done17) => succeed12(left(done17))
      });
    }
    case OP_EMIT2: {
      return succeed12(right(exec.getEmit()));
    }
    case OP_FROM_EFFECT3: {
      return pipe(state.effect, flatMap15(() => interpretToPull(exec.run(), exec)));
    }
    case OP_READ2: {
      return readUpstream(state, () => interpretToPull(exec.run(), exec), (cause3) => failCause9(cause3));
    }
  }
};
var toQueue = (queue) => suspend5(() => toQueueInternal(queue));
var toQueueInternal = (queue) => {
  return readWithCause({
    onInput: (elem) => flatMap17(fromEffect5(offer3(queue, right(elem))), () => toQueueInternal(queue)),
    onFailure: (cause3) => fromEffect5(pipe(offer3(queue, left(failCause3(cause3))))),
    onDone: (done17) => fromEffect5(pipe(offer3(queue, left(succeed3(done17)))))
  });
};
var unwrap2 = (channel) => flatten11(fromEffect5(channel));
var unwrapScoped3 = (self) => concatAllWith(scoped5(self), (d, _) => d, (d, _) => d);
var updateService3 = dual(3, (self, tag4, f) => mapInputContext4(self, (context13) => merge3(context13, make7(tag4, f(unsafeGet3(context13, tag4))))));
var withSpan5 = dual(3, (self, name, options) => unwrapScoped3(flatMap15(context3(), (context13) => map22(makeSpanScoped2(name, options), (span4) => provideContext3(self, add2(context13, spanTag, span4))))));
var writeAll = (...outs) => writeChunk(fromIterable2(outs));
var writeChunk = (outs) => writeChunkWriter(0, outs.length, outs);
var writeChunkWriter = (idx, len, chunk7) => {
  return idx === len ? void_5 : pipe(write(pipe(chunk7, unsafeGet4(idx))), flatMap17(() => writeChunkWriter(idx + 1, len, chunk7)));
};
var zip11 = dual((args) => isChannel(args[1]), (self, that, options) => (options == null ? void 0 : options.concurrent) ? mergeWith(self, {
  other: that,
  onSelfDone: (exit1) => Await((exit22) => suspend3(() => zip5(exit1, exit22))),
  onOtherDone: (exit22) => Await((exit1) => suspend3(() => zip5(exit1, exit22)))
}) : flatMap17(self, (a) => map24(that, (b) => [a, b])));
var zipLeft7 = dual((args) => isChannel(args[1]), (self, that, options) => (options == null ? void 0 : options.concurrent) ? map24(zip11(self, that, {
  concurrent: true
}), (tuple4) => tuple4[0]) : flatMap17(self, (z) => as7(that, z)));
var zipRight7 = dual((args) => isChannel(args[1]), (self, that, options) => (options == null ? void 0 : options.concurrent) ? map24(zip11(self, that, {
  concurrent: true
}), (tuple4) => tuple4[1]) : flatMap17(self, () => that));
var ChannelExceptionTypeId = Symbol.for("effect/Channel/ChannelException");
var ChannelException = (error4) => ({
  _tag: "ChannelException",
  [ChannelExceptionTypeId]: ChannelExceptionTypeId,
  error: error4
});
var isChannelException = (u) => hasProperty(u, ChannelExceptionTypeId);

// ../node_modules/effect/dist/esm/internal/sink.js
var SinkTypeId3 = Symbol.for("effect/Sink");
var sinkVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _L: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var _a58;
var SinkImpl = class {
  constructor(channel) {
    __publicField(this, "channel");
    __publicField(this, _a58, sinkVariance);
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
_a58 = SinkTypeId3;
var isSink = (u) => hasProperty(u, SinkTypeId3);
var suspend6 = (evaluate3) => new SinkImpl(suspend5(() => toChannel(evaluate3())));
var as8 = dual(2, (self, a) => pipe(self, map25(() => a)));
var collectAll = () => new SinkImpl(collectAllLoop(empty5()));
var collectAllLoop = (acc) => readWithCause({
  onInput: (chunk7) => collectAllLoop(pipe(acc, appendAll2(chunk7))),
  onFailure: failCause11,
  onDone: () => succeed14(acc)
});
var collectAllN = (n) => suspend6(() => fromChannel(collectAllNLoop(n, empty5())));
var collectAllNLoop = (n, acc) => readWithCause({
  onInput: (chunk7) => {
    const [collected, leftovers] = splitAt2(chunk7, n);
    if (collected.length < n) {
      return collectAllNLoop(n - collected.length, appendAll2(acc, collected));
    }
    if (isEmpty(leftovers)) {
      return succeed14(appendAll2(acc, collected));
    }
    return flatMap17(write(leftovers), () => succeed14(appendAll2(acc, collected)));
  },
  onFailure: failCause11,
  onDone: () => succeed14(acc)
});
var collectAllFrom = (self) => collectAllWhileWith(self, {
  initial: empty5(),
  while: constTrue,
  body: (chunk7, a) => pipe(chunk7, append2(a))
});
var collectAllToMap = (key, merge15) => {
  return pipe(foldLeftChunks(empty9(), (map43, chunk7) => pipe(chunk7, reduce2(map43, (map44, input) => {
    const k = key(input);
    const v = pipe(map44, has4(k)) ? merge15(pipe(map44, unsafeGet6(k)), input) : input;
    return pipe(map44, set3(k, v));
  }))));
};
var collectAllToMapN = (n, key, merge15) => {
  return foldWeighted({
    initial: empty9(),
    maxCost: n,
    cost: (acc, input) => pipe(acc, has4(key(input))) ? 0 : 1,
    body: (acc, input) => {
      const k = key(input);
      const v = pipe(acc, has4(k)) ? merge15(pipe(acc, unsafeGet6(k)), input) : input;
      return pipe(acc, set3(k, v));
    }
  });
};
var collectAllToSet = () => foldLeftChunks(empty8(), (acc, chunk7) => pipe(chunk7, reduce2(acc, (acc2, input) => pipe(acc2, add4(input)))));
var collectAllToSetN = (n) => foldWeighted({
  initial: empty8(),
  maxCost: n,
  cost: (acc, input) => has3(acc, input) ? 0 : 1,
  body: (acc, input) => add4(acc, input)
});
var collectAllUntil = (p) => {
  return pipe(fold([empty5(), true], (tuple4) => tuple4[1], ([chunk7, _], input) => [pipe(chunk7, append2(input)), !p(input)]), map25((tuple4) => tuple4[0]));
};
var collectAllUntilEffect = (p) => {
  return pipe(foldEffect([empty5(), true], (tuple4) => tuple4[1], ([chunk7, _], input) => pipe(p(input), map22((bool) => [pipe(chunk7, append2(input)), !bool]))), map25((tuple4) => tuple4[0]));
};
var collectAllWhile = (predicate) => fromChannel(collectAllWhileReader(predicate, empty5()));
var collectAllWhileReader = (predicate, done17) => readWith({
  onInput: (input) => {
    const [collected, leftovers] = pipe(toReadonlyArray(input), span(predicate));
    if (leftovers.length === 0) {
      return collectAllWhileReader(predicate, pipe(done17, appendAll2(unsafeFromArray(collected))));
    }
    return pipe(write(unsafeFromArray(leftovers)), zipRight7(succeed14(pipe(done17, appendAll2(unsafeFromArray(collected))))));
  },
  onFailure: fail13,
  onDone: () => succeed14(done17)
});
var collectAllWhileEffect = (predicate) => fromChannel(collectAllWhileEffectReader(predicate, empty5()));
var collectAllWhileEffectReader = (predicate, done17) => readWith({
  onInput: (input) => pipe(fromEffect5(pipe(input, takeWhile3(predicate), map22(unsafeFromArray))), flatMap17((collected) => {
    const leftovers = pipe(input, drop2(collected.length));
    if (isEmpty(leftovers)) {
      return collectAllWhileEffectReader(predicate, pipe(done17, appendAll2(collected)));
    }
    return pipe(write(leftovers), zipRight7(succeed14(pipe(done17, appendAll2(collected)))));
  })),
  onFailure: fail13,
  onDone: () => succeed14(done17)
});
var collectAllWhileWith = dual(2, (self, options) => {
  const refs = pipe(make36(empty5()), zip10(make36(false)));
  const newChannel = pipe(fromEffect5(refs), flatMap17(([leftoversRef, upstreamDoneRef]) => {
    const upstreamMarker = readWith({
      onInput: (input) => pipe(write(input), flatMap17(() => upstreamMarker)),
      onFailure: fail13,
      onDone: (done17) => pipe(fromEffect5(set6(upstreamDoneRef, true)), as7(done17))
    });
    return pipe(upstreamMarker, pipeTo(bufferChunk(leftoversRef)), pipeTo(collectAllWhileWithLoop(self, leftoversRef, upstreamDoneRef, options.initial, options.while, options.body)));
  }));
  return new SinkImpl(newChannel);
});
var collectAllWhileWithLoop = (self, leftoversRef, upstreamDoneRef, currentResult, p, f) => {
  return pipe(toChannel(self), doneCollect, foldChannel({
    onFailure: fail13,
    onSuccess: ([leftovers, doneValue]) => p(doneValue) ? pipe(fromEffect5(set6(leftoversRef, flatten2(leftovers))), flatMap17(() => pipe(fromEffect5(get11(upstreamDoneRef)), flatMap17((upstreamDone) => {
      const accumulatedResult = f(currentResult, doneValue);
      return upstreamDone ? pipe(write(flatten2(leftovers)), as7(accumulatedResult)) : collectAllWhileWithLoop(self, leftoversRef, upstreamDoneRef, accumulatedResult, p, f);
    })))) : pipe(write(flatten2(leftovers)), as7(currentResult))
  }));
};
var collectLeftover = (self) => new SinkImpl(pipe(collectElements(toChannel(self)), map24(([chunks3, z]) => [z, flatten2(chunks3)])));
var mapInput7 = dual(2, (self, f) => pipe(self, mapInputChunks(map4(f))));
var mapInputEffect3 = dual(2, (self, f) => mapInputChunksEffect(self, (chunk7) => map22(forEach12(chunk7, (v) => f(v)), unsafeFromArray)));
var mapInputChunks = dual(2, (self, f) => {
  const loop5 = readWith({
    onInput: (chunk7) => pipe(write(f(chunk7)), flatMap17(() => loop5)),
    onFailure: fail13,
    onDone: succeed14
  });
  return new SinkImpl(pipe(loop5, pipeTo(toChannel(self))));
});
var mapInputChunksEffect = dual(2, (self, f) => {
  const loop5 = readWith({
    onInput: (chunk7) => pipe(fromEffect5(f(chunk7)), flatMap17(write), flatMap17(() => loop5)),
    onFailure: fail13,
    onDone: succeed14
  });
  return new SinkImpl(pipe(loop5, pipeToOrFail(toChannel(self))));
});
var die9 = (defect) => failCause12(die5(defect));
var dieMessage3 = (message) => failCause12(die5(new RuntimeException2(message)));
var dieSync6 = (evaluate3) => failCauseSync7(() => die5(evaluate3()));
var dimap = dual(2, (self, options) => map25(mapInput7(self, options.onInput), options.onDone));
var dimapEffect = dual(2, (self, options) => mapEffect6(mapInputEffect3(self, options.onInput), options.onDone));
var dimapChunks = dual(2, (self, options) => map25(mapInputChunks(self, options.onInput), options.onDone));
var dimapChunksEffect = dual(2, (self, options) => mapEffect6(mapInputChunksEffect(self, options.onInput), options.onDone));
var drain2 = new SinkImpl(drain(identityChannel()));
var drop4 = (n) => suspend6(() => new SinkImpl(dropLoop(n)));
var dropLoop = (n) => readWith({
  onInput: (input) => {
    const dropped = pipe(input, drop2(n));
    const leftover3 = Math.max(n - input.length, 0);
    const more = isEmpty(input) || leftover3 > 0;
    if (more) {
      return dropLoop(leftover3);
    }
    return pipe(write(dropped), zipRight7(identityChannel()));
  },
  onFailure: fail13,
  onDone: () => void_5
});
var dropUntil3 = (predicate) => new SinkImpl(pipe(toChannel(dropWhile4((input) => !predicate(input))), pipeToOrFail(toChannel(drop4(1)))));
var dropUntilEffect = (predicate) => suspend6(() => new SinkImpl(dropUntilEffectReader(predicate)));
var dropUntilEffectReader = (predicate) => readWith({
  onInput: (input) => pipe(input, dropUntil2(predicate), map22((leftover3) => {
    const more = leftover3.length === 0;
    return more ? dropUntilEffectReader(predicate) : pipe(write(unsafeFromArray(leftover3)), zipRight7(identityChannel()));
  }), unwrap2),
  onFailure: fail13,
  onDone: () => void_5
});
var dropWhile4 = (predicate) => new SinkImpl(dropWhileReader(predicate));
var dropWhileReader = (predicate) => readWith({
  onInput: (input) => {
    const out = pipe(input, dropWhile(predicate));
    if (isEmpty(out)) {
      return dropWhileReader(predicate);
    }
    return pipe(write(out), zipRight7(identityChannel()));
  },
  onFailure: fail13,
  onDone: succeedNow
});
var dropWhileEffect = (predicate) => suspend6(() => new SinkImpl(dropWhileEffectReader(predicate)));
var dropWhileEffectReader = (predicate) => readWith({
  onInput: (input) => pipe(input, dropWhile3(predicate), map22((leftover3) => {
    const more = leftover3.length === 0;
    return more ? dropWhileEffectReader(predicate) : pipe(write(unsafeFromArray(leftover3)), zipRight7(identityChannel()));
  }), unwrap2),
  onFailure: fail13,
  onDone: () => void_5
});
var ensuring5 = dual(2, (self, finalizer3) => new SinkImpl(pipe(self, toChannel, ensuring4(finalizer3))));
var ensuringWith2 = dual(2, (self, finalizer3) => new SinkImpl(pipe(self, toChannel, ensuringWith(finalizer3))));
var context6 = () => fromEffect7(context3());
var contextWith4 = (f) => pipe(context6(), map25(f));
var contextWithEffect4 = (f) => pipe(context6(), mapEffect6(f));
var contextWithSink = (f) => new SinkImpl(unwrap2(pipe(contextWith2((context13) => toChannel(f(context13))))));
var every10 = (predicate) => fold(true, identity, (acc, input) => acc && predicate(input));
var fail14 = (e) => new SinkImpl(fail13(e));
var failSync7 = (evaluate3) => new SinkImpl(failSync6(evaluate3));
var failCause12 = (cause3) => new SinkImpl(failCause11(cause3));
var failCauseSync7 = (evaluate3) => new SinkImpl(failCauseSync6(evaluate3));
var filterInput = (f) => {
  return (self) => pipe(self, mapInputChunks(filter2(f)));
};
var filterInputEffect = dual(2, (self, f) => mapInputChunksEffect(self, (chunk7) => map22(filter12(chunk7, f), unsafeFromArray)));
var findEffect = dual(2, (self, f) => {
  const newChannel = pipe(fromEffect5(pipe(make36(empty5()), zip10(make36(false)))), flatMap17(([leftoversRef, upstreamDoneRef]) => {
    const upstreamMarker = readWith({
      onInput: (input) => pipe(write(input), flatMap17(() => upstreamMarker)),
      onFailure: fail13,
      onDone: (done17) => pipe(fromEffect5(set6(upstreamDoneRef, true)), as7(done17))
    });
    const loop5 = foldChannel(collectElements(toChannel(self)), {
      onFailure: fail13,
      onSuccess: ([leftovers, doneValue]) => pipe(fromEffect5(f(doneValue)), flatMap17((satisfied) => pipe(fromEffect5(set6(leftoversRef, flatten2(leftovers))), zipRight7(pipe(fromEffect5(get11(upstreamDoneRef)), flatMap17((upstreamDone) => {
        if (satisfied) {
          return pipe(write(flatten2(leftovers)), as7(some2(doneValue)));
        }
        if (upstreamDone) {
          return pipe(write(flatten2(leftovers)), as7(none2()));
        }
        return loop5;
      }))))))
    });
    return pipe(upstreamMarker, pipeTo(bufferChunk(leftoversRef)), pipeTo(loop5));
  }));
  return new SinkImpl(newChannel);
});
var fold = (s, contFn, f) => suspend6(() => new SinkImpl(foldReader(s, contFn, f)));
var foldReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => {
      const [nextS, leftovers] = foldChunkSplit(s, input, contFn, f, 0, input.length);
      if (isNonEmpty2(leftovers)) {
        return pipe(write(leftovers), as7(nextS));
      }
      return foldReader(nextS, contFn, f);
    },
    onFailure: fail13,
    onDone: () => succeedNow(s)
  });
};
var foldChunkSplit = (s, chunk7, contFn, f, index, length3) => {
  if (index === length3) {
    return [s, empty5()];
  }
  const s1 = f(s, pipe(chunk7, unsafeGet4(index)));
  if (contFn(s1)) {
    return foldChunkSplit(s1, chunk7, contFn, f, index + 1, length3);
  }
  return [s1, pipe(chunk7, drop2(index + 1))];
};
var foldSink = dual(2, (self, options) => {
  const newChannel = pipe(toChannel(self), collectElements, foldChannel({
    onFailure: (error4) => toChannel(options.onFailure(error4)),
    onSuccess: ([leftovers, z]) => suspend5(() => {
      const leftoversRef = {
        ref: pipe(leftovers, filter2(isNonEmpty2))
      };
      const refReader = pipe(
        sync9(() => {
          const ref = leftoversRef.ref;
          leftoversRef.ref = empty5();
          return ref;
        }),
        // This cast is safe because of the L1 >: L <: In1 bound. It follows that
        // L <: In1 and therefore Chunk[L] can be safely cast to Chunk[In1].
        flatMap17((chunk7) => writeChunk(chunk7))
      );
      const passthrough5 = identityChannel();
      const continuationSink = pipe(refReader, zipRight7(passthrough5), pipeTo(toChannel(options.onSuccess(z))));
      return flatMap17(collectElements(continuationSink), ([newLeftovers, z1]) => pipe(succeed14(leftoversRef.ref), flatMap17(writeChunk), zipRight7(writeChunk(newLeftovers)), as7(z1)));
    })
  }));
  return new SinkImpl(newChannel);
});
var foldChunks = (s, contFn, f) => suspend6(() => new SinkImpl(foldChunksReader(s, contFn, f)));
var foldChunksReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => foldChunksReader(f(s, input), contFn, f),
    onFailure: fail13,
    onDone: () => succeedNow(s)
  });
};
var foldChunksEffect = (s, contFn, f) => suspend6(() => new SinkImpl(foldChunksEffectReader(s, contFn, f)));
var foldChunksEffectReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => pipe(fromEffect5(f(s, input)), flatMap17((s2) => foldChunksEffectReader(s2, contFn, f))),
    onFailure: fail13,
    onDone: () => succeedNow(s)
  });
};
var foldEffect = (s, contFn, f) => suspend6(() => new SinkImpl(foldEffectReader(s, contFn, f)));
var foldEffectReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => pipe(fromEffect5(foldChunkSplitEffect(s, input, contFn, f)), flatMap17(([nextS, leftovers]) => pipe(leftovers, match2({
      onNone: () => foldEffectReader(nextS, contFn, f),
      onSome: (leftover3) => pipe(write(leftover3), as7(nextS))
    })))),
    onFailure: fail13,
    onDone: () => succeedNow(s)
  });
};
var foldChunkSplitEffect = (s, chunk7, contFn, f) => foldChunkSplitEffectInternal(s, chunk7, 0, chunk7.length, contFn, f);
var foldChunkSplitEffectInternal = (s, chunk7, index, length3, contFn, f) => {
  if (index === length3) {
    return succeed12([s, none2()]);
  }
  return pipe(f(s, pipe(chunk7, unsafeGet4(index))), flatMap15((s1) => contFn(s1) ? foldChunkSplitEffectInternal(s1, chunk7, index + 1, length3, contFn, f) : succeed12([s1, some2(pipe(chunk7, drop2(index + 1)))])));
};
var foldLeft = (s, f) => ignoreLeftover(fold(s, constTrue, f));
var foldLeftChunks = (s, f) => foldChunks(s, constTrue, f);
var foldLeftChunksEffect = (s, f) => ignoreLeftover(foldChunksEffect(s, constTrue, f));
var foldLeftEffect = (s, f) => foldEffect(s, constTrue, f);
var foldUntil = (s, max9, f) => pipe(fold([s, 0], (tuple4) => tuple4[1] < max9, ([output, count9], input) => [f(output, input), count9 + 1]), map25((tuple4) => tuple4[0]));
var foldUntilEffect = (s, max9, f) => pipe(foldEffect([s, 0], (tuple4) => tuple4[1] < max9, ([output, count9], input) => pipe(f(output, input), map22((s2) => [s2, count9 + 1]))), map25((tuple4) => tuple4[0]));
var foldWeighted = (options) => foldWeightedDecompose({
  ...options,
  decompose: of2
});
var foldWeightedDecompose = (options) => suspend6(() => new SinkImpl(foldWeightedDecomposeLoop(options.initial, 0, false, options.maxCost, options.cost, options.decompose, options.body)));
var foldWeightedDecomposeLoop = (s, cost, dirty, max9, costFn, decompose, f) => readWith({
  onInput: (input) => {
    const [nextS, nextCost, nextDirty, leftovers] = foldWeightedDecomposeFold(input, 0, s, cost, dirty, max9, costFn, decompose, f);
    if (isNonEmpty2(leftovers)) {
      return pipe(write(leftovers), zipRight7(succeedNow(nextS)));
    }
    if (cost > max9) {
      return succeedNow(nextS);
    }
    return foldWeightedDecomposeLoop(nextS, nextCost, nextDirty, max9, costFn, decompose, f);
  },
  onFailure: fail13,
  onDone: () => succeedNow(s)
});
var foldWeightedDecomposeFold = (input, index, s, cost, dirty, max9, costFn, decompose, f) => {
  if (index === input.length) {
    return [s, cost, dirty, empty5()];
  }
  const elem = pipe(input, unsafeGet4(index));
  const total = cost + costFn(s, elem);
  if (total <= max9) {
    return foldWeightedDecomposeFold(input, index + 1, f(s, elem), total, true, max9, costFn, decompose, f);
  }
  const decomposed = decompose(elem);
  if (decomposed.length <= 1 && !dirty) {
    return [f(s, elem), total, true, pipe(input, drop2(index + 1))];
  }
  if (decomposed.length <= 1 && dirty) {
    return [s, cost, dirty, pipe(input, drop2(index))];
  }
  const next6 = pipe(decomposed, appendAll2(pipe(input, drop2(index + 1))));
  return foldWeightedDecomposeFold(next6, 0, s, cost, dirty, max9, costFn, decompose, f);
};
var foldWeightedDecomposeEffect = (options) => suspend6(() => new SinkImpl(foldWeightedDecomposeEffectLoop(options.initial, options.maxCost, options.cost, options.decompose, options.body, 0, false)));
var foldWeightedEffect = (options) => foldWeightedDecomposeEffect({
  ...options,
  decompose: (input) => succeed12(of2(input))
});
var foldWeightedDecomposeEffectLoop = (s, max9, costFn, decompose, f, cost, dirty) => readWith({
  onInput: (input) => pipe(fromEffect5(foldWeightedDecomposeEffectFold(s, max9, costFn, decompose, f, input, dirty, cost, 0)), flatMap17(([nextS, nextCost, nextDirty, leftovers]) => {
    if (isNonEmpty2(leftovers)) {
      return pipe(write(leftovers), zipRight7(succeedNow(nextS)));
    }
    if (cost > max9) {
      return succeedNow(nextS);
    }
    return foldWeightedDecomposeEffectLoop(nextS, max9, costFn, decompose, f, nextCost, nextDirty);
  })),
  onFailure: fail13,
  onDone: () => succeedNow(s)
});
var foldWeightedDecomposeEffectFold = (s, max9, costFn, decompose, f, input, dirty, cost, index) => {
  if (index === input.length) {
    return succeed12([s, cost, dirty, empty5()]);
  }
  const elem = pipe(input, unsafeGet4(index));
  return pipe(costFn(s, elem), map22((newCost) => cost + newCost), flatMap15((total) => {
    if (total <= max9) {
      return pipe(f(s, elem), flatMap15((s2) => foldWeightedDecomposeEffectFold(s2, max9, costFn, decompose, f, input, true, total, index + 1)));
    }
    return pipe(decompose(elem), flatMap15((decomposed) => {
      if (decomposed.length <= 1 && !dirty) {
        return pipe(f(s, elem), map22((s2) => [s2, total, true, pipe(input, drop2(index + 1))]));
      }
      if (decomposed.length <= 1 && dirty) {
        return succeed12([s, cost, dirty, pipe(input, drop2(index))]);
      }
      const next6 = pipe(decomposed, appendAll2(pipe(input, drop2(index + 1))));
      return foldWeightedDecomposeEffectFold(s, max9, costFn, decompose, f, next6, dirty, cost, 0);
    }));
  }));
};
var flatMap18 = dual(2, (self, f) => foldSink(self, {
  onFailure: fail14,
  onSuccess: f
}));
var forEach13 = (f) => {
  const process2 = readWithCause({
    onInput: (input) => pipe(fromEffect5(forEach12(input, (v) => f(v), {
      discard: true
    })), flatMap17(() => process2)),
    onFailure: failCause11,
    onDone: () => void_5
  });
  return new SinkImpl(process2);
};
var forEachChunk = (f) => {
  const process2 = readWithCause({
    onInput: (input) => pipe(fromEffect5(f(input)), flatMap17(() => process2)),
    onFailure: failCause11,
    onDone: () => void_5
  });
  return new SinkImpl(process2);
};
var forEachWhile = (f) => {
  const process2 = readWithCause({
    onInput: (input) => forEachWhileReader(f, input, 0, input.length, process2),
    onFailure: failCause11,
    onDone: () => void_5
  });
  return new SinkImpl(process2);
};
var forEachWhileReader = (f, input, index, length3, cont) => {
  if (index === length3) {
    return cont;
  }
  return pipe(fromEffect5(f(pipe(input, unsafeGet4(index)))), flatMap17((bool) => bool ? forEachWhileReader(f, input, index + 1, length3, cont) : write(pipe(input, drop2(index)))), catchAll5((error4) => pipe(write(pipe(input, drop2(index))), zipRight7(fail13(error4)))));
};
var forEachChunkWhile = (f) => {
  const reader = readWith({
    onInput: (input) => pipe(fromEffect5(f(input)), flatMap17((cont) => cont ? reader : void_5)),
    onFailure: fail13,
    onDone: () => void_5
  });
  return new SinkImpl(reader);
};
var fromChannel = (channel) => new SinkImpl(channel);
var fromEffect7 = (effect4) => new SinkImpl(fromEffect5(effect4));
var fromPubSub2 = (pubsub, options) => fromQueue2(pubsub, options);
var fromPush = (push) => new SinkImpl(unwrapScoped3(pipe(push, map22(fromPushPull))));
var fromPushPull = (push) => readWith({
  onInput: (input) => foldChannel(fromEffect5(push(some2(input))), {
    onFailure: ([either13, leftovers]) => match(either13, {
      onLeft: (error4) => pipe(write(leftovers), zipRight7(fail13(error4))),
      onRight: (z) => pipe(write(leftovers), zipRight7(succeedNow(z)))
    }),
    onSuccess: () => fromPushPull(push)
  }),
  onFailure: fail13,
  onDone: () => foldChannel(fromEffect5(push(none2())), {
    onFailure: ([either13, leftovers]) => match(either13, {
      onLeft: (error4) => pipe(write(leftovers), zipRight7(fail13(error4))),
      onRight: (z) => pipe(write(leftovers), zipRight7(succeedNow(z)))
    }),
    onSuccess: () => fromEffect5(dieMessage2("BUG: Sink.fromPush - please report an issue at https://github.com/Effect-TS/effect/issues"))
  })
});
var fromQueue2 = (queue, options) => (options == null ? void 0 : options.shutdown) ? unwrapScoped4(map22(acquireRelease2(succeed12(queue), shutdown4), fromQueue2)) : forEachChunk((input) => pipe(offerAll3(queue, input)));
var head7 = () => fold(none2(), isNone, (option9, input) => match2(option9, {
  onNone: () => some2(input),
  onSome: () => option9
}));
var ignoreLeftover = (self) => new SinkImpl(drain(toChannel(self)));
var last6 = () => foldLeftChunks(none2(), (s, input) => orElse(last2(input), () => s));
var leftover = (chunk7) => new SinkImpl(suspend5(() => write(chunk7)));
var map25 = dual(2, (self, f) => {
  return new SinkImpl(pipe(toChannel(self), map24(f)));
});
var mapEffect6 = dual(2, (self, f) => new SinkImpl(pipe(toChannel(self), mapEffect5(f))));
var mapError7 = dual(2, (self, f) => new SinkImpl(pipe(toChannel(self), mapError6(f))));
var mapLeftover = dual(2, (self, f) => new SinkImpl(pipe(toChannel(self), mapOut(map4(f)))));
var never6 = fromEffect7(never4);
var orElse10 = dual(2, (self, that) => new SinkImpl(pipe(toChannel(self), orElse9(() => toChannel(that())))));
var provideContext4 = dual(2, (self, context13) => new SinkImpl(pipe(toChannel(self), provideContext3(context13))));
var race3 = dual(2, (self, that) => pipe(self, raceBoth(that), map25(merge)));
var raceBoth = dual((args) => isSink(args[1]), (self, that, options) => raceWith3(self, {
  other: that,
  onSelfDone: (selfDone) => Done3(map22(selfDone, left)),
  onOtherDone: (thatDone) => Done3(map22(thatDone, right)),
  capacity: (options == null ? void 0 : options.capacity) ?? 16
}));
var raceWith3 = dual(2, (self, options) => {
  const scoped9 = gen2(function* ($) {
    const pubsub = yield* $(bounded4((options == null ? void 0 : options.capacity) ?? 16));
    const channel1 = yield* $(fromPubSubScoped(pubsub));
    const channel2 = yield* $(fromPubSubScoped(pubsub));
    const reader = toPubSub(pubsub);
    const writer = pipe(channel1, pipeTo(toChannel(self)), mergeWith({
      other: pipe(channel2, pipeTo(toChannel(options.other))),
      onSelfDone: options.onSelfDone,
      onOtherDone: options.onOtherDone
    }));
    const racedChannel = mergeWith(reader, {
      other: writer,
      onSelfDone: (_) => Await((exit3) => suspend3(() => exit3)),
      onOtherDone: (done17) => Done3(suspend3(() => done17))
    });
    return new SinkImpl(racedChannel);
  });
  return unwrapScoped4(scoped9);
});
var refineOrDie = dual(2, (self, pf) => pipe(self, refineOrDieWith(pf, identity)));
var refineOrDieWith = dual(3, (self, pf, f) => {
  const newChannel = pipe(self, toChannel, catchAll5((error4) => match2(pf(error4), {
    onNone: () => failCauseSync6(() => die5(f(error4))),
    onSome: fail13
  })));
  return new SinkImpl(newChannel);
});
var some9 = (predicate) => fold(false, (bool) => !bool, (acc, input) => acc || predicate(input));
var splitWhere2 = dual(2, (self, f) => {
  const newChannel = pipe(fromEffect5(make36(empty5())), flatMap17((ref) => pipe(splitWhereSplitter(false, ref, f), pipeToOrFail(toChannel(self)), collectElements, flatMap17(([leftovers, z]) => pipe(fromEffect5(get11(ref)), flatMap17((leftover3) => pipe(write(pipe(leftover3, appendAll2(flatten2(leftovers)))), zipRight7(succeed14(z)))))))));
  return new SinkImpl(newChannel);
});
var splitWhereSplitter = (written, leftovers, f) => readWithCause({
  onInput: (input) => {
    if (isEmpty(input)) {
      return splitWhereSplitter(written, leftovers, f);
    }
    if (written) {
      const index2 = indexWhere(input, f);
      if (index2 === -1) {
        return zipRight7(write(input), splitWhereSplitter(true, leftovers, f));
      }
      const [left3, right3] = splitAt2(input, index2);
      return zipRight7(write(left3), fromEffect5(set6(leftovers, right3)));
    }
    const index = indexWhere(input, f, 1);
    if (index === -1) {
      return zipRight7(write(input), splitWhereSplitter(true, leftovers, f));
    }
    const [left2, right2] = pipe(input, splitAt2(Math.max(index, 1)));
    return zipRight7(write(left2), fromEffect5(set6(leftovers, right2)));
  },
  onFailure: failCause11,
  onDone: succeed14
});
var indexWhere = (self, predicate, from = 0) => {
  const iterator = self[Symbol.iterator]();
  let index = 0;
  let result = -1;
  let next6;
  while (result < 0 && (next6 = iterator.next()) && !next6.done) {
    const a = next6.value;
    if (index >= from && predicate(a)) {
      result = index;
    }
    index = index + 1;
  }
  return result;
};
var succeed15 = (a) => new SinkImpl(succeed14(a));
var sum4 = foldLeftChunks(0, (acc, chunk7) => acc + reduce2(chunk7, 0, (s, a) => s + a));
var summarized3 = dual(3, (self, summary11, f) => {
  const newChannel = pipe(fromEffect5(summary11), flatMap17((start5) => pipe(self, toChannel, flatMap17((done17) => pipe(fromEffect5(summary11), map24((end7) => [done17, f(start5, end7)]))))));
  return new SinkImpl(newChannel);
});
var sync10 = (evaluate3) => new SinkImpl(sync9(evaluate3));
var take5 = (n) => pipe(foldChunks(empty5(), (chunk7) => chunk7.length < n, (acc, chunk7) => pipe(acc, appendAll2(chunk7))), flatMap18((acc) => {
  const [taken, leftover3] = pipe(acc, splitAt2(n));
  return new SinkImpl(pipe(write(leftover3), zipRight7(succeedNow(taken))));
}));
var toChannel = (self) => isEffect2(self) ? toChannel(fromEffect7(self)) : self.channel;
var unwrap3 = (effect4) => new SinkImpl(unwrap2(pipe(effect4, map22((sink) => toChannel(sink)))));
var unwrapScoped4 = (effect4) => {
  return new SinkImpl(unwrapScoped3(pipe(effect4, map22((sink) => toChannel(sink)))));
};
var withDuration = (self) => pipe(self, summarized3(currentTimeMillis2, (start5, end7) => millis(end7 - start5)));
var zip12 = dual((args) => isSink(args[1]), (self, that, options) => zipWith10(self, that, (z, z2) => [z, z2], options));
var zipLeft8 = dual((args) => isSink(args[1]), (self, that, options) => zipWith10(self, that, (z, _) => z, options));
var zipRight8 = dual((args) => isSink(args[1]), (self, that, options) => zipWith10(self, that, (_, z2) => z2, options));
var zipWith10 = dual((args) => isSink(args[1]), (self, that, f, options) => (options == null ? void 0 : options.concurrent) ? raceWith3(self, {
  other: that,
  onSelfDone: match7({
    onFailure: (cause3) => Done3(failCause9(cause3)),
    onSuccess: (leftZ) => Await(match7({
      onFailure: failCause9,
      onSuccess: (rightZ) => succeed12(f(leftZ, rightZ))
    }))
  }),
  onOtherDone: match7({
    onFailure: (cause3) => Done3(failCause9(cause3)),
    onSuccess: (rightZ) => Await(match7({
      onFailure: failCause9,
      onSuccess: (leftZ) => succeed12(f(leftZ, rightZ))
    }))
  })
}) : flatMap18(self, (z) => map25(that, (z2) => f(z, z2))));
var channelToSink = (self) => new SinkImpl(self);
var count3 = foldLeftChunks(0, (acc, chunk7) => acc + chunk7.length);
var mkString = suspend6(() => {
  const strings = [];
  return pipe(foldLeftChunks(void 0, (_, elems) => map4(elems, (elem) => {
    strings.push(String(elem));
  })), map25(() => strings.join("")));
});
var timed3 = pipe(withDuration(drain2), map25((tuple4) => tuple4[1]));

// ../node_modules/effect/dist/esm/MergeDecision.js
var MergeDecision_exports = {};
__export(MergeDecision_exports, {
  Await: () => Await2,
  AwaitConst: () => AwaitConst2,
  Done: () => Done4,
  MergeDecisionTypeId: () => MergeDecisionTypeId2,
  isMergeDecision: () => isMergeDecision2,
  match: () => match25
});
var MergeDecisionTypeId2 = MergeDecisionTypeId;
var Done4 = Done3;
var Await2 = Await;
var AwaitConst2 = AwaitConst;
var isMergeDecision2 = isMergeDecision;
var match25 = match22;

// ../node_modules/effect/dist/esm/Runtime.js
var Runtime_exports = {};
__export(Runtime_exports, {
  FiberFailureCauseId: () => FiberFailureCauseId2,
  FiberFailureId: () => FiberFailureId2,
  defaultRuntime: () => defaultRuntime2,
  defaultRuntimeFlags: () => defaultRuntimeFlags2,
  deleteFiberRef: () => deleteFiberRef2,
  disableRuntimeFlag: () => disableRuntimeFlag2,
  enableRuntimeFlag: () => enableRuntimeFlag2,
  isAsyncFiberException: () => isAsyncFiberException2,
  isFiberFailure: () => isFiberFailure2,
  make: () => make60,
  makeFiberFailure: () => makeFiberFailure,
  provideService: () => provideService6,
  runCallback: () => runCallback2,
  runFork: () => runFork2,
  runPromise: () => runPromise2,
  runPromiseExit: () => runPromiseExit2,
  runSync: () => runSync2,
  runSyncExit: () => runSyncExit2,
  setFiberRef: () => setFiberRef2,
  updateContext: () => updateContext2,
  updateFiberRefs: () => updateFiberRefs4,
  updateRuntimeFlags: () => updateRuntimeFlags3
});
var runFork2 = unsafeFork2;
var runSyncExit2 = unsafeRunSyncExit;
var runSync2 = unsafeRunSync;
var runCallback2 = unsafeRunCallback;
var runPromise2 = unsafeRunPromise;
var runPromiseExit2 = unsafeRunPromiseExit;
var defaultRuntime2 = defaultRuntime;
var defaultRuntimeFlags2 = defaultRuntimeFlags;
var make60 = make56;
var FiberFailureId2 = Symbol.for("effect/Runtime/FiberFailure");
var FiberFailureCauseId2 = FiberFailureCauseId;
var isAsyncFiberException2 = isAsyncFiberException;
var isFiberFailure2 = isFiberFailure;
var makeFiberFailure = fiberFailure;
var updateRuntimeFlags3 = updateRuntimeFlags2;
var enableRuntimeFlag2 = enableRuntimeFlag;
var disableRuntimeFlag2 = disableRuntimeFlag;
var updateContext2 = updateContext;
var provideService6 = provideService3;
var updateFiberRefs4 = updateFiberRefs2;
var setFiberRef2 = setFiberRef;
var deleteFiberRef2 = deleteFiberRef;

// ../node_modules/effect/dist/esm/Schedule.js
var Schedule_exports = {};
__export(Schedule_exports, {
  ScheduleDriverTypeId: () => ScheduleDriverTypeId2,
  ScheduleTypeId: () => ScheduleTypeId2,
  addDelay: () => addDelay2,
  addDelayEffect: () => addDelayEffect2,
  andThen: () => andThen9,
  andThenEither: () => andThenEither2,
  as: () => as9,
  asVoid: () => asVoid6,
  bothInOut: () => bothInOut2,
  check: () => check2,
  checkEffect: () => checkEffect2,
  collectAllInputs: () => collectAllInputs2,
  collectAllOutputs: () => collectAllOutputs2,
  collectUntil: () => collectUntil2,
  collectUntilEffect: () => collectUntilEffect2,
  collectWhile: () => collectWhile2,
  collectWhileEffect: () => collectWhileEffect2,
  compose: () => compose2,
  count: () => count4,
  cron: () => cron2,
  dayOfMonth: () => dayOfMonth2,
  dayOfWeek: () => dayOfWeek2,
  delayed: () => delayed2,
  delayedEffect: () => delayedEffect2,
  delayedSchedule: () => delayedSchedule2,
  delays: () => delays2,
  driver: () => driver2,
  duration: () => duration2,
  either: () => either6,
  eitherWith: () => eitherWith2,
  elapsed: () => elapsed2,
  ensuring: () => ensuring6,
  exponential: () => exponential3,
  fibonacci: () => fibonacci2,
  fixed: () => fixed2,
  forever: () => forever4,
  fromDelay: () => fromDelay2,
  fromDelays: () => fromDelays2,
  fromFunction: () => fromFunction4,
  hourOfDay: () => hourOfDay2,
  identity: () => identity3,
  intersect: () => intersect6,
  intersectWith: () => intersectWith2,
  jittered: () => jittered2,
  jitteredWith: () => jitteredWith2,
  linear: () => linear3,
  makeWithState: () => makeWithState2,
  map: () => map26,
  mapBoth: () => mapBoth5,
  mapBothEffect: () => mapBothEffect2,
  mapEffect: () => mapEffect7,
  mapInput: () => mapInput8,
  mapInputContext: () => mapInputContext5,
  mapInputEffect: () => mapInputEffect4,
  minuteOfHour: () => minuteOfHour2,
  modifyDelay: () => modifyDelay2,
  modifyDelayEffect: () => modifyDelayEffect2,
  onDecision: () => onDecision2,
  once: () => once4,
  passthrough: () => passthrough4,
  provideContext: () => provideContext5,
  provideService: () => provideService7,
  recurUntil: () => recurUntil2,
  recurUntilEffect: () => recurUntilEffect2,
  recurUntilOption: () => recurUntilOption2,
  recurUpTo: () => recurUpTo2,
  recurWhile: () => recurWhile2,
  recurWhileEffect: () => recurWhileEffect2,
  recurs: () => recurs2,
  reduce: () => reduce16,
  reduceEffect: () => reduceEffect4,
  repeatForever: () => repeatForever,
  repetitions: () => repetitions2,
  resetAfter: () => resetAfter2,
  resetWhen: () => resetWhen2,
  run: () => run4,
  secondOfMinute: () => secondOfMinute2,
  spaced: () => spaced2,
  stop: () => stop2,
  succeed: () => succeed16,
  sync: () => sync11,
  tapInput: () => tapInput2,
  tapOutput: () => tapOutput2,
  unfold: () => unfold3,
  union: () => union13,
  unionWith: () => unionWith2,
  untilInput: () => untilInput2,
  untilInputEffect: () => untilInputEffect2,
  untilOutput: () => untilOutput2,
  untilOutputEffect: () => untilOutputEffect2,
  upTo: () => upTo2,
  whileInput: () => whileInput2,
  whileInputEffect: () => whileInputEffect2,
  whileOutput: () => whileOutput2,
  whileOutputEffect: () => whileOutputEffect2,
  windowed: () => windowed2,
  zipLeft: () => zipLeft9,
  zipRight: () => zipRight9,
  zipWith: () => zipWith11
});
var ScheduleTypeId2 = ScheduleTypeId;
var ScheduleDriverTypeId2 = ScheduleDriverTypeId;
var makeWithState2 = makeWithState;
var addDelay2 = addDelay;
var addDelayEffect2 = addDelayEffect;
var andThen9 = andThen7;
var andThenEither2 = andThenEither;
var as9 = as5;
var asVoid6 = asVoid3;
var bothInOut2 = bothInOut;
var check2 = check;
var checkEffect2 = checkEffect;
var collectAllInputs2 = collectAllInputs;
var collectAllOutputs2 = collectAllOutputs;
var collectUntil2 = collectUntil;
var collectUntilEffect2 = collectUntilEffect;
var collectWhile2 = collectWhile;
var collectWhileEffect2 = collectWhileEffect;
var compose2 = compose;
var mapInput8 = mapInput5;
var mapInputContext5 = mapInputContext2;
var mapInputEffect4 = mapInputEffect;
var count4 = count;
var cron2 = cron;
var dayOfMonth2 = dayOfMonth;
var dayOfWeek2 = dayOfWeek;
var delayed2 = delayed;
var delayedEffect2 = delayedEffect;
var delayedSchedule2 = delayedSchedule;
var delays2 = delays;
var mapBoth5 = mapBoth3;
var mapBothEffect2 = mapBothEffect;
var driver2 = driver;
var duration2 = duration;
var either6 = either4;
var eitherWith2 = eitherWith;
var elapsed2 = elapsed;
var ensuring6 = ensuring2;
var exponential3 = exponential2;
var fibonacci2 = fibonacci;
var fixed2 = fixed;
var forever4 = forever2;
var fromDelay2 = fromDelay;
var fromDelays2 = fromDelays;
var fromFunction4 = fromFunction;
var hourOfDay2 = hourOfDay;
var identity3 = identity2;
var intersect6 = intersect5;
var intersectWith2 = intersectWith;
var jittered2 = jittered;
var jitteredWith2 = jitteredWith;
var linear3 = linear2;
var map26 = map19;
var mapEffect7 = mapEffect3;
var minuteOfHour2 = minuteOfHour;
var modifyDelay2 = modifyDelay;
var modifyDelayEffect2 = modifyDelayEffect;
var onDecision2 = onDecision;
var once4 = once2;
var passthrough4 = passthrough;
var provideContext5 = provideContext2;
var provideService7 = provideService2;
var recurUntil2 = recurUntil;
var recurUntilEffect2 = recurUntilEffect;
var recurUntilOption2 = recurUntilOption;
var recurUpTo2 = recurUpTo;
var recurWhile2 = recurWhile;
var recurWhileEffect2 = recurWhileEffect;
var recurs2 = recurs;
var reduce16 = reduce14;
var reduceEffect4 = reduceEffect2;
var repeatForever = forever2;
var repetitions2 = repetitions;
var resetAfter2 = resetAfter;
var resetWhen2 = resetWhen;
var run4 = run;
var secondOfMinute2 = secondOfMinute;
var spaced2 = spaced;
var stop2 = stop;
var succeed16 = succeed8;
var sync11 = sync5;
var tapInput2 = tapInput;
var tapOutput2 = tapOutput;
var unfold3 = unfold2;
var union13 = union12;
var unionWith2 = unionWith;
var untilInput2 = untilInput;
var untilInputEffect2 = untilInputEffect;
var untilOutput2 = untilOutput;
var untilOutputEffect2 = untilOutputEffect;
var upTo2 = upTo;
var whileInput2 = whileInput;
var whileInputEffect2 = whileInputEffect;
var whileOutput2 = whileOutput;
var whileOutputEffect2 = whileOutputEffect;
var windowed2 = windowed;
var zipLeft9 = zipLeft4;
var zipRight9 = zipRight4;
var zipWith11 = zipWith5;

// ../node_modules/effect/dist/esm/StreamHaltStrategy.js
var StreamHaltStrategy_exports = {};
__export(StreamHaltStrategy_exports, {
  Both: () => Both2,
  Either: () => Either2,
  Left: () => Left2,
  Right: () => Right2,
  fromInput: () => fromInput3,
  isBoth: () => isBoth2,
  isEither: () => isEither3,
  isLeft: () => isLeft3,
  isRight: () => isRight3,
  match: () => match27
});

// ../node_modules/effect/dist/esm/internal/opCodes/streamHaltStrategy.js
var OP_LEFT = "Left";
var OP_RIGHT = "Right";
var OP_BOTH = "Both";
var OP_EITHER = "Either";

// ../node_modules/effect/dist/esm/internal/stream/haltStrategy.js
var Left = {
  _tag: OP_LEFT
};
var Right = {
  _tag: OP_RIGHT
};
var Both = {
  _tag: OP_BOTH
};
var Either = {
  _tag: OP_EITHER
};
var fromInput2 = (input) => {
  switch (input) {
    case "left":
      return Left;
    case "right":
      return Right;
    case "both":
      return Both;
    case "either":
      return Either;
    default:
      return input;
  }
};
var isLeft2 = (self) => self._tag === OP_LEFT;
var isRight2 = (self) => self._tag === OP_RIGHT;
var isBoth = (self) => self._tag === OP_BOTH;
var isEither2 = (self) => self._tag === OP_EITHER;
var match26 = dual(2, (self, options) => {
  switch (self._tag) {
    case OP_LEFT: {
      return options.onLeft();
    }
    case OP_RIGHT: {
      return options.onRight();
    }
    case OP_BOTH: {
      return options.onBoth();
    }
    case OP_EITHER: {
      return options.onEither();
    }
  }
});

// ../node_modules/effect/dist/esm/StreamHaltStrategy.js
var Left2 = Left;
var Right2 = Right;
var Both2 = Both;
var Either2 = Either;
var fromInput3 = fromInput2;
var isLeft3 = isLeft2;
var isRight3 = isRight2;
var isBoth2 = isBoth;
var isEither3 = isEither2;
var match27 = match26;

// ../node_modules/effect/dist/esm/internal/ringBuffer.js
var RingBuffer = class {
  constructor(capacity10) {
    __publicField(this, "capacity");
    __publicField(this, "array");
    __publicField(this, "size", 0);
    __publicField(this, "current", 0);
    this.capacity = capacity10;
    this.array = Array.from({
      length: capacity10
    }, constUndefined);
  }
  head() {
    return fromNullable(this.array[this.current]);
  }
  lastOrNull() {
    if (this.size === 0) {
      return void 0;
    }
    const index = this.current === 0 ? this.array.length - 1 : this.current - 1;
    return this.array[index] ?? void 0;
  }
  put(value8) {
    this.array[this.current] = value8;
    this.increment();
  }
  dropLast() {
    if (this.size > 0) {
      this.decrement();
      this.array[this.current] = void 0;
    }
  }
  toChunk() {
    const begin = this.current - this.size;
    const newArray = begin < 0 ? [...this.array.slice(this.capacity + begin, this.capacity), ...this.array.slice(0, this.current)] : this.array.slice(begin, this.current);
    return fromIterable2(newArray);
  }
  increment() {
    if (this.size < this.capacity) {
      this.size += 1;
    }
    this.current = (this.current + 1) % this.capacity;
  }
  decrement() {
    this.size -= 1;
    if (this.current > 0) {
      this.current -= 1;
    } else {
      this.current = this.capacity - 1;
    }
  }
};

// ../node_modules/effect/dist/esm/internal/stream/debounceState.js
var OP_NOT_STARTED = "NotStarted";
var OP_PREVIOUS = "Previous";
var OP_CURRENT = "Current";
var notStarted = {
  _tag: OP_NOT_STARTED
};
var previous = (fiber) => ({
  _tag: OP_PREVIOUS,
  fiber
});
var current = (fiber) => ({
  _tag: OP_CURRENT,
  fiber
});

// ../node_modules/effect/dist/esm/internal/stream/emit.js
var make61 = (emit2) => {
  const ops = {
    chunk(as16) {
      return this(succeed12(as16));
    },
    die(defect) {
      return this(die7(defect));
    },
    dieMessage(message) {
      return this(dieMessage2(message));
    },
    done(exit3) {
      return this(suspend3(() => mapBoth2(exit3, {
        onFailure: some2,
        onSuccess: of2
      })));
    },
    end() {
      return this(fail11(none2()));
    },
    fail(e) {
      return this(fail11(some2(e)));
    },
    fromEffect(effect4) {
      return this(mapBoth4(effect4, {
        onFailure: some2,
        onSuccess: of2
      }));
    },
    fromEffectChunk(effect4) {
      return this(pipe(effect4, mapError4(some2)));
    },
    halt(cause3) {
      return this(failCause9(pipe(cause3, map18(some2))));
    },
    single(value8) {
      return this(succeed12(of2(value8)));
    }
  };
  return Object.assign(emit2, ops);
};

// ../node_modules/effect/dist/esm/internal/stream/handoff.js
var HandoffTypeId = Symbol.for("effect/Stream/Handoff");
var OP_HANDOFF_STATE_EMPTY = "Empty";
var OP_HANDOFF_STATE_FULL = "Full";
var handoffStateEmpty = (notifyConsumer) => ({
  _tag: OP_HANDOFF_STATE_EMPTY,
  notifyConsumer
});
var handoffStateFull = (value8, notifyProducer) => ({
  _tag: OP_HANDOFF_STATE_FULL,
  value: value8,
  notifyProducer
});
var handoffStateMatch = (onEmpty, onFull) => {
  return (self) => {
    switch (self._tag) {
      case OP_HANDOFF_STATE_EMPTY: {
        return onEmpty(self.notifyConsumer);
      }
      case OP_HANDOFF_STATE_FULL: {
        return onFull(self.value, self.notifyProducer);
      }
    }
  };
};
var handoffVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var make62 = () => pipe(make23(), flatMap15((deferred) => make36(handoffStateEmpty(deferred))), map22((ref) => ({
  [HandoffTypeId]: handoffVariance,
  ref
})));
var offer4 = dual(2, (self, value8) => {
  return flatMap15(make23(), (deferred) => flatten9(modify6(self.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [zipRight6(succeed2(notifyConsumer, void 0), _await(deferred)), handoffStateFull(value8, deferred)], (_, notifyProducer) => [flatMap15(_await(notifyProducer), () => pipe(self, offer4(value8))), state])))));
});
var take6 = (self) => flatMap15(make23(), (deferred) => flatten9(modify6(self.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [flatMap15(_await(notifyConsumer), () => take6(self)), state], (value8, notifyProducer) => [as6(succeed2(notifyProducer, void 0), value8), handoffStateEmpty(deferred)])))));

// ../node_modules/effect/dist/esm/internal/stream/handoffSignal.js
var OP_EMIT4 = "Emit";
var OP_HALT = "Halt";
var OP_END = "End";
var emit = (elements) => ({
  _tag: OP_EMIT4,
  elements
});
var halt = (cause3) => ({
  _tag: OP_HALT,
  cause: cause3
});
var end3 = (reason) => ({
  _tag: OP_END,
  reason
});

// ../node_modules/effect/dist/esm/internal/take.js
var TakeSymbolKey = "effect/Take";
var TakeTypeId = Symbol.for(TakeSymbolKey);
var takeVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _E: (_) => _
};
var _a59;
var TakeImpl = class {
  constructor(exit3) {
    __publicField(this, "exit");
    __publicField(this, _a59, takeVariance);
    this.exit = exit3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
_a59 = TakeTypeId;
var chunk3 = (chunk7) => new TakeImpl(succeed3(chunk7));
var die10 = (defect) => new TakeImpl(die4(defect));
var dieMessage4 = (message) => new TakeImpl(die4(new RuntimeException2(message)));
var done9 = (self) => suspend3(() => self.exit);
var end4 = new TakeImpl(fail4(none2()));
var fail15 = (error4) => new TakeImpl(fail4(some2(error4)));
var failCause13 = (cause3) => new TakeImpl(failCause3(pipe(cause3, map18(some2))));
var fromEffect8 = (effect4) => matchCause3(effect4, {
  onFailure: failCause13,
  onSuccess: of6
});
var fromExit = (exit3) => new TakeImpl(pipe(exit3, mapBoth2({
  onFailure: some2,
  onSuccess: of2
})));
var fromPull = (pull) => matchCause3(pull, {
  onFailure: (cause3) => match2(flipCauseOption2(cause3), {
    onNone: () => end4,
    onSome: failCause13
  }),
  onSuccess: chunk3
});
var isDone6 = (self) => match7(self.exit, {
  onFailure: (cause3) => isNone(flipCauseOption2(cause3)),
  onSuccess: constFalse
});
var isFailure6 = (self) => match7(self.exit, {
  onFailure: (cause3) => isSome(flipCauseOption2(cause3)),
  onSuccess: constFalse
});
var isSuccess4 = (self) => match7(self.exit, {
  onFailure: constFalse,
  onSuccess: constTrue
});
var make63 = (exit3) => new TakeImpl(exit3);
var match28 = dual(2, (self, {
  onEnd,
  onFailure,
  onSuccess
}) => match7(self.exit, {
  onFailure: (cause3) => match2(flipCauseOption2(cause3), {
    onNone: onEnd,
    onSome: onFailure
  }),
  onSuccess
}));
var matchEffect4 = dual(2, (self, {
  onEnd,
  onFailure,
  onSuccess
}) => matchEffect2(self.exit, {
  onFailure: (cause3) => match2(flipCauseOption2(cause3), {
    onNone: () => onEnd,
    onSome: onFailure
  }),
  onSuccess
}));
var map27 = dual(2, (self, f) => new TakeImpl(pipe(self.exit, map12(map4(f)))));
var of6 = (value8) => new TakeImpl(succeed3(of2(value8)));
var tap5 = dual(2, (self, f) => pipe(self.exit, forEachEffect(f), asVoid4));

// ../node_modules/effect/dist/esm/internal/stream/pull.js
var end5 = () => fail11(none2());
var failCause14 = (cause3) => mapError4(failCause9(cause3), some2);

// ../node_modules/effect/dist/esm/internal/stream/sinkEndReason.js
var OP_SCHEDULE_END = "ScheduleEnd";
var OP_UPSTREAM_END = "UpstreamEnd";
var ScheduleEnd = {
  _tag: OP_SCHEDULE_END
};
var UpstreamEnd = {
  _tag: OP_UPSTREAM_END
};

// ../node_modules/effect/dist/esm/internal/stream/zipAllState.js
var OP_DRAIN_LEFT = "DrainLeft";
var OP_DRAIN_RIGHT = "DrainRight";
var OP_PULL_BOTH = "PullBoth";
var OP_PULL_LEFT = "PullLeft";
var OP_PULL_RIGHT = "PullRight";
var DrainLeft = {
  _tag: OP_DRAIN_LEFT
};
var DrainRight = {
  _tag: OP_DRAIN_RIGHT
};
var PullBoth = {
  _tag: OP_PULL_BOTH
};
var PullLeft = (rightChunk) => ({
  _tag: OP_PULL_LEFT,
  rightChunk
});
var PullRight = (leftChunk) => ({
  _tag: OP_PULL_RIGHT,
  leftChunk
});

// ../node_modules/effect/dist/esm/internal/stream/zipChunksState.js
var OP_PULL_BOTH2 = "PullBoth";
var OP_PULL_LEFT2 = "PullLet";
var OP_PULL_RIGHT2 = "PullRight";
var PullBoth2 = {
  _tag: OP_PULL_BOTH2
};
var PullLeft2 = (rightChunk) => ({
  _tag: OP_PULL_LEFT2,
  rightChunk
});
var PullRight2 = (leftChunk) => ({
  _tag: OP_PULL_RIGHT2,
  leftChunk
});

// ../node_modules/effect/dist/esm/internal/stream.js
var StreamSymbolKey = "effect/Stream";
var StreamTypeId3 = Symbol.for(StreamSymbolKey);
var streamVariance = {
  _R: (_) => _,
  _E: (_) => _,
  _A: (_) => _
};
var _a60;
var StreamImpl = class {
  constructor(channel) {
    __publicField(this, "channel");
    __publicField(this, _a60, streamVariance);
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
_a60 = StreamTypeId3;
var isStream = (u) => hasProperty(u, StreamTypeId3) || isEffect2(u);
var DefaultChunkSize = 4096;
var accumulate = (self) => chunks(accumulateChunks(self));
var accumulateChunks = (self) => {
  const accumulator = (s) => readWith({
    onInput: (input) => {
      const next6 = appendAll2(s, input);
      return flatMap17(write(next6), () => accumulator(next6));
    },
    onFailure: fail13,
    onDone: () => void_5
  });
  return new StreamImpl(pipeTo(toChannel2(self), accumulator(empty5())));
};
var acquireRelease3 = (acquire3, release3) => scoped6(acquireRelease2(acquire3, release3));
var aggregate = dual(2, (self, sink) => aggregateWithin(self, sink, forever4));
var aggregateWithin = dual(3, (self, sink, schedule4) => filterMap8(aggregateWithinEither(self, sink, schedule4), (_) => match(_, {
  onLeft: none2,
  onRight: some2
})));
var aggregateWithinEither = dual(3, (self, sink, schedule4) => {
  const layer = all7([make62(), make36(ScheduleEnd), make36(empty5()), driver2(schedule4), make36(false), make36(false)]);
  return pipe(fromEffect9(layer), flatMap19(([handoff, sinkEndReason, sinkLeftovers, scheduleDriver, consumed, endAfterEmit]) => {
    const handoffProducer = readWithCause({
      onInput: (input) => flatMap17(fromEffect5(pipe(handoff, offer4(emit(input)), when2(() => isNonEmpty2(input)))), () => handoffProducer),
      onFailure: (cause3) => fromEffect5(offer4(handoff, halt(cause3))),
      onDone: () => fromEffect5(offer4(handoff, end3(UpstreamEnd)))
    });
    const handoffConsumer = pipe(getAndSet3(sinkLeftovers, empty5()), flatMap15((leftovers) => {
      if (isNonEmpty2(leftovers)) {
        return pipe(set6(consumed, true), zipRight6(succeed12(pipe(write(leftovers), flatMap17(() => handoffConsumer)))));
      }
      return pipe(take6(handoff), map22((signal) => {
        switch (signal._tag) {
          case OP_EMIT4: {
            return pipe(fromEffect5(set6(consumed, true)), zipRight7(write(signal.elements)), zipRight7(fromEffect5(get11(endAfterEmit))), flatMap17((bool) => bool ? void_5 : handoffConsumer));
          }
          case OP_HALT: {
            return failCause11(signal.cause);
          }
          case OP_END: {
            if (signal.reason._tag === OP_SCHEDULE_END) {
              return pipe(get11(consumed), map22((bool) => bool ? fromEffect5(pipe(set6(sinkEndReason, ScheduleEnd), zipRight6(set6(endAfterEmit, true)))) : pipe(fromEffect5(pipe(set6(sinkEndReason, ScheduleEnd), zipRight6(set6(endAfterEmit, true)))), flatMap17(() => handoffConsumer))), unwrap2);
            }
            return pipe(set6(sinkEndReason, signal.reason), zipRight6(set6(endAfterEmit, true)), fromEffect5);
          }
        }
      }));
    }), unwrap2);
    const timeout5 = (lastB) => scheduleDriver.next(lastB);
    const scheduledAggregator = (sinkFiber, scheduleFiber, scope5) => {
      const forkSink = pipe(set6(consumed, false), zipRight6(set6(endAfterEmit, false)), zipRight6(pipe(handoffConsumer, pipeToOrFail(toChannel(sink)), collectElements, run2, forkIn2(scope5))));
      const handleSide = (leftovers, b, c) => pipe(set6(sinkLeftovers, flatten2(leftovers)), zipRight6(map22(get11(sinkEndReason), (reason) => {
        switch (reason._tag) {
          case OP_SCHEDULE_END: {
            return pipe(all7([get11(consumed), forkSink, pipe(timeout5(some2(b)), forkIn2(scope5))]), map22(([wasConsumed, sinkFiber2, scheduleFiber2]) => {
              const toWrite = pipe(c, match2({
                onNone: () => of2(right(b)),
                onSome: (c2) => make8(right(b), left(c2))
              }));
              if (wasConsumed) {
                return pipe(write(toWrite), flatMap17(() => scheduledAggregator(sinkFiber2, scheduleFiber2, scope5)));
              }
              return scheduledAggregator(sinkFiber2, scheduleFiber2, scope5);
            }), unwrap2);
          }
          case OP_UPSTREAM_END: {
            return pipe(get11(consumed), map22((wasConsumed) => wasConsumed ? write(of2(right(b))) : void_5), unwrap2);
          }
        }
      })), unwrap2);
      return unwrap2(raceWith2(join4(sinkFiber), join4(scheduleFiber), {
        onSelfDone: (sinkExit, _) => pipe(interrupt6(scheduleFiber), zipRight6(pipe(suspend3(() => sinkExit), map22(([leftovers, b]) => handleSide(leftovers, b, none2()))))),
        onOtherDone: (scheduleExit, _) => matchCauseEffect2(suspend3(() => scheduleExit), {
          onFailure: (cause3) => match(failureOrCause2(cause3), {
            onLeft: () => pipe(handoff, offer4(end3(ScheduleEnd)), forkDaemon2, zipRight6(pipe(join4(sinkFiber), map22(([leftovers, b]) => handleSide(leftovers, b, none2()))))),
            onRight: (cause4) => pipe(handoff, offer4(halt(cause4)), forkDaemon2, zipRight6(pipe(join4(sinkFiber), map22(([leftovers, b]) => handleSide(leftovers, b, none2())))))
          }),
          onSuccess: (c) => pipe(handoff, offer4(end3(ScheduleEnd)), forkDaemon2, zipRight6(pipe(join4(sinkFiber), map22(([leftovers, b]) => handleSide(leftovers, b, some2(c))))))
        })
      }));
    };
    return unwrapScoped5(pipe(self, toChannel2, pipeTo(handoffProducer), run2, forkScoped2, zipRight6(pipe(handoffConsumer, pipeToOrFail(toChannel(sink)), collectElements, run2, forkScoped2, flatMap15((sinkFiber) => pipe(forkScoped2(timeout5(none2())), flatMap15((scheduleFiber) => pipe(scope3, map22((scope5) => new StreamImpl(scheduledAggregator(sinkFiber, scheduleFiber, scope5)))))))))));
  }));
});
var as10 = dual(2, (self, value8) => map28(self, () => value8));
var _async = (register, outputBuffer = 16) => acquireRelease2(bounded5(outputBuffer), (queue) => shutdown4(queue)).pipe(flatMap15((output) => runtime4().pipe(flatMap15((runtime8) => sync7(() => {
  const runPromiseExit3 = runPromiseExit2(runtime8);
  const canceler = register(make61((resume2) => fromPull(resume2).pipe(flatMap15((take14) => offer3(output, take14)), asVoid4, runPromiseExit3).then((exit3) => {
    if (isFailure2(exit3)) {
      if (!isInterrupted3(exit3.cause)) {
        throw squash(exit3.cause);
      }
    }
  })));
  return canceler;
})), map22((value8) => {
  const loop5 = take4(output).pipe(flatMap15((take14) => done9(take14)), match17({
    onFailure: (maybeError) => fromEffect5(shutdown4(output)).pipe(zipRight7(match2(maybeError, {
      onNone: () => void_5,
      onSome: (error4) => fail13(error4)
    }))),
    onSuccess: (chunk7) => write(chunk7).pipe(flatMap17(() => loop5))
  }), unwrap2);
  return fromChannel2(loop5).pipe(ensuring7(value8 ?? _void));
}))), unwrapScoped5);
var asyncEffect3 = (register, outputBuffer = 16) => pipe(acquireRelease2(bounded5(outputBuffer), (queue) => shutdown4(queue)), flatMap15((output) => pipe(runtime4(), flatMap15((runtime8) => pipe(register(make61((k) => pipe(fromPull(k), flatMap15((take14) => offer3(output, take14)), asVoid4, runPromiseExit2(runtime8)).then((exit3) => {
  if (isFailure2(exit3)) {
    if (!isInterrupted3(exit3.cause)) {
      throw squash(exit3.cause);
    }
  }
}))), map22(() => {
  const loop5 = pipe(take4(output), flatMap15(done9), match17({
    onFailure: (maybeError) => pipe(fromEffect5(shutdown4(output)), zipRight7(match2(maybeError, {
      onNone: () => void_5,
      onSome: fail13
    }))),
    onSuccess: (chunk7) => pipe(write(chunk7), flatMap17(() => loop5))
  }), unwrap2);
  return loop5;
}))))), unwrapScoped3, fromChannel2);
var asyncScoped = (register, outputBuffer = 16) => pipe(acquireRelease2(bounded5(outputBuffer), (queue) => shutdown4(queue)), flatMap15((output) => pipe(runtime4(), flatMap15((runtime8) => pipe(register(make61((k) => pipe(fromPull(k), flatMap15((take14) => offer3(output, take14)), asVoid4, runPromiseExit2(runtime8)).then((exit3) => {
  if (isFailure2(exit3)) {
    if (!isInterrupted3(exit3.cause)) {
      throw squash(exit3.cause);
    }
  }
}))), zipRight6(make36(false)), flatMap15((ref) => pipe(get11(ref), map22((isDone9) => isDone9 ? end5() : pipe(take4(output), flatMap15(done9), onError2(() => pipe(set6(ref, true), zipRight6(shutdown4(output)))))))))))), scoped6, flatMap19(repeatEffectChunkOption));
var branchAfter = dual(3, (self, n, f) => suspend7(() => {
  const buffering = (acc) => readWith({
    onInput: (input) => {
      const nextSize = acc.length + input.length;
      if (nextSize >= n) {
        const [b1, b2] = pipe(input, splitAt2(n - acc.length));
        return running4(pipe(acc, appendAll2(b1)), b2);
      }
      return buffering(pipe(acc, appendAll2(input)));
    },
    onFailure: fail13,
    onDone: () => running4(acc, empty5())
  });
  const running4 = (prefix, leftover3) => pipeTo(zipRight7(write(leftover3), identityChannel()), toChannel2(f(prefix)));
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(buffering(empty5()))));
}));
var broadcast = dual(3, (self, n, maximumLag) => pipe(self, broadcastedQueues(n, maximumLag), map22((tuple4) => tuple4.map((queue) => flattenTake(fromQueue3(queue, {
  shutdown: true
}))))));
var broadcastDynamic = dual(2, (self, maximumLag) => pipe(self, broadcastedQueuesDynamic(maximumLag), map22((effect4) => flattenTake(flatMap19(scoped6(effect4), fromQueue3)))));
var broadcastedQueues = dual(3, (self, n, maximumLag) => flatMap15(bounded4(maximumLag), (pubsub) => pipe(all7(Array.from({
  length: n
}, () => subscribe2(pubsub))), tap3(() => forkScoped2(runIntoPubSubScoped(self, pubsub))))));
var broadcastedQueuesDynamic = dual(2, (self, maximumLag) => map22(toPubSub2(self, maximumLag), subscribe2));
var buffer2 = dual(2, (self, options) => {
  if (options.capacity === "unbounded") {
    return bufferUnbounded(self);
  } else if (options.strategy === "dropping") {
    return bufferDropping(self, options.capacity);
  } else if (options.strategy === "sliding") {
    return bufferSliding(self, options.capacity);
  }
  const queue = toQueueOfElements(self, options);
  return new StreamImpl(unwrapScoped3(map22(queue, (queue2) => {
    const process2 = pipe(fromEffect5(take4(queue2)), flatMap17(match7({
      onFailure: (cause3) => pipe(flipCauseOption2(cause3), match2({
        onNone: () => void_5,
        onSome: failCause11
      })),
      onSuccess: (value8) => flatMap17(write(of2(value8)), () => process2)
    })));
    return process2;
  })));
});
var bufferChunks = dual(2, (self, options) => {
  if (options.strategy === "dropping") {
    return bufferChunksDropping(self, options.capacity);
  } else if (options.strategy === "sliding") {
    return bufferChunksSliding(self, options.capacity);
  }
  const queue = toQueue2(self, options);
  return new StreamImpl(unwrapScoped3(map22(queue, (queue2) => {
    const process2 = pipe(fromEffect5(take4(queue2)), flatMap17(match28({
      onEnd: () => void_5,
      onFailure: failCause11,
      onSuccess: (value8) => pipe(write(value8), flatMap17(() => process2))
    })));
    return process2;
  })));
});
var bufferChunksDropping = dual(2, (self, capacity10) => {
  const queue = acquireRelease2(dropping4(capacity10), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self)));
});
var bufferChunksSliding = dual(2, (self, capacity10) => {
  const queue = acquireRelease2(sliding4(capacity10), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self)));
});
var bufferDropping = dual(2, (self, capacity10) => {
  const queue = acquireRelease2(dropping4(capacity10), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(rechunk(1)(self))));
});
var bufferSliding = dual(2, (self, capacity10) => {
  const queue = acquireRelease2(sliding4(capacity10), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(pipe(self, rechunk(1)))));
});
var bufferUnbounded = (self) => {
  const queue = toQueue2(self, {
    strategy: "unbounded"
  });
  return new StreamImpl(unwrapScoped3(map22(queue, (queue2) => {
    const process2 = pipe(fromEffect5(take4(queue2)), flatMap17(match28({
      onEnd: () => void_5,
      onFailure: failCause11,
      onSuccess: (value8) => flatMap17(write(value8), () => process2)
    })));
    return process2;
  })));
};
var bufferSignal = (scoped9, bufferChannel) => {
  const producer = (queue, ref) => {
    const terminate = (take14) => pipe(get11(ref), tap3(_await), zipRight6(make23()), flatMap15((deferred) => pipe(offer3(queue, [take14, deferred]), zipRight6(set6(ref, deferred)), zipRight6(_await(deferred)))), asVoid4, fromEffect5);
    return readWithCause({
      onInput: (input) => pipe(make23(), flatMap15((deferred) => pipe(offer3(queue, [chunk3(input), deferred]), flatMap15((added) => pipe(set6(ref, deferred), when2(() => added))))), asVoid4, fromEffect5, flatMap17(() => producer(queue, ref))),
      onFailure: (error4) => terminate(failCause13(error4)),
      onDone: () => terminate(end4)
    });
  };
  const consumer = (queue) => {
    const process2 = pipe(fromEffect5(take4(queue)), flatMap17(([take14, deferred]) => zipRight7(fromEffect5(succeed2(deferred, void 0)), match28(take14, {
      onEnd: () => void_5,
      onFailure: failCause11,
      onSuccess: (value8) => pipe(write(value8), flatMap17(() => process2))
    }))));
    return process2;
  };
  return unwrapScoped3(pipe(scoped9, flatMap15((queue) => pipe(make23(), tap3((start5) => succeed2(start5, void 0)), flatMap15((start5) => pipe(make36(start5), flatMap15((ref) => pipe(bufferChannel, pipeTo(producer(queue, ref)), runScoped, forkScoped2)), as6(consumer(queue))))))));
};
var catchAll6 = dual(2, (self, f) => catchAllCause6(self, (cause3) => match(failureOrCause2(cause3), {
  onLeft: f,
  onRight: failCause15
})));
var catchAllCause6 = dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), catchAllCause5((cause3) => toChannel2(f(cause3))))));
var catchSome3 = dual(2, (self, pf) => pipe(self, catchAll6((error4) => pipe(pf(error4), getOrElse(() => fail16(error4))))));
var catchSomeCause3 = dual(2, (self, pf) => pipe(self, catchAllCause6((cause3) => pipe(pf(cause3), getOrElse(() => failCause15(cause3))))));
var catchTag3 = dual(3, (self, k, f) => catchAll6(self, (e) => {
  if ("_tag" in e && e["_tag"] === k) {
    return f(e);
  }
  return fail16(e);
}));
var catchTags3 = dual(2, (self, cases) => catchAll6(self, (e) => {
  const keys10 = Object.keys(cases);
  if ("_tag" in e && keys10.includes(e["_tag"])) {
    return cases[e["_tag"]](e);
  }
  return fail16(e);
}));
var changes = (self) => pipe(self, changesWith((x, y) => equals(y)(x)));
var changesWith = dual(2, (self, f) => {
  const writer = (last8) => readWithCause({
    onInput: (input) => {
      const [newLast, newChunk] = reduce2(input, [last8, empty5()], ([option9, outputs], output) => {
        if (isSome(option9) && f(option9.value, output)) {
          return [some2(output), outputs];
        }
        return [some2(output), pipe(outputs, append2(output))];
      });
      return flatMap17(write(newChunk), () => writer(newLast));
    },
    onFailure: failCause11,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(writer(none2()))));
});
var changesWithEffect = dual(2, (self, f) => {
  const writer = (last8) => readWithCause({
    onInput: (input) => pipe(input, reduce15([last8, empty5()], ([option9, outputs], output) => {
      if (isSome(option9)) {
        return pipe(f(option9.value, output), map22((bool) => bool ? [some2(output), outputs] : [some2(output), pipe(outputs, append2(output))]));
      }
      return succeed12([some2(output), pipe(outputs, append2(output))]);
    }), fromEffect5, flatMap17(([newLast, newChunk]) => pipe(write(newChunk), flatMap17(() => writer(newLast))))),
    onFailure: failCause11,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(writer(none2()))));
});
var chunks = (self) => pipe(self, mapChunks(of2));
var chunksWith = dual(2, (self, f) => flattenChunks(f(chunks(self))));
var unsome = (effect4) => catchAll3(asSome2(effect4), (o) => o._tag === "None" ? succeedNone2 : fail11(o.value));
var combine14 = dual(4, (self, that, s, f) => {
  const producer = (handoff, latch) => pipe(fromEffect5(take6(latch)), zipRight7(readWithCause({
    onInput: (input) => flatMap17(fromEffect5(pipe(handoff, offer4(succeed3(input)))), () => producer(handoff, latch)),
    onFailure: (cause3) => fromEffect5(offer4(handoff, failCause3(pipe(cause3, map18(some2))))),
    onDone: () => flatMap17(fromEffect5(offer4(handoff, fail4(none2()))), () => producer(handoff, latch))
  })));
  return new StreamImpl(unwrapScoped3(gen2(function* ($) {
    const left2 = yield* $(make62());
    const right2 = yield* $(make62());
    const latchL = yield* $(make62());
    const latchR = yield* $(make62());
    yield* $(toChannel2(self), concatMap(writeChunk), pipeTo(producer(left2, latchL)), runScoped, forkScoped2);
    yield* $(toChannel2(that), concatMap(writeChunk), pipeTo(producer(right2, latchR)), runScoped, forkScoped2);
    const pullLeft = pipe(
      latchL,
      offer4(void 0),
      // TODO: remove
      zipRight6(pipe(take6(left2), flatMap15((exit3) => suspend3(() => exit3))))
    );
    const pullRight = pipe(
      latchR,
      offer4(void 0),
      // TODO: remove
      zipRight6(pipe(take6(right2), flatMap15((exit3) => suspend3(() => exit3))))
    );
    return toChannel2(unfoldEffect(s, (s2) => flatMap15(f(s2, pullLeft, pullRight), unsome)));
  })));
});
var combineChunks = dual(4, (self, that, s, f) => {
  const producer = (handoff, latch) => zipRight7(fromEffect5(take6(latch)), readWithCause({
    onInput: (input) => flatMap17(fromEffect5(pipe(handoff, offer4(chunk3(input)))), () => producer(handoff, latch)),
    onFailure: (cause3) => fromEffect5(offer4(handoff, failCause13(cause3))),
    onDone: () => fromEffect5(offer4(handoff, end4))
  }));
  return new StreamImpl(pipe(all7([make62(), make62(), make62(), make62()]), tap3(([left2, _, latchL]) => pipe(toChannel2(self), pipeTo(producer(left2, latchL)), runScoped, forkScoped2)), tap3(([_, right2, __, latchR]) => pipe(toChannel2(that), pipeTo(producer(right2, latchR)), runScoped, forkScoped2)), map22(([left2, right2, latchL, latchR]) => {
    const pullLeft = pipe(latchL, offer4(void 0), zipRight6(pipe(take6(left2), flatMap15(done9))));
    const pullRight = pipe(latchR, offer4(void 0), zipRight6(pipe(take6(right2), flatMap15(done9))));
    return toChannel2(unfoldChunkEffect(s, (s2) => flatMap15(f(s2, pullLeft, pullRight), unsome)));
  }), unwrapScoped3));
});
var concat2 = dual(2, (self, that) => new StreamImpl(pipe(toChannel2(self), zipRight7(toChannel2(that)))));
var concatAll2 = (streams) => suspend7(() => pipe(streams, reduce2(empty40, (x, y) => concat2(y)(x))));
var cross = dual(2, (self, that) => pipe(self, crossWith(that, (a, a2) => [a, a2])));
var crossLeft = dual(2, (self, that) => pipe(self, crossWith(that, (a, _) => a)));
var crossRight = dual(2, (self, that) => flatMap19(self, () => that));
var crossWith = dual(3, (self, that, f) => pipe(self, flatMap19((a) => pipe(that, map28((b) => f(a, b))))));
var debounce = dual(2, (self, duration5) => pipe(make59(), flatMap15((input) => transplant2((grafter) => pipe(make62(), map22((handoff) => {
  const enqueue = (last8) => pipe(sleep2(duration5), as6(last8), fork3, grafter, map22((fiber) => consumer(previous(fiber))));
  const producer = readWithCause({
    onInput: (input2) => match2(last2(input2), {
      onNone: () => producer,
      onSome: (last8) => flatMap17(fromEffect5(offer4(handoff, emit(of2(last8)))), () => producer)
    }),
    onFailure: (cause3) => fromEffect5(offer4(handoff, halt(cause3))),
    onDone: () => fromEffect5(offer4(handoff, end3(UpstreamEnd)))
  });
  const consumer = (state) => {
    switch (state._tag) {
      case OP_NOT_STARTED: {
        return pipe(take6(handoff), map22((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return unwrap2(enqueue(signal.elements));
            }
            case OP_HALT: {
              return failCause11(signal.cause);
            }
            case OP_END: {
              return void_5;
            }
          }
        }), unwrap2);
      }
      case OP_PREVIOUS: {
        return unwrap2(raceWith2(join4(state.fiber), take6(handoff), {
          onSelfDone: (leftExit, current2) => match7(leftExit, {
            onFailure: (cause3) => pipe(interrupt6(current2), as6(failCause11(cause3))),
            onSuccess: (chunk7) => succeed12(pipe(write(chunk7), flatMap17(() => consumer(current(current2)))))
          }),
          onOtherDone: (rightExit, previous2) => match7(rightExit, {
            onFailure: (cause3) => pipe(interrupt6(previous2), as6(failCause11(cause3))),
            onSuccess: (signal) => {
              switch (signal._tag) {
                case OP_EMIT4: {
                  return pipe(interrupt6(previous2), zipRight6(enqueue(signal.elements)));
                }
                case OP_HALT: {
                  return pipe(interrupt6(previous2), as6(failCause11(signal.cause)));
                }
                case OP_END: {
                  return pipe(join4(previous2), map22((chunk7) => pipe(write(chunk7), zipRight7(void_5))));
                }
              }
            }
          })
        }));
      }
      case OP_CURRENT: {
        return pipe(join4(state.fiber), map22((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return unwrap2(enqueue(signal.elements));
            }
            case OP_HALT: {
              return failCause11(signal.cause);
            }
            case OP_END: {
              return void_5;
            }
          }
        }), unwrap2);
      }
    }
  };
  const debounceChannel = pipe(fromInput(input), pipeTo(producer), run2, forkScoped2, as6(pipe(consumer(notStarted), embedInput(input))), unwrapScoped3);
  return new StreamImpl(pipe(toChannel2(self), pipeTo(debounceChannel)));
})))), unwrap4));
var die11 = (defect) => fromEffect9(die7(defect));
var dieSync7 = (evaluate3) => fromEffect9(dieSync4(evaluate3));
var dieMessage5 = (message) => fromEffect9(dieMessage2(message));
var distributedWith = dual(2, (self, options) => pipe(make23(), flatMap15((deferred) => pipe(self, distributedWithDynamic({
  maximumLag: options.maximumLag,
  decide: (a) => flatMap15(_await(deferred), (f) => f(a))
}), flatMap15((next6) => pipe(all7(map4(range(0, options.size - 1), (id3) => map22(next6, ([key, queue]) => [[key, id3], queue]))), map22(unsafeFromArray), flatMap15((entries6) => {
  const [mappings, queues] = reduceRight2(entries6, [/* @__PURE__ */ new Map(), empty5()], ([mappings2, queues2], [mapping, queue]) => [mappings2.set(mapping[0], mapping[1]), pipe(queues2, prepend2(queue))]);
  return pipe(succeed2(deferred, (a) => map22(options.decide(a), (f) => (key) => pipe(f(mappings.get(key))))), as6(Array.from(queues)));
})))))));
var distributedWithDynamicId = {
  ref: 0
};
var newDistributedWithDynamicId = () => {
  const current2 = distributedWithDynamicId.ref;
  distributedWithDynamicId.ref = current2 + 1;
  return current2;
};
var distributedWithDynamic = dual(2, (self, options) => distributedWithDynamicCallback(self, options.maximumLag, options.decide, () => _void));
var distributedWithDynamicCallback = dual(4, (self, maximumLag, decide, done17) => pipe(acquireRelease2(make36(/* @__PURE__ */ new Map()), (ref, _) => pipe(get11(ref), flatMap15((queues) => pipe(queues.values(), forEach12(shutdown4))))), flatMap15((queuesRef) => gen2(function* ($) {
  const offer9 = (a) => pipe(decide(a), flatMap15((shouldProcess) => pipe(get11(queuesRef), flatMap15((queues) => pipe(queues.entries(), reduce15(empty5(), (acc, [id3, queue]) => {
    if (shouldProcess(id3)) {
      return pipe(offer3(queue, succeed3(a)), matchCauseEffect2({
        onFailure: (cause3) => (
          // Ignore all downstream queues that were shut
          // down and remove them later
          isInterrupted3(cause3) ? succeed12(pipe(acc, prepend2(id3))) : failCause9(cause3)
        ),
        onSuccess: () => succeed12(acc)
      }));
    }
    return succeed12(acc);
  }), flatMap15((ids3) => {
    if (isNonEmpty2(ids3)) {
      return pipe(update4(queuesRef, (map43) => {
        for (const id3 of ids3) {
          map43.delete(id3);
        }
        return map43;
      }));
    }
    return _void;
  }))))), asVoid4);
  const queuesLock = yield* $(makeSemaphore2(1));
  const newQueue = yield* $(make36(pipe(bounded5(maximumLag), flatMap15((queue) => {
    const id3 = newDistributedWithDynamicId();
    return pipe(update4(queuesRef, (map43) => map43.set(id3, queue)), as6([id3, queue]));
  }))));
  const finalize = (endTake) => (
    // Make sure that no queues are currently being added
    queuesLock.withPermits(1)(pipe(set6(newQueue, pipe(
      // All newly created queues should end immediately
      bounded5(1),
      tap3((queue) => offer3(queue, endTake)),
      flatMap15((queue) => {
        const id3 = newDistributedWithDynamicId();
        return pipe(update4(queuesRef, (map43) => map43.set(id3, queue)), as6(make3(id3, queue)));
      })
    )), zipRight6(pipe(get11(queuesRef), flatMap15((map43) => pipe(fromIterable2(map43.values()), forEach12((queue) => pipe(offer3(queue, endTake), catchSomeCause2((cause3) => isInterrupted3(cause3) ? some2(_void) : none2()))))))), zipRight6(done17(endTake)), asVoid4))
  );
  yield* $(self, runForEachScoped(offer9), matchCauseEffect2({
    onFailure: (cause3) => finalize(failCause3(pipe(cause3, map18(some2)))),
    onSuccess: () => finalize(fail4(none2()))
  }), forkScoped2);
  return queuesLock.withPermits(1)(flatten9(get11(newQueue)));
}))));
var drain3 = (self) => new StreamImpl(drain(toChannel2(self)));
var drainFork = dual(2, (self, that) => pipe(fromEffect9(make23()), flatMap19((backgroundDied) => pipe(scoped6(pipe(that, runForEachScoped(() => _void), catchAllCause3((cause3) => failCause2(backgroundDied, cause3)), forkScoped2)), crossRight(pipe(self, interruptWhenDeferred2(backgroundDied)))))));
var drop5 = dual(2, (self, n) => {
  const loop5 = (r) => readWith({
    onInput: (input) => {
      const dropped = pipe(input, drop2(r));
      const leftover3 = Math.max(0, r - input.length);
      const more = isEmpty(input) || leftover3 > 0;
      if (more) {
        return loop5(leftover3);
      }
      return pipe(write(dropped), zipRight7(identityChannel()));
    },
    onFailure: fail13,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop5(n))));
});
var dropRight2 = dual(2, (self, n) => {
  if (n <= 0) {
    return identityStream();
  }
  return suspend7(() => {
    const queue = new RingBuffer(n);
    const reader = readWith({
      onInput: (input) => {
        const outputs = pipe(input, filterMap2((elem) => {
          const head11 = queue.head();
          queue.put(elem);
          return head11;
        }));
        return pipe(write(outputs), flatMap17(() => reader));
      },
      onFailure: fail13,
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(reader)));
  });
});
var dropUntil4 = dual(2, (self, predicate) => drop5(dropWhile5(self, (a) => !predicate(a)), 1));
var dropUntilEffect2 = dual(2, (self, predicate) => {
  const loop5 = readWith({
    onInput: (input) => pipe(dropUntil2(input, predicate), map22(unsafeFromArray), map22((leftover3) => {
      const more = isEmpty(leftover3);
      if (more) {
        return suspend5(() => loop5);
      }
      return pipe(write(leftover3), zipRight7(identityChannel()));
    }), unwrap2),
    onFailure: fail13,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop5)));
});
var dropWhile5 = dual(2, (self, predicate) => {
  const loop5 = readWith({
    onInput: (input) => {
      const output = dropWhile(input, predicate);
      if (isEmpty(output)) {
        return suspend5(() => loop5);
      }
      return zipRight7(write(output), identityChannel());
    },
    onFailure: fail13,
    onDone: succeedNow
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self), loop5));
});
var dropWhileEffect2 = dual(2, (self, predicate) => {
  const loop5 = readWith({
    onInput: (input) => pipe(dropWhile3(input, predicate), map22(unsafeFromArray), map22((leftover3) => {
      const more = isEmpty(leftover3);
      if (more) {
        return suspend5(() => loop5);
      }
      return zipRight7(write(leftover3), identityChannel());
    }), unwrap2),
    onFailure: fail13,
    onDone: () => void_5
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self), loop5));
});
var either7 = (self) => pipe(self, map28(right), catchAll6((error4) => make64(left(error4))));
var empty40 = new StreamImpl(write(empty5()));
var ensuring7 = dual(2, (self, finalizer3) => new StreamImpl(pipe(toChannel2(self), ensuring4(finalizer3))));
var ensuringWith3 = dual(2, (self, finalizer3) => new StreamImpl(ensuringWith(toChannel2(self), finalizer3)));
var context7 = () => fromEffect9(context3());
var contextWith5 = (f) => pipe(context7(), map28(f));
var contextWithEffect5 = (f) => pipe(context7(), mapEffectSequential(f));
var contextWithStream = (f) => pipe(context7(), flatMap19(f));
var execute = (effect4) => drain3(fromEffect9(effect4));
var fail16 = (error4) => fromEffectOption(fail11(some2(error4)));
var failSync8 = (evaluate3) => fromEffectOption(failSync4(() => some2(evaluate3())));
var failCause15 = (cause3) => fromEffect9(failCause9(cause3));
var failCauseSync8 = (evaluate3) => fromEffect9(failCauseSync4(evaluate3));
var filter13 = dual(2, (self, predicate) => mapChunks(self, filter2(predicate)));
var filterEffect = dual(2, (self, f) => {
  const loop5 = (iterator) => {
    const next6 = iterator.next();
    if (next6.done) {
      return readWithCause({
        onInput: (input) => loop5(input[Symbol.iterator]()),
        onFailure: failCause11,
        onDone: succeed14
      });
    } else {
      return pipe(f(next6.value), map22((bool) => bool ? pipe(write(of2(next6.value)), flatMap17(() => loop5(iterator))) : loop5(iterator)), unwrap2);
    }
  };
  return new StreamImpl(suspend5(() => pipe(toChannel2(self), pipeTo(loop5(empty5()[Symbol.iterator]())))));
});
var filterMap8 = dual(2, (self, pf) => mapChunks(self, filterMap2(pf)));
var filterMapEffect = dual(2, (self, pf) => suspend7(() => {
  const loop5 = (iterator) => {
    const next6 = iterator.next();
    if (next6.done) {
      return readWithCause({
        onInput: (input) => loop5(input[Symbol.iterator]()),
        onFailure: failCause11,
        onDone: succeed14
      });
    } else {
      return pipe(pf(next6.value), match2({
        onNone: () => sync7(() => loop5(iterator)),
        onSome: map22((a2) => flatMap17(write(of2(a2)), () => loop5(iterator)))
      }), unwrap2);
    }
  };
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop5(empty5()[Symbol.iterator]()))));
}));
var filterMapWhile3 = dual(2, (self, pf) => {
  const loop5 = readWith({
    onInput: (input) => {
      const mapped = filterMapWhile2(input, pf);
      if (mapped.length === input.length) {
        return pipe(write(mapped), flatMap17(() => loop5));
      }
      return write(mapped);
    },
    onFailure: fail13,
    onDone: succeed14
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop5)));
});
var filterMapWhileEffect = dual(2, (self, pf) => suspend7(() => {
  const loop5 = (iterator) => {
    const next6 = iterator.next();
    if (next6.done) {
      return readWithCause({
        onInput: (input) => loop5(input[Symbol.iterator]()),
        onFailure: failCause11,
        onDone: succeed14
      });
    } else {
      return unwrap2(match2(pf(next6.value), {
        onNone: () => succeed12(void_5),
        onSome: map22((a2) => flatMap17(write(of2(a2)), () => loop5(iterator)))
      }));
    }
  };
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop5(empty5()[Symbol.iterator]()))));
}));
var finalizer = (finalizer3) => acquireRelease3(_void, () => finalizer3);
var find3 = dual(2, (self, predicate) => {
  const loop5 = readWith({
    onInput: (input) => match2(findFirst2(input, predicate), {
      onNone: () => loop5,
      onSome: (n) => write(of2(n))
    }),
    onFailure: fail13,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop5)));
});
var findEffect2 = dual(2, (self, predicate) => {
  const loop5 = readWith({
    onInput: (input) => pipe(findFirst9(input, predicate), map22(match2({
      onNone: () => loop5,
      onSome: (n) => write(of2(n))
    })), unwrap2),
    onFailure: fail13,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop5)));
});
var flatMap19 = dual((args) => isStream(args[0]), (self, f, options) => {
  const bufferSize = (options == null ? void 0 : options.bufferSize) ?? 16;
  if (options == null ? void 0 : options.switch) {
    return matchConcurrency(options == null ? void 0 : options.concurrency, () => flatMapParSwitchBuffer(self, 1, bufferSize, f), (n) => flatMapParSwitchBuffer(self, n, bufferSize, f));
  }
  return matchConcurrency(options == null ? void 0 : options.concurrency, () => new StreamImpl(concatMap(toChannel2(self), (as16) => pipe(as16, map4((a) => toChannel2(f(a))), reduce2(void_5, (left2, right2) => pipe(left2, zipRight7(right2)))))), (_) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), options))));
});
var matchConcurrency = (concurrency, sequential6, bounded10) => {
  switch (concurrency) {
    case void 0:
      return sequential6();
    case "unbounded":
      return bounded10(Number.MAX_SAFE_INTEGER);
    default:
      return concurrency > 1 ? bounded10(concurrency) : sequential6();
  }
};
var flatMapParSwitchBuffer = dual(4, (self, n, bufferSize, f) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), {
  concurrency: n,
  mergeStrategy: BufferSliding(),
  bufferSize
}))));
var flatten12 = dual((args) => isStream(args[0]), (self, options) => flatMap19(self, identity, options));
var flattenChunks = (self) => {
  const flatten17 = readWithCause({
    onInput: (chunks3) => flatMap17(writeChunk(chunks3), () => flatten17),
    onFailure: failCause11,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(flatten17)));
};
var flattenEffect = dual((args) => isStream(args[0]), (self, options) => (options == null ? void 0 : options.unordered) ? flatMap19(self, (a) => fromEffect9(a), {
  concurrency: options.concurrency
}) : matchConcurrency(options == null ? void 0 : options.concurrency, () => mapEffectSequential(self, identity), (n) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mapOutEffectPar(identity, n), mapOut(of2)))));
var flattenExitOption = (self) => {
  const processChunk = (chunk7, cont) => {
    const [toEmit, rest] = pipe(chunk7, splitWhere((exit3) => !isSuccess(exit3)));
    const next6 = pipe(head2(rest), match2({
      onNone: () => cont,
      onSome: match7({
        onFailure: (cause3) => match2(flipCauseOption2(cause3), {
          onNone: () => void_5,
          onSome: failCause11
        }),
        onSuccess: () => void_5
      })
    }));
    return pipe(write(pipe(toEmit, filterMap2((exit3) => isSuccess(exit3) ? some2(exit3.value) : none2()))), flatMap17(() => next6));
  };
  const process2 = readWithCause({
    onInput: (chunk7) => processChunk(chunk7, process2),
    onFailure: (cause3) => failCause11(cause3),
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(process2)));
};
var flattenIterables = (self) => pipe(self, map28(fromIterable2), flattenChunks);
var flattenTake = (self) => flattenChunks(flattenExitOption(pipe(self, map28((take14) => take14.exit))));
var forever5 = (self) => new StreamImpl(repeated(toChannel2(self)));
var fromAsyncIterable = (iterable, onError5) => pipe(acquireRelease2(sync7(() => iterable[Symbol.asyncIterator]()), (iterator) => iterator.return ? promise2(async () => iterator.return()) : _void), map22((iterator) => repeatEffectOption(pipe(tryPromise2({
  try: async () => iterator.next(),
  catch: (reason) => some2(onError5(reason))
}), flatMap15((result) => result.done ? fail11(none2()) : succeed12(result.value))))), unwrapScoped5);
var fromChannel2 = (channel) => new StreamImpl(channel);
var toChannel2 = (stream) => {
  if ("channel" in stream) {
    return stream.channel;
  } else if (isEffect2(stream)) {
    return toChannel2(fromEffect9(stream));
  } else {
    throw new TypeError(`Expected a Stream.`);
  }
};
var fromChunk = (chunk7) => new StreamImpl(isEmpty(chunk7) ? void_5 : write(chunk7));
var fromChunkPubSub = (pubsub, options) => {
  if (options == null ? void 0 : options.scoped) {
    const effect4 = map22(subscribe2(pubsub), fromChunkQueue);
    return options.shutdown ? map22(effect4, ensuring7(shutdown3(pubsub))) : effect4;
  }
  const stream = flatMap19(scoped6(subscribe2(pubsub)), fromChunkQueue);
  return (options == null ? void 0 : options.shutdown) ? ensuring7(stream, shutdown3(pubsub)) : stream;
};
var fromChunkQueue = (queue, options) => pipe(take4(queue), catchAllCause3((cause3) => pipe(isShutdown4(queue), flatMap15((isShutdown9) => isShutdown9 && isInterrupted3(cause3) ? end5() : failCause14(cause3)))), repeatEffectChunkOption, (options == null ? void 0 : options.shutdown) ? ensuring7(shutdown4(queue)) : identity);
var fromChunks = (...chunks3) => pipe(fromIterable16(chunks3), flatMap19(fromChunk));
var fromEffect9 = (effect4) => pipe(effect4, mapError4(some2), fromEffectOption);
var fromEffectOption = (effect4) => new StreamImpl(unwrap2(match17(effect4, {
  onFailure: match2({
    onNone: () => void_5,
    onSome: fail13
  }),
  onSuccess: (a) => write(of2(a))
})));
var fromPubSub3 = (pubsub, options) => {
  const maxChunkSize = (options == null ? void 0 : options.maxChunkSize) ?? DefaultChunkSize;
  if (options == null ? void 0 : options.scoped) {
    const effect4 = map22(subscribe2(pubsub), (queue) => fromQueue3(queue, {
      maxChunkSize,
      shutdown: true
    }));
    return options.shutdown ? map22(effect4, ensuring7(shutdown3(pubsub))) : effect4;
  }
  const stream = flatMap19(scoped6(subscribe2(pubsub)), (queue) => fromQueue3(queue, {
    maxChunkSize
  }));
  return (options == null ? void 0 : options.shutdown) ? ensuring7(stream, shutdown3(pubsub)) : stream;
};
var fromIterable16 = (iterable) => suspend7(() => isChunk(iterable) ? fromChunk(iterable) : fromIteratorSucceed(iterable[Symbol.iterator]()));
var fromIterableEffect = (effect4) => pipe(effect4, map22(fromIterable16), unwrap4);
var fromIteratorSucceed = (iterator, maxChunkSize = DefaultChunkSize) => {
  return pipe(sync7(() => {
    let builder = [];
    const loop5 = (iterator2) => pipe(sync7(() => {
      let next6 = iterator2.next();
      if (maxChunkSize === 1) {
        if (next6.done) {
          return void_5;
        }
        return pipe(write(of2(next6.value)), flatMap17(() => loop5(iterator2)));
      }
      builder = [];
      let count9 = 0;
      while (next6.done === false) {
        builder.push(next6.value);
        count9 = count9 + 1;
        if (count9 >= maxChunkSize) {
          break;
        }
        next6 = iterator2.next();
      }
      if (count9 > 0) {
        return pipe(write(unsafeFromArray(builder)), flatMap17(() => loop5(iterator2)));
      }
      return void_5;
    }), unwrap2);
    return new StreamImpl(loop5(iterator));
  }), unwrap4);
};
var fromPull2 = (effect4) => pipe(effect4, map22(repeatEffectChunkOption), unwrapScoped5);
var fromQueue3 = (queue, options) => pipe(takeBetween2(queue, 1, (options == null ? void 0 : options.maxChunkSize) ?? DefaultChunkSize), catchAllCause3((cause3) => pipe(isShutdown4(queue), flatMap15((isShutdown9) => isShutdown9 && isInterrupted3(cause3) ? end5() : failCause14(cause3)))), repeatEffectChunkOption, (options == null ? void 0 : options.shutdown) ? ensuring7(shutdown4(queue)) : identity);
var fromSchedule = (schedule4) => pipe(driver2(schedule4), map22((driver3) => repeatEffectOption(driver3.next(void 0))), unwrap4);
var fromReadableStream = (evaluate3, onError5) => unwrapScoped5(map22(acquireRelease2(sync7(() => evaluate3().getReader()), (reader) => promise2(() => reader.cancel())), (reader) => repeatEffectOption(flatMap15(tryPromise2({
  try: () => reader.read(),
  catch: (reason) => some2(onError5(reason))
}), ({
  done: done17,
  value: value8
}) => done17 ? fail11(none2()) : succeed12(value8)))));
var fromReadableStreamByob = (evaluate3, onError5, allocSize = 4096) => unwrapScoped5(map22(acquireRelease2(sync7(() => evaluate3().getReader({
  mode: "byob"
})), (reader) => promise2(() => reader.cancel())), (reader) => catchAll6(forever5(readChunkStreamByobReader(reader, onError5, allocSize)), (error4) => isTagged(error4, "EOF") ? empty40 : fail16(error4))));
var readChunkStreamByobReader = (reader, onError5, size38) => {
  const buffer5 = new ArrayBuffer(size38);
  return paginateEffect(0, (offset) => flatMap15(tryPromise2({
    try: () => reader.read(new Uint8Array(buffer5, offset, buffer5.byteLength - offset)),
    catch: (reason) => onError5(reason)
  }), ({
    done: done17,
    value: value8
  }) => {
    if (done17) {
      return fail11({
        _tag: "EOF"
      });
    }
    const newOffset = offset + value8.byteLength;
    return succeed12([value8, newOffset >= buffer5.byteLength ? none2() : some2(newOffset)]);
  }));
};
var groupAdjacentBy = dual(2, (self, f) => {
  const groupAdjacentByChunk = (state, chunk7) => {
    if (isEmpty(chunk7)) {
      return [state, empty5()];
    }
    const builder = [];
    let from = 0;
    let until = 0;
    let key = void 0;
    let previousChunk = empty5();
    switch (state._tag) {
      case "Some": {
        const tuple4 = state.value;
        key = tuple4[0];
        let loop5 = true;
        while (loop5 && until < chunk7.length) {
          const input = unsafeGet4(chunk7, until);
          const updatedKey = f(input);
          if (!equals(key, updatedKey)) {
            const previousChunk2 = tuple4[1];
            const additionalChunk = unsafeFromArray(Array.from(chunk7).slice(from, until));
            const group3 = appendAll2(previousChunk2, additionalChunk);
            builder.push([key, group3]);
            key = updatedKey;
            from = until;
            loop5 = false;
          }
          until = until + 1;
        }
        if (loop5) {
          previousChunk = tuple4[1];
        }
        break;
      }
      case "None": {
        key = f(unsafeGet4(chunk7, until));
        until = until + 1;
        break;
      }
    }
    while (until < chunk7.length) {
      const input = unsafeGet4(chunk7, until);
      const updatedKey = f(input);
      if (!equals(key, updatedKey)) {
        builder.push([key, unsafeFromArray(Array.from(chunk7).slice(from, until))]);
        key = updatedKey;
        from = until;
      }
      until = until + 1;
    }
    const nonEmptyChunk = appendAll2(previousChunk, unsafeFromArray(Array.from(chunk7).slice(from, until)));
    const output = unsafeFromArray(builder);
    return [some2([key, nonEmptyChunk]), output];
  };
  const groupAdjacent = (state) => readWithCause({
    onInput: (input) => {
      const [updatedState, output] = groupAdjacentByChunk(state, input);
      return isEmpty(output) ? groupAdjacent(updatedState) : flatMap17(write(output), () => groupAdjacent(updatedState));
    },
    onFailure: (cause3) => match2(state, {
      onNone: () => failCause11(cause3),
      onSome: (output) => flatMap17(write(of2(output)), () => failCause11(cause3))
    }),
    onDone: (done17) => match2(state, {
      onNone: () => succeedNow(done17),
      onSome: (output) => flatMap17(write(of2(output)), () => succeedNow(done17))
    })
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self), groupAdjacent(none2())));
});
var grouped = dual(2, (self, chunkSize) => pipe(self, rechunk(chunkSize), chunks));
var groupedWithin = dual(3, (self, chunkSize, duration5) => aggregateWithin(self, collectAllN(chunkSize), spaced2(duration5)));
var haltWhen = dual(2, (self, effect4) => {
  const writer = (fiber) => pipe(poll4(fiber), map22(match2({
    onNone: () => readWith({
      onInput: (input) => flatMap17(write(input), () => writer(fiber)),
      onFailure: fail13,
      onDone: () => void_5
    }),
    onSome: match7({
      onFailure: failCause11,
      onSuccess: () => void_5
    })
  })), unwrap2);
  return new StreamImpl(pipe(forkScoped2(effect4), map22((fiber) => pipe(toChannel2(self), pipeTo(writer(fiber)))), unwrapScoped3));
});
var haltAfter = dual(2, (self, duration5) => pipe(self, haltWhen(sleep2(duration5))));
var haltWhenDeferred = dual(2, (self, deferred) => {
  const writer = pipe(poll(deferred), map22(match2({
    onNone: () => readWith({
      onInput: (input) => pipe(write(input), flatMap17(() => writer)),
      onFailure: fail13,
      onDone: () => void_5
    }),
    onSome: (effect4) => unwrap2(match17(effect4, {
      onFailure: fail13,
      onSuccess: () => void_5
    }))
  })), unwrap2);
  return new StreamImpl(pipe(toChannel2(self), pipeTo(writer)));
});
var identityStream = () => new StreamImpl(identityChannel());
var interleave = dual(2, (self, that) => pipe(self, interleaveWith(that, forever5(make64(true, false)))));
var interleaveWith = dual(3, (self, that, decider) => {
  const producer = (handoff) => readWithCause({
    onInput: (value8) => flatMap17(fromEffect5(offer4(handoff, of6(value8))), () => producer(handoff)),
    onFailure: (cause3) => fromEffect5(offer4(handoff, failCause13(cause3))),
    onDone: () => fromEffect5(offer4(handoff, end4))
  });
  return new StreamImpl(unwrapScoped3(pipe(make62(), zip10(make62()), tap3(([left2]) => pipe(toChannel2(self), concatMap(writeChunk), pipeTo(producer(left2)), runScoped, forkScoped2)), tap3(([_, right2]) => pipe(toChannel2(that), concatMap(writeChunk), pipeTo(producer(right2)), runScoped, forkScoped2)), map22(([left2, right2]) => {
    const process2 = (leftDone, rightDone) => readWithCause({
      onInput: (bool) => {
        if (bool && !leftDone) {
          return pipe(fromEffect5(take6(left2)), flatMap17(match28({
            onEnd: () => rightDone ? void_5 : process2(true, rightDone),
            onFailure: failCause11,
            onSuccess: (chunk7) => pipe(write(chunk7), flatMap17(() => process2(leftDone, rightDone)))
          })));
        }
        if (!bool && !rightDone) {
          return pipe(fromEffect5(take6(right2)), flatMap17(match28({
            onEnd: () => leftDone ? void_5 : process2(leftDone, true),
            onFailure: failCause11,
            onSuccess: (chunk7) => pipe(write(chunk7), flatMap17(() => process2(leftDone, rightDone)))
          })));
        }
        return process2(leftDone, rightDone);
      },
      onFailure: failCause11,
      onDone: () => void_5
    });
    return pipe(toChannel2(decider), concatMap(writeChunk), pipeTo(process2(false, false)));
  }))));
});
var intersperse = dual(2, (self, element) => new StreamImpl(pipe(toChannel2(self), pipeToOrFail(suspend5(() => {
  const writer = (isFirst) => readWithCause({
    onInput: (chunk7) => {
      const builder = [];
      let flagResult = isFirst;
      for (const output of chunk7) {
        if (flagResult) {
          flagResult = false;
          builder.push(output);
        } else {
          builder.push(element);
          builder.push(output);
        }
      }
      return pipe(write(unsafeFromArray(builder)), flatMap17(() => writer(flagResult)));
    },
    onFailure: failCause11,
    onDone: () => void_5
  });
  return writer(true);
})))));
var intersperseAffixes = dual(2, (self, {
  end: end7,
  middle,
  start: start5
}) => pipe(make64(start5), concat2(pipe(self, intersperse(middle))), concat2(make64(end7))));
var interruptAfter = dual(2, (self, duration5) => pipe(self, interruptWhen2(sleep2(duration5))));
var interruptWhen2 = dual(2, (self, effect4) => new StreamImpl(pipe(toChannel2(self), interruptWhen(effect4))));
var interruptWhenDeferred2 = dual(2, (self, deferred) => new StreamImpl(pipe(toChannel2(self), interruptWhenDeferred(deferred))));
var iterate3 = (value8, next6) => unfold4(value8, (a) => some2([a, next6(a)]));
var make64 = (...as16) => fromIterable16(as16);
var map28 = dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapOut(map4(f)))));
var mapAccum5 = dual(3, (self, s, f) => {
  const accumulator = (s2) => readWith({
    onInput: (input) => {
      const [nextS, chunk7] = mapAccum2(input, s2, f);
      return flatMap17(write(chunk7), () => accumulator(nextS));
    },
    onFailure: fail13,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(accumulator(s))));
});
var mapAccumEffect = dual(3, (self, s, f) => suspend7(() => {
  const accumulator = (s2) => readWith({
    onInput: (input) => pipe(suspend3(() => {
      const outputs = [];
      const emit2 = (output) => sync7(() => {
        outputs.push(output);
      });
      return pipe(input, reduce15(s2, (s3, a) => pipe(f(s3, a), flatMap15(([s4, a2]) => pipe(emit2(a2), as6(s4))))), match17({
        onFailure: (error4) => {
          if (outputs.length !== 0) {
            return zipRight7(write(unsafeFromArray(outputs)), fail13(error4));
          }
          return fail13(error4);
        },
        onSuccess: (s3) => flatMap17(write(unsafeFromArray(outputs)), () => accumulator(s3))
      }));
    }), unwrap2),
    onFailure: fail13,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(accumulator(s))));
}));
var mapBoth6 = dual(2, (self, options) => pipe(self, mapError8(options.onFailure), map28(options.onSuccess)));
var mapChunks = dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapOut(f))));
var mapChunksEffect = dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapOutEffect(f))));
var mapConcat = dual(2, (self, f) => pipe(self, mapConcatChunk((a) => fromIterable2(f(a)))));
var mapConcatChunk = dual(2, (self, f) => pipe(self, mapChunks(flatMap3(f))));
var mapConcatChunkEffect = dual(2, (self, f) => pipe(self, mapEffectSequential(f), mapConcatChunk(identity)));
var mapConcatEffect = dual(2, (self, f) => pipe(self, mapEffectSequential((a) => pipe(f(a), map22(fromIterable2))), mapConcatChunk(identity)));
var mapEffectSequential = dual(2, (self, f) => {
  const loop5 = (iterator) => {
    const next6 = iterator.next();
    if (next6.done) {
      return readWithCause({
        onInput: (elem) => loop5(elem[Symbol.iterator]()),
        onFailure: failCause11,
        onDone: succeed14
      });
    } else {
      const value8 = next6.value;
      return unwrap2(map22(f(value8), (a2) => flatMap17(write(of2(a2)), () => loop5(iterator))));
    }
  };
  return new StreamImpl(pipe(toChannel2(self), pipeTo(suspend5(() => loop5(empty5()[Symbol.iterator]())))));
});
var mapEffectPar = dual(3, (self, n, f) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mapOutEffectPar(f, n), mapOut(of2))));
var mapError8 = dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapError6(f))));
var mapErrorCause5 = dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapErrorCause4(f))));
var merge9 = dual((args) => isStream(args[1]), (self, that, options) => mergeWith2(self, that, {
  onSelf: identity,
  onOther: identity,
  haltStrategy: options == null ? void 0 : options.haltStrategy
}));
var mergeAll6 = dual((args) => Symbol.iterator in args[0], (streams, options) => flatten12(fromIterable16(streams), options));
var mergeEither = dual(2, (self, that) => mergeWith2(self, that, {
  onSelf: left,
  onOther: right
}));
var mergeLeft = dual(2, (self, that) => pipe(self, merge9(drain3(that))));
var mergeRight = dual(2, (self, that) => pipe(drain3(self), merge9(that)));
var mergeWith2 = dual(3, (self, other, options) => {
  const strategy = options.haltStrategy ? fromInput2(options.haltStrategy) : Both2;
  const handler = (terminate) => (exit3) => terminate || !isSuccess(exit3) ? (
    // TODO: remove
    Done4(suspend3(() => exit3))
  ) : Await2((exit4) => suspend3(() => exit4));
  return new StreamImpl(mergeWith(toChannel2(map28(self, options.onSelf)), {
    other: toChannel2(map28(other, options.onOther)),
    onSelfDone: handler(strategy._tag === "Either" || strategy._tag === "Left"),
    onOtherDone: handler(strategy._tag === "Either" || strategy._tag === "Right")
  }));
});
var mkString2 = (self) => run5(self, mkString);
var never7 = fromEffect9(never4);
var onError3 = dual(2, (self, cleanup) => pipe(self, catchAllCause6((cause3) => fromEffect9(pipe(cleanup(cause3), zipRight6(failCause9(cause3)))))));
var onDone = dual(2, (self, cleanup) => new StreamImpl(pipe(toChannel2(self), ensuringWith((exit3) => isSuccess(exit3) ? cleanup() : _void))));
var orDie6 = (self) => pipe(self, orDieWith4(identity));
var orDieWith4 = dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), orDieWith3(f))));
var orElse11 = dual(2, (self, that) => new StreamImpl(pipe(toChannel2(self), orElse9(() => toChannel2(that())))));
var orElseEither5 = dual(2, (self, that) => pipe(self, map28(left), orElse11(() => pipe(that(), map28(right)))));
var orElseFail3 = dual(2, (self, error4) => pipe(self, orElse11(() => failSync8(error4))));
var orElseIfEmpty = dual(2, (self, element) => pipe(self, orElseIfEmptyChunk(() => of2(element()))));
var orElseIfEmptyChunk = dual(2, (self, chunk7) => pipe(self, orElseIfEmptyStream(() => new StreamImpl(write(chunk7())))));
var orElseIfEmptyStream = dual(2, (self, stream) => {
  const writer = readWith({
    onInput: (input) => {
      if (isEmpty(input)) {
        return suspend5(() => writer);
      }
      return pipe(write(input), zipRight7(identityChannel()));
    },
    onFailure: fail13,
    onDone: () => suspend5(() => toChannel2(stream()))
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(writer)));
});
var orElseSucceed3 = dual(2, (self, value8) => pipe(self, orElse11(() => sync12(value8))));
var paginate = (s, f) => paginateChunk(s, (s2) => {
  const page = f(s2);
  return [of2(page[0]), page[1]];
});
var paginateChunk = (s, f) => {
  const loop5 = (s2) => {
    const page = f(s2);
    return match2(page[1], {
      onNone: () => zipRight7(write(page[0]), void_5),
      onSome: (s3) => flatMap17(write(page[0]), () => loop5(s3))
    });
  };
  return new StreamImpl(suspend5(() => loop5(s)));
};
var paginateChunkEffect = (s, f) => {
  const loop5 = (s2) => unwrap2(map22(f(s2), ([chunk7, option9]) => match2(option9, {
    onNone: () => zipRight7(write(chunk7), void_5),
    onSome: (s3) => flatMap17(write(chunk7), () => loop5(s3))
  })));
  return new StreamImpl(suspend5(() => loop5(s)));
};
var paginateEffect = (s, f) => paginateChunkEffect(s, (s2) => pipe(f(s2), map22(([a, s3]) => [of2(a), s3])));
var peel = dual(2, (self, sink) => {
  const OP_EMIT5 = "Emit";
  const OP_HALT2 = "Halt";
  const OP_END2 = "End";
  return pipe(make23(), flatMap15((deferred) => pipe(make62(), map22((handoff) => {
    const consumer = foldSink(collectLeftover(sink), {
      onFailure: (error4) => zipRight8(fromEffect7(fail3(deferred, error4)), fail14(error4)),
      onSuccess: ([z, leftovers]) => {
        const loop5 = readWithCause({
          onInput: (elements) => flatMap17(fromEffect5(offer4(handoff, {
            _tag: OP_EMIT5,
            elements
          })), () => loop5),
          onFailure: (cause3) => zipRight7(fromEffect5(offer4(handoff, {
            _tag: OP_HALT2,
            cause: cause3
          })), failCause11(cause3)),
          onDone: (_) => zipRight7(fromEffect5(offer4(handoff, {
            _tag: OP_END2
          })), void_5)
        });
        return fromChannel(pipe(fromEffect5(succeed2(deferred, z)), zipRight7(fromEffect5(pipe(handoff, offer4({
          _tag: OP_EMIT5,
          elements: leftovers
        })))), zipRight7(loop5)));
      }
    });
    const producer = pipe(take6(handoff), map22((signal) => {
      switch (signal._tag) {
        case OP_EMIT5: {
          return pipe(write(signal.elements), flatMap17(() => producer));
        }
        case OP_HALT2: {
          return failCause11(signal.cause);
        }
        case OP_END2: {
          return void_5;
        }
      }
    }), unwrap2);
    return pipe(self, tapErrorCause5((cause3) => failCause2(deferred, cause3)), run5(consumer), forkScoped2, zipRight6(_await(deferred)), map22((z) => [z, new StreamImpl(producer)]));
  }))), flatten9);
});
var partition9 = dual((args) => typeof args[1] === "function", (self, predicate, options) => partitionEither(self, (a) => succeed12(predicate(a) ? left(a) : right(a)), options));
var partitionEither = dual((args) => typeof args[1] === "function", (self, predicate, options) => pipe(mapEffectSequential(self, predicate), distributedWith({
  size: 2,
  maximumLag: (options == null ? void 0 : options.bufferSize) ?? 16,
  decide: match({
    onLeft: () => succeed12((n) => n === 0),
    onRight: () => succeed12((n) => n === 1)
  })
}), flatMap15(([queue1, queue2]) => succeed12([filterMap8(flattenExitOption(fromQueue3(queue1, {
  shutdown: true
})), (_) => match(_, {
  onLeft: some2,
  onRight: none2
})), filterMap8(flattenExitOption(fromQueue3(queue2, {
  shutdown: true
})), (_) => match(_, {
  onLeft: none2,
  onRight: some2
}))]))));
var pipeThrough = dual(2, (self, sink) => new StreamImpl(pipe(toChannel2(self), pipeToOrFail(toChannel(sink)))));
var pipeThroughChannel = dual(2, (self, channel) => new StreamImpl(pipeTo(toChannel2(self), channel)));
var pipeThroughChannelOrFail = dual(2, (self, chan) => new StreamImpl(pipe(toChannel2(self), pipeToOrFail(chan))));
var prepend5 = dual(2, (self, values13) => new StreamImpl(zipRight7(write(values13), toChannel2(self))));
var provideContext6 = dual(2, (self, context13) => new StreamImpl(pipe(toChannel2(self), provideContext3(context13))));
var provideLayer2 = dual(2, (self, layer) => new StreamImpl(unwrapScoped3(pipe(build2(layer), map22((env) => pipe(toChannel2(self), provideContext3(env)))))));
var provideService8 = dual(3, (self, tag4, resource) => provideServiceEffect3(self, tag4, succeed12(resource)));
var provideServiceEffect3 = dual(3, (self, tag4, effect4) => provideServiceStream(self, tag4, fromEffect9(effect4)));
var provideServiceStream = dual(3, (self, tag4, stream) => contextWithStream((env) => flatMap19(stream, (service3) => pipe(self, provideContext6(add2(env, tag4, service3))))));
var mapInputContext6 = dual(2, (self, f) => contextWithStream((env) => pipe(self, provideContext6(f(env)))));
var provideSomeLayer3 = dual(2, (self, layer) => (
  // @ts-expect-error
  pipe(self, provideLayer2(pipe(context4(), merge8(layer))))
));
var range2 = (min7, max9, chunkSize = DefaultChunkSize) => suspend7(() => {
  if (min7 > max9) {
    return empty40;
  }
  const go = (min8, max10, chunkSize2) => {
    const remaining = max10 - min8 + 1;
    if (remaining > chunkSize2) {
      return pipe(write(range(min8, min8 + chunkSize2 - 1)), flatMap17(() => go(min8 + chunkSize2, max10, chunkSize2)));
    }
    return write(range(min8, min8 + remaining - 1));
  };
  return new StreamImpl(go(min7, max9, chunkSize));
});
var rechunk = dual(2, (self, n) => suspend7(() => {
  const target = Math.max(n, 1);
  const process2 = rechunkProcess(new StreamRechunker(target), target);
  return new StreamImpl(pipe(toChannel2(self), pipeTo(process2)));
}));
var rechunkProcess = (rechunker, target) => readWithCause({
  onInput: (chunk7) => {
    if (chunk7.length === target && rechunker.isEmpty()) {
      return flatMap17(write(chunk7), () => rechunkProcess(rechunker, target));
    }
    if (chunk7.length > 0) {
      const chunks3 = [];
      let result = void 0;
      let index = 0;
      while (index < chunk7.length) {
        while (index < chunk7.length && result === void 0) {
          result = rechunker.write(pipe(chunk7, unsafeGet4(index)));
          index = index + 1;
        }
        if (result !== void 0) {
          chunks3.push(result);
          result = void 0;
        }
      }
      return flatMap17(writeAll(...chunks3), () => rechunkProcess(rechunker, target));
    }
    return suspend5(() => rechunkProcess(rechunker, target));
  },
  onFailure: (cause3) => zipRight7(rechunker.emitIfNotEmpty(), failCause11(cause3)),
  onDone: () => rechunker.emitIfNotEmpty()
});
var StreamRechunker = class {
  constructor(n) {
    __publicField(this, "n");
    __publicField(this, "builder", []);
    __publicField(this, "pos", 0);
    this.n = n;
  }
  isEmpty() {
    return this.pos === 0;
  }
  write(elem) {
    this.builder.push(elem);
    this.pos += 1;
    if (this.pos === this.n) {
      const result = unsafeFromArray(this.builder);
      this.builder = [];
      this.pos = 0;
      return result;
    }
    return void 0;
  }
  emitIfNotEmpty() {
    if (this.pos !== 0) {
      return write(unsafeFromArray(this.builder));
    }
    return void_5;
  }
};
var refineOrDie2 = dual(2, (self, pf) => pipe(self, refineOrDieWith2(pf, identity)));
var refineOrDieWith2 = dual(3, (self, pf, f) => new StreamImpl(catchAll5(toChannel2(self), (error4) => match2(pf(error4), {
  onNone: () => failCause11(die5(f(error4))),
  onSome: fail13
}))));
var repeat2 = dual(2, (self, schedule4) => filterMap8(repeatEither(self, schedule4), (_) => match(_, {
  onLeft: none2,
  onRight: some2
})));
var repeatEffect = (effect4) => repeatEffectOption(pipe(effect4, mapError4(some2)));
var repeatEffectChunk = (effect4) => repeatEffectChunkOption(pipe(effect4, mapError4(some2)));
var repeatEffectChunkOption = (effect4) => unfoldChunkEffect(effect4, (effect5) => pipe(map22(effect5, (chunk7) => some2([chunk7, effect5])), catchAll3(match2({
  onNone: () => succeed12(none2()),
  onSome: fail11
}))));
var repeatEffectOption = (effect4) => repeatEffectChunkOption(pipe(effect4, map22(of2)));
var repeatEither = dual(2, (self, schedule4) => repeatWith(self, schedule4, {
  onElement: (a) => right(a),
  onSchedule: left
}));
var repeatElements = dual(2, (self, schedule4) => filterMap8(repeatElementsWith(self, schedule4, {
  onElement: (a) => some2(a),
  onSchedule: none2
}), identity));
var repeatElementsWith = dual(3, (self, schedule4, options) => {
  const driver3 = pipe(driver2(schedule4), map22((driver4) => {
    const feed = (input) => match2(head2(input), {
      onNone: () => loop5,
      onSome: (a) => zipRight7(write(of2(options.onElement(a))), step4(pipe(input, drop2(1)), a))
    });
    const step4 = (input, a) => {
      const advance = pipe(driver4.next(a), as6(pipe(write(of2(options.onElement(a))), flatMap17(() => step4(input, a)))));
      const reset3 = pipe(driver4.last, orDie3, flatMap15((b) => pipe(driver4.reset, map22(() => pipe(write(of2(options.onSchedule(b))), zipRight7(feed(input)))))));
      return pipe(advance, orElse7(() => reset3), unwrap2);
    };
    const loop5 = readWith({
      onInput: feed,
      onFailure: fail13,
      onDone: () => void_5
    });
    return loop5;
  }), unwrap2);
  return new StreamImpl(pipe(toChannel2(self), pipeTo(driver3)));
});
var repeatValue = (value8) => new StreamImpl(repeated(write(of2(value8))));
var repeatWith = dual(3, (self, schedule4, options) => {
  return pipe(driver2(schedule4), map22((driver3) => {
    const scheduleOutput = pipe(driver3.last, orDie3, map22(options.onSchedule));
    const process2 = pipe(self, map28(options.onElement), toChannel2);
    const loop5 = unwrap2(match17(driver3.next(void 0), {
      onFailure: () => void_5,
      onSuccess: () => pipe(process2, zipRight7(pipe(scheduleOutput, map22((c) => pipe(write(of2(c)), flatMap17(() => loop5))), unwrap2)))
    }));
    return new StreamImpl(pipe(process2, zipRight7(loop5)));
  }), unwrap4);
});
var repeatWithSchedule = (value8, schedule4) => repeatEffectWithSchedule(succeed12(value8), schedule4);
var repeatEffectWithSchedule = (effect4, schedule4) => flatMap19(fromEffect9(zip10(effect4, driver2(schedule4))), ([a, driver3]) => concat2(succeed17(a), unfoldEffect(a, (s) => matchEffect3(driver3.next(s), {
  onFailure: succeed12,
  onSuccess: () => map22(effect4, (nextA) => some2([nextA, nextA]))
}))));
var retry4 = dual(2, (self, schedule4) => unwrap4(map22(driver2(schedule4), (driver3) => {
  const loop5 = catchAll6(self, (error4) => unwrap4(matchEffect3(driver3.next(error4), {
    onFailure: () => fail11(error4),
    onSuccess: () => succeed12(pipe(loop5, tap6(() => driver3.reset)))
  })));
  return loop5;
})));
var run5 = dual(2, (self, sink) => pipe(toChannel2(self), pipeToOrFail(toChannel(sink)), runDrain));
var runCollect2 = (self) => pipe(self, run5(collectAll()));
var runCount = (self) => pipe(self, run5(count3));
var runDrain2 = (self) => pipe(self, run5(drain2));
var runFold = dual(3, (self, s, f) => pipe(self, runFoldWhileScoped(s, constTrue, f), scoped3));
var runFoldEffect = dual(3, (self, s, f) => pipe(self, runFoldWhileScopedEffect(s, constTrue, f), scoped3));
var runFoldScoped = dual(3, (self, s, f) => pipe(self, runFoldWhileScoped(s, constTrue, f)));
var runFoldScopedEffect = dual(3, (self, s, f) => pipe(self, runFoldWhileScopedEffect(s, constTrue, f)));
var runFoldWhile = dual(4, (self, s, cont, f) => pipe(self, runFoldWhileScoped(s, cont, f), scoped3));
var runFoldWhileEffect = dual(4, (self, s, cont, f) => pipe(self, runFoldWhileScopedEffect(s, cont, f), scoped3));
var runFoldWhileScoped = dual(4, (self, s, cont, f) => pipe(self, runScoped2(fold(s, cont, f))));
var runFoldWhileScopedEffect = dual(4, (self, s, cont, f) => pipe(self, runScoped2(foldEffect(s, cont, f))));
var runForEach = dual(2, (self, f) => pipe(self, run5(forEach13(f))));
var runForEachChunk = dual(2, (self, f) => pipe(self, run5(forEachChunk(f))));
var runForEachChunkScoped = dual(2, (self, f) => pipe(self, runScoped2(forEachChunk(f))));
var runForEachScoped = dual(2, (self, f) => pipe(self, runScoped2(forEach13(f))));
var runForEachWhile = dual(2, (self, f) => pipe(self, run5(forEachWhile(f))));
var runForEachWhileScoped = dual(2, (self, f) => pipe(self, runScoped2(forEachWhile(f))));
var runHead = (self) => pipe(self, run5(head7()));
var runIntoPubSub = dual(2, (self, pubsub) => pipe(self, runIntoQueue(pubsub)));
var runIntoPubSubScoped = dual(2, (self, pubsub) => pipe(self, runIntoQueueScoped(pubsub)));
var runIntoQueue = dual(2, (self, queue) => pipe(self, runIntoQueueScoped(queue), scoped3));
var runIntoQueueElementsScoped = dual(2, (self, queue) => {
  const writer = readWithCause({
    onInput: (input) => flatMap17(fromEffect5(offerAll3(queue, map4(input, succeed3))), () => writer),
    onFailure: (cause3) => fromEffect5(offer3(queue, failCause3(map18(cause3, some2)))),
    onDone: () => fromEffect5(offer3(queue, fail4(none2())))
  });
  return pipe(pipeTo(toChannel2(self), writer), drain, runScoped, asVoid4);
});
var runIntoQueueScoped = dual(2, (self, queue) => {
  const writer = readWithCause({
    onInput: (input) => flatMap17(write(chunk3(input)), () => writer),
    onFailure: (cause3) => write(failCause13(cause3)),
    onDone: () => write(end4)
  });
  return pipe(pipeTo(toChannel2(self), writer), mapOutEffect((take14) => offer3(queue, take14)), drain, runScoped, asVoid4);
});
var runLast = (self) => pipe(self, run5(last6()));
var runScoped2 = dual(2, (self, sink) => pipe(toChannel2(self), pipeToOrFail(toChannel(sink)), drain, runScoped));
var runSum = (self) => pipe(self, run5(sum4));
var scan = dual(3, (self, s, f) => pipe(self, scanEffect(s, (s2, a) => succeed12(f(s2, a)))));
var scanReduce = dual(2, (self, f) => pipe(self, scanReduceEffect((a2, a) => succeed12(f(a2, a)))));
var scanReduceEffect = dual(2, (self, f) => pipe(self, mapAccumEffect(none2(), (option9, a) => {
  switch (option9._tag) {
    case "None": {
      return succeed12([some2(a), a]);
    }
    case "Some": {
      return pipe(f(option9.value, a), map22((b) => [some2(b), b]));
    }
  }
})));
var schedule2 = dual(2, (self, schedule4) => filterMap8(scheduleWith(self, schedule4, {
  onElement: some2,
  onSchedule: none2
}), identity));
var scheduleWith = dual(3, (self, schedule4, options) => {
  const loop5 = (driver3, iterator) => {
    const next6 = iterator.next();
    if (next6.done) {
      return readWithCause({
        onInput: (chunk7) => loop5(driver3, chunk7[Symbol.iterator]()),
        onFailure: failCause11,
        onDone: succeedNow
      });
    }
    return unwrap2(matchEffect3(driver3.next(next6.value), {
      onFailure: () => pipe(driver3.last, orDie3, map22((b) => pipe(write(make8(options.onElement(next6.value), options.onSchedule(b))), flatMap17(() => loop5(driver3, iterator)))), zipLeft6(driver3.reset)),
      onSuccess: () => succeed12(pipe(write(of2(options.onElement(next6.value))), flatMap17(() => loop5(driver3, iterator))))
    }));
  };
  return new StreamImpl(pipe(fromEffect5(driver2(schedule4)), flatMap17((driver3) => pipe(toChannel2(self), pipeTo(loop5(driver3, empty5()[Symbol.iterator]()))))));
});
var scanEffect = dual(3, (self, s, f) => new StreamImpl(pipe(write(of2(s)), flatMap17(() => toChannel2(pipe(self, mapAccumEffect(s, (s2, a) => pipe(f(s2, a), map22((s3) => [s3, s3])))))))));
var scoped6 = (effect4) => new StreamImpl(ensuring4(scoped5(pipe(effect4, map22(of2))), _void));
var some10 = (self) => pipe(self, mapError8(some2), someOrFail(() => none2()));
var someOrElse = dual(2, (self, fallback) => pipe(self, map28(getOrElse(fallback))));
var someOrFail = dual(2, (self, error4) => mapEffectSequential(self, match2({
  onNone: () => failSync4(error4),
  onSome: succeed12
})));
var sliding5 = dual(2, (self, chunkSize) => slidingSize(self, chunkSize, 1));
var slidingSize = dual(3, (self, chunkSize, stepSize) => {
  if (chunkSize <= 0 || stepSize <= 0) {
    return die11(new IllegalArgumentException2("Invalid bounds - `chunkSize` and `stepSize` must be greater than zero"));
  }
  return new StreamImpl(suspend5(() => {
    const queue = new RingBuffer(chunkSize);
    const emitOnStreamEnd = (queueSize, channelEnd) => {
      if (queueSize < chunkSize) {
        const items = queue.toChunk();
        const result2 = isEmpty(items) ? empty5() : of2(items);
        return pipe(write(result2), flatMap17(() => channelEnd));
      }
      const lastEmitIndex = queueSize - (queueSize - chunkSize) % stepSize;
      if (lastEmitIndex === queueSize) {
        return channelEnd;
      }
      const leftovers = queueSize - (lastEmitIndex - chunkSize + stepSize);
      const lastItems = pipe(queue.toChunk(), takeRight(leftovers));
      const result = isEmpty(lastItems) ? empty5() : of2(lastItems);
      return pipe(write(result), flatMap17(() => channelEnd));
    };
    const reader = (queueSize) => readWithCause({
      onInput: (input) => flatMap17(write(filterMap2(input, (element, index) => {
        queue.put(element);
        const currentIndex = queueSize + index + 1;
        if (currentIndex < chunkSize || (currentIndex - chunkSize) % stepSize > 0) {
          return none2();
        }
        return some2(queue.toChunk());
      })), () => reader(queueSize + input.length)),
      onFailure: (cause3) => emitOnStreamEnd(queueSize, failCause11(cause3)),
      onDone: () => emitOnStreamEnd(queueSize, void_5)
    });
    return pipe(toChannel2(self), pipeTo(reader(0)));
  }));
});
var split2 = dual(2, (self, predicate) => {
  const split4 = (leftovers, input) => {
    const [chunk7, remaining] = pipe(leftovers, appendAll2(input), splitWhere(predicate));
    if (isEmpty(chunk7) || isEmpty(remaining)) {
      return loop5(pipe(chunk7, appendAll2(pipe(remaining, drop2(1)))));
    }
    return pipe(write(of2(chunk7)), flatMap17(() => split4(empty5(), pipe(remaining, drop2(1)))));
  };
  const loop5 = (leftovers) => readWith({
    onInput: (input) => split4(leftovers, input),
    onFailure: fail13,
    onDone: () => {
      if (isEmpty(leftovers)) {
        return void_5;
      }
      if (isNone(pipe(leftovers, findFirst2(predicate)))) {
        return zipRight7(write(of2(leftovers)), void_5);
      }
      return zipRight7(split4(empty5(), leftovers), void_5);
    }
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop5(empty5()))));
});
var splitOnChunk = dual(2, (self, delimiter) => {
  const next6 = (leftover3, delimiterIndex) => readWithCause({
    onInput: (inputChunk) => {
      let buffer5;
      const [carry, delimiterCursor] = pipe(inputChunk, reduce2([pipe(leftover3, getOrElse(() => empty5())), delimiterIndex], ([carry2, delimiterCursor2], a) => {
        const concatenated = pipe(carry2, append2(a));
        if (delimiterCursor2 < delimiter.length && equals(a, pipe(delimiter, unsafeGet4(delimiterCursor2)))) {
          if (delimiterCursor2 + 1 === delimiter.length) {
            if (buffer5 === void 0) {
              buffer5 = [];
            }
            buffer5.push(pipe(concatenated, take(concatenated.length - delimiter.length)));
            return [empty5(), 0];
          }
          return [concatenated, delimiterCursor2 + 1];
        }
        return [concatenated, equals(a, pipe(delimiter, unsafeGet4(0))) ? 1 : 0];
      }));
      const output = buffer5 === void 0 ? empty5() : unsafeFromArray(buffer5);
      return flatMap17(write(output), () => next6(isNonEmpty2(carry) ? some2(carry) : none2(), delimiterCursor));
    },
    onFailure: (cause3) => match2(leftover3, {
      onNone: () => failCause11(cause3),
      onSome: (chunk7) => zipRight7(write(of2(chunk7)), failCause11(cause3))
    }),
    onDone: (done17) => match2(leftover3, {
      onNone: () => succeed14(done17),
      onSome: (chunk7) => zipRight7(write(of2(chunk7)), succeed14(done17))
    })
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(next6(none2(), 0))));
});
var splitLines2 = (self) => pipeThroughChannel(self, splitLines());
var succeed17 = (value8) => fromChunk(of2(value8));
var sync12 = (evaluate3) => suspend7(() => fromChunk(of2(evaluate3())));
var suspend7 = (stream) => new StreamImpl(suspend5(() => toChannel2(stream())));
var take7 = dual(2, (self, n) => {
  if (!Number.isInteger(n)) {
    return die11(new IllegalArgumentException2(`${n} must be an integer`));
  }
  const loop5 = (n2) => readWith({
    onInput: (input) => {
      const taken = pipe(input, take(Math.min(n2, Number.POSITIVE_INFINITY)));
      const leftover3 = Math.max(0, n2 - taken.length);
      const more = leftover3 > 0;
      if (more) {
        return pipe(write(taken), flatMap17(() => loop5(leftover3)));
      }
      return write(taken);
    },
    onFailure: fail13,
    onDone: succeed14
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(0 < n ? loop5(n) : void_5)));
});
var takeRight2 = dual(2, (self, n) => {
  if (n <= 0) {
    return empty40;
  }
  return new StreamImpl(pipe(succeed12(new RingBuffer(n)), map22((queue) => {
    const reader = readWith({
      onInput: (input) => {
        for (const element of input) {
          queue.put(element);
        }
        return reader;
      },
      onFailure: fail13,
      onDone: () => pipe(write(queue.toChunk()), zipRight7(void_5))
    });
    return pipe(toChannel2(self), pipeTo(reader));
  }), unwrap2));
});
var takeUntil3 = dual(2, (self, predicate) => {
  const loop5 = readWith({
    onInput: (input) => {
      const taken = pipe(input, takeWhile((a) => !predicate(a)));
      const last8 = pipe(input, drop2(taken.length), take(1));
      if (isEmpty(last8)) {
        return pipe(write(taken), flatMap17(() => loop5));
      }
      return write(pipe(taken, appendAll2(last8)));
    },
    onFailure: fail13,
    onDone: succeed14
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop5)));
});
var takeUntilEffect = dual(2, (self, predicate) => {
  const loop5 = (iterator) => {
    const next6 = iterator.next();
    if (next6.done) {
      return readWithCause({
        onInput: (elem) => loop5(elem[Symbol.iterator]()),
        onFailure: failCause11,
        onDone: succeed14
      });
    }
    return pipe(predicate(next6.value), map22((bool) => bool ? write(of2(next6.value)) : pipe(write(of2(next6.value)), flatMap17(() => loop5(iterator)))), unwrap2);
  };
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop5(empty5()[Symbol.iterator]()))));
});
var takeWhile4 = dual(2, (self, predicate) => {
  const loop5 = readWith({
    onInput: (input) => {
      const taken = pipe(input, takeWhile(predicate));
      const more = taken.length === input.length;
      if (more) {
        return pipe(write(taken), flatMap17(() => loop5));
      }
      return write(taken);
    },
    onFailure: fail13,
    onDone: succeed14
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop5)));
});
var tap6 = dual(2, (self, f) => mapEffectSequential(self, (a) => as6(f(a), a)));
var tapBoth3 = dual(2, (self, options) => pipe(self, tapError5(options.onFailure), tap6(options.onSuccess)));
var tapError5 = dual(2, (self, f) => catchAll6(self, (error4) => fromEffect9(zipRight6(f(error4), fail11(error4)))));
var tapErrorCause5 = dual(2, (self, f) => {
  const loop5 = readWithCause({
    onInput: (chunk7) => flatMap17(write(chunk7), () => loop5),
    onFailure: (cause3) => fromEffect5(zipRight6(f(cause3), failCause9(cause3))),
    onDone: succeedNow
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop5)));
});
var tapSink = dual(2, (self, sink) => pipe(fromEffect9(all7([bounded5(1), make23()])), flatMap19(([queue, deferred]) => {
  const right2 = flattenTake(fromQueue3(queue, {
    maxChunkSize: 1
  }));
  const loop5 = readWithCause({
    onInput: (chunk7) => pipe(fromEffect5(offer3(queue, chunk3(chunk7))), foldCauseChannel({
      onFailure: () => flatMap17(write(chunk7), () => identityChannel()),
      onSuccess: () => flatMap17(write(chunk7), () => loop5)
    })),
    onFailure: (cause3) => pipe(fromEffect5(offer3(queue, failCause13(cause3))), foldCauseChannel({
      onFailure: () => failCause11(cause3),
      onSuccess: () => failCause11(cause3)
    })),
    onDone: () => pipe(fromEffect5(offer3(queue, end4)), foldCauseChannel({
      onFailure: () => void_5,
      onSuccess: () => void_5
    }))
  });
  return pipe(new StreamImpl(pipe(pipeTo(toChannel2(self), loop5), ensuring4(zipRight6(forkDaemon2(offer3(queue, end4)), _await(deferred))))), merge9(execute(pipe(run5(right2, sink), ensuring3(zipRight6(shutdown4(queue), succeed2(deferred, void 0)))))));
})));
var throttle = dual(2, (self, options) => throttleEffect(self, {
  ...options,
  cost: (chunk7) => succeed12(options.cost(chunk7))
}));
var throttleEffect = dual(2, (self, options) => {
  if (options.strategy === "enforce") {
    return throttleEnforceEffect(self, options.cost, options.units, options.duration, options.burst ?? 0);
  }
  return throttleShapeEffect(self, options.cost, options.units, options.duration, options.burst ?? 0);
});
var throttleEnforceEffect = (self, cost, units, duration5, burst) => {
  const loop5 = (tokens, timestampMillis) => readWithCause({
    onInput: (input) => pipe(cost(input), zip10(currentTimeMillis2), map22(([weight, currentTimeMillis4]) => {
      const elapsed3 = currentTimeMillis4 - timestampMillis;
      const cycles = elapsed3 / toMillis(duration5);
      const sum6 = tokens + cycles * units;
      const max9 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available3 = sum6 < 0 ? max9 : Math.min(sum6, max9);
      if (weight <= available3) {
        return pipe(write(input), flatMap17(() => loop5(available3 - weight, currentTimeMillis4)));
      }
      return loop5(tokens, timestampMillis);
    }), unwrap2),
    onFailure: failCause11,
    onDone: () => void_5
  });
  const throttled = pipe(currentTimeMillis2, map22((currentTimeMillis4) => loop5(units, currentTimeMillis4)), unwrap2);
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(throttled)));
};
var throttleShapeEffect = (self, costFn, units, duration5, burst) => {
  const loop5 = (tokens, timestampMillis) => readWithCause({
    onInput: (input) => pipe(costFn(input), zip10(currentTimeMillis2), map22(([weight, currentTimeMillis4]) => {
      const elapsed3 = currentTimeMillis4 - timestampMillis;
      const cycles = elapsed3 / toMillis(duration5);
      const sum6 = tokens + cycles * units;
      const max9 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available3 = sum6 < 0 ? max9 : Math.min(sum6, max9);
      const remaining = available3 - weight;
      const waitCycles = remaining >= 0 ? 0 : -remaining / units;
      const delay3 = millis(Math.max(0, waitCycles * toMillis(duration5)));
      if (greaterThan4(delay3, zero2)) {
        return pipe(fromEffect5(sleep2(delay3)), zipRight7(write(input)), flatMap17(() => loop5(remaining, currentTimeMillis4)));
      }
      return flatMap17(write(input), () => loop5(remaining, currentTimeMillis4));
    }), unwrap2),
    onFailure: failCause11,
    onDone: () => void_5
  });
  const throttled = pipe(currentTimeMillis2, map22((currentTimeMillis4) => loop5(units, currentTimeMillis4)), unwrap2);
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(throttled)));
};
var tick = (interval) => repeatWithSchedule(void 0, spaced2(interval));
var timeout3 = dual(2, (self, duration5) => pipe(toPull2(self), map22(timeoutFail2({
  onTimeout: () => none2(),
  duration: duration5
})), fromPull2));
var timeoutFail3 = dual(3, (self, error4, duration5) => pipe(self, timeoutTo3(duration5, failSync8(error4))));
var timeoutFailCause3 = dual(3, (self, cause3, duration5) => pipe(toPull2(self), map22(timeoutFailCause2({
  onTimeout: () => map18(cause3(), some2),
  duration: duration5
})), fromPull2));
var timeoutTo3 = dual(3, (self, duration5, that) => {
  const StreamTimeout = new RuntimeException2("Stream Timeout");
  return pipe(self, timeoutFailCause3(() => die5(StreamTimeout), duration5), catchSomeCause3((cause3) => isDieType2(cause3) && isRuntimeException2(cause3.defect) && cause3.defect.message !== void 0 && cause3.defect.message === "Stream Timeout" ? some2(that) : none2()));
});
var toPubSub2 = dual(2, (self, capacity10) => pipe(acquireRelease2(bounded4(capacity10), (pubsub) => shutdown3(pubsub)), tap3((pubsub) => pipe(self, runIntoPubSubScoped(pubsub), forkScoped2))));
var toPull2 = (self) => map22(toPull(toChannel2(self)), (pull) => pipe(pull, mapError4(some2), flatMap15(match({
  onLeft: () => fail11(none2()),
  onRight: succeed12
}))));
var toQueue2 = dual((args) => isStream(args[0]), (self, options) => tap3(acquireRelease2((options == null ? void 0 : options.strategy) === "unbounded" ? unbounded5() : (options == null ? void 0 : options.strategy) === "dropping" ? dropping4(options.capacity ?? 2) : (options == null ? void 0 : options.strategy) === "sliding" ? sliding4(options.capacity ?? 2) : bounded5((options == null ? void 0 : options.capacity) ?? 2), (queue) => shutdown4(queue)), (queue) => forkScoped2(runIntoQueueScoped(self, queue))));
var toQueueOfElements = dual((args) => isStream(args[0]), (self, options) => tap3(acquireRelease2(bounded5((options == null ? void 0 : options.capacity) ?? 2), (queue) => shutdown4(queue)), (queue) => forkScoped2(runIntoQueueElementsScoped(self, queue))));
var toReadableStream = (source) => {
  let pull;
  let scope5;
  return new ReadableStream({
    start(controller) {
      scope5 = runSync(make54());
      pull = pipe(toPull2(source), use(scope5), runSync, tap3((chunk7) => sync7(() => {
        map4(chunk7, (a) => {
          controller.enqueue(a);
        });
      })), tapErrorCause3(() => close(scope5, void_2)), catchTags2({
        "None": () => sync7(() => {
          controller.close();
        }),
        "Some": (error4) => sync7(() => {
          controller.error(error4.value);
        })
      }), asVoid4);
    },
    pull() {
      return runPromise(pull);
    },
    cancel() {
      return runPromise(close(scope5, void_2));
    }
  });
};
var transduce = dual(2, (self, sink) => {
  const newChannel = suspend5(() => {
    const leftovers = {
      ref: empty5()
    };
    const upstreamDone = {
      ref: false
    };
    const buffer5 = suspend5(() => {
      const leftover3 = leftovers.ref;
      if (isEmpty(leftover3)) {
        return readWith({
          onInput: (input) => pipe(write(input), flatMap17(() => buffer5)),
          onFailure: fail13,
          onDone: succeedNow
        });
      }
      leftovers.ref = empty5();
      return pipe(writeChunk(leftover3), flatMap17(() => buffer5));
    });
    const concatAndGet = (chunk7) => {
      const leftover3 = leftovers.ref;
      const concatenated = appendAll2(leftover3, filter2(chunk7, (chunk8) => chunk8.length !== 0));
      leftovers.ref = concatenated;
      return concatenated;
    };
    const upstreamMarker = readWith({
      onInput: (input) => flatMap17(write(input), () => upstreamMarker),
      onFailure: fail13,
      onDone: (done17) => zipRight7(sync9(() => {
        upstreamDone.ref = true;
      }), succeedNow(done17))
    });
    const transducer = pipe(sink, toChannel, collectElements, flatMap17(([leftover3, z]) => pipe(succeed14([upstreamDone.ref, concatAndGet(leftover3)]), flatMap17(([done17, newLeftovers]) => {
      const nextChannel = done17 && isEmpty(newLeftovers) ? void_5 : transducer;
      return pipe(write(of2(z)), flatMap17(() => nextChannel));
    }))));
    return pipe(toChannel2(self), pipeTo(upstreamMarker), pipeTo(buffer5), pipeToOrFail(transducer));
  });
  return new StreamImpl(newChannel);
});
var unfold4 = (s, f) => unfoldChunk(s, (s2) => pipe(f(s2), map2(([a, s3]) => [of2(a), s3])));
var unfoldChunk = (s, f) => {
  const loop5 = (s2) => match2(f(s2), {
    onNone: () => void_5,
    onSome: ([chunk7, s3]) => flatMap17(write(chunk7), () => loop5(s3))
  });
  return new StreamImpl(suspend5(() => loop5(s)));
};
var unfoldChunkEffect = (s, f) => suspend7(() => {
  const loop5 = (s2) => unwrap2(map22(f(s2), match2({
    onNone: () => void_5,
    onSome: ([chunk7, s3]) => flatMap17(write(chunk7), () => loop5(s3))
  })));
  return new StreamImpl(loop5(s));
});
var unfoldEffect = (s, f) => unfoldChunkEffect(s, (s2) => pipe(f(s2), map22(map2(([a, s3]) => [of2(a), s3]))));
var void_6 = succeed17(void 0);
var unwrap4 = (effect4) => flatten12(fromEffect9(effect4));
var unwrapScoped5 = (effect4) => flatten12(scoped6(effect4));
var updateService4 = dual(3, (self, tag4, f) => pipe(self, mapInputContext6((context13) => pipe(context13, add2(tag4, f(pipe(context13, unsafeGet3(tag4))))))));
var when3 = dual(2, (self, test3) => pipe(self, whenEffect3(sync7(test3))));
var whenCase = (evaluate3, pf) => whenCaseEffect(pf)(sync7(evaluate3));
var whenCaseEffect = dual(2, (self, pf) => pipe(fromEffect9(self), flatMap19((a) => pipe(pf(a), getOrElse(() => empty40)))));
var whenEffect3 = dual(2, (self, effect4) => pipe(fromEffect9(effect4), flatMap19((bool) => bool ? self : empty40)));
var withSpan6 = dual(3, (self, name, options) => new StreamImpl(withSpan5(toChannel2(self), name, options)));
var zip13 = dual(2, (self, that) => pipe(self, zipWith12(that, (a, a2) => [a, a2])));
var zipFlatten2 = dual(2, (self, that) => pipe(self, zipWith12(that, (a, a2) => [...a, a2])));
var zipAll = dual(2, (self, options) => zipAllWith(self, {
  other: options.other,
  onSelf: (a) => [a, options.defaultOther],
  onOther: (a2) => [options.defaultSelf, a2],
  onBoth: (a, a2) => [a, a2]
}));
var zipAllLeft = dual(3, (self, other, defaultSelf) => zipAllWith(self, {
  other,
  onSelf: identity,
  onOther: () => defaultSelf,
  onBoth: (a) => a
}));
var zipAllRight = dual(3, (self, other, defaultRight) => zipAllWith(self, {
  other,
  onSelf: () => defaultRight,
  onOther: identity,
  onBoth: (_, a2) => a2
}));
var zipAllSortedByKey = dual(2, (self, options) => zipAllSortedByKeyWith(self, {
  other: options.other,
  onSelf: (a) => [a, options.defaultOther],
  onOther: (a2) => [options.defaultSelf, a2],
  onBoth: (a, a2) => [a, a2],
  order: options.order
}));
var zipAllSortedByKeyLeft = dual(2, (self, options) => zipAllSortedByKeyWith(self, {
  other: options.other,
  onSelf: identity,
  onOther: () => options.defaultSelf,
  onBoth: (a) => a,
  order: options.order
}));
var zipAllSortedByKeyRight = dual(2, (self, options) => zipAllSortedByKeyWith(self, {
  other: options.other,
  onSelf: () => options.defaultOther,
  onOther: identity,
  onBoth: (_, a2) => a2,
  order: options.order
}));
var zipAllSortedByKeyWith = dual(2, (self, options) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_DRAIN_LEFT: {
        return pipe(pullLeft, match17({
          onFailure: fail4,
          onSuccess: (leftChunk) => succeed3([map4(leftChunk, ([k, a]) => [k, options.onSelf(a)]), DrainLeft])
        }));
      }
      case OP_DRAIN_RIGHT: {
        return pipe(pullRight, match17({
          onFailure: fail4,
          onSuccess: (rightChunk) => succeed3([map4(rightChunk, ([k, a2]) => [k, options.onOther(a2)]), DrainRight])
        }));
      }
      case OP_PULL_BOTH: {
        return pipe(unsome(pullLeft), zip10(unsome(pullRight), {
          concurrent: true
        }), matchEffect3({
          onFailure: (error4) => succeed12(fail4(some2(error4))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome(leftOption) && isSome(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight(leftOption.value), pullLeft, pullRight);
              }
              return succeed12(succeed3(merge15(leftOption.value, rightOption.value)));
            }
            if (isSome(leftOption) && isNone(rightOption)) {
              if (isEmpty(leftOption.value)) {
                return pull(DrainLeft, pullLeft, pullRight);
              }
              return succeed12(succeed3([pipe(leftOption.value, map4(([k, a]) => [k, options.onSelf(a)])), DrainLeft]));
            }
            if (isNone(leftOption) && isSome(rightOption)) {
              if (isEmpty(rightOption.value)) {
                return pull(DrainRight, pullLeft, pullRight);
              }
              return succeed12(succeed3([pipe(rightOption.value, map4(([k, a2]) => [k, options.onOther(a2)])), DrainRight]));
            }
            return succeed12(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT: {
        return matchEffect3(pullLeft, {
          onFailure: match2({
            onNone: () => succeed12(succeed3([pipe(state.rightChunk, map4(([k, a2]) => [k, options.onOther(a2)])), DrainRight])),
            onSome: (error4) => succeed12(fail4(some2(error4)))
          }),
          onSuccess: (leftChunk) => isEmpty(leftChunk) ? pull(PullLeft(state.rightChunk), pullLeft, pullRight) : succeed12(succeed3(merge15(leftChunk, state.rightChunk)))
        });
      }
      case OP_PULL_RIGHT: {
        return matchEffect3(pullRight, {
          onFailure: match2({
            onNone: () => succeed12(succeed3([map4(state.leftChunk, ([k, a]) => [k, options.onSelf(a)]), DrainLeft])),
            onSome: (error4) => succeed12(fail4(some2(error4)))
          }),
          onSuccess: (rightChunk) => isEmpty(rightChunk) ? pull(PullRight(state.leftChunk), pullLeft, pullRight) : succeed12(succeed3(merge15(state.leftChunk, rightChunk)))
        });
      }
    }
  };
  const merge15 = (leftChunk, rightChunk) => {
    const hasNext = (chunk7, index) => index < chunk7.length - 1;
    const builder = [];
    let state = void 0;
    let leftIndex = 0;
    let rightIndex = 0;
    let leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
    let rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
    let k1 = leftTuple[0];
    let a = leftTuple[1];
    let k2 = rightTuple[0];
    let a2 = rightTuple[1];
    let loop5 = true;
    while (loop5) {
      const compare = options.order(k1, k2);
      if (compare === 0) {
        builder.push([k1, options.onBoth(a, a2)]);
        if (hasNext(leftChunk, leftIndex) && hasNext(rightChunk, rightIndex)) {
          leftIndex = leftIndex + 1;
          rightIndex = rightIndex + 1;
          leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
          rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
          k1 = leftTuple[0];
          a = leftTuple[1];
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else if (hasNext(leftChunk, leftIndex)) {
          state = PullRight(pipe(leftChunk, drop2(leftIndex + 1)));
          loop5 = false;
        } else if (hasNext(rightChunk, rightIndex)) {
          state = PullLeft(pipe(rightChunk, drop2(rightIndex + 1)));
          loop5 = false;
        } else {
          state = PullBoth;
          loop5 = false;
        }
      } else if (compare < 0) {
        builder.push([k1, options.onSelf(a)]);
        if (hasNext(leftChunk, leftIndex)) {
          leftIndex = leftIndex + 1;
          leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
          k1 = leftTuple[0];
          a = leftTuple[1];
        } else {
          const rightBuilder = [];
          rightBuilder.push(rightTuple);
          while (hasNext(rightChunk, rightIndex)) {
            rightIndex = rightIndex + 1;
            rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
            rightBuilder.push(rightTuple);
          }
          state = PullLeft(unsafeFromArray(rightBuilder));
          loop5 = false;
        }
      } else {
        builder.push([k2, options.onOther(a2)]);
        if (hasNext(rightChunk, rightIndex)) {
          rightIndex = rightIndex + 1;
          rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else {
          const leftBuilder = [];
          leftBuilder.push(leftTuple);
          while (hasNext(leftChunk, leftIndex)) {
            leftIndex = leftIndex + 1;
            leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
            leftBuilder.push(leftTuple);
          }
          state = PullRight(unsafeFromArray(leftBuilder));
          loop5 = false;
        }
      }
    }
    return [unsafeFromArray(builder), state];
  };
  return combineChunks(self, options.other, PullBoth, pull);
});
var zipAllWith = dual(2, (self, options) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_DRAIN_LEFT: {
        return matchEffect3(pullLeft, {
          onFailure: (error4) => succeed12(fail4(error4)),
          onSuccess: (leftChunk) => succeed12(succeed3([map4(leftChunk, options.onSelf), DrainLeft]))
        });
      }
      case OP_DRAIN_RIGHT: {
        return matchEffect3(pullRight, {
          onFailure: (error4) => succeed12(fail4(error4)),
          onSuccess: (rightChunk) => succeed12(succeed3([map4(rightChunk, options.onOther), DrainRight]))
        });
      }
      case OP_PULL_BOTH: {
        return pipe(unsome(pullLeft), zip10(unsome(pullRight), {
          concurrent: true
        }), matchEffect3({
          onFailure: (error4) => succeed12(fail4(some2(error4))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome(leftOption) && isSome(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight(leftOption.value), pullLeft, pullRight);
              }
              return succeed12(succeed3(zip25(leftOption.value, rightOption.value, options.onBoth)));
            }
            if (isSome(leftOption) && isNone(rightOption)) {
              return succeed12(succeed3([map4(leftOption.value, options.onSelf), DrainLeft]));
            }
            if (isNone(leftOption) && isSome(rightOption)) {
              return succeed12(succeed3([map4(rightOption.value, options.onOther), DrainRight]));
            }
            return succeed12(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT: {
        return matchEffect3(pullLeft, {
          onFailure: match2({
            onNone: () => succeed12(succeed3([map4(state.rightChunk, options.onOther), DrainRight])),
            onSome: (error4) => succeed12(fail4(some2(error4)))
          }),
          onSuccess: (leftChunk) => {
            if (isEmpty(leftChunk)) {
              return pull(PullLeft(state.rightChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.rightChunk)) {
              return pull(PullRight(leftChunk), pullLeft, pullRight);
            }
            return succeed12(succeed3(zip25(leftChunk, state.rightChunk, options.onBoth)));
          }
        });
      }
      case OP_PULL_RIGHT: {
        return matchEffect3(pullRight, {
          onFailure: match2({
            onNone: () => succeed12(succeed3([map4(state.leftChunk, options.onSelf), DrainLeft])),
            onSome: (error4) => succeed12(fail4(some2(error4)))
          }),
          onSuccess: (rightChunk) => {
            if (isEmpty(rightChunk)) {
              return pull(PullRight(state.leftChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.leftChunk)) {
              return pull(PullLeft(rightChunk), pullLeft, pullRight);
            }
            return succeed12(succeed3(zip25(state.leftChunk, rightChunk, options.onBoth)));
          }
        });
      }
    }
  };
  const zip25 = (leftChunk, rightChunk, f) => {
    const [output, either13] = zipChunks(leftChunk, rightChunk, f);
    switch (either13._tag) {
      case "Left": {
        if (isEmpty(either13.left)) {
          return [output, PullBoth];
        }
        return [output, PullRight(either13.left)];
      }
      case "Right": {
        if (isEmpty(either13.right)) {
          return [output, PullBoth];
        }
        return [output, PullLeft(either13.right)];
      }
    }
  };
  return combineChunks(self, options.other, PullBoth, pull);
});
var zipLatest = dual(2, (self, that) => pipe(self, zipLatestWith(that, (a, a2) => [a, a2])));
var zipLatestWith = dual(3, (self, that, f) => {
  const pullNonEmpty = (pull) => pipe(pull, flatMap15((chunk7) => isEmpty(chunk7) ? pullNonEmpty(pull) : succeed12(chunk7)));
  return pipe(toPull2(self), map22(pullNonEmpty), zip10(pipe(toPull2(that), map22(pullNonEmpty))), flatMap15(([left2, right2]) => pipe(fromEffectOption(raceWith2(left2, right2, {
    onSelfDone: (leftDone, rightFiber) => pipe(suspend3(() => leftDone), zipWith8(join4(rightFiber), (l, r) => [l, r, true])),
    onOtherDone: (rightDone, leftFiber) => pipe(suspend3(() => rightDone), zipWith8(join4(leftFiber), (l, r) => [r, l, false]))
  })), flatMap19(([l, r, leftFirst]) => pipe(fromEffect9(make36([unsafeLast(l), unsafeLast(r)])), flatMap19((latest) => pipe(fromChunk(leftFirst ? pipe(r, map4((a2) => f(unsafeLast(l), a2))) : pipe(l, map4((a) => f(a, unsafeLast(r))))), concat2(pipe(repeatEffectOption(left2), mergeEither(repeatEffectOption(right2)), mapEffectSequential(match({
    onLeft: (leftChunk) => pipe(modify6(latest, ([_, rightLatest]) => [pipe(leftChunk, map4((a) => f(a, rightLatest))), [unsafeLast(leftChunk), rightLatest]])),
    onRight: (rightChunk) => pipe(modify6(latest, ([leftLatest, _]) => [pipe(rightChunk, map4((a2) => f(leftLatest, a2))), [leftLatest, unsafeLast(rightChunk)]]))
  })), flatMap19(fromChunk))))))), toPull2)), fromPull2);
});
var zipLeft10 = dual(2, (self, that) => pipe(self, zipWithChunks(that, (left2, right2) => {
  if (left2.length > right2.length) {
    return [pipe(left2, take(right2.length)), left(pipe(left2, take(right2.length)))];
  }
  return [left2, right(pipe(right2, drop2(left2.length)))];
})));
var zipRight10 = dual(2, (self, that) => pipe(self, zipWithChunks(that, (left2, right2) => {
  if (left2.length > right2.length) {
    return [right2, left(pipe(left2, take(right2.length)))];
  }
  return [pipe(right2, take(left2.length)), right(pipe(right2, drop2(left2.length)))];
})));
var zipWith12 = dual(3, (self, that, f) => pipe(self, zipWithChunks(that, (leftChunk, rightChunk) => zipChunks(leftChunk, rightChunk, f))));
var zipWithChunks = dual(3, (self, that, f) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_PULL_BOTH2: {
        return pipe(unsome(pullLeft), zip10(unsome(pullRight), {
          concurrent: true
        }), matchEffect3({
          onFailure: (error4) => succeed12(fail4(some2(error4))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome(leftOption) && isSome(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth2, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft2(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight2(leftOption.value), pullLeft, pullRight);
              }
              return succeed12(succeed3(zip25(leftOption.value, rightOption.value)));
            }
            return succeed12(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT2: {
        return matchEffect3(pullLeft, {
          onFailure: (error4) => succeed12(fail4(error4)),
          onSuccess: (leftChunk) => {
            if (isEmpty(leftChunk)) {
              return pull(PullLeft2(state.rightChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.rightChunk)) {
              return pull(PullRight2(leftChunk), pullLeft, pullRight);
            }
            return succeed12(succeed3(zip25(leftChunk, state.rightChunk)));
          }
        });
      }
      case OP_PULL_RIGHT2: {
        return matchEffect3(pullRight, {
          onFailure: (error4) => succeed12(fail4(error4)),
          onSuccess: (rightChunk) => {
            if (isEmpty(rightChunk)) {
              return pull(PullRight2(state.leftChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.leftChunk)) {
              return pull(PullLeft2(rightChunk), pullLeft, pullRight);
            }
            return succeed12(succeed3(zip25(state.leftChunk, rightChunk)));
          }
        });
      }
    }
  };
  const zip25 = (leftChunk, rightChunk) => {
    const [output, either13] = f(leftChunk, rightChunk);
    switch (either13._tag) {
      case "Left": {
        if (isEmpty(either13.left)) {
          return [output, PullBoth2];
        }
        return [output, PullRight2(either13.left)];
      }
      case "Right": {
        if (isEmpty(either13.right)) {
          return [output, PullBoth2];
        }
        return [output, PullLeft2(either13.right)];
      }
    }
  };
  return pipe(self, combineChunks(that, PullBoth2, pull));
});
var zipWithIndex = (self) => pipe(self, mapAccum5(0, (index, a) => [index + 1, [a, index]]));
var zipWithNext = (self) => {
  const process2 = (last8) => readWithCause({
    onInput: (input) => {
      const [newLast, chunk7] = mapAccum2(input, last8, (prev, curr) => [some2(curr), pipe(prev, map2((a) => [a, curr]))]);
      const output = filterMap2(chunk7, (option9) => isSome(option9) ? some2([option9.value[0], some2(option9.value[1])]) : none2());
      return flatMap17(write(output), () => process2(newLast));
    },
    onFailure: failCause11,
    onDone: () => match2(last8, {
      onNone: () => void_5,
      onSome: (value8) => zipRight7(write(of2([value8, none2()])), void_5)
    })
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(process2(none2()))));
};
var zipWithPrevious = (self) => pipe(self, mapAccum5(none2(), (prev, curr) => [some2(curr), [prev, curr]]));
var zipWithPreviousAndNext = (self) => pipe(zipWithNext(zipWithPrevious(self)), map28(([[prev, curr], next6]) => [prev, curr, pipe(next6, map2((tuple4) => tuple4[1]))]));
var zipChunks = (left2, right2, f) => {
  if (left2.length > right2.length) {
    return [pipe(left2, take(right2.length), zipWith2(right2, f)), left(pipe(left2, drop2(right2.length)))];
  }
  return [pipe(left2, zipWith2(pipe(right2, take(left2.length)), f)), right(pipe(right2, drop2(left2.length)))];
};
var Do3 = succeed17({});
var bind3 = dual((args) => typeof args[0] !== "string", (self, tag4, f, options) => flatMap19(self, (k) => map28(f(k), (a) => ({
  ...k,
  [tag4]: a
})), options));
var bindTo3 = dual(2, (self, tag4) => map28(self, (a) => ({
  [tag4]: a
})));
var let_3 = dual(3, (self, tag4, f) => map28(self, (k) => ({
  ...k,
  [tag4]: f(k)
})));
var channelToStream = (self) => {
  return new StreamImpl(self);
};
var decodeText = dual((args) => isStream(args[0]), (self, encoding = "utf-8") => suspend7(() => {
  const decoder2 = new TextDecoder(encoding);
  return map28(self, (s) => decoder2.decode(s));
}));
var encodeText = (self) => suspend7(() => {
  const encoder2 = new TextEncoder();
  return map28(self, (s) => encoder2.encode(s));
});

// ../node_modules/effect/dist/esm/Channel.js
var ChannelTypeId4 = ChannelTypeId3;
var ChannelExceptionTypeId2 = ChannelExceptionTypeId;
var acquireUseRelease4 = acquireUseRelease3;
var acquireReleaseOut2 = acquireReleaseOut;
var as11 = as7;
var asVoid7 = asVoid5;
var buffer3 = buffer;
var bufferChunk2 = bufferChunk;
var catchAll7 = catchAll5;
var catchAllCause7 = catchAllCause5;
var concatAll3 = concatAll;
var concatAllWith2 = concatAllWith;
var concatMap2 = concatMap;
var concatMapWith2 = concatMapWith;
var concatMapWithCustom2 = concatMapWithCustom;
var collect2 = collect;
var concatOut2 = concatOut;
var mapInput9 = mapInput6;
var mapInputEffect5 = mapInputEffect2;
var mapInputError2 = mapInputError;
var mapInputErrorEffect2 = mapInputErrorEffect;
var mapInputIn2 = mapInputIn;
var mapInputInEffect2 = mapInputInEffect;
var doneCollect2 = doneCollect;
var drain4 = drain;
var embedInput2 = embedInput;
var emitCollect2 = emitCollect;
var ensuring8 = ensuring4;
var ensuringWith4 = ensuringWith;
var context8 = context5;
var contextWith6 = contextWith3;
var contextWithChannel2 = contextWithChannel;
var contextWithEffect6 = contextWithEffect3;
var fail17 = fail13;
var failSync9 = failSync6;
var failCause16 = failCause11;
var failCauseSync9 = failCauseSync6;
var flatMap20 = flatMap17;
var flatten13 = flatten11;
var foldChannel2 = foldChannel;
var foldCauseChannel2 = foldCauseChannel;
var fromEffect10 = fromEffect5;
var fromEither3 = fromEither2;
var fromInput4 = fromInput;
var fromPubSub4 = fromPubSub;
var fromPubSubScoped2 = fromPubSubScoped;
var fromOption4 = fromOption3;
var fromQueue4 = fromQueue;
var identity4 = identityChannel;
var interruptWhen3 = interruptWhen;
var interruptWhenDeferred3 = interruptWhenDeferred;
var map29 = map24;
var mapEffect8 = mapEffect5;
var mapError9 = mapError6;
var mapErrorCause6 = mapErrorCause4;
var mapOut2 = mapOut;
var mapOutEffect2 = mapOutEffect;
var mapOutEffectPar2 = mapOutEffectPar;
var mergeAll7 = mergeAll5;
var mergeAllUnbounded2 = mergeAllUnbounded;
var mergeAllUnboundedWith2 = mergeAllUnboundedWith;
var mergeAllWith2 = mergeAllWith;
var mergeMap2 = mergeMap;
var mergeOut2 = mergeOut;
var mergeOutWith2 = mergeOutWith;
var mergeWith3 = mergeWith;
var never8 = never5;
var orDie7 = orDie5;
var orDieWith5 = orDieWith3;
var orElse12 = orElse9;
var pipeTo2 = pipeTo;
var pipeToOrFail2 = pipeToOrFail;
var provideContext7 = provideContext3;
var provideLayer3 = provideLayer;
var mapInputContext7 = mapInputContext4;
var provideSomeLayer4 = provideSomeLayer2;
var provideService9 = provideService5;
var read2 = read;
var readOrFail2 = readOrFail;
var readWith2 = readWith;
var readWithCause2 = readWithCause;
var repeated2 = repeated;
var run6 = run3;
var runCollect3 = runCollect;
var runDrain3 = runDrain;
var scoped7 = scoped5;
var splitLines3 = splitLines;
var succeed18 = succeed14;
var suspend8 = suspend5;
var sync13 = sync9;
var toPubSub3 = toPubSub;
var toPull3 = toPull;
var toQueue3 = toQueue;
var toSink = channelToSink;
var toStream = channelToStream;
var void_7 = void_5;
var unwrap5 = unwrap2;
var unwrapScoped6 = unwrapScoped3;
var updateService5 = updateService3;
var withSpan7 = withSpan5;
var write2 = write;
var writeAll2 = writeAll;
var writeChunk2 = writeChunk;
var zip14 = zip11;
var zipLeft11 = zipLeft7;
var zipRight11 = zipRight7;
var ChannelException2 = ChannelException;
var isChannelException2 = isChannelException;

// ../node_modules/effect/dist/esm/ChildExecutorDecision.js
var ChildExecutorDecision_exports = {};
__export(ChildExecutorDecision_exports, {
  ChildExecutorDecisionTypeId: () => ChildExecutorDecisionTypeId2,
  Close: () => Close2,
  Continue: () => Continue2,
  Yield: () => Yield2,
  isChildExecutorDecision: () => isChildExecutorDecision2,
  isClose: () => isClose2,
  isContinue: () => isContinue4,
  isYield: () => isYield2,
  match: () => match29
});
var ChildExecutorDecisionTypeId2 = ChildExecutorDecisionTypeId;
var Continue2 = Continue;
var Close2 = Close;
var Yield2 = Yield;
var isChildExecutorDecision2 = isChildExecutorDecision;
var isContinue4 = isContinue3;
var isClose2 = isClose;
var isYield2 = isYield;
var match29 = match19;

// ../node_modules/effect/dist/esm/Config.js
var Config_exports = {};
__export(Config_exports, {
  ConfigTypeId: () => ConfigTypeId2,
  all: () => all9,
  array: () => array4,
  boolean: () => boolean4,
  chunk: () => chunk5,
  date: () => date2,
  duration: () => duration4,
  fail: () => fail19,
  hashMap: () => hashMap4,
  hashSet: () => hashSet4,
  integer: () => integer2,
  isConfig: () => isConfig2,
  literal: () => literal2,
  logLevel: () => logLevel2,
  map: () => map31,
  mapAttempt: () => mapAttempt2,
  mapOrFail: () => mapOrFail2,
  nested: () => nested4,
  number: () => number5,
  option: () => option4,
  orElse: () => orElse14,
  orElseIf: () => orElseIf2,
  primitive: () => primitive2,
  repeat: () => repeat4,
  secret: () => secret2,
  string: () => string3,
  succeed: () => succeed20,
  suspend: () => suspend10,
  sync: () => sync15,
  unwrap: () => unwrap7,
  validate: () => validate4,
  withDefault: () => withDefault2,
  withDescription: () => withDescription2,
  zip: () => zip16,
  zipWith: () => zipWith14
});

// ../node_modules/effect/dist/esm/ConfigError.js
var ConfigError_exports = {};
__export(ConfigError_exports, {
  And: () => And2,
  ConfigErrorTypeId: () => ConfigErrorTypeId2,
  InvalidData: () => InvalidData2,
  MissingData: () => MissingData2,
  Or: () => Or2,
  SourceUnavailable: () => SourceUnavailable2,
  Unsupported: () => Unsupported2,
  isAnd: () => isAnd2,
  isConfigError: () => isConfigError2,
  isInvalidData: () => isInvalidData2,
  isMissingData: () => isMissingData2,
  isMissingDataOnly: () => isMissingDataOnly2,
  isOr: () => isOr2,
  isSourceUnavailable: () => isSourceUnavailable2,
  isUnsupported: () => isUnsupported2,
  prefixed: () => prefixed2,
  reduceWithContext: () => reduceWithContext4
});
var ConfigErrorTypeId2 = ConfigErrorTypeId;
var And2 = And;
var Or2 = Or;
var MissingData2 = MissingData;
var InvalidData2 = InvalidData;
var SourceUnavailable2 = SourceUnavailable;
var Unsupported2 = Unsupported;
var isConfigError2 = isConfigError;
var isAnd2 = isAnd;
var isOr2 = isOr;
var isInvalidData2 = isInvalidData;
var isMissingData2 = isMissingData;
var isMissingDataOnly2 = isMissingDataOnly;
var isSourceUnavailable2 = isSourceUnavailable;
var isUnsupported2 = isUnsupported;
var prefixed2 = prefixed;
var reduceWithContext4 = reduceWithContext2;

// ../node_modules/effect/dist/esm/internal/secret.js
var SecretSymbolKey = "effect/Secret";
var SecretTypeId = Symbol.for(SecretSymbolKey);
var proto12 = {
  [SecretTypeId]: SecretTypeId,
  [symbol2]() {
    return pipe(hash(SecretSymbolKey), combine(array2(this.raw)), cached(this));
  },
  [symbol3](that) {
    return isSecret(that) && this.raw.length === that.raw.length && this.raw.every((v, i) => equals(v, that.raw[i]));
  }
};
var isSecret = (u) => hasProperty(u, SecretTypeId);
var make65 = (bytes) => {
  const secret3 = Object.create(proto12);
  Object.defineProperty(secret3, "toString", {
    enumerable: false,
    value() {
      return "Secret(<redacted>)";
    }
  });
  Object.defineProperty(secret3, "toJSON", {
    enumerable: false,
    value() {
      return "<redacted>";
    }
  });
  Object.defineProperty(secret3, "raw", {
    enumerable: false,
    value: bytes
  });
  return secret3;
};
var fromIterable17 = (iterable) => make65(fromIterable(iterable).map((char) => char.charCodeAt(0)));
var fromString3 = (text) => {
  return make65(text.split("").map((char) => char.charCodeAt(0)));
};
var value2 = (self) => {
  return self.raw.map((byte) => String.fromCharCode(byte)).join("");
};
var unsafeWipe = (self) => {
  for (let i = 0; i < self.raw.length; i++) {
    self.raw[i] = 0;
  }
};

// ../node_modules/effect/dist/esm/internal/config.js
var ConfigSymbolKey = "effect/Config";
var ConfigTypeId = Symbol.for(ConfigSymbolKey);
var configVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto13 = {
  ...CommitPrototype,
  [ConfigTypeId]: configVariance,
  commit() {
    return config(this);
  }
};
var boolean3 = (name) => {
  const config2 = primitive("a boolean property", (text) => {
    switch (text) {
      case "true":
      case "yes":
      case "on":
      case "1": {
        return right(true);
      }
      case "false":
      case "no":
      case "off":
      case "0": {
        return right(false);
      }
      default: {
        const error4 = InvalidData([], `Expected a boolean value but received ${text}`);
        return left(error4);
      }
    }
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var array3 = (config2, name) => {
  return pipe(chunk4(config2, name), map30(toReadonlyArray));
};
var chunk4 = (config2, name) => {
  return map30(name === void 0 ? repeat3(config2) : nested3(repeat3(config2), name), unsafeFromArray);
};
var date = (name) => {
  const config2 = primitive("a date property", (text) => {
    const result = Date.parse(text);
    if (Number.isNaN(result)) {
      return left(InvalidData([], `Expected a Date value but received ${text}`));
    }
    return right(new Date(result));
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var fail18 = (message) => {
  const fail28 = Object.create(proto13);
  fail28._tag = OP_FAIL2;
  fail28.message = message;
  fail28.parse = () => left(Unsupported([], message));
  return fail28;
};
var number4 = (name) => {
  const config2 = primitive("a number property", (text) => {
    const result = Number.parseFloat(text);
    if (Number.isNaN(result)) {
      return left(InvalidData([], `Expected a number value but received ${text}`));
    }
    return right(result);
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var integer = (name) => {
  const config2 = primitive("an integer property", (text) => {
    const result = Number.parseInt(text, 10);
    if (Number.isNaN(result)) {
      return left(InvalidData([], `Expected an integer value but received ${text}`));
    }
    return right(result);
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var literal = (...literals) => (name) => {
  const valuesString = literals.map(String).join(", ");
  const config2 = primitive(`one of (${valuesString})`, (text) => {
    const found = literals.find((value8) => String(value8) === text);
    if (found === void 0) {
      return left(InvalidData([], `Expected one of (${valuesString}) but received ${text}`));
    }
    return right(found);
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var logLevel = (name) => {
  const config2 = mapOrFail(string2(), (value8) => {
    const label = value8.toUpperCase();
    const level = allLogLevels.find((level2) => level2.label === label);
    return level === void 0 ? left(InvalidData([], `Expected a log level but received ${value8}`)) : right(level);
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var duration3 = (name) => {
  const config2 = mapOrFail(string2(), (value8) => {
    const duration5 = decodeUnknown(value8);
    return fromOption(duration5, () => InvalidData([], `Expected a duration but received ${value8}`));
  });
  return name === void 0 ? config2 : nested3(config2, name);
};
var map30 = dual(2, (self, f) => mapOrFail(self, (a) => right(f(a))));
var mapAttempt = dual(2, (self, f) => mapOrFail(self, (a) => {
  try {
    return right(f(a));
  } catch (error4) {
    return left(InvalidData([], error4 instanceof Error ? error4.message : `${error4}`));
  }
}));
var mapOrFail = dual(2, (self, f) => {
  const mapOrFail3 = Object.create(proto13);
  mapOrFail3._tag = OP_MAP_OR_FAIL;
  mapOrFail3.original = self;
  mapOrFail3.mapOrFail = f;
  return mapOrFail3;
});
var nested3 = dual(2, (self, name) => {
  const nested7 = Object.create(proto13);
  nested7._tag = OP_NESTED;
  nested7.name = name;
  nested7.config = self;
  return nested7;
});
var orElse13 = dual(2, (self, that) => {
  const fallback = Object.create(proto13);
  fallback._tag = OP_FALLBACK;
  fallback.first = self;
  fallback.second = suspend9(that);
  fallback.condition = constTrue;
  return fallback;
});
var orElseIf = dual(2, (self, options) => {
  const fallback = Object.create(proto13);
  fallback._tag = OP_FALLBACK;
  fallback.first = self;
  fallback.second = suspend9(options.orElse);
  fallback.condition = options.if;
  return fallback;
});
var option3 = (self) => {
  return pipe(self, map30(some2), orElseIf({
    orElse: () => succeed19(none2()),
    if: isMissingDataOnly2
  }));
};
var primitive = (description, parse2) => {
  const primitive3 = Object.create(proto13);
  primitive3._tag = OP_PRIMITIVE;
  primitive3.description = description;
  primitive3.parse = parse2;
  return primitive3;
};
var repeat3 = (self) => {
  const repeat6 = Object.create(proto13);
  repeat6._tag = OP_SEQUENCE;
  repeat6.config = self;
  return repeat6;
};
var secret = (name) => {
  const config2 = primitive("a secret property", (text) => right(fromString3(text)));
  return name === void 0 ? config2 : nested3(config2, name);
};
var hashSet3 = (config2, name) => {
  const newConfig = map30(chunk4(config2), fromIterable5);
  return name === void 0 ? newConfig : nested3(newConfig, name);
};
var string2 = (name) => {
  const config2 = primitive("a text property", right);
  return name === void 0 ? config2 : nested3(config2, name);
};
var all8 = (arg) => {
  if (Array.isArray(arg)) {
    return tuple2(arg);
  } else if (Symbol.iterator in arg) {
    return tuple2([...arg]);
  }
  return struct4(arg);
};
var struct4 = (r) => {
  const entries6 = Object.entries(r);
  let result = pipe(entries6[0][1], map30((value8) => ({
    [entries6[0][0]]: value8
  })));
  if (entries6.length === 1) {
    return result;
  }
  const rest = entries6.slice(1);
  for (const [key, config2] of rest) {
    result = pipe(result, zipWith13(config2, (record2, value8) => ({
      ...record2,
      [key]: value8
    })));
  }
  return result;
};
var succeed19 = (value8) => {
  const constant2 = Object.create(proto13);
  constant2._tag = OP_CONSTANT;
  constant2.value = value8;
  constant2.parse = () => right(value8);
  return constant2;
};
var suspend9 = (config2) => {
  const lazy = Object.create(proto13);
  lazy._tag = OP_LAZY;
  lazy.config = config2;
  return lazy;
};
var sync14 = (value8) => {
  return suspend9(() => succeed19(value8()));
};
var hashMap3 = (config2, name) => {
  const table3 = Object.create(proto13);
  table3._tag = OP_HASHMAP;
  table3.valueConfig = config2;
  return name === void 0 ? table3 : nested3(table3, name);
};
var isConfig = (u) => hasProperty(u, ConfigTypeId);
var tuple2 = (tuple4) => {
  if (tuple4.length === 0) {
    return succeed19([]);
  }
  if (tuple4.length === 1) {
    return map30(tuple4[0], (x) => [x]);
  }
  let result = map30(tuple4[0], (x) => [x]);
  for (let i = 1; i < tuple4.length; i++) {
    const config2 = tuple4[i];
    result = pipe(result, zipWith13(config2, (tuple5, value8) => [...tuple5, value8]));
  }
  return result;
};
var unwrap6 = (wrapped) => {
  if (isConfig(wrapped)) {
    return wrapped;
  }
  return struct4(Object.fromEntries(Object.entries(wrapped).map(([k, a]) => [k, unwrap6(a)])));
};
var validate3 = dual(2, (self, {
  message,
  validation
}) => mapOrFail(self, (a) => {
  if (validation(a)) {
    return right(a);
  }
  return left(InvalidData([], message));
}));
var withDefault = dual(2, (self, def) => orElseIf(self, {
  orElse: () => succeed19(def),
  if: isMissingDataOnly2
}));
var withDescription = dual(2, (self, description) => {
  const described = Object.create(proto13);
  described._tag = OP_DESCRIBED;
  described.config = self;
  described.description = description;
  return described;
});
var zip15 = dual(2, (self, that) => zipWith13(self, that, (a, b) => [a, b]));
var zipWith13 = dual(3, (self, that, f) => {
  const zipWith19 = Object.create(proto13);
  zipWith19._tag = OP_ZIP_WITH;
  zipWith19.left = self;
  zipWith19.right = that;
  zipWith19.zip = f;
  return zipWith19;
});

// ../node_modules/effect/dist/esm/Config.js
var ConfigTypeId2 = ConfigTypeId;
var all9 = all8;
var array4 = array3;
var boolean4 = boolean3;
var chunk5 = chunk4;
var date2 = date;
var fail19 = fail18;
var number5 = number4;
var integer2 = integer;
var literal2 = literal;
var logLevel2 = logLevel;
var duration4 = duration3;
var isConfig2 = isConfig;
var map31 = map30;
var mapAttempt2 = mapAttempt;
var mapOrFail2 = mapOrFail;
var nested4 = nested3;
var orElse14 = orElse13;
var orElseIf2 = orElseIf;
var option4 = option3;
var primitive2 = primitive;
var repeat4 = repeat3;
var secret2 = secret;
var hashSet4 = hashSet3;
var string3 = string2;
var succeed20 = succeed19;
var suspend10 = suspend9;
var sync15 = sync14;
var hashMap4 = hashMap3;
var unwrap7 = unwrap6;
var validate4 = validate3;
var withDefault2 = withDefault;
var withDescription2 = withDescription;
var zip16 = zip15;
var zipWith14 = zipWith13;

// ../node_modules/effect/dist/esm/ConfigProvider.js
var ConfigProvider_exports = {};
__export(ConfigProvider_exports, {
  ConfigProvider: () => ConfigProvider,
  ConfigProviderTypeId: () => ConfigProviderTypeId2,
  FlatConfigProviderTypeId: () => FlatConfigProviderTypeId2,
  constantCase: () => constantCase3,
  fromEnv: () => fromEnv2,
  fromFlat: () => fromFlat2,
  fromJson: () => fromJson2,
  fromMap: () => fromMap2,
  kebabCase: () => kebabCase3,
  lowerCase: () => lowerCase3,
  make: () => make66,
  makeFlat: () => makeFlat2,
  mapInputPath: () => mapInputPath2,
  nested: () => nested5,
  orElse: () => orElse15,
  snakeCase: () => snakeCase3,
  unnested: () => unnested3,
  upperCase: () => upperCase3,
  within: () => within2
});
var ConfigProviderTypeId2 = ConfigProviderTypeId;
var FlatConfigProviderTypeId2 = FlatConfigProviderTypeId;
var ConfigProvider = configProviderTag;
var make66 = make29;
var makeFlat2 = makeFlat;
var fromEnv2 = fromEnv;
var fromFlat2 = fromFlat;
var fromJson2 = fromJson;
var fromMap2 = fromMap;
var constantCase3 = constantCase2;
var mapInputPath2 = mapInputPath;
var kebabCase3 = kebabCase2;
var lowerCase3 = lowerCase2;
var nested5 = nested2;
var orElse15 = orElse3;
var unnested3 = unnested2;
var snakeCase3 = snakeCase2;
var upperCase3 = upperCase2;
var within2 = within;

// ../node_modules/effect/dist/esm/ConfigProviderPathPatch.js
var ConfigProviderPathPatch_exports = {};
__export(ConfigProviderPathPatch_exports, {
  andThen: () => andThen10,
  empty: () => empty41,
  mapName: () => mapName2,
  nested: () => nested6,
  unnested: () => unnested4
});
var empty41 = empty23;
var andThen10 = andThen5;
var mapName2 = mapName;
var nested6 = nested;
var unnested4 = unnested;

// ../node_modules/effect/dist/esm/Console.js
var Console_exports = {};
__export(Console_exports, {
  Console: () => Console,
  TypeId: () => TypeId15,
  assert: () => assert2,
  clear: () => clear3,
  consoleWith: () => consoleWith3,
  count: () => count5,
  countReset: () => countReset2,
  debug: () => debug2,
  dir: () => dir2,
  dirxml: () => dirxml2,
  error: () => error3,
  group: () => group2,
  info: () => info2,
  log: () => log4,
  setConsole: () => setConsole2,
  table: () => table2,
  time: () => time2,
  timeLog: () => timeLog2,
  trace: () => trace2,
  warn: () => warn2,
  withConsole: () => withConsole3,
  withGroup: () => withGroup2,
  withTime: () => withTime2
});
var TypeId15 = TypeId10;
var Console = consoleTag;
var withConsole3 = withConsole;
var setConsole2 = setConsole;
var consoleWith3 = consoleWith;
var assert2 = assert;
var clear3 = clear2;
var count5 = count2;
var countReset2 = countReset;
var debug2 = debug;
var dir2 = dir;
var dirxml2 = dirxml;
var error3 = error2;
var group2 = group;
var info2 = info;
var log4 = log2;
var table2 = table;
var time2 = time;
var timeLog2 = timeLog;
var trace2 = trace;
var warn2 = warn;
var withGroup2 = withGroup;
var withTime2 = withTime;

// ../node_modules/effect/dist/esm/Data.js
var Data_exports = {};
__export(Data_exports, {
  Class: () => Class4,
  Error: () => Error3,
  Structural: () => Structural2,
  TaggedClass: () => TaggedClass3,
  TaggedError: () => TaggedError,
  array: () => array5,
  case: () => _case,
  struct: () => struct5,
  tagged: () => tagged5,
  taggedEnum: () => taggedEnum,
  tuple: () => tuple3,
  unsafeArray: () => unsafeArray,
  unsafeStruct: () => unsafeStruct
});
var struct5 = struct3;
var unsafeStruct = (as16) => Object.setPrototypeOf(as16, StructuralPrototype);
var tuple3 = (...as16) => unsafeArray(as16);
var array5 = (as16) => unsafeArray(as16.slice(0));
var unsafeArray = (as16) => Object.setPrototypeOf(as16, ArrayProto);
var _case = () => (args) => args === void 0 ? Object.create(StructuralPrototype) : struct5(args);
var tagged5 = (tag4) => (args) => {
  const value8 = args === void 0 ? Object.create(StructuralPrototype) : struct5(args);
  value8._tag = tag4;
  return value8;
};
var Class4 = Structural;
var TaggedClass3 = (tag4) => {
  class Base3 extends Class4 {
    constructor() {
      super(...arguments);
      __publicField(this, "_tag", tag4);
    }
  }
  return Base3;
};
var Structural2 = Structural;
var taggedEnum = () => new Proxy({}, {
  get(_target, tag4, _receiver) {
    return tagged5(tag4);
  }
});
var Error3 = function() {
  return class Base extends YieldableError {
    constructor(args) {
      super();
      if (args) {
        Object.assign(this, args);
      }
    }
  };
}();
var TaggedError = (tag4) => {
  class Base3 extends Error3 {
    constructor() {
      super(...arguments);
      __publicField(this, "_tag", tag4);
    }
  }
  ;
  Base3.prototype.name = tag4;
  return Base3;
};

// ../node_modules/effect/dist/esm/DefaultServices.js
var DefaultServices_exports = {};
__export(DefaultServices_exports, {
  currentServices: () => currentServices2,
  liveServices: () => liveServices2
});
var liveServices2 = liveServices;
var currentServices2 = currentServices;

// ../node_modules/effect/dist/esm/Encoding.js
var Encoding_exports = {};
__export(Encoding_exports, {
  DecodeException: () => DecodeException2,
  DecodeExceptionTypeId: () => DecodeExceptionTypeId2,
  decodeBase64: () => decodeBase64,
  decodeBase64String: () => decodeBase64String,
  decodeBase64Url: () => decodeBase64Url,
  decodeBase64UrlString: () => decodeBase64UrlString,
  decodeHex: () => decodeHex,
  decodeHexString: () => decodeHexString,
  encodeBase64: () => encodeBase64,
  encodeBase64Url: () => encodeBase64Url,
  encodeHex: () => encodeHex,
  isDecodeException: () => isDecodeException2
});

// ../node_modules/effect/dist/esm/internal/encoding/common.js
var DecodeExceptionTypeId = Symbol.for("effect/Encoding/errors/Decode");
var DecodeException = (input, message) => {
  const out = {
    _tag: "DecodeException",
    [DecodeExceptionTypeId]: DecodeExceptionTypeId,
    input
  };
  if (isString(message)) {
    out.message = message;
  }
  return out;
};
var isDecodeException = (u) => hasProperty(u, DecodeExceptionTypeId);
var encoder = new TextEncoder();
var decoder = new TextDecoder();

// ../node_modules/effect/dist/esm/internal/encoding/base64.js
var encode = (bytes) => {
  const length3 = bytes.length;
  let result = "";
  let i;
  for (i = 2; i < length3; i += 3) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 15) << 2 | bytes[i] >> 6];
    result += base64abc[bytes[i] & 63];
  }
  if (i === length3 + 1) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === length3) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
};
var decode2 = (str) => {
  const length3 = str.length;
  if (length3 % 4 !== 0) {
    return left(DecodeException(str, `Length must be a multiple of 4, but is ${length3}`));
  }
  const index = str.indexOf("=");
  if (index !== -1 && (index < length3 - 2 || index === length3 - 2 && str[length3 - 1] !== "=")) {
    return left(DecodeException(str, "Found a '=' character, but it is not at the end"));
  }
  try {
    const missingOctets = str.endsWith("==") ? 2 : str.endsWith("=") ? 1 : 0;
    const result = new Uint8Array(3 * (length3 / 4));
    for (let i = 0, j = 0; i < length3; i += 4, j += 3) {
      const buffer5 = getBase64Code(str.charCodeAt(i)) << 18 | getBase64Code(str.charCodeAt(i + 1)) << 12 | getBase64Code(str.charCodeAt(i + 2)) << 6 | getBase64Code(str.charCodeAt(i + 3));
      result[j] = buffer5 >> 16;
      result[j + 1] = buffer5 >> 8 & 255;
      result[j + 2] = buffer5 & 255;
    }
    return right(result.subarray(0, result.length - missingOctets));
  } catch (e) {
    return left(DecodeException(str, e instanceof Error ? e.message : "Invalid input"));
  }
};
function getBase64Code(charCode) {
  if (charCode >= base64codes.length) {
    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
  }
  const code = base64codes[charCode];
  if (code === 255) {
    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
  }
  return code;
}
var base64abc = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"];
var base64codes = [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];

// ../node_modules/effect/dist/esm/internal/encoding/base64Url.js
var encode2 = (data) => encode(data).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
var decode3 = (str) => {
  const length3 = str.length;
  if (length3 % 4 === 1) {
    return left(DecodeException(str, `Length should be a multiple of 4, but is ${length3}`));
  }
  if (!/^[-_A-Z0-9]*?={0,2}$/i.test(str)) {
    return left(DecodeException(str, "Invalid input"));
  }
  let sanitized = length3 % 4 === 2 ? `${str}==` : length3 % 4 === 3 ? `${str}=` : str;
  sanitized = sanitized.replace(/-/g, "+").replace(/_/g, "/");
  return decode2(sanitized);
};

// ../node_modules/effect/dist/esm/internal/encoding/hex.js
var encode3 = (bytes) => {
  let result = "";
  for (let i = 0; i < bytes.length; ++i) {
    result += bytesToHex[bytes[i]];
  }
  return result;
};
var decode4 = (str) => {
  const bytes = new TextEncoder().encode(str);
  if (bytes.length % 2 !== 0) {
    return left(DecodeException(str, `Length must be a multiple of 2, but is ${bytes.length}`));
  }
  try {
    const length3 = bytes.length / 2;
    const result = new Uint8Array(length3);
    for (let i = 0; i < length3; i++) {
      const a = fromHexChar(bytes[i * 2]);
      const b = fromHexChar(bytes[i * 2 + 1]);
      result[i] = a << 4 | b;
    }
    return right(result);
  } catch (e) {
    return left(DecodeException(str, e instanceof Error ? e.message : "Invalid input"));
  }
};
var bytesToHex = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
var fromHexChar = (byte) => {
  if (48 <= byte && byte <= 57) {
    return byte - 48;
  }
  if (97 <= byte && byte <= 102) {
    return byte - 97 + 10;
  }
  if (65 <= byte && byte <= 70) {
    return byte - 65 + 10;
  }
  throw new TypeError("Invalid input");
};

// ../node_modules/effect/dist/esm/Encoding.js
var encodeBase64 = (input) => typeof input === "string" ? encode(encoder.encode(input)) : encode(input);
var decodeBase64 = (str) => decode2(str);
var decodeBase64String = (str) => map(decodeBase64(str), (_) => decoder.decode(_));
var encodeBase64Url = (input) => typeof input === "string" ? encode2(encoder.encode(input)) : encode2(input);
var decodeBase64Url = (str) => decode3(str);
var decodeBase64UrlString = (str) => map(decodeBase64Url(str), (_) => decoder.decode(_));
var encodeHex = (input) => typeof input === "string" ? encode3(encoder.encode(input)) : encode3(input);
var decodeHex = (str) => decode4(str);
var decodeHexString = (str) => map(decodeHex(str), (_) => decoder.decode(_));
var DecodeExceptionTypeId2 = DecodeExceptionTypeId;
var DecodeException2 = DecodeException;
var isDecodeException2 = isDecodeException;

// ../node_modules/effect/dist/esm/FiberHandle.js
var FiberHandle_exports = {};
__export(FiberHandle_exports, {
  TypeId: () => TypeId16,
  clear: () => clear4,
  get: () => get13,
  isFiberHandle: () => isFiberHandle,
  join: () => join5,
  make: () => make68,
  makeRuntime: () => makeRuntime,
  run: () => run7,
  runtime: () => runtime5,
  set: () => set9,
  unsafeGet: () => unsafeGet8,
  unsafeSet: () => unsafeSet
});

// ../node_modules/effect/dist/esm/FiberRef.js
var FiberRef_exports = {};
__export(FiberRef_exports, {
  FiberRefTypeId: () => FiberRefTypeId2,
  currentConcurrency: () => currentConcurrency2,
  currentContext: () => currentContext2,
  currentLogAnnotations: () => currentLogAnnotations2,
  currentLogLevel: () => currentLogLevel2,
  currentLogSpan: () => currentLogSpan2,
  currentLoggers: () => currentLoggers2,
  currentMaxOpsBeforeYield: () => currentMaxOpsBeforeYield2,
  currentMetricLabels: () => currentMetricLabels2,
  currentMinimumLogLevel: () => currentMinimumLogLevel2,
  currentRequestBatchingEnabled: () => currentRequestBatchingEnabled,
  currentRequestCache: () => currentRequestCache,
  currentRequestCacheEnabled: () => currentRequestCacheEnabled,
  currentRuntimeFlags: () => currentRuntimeFlags2,
  currentScheduler: () => currentScheduler2,
  currentSchedulingPriority: () => currentSchedulingPriority2,
  currentSupervisor: () => currentSupervisor2,
  currentTracerEnabled: () => currentTracerEnabled2,
  currentTracerSpanAnnotations: () => currentTracerSpanAnnotations2,
  currentTracerSpanLinks: () => currentTracerSpanLinks2,
  currentTracerTimingEnabled: () => currentTracerTimingEnabled2,
  delete: () => _delete,
  get: () => get12,
  getAndSet: () => getAndSet4,
  getAndUpdate: () => getAndUpdate4,
  getAndUpdateSome: () => getAndUpdateSome3,
  getWith: () => getWith,
  interruptedCause: () => interruptedCause,
  make: () => make67,
  makeContext: () => makeContext2,
  makeRuntimeFlags: () => makeRuntimeFlags,
  makeWith: () => makeWith3,
  modify: () => modify8,
  modifySome: () => modifySome3,
  reset: () => reset2,
  set: () => set8,
  unhandledErrorLogLevel: () => unhandledErrorLogLevel,
  unsafeMake: () => unsafeMake12,
  unsafeMakeContext: () => unsafeMakeContext,
  unsafeMakeHashSet: () => unsafeMakeHashSet,
  unsafeMakePatch: () => unsafeMakePatch,
  unsafeMakeSupervisor: () => unsafeMakeSupervisor,
  update: () => update7,
  updateAndGet: () => updateAndGet4,
  updateSome: () => updateSome3,
  updateSomeAndGet: () => updateSomeAndGet3
});
var FiberRefTypeId2 = FiberRefTypeId;
var make67 = fiberRefMake;
var makeWith3 = fiberRefMakeWith;
var makeContext2 = fiberRefMakeContext;
var makeRuntimeFlags = fiberRefMakeRuntimeFlags;
var unsafeMake12 = fiberRefUnsafeMake;
var unsafeMakeHashSet = fiberRefUnsafeMakeHashSet;
var unsafeMakeContext = fiberRefUnsafeMakeContext;
var unsafeMakeSupervisor = fiberRefUnsafeMakeSupervisor;
var unsafeMakePatch = fiberRefUnsafeMakePatch;
var get12 = fiberRefGet;
var getAndSet4 = fiberRefGetAndSet;
var getAndUpdate4 = fiberRefGetAndUpdate;
var getAndUpdateSome3 = fiberRefGetAndUpdateSome;
var getWith = fiberRefGetWith;
var set8 = fiberRefSet;
var _delete = fiberRefDelete;
var reset2 = fiberRefReset;
var modify8 = fiberRefModify;
var modifySome3 = fiberRefModifySome;
var update7 = fiberRefUpdate;
var updateSome3 = fiberRefUpdateSome;
var updateAndGet4 = fiberRefUpdateAndGet;
var updateSomeAndGet3 = fiberRefUpdateSomeAndGet;
var currentConcurrency2 = currentConcurrency;
var currentRequestBatchingEnabled = currentRequestBatching;
var currentRequestCache = currentCache;
var currentRequestCacheEnabled = currentCacheEnabled;
var currentContext2 = currentContext;
var currentSchedulingPriority2 = currentSchedulingPriority;
var currentMaxOpsBeforeYield2 = currentMaxOpsBeforeYield;
var unhandledErrorLogLevel = currentUnhandledErrorLogLevel;
var currentLogAnnotations2 = currentLogAnnotations;
var currentLoggers2 = currentLoggers;
var currentLogLevel2 = currentLogLevel;
var currentMinimumLogLevel2 = currentMinimumLogLevel;
var currentLogSpan2 = currentLogSpan;
var currentRuntimeFlags2 = currentRuntimeFlags;
var currentScheduler2 = currentScheduler;
var currentSupervisor2 = currentSupervisor;
var currentMetricLabels2 = currentMetricLabels;
var currentTracerEnabled2 = currentTracerEnabled;
var currentTracerTimingEnabled2 = currentTracerTimingEnabled;
var currentTracerSpanAnnotations2 = currentTracerSpanAnnotations;
var currentTracerSpanLinks2 = currentTracerSpanLinks;
var interruptedCause = currentInterruptedCause;

// ../node_modules/effect/dist/esm/FiberHandle.js
var TypeId16 = Symbol.for("effect/FiberHandle");
var isFiberHandle = (u) => hasProperty(u, TypeId16);
var Proto2 = {
  [TypeId16]: TypeId16,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberHandle",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeMake13 = (deferred) => {
  const self = Object.create(Proto2);
  self.state = {
    _tag: "Open",
    fiber: void 0
  };
  self.deferred = deferred;
  return self;
};
var make68 = () => acquireRelease2(map22(make23(), (deferred) => unsafeMake13(deferred)), (handle) => zipRight6(clear4(handle), suspend3(() => {
  handle.state = {
    _tag: "Closed"
  };
  return done2(handle.deferred, void_2);
})));
var makeRuntime = () => flatMap15(make68(), (self) => runtime5(self)());
var unsafeSet = dual((args) => isFiberHandle(args[0]), (self, fiber, options) => {
  if (self.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork((options == null ? void 0 : options.interruptAs) ?? none4);
    return;
  } else if (self.state.fiber !== void 0) {
    if ((options == null ? void 0 : options.onlyIfMissing) === true) {
      fiber.unsafeInterruptAsFork((options == null ? void 0 : options.interruptAs) ?? none4);
      return;
    } else if (self.state.fiber === fiber) {
      return;
    }
    self.state.fiber.unsafeInterruptAsFork((options == null ? void 0 : options.interruptAs) ?? none4);
    self.state.fiber === void 0;
  }
  ;
  fiber.setFiberRef(unhandledErrorLogLevel, none2());
  self.state.fiber = fiber;
  fiber.addObserver((exit3) => {
    if (self.state._tag === "Open" && fiber === self.state.fiber) {
      self.state.fiber = void 0;
    }
    if (isFailure2(exit3) && !isInterruptedOnly2(exit3.cause)) {
      unsafeDone(self.deferred, exit3);
    }
  });
});
var set9 = dual((args) => isFiberHandle(args[0]), (self, fiber, options) => fiberIdWith2((fiberId5) => sync7(() => unsafeSet(self, fiber, {
  interruptAs: fiberId5,
  onlyIfMissing: options == null ? void 0 : options.onlyIfMissing
}))));
var unsafeGet8 = (self) => self.state._tag === "Closed" ? none2() : fromNullable(self.state.fiber);
var get13 = (self) => suspend3(() => unsafeGet8(self));
var clear4 = (self) => uninterruptibleMask2((restore) => suspend3(() => {
  if (self.state._tag === "Closed" || self.state.fiber === void 0) {
    return _void;
  }
  return zipRight6(restore(interrupt6(self.state.fiber)), sync7(() => {
    if (self.state._tag === "Open") {
      self.state.fiber = void 0;
    }
  }));
}));
var constInterruptedFiber = function() {
  let fiber = void 0;
  return () => {
    if (fiber === void 0) {
      fiber = runFork(interrupt7);
    }
    return fiber;
  };
}();
var run7 = function() {
  const self = arguments[0];
  if (isEffect2(arguments[1])) {
    const effect4 = arguments[1];
    const options2 = arguments[2];
    return suspend3(() => {
      if (self.state._tag === "Closed") {
        return interrupt7;
      } else if (self.state.fiber !== void 0 && (options2 == null ? void 0 : options2.onlyIfMissing) === true) {
        return sync7(constInterruptedFiber);
      }
      return uninterruptibleMask2((restore) => tap3(restore(forkDaemon2(effect4)), (fiber) => set9(self, fiber, options2)));
    });
  }
  const options = arguments[1];
  return (effect4) => suspend3(() => {
    if (self.state._tag === "Closed") {
      return interrupt7;
    } else if (self.state.fiber !== void 0 && (options == null ? void 0 : options.onlyIfMissing) === true) {
      return sync7(constInterruptedFiber);
    }
    return uninterruptibleMask2((restore) => tap3(restore(forkDaemon2(effect4)), (fiber) => set9(self, fiber, options)));
  });
};
var runtime5 = (self) => () => map22(runtime4(), (runtime8) => {
  const runFork3 = runFork2(runtime8);
  return (effect4, options) => {
    if (self.state._tag === "Closed") {
      return constInterruptedFiber();
    } else if (self.state.fiber !== void 0 && (options == null ? void 0 : options.onlyIfMissing) === true) {
      return constInterruptedFiber();
    }
    const fiber = runFork3(effect4, options);
    unsafeSet(self, fiber, options);
    return fiber;
  };
});
var join5 = (self) => _await(self.deferred);

// ../node_modules/effect/dist/esm/FiberMap.js
var FiberMap_exports = {};
__export(FiberMap_exports, {
  TypeId: () => TypeId17,
  clear: () => clear5,
  get: () => get14,
  has: () => has9,
  isFiberMap: () => isFiberMap,
  join: () => join6,
  make: () => make69,
  makeRuntime: () => makeRuntime2,
  remove: () => remove10,
  run: () => run8,
  runtime: () => runtime6,
  set: () => set10,
  size: () => size19,
  unsafeGet: () => unsafeGet9,
  unsafeHas: () => unsafeHas,
  unsafeSet: () => unsafeSet2
});
var TypeId17 = Symbol.for("effect/FiberMap");
var isFiberMap = (u) => hasProperty(u, TypeId17);
var Proto3 = {
  [TypeId17]: TypeId17,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return empty();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeMake14 = (backing, deferred) => {
  const self = Object.create(Proto3);
  self.state = {
    _tag: "Open",
    backing
  };
  self.deferred = deferred;
  return self;
};
var make69 = () => acquireRelease2(map22(make23(), (deferred) => unsafeMake14(empty21(), deferred)), (map43) => zipRight6(clear5(map43), suspend3(() => {
  map43.state = {
    _tag: "Closed"
  };
  return done2(map43.deferred, void_2);
})));
var makeRuntime2 = () => flatMap15(make69(), (self) => runtime6(self)());
var unsafeSet2 = dual((args) => isFiberMap(args[0]), (self, key, fiber, options) => {
  if (self.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork((options == null ? void 0 : options.interruptAs) ?? none4);
    return;
  }
  const previous2 = get7(self.state.backing, key);
  if (previous2._tag === "Some") {
    if ((options == null ? void 0 : options.onlyIfMissing) === true) {
      fiber.unsafeInterruptAsFork((options == null ? void 0 : options.interruptAs) ?? none4);
      return;
    } else if (previous2.value === fiber) {
      return;
    }
    previous2.value.unsafeInterruptAsFork((options == null ? void 0 : options.interruptAs) ?? none4);
  }
  ;
  fiber.setFiberRef(unhandledErrorLogLevel, none2());
  set4(self.state.backing, key, fiber);
  fiber.addObserver((exit3) => {
    if (self.state._tag === "Closed") {
      return;
    }
    const current2 = get7(self.state.backing, key);
    if (isSome(current2) && fiber === current2.value) {
      remove7(self.state.backing, key);
    }
    if (isFailure2(exit3) && !isInterruptedOnly2(exit3.cause)) {
      unsafeDone(self.deferred, exit3);
    }
  });
});
var set10 = dual((args) => isFiberMap(args[0]), (self, key, fiber, options) => fiberIdWith2((fiberId5) => sync7(() => unsafeSet2(self, key, fiber, {
  interruptAs: fiberId5,
  onlyIfMissing: options == null ? void 0 : options.onlyIfMissing
}))));
var unsafeGet9 = dual(2, (self, key) => self.state._tag === "Closed" ? none2() : get7(self.state.backing, key));
var get14 = dual(2, (self, key) => suspend3(() => unsafeGet9(self, key)));
var unsafeHas = dual(2, (self, key) => self.state._tag === "Closed" ? false : has5(self.state.backing, key));
var has9 = dual(2, (self, key) => sync7(() => unsafeHas(self, key)));
var remove10 = dual(2, (self, key) => suspend3(() => {
  if (self.state._tag === "Closed") {
    return _void;
  }
  const fiber = get7(self.state.backing, key);
  if (fiber._tag === "None") {
    return _void;
  }
  return interrupt6(fiber.value);
}));
var clear5 = (self) => suspend3(() => {
  if (self.state._tag === "Closed") {
    return _void;
  }
  return forEach12(self.state.backing, ([, fiber]) => (
    // will be removed by the observer
    interrupt6(fiber)
  ));
});
var constInterruptedFiber2 = function() {
  let fiber = void 0;
  return () => {
    if (fiber === void 0) {
      fiber = runFork(interrupt7);
    }
    return fiber;
  };
}();
var run8 = function() {
  if (isEffect2(arguments[2])) {
    const self2 = arguments[0];
    const key2 = arguments[1];
    const effect4 = arguments[2];
    const options2 = arguments[3];
    return suspend3(() => {
      if (self2.state._tag === "Closed") {
        return interrupt7;
      } else if ((options2 == null ? void 0 : options2.onlyIfMissing) === true && unsafeHas(self2, key2)) {
        return sync7(constInterruptedFiber2);
      }
      return uninterruptibleMask2((restore) => tap3(restore(forkDaemon2(effect4)), (fiber) => set10(self2, key2, fiber, options2)));
    });
  }
  const self = arguments[0];
  const key = arguments[1];
  const options = arguments[2];
  return (effect4) => suspend3(() => {
    if (self.state._tag === "Closed") {
      return interrupt7;
    } else if ((options == null ? void 0 : options.onlyIfMissing) === true && unsafeHas(self, key)) {
      return sync7(constInterruptedFiber2);
    }
    return uninterruptibleMask2((restore) => tap3(restore(forkDaemon2(effect4)), (fiber) => set10(self, key, fiber, options)));
  });
};
var runtime6 = (self) => () => map22(runtime4(), (runtime8) => {
  const runFork3 = runFork2(runtime8);
  return (key, effect4, options) => {
    if (self.state._tag === "Closed") {
      return constInterruptedFiber2();
    } else if ((options == null ? void 0 : options.onlyIfMissing) === true && unsafeHas(self, key)) {
      return constInterruptedFiber2();
    }
    const fiber = runFork3(effect4, options);
    unsafeSet2(self, key, fiber, options);
    return fiber;
  };
});
var size19 = (self) => sync7(() => self.state._tag === "Closed" ? 0 : size8(self.state.backing));
var join6 = (self) => _await(self.deferred);

// ../node_modules/effect/dist/esm/FiberSet.js
var FiberSet_exports = {};
__export(FiberSet_exports, {
  TypeId: () => TypeId18,
  add: () => add6,
  clear: () => clear6,
  isFiberSet: () => isFiberSet,
  join: () => join7,
  make: () => make70,
  makeRuntime: () => makeRuntime3,
  run: () => run9,
  runtime: () => runtime7,
  size: () => size20,
  unsafeAdd: () => unsafeAdd
});
var TypeId18 = Symbol.for("effect/FiberSet");
var isFiberSet = (u) => hasProperty(u, TypeId18);
var Proto4 = {
  [TypeId18]: TypeId18,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return empty();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeMake15 = (backing, deferred) => {
  const self = Object.create(Proto4);
  self.state = {
    _tag: "Open",
    backing
  };
  self.deferred = deferred;
  return self;
};
var make70 = () => acquireRelease2(map22(make23(), (deferred) => unsafeMake15(/* @__PURE__ */ new Set(), deferred)), (set22) => zipRight6(clear6(set22), suspend3(() => {
  set22.state = {
    _tag: "Closed"
  };
  return done2(set22.deferred, void_2);
})));
var makeRuntime3 = () => flatMap15(make70(), (self) => runtime7(self)());
var unsafeAdd = dual((args) => isFiberSet(args[0]), (self, fiber, options) => {
  if (self.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork((options == null ? void 0 : options.interruptAs) ?? none4);
    return;
  } else if (self.state.backing.has(fiber)) {
    return;
  }
  ;
  fiber.setFiberRef(unhandledErrorLogLevel, none2());
  self.state.backing.add(fiber);
  fiber.addObserver((exit3) => {
    if (self.state._tag === "Closed") {
      return;
    }
    self.state.backing.delete(fiber);
    if (isFailure2(exit3) && !isInterruptedOnly2(exit3.cause)) {
      unsafeDone(self.deferred, exit3);
    }
  });
});
var add6 = dual(2, (self, fiber) => fiberIdWith2((fiberId5) => sync7(() => unsafeAdd(self, fiber, {
  interruptAs: fiberId5
}))));
var clear6 = (self) => suspend3(() => {
  if (self.state._tag === "Closed") {
    return _void;
  }
  return forEach12(self.state.backing, (fiber) => (
    // will be removed by the observer
    interrupt6(fiber)
  ));
});
var run9 = function() {
  const self = arguments[0];
  if (arguments.length === 1) {
    return (effect5) => suspend3(() => {
      if (self.state._tag === "Closed") {
        return interrupt7;
      }
      return uninterruptibleMask2((restore) => tap3(restore(forkDaemon2(effect5)), (fiber) => add6(self, fiber)));
    });
  }
  const effect4 = arguments[1];
  return suspend3(() => {
    if (self.state._tag === "Closed") {
      return interrupt7;
    }
    return uninterruptibleMask2((restore) => tap3(restore(forkDaemon2(effect4)), (fiber) => add6(self, fiber)));
  });
};
var runtime7 = (self) => () => map22(runtime4(), (runtime8) => {
  const runFork3 = runFork2(runtime8);
  return (effect4, options) => {
    const fiber = runFork3(effect4, options);
    unsafeAdd(self, fiber);
    return fiber;
  };
});
var size20 = (self) => sync7(() => self.state._tag === "Closed" ? 0 : self.state.backing.size);
var join7 = (self) => _await(self.deferred);

// ../node_modules/effect/dist/esm/GroupBy.js
var GroupBy_exports = {};
__export(GroupBy_exports, {
  GroupByTypeId: () => GroupByTypeId2,
  evaluate: () => evaluate2,
  filter: () => filter15,
  first: () => first4,
  make: () => make72
});

// ../node_modules/effect/dist/esm/internal/groupBy.js
var GroupBySymbolKey = "effect/GroupBy";
var GroupByTypeId = Symbol.for(GroupBySymbolKey);
var groupByVariance = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _K: (_) => _,
  /* c8 ignore next */
  _V: (_) => _
};
var isGroupBy = (u) => hasProperty(u, GroupByTypeId);
var evaluate = dual((args) => isGroupBy(args[0]), (self, f, options) => flatMap19(self.grouped, ([key, queue]) => f(key, flattenTake(fromQueue3(queue, {
  shutdown: true
}))), {
  concurrency: "unbounded",
  bufferSize: (options == null ? void 0 : options.bufferSize) ?? 16
}));
var filter14 = dual(2, (self, predicate) => make71(pipe(self.grouped, filterEffect((tuple4) => {
  if (predicate(tuple4[0])) {
    return pipe(succeed12(tuple4), as6(true));
  }
  return pipe(shutdown4(tuple4[1]), as6(false));
}))));
var first3 = dual(2, (self, n) => make71(pipe(zipWithIndex(self.grouped), filterEffect((tuple4) => {
  const index = tuple4[1];
  const queue = tuple4[0][1];
  if (index < n) {
    return pipe(succeed12(tuple4), as6(true));
  }
  return pipe(shutdown4(queue), as6(false));
}), map28((tuple4) => tuple4[0]))));
var make71 = (grouped3) => ({
  [GroupByTypeId]: groupByVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  grouped: grouped3
});
var groupBy = dual((args) => isStream(args[0]), (self, f, options) => make71(unwrapScoped5(gen2(function* ($) {
  const decider = yield* $(make23());
  const output = yield* $(acquireRelease2(bounded5((options == null ? void 0 : options.bufferSize) ?? 16), (queue) => shutdown4(queue)));
  const ref = yield* $(make36(/* @__PURE__ */ new Map()));
  const add11 = yield* $(mapEffectSequential(self, f), distributedWithDynamicCallback((options == null ? void 0 : options.bufferSize) ?? 16, ([key, value8]) => flatMap15(_await(decider), (f2) => f2(key, value8)), (exit3) => offer3(output, exit3)));
  yield* $(succeed2(decider, (key, _) => pipe(get11(ref), map22((map43) => fromNullable(map43.get(key))), flatMap15(match2({
    onNone: () => flatMap15(add11, ([index, queue]) => zipRight6(update4(ref, (map43) => map43.set(key, index)), pipe(offer3(output, succeed3([key, mapDequeue(queue, (exit3) => new TakeImpl(pipe(exit3, map12((tuple4) => of2(tuple4[1])))))])), as6((n) => n === index)))),
    onSome: (index) => succeed12((n) => n === index)
  })))));
  return flattenExitOption(fromQueue3(output, {
    shutdown: true
  }));
}))));
var mapEffectOptions = dual((args) => typeof args[0] !== "function", (self, f, options) => {
  if (options == null ? void 0 : options.key) {
    return evaluate(groupByKey(self, options.key, {
      bufferSize: options.bufferSize
    }), (_, s) => mapEffectSequential(s, f));
  }
  return matchConcurrency(options == null ? void 0 : options.concurrency, () => mapEffectSequential(self, f), (n) => (options == null ? void 0 : options.unordered) ? flatMap19(self, (a) => fromEffect9(f(a)), {
    concurrency: n
  }) : mapEffectPar(self, n, f));
});
var bindEffect = dual((args) => typeof args[0] !== "string", (self, tag4, f, options) => mapEffectOptions(self, (k) => map22(f(k), (a) => ({
  ...k,
  [tag4]: a
})), options));
var mapDequeue = (dequeue, f) => new MapDequeue(dequeue, f);
var _a61;
var MapDequeue = class {
  constructor(dequeue, f) {
    __publicField(this, "dequeue");
    __publicField(this, "f");
    __publicField(this, _a61, {
      _Out: (_) => _
    });
    this.dequeue = dequeue;
    this.f = f;
  }
  capacity() {
    return capacity5(this.dequeue);
  }
  get size() {
    return size18(this.dequeue);
  }
  unsafeSize() {
    return this.dequeue.unsafeSize();
  }
  get awaitShutdown() {
    return awaitShutdown4(this.dequeue);
  }
  isActive() {
    return this.dequeue.isActive();
  }
  get isShutdown() {
    return isShutdown4(this.dequeue);
  }
  get shutdown() {
    return shutdown4(this.dequeue);
  }
  get isFull() {
    return isFull5(this.dequeue);
  }
  get isEmpty() {
    return isEmpty15(this.dequeue);
  }
  get take() {
    return pipe(take4(this.dequeue), map22((a) => this.f(a)));
  }
  get takeAll() {
    return pipe(takeAll2(this.dequeue), map22(map4((a) => this.f(a))));
  }
  takeUpTo(max9) {
    return pipe(takeUpTo2(this.dequeue, max9), map22(map4((a) => this.f(a))));
  }
  takeBetween(min7, max9) {
    return pipe(takeBetween2(this.dequeue, min7, max9), map22(map4((a) => this.f(a))));
  }
  takeN(n) {
    return pipe(takeN2(this.dequeue, n), map22(map4((a) => this.f(a))));
  }
  poll() {
    return pipe(poll6(this.dequeue), map22(map2((a) => this.f(a))));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
_a61 = DequeueTypeId2;
var groupByKey = dual((args) => typeof args[0] !== "function", (self, f, options) => {
  const loop5 = (map43, outerQueue) => readWithCause({
    onInput: (input) => flatMap17(fromEffect5(forEach12(groupByIterable(input, f), ([key, values13]) => {
      const innerQueue = map43.get(key);
      if (innerQueue === void 0) {
        return pipe(bounded5((options == null ? void 0 : options.bufferSize) ?? 16), flatMap15((innerQueue2) => pipe(sync7(() => {
          map43.set(key, innerQueue2);
        }), zipRight6(offer3(outerQueue, of6([key, innerQueue2]))), zipRight6(pipe(offer3(innerQueue2, chunk3(values13)), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2()))))));
      }
      return catchSomeCause2(offer3(innerQueue, chunk3(values13)), (cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2());
    }, {
      discard: true
    })), () => loop5(map43, outerQueue)),
    onFailure: (cause3) => fromEffect5(offer3(outerQueue, failCause13(cause3))),
    onDone: () => pipe(fromEffect5(pipe(forEach12(map43.entries(), ([_, innerQueue]) => pipe(offer3(innerQueue, end4), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2())), {
      discard: true
    }), zipRight6(offer3(outerQueue, end4)))))
  });
  return make71(unwrapScoped5(pipe(sync7(() => /* @__PURE__ */ new Map()), flatMap15((map43) => pipe(acquireRelease2(unbounded5(), (queue) => shutdown4(queue)), flatMap15((queue) => pipe(self, toChannel2, pipeTo(loop5(map43, queue)), drain, runScoped, forkScoped2, as6(flattenTake(fromQueue3(queue, {
    shutdown: true
  }))))))))));
});
var groupByIterable = dual(2, (iterable, f) => {
  const builder = [];
  const iterator = iterable[Symbol.iterator]();
  const map43 = /* @__PURE__ */ new Map();
  let next6;
  while ((next6 = iterator.next()) && !next6.done) {
    const value8 = next6.value;
    const key = f(value8);
    if (map43.has(key)) {
      const innerBuilder = map43.get(key);
      innerBuilder.push(value8);
    } else {
      const innerBuilder = [value8];
      builder.push([key, innerBuilder]);
      map43.set(key, innerBuilder);
    }
  }
  return unsafeFromArray(builder.map((tuple4) => [tuple4[0], unsafeFromArray(tuple4[1])]));
});

// ../node_modules/effect/dist/esm/GroupBy.js
var GroupByTypeId2 = GroupByTypeId;
var evaluate2 = evaluate;
var filter15 = filter14;
var first4 = first3;
var make72 = make71;

// ../node_modules/effect/dist/esm/HKT.js
var HKT_exports = {};

// ../node_modules/effect/dist/esm/KeyedPool.js
var KeyedPool_exports = {};
__export(KeyedPool_exports, {
  KeyedPoolTypeId: () => KeyedPoolTypeId2,
  get: () => get17,
  invalidate: () => invalidate3,
  make: () => make75,
  makeWith: () => makeWith6,
  makeWithTTL: () => makeWithTTL3,
  makeWithTTLBy: () => makeWithTTLBy2
});

// ../node_modules/effect/dist/esm/internal/pool.js
var PoolSymbolKey = "effect/Pool";
var PoolTypeId = Symbol.for(PoolSymbolKey);
var poolVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var NoneStrategy = class {
  initial() {
    return void_;
  }
  track() {
    return void_;
  }
  run() {
    return void_;
  }
};
var TimeToLiveStrategy = class {
  constructor(timeToLive) {
    __publicField(this, "timeToLive");
    this.timeToLive = timeToLive;
  }
  initial() {
    return flatMap10(clock, (clock3) => flatMap10(clock3.currentTimeMillis, (now) => map11(make35(now), (ref) => [clock3, ref])));
  }
  track(state) {
    return asVoid(flatMap10(state[0].currentTimeMillis, (now) => set5(state[1], now)));
  }
  run(state, getExcess, shrink2) {
    return flatMap10(getExcess, (excess2) => excess2 <= 0 ? zipRight(state[0].sleep(this.timeToLive), this.run(state, getExcess, shrink2)) : pipe(zipWith3(get10(state[1]), state[0].currentTimeMillis, (start5, end7) => end7 - start5), flatMap10((duration5) => {
      if (duration5 >= toMillis(this.timeToLive)) {
        return zipRight(shrink2, this.run(state, getExcess, shrink2));
      } else {
        return zipRight(state[0].sleep(this.timeToLive), this.run(state, getExcess, shrink2));
      }
    })));
  }
};
var _a62;
var PoolImpl = class {
  constructor(creator, min7, max9, isShuttingDown, state, items, invalidated, track3) {
    __publicField(this, "creator");
    __publicField(this, "min");
    __publicField(this, "max");
    __publicField(this, "isShuttingDown");
    __publicField(this, "state");
    __publicField(this, "items");
    __publicField(this, "invalidated");
    __publicField(this, "track");
    __publicField(this, _a62, poolVariance);
    this.creator = creator;
    this.min = min7;
    this.max = max9;
    this.isShuttingDown = isShuttingDown;
    this.state = state;
    this.items = items;
    this.invalidated = invalidated;
    this.track = track3;
  }
  [(_a62 = PoolTypeId, symbol2)]() {
    return pipe(hash(this.creator), combine(number2(this.min)), combine(number2(this.max)), combine(hash(this.isShuttingDown)), combine(hash(this.state)), combine(hash(this.items)), combine(hash(this.invalidated)), combine(hash(this.track)), cached(this));
  }
  [symbol3](that) {
    return isPool(that) && equals(this.creator, that.creator) && this.min === that.min && this.max === that.max && equals(this.isShuttingDown, that.isShuttingDown) && equals(this.state, that.state) && equals(this.items, that.items) && equals(this.invalidated, that.invalidated) && equals(this.track, that.track);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  get get() {
    const acquire3 = (restore) => flatMap10(get10(this.isShuttingDown), (down) => down ? interrupt2 : flatten5(modify5(this.state, (state) => {
      if (state.free > 0 || state.size >= this.max) {
        return [flatMap10(take3(this.items), (attempted) => exitMatch(attempted.result, {
          onFailure: () => succeed(attempted),
          onSuccess: (item) => flatMap10(get10(this.invalidated), (set22) => {
            if (pipe(set22, has3(item))) {
              return zipRight(finalizeInvalid(this, attempted), acquire3(restore));
            }
            return succeed(attempted);
          })
        })), {
          ...state,
          free: state.free - 1
        }];
      }
      if (state.size >= 0) {
        return [zipRight(allocate2(this, restore), acquire3(restore)), {
          size: state.size + 1,
          free: state.free + 1
        }];
      }
      return [interrupt2, state];
    })));
    const release3 = (attempted) => exitMatch(attempted.result, {
      onFailure: () => flatten5(modify5(this.state, (state) => {
        if (state.size <= this.min) {
          return [allocateUinterruptible(this), {
            ...state,
            free: state.free + 1
          }];
        }
        return [void_, {
          ...state,
          size: state.size - 1
        }];
      })),
      onSuccess: (item) => flatMap10(get10(this.invalidated), (set22) => {
        if (pipe(set22, has3(item))) {
          return finalizeInvalid(this, attempted);
        }
        return pipe(update3(this.state, (state) => ({
          ...state,
          free: state.free + 1
        })), zipRight(offer2(this.items, attempted)), zipRight(this.track(attempted.result)), zipRight(whenEffect(getAndShutdown(this), get10(this.isShuttingDown))));
      })
    });
    return pipe(uninterruptibleMask((restore) => tap(acquire3(restore), (a) => addFinalizer((_exit) => release3(a)))), withEarlyRelease, disconnect, flatMap10(([release4, attempted]) => pipe(when(release4, () => isFailure7(attempted)), zipRight(toEffect(attempted)))));
  }
  invalidate(item) {
    return update3(this.invalidated, add4(item));
  }
};
var allocate2 = (self, restore) => flatMap10(scopeMake(), (scope5) => flatMap10(exit(restore(scopeExtend(self.creator, scope5))), (exit3) => flatMap10(succeed({
  result: exit3,
  finalizer: scopeClose(scope5, exitSucceed(void 0))
}), (attempted) => pipe(offer2(self.items, attempted), zipRight(self.track(attempted.result)), zipRight(whenEffect(getAndShutdown(self), get10(self.isShuttingDown))), as2(attempted)))));
var allocateUinterruptible = (self) => uninterruptibleMask((restore) => allocate2(self, restore));
var excess = (self) => map11(get10(self.state), (state) => state.size - Math.min(self.min, state.free));
var finalizeInvalid = (self, attempted) => pipe(forEach14(attempted, (a) => update3(self.invalidated, remove5(a))), zipRight(attempted.finalizer), zipRight(flatten5(modify5(self.state, (state) => {
  if (state.size <= self.min) {
    return [allocateUinterruptible(self), {
      ...state,
      free: state.free + 1
    }];
  }
  return [void_, {
    ...state,
    size: state.size - 1
  }];
}))));
var getAndShutdown = (self) => flatten5(modify5(self.state, (state) => {
  if (state.free > 0) {
    return [matchCauseEffect(take3(self.items), {
      onFailure: () => void_,
      onSuccess: (attempted) => pipe(forEach14(attempted, (a) => update3(self.invalidated, remove5(a))), zipRight(attempted.finalizer), zipRight(update3(self.state, (state2) => ({
        ...state2,
        size: state2.size - 1
      }))), flatMap10(() => getAndShutdown(self)))
    }), {
      ...state,
      free: state.free - 1
    }];
  }
  if (state.size > 0) {
    return [void_, state];
  }
  return [shutdown(self.items), {
    ...state,
    size: state.size - 1
  }];
}));
var initialize = (self) => replicateEffect(uninterruptibleMask((restore) => flatten5(modify5(self.state, (state) => {
  if (state.size < self.min && state.size >= 0) {
    return [allocate2(self, restore), {
      size: state.size + 1,
      free: state.free + 1
    }];
  }
  return [void_, state];
}))), self.min, {
  discard: true
});
var shrink = (self) => uninterruptible(flatten5(modify5(self.state, (state) => {
  if (state.size > self.min && state.free > 0) {
    return [pipe(take3(self.items), flatMap10((attempted) => pipe(forEach14(attempted, (a) => update3(self.invalidated, remove5(a))), zipRight(attempted.finalizer), zipRight(update3(self.state, (state2) => ({
      ...state2,
      size: state2.size - 1
    })))))), {
      ...state,
      free: state.free - 1
    }];
  }
  return [void_, state];
})));
var shutdown5 = (self) => flatten5(modify5(self.isShuttingDown, (down) => down ? [awaitShutdown(self.items), true] : [zipRight(getAndShutdown(self), awaitShutdown(self.items)), true]));
var isFailure7 = (self) => exitIsFailure(self.result);
var forEach14 = (self, f) => exitMatch(self.result, {
  onFailure: () => void_,
  onSuccess: f
});
var toEffect = (self) => self.result;
var makeWith4 = (options) => uninterruptibleMask((restore) => pipe(all5([context(), make35(false), make35({
  size: 0,
  free: 0
}), bounded2(options.max), make35(empty8()), options.strategy.initial()]), flatMap10(([context13, down, state, items, inv, initial]) => {
  const pool = new PoolImpl(mapInputContext(options.acquire, (old) => merge3(old)(context13)), options.min, options.max, down, state, items, inv, (exit3) => options.strategy.track(initial, exit3));
  return pipe(forkDaemon(restore(initialize(pool))), flatMap10((fiber) => flatMap10(forkDaemon(restore(options.strategy.run(initial, excess(pool), shrink(pool)))), (shrink2) => addFinalizer(() => pipe(shutdown5(pool), zipRight(interruptFiber(fiber)), zipRight(interruptFiber(shrink2)))))), as2(pool));
})));
var isPool = (u) => hasProperty(u, PoolTypeId);
var make73 = (options) => makeWith4({
  acquire: options.acquire,
  min: options.size,
  max: options.size,
  strategy: new NoneStrategy()
});
var makeWithTTL = (options) => makeWith4({
  acquire: options.acquire,
  min: options.min,
  max: options.max,
  strategy: new TimeToLiveStrategy(decode(options.timeToLive))
});
var get15 = (self) => self.get;
var invalidate = dual(2, (self, value8) => self.invalidate(value8));

// ../node_modules/effect/dist/esm/internal/keyedPool.js
var KeyedPoolSymbolKey = "effect/KeyedPool";
var KeyedPoolTypeId = Symbol.for(KeyedPoolSymbolKey);
var KeyedPoolMapValueSymbol = Symbol.for("effect/KeyedPool/MapValue");
var keyedPoolVariance = {
  /* c8 ignore next */
  _K: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var _a63;
var KeyedPoolImpl = class {
  constructor(getOrCreatePool, activePools) {
    __publicField(this, "getOrCreatePool");
    __publicField(this, "activePools");
    __publicField(this, _a63, keyedPoolVariance);
    this.getOrCreatePool = getOrCreatePool;
    this.activePools = activePools;
  }
  get(key) {
    return flatMap10(this.getOrCreatePool(key), get15);
  }
  invalidate(item) {
    return flatMap10(this.activePools, forEachSequentialDiscard((pool) => pool.invalidate(item)));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
_a63 = KeyedPoolTypeId;
var _a64;
var Complete = class {
  constructor(pool) {
    __publicField(this, "pool");
    __publicField(this, "_tag", "Complete");
    __publicField(this, _a64, KeyedPoolMapValueSymbol);
    this.pool = pool;
  }
  [(_a64 = KeyedPoolMapValueSymbol, symbol2)]() {
    return pipe(string("effect/KeyedPool/Complete"), combine(hash(this.pool)), cached(this));
  }
  [symbol3](u) {
    return isComplete(u) && equals(this.pool, u.pool);
  }
};
var isComplete = (u) => isTagged(u, "Complete") && KeyedPoolMapValueSymbol in u;
var _a65;
var Pending = class {
  constructor(deferred) {
    __publicField(this, "deferred");
    __publicField(this, "_tag", "Pending");
    __publicField(this, _a65, KeyedPoolMapValueSymbol);
    this.deferred = deferred;
  }
  [(_a65 = KeyedPoolMapValueSymbol, symbol2)]() {
    return pipe(string("effect/KeyedPool/Pending"), combine(hash(this.deferred)), cached(this));
  }
  [symbol3](u) {
    return isPending(u) && equals(this.deferred, u.deferred);
  }
};
var isPending = (u) => isTagged(u, "Pending") && KeyedPoolMapValueSymbol in u;
var makeImpl4 = (get40, min7, max9, timeToLive) => pipe(all5([context(), fiberId, sync(() => make13(empty9())), scopeMake()]), map11(([context13, fiberId5, map43, scope5]) => {
  const getOrCreatePool = (key) => suspend(() => {
    let value8 = getOrUndefined(get6(get5(map43), key));
    if (value8 === void 0) {
      return uninterruptibleMask((restore) => {
        const deferred = deferredUnsafeMake(fiberId5);
        value8 = new Pending(deferred);
        let previous2 = void 0;
        if (has4(get5(map43), key)) {
          previous2 = getOrUndefined(get6(get5(map43), key));
        } else {
          update(map43, set3(key, value8));
        }
        if (previous2 === void 0) {
          return pipe(restore(scopeExtend(makeWithTTL({
            acquire: provideContext(get40(key), context13),
            min: min7(key),
            max: max9(key),
            timeToLive: getOrElse(timeToLive(key), () => infinity)
          }), scope5)), matchCauseEffect({
            onFailure: (cause3) => {
              const current2 = getOrUndefined(get6(get5(map43), key));
              if (equals(current2, value8)) {
                update(map43, remove6(key));
              }
              return zipRight(deferredFailCause(deferred, cause3), failCause(cause3));
            },
            onSuccess: (pool) => {
              update(map43, set3(key, new Complete(pool)));
              return as2(deferredSucceed(deferred, pool), pool);
            }
          }));
        }
        switch (previous2._tag) {
          case "Complete": {
            return succeed(previous2.pool);
          }
          case "Pending": {
            return restore(deferredAwait(previous2.deferred));
          }
        }
      });
    }
    switch (value8._tag) {
      case "Complete": {
        return succeed(value8.pool);
      }
      case "Pending": {
        return deferredAwait(value8.deferred);
      }
    }
  });
  const activePools = suspend(() => forEachSequential(Array.from(values4(get5(map43))), (value8) => {
    switch (value8._tag) {
      case "Complete": {
        return succeed(value8.pool);
      }
      case "Pending": {
        return deferredAwait(value8.deferred);
      }
    }
  }));
  return new KeyedPoolImpl(getOrCreatePool, activePools);
}));
var make74 = (options) => makeImpl4(options.acquire, () => options.size, () => options.size, () => none2());
var makeWith5 = (options) => makeImpl4(options.acquire, options.size, options.size, () => none2());
var makeWithTTL2 = (options) => {
  const timeToLive = decode(options.timeToLive);
  return makeImpl4(options.acquire, options.min, options.max, () => some2(timeToLive));
};
var makeWithTTLBy = (options) => makeImpl4(options.acquire, options.min, options.max, (key) => some2(decode(options.timeToLive(key))));
var get16 = dual(2, (self, key) => self.get(key));
var invalidate2 = dual(2, (self, item) => self.invalidate(item));

// ../node_modules/effect/dist/esm/KeyedPool.js
var KeyedPoolTypeId2 = KeyedPoolTypeId;
var make75 = make74;
var makeWith6 = makeWith5;
var makeWithTTL3 = makeWithTTL2;
var makeWithTTLBy2 = makeWithTTLBy;
var get17 = get16;
var invalidate3 = invalidate2;

// ../node_modules/effect/dist/esm/Logger.js
var Logger_exports = {};
__export(Logger_exports, {
  LoggerTypeId: () => LoggerTypeId2,
  add: () => add7,
  addEffect: () => addEffect,
  addScoped: () => addScoped,
  batched: () => batched,
  defaultLogger: () => defaultLogger2,
  filterLogLevel: () => filterLogLevel2,
  isLogger: () => isLogger2,
  json: () => json,
  jsonLogger: () => jsonLogger3,
  logFmt: () => logFmt,
  logfmtLogger: () => logfmtLogger2,
  make: () => make76,
  map: () => map32,
  mapInput: () => mapInput10,
  mapInputOptions: () => mapInputOptions2,
  minimumLogLevel: () => minimumLogLevel2,
  none: () => none10,
  remove: () => remove11,
  replace: () => replace3,
  replaceEffect: () => replaceEffect,
  replaceScoped: () => replaceScoped,
  simple: () => simple2,
  stringLogger: () => stringLogger2,
  structured: () => structured,
  structuredLogger: () => structuredLogger3,
  succeed: () => succeed21,
  sync: () => sync16,
  test: () => test2,
  tracerLogger: () => tracerLogger2,
  withConsoleError: () => withConsoleError,
  withConsoleLog: () => withConsoleLog,
  withMinimumLogLevel: () => withMinimumLogLevel2,
  withSpanAnnotations: () => withSpanAnnotations,
  zip: () => zip17,
  zipLeft: () => zipLeft12,
  zipRight: () => zipRight12
});

// ../node_modules/effect/dist/esm/internal/logger-circular.js
var test = dual(2, (self, input) => self.log({
  fiberId: none3,
  logLevel: logLevelInfo,
  message: input,
  cause: empty33,
  context: empty24(),
  spans: empty10(),
  annotations: empty9(),
  date: /* @__PURE__ */ new Date()
}));

// ../node_modules/effect/dist/esm/Logger.js
var LoggerTypeId2 = LoggerTypeId;
var make76 = makeLogger;
var add7 = addLogger;
var addEffect = addLoggerEffect;
var addScoped = addLoggerScoped;
var mapInput10 = mapInput3;
var mapInputOptions2 = mapInputOptions;
var filterLogLevel2 = filterLogLevel;
var map32 = map15;
var batched = batchedLogger;
var withConsoleLog = loggerWithConsoleLog;
var withConsoleError = loggerWithConsoleError;
var none10 = none7;
var remove11 = removeLogger;
var replace3 = replaceLogger;
var replaceEffect = replaceLoggerEffect;
var replaceScoped = replaceLoggerScoped;
var simple2 = simple;
var succeed21 = succeed5;
var sync16 = sync3;
var test2 = test;
var withMinimumLogLevel2 = withMinimumLogLevel;
var withSpanAnnotations = loggerWithSpanAnnotations;
var zip17 = zip6;
var zipLeft12 = zipLeft3;
var zipRight12 = zipRight3;
var defaultLogger2 = defaultLogger;
var jsonLogger3 = jsonLogger;
var logfmtLogger2 = logfmtLogger;
var stringLogger2 = stringLogger;
var structuredLogger3 = structuredLogger;
var tracerLogger2 = tracerLogger;
var json = replace3(defaultLogger, jsonLogger2);
var logFmt = replace3(defaultLogger, logFmtLogger);
var structured = replace3(defaultLogger, structuredLogger2);
var minimumLogLevel2 = minimumLogLevel;
var isLogger2 = isLogger;

// ../node_modules/effect/dist/esm/ManagedRuntime.js
var ManagedRuntime_exports = {};
__export(ManagedRuntime_exports, {
  make: () => make78
});

// ../node_modules/effect/dist/esm/internal/managedRuntime.js
function provide4(managed, effect4) {
  return flatMap10(managed.runtimeEffect, (rt) => withFiberRuntime((fiber) => {
    fiber.setFiberRefs(rt.fiberRefs);
    fiber._runtimeFlags = rt.runtimeFlags;
    return provideContext(effect4, rt.context);
  }));
}
var make77 = (layer, memoMap) => {
  memoMap = memoMap ?? unsafeMakeMemoMap();
  const scope5 = unsafeRunSyncEffect(scopeMake());
  const self = {
    memoMap,
    scope: scope5,
    runtimeEffect: unsafeRunSyncEffect(memoize(tap(extend2(toRuntimeWithMemoMap(layer, memoMap), scope5), (rt) => {
      self.cachedRuntime = rt;
    }))),
    cachedRuntime: void 0,
    pipe() {
      return pipeArguments(this, arguments);
    },
    runtime() {
      return self.cachedRuntime === void 0 ? unsafeRunPromiseEffect(self.runtimeEffect) : Promise.resolve(self.cachedRuntime);
    },
    dispose() {
      return unsafeRunPromiseEffect(self.disposeEffect);
    },
    disposeEffect: suspend(() => {
      ;
      self.runtime = die2("ManagedRuntime disposed");
      self.cachedRuntime = void 0;
      return close(self.scope, exitVoid);
    }),
    runFork(effect4, options) {
      return self.cachedRuntime === void 0 ? unsafeForkEffect(provide4(self, effect4), options) : unsafeFork2(self.cachedRuntime)(effect4, options);
    },
    runSyncExit(effect4) {
      return self.cachedRuntime === void 0 ? unsafeRunSyncExitEffect(provide4(self, effect4)) : unsafeRunSyncExit(self.cachedRuntime)(effect4);
    },
    runSync(effect4) {
      return self.cachedRuntime === void 0 ? unsafeRunSyncEffect(provide4(self, effect4)) : unsafeRunSync(self.cachedRuntime)(effect4);
    },
    runPromiseExit(effect4, options) {
      return self.cachedRuntime === void 0 ? unsafeRunPromiseExitEffect(provide4(self, effect4), options) : unsafeRunPromiseExit(self.cachedRuntime)(effect4, options);
    },
    runCallback(effect4, options) {
      return self.cachedRuntime === void 0 ? unsafeRunCallback(defaultRuntime)(provide4(self, effect4), options) : unsafeRunCallback(self.cachedRuntime)(effect4, options);
    },
    runPromise(effect4, options) {
      return self.cachedRuntime === void 0 ? unsafeRunPromiseEffect(provide4(self, effect4), options) : unsafeRunPromise(self.cachedRuntime)(effect4, options);
    }
  };
  return self;
};

// ../node_modules/effect/dist/esm/ManagedRuntime.js
var make78 = make77;

// ../node_modules/effect/dist/esm/Match.js
var Match_exports = {};
__export(Match_exports, {
  MatcherTypeId: () => MatcherTypeId,
  SafeRefinementId: () => SafeRefinementId,
  any: () => any2,
  bigint: () => bigint3,
  boolean: () => boolean5,
  date: () => date3,
  defined: () => defined2,
  discriminator: () => discriminator2,
  discriminatorStartsWith: () => discriminatorStartsWith2,
  discriminators: () => discriminators2,
  discriminatorsExhaustive: () => discriminatorsExhaustive2,
  either: () => either9,
  exhaustive: () => exhaustive2,
  instanceOf: () => instanceOf2,
  instanceOfUnsafe: () => instanceOfUnsafe,
  is: () => is2,
  nonEmptyString: () => nonEmptyString2,
  not: () => not3,
  null: () => _null,
  number: () => number6,
  option: () => option6,
  orElse: () => orElse17,
  orElseAbsurd: () => orElseAbsurd2,
  record: () => record,
  string: () => string4,
  symbol: () => symbol4,
  tag: () => tag2,
  tagStartsWith: () => tagStartsWith2,
  tags: () => tags2,
  tagsExhaustive: () => tagsExhaustive2,
  type: () => type2,
  typeTags: () => typeTags2,
  undefined: () => _undefined,
  value: () => value4,
  valueTags: () => valueTags2,
  when: () => when5,
  whenAnd: () => whenAnd2,
  whenOr: () => whenOr2
});

// ../node_modules/effect/dist/esm/internal/matcher.js
var TypeId19 = Symbol.for("@effect/matcher/Matcher");
var TypeMatcherProto = {
  [TypeId19]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity
  },
  _tag: "TypeMatcher",
  add(_case2) {
    return makeTypeMatcher([...this.cases, _case2]);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeTypeMatcher(cases) {
  const matcher = Object.create(TypeMatcherProto);
  matcher.cases = cases;
  return matcher;
}
var ValueMatcherProto = {
  [TypeId19]: {
    _input: identity,
    _filters: identity,
    _result: identity
  },
  _tag: "ValueMatcher",
  add(_case2) {
    if (this.value._tag === "Right") {
      return this;
    }
    if (_case2._tag === "When" && _case2.guard(this.provided) === true) {
      return makeValueMatcher(this.provided, right(_case2.evaluate(this.provided)));
    } else if (_case2._tag === "Not" && _case2.guard(this.provided) === false) {
      return makeValueMatcher(this.provided, right(_case2.evaluate(this.provided)));
    }
    return this;
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeValueMatcher(provided, value8) {
  const matcher = Object.create(ValueMatcherProto);
  matcher.provided = provided;
  matcher.value = value8;
  return matcher;
}
var makeWhen = (guard, evaluate3) => ({
  _tag: "When",
  guard,
  evaluate: evaluate3
});
var makeNot = (guard, evaluate3) => ({
  _tag: "Not",
  guard,
  evaluate: evaluate3
});
var makePredicate = (pattern) => {
  if (typeof pattern === "function") {
    return pattern;
  } else if (Array.isArray(pattern)) {
    const predicates = pattern.map(makePredicate);
    const len = predicates.length;
    return (u) => {
      if (!Array.isArray(u)) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        if (predicates[i](u[i]) === false) {
          return false;
        }
      }
      return true;
    };
  } else if (pattern !== null && typeof pattern === "object") {
    const keysAndPredicates = Object.entries(pattern).map(([k, p]) => [k, makePredicate(p)]);
    const len = keysAndPredicates.length;
    return (u) => {
      if (typeof u !== "object" || u === null) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        const [key, predicate] = keysAndPredicates[i];
        if (!(key in u) || predicate(u[key]) === false) {
          return false;
        }
      }
      return true;
    };
  }
  return (u) => u === pattern;
};
var makeOrPredicate = (patterns) => {
  const predicates = patterns.map(makePredicate);
  const len = predicates.length;
  return (u) => {
    for (let i = 0; i < len; i++) {
      if (predicates[i](u) === true) {
        return true;
      }
    }
    return false;
  };
};
var makeAndPredicate = (patterns) => {
  const predicates = patterns.map(makePredicate);
  const len = predicates.length;
  return (u) => {
    for (let i = 0; i < len; i++) {
      if (predicates[i](u) === false) {
        return false;
      }
    }
    return true;
  };
};
var type = () => makeTypeMatcher([]);
var value3 = (i) => makeValueMatcher(i, left(i));
var valueTags = (fields) => {
  const match38 = tagsExhaustive(fields)(makeTypeMatcher([]));
  return (input) => match38(input);
};
var typeTags = () => (fields) => {
  const match38 = tagsExhaustive(fields)(makeTypeMatcher([]));
  return (input) => match38(input);
};
var when4 = (pattern, f) => (self) => self.add(makeWhen(makePredicate(pattern), f));
var whenOr = (...args) => (self) => {
  const onMatch = args[args.length - 1];
  const patterns = args.slice(0, -1);
  return self.add(makeWhen(makeOrPredicate(patterns), onMatch));
};
var whenAnd = (...args) => (self) => {
  const onMatch = args[args.length - 1];
  const patterns = args.slice(0, -1);
  return self.add(makeWhen(makeAndPredicate(patterns), onMatch));
};
var discriminator = (field) => (...pattern) => {
  const f = pattern[pattern.length - 1];
  const values13 = pattern.slice(0, -1);
  const pred = values13.length === 1 ? (_) => _[field] === values13[0] : (_) => values13.includes(_[field]);
  return (self) => self.add(makeWhen(pred, f));
};
var discriminatorStartsWith = (field) => (pattern, f) => {
  const pred = (_) => typeof _[field] === "string" && _[field].startsWith(pattern);
  return (self) => self.add(makeWhen(pred, f));
};
var discriminators = (field) => (fields) => {
  const predicate = makeWhen((_) => _[field] in fields, (data) => fields[data[field]](data));
  return (self) => self.add(predicate);
};
var discriminatorsExhaustive = (field) => (fields) => {
  const addCases = discriminators(field)(fields);
  return (matcher) => exhaustive(addCases(matcher));
};
var tag = discriminator("_tag");
var tagStartsWith = discriminatorStartsWith("_tag");
var tags = discriminators("_tag");
var tagsExhaustive = discriminatorsExhaustive("_tag");
var not2 = (pattern, f) => (self) => self.add(makeNot(makePredicate(pattern), f));
var nonEmptyString = (u) => typeof u === "string" && u.length > 0;
var is = (...literals) => {
  const len = literals.length;
  return (u) => {
    for (let i = 0; i < len; i++) {
      if (u === literals[i]) {
        return true;
      }
    }
    return false;
  };
};
var any = () => true;
var defined = (u) => u !== void 0 && u !== null;
var instanceOf = (constructor) => (u) => u instanceof constructor;
var orElse16 = (f) => (self) => {
  const result = either8(self);
  if (isEither(result)) {
    return result._tag === "Right" ? result.right : f(result.left);
  }
  return (input) => {
    const a = result(input);
    return a._tag === "Right" ? a.right : f(a.left);
  };
};
var orElseAbsurd = (self) => orElse16(() => {
  throw new Error("effect/Match/orElseAbsurd: absurd");
})(self);
var either8 = (self) => {
  if (self._tag === "ValueMatcher") {
    return self.value;
  }
  const len = self.cases.length;
  if (len === 1) {
    const _case2 = self.cases[0];
    return (input) => {
      if (_case2._tag === "When" && _case2.guard(input) === true) {
        return right(_case2.evaluate(input));
      } else if (_case2._tag === "Not" && _case2.guard(input) === false) {
        return right(_case2.evaluate(input));
      }
      return left(input);
    };
  }
  return (input) => {
    for (let i = 0; i < len; i++) {
      const _case2 = self.cases[i];
      if (_case2._tag === "When" && _case2.guard(input) === true) {
        return right(_case2.evaluate(input));
      } else if (_case2._tag === "Not" && _case2.guard(input) === false) {
        return right(_case2.evaluate(input));
      }
    }
    return left(input);
  };
};
var option5 = (self) => {
  const toEither = either8(self);
  if (isEither(toEither)) {
    return match(toEither, {
      onLeft: () => none2(),
      onRight: some2
    });
  }
  return (input) => match(toEither(input), {
    onLeft: () => none2(),
    onRight: some2
  });
};
var getExhaustiveAbsurdErrorMessage = "effect/Match/exhaustive: absurd";
var exhaustive = (self) => {
  const toEither = either8(self);
  if (isEither(toEither)) {
    if (toEither._tag === "Right") {
      return toEither.right;
    }
    throw new Error(getExhaustiveAbsurdErrorMessage);
  }
  return (u) => {
    const result = toEither(u);
    if (result._tag === "Right") {
      return result.right;
    }
    throw new Error(getExhaustiveAbsurdErrorMessage);
  };
};

// ../node_modules/effect/dist/esm/Match.js
var MatcherTypeId = TypeId19;
var type2 = type;
var value4 = value3;
var valueTags2 = valueTags;
var typeTags2 = typeTags;
var when5 = when4;
var whenOr2 = whenOr;
var whenAnd2 = whenAnd;
var discriminator2 = discriminator;
var discriminatorStartsWith2 = discriminatorStartsWith;
var discriminators2 = discriminators;
var discriminatorsExhaustive2 = discriminatorsExhaustive;
var tag2 = tag;
var tagStartsWith2 = tagStartsWith;
var tags2 = tags;
var tagsExhaustive2 = tagsExhaustive;
var not3 = not2;
var nonEmptyString2 = nonEmptyString;
var is2 = is;
var string4 = isString;
var number6 = isNumber;
var any2 = any;
var defined2 = defined;
var boolean5 = isBoolean;
var _undefined = isUndefined;
var _null = isNull;
var bigint3 = isBigInt;
var symbol4 = isSymbol;
var date3 = isDate;
var record = isRecord;
var instanceOf2 = instanceOf;
var instanceOfUnsafe = instanceOf;
var orElse17 = orElse16;
var orElseAbsurd2 = orElseAbsurd;
var either9 = either8;
var option6 = option5;
var exhaustive2 = exhaustive;
var SafeRefinementId = Symbol.for("effect/SafeRefinement");
var Fail = Symbol.for("effect/Fail");

// ../node_modules/effect/dist/esm/MergeState.js
var MergeState_exports = {};
__export(MergeState_exports, {
  BothRunning: () => BothRunning2,
  LeftDone: () => LeftDone2,
  MergeStateTypeId: () => MergeStateTypeId2,
  RightDone: () => RightDone2,
  isBothRunning: () => isBothRunning2,
  isLeftDone: () => isLeftDone2,
  isMergeState: () => isMergeState2,
  isRightDone: () => isRightDone2,
  match: () => match30
});
var MergeStateTypeId2 = MergeStateTypeId;
var BothRunning2 = BothRunning;
var LeftDone2 = LeftDone;
var RightDone2 = RightDone;
var isMergeState2 = isMergeState;
var isBothRunning2 = isBothRunning;
var isLeftDone2 = isLeftDone;
var isRightDone2 = isRightDone;
var match30 = match23;

// ../node_modules/effect/dist/esm/MergeStrategy.js
var MergeStrategy_exports = {};
__export(MergeStrategy_exports, {
  BackPressure: () => BackPressure2,
  BufferSliding: () => BufferSliding2,
  MergeStrategyTypeId: () => MergeStrategyTypeId2,
  isBackPressure: () => isBackPressure2,
  isBufferSliding: () => isBufferSliding2,
  isMergeStrategy: () => isMergeStrategy2,
  match: () => match31
});
var MergeStrategyTypeId2 = MergeStrategyTypeId;
var BackPressure2 = BackPressure;
var BufferSliding2 = BufferSliding;
var isMergeStrategy2 = isMergeStrategy;
var isBackPressure2 = isBackPressure;
var isBufferSliding2 = isBufferSliding;
var match31 = match24;

// ../node_modules/effect/dist/esm/Metric.js
var Metric_exports = {};
__export(Metric_exports, {
  MetricTypeId: () => MetricTypeId2,
  counter: () => counter6,
  fiberActive: () => fiberActive2,
  fiberFailures: () => fiberFailures2,
  fiberLifetimes: () => fiberLifetimes2,
  fiberStarted: () => fiberStarted2,
  fiberSuccesses: () => fiberSuccesses2,
  frequency: () => frequency6,
  fromMetricKey: () => fromMetricKey2,
  gauge: () => gauge6,
  globalMetricRegistry: () => globalMetricRegistry2,
  histogram: () => histogram6,
  increment: () => increment4,
  incrementBy: () => incrementBy2,
  make: () => make79,
  map: () => map33,
  mapInput: () => mapInput11,
  mapType: () => mapType2,
  set: () => set11,
  snapshot: () => snapshot2,
  succeed: () => succeed22,
  summary: () => summary6,
  summaryTimestamp: () => summaryTimestamp2,
  sync: () => sync17,
  tagged: () => tagged6,
  taggedWithLabels: () => taggedWithLabels3,
  taggedWithLabelsInput: () => taggedWithLabelsInput2,
  timer: () => timer3,
  timerWithBoundaries: () => timerWithBoundaries2,
  trackAll: () => trackAll2,
  trackDefect: () => trackDefect2,
  trackDefectWith: () => trackDefectWith2,
  trackDuration: () => trackDuration2,
  trackDurationWith: () => trackDurationWith2,
  trackError: () => trackError2,
  trackErrorWith: () => trackErrorWith2,
  trackSuccess: () => trackSuccess2,
  trackSuccessWith: () => trackSuccessWith2,
  unsafeSnapshot: () => unsafeSnapshot2,
  update: () => update8,
  value: () => value5,
  withConstantInput: () => withConstantInput2,
  withNow: () => withNow2,
  zip: () => zip18
});
var MetricTypeId2 = MetricTypeId;
var globalMetricRegistry2 = globalMetricRegistry;
var make79 = make43;
var mapInput11 = mapInput4;
var counter6 = counter5;
var frequency6 = frequency5;
var withConstantInput2 = withConstantInput;
var fromMetricKey2 = fromMetricKey;
var gauge6 = gauge5;
var histogram6 = histogram5;
var increment4 = increment3;
var incrementBy2 = incrementBy;
var map33 = map16;
var mapType2 = mapType;
var set11 = set7;
var snapshot2 = snapshot;
var succeed22 = succeed6;
var sync17 = sync4;
var summary6 = summary5;
var summaryTimestamp2 = summaryTimestamp;
var tagged6 = tagged2;
var taggedWithLabelsInput2 = taggedWithLabelsInput;
var taggedWithLabels3 = taggedWithLabels2;
var timer3 = timer2;
var timerWithBoundaries2 = timerWithBoundaries;
var trackAll2 = trackAll;
var trackDefect2 = trackDefect;
var trackDefectWith2 = trackDefectWith;
var trackDuration2 = trackDuration;
var trackDurationWith2 = trackDurationWith;
var trackError2 = trackError;
var trackErrorWith2 = trackErrorWith;
var trackSuccess2 = trackSuccess;
var trackSuccessWith2 = trackSuccessWith;
var update8 = update5;
var value5 = value;
var withNow2 = withNow;
var zip18 = zip7;
var unsafeSnapshot2 = unsafeSnapshot;
var fiberStarted2 = fiberStarted;
var fiberSuccesses2 = fiberSuccesses;
var fiberFailures2 = fiberFailures;
var fiberLifetimes2 = fiberLifetimes;
var fiberActive2 = fiberActive;

// ../node_modules/effect/dist/esm/MetricBoundaries.js
var MetricBoundaries_exports = {};
__export(MetricBoundaries_exports, {
  MetricBoundariesTypeId: () => MetricBoundariesTypeId2,
  exponential: () => exponential4,
  fromIterable: () => fromIterable18,
  isMetricBoundaries: () => isMetricBoundaries2,
  linear: () => linear4
});
var MetricBoundariesTypeId2 = MetricBoundariesTypeId;
var isMetricBoundaries2 = isMetricBoundaries;
var fromIterable18 = fromIterable10;
var linear4 = linear;
var exponential4 = exponential;

// ../node_modules/effect/dist/esm/MetricHook.js
var MetricHook_exports = {};
__export(MetricHook_exports, {
  MetricHookTypeId: () => MetricHookTypeId2,
  counter: () => counter7,
  frequency: () => frequency7,
  gauge: () => gauge7,
  histogram: () => histogram7,
  make: () => make80,
  onUpdate: () => onUpdate2,
  summary: () => summary7
});
var MetricHookTypeId2 = MetricHookTypeId;
var make80 = make40;
var counter7 = counter4;
var frequency7 = frequency4;
var gauge7 = gauge4;
var histogram7 = histogram4;
var summary7 = summary4;
var onUpdate2 = onUpdate;

// ../node_modules/effect/dist/esm/MetricKey.js
var MetricKey_exports = {};
__export(MetricKey_exports, {
  MetricKeyTypeId: () => MetricKeyTypeId2,
  counter: () => counter8,
  frequency: () => frequency8,
  gauge: () => gauge8,
  histogram: () => histogram8,
  isMetricKey: () => isMetricKey2,
  summary: () => summary8,
  tagged: () => tagged7,
  taggedWithLabels: () => taggedWithLabels4
});
var MetricKeyTypeId2 = MetricKeyTypeId;
var isMetricKey2 = isMetricKey;
var counter8 = counter2;
var frequency8 = frequency2;
var gauge8 = gauge2;
var histogram8 = histogram2;
var summary8 = summary2;
var tagged7 = tagged;
var taggedWithLabels4 = taggedWithLabels;

// ../node_modules/effect/dist/esm/MetricKeyType.js
var MetricKeyType_exports = {};
__export(MetricKeyType_exports, {
  CounterKeyTypeTypeId: () => CounterKeyTypeTypeId2,
  FrequencyKeyTypeTypeId: () => FrequencyKeyTypeTypeId2,
  GaugeKeyTypeTypeId: () => GaugeKeyTypeTypeId2,
  HistogramKeyTypeTypeId: () => HistogramKeyTypeTypeId2,
  MetricKeyTypeTypeId: () => MetricKeyTypeTypeId2,
  SummaryKeyTypeTypeId: () => SummaryKeyTypeTypeId2,
  counter: () => counter9,
  frequency: () => frequency9,
  gauge: () => gauge9,
  histogram: () => histogram9,
  isCounterKey: () => isCounterKey2,
  isFrequencyKey: () => isFrequencyKey2,
  isGaugeKey: () => isGaugeKey2,
  isHistogramKey: () => isHistogramKey2,
  isMetricKeyType: () => isMetricKeyType2,
  isSummaryKey: () => isSummaryKey2,
  summary: () => summary9
});
var MetricKeyTypeTypeId2 = MetricKeyTypeTypeId;
var CounterKeyTypeTypeId2 = CounterKeyTypeTypeId;
var FrequencyKeyTypeTypeId2 = FrequencyKeyTypeTypeId;
var GaugeKeyTypeTypeId2 = GaugeKeyTypeTypeId;
var HistogramKeyTypeTypeId2 = HistogramKeyTypeTypeId;
var SummaryKeyTypeTypeId2 = SummaryKeyTypeTypeId;
var counter9 = counter;
var frequency9 = frequency;
var gauge9 = gauge;
var histogram9 = histogram;
var summary9 = summary;
var isMetricKeyType2 = isMetricKeyType;
var isCounterKey2 = isCounterKey;
var isFrequencyKey2 = isFrequencyKey;
var isGaugeKey2 = isGaugeKey;
var isHistogramKey2 = isHistogramKey;
var isSummaryKey2 = isSummaryKey;

// ../node_modules/effect/dist/esm/MetricLabel.js
var MetricLabel_exports = {};
__export(MetricLabel_exports, {
  MetricLabelTypeId: () => MetricLabelTypeId2,
  isMetricLabel: () => isMetricLabel2,
  make: () => make81
});
var MetricLabelTypeId2 = MetricLabelTypeId;
var make81 = make38;
var isMetricLabel2 = isMetricLabel;

// ../node_modules/effect/dist/esm/MetricPair.js
var MetricPair_exports = {};
__export(MetricPair_exports, {
  MetricPairTypeId: () => MetricPairTypeId2,
  make: () => make82,
  unsafeMake: () => unsafeMake16
});
var MetricPairTypeId2 = MetricPairTypeId;
var make82 = make41;
var unsafeMake16 = unsafeMake10;

// ../node_modules/effect/dist/esm/MetricPolling.js
var MetricPolling_exports = {};
__export(MetricPolling_exports, {
  MetricPollingTypeId: () => MetricPollingTypeId2,
  collectAll: () => collectAll3,
  launch: () => launch4,
  make: () => make84,
  poll: () => poll8,
  pollAndUpdate: () => pollAndUpdate2,
  retry: () => retry6,
  zip: () => zip20
});

// ../node_modules/effect/dist/esm/internal/metric/polling.js
var MetricPollingSymbolKey = "effect/MetricPolling";
var MetricPollingTypeId = Symbol.for(MetricPollingSymbolKey);
var make83 = (metric, poll13) => {
  return {
    [MetricPollingTypeId]: MetricPollingTypeId,
    pipe() {
      return pipeArguments(this, arguments);
    },
    metric,
    poll: poll13
  };
};
var collectAll2 = (iterable) => {
  const metrics = Array.from(iterable);
  return {
    [MetricPollingTypeId]: MetricPollingTypeId,
    pipe() {
      return pipeArguments(this, arguments);
    },
    metric: make43(Array.of(void 0), (inputs, extraTags) => {
      for (let i = 0; i < inputs.length; i++) {
        const pollingMetric = metrics[i];
        const input = pipe(inputs, (x) => x[i]);
        pollingMetric.metric.unsafeUpdate(input, extraTags);
      }
    }, (extraTags) => Array.from(metrics.map((pollingMetric) => pollingMetric.metric.unsafeValue(extraTags)))),
    poll: forEachSequential(metrics, (metric) => metric.poll)
  };
};
var launch3 = dual(2, (self, schedule4) => pipe(pollAndUpdate(self), zipRight(value(self.metric)), scheduleForked(schedule4)));
var poll7 = (self) => self.poll;
var pollAndUpdate = (self) => flatMap10(self.poll, (value8) => update5(self.metric, value8));
var retry5 = dual(2, (self, policy) => ({
  [MetricPollingTypeId]: MetricPollingTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  metric: self.metric,
  poll: retry_Effect(self.poll, policy)
}));
var zip19 = dual(2, (self, that) => ({
  [MetricPollingTypeId]: MetricPollingTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  metric: pipe(self.metric, zip7(that.metric)),
  poll: zip4(self.poll, that.poll)
}));

// ../node_modules/effect/dist/esm/MetricPolling.js
var MetricPollingTypeId2 = MetricPollingTypeId;
var make84 = make83;
var collectAll3 = collectAll2;
var launch4 = launch3;
var poll8 = poll7;
var pollAndUpdate2 = pollAndUpdate;
var retry6 = retry5;
var zip20 = zip19;

// ../node_modules/effect/dist/esm/MetricRegistry.js
var MetricRegistry_exports = {};
__export(MetricRegistry_exports, {
  MetricRegistryTypeId: () => MetricRegistryTypeId2,
  make: () => make85
});
var MetricRegistryTypeId2 = MetricRegistryTypeId;
var make85 = make42;

// ../node_modules/effect/dist/esm/MetricState.js
var MetricState_exports = {};
__export(MetricState_exports, {
  CounterStateTypeId: () => CounterStateTypeId2,
  FrequencyStateTypeId: () => FrequencyStateTypeId2,
  GaugeStateTypeId: () => GaugeStateTypeId2,
  HistogramStateTypeId: () => HistogramStateTypeId2,
  MetricStateTypeId: () => MetricStateTypeId2,
  SummaryStateTypeId: () => SummaryStateTypeId2,
  counter: () => counter10,
  frequency: () => frequency10,
  gauge: () => gauge10,
  histogram: () => histogram10,
  isCounterState: () => isCounterState2,
  isFrequencyState: () => isFrequencyState2,
  isGaugeState: () => isGaugeState2,
  isHistogramState: () => isHistogramState2,
  isMetricState: () => isMetricState2,
  isSummaryState: () => isSummaryState2,
  summary: () => summary10
});
var MetricStateTypeId2 = MetricStateTypeId;
var CounterStateTypeId2 = CounterStateTypeId;
var FrequencyStateTypeId2 = FrequencyStateTypeId;
var GaugeStateTypeId2 = GaugeStateTypeId;
var HistogramStateTypeId2 = HistogramStateTypeId;
var SummaryStateTypeId2 = SummaryStateTypeId;
var counter10 = counter3;
var frequency10 = frequency3;
var gauge10 = gauge3;
var histogram10 = histogram3;
var summary10 = summary3;
var isMetricState2 = isMetricState;
var isCounterState2 = isCounterState;
var isFrequencyState2 = isFrequencyState;
var isGaugeState2 = isGaugeState;
var isHistogramState2 = isHistogramState;
var isSummaryState2 = isSummaryState;

// ../node_modules/effect/dist/esm/ModuleVersion.js
var ModuleVersion_exports = {};
__export(ModuleVersion_exports, {
  getCurrentVersion: () => getCurrentVersion2,
  setCurrentVersion: () => setCurrentVersion2
});
var getCurrentVersion2 = getCurrentVersion;
var setCurrentVersion2 = setCurrentVersion;

// ../node_modules/effect/dist/esm/MutableHashSet.js
var MutableHashSet_exports = {};
__export(MutableHashSet_exports, {
  add: () => add8,
  clear: () => clear7,
  empty: () => empty42,
  fromIterable: () => fromIterable19,
  has: () => has10,
  make: () => make86,
  remove: () => remove12,
  size: () => size21
});
var TypeId20 = Symbol.for("effect/MutableHashSet");
var MutableHashSetProto = {
  [TypeId20]: TypeId20,
  [Symbol.iterator]() {
    return Array.from(this.keyMap).map(([_]) => _)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var fromHashMap = (keyMap) => {
  const set22 = Object.create(MutableHashSetProto);
  set22.keyMap = keyMap;
  return set22;
};
var empty42 = () => fromHashMap(empty21());
var fromIterable19 = (keys10) => fromHashMap(fromIterable8(Array.from(keys10).map((k) => [k, true])));
var make86 = (...keys10) => fromIterable19(keys10);
var add8 = dual(2, (self, key) => (set4(self.keyMap, key, true), self));
var has10 = dual(2, (self, key) => has5(self.keyMap, key));
var remove12 = dual(2, (self, key) => (remove7(self.keyMap, key), self));
var size21 = (self) => size8(self.keyMap);
var clear7 = (self) => (clear(self.keyMap), self);

// ../node_modules/effect/dist/esm/NonEmptyIterable.js
var NonEmptyIterable_exports = {};
__export(NonEmptyIterable_exports, {
  unprepend: () => unprepend
});
var unprepend = (self) => {
  const iterator = self[Symbol.iterator]();
  const next6 = iterator.next();
  if (next6.done) {
    throw new Error("BUG: NonEmptyIterator should not be empty - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return [next6.value, iterator];
};

// ../node_modules/effect/dist/esm/Ordering.js
var Ordering_exports = {};
__export(Ordering_exports, {
  combine: () => combine15,
  combineAll: () => combineAll3,
  combineMany: () => combineMany,
  match: () => match32,
  reverse: () => reverse4
});
var reverse4 = (o) => o === -1 ? 1 : o === 1 ? -1 : 0;
var match32 = dual(2, (self, {
  onEqual,
  onGreaterThan,
  onLessThan
}) => self === -1 ? onLessThan() : self === 0 ? onEqual() : onGreaterThan());
var combine15 = dual(2, (self, that) => self !== 0 ? self : that);
var combineMany = dual(2, (self, collection) => {
  let ordering = self;
  if (ordering !== 0) {
    return ordering;
  }
  for (ordering of collection) {
    if (ordering !== 0) {
      return ordering;
    }
  }
  return ordering;
});
var combineAll3 = (collection) => combineMany(0, collection);

// ../node_modules/effect/dist/esm/Pool.js
var Pool_exports = {};
__export(Pool_exports, {
  PoolTypeId: () => PoolTypeId2,
  get: () => get18,
  invalidate: () => invalidate4,
  isPool: () => isPool2,
  make: () => make87,
  makeWithTTL: () => makeWithTTL4
});
var PoolTypeId2 = PoolTypeId;
var isPool2 = isPool;
var make87 = make73;
var makeWithTTL4 = makeWithTTL;
var get18 = get15;
var invalidate4 = invalidate;

// ../node_modules/effect/dist/esm/PrimaryKey.js
var PrimaryKey_exports = {};
__export(PrimaryKey_exports, {
  symbol: () => symbol5,
  value: () => value6
});
var symbol5 = Symbol.for("effect/PrimaryKey");
var value6 = (self) => self[symbol5]();

// ../node_modules/effect/dist/esm/RateLimiter.js
var RateLimiter_exports = {};
__export(RateLimiter_exports, {
  make: () => make89,
  withCost: () => withCost2
});

// ../node_modules/effect/dist/esm/internal/rateLimiter.js
var make88 = ({
  algorithm = "token-bucket",
  interval,
  limit
}) => {
  switch (algorithm) {
    case "fixed-window": {
      return fixedWindow(limit, interval);
    }
    case "token-bucket": {
      return tokenBucket(limit, interval);
    }
  }
};
var tokenBucket = (limit, window) => gen2(function* (_) {
  const millisPerToken = Math.ceil(toMillis(window) / limit);
  const semaphore = yield* _(makeSemaphore2(limit));
  const latch = yield* _(makeSemaphore2(0));
  const refill = sleep4(millisPerToken).pipe(zipRight6(latch.releaseAll), zipRight6(semaphore.release(1)), flatMap15((free) => free === limit ? _void : refill));
  yield* _(latch.take(1), zipRight6(refill), forever3, forkScoped2, interruptible3);
  const take14 = uninterruptibleMask2((restore) => flatMap15(get12(currentCost), (cost) => zipRight6(restore(semaphore.take(cost)), latch.release(1))));
  return (effect4) => zipRight6(take14, effect4);
});
var fixedWindow = (limit, window) => gen2(function* (_) {
  const semaphore = yield* _(makeSemaphore2(limit));
  const latch = yield* _(makeSemaphore2(0));
  yield* _(latch.take(1), zipRight6(sleep4(window)), zipRight6(latch.releaseAll), zipRight6(semaphore.releaseAll), forever3, forkScoped2, interruptible3);
  const take14 = uninterruptibleMask2((restore) => flatMap15(get12(currentCost), (cost) => zipRight6(restore(semaphore.take(cost)), latch.release(1))));
  return (effect4) => zipRight6(take14, effect4);
});
var currentCost = globalValue(Symbol.for("effect/RateLimiter/currentCost"), () => unsafeMake12(1));
var withCost = (cost) => locally2(currentCost, cost);

// ../node_modules/effect/dist/esm/RateLimiter.js
var make89 = make88;
var withCost2 = withCost;

// ../node_modules/effect/dist/esm/Reloadable.js
var Reloadable_exports = {};
__export(Reloadable_exports, {
  ReloadableTypeId: () => ReloadableTypeId2,
  auto: () => auto2,
  autoFromConfig: () => autoFromConfig2,
  get: () => get21,
  manual: () => manual2,
  reload: () => reload2,
  reloadFork: () => reloadFork2,
  tag: () => tag3
});

// ../node_modules/effect/dist/esm/internal/scopedRef.js
var ScopedRefSymbolKey = "effect/ScopedRef";
var ScopedRefTypeId = Symbol.for(ScopedRefSymbolKey);
var scopedRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var close2 = (self) => flatMap10(get10(self.ref), (tuple4) => tuple4[0].close(exitVoid));
var fromAcquire = (acquire3) => uninterruptible(scopeMake().pipe(flatMap10((newScope) => acquire3.pipe(mapInputContext(add2(scopeTag, newScope)), onError((cause3) => newScope.close(exitFail(cause3))), flatMap10((value8) => makeSynchronized([newScope, value8]).pipe(flatMap10((ref) => {
  const scopedRef = {
    [ScopedRefTypeId]: scopedRefVariance,
    pipe() {
      return pipeArguments(this, arguments);
    },
    ref
  };
  return pipe(addFinalizer(() => close2(scopedRef)), as2(scopedRef));
})))))));
var get19 = (self) => map11(get10(self.ref), (tuple4) => tuple4[1]);
var make90 = (evaluate3) => fromAcquire(sync(evaluate3));
var set12 = dual(2, (self, acquire3) => flatten5(modifyEffect(self.ref, ([oldScope, value8]) => uninterruptible(scopeClose(oldScope, exitVoid).pipe(zipRight(scopeMake()), flatMap10((newScope) => exit(scopeExtend(acquire3, newScope)).pipe(flatMap10((exit3) => exitMatch(exit3, {
  onFailure: (cause3) => scopeClose(newScope, exitVoid).pipe(as2([failCause(cause3), [oldScope, value8]])),
  onSuccess: (value9) => succeed([void_, [newScope, value9]])
})))))))));

// ../node_modules/effect/dist/esm/internal/reloadable.js
var ReloadableSymbolKey = "effect/Reloadable";
var ReloadableTypeId = Symbol.for(ReloadableSymbolKey);
var reloadableVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var auto = (tag4, options) => scoped2(reloadableTag(tag4), pipe(build(manual(tag4, {
  layer: options.layer
})), map11(unsafeGet3(reloadableTag(tag4))), tap((reloadable) => acquireRelease(pipe(reloadable.reload, ignoreLogged, schedule_Effect(options.schedule), forkDaemon), interruptFiber))));
var autoFromConfig = (tag4, options) => scoped2(reloadableTag(tag4), pipe(context(), flatMap10((env) => pipe(build(auto(tag4, {
  layer: options.layer,
  schedule: options.scheduleFromConfig(env)
})), map11(unsafeGet3(reloadableTag(tag4)))))));
var get20 = (tag4) => flatMap10(reloadableTag(tag4), (reloadable) => get19(reloadable.scopedRef));
var manual = (tag4, options) => scoped2(reloadableTag(tag4), pipe(context(), flatMap10((env) => pipe(fromAcquire(pipe(build(options.layer), map11(unsafeGet3(tag4)))), map11((ref) => ({
  [ReloadableTypeId]: reloadableVariance,
  scopedRef: ref,
  reload: pipe(set12(ref, pipe(build(options.layer), map11(unsafeGet3(tag4)))), provideContext(env))
}))))));
var reloadableTag = (tag4) => {
  return GenericTag(`effect/Reloadable<${tag4.key}>`);
};
var reload = (tag4) => flatMap10(reloadableTag(tag4), (reloadable) => reloadable.reload);
var reloadFork = (tag4) => flatMap10(reloadableTag(tag4), (reloadable) => pipe(reloadable.reload, ignoreLogged, forkDaemon, asVoid));

// ../node_modules/effect/dist/esm/Reloadable.js
var ReloadableTypeId2 = ReloadableTypeId;
var auto2 = auto;
var autoFromConfig2 = autoFromConfig;
var get21 = get20;
var manual2 = manual;
var reload2 = reload;
var tag3 = reloadableTag;
var reloadFork2 = reloadFork;

// ../node_modules/effect/dist/esm/RequestBlock.js
var RequestBlock_exports = {};
__export(RequestBlock_exports, {
  empty: () => empty43,
  mapRequestResolvers: () => mapRequestResolvers2,
  parallel: () => parallel5,
  reduce: () => reduce17,
  sequential: () => sequential5,
  single: () => single2
});
var single2 = single;
var empty43 = empty19;
var mapRequestResolvers2 = mapRequestResolvers;
var parallel5 = par;
var reduce17 = reduce8;
var sequential5 = seq;

// ../node_modules/effect/dist/esm/RequestResolver.js
var RequestResolver_exports = {};
__export(RequestResolver_exports, {
  RequestResolverTypeId: () => RequestResolverTypeId2,
  around: () => around2,
  aroundRequests: () => aroundRequests2,
  batchN: () => batchN2,
  contextFromEffect: () => contextFromEffect,
  contextFromServices: () => contextFromServices,
  eitherWith: () => eitherWith4,
  fromEffect: () => fromEffect12,
  fromEffectTagged: () => fromEffectTagged2,
  fromFunction: () => fromFunction6,
  fromFunctionBatched: () => fromFunctionBatched2,
  isRequestResolver: () => isRequestResolver2,
  locally: () => locally4,
  make: () => make92,
  makeBatched: () => makeBatched3,
  makeWithEntry: () => makeWithEntry2,
  mapInputContext: () => mapInputContext9,
  never: () => never10,
  provideContext: () => provideContext9,
  race: () => race5
});

// ../node_modules/effect/dist/esm/internal/dataSource.js
var make91 = (runAll) => new RequestResolverImpl((requests) => runAll(requests.map((_) => _.map((_2) => _2.request))));
var makeWithEntry = (runAll) => new RequestResolverImpl((requests) => runAll(requests));
var makeBatched2 = (run11) => new RequestResolverImpl((requests) => {
  if (requests.length > 1) {
    return forEachSequentialDiscard(requests, (block) => {
      const filtered = block.filter((_) => !_.state.completed).map((_) => _.request);
      if (filtered.length === 0) {
        return void_;
      }
      return invokeWithInterrupt(run11(filtered), block);
    });
  } else if (requests.length === 1) {
    const filtered = requests[0].filter((_) => !_.state.completed).map((_) => _.request);
    if (filtered.length === 0) {
      return void_;
    }
    return run11(filtered);
  }
  return void_;
});
var around = dual(3, (self, before3, after3) => new RequestResolverImpl((requests) => acquireUseRelease(before3, () => self.runAll(requests), after3), make8("Around", self, before3, after3)));
var aroundRequests = dual(3, (self, before3, after3) => new RequestResolverImpl((requests) => {
  const flatRequests = requests.flatMap((chunk7) => chunk7.map((entry) => entry.request));
  return acquireUseRelease(before3(flatRequests), () => self.runAll(requests), (a2) => after3(flatRequests, a2));
}, make8("AroundRequests", self, before3, after3)));
var batchN = dual(2, (self, n) => new RequestResolverImpl((requests) => {
  return n < 1 ? die2(new IllegalArgumentException2("RequestResolver.batchN: n must be at least 1")) : self.runAll(Array.from(map4(reduce(requests, empty5(), (acc, chunk7) => appendAll2(acc, chunksOf(unsafeFromArray(chunk7), n))), (chunk7) => Array.from(chunk7))));
}, make8("BatchN", self, n)));
var mapInputContext8 = dual(2, (self, f) => new RequestResolverImpl((requests) => mapInputContext(self.runAll(requests), (context13) => f(context13)), make8("MapInputContext", self, f)));
var eitherWith3 = dual(3, (self, that, f) => new RequestResolverImpl((batch) => pipe(forEachSequential(batch, (requests) => {
  const [as16, bs] = pipe(requests, partitionMap(f));
  return zipWithOptions(self.runAll(Array.of(as16)), that.runAll(Array.of(bs)), () => void 0, {
    concurrent: true
  });
})), make8("EitherWith", self, that, f)));
var fromFunction5 = (f) => makeBatched2((requests) => forEachSequentialDiscard(requests, (request2) => complete2(request2, exitSucceed(f(request2))))).identified("FromFunction", f);
var fromFunctionBatched = (f) => makeBatched2((as16) => forEach12(f(as16), (res, i) => complete2(as16[i], exitSucceed(res)), {
  discard: true
})).identified("FromFunctionBatched", f);
var fromEffect11 = (f) => makeBatched2((requests) => forEach12(requests, (a) => flatMap15(exit2(f(a)), (e) => complete2(a, e)), {
  concurrency: "unbounded",
  discard: true
})).identified("FromEffect", f);
var fromEffectTagged = () => (fns) => makeBatched2((requests) => {
  const grouped3 = {};
  const tags3 = [];
  for (let i = 0, len = requests.length; i < len; i++) {
    if (tags3.includes(requests[i]._tag)) {
      grouped3[requests[i]._tag].push(requests[i]);
    } else {
      grouped3[requests[i]._tag] = [requests[i]];
      tags3.push(requests[i]._tag);
    }
  }
  return forEach12(tags3, (tag4) => matchCauseEffect2(fns[tag4](grouped3[tag4]), {
    onFailure: (cause3) => forEach12(grouped3[tag4], (req) => complete2(req, exitFail(cause3)), {
      discard: true
    }),
    onSuccess: (res) => forEach12(grouped3[tag4], (req, i) => complete2(req, exitSucceed(res[i])), {
      discard: true
    })
  }), {
    concurrency: "unbounded",
    discard: true
  });
}).identified("FromEffectTagged", fns);
var never9 = make91(() => never4).identified("Never");
var provideContext8 = dual(2, (self, context13) => mapInputContext8(self, (_) => context13).identified("ProvideContext", self, context13));
var race4 = dual(2, (self, that) => new RequestResolverImpl((requests) => race2(self.runAll(requests), that.runAll(requests))).identified("Race", self, that));

// ../node_modules/effect/dist/esm/RequestResolver.js
var RequestResolverTypeId2 = RequestResolverTypeId;
var contextFromEffect = (self) => contextWith2((_) => provideContext9(self, _));
var contextFromServices = (...services) => (self) => contextWith2((_) => provideContext9(self, pick2(...services)(_)));
var isRequestResolver2 = isRequestResolver;
var make92 = make91;
var makeWithEntry2 = makeWithEntry;
var makeBatched3 = makeBatched2;
var around2 = around;
var aroundRequests2 = aroundRequests;
var batchN2 = batchN;
var mapInputContext9 = mapInputContext8;
var eitherWith4 = eitherWith3;
var fromFunction6 = fromFunction5;
var fromFunctionBatched2 = fromFunctionBatched;
var fromEffect12 = fromEffect11;
var fromEffectTagged2 = fromEffectTagged;
var never10 = never9;
var provideContext9 = provideContext8;
var race5 = race4;
var locally4 = resolverLocally;

// ../node_modules/effect/dist/esm/Resource.js
var Resource_exports = {};
__export(Resource_exports, {
  ResourceTypeId: () => ResourceTypeId2,
  auto: () => auto4,
  get: () => get23,
  manual: () => manual4,
  refresh: () => refresh2
});

// ../node_modules/effect/dist/esm/internal/resource.js
var ResourceSymbolKey = "effect/Resource";
var ResourceTypeId = Symbol.for(ResourceSymbolKey);
var resourceVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var auto3 = (acquire3, policy) => tap(manual3(acquire3), (manual5) => acquireRelease(pipe(refresh(manual5), schedule_Effect(policy), interruptible2, forkDaemon), interruptFiber));
var manual3 = (acquire3) => flatMap10(context(), (env) => pipe(fromAcquire(exit(acquire3)), map11((ref) => ({
  [ResourceTypeId]: resourceVariance,
  scopedRef: ref,
  acquire: provideContext(acquire3, env)
}))));
var get22 = (self) => flatMap10(get19(self.scopedRef), identity);
var refresh = (self) => set12(self.scopedRef, map11(self.acquire, exitSucceed));

// ../node_modules/effect/dist/esm/Resource.js
var ResourceTypeId2 = ResourceTypeId;
var auto4 = auto3;
var get23 = get22;
var manual4 = manual3;
var refresh2 = refresh;

// ../node_modules/effect/dist/esm/RuntimeFlags.js
var RuntimeFlags_exports = {};
__export(RuntimeFlags_exports, {
  CooperativeYielding: () => CooperativeYielding2,
  Interruption: () => Interruption2,
  None: () => None4,
  OpSupervision: () => OpSupervision2,
  RuntimeMetrics: () => RuntimeMetrics2,
  WindDown: () => WindDown2,
  cooperativeYielding: () => cooperativeYielding2,
  diff: () => diff12,
  differ: () => differ3,
  disable: () => disable4,
  disableAll: () => disableAll2,
  disableCooperativeYielding: () => disableCooperativeYielding2,
  disableInterruption: () => disableInterruption2,
  disableOpSupervision: () => disableOpSupervision2,
  disableRuntimeMetrics: () => disableRuntimeMetrics2,
  disableWindDown: () => disableWindDown2,
  enable: () => enable4,
  enableAll: () => enableAll2,
  enableCooperativeYielding: () => enableCooperativeYielding2,
  enableInterruption: () => enableInterruption2,
  enableOpSupervision: () => enableOpSupervision2,
  enableRuntimeMetrics: () => enableRuntimeMetrics2,
  enableWindDown: () => enableWindDown2,
  interruptible: () => interruptible4,
  interruption: () => interruption2,
  isDisabled: () => isDisabled4,
  isEnabled: () => isEnabled4,
  make: () => make93,
  none: () => none11,
  opSupervision: () => opSupervision2,
  patch: () => patch13,
  render: () => render5,
  runtimeMetrics: () => runtimeMetrics2,
  toSet: () => toSet5,
  windDown: () => windDown2
});
var None4 = None2;
var Interruption2 = Interruption;
var OpSupervision2 = OpSupervision;
var RuntimeMetrics2 = RuntimeMetrics;
var WindDown2 = WindDown;
var CooperativeYielding2 = CooperativeYielding;
var cooperativeYielding2 = cooperativeYielding;
var diff12 = diff7;
var differ3 = differ;
var disable4 = disable2;
var disableAll2 = disableAll;
var disableCooperativeYielding2 = disableCooperativeYielding;
var disableInterruption2 = disableInterruption;
var disableOpSupervision2 = disableOpSupervision;
var disableRuntimeMetrics2 = disableRuntimeMetrics;
var disableWindDown2 = disableWindDown;
var enable4 = enable2;
var enableAll2 = enableAll;
var enableCooperativeYielding2 = enableCooperativeYielding;
var enableInterruption2 = enableInterruption;
var enableOpSupervision2 = enableOpSupervision;
var enableRuntimeMetrics2 = enableRuntimeMetrics;
var enableWindDown2 = enableWindDown;
var interruptible4 = interruptible;
var interruption2 = interruption;
var isEnabled4 = isEnabled2;
var isDisabled4 = isDisabled2;
var make93 = make20;
var none11 = none5;
var opSupervision2 = opSupervision;
var patch13 = patch7;
var render5 = render;
var runtimeMetrics2 = runtimeMetrics;
var toSet5 = toSet3;
var windDown2 = windDown;

// ../node_modules/effect/dist/esm/STM.js
var STM_exports = {};
__export(STM_exports, {
  Do: () => Do5,
  STMTypeId: () => STMTypeId3,
  acquireUseRelease: () => acquireUseRelease6,
  all: () => all11,
  as: () => as14,
  asSome: () => asSome4,
  asSomeError: () => asSomeError4,
  asVoid: () => asVoid9,
  attempt: () => attempt2,
  bind: () => bind6,
  bindTo: () => bindTo6,
  catchAll: () => catchAll10,
  catchSome: () => catchSome6,
  catchTag: () => catchTag6,
  catchTags: () => catchTags6,
  check: () => check4,
  collect: () => collect4,
  collectSTM: () => collectSTM2,
  commit: () => commit3,
  commitEither: () => commitEither2,
  cond: () => cond2,
  context: () => context11,
  contextWith: () => contextWith9,
  contextWithSTM: () => contextWithSTM2,
  die: () => die15,
  dieMessage: () => dieMessage8,
  dieSync: () => dieSync10,
  either: () => either12,
  ensuring: () => ensuring11,
  eventually: () => eventually4,
  every: () => every12,
  exists: () => exists5,
  fail: () => fail23,
  failSync: () => failSync12,
  fiberId: () => fiberId4,
  filter: () => filter18,
  filterNot: () => filterNot2,
  filterOrDie: () => filterOrDie4,
  filterOrDieMessage: () => filterOrDieMessage4,
  filterOrElse: () => filterOrElse4,
  filterOrFail: () => filterOrFail4,
  firstSuccessOf: () => firstSuccessOf3,
  flatMap: () => flatMap23,
  flatten: () => flatten16,
  flip: () => flip4,
  flipWith: () => flipWith4,
  forEach: () => forEach16,
  fromEither: () => fromEither5,
  fromOption: () => fromOption6,
  gen: () => gen4,
  head: () => head9,
  if: () => if_4,
  ignore: () => ignore4,
  interrupt: () => interrupt10,
  interruptAs: () => interruptAs3,
  isFailure: () => isFailure9,
  isSTM: () => isSTM2,
  isSuccess: () => isSuccess7,
  iterate: () => iterate6,
  let: () => let_6,
  loop: () => loop4,
  map: () => map36,
  mapAttempt: () => mapAttempt4,
  mapBoth: () => mapBoth9,
  mapError: () => mapError12,
  mapInputContext: () => mapInputContext12,
  match: () => match34,
  matchSTM: () => matchSTM2,
  merge: () => merge12,
  mergeAll: () => mergeAll10,
  negate: () => negate5,
  none: () => none13,
  option: () => option8,
  orDie: () => orDie10,
  orDieWith: () => orDieWith8,
  orElse: () => orElse20,
  orElseEither: () => orElseEither8,
  orElseFail: () => orElseFail6,
  orElseOptional: () => orElseOptional2,
  orElseSucceed: () => orElseSucceed6,
  orTry: () => orTry2,
  partition: () => partition12,
  provideContext: () => provideContext12,
  provideService: () => provideService12,
  provideServiceSTM: () => provideServiceSTM2,
  provideSomeContext: () => provideSomeContext3,
  reduce: () => reduce19,
  reduceAll: () => reduceAll2,
  reduceRight: () => reduceRight7,
  refineOrDie: () => refineOrDie5,
  refineOrDieWith: () => refineOrDieWith5,
  reject: () => reject2,
  rejectSTM: () => rejectSTM2,
  repeatUntil: () => repeatUntil2,
  repeatWhile: () => repeatWhile2,
  replicate: () => replicate4,
  replicateSTM: () => replicateSTM2,
  replicateSTMDiscard: () => replicateSTMDiscard2,
  retry: () => retry10,
  retryUntil: () => retryUntil2,
  retryWhile: () => retryWhile2,
  some: () => some13,
  succeed: () => succeed26,
  succeedNone: () => succeedNone4,
  succeedSome: () => succeedSome4,
  summarized: () => summarized5,
  suspend: () => suspend14,
  sync: () => sync20,
  tap: () => tap9,
  tapBoth: () => tapBoth6,
  tapError: () => tapError8,
  try: () => try_4,
  unless: () => unless4,
  unlessSTM: () => unlessSTM2,
  unsome: () => unsome3,
  validateAll: () => validateAll4,
  validateFirst: () => validateFirst4,
  void: () => void_11,
  when: () => when8,
  whenSTM: () => whenSTM2,
  zip: () => zip23,
  zipLeft: () => zipLeft15,
  zipRight: () => zipRight15,
  zipWith: () => zipWith17
});

// ../node_modules/effect/dist/esm/Stream.js
var Stream_exports = {};
__export(Stream_exports, {
  DefaultChunkSize: () => DefaultChunkSize2,
  Do: () => Do4,
  StreamTypeId: () => StreamTypeId4,
  accumulate: () => accumulate2,
  accumulateChunks: () => accumulateChunks2,
  acquireRelease: () => acquireRelease4,
  aggregate: () => aggregate2,
  aggregateWithin: () => aggregateWithin2,
  aggregateWithinEither: () => aggregateWithinEither2,
  as: () => as12,
  async: () => _async2,
  asyncEffect: () => asyncEffect4,
  asyncScoped: () => asyncScoped2,
  bind: () => bind4,
  bindEffect: () => bindEffect2,
  bindTo: () => bindTo4,
  branchAfter: () => branchAfter2,
  broadcast: () => broadcast2,
  broadcastDynamic: () => broadcastDynamic2,
  broadcastedQueues: () => broadcastedQueues2,
  broadcastedQueuesDynamic: () => broadcastedQueuesDynamic2,
  buffer: () => buffer4,
  bufferChunks: () => bufferChunks2,
  catchAll: () => catchAll8,
  catchAllCause: () => catchAllCause8,
  catchSome: () => catchSome4,
  catchSomeCause: () => catchSomeCause4,
  catchTag: () => catchTag4,
  catchTags: () => catchTags4,
  changes: () => changes2,
  changesWith: () => changesWith2,
  changesWithEffect: () => changesWithEffect2,
  chunks: () => chunks2,
  chunksWith: () => chunksWith2,
  combine: () => combine16,
  combineChunks: () => combineChunks2,
  concat: () => concat3,
  concatAll: () => concatAll4,
  context: () => context9,
  contextWith: () => contextWith7,
  contextWithEffect: () => contextWithEffect7,
  contextWithStream: () => contextWithStream2,
  cross: () => cross2,
  crossLeft: () => crossLeft2,
  crossRight: () => crossRight2,
  crossWith: () => crossWith2,
  debounce: () => debounce2,
  decodeText: () => decodeText2,
  die: () => die12,
  dieMessage: () => dieMessage6,
  dieSync: () => dieSync8,
  distributedWith: () => distributedWith2,
  distributedWithDynamic: () => distributedWithDynamic2,
  drain: () => drain5,
  drainFork: () => drainFork2,
  drop: () => drop6,
  dropRight: () => dropRight3,
  dropUntil: () => dropUntil5,
  dropUntilEffect: () => dropUntilEffect3,
  dropWhile: () => dropWhile6,
  dropWhileEffect: () => dropWhileEffect3,
  either: () => either10,
  empty: () => empty44,
  encodeText: () => encodeText2,
  ensuring: () => ensuring9,
  ensuringWith: () => ensuringWith5,
  execute: () => execute2,
  fail: () => fail20,
  failCause: () => failCause17,
  failCauseSync: () => failCauseSync10,
  failSync: () => failSync10,
  filter: () => filter16,
  filterEffect: () => filterEffect2,
  filterMap: () => filterMap9,
  filterMapEffect: () => filterMapEffect2,
  filterMapWhile: () => filterMapWhile4,
  filterMapWhileEffect: () => filterMapWhileEffect2,
  finalizer: () => finalizer2,
  find: () => find4,
  findEffect: () => findEffect3,
  flatMap: () => flatMap21,
  flatten: () => flatten14,
  flattenChunks: () => flattenChunks2,
  flattenEffect: () => flattenEffect2,
  flattenExitOption: () => flattenExitOption2,
  flattenIterables: () => flattenIterables2,
  flattenTake: () => flattenTake2,
  forever: () => forever6,
  fromAsyncIterable: () => fromAsyncIterable2,
  fromChannel: () => fromChannel3,
  fromChunk: () => fromChunk2,
  fromChunkPubSub: () => fromChunkPubSub2,
  fromChunkQueue: () => fromChunkQueue2,
  fromChunks: () => fromChunks2,
  fromEffect: () => fromEffect13,
  fromEffectOption: () => fromEffectOption2,
  fromIterable: () => fromIterable20,
  fromIterableEffect: () => fromIterableEffect2,
  fromIteratorSucceed: () => fromIteratorSucceed2,
  fromPubSub: () => fromPubSub5,
  fromPull: () => fromPull3,
  fromQueue: () => fromQueue5,
  fromReadableStream: () => fromReadableStream2,
  fromReadableStreamByob: () => fromReadableStreamByob2,
  fromSchedule: () => fromSchedule2,
  groupAdjacentBy: () => groupAdjacentBy2,
  groupBy: () => groupBy2,
  groupByKey: () => groupByKey2,
  grouped: () => grouped2,
  groupedWithin: () => groupedWithin2,
  haltAfter: () => haltAfter2,
  haltWhen: () => haltWhen2,
  haltWhenDeferred: () => haltWhenDeferred2,
  identity: () => identity5,
  interleave: () => interleave2,
  interleaveWith: () => interleaveWith2,
  interruptAfter: () => interruptAfter2,
  interruptWhen: () => interruptWhen4,
  interruptWhenDeferred: () => interruptWhenDeferred4,
  intersperse: () => intersperse2,
  intersperseAffixes: () => intersperseAffixes2,
  iterate: () => iterate4,
  let: () => let_4,
  make: () => make94,
  map: () => map34,
  mapAccum: () => mapAccum6,
  mapAccumEffect: () => mapAccumEffect2,
  mapBoth: () => mapBoth7,
  mapChunks: () => mapChunks2,
  mapChunksEffect: () => mapChunksEffect2,
  mapConcat: () => mapConcat2,
  mapConcatChunk: () => mapConcatChunk2,
  mapConcatChunkEffect: () => mapConcatChunkEffect2,
  mapConcatEffect: () => mapConcatEffect2,
  mapEffect: () => mapEffect9,
  mapError: () => mapError10,
  mapErrorCause: () => mapErrorCause7,
  mapInputContext: () => mapInputContext10,
  merge: () => merge10,
  mergeAll: () => mergeAll8,
  mergeEither: () => mergeEither2,
  mergeLeft: () => mergeLeft2,
  mergeRight: () => mergeRight2,
  mergeWith: () => mergeWith4,
  mkString: () => mkString3,
  never: () => never11,
  onDone: () => onDone2,
  onError: () => onError4,
  orDie: () => orDie8,
  orDieWith: () => orDieWith6,
  orElse: () => orElse18,
  orElseEither: () => orElseEither6,
  orElseFail: () => orElseFail4,
  orElseIfEmpty: () => orElseIfEmpty2,
  orElseIfEmptyChunk: () => orElseIfEmptyChunk2,
  orElseIfEmptyStream: () => orElseIfEmptyStream2,
  orElseSucceed: () => orElseSucceed4,
  paginate: () => paginate2,
  paginateChunk: () => paginateChunk2,
  paginateChunkEffect: () => paginateChunkEffect2,
  paginateEffect: () => paginateEffect2,
  partition: () => partition10,
  partitionEither: () => partitionEither2,
  peel: () => peel2,
  pipeThrough: () => pipeThrough2,
  pipeThroughChannel: () => pipeThroughChannel2,
  pipeThroughChannelOrFail: () => pipeThroughChannelOrFail2,
  prepend: () => prepend6,
  provideContext: () => provideContext10,
  provideLayer: () => provideLayer4,
  provideService: () => provideService10,
  provideServiceEffect: () => provideServiceEffect4,
  provideServiceStream: () => provideServiceStream2,
  provideSomeLayer: () => provideSomeLayer5,
  range: () => range3,
  rechunk: () => rechunk2,
  refineOrDie: () => refineOrDie3,
  refineOrDieWith: () => refineOrDieWith3,
  repeat: () => repeat5,
  repeatEffect: () => repeatEffect2,
  repeatEffectChunk: () => repeatEffectChunk2,
  repeatEffectChunkOption: () => repeatEffectChunkOption2,
  repeatEffectOption: () => repeatEffectOption2,
  repeatEffectWithSchedule: () => repeatEffectWithSchedule2,
  repeatEither: () => repeatEither2,
  repeatElements: () => repeatElements2,
  repeatElementsWith: () => repeatElementsWith2,
  repeatValue: () => repeatValue2,
  repeatWith: () => repeatWith2,
  retry: () => retry7,
  run: () => run10,
  runCollect: () => runCollect4,
  runCount: () => runCount2,
  runDrain: () => runDrain4,
  runFold: () => runFold2,
  runFoldEffect: () => runFoldEffect2,
  runFoldScoped: () => runFoldScoped2,
  runFoldScopedEffect: () => runFoldScopedEffect2,
  runFoldWhile: () => runFoldWhile2,
  runFoldWhileEffect: () => runFoldWhileEffect2,
  runFoldWhileScoped: () => runFoldWhileScoped2,
  runFoldWhileScopedEffect: () => runFoldWhileScopedEffect2,
  runForEach: () => runForEach2,
  runForEachChunk: () => runForEachChunk2,
  runForEachChunkScoped: () => runForEachChunkScoped2,
  runForEachScoped: () => runForEachScoped2,
  runForEachWhile: () => runForEachWhile2,
  runForEachWhileScoped: () => runForEachWhileScoped2,
  runHead: () => runHead2,
  runIntoPubSub: () => runIntoPubSub2,
  runIntoPubSubScoped: () => runIntoPubSubScoped2,
  runIntoQueue: () => runIntoQueue2,
  runIntoQueueElementsScoped: () => runIntoQueueElementsScoped2,
  runIntoQueueScoped: () => runIntoQueueScoped2,
  runLast: () => runLast2,
  runScoped: () => runScoped3,
  runSum: () => runSum2,
  scan: () => scan2,
  scanEffect: () => scanEffect2,
  scanReduce: () => scanReduce2,
  scanReduceEffect: () => scanReduceEffect2,
  schedule: () => schedule3,
  scheduleWith: () => scheduleWith2,
  scoped: () => scoped8,
  sliding: () => sliding6,
  slidingSize: () => slidingSize2,
  some: () => some11,
  someOrElse: () => someOrElse2,
  someOrFail: () => someOrFail2,
  split: () => split3,
  splitLines: () => splitLines4,
  splitOnChunk: () => splitOnChunk2,
  succeed: () => succeed23,
  suspend: () => suspend11,
  sync: () => sync18,
  take: () => take8,
  takeRight: () => takeRight3,
  takeUntil: () => takeUntil4,
  takeUntilEffect: () => takeUntilEffect2,
  takeWhile: () => takeWhile5,
  tap: () => tap7,
  tapBoth: () => tapBoth4,
  tapError: () => tapError6,
  tapErrorCause: () => tapErrorCause6,
  tapSink: () => tapSink2,
  throttle: () => throttle2,
  throttleEffect: () => throttleEffect2,
  tick: () => tick2,
  timeout: () => timeout4,
  timeoutFail: () => timeoutFail4,
  timeoutFailCause: () => timeoutFailCause4,
  timeoutTo: () => timeoutTo4,
  toChannel: () => toChannel3,
  toPubSub: () => toPubSub4,
  toPull: () => toPull4,
  toQueue: () => toQueue4,
  toQueueOfElements: () => toQueueOfElements2,
  toReadableStream: () => toReadableStream2,
  transduce: () => transduce2,
  unfold: () => unfold5,
  unfoldChunk: () => unfoldChunk2,
  unfoldChunkEffect: () => unfoldChunkEffect2,
  unfoldEffect: () => unfoldEffect2,
  unwrap: () => unwrap8,
  unwrapScoped: () => unwrapScoped7,
  updateService: () => updateService6,
  void: () => void_8,
  when: () => when6,
  whenCase: () => whenCase2,
  whenCaseEffect: () => whenCaseEffect2,
  whenEffect: () => whenEffect4,
  withSpan: () => withSpan8,
  zip: () => zip21,
  zipAll: () => zipAll2,
  zipAllLeft: () => zipAllLeft2,
  zipAllRight: () => zipAllRight2,
  zipAllSortedByKey: () => zipAllSortedByKey2,
  zipAllSortedByKeyLeft: () => zipAllSortedByKeyLeft2,
  zipAllSortedByKeyRight: () => zipAllSortedByKeyRight2,
  zipAllSortedByKeyWith: () => zipAllSortedByKeyWith2,
  zipAllWith: () => zipAllWith2,
  zipFlatten: () => zipFlatten3,
  zipLatest: () => zipLatest2,
  zipLatestWith: () => zipLatestWith2,
  zipLeft: () => zipLeft13,
  zipRight: () => zipRight13,
  zipWith: () => zipWith15,
  zipWithChunks: () => zipWithChunks2,
  zipWithIndex: () => zipWithIndex2,
  zipWithNext: () => zipWithNext2,
  zipWithPrevious: () => zipWithPrevious2,
  zipWithPreviousAndNext: () => zipWithPreviousAndNext2
});
var StreamTypeId4 = StreamTypeId3;
var DefaultChunkSize2 = DefaultChunkSize;
var accumulate2 = accumulate;
var accumulateChunks2 = accumulateChunks;
var acquireRelease4 = acquireRelease3;
var aggregate2 = aggregate;
var aggregateWithin2 = aggregateWithin;
var aggregateWithinEither2 = aggregateWithinEither;
var as12 = as10;
var _async2 = _async;
var asyncEffect4 = asyncEffect3;
var asyncScoped2 = asyncScoped;
var branchAfter2 = branchAfter;
var broadcast2 = broadcast;
var broadcastDynamic2 = broadcastDynamic;
var broadcastedQueues2 = broadcastedQueues;
var broadcastedQueuesDynamic2 = broadcastedQueuesDynamic;
var buffer4 = buffer2;
var bufferChunks2 = bufferChunks;
var catchAll8 = catchAll6;
var catchAllCause8 = catchAllCause6;
var catchSome4 = catchSome3;
var catchTag4 = catchTag3;
var catchTags4 = catchTags3;
var catchSomeCause4 = catchSomeCause3;
var changes2 = changes;
var changesWith2 = changesWith;
var changesWithEffect2 = changesWithEffect;
var chunks2 = chunks;
var chunksWith2 = chunksWith;
var combine16 = combine14;
var combineChunks2 = combineChunks;
var concat3 = concat2;
var concatAll4 = concatAll2;
var cross2 = cross;
var crossLeft2 = crossLeft;
var crossRight2 = crossRight;
var crossWith2 = crossWith;
var debounce2 = debounce;
var die12 = die11;
var dieSync8 = dieSync7;
var dieMessage6 = dieMessage5;
var distributedWith2 = distributedWith;
var distributedWithDynamic2 = distributedWithDynamic;
var drain5 = drain3;
var drainFork2 = drainFork;
var drop6 = drop5;
var dropRight3 = dropRight2;
var dropUntil5 = dropUntil4;
var dropUntilEffect3 = dropUntilEffect2;
var dropWhile6 = dropWhile5;
var dropWhileEffect3 = dropWhileEffect2;
var either10 = either7;
var empty44 = empty40;
var ensuring9 = ensuring7;
var ensuringWith5 = ensuringWith3;
var context9 = context7;
var contextWith7 = contextWith5;
var contextWithEffect7 = contextWithEffect5;
var contextWithStream2 = contextWithStream;
var execute2 = execute;
var fail20 = fail16;
var failSync10 = failSync8;
var failCause17 = failCause15;
var failCauseSync10 = failCauseSync8;
var filter16 = filter13;
var filterEffect2 = filterEffect;
var filterMap9 = filterMap8;
var filterMapEffect2 = filterMapEffect;
var filterMapWhile4 = filterMapWhile3;
var filterMapWhileEffect2 = filterMapWhileEffect;
var finalizer2 = finalizer;
var find4 = find3;
var findEffect3 = findEffect2;
var flatMap21 = flatMap19;
var flatten14 = flatten12;
var flattenChunks2 = flattenChunks;
var flattenEffect2 = flattenEffect;
var flattenExitOption2 = flattenExitOption;
var flattenIterables2 = flattenIterables;
var flattenTake2 = flattenTake;
var forever6 = forever5;
var fromAsyncIterable2 = fromAsyncIterable;
var fromChannel3 = fromChannel2;
var toChannel3 = toChannel2;
var fromChunk2 = fromChunk;
var fromChunkPubSub2 = fromChunkPubSub;
var fromChunkQueue2 = fromChunkQueue;
var fromChunks2 = fromChunks;
var fromEffect13 = fromEffect9;
var fromEffectOption2 = fromEffectOption;
var fromPubSub5 = fromPubSub3;
var fromIterable20 = fromIterable16;
var fromIterableEffect2 = fromIterableEffect;
var fromIteratorSucceed2 = fromIteratorSucceed;
var fromPull3 = fromPull2;
var fromQueue5 = fromQueue3;
var fromReadableStream2 = fromReadableStream;
var fromReadableStreamByob2 = fromReadableStreamByob;
var fromSchedule2 = fromSchedule;
var groupAdjacentBy2 = groupAdjacentBy;
var groupBy2 = groupBy;
var groupByKey2 = groupByKey;
var grouped2 = grouped;
var groupedWithin2 = groupedWithin;
var haltAfter2 = haltAfter;
var haltWhen2 = haltWhen;
var haltWhenDeferred2 = haltWhenDeferred;
var identity5 = identityStream;
var interleave2 = interleave;
var interleaveWith2 = interleaveWith;
var intersperse2 = intersperse;
var intersperseAffixes2 = intersperseAffixes;
var interruptAfter2 = interruptAfter;
var interruptWhen4 = interruptWhen2;
var interruptWhenDeferred4 = interruptWhenDeferred2;
var iterate4 = iterate3;
var make94 = make64;
var map34 = map28;
var mapAccum6 = mapAccum5;
var mapAccumEffect2 = mapAccumEffect;
var mapBoth7 = mapBoth6;
var mapChunks2 = mapChunks;
var mapChunksEffect2 = mapChunksEffect;
var mapConcat2 = mapConcat;
var mapConcatChunk2 = mapConcatChunk;
var mapConcatChunkEffect2 = mapConcatChunkEffect;
var mapConcatEffect2 = mapConcatEffect;
var mapEffect9 = mapEffectOptions;
var mapError10 = mapError8;
var mapErrorCause7 = mapErrorCause5;
var merge10 = merge9;
var mergeAll8 = mergeAll6;
var mergeWith4 = mergeWith2;
var mergeEither2 = mergeEither;
var mergeLeft2 = mergeLeft;
var mergeRight2 = mergeRight;
var mkString3 = mkString2;
var never11 = never7;
var onError4 = onError3;
var onDone2 = onDone;
var orDie8 = orDie6;
var orDieWith6 = orDieWith4;
var orElse18 = orElse11;
var orElseEither6 = orElseEither5;
var orElseFail4 = orElseFail3;
var orElseIfEmpty2 = orElseIfEmpty;
var orElseIfEmptyChunk2 = orElseIfEmptyChunk;
var orElseIfEmptyStream2 = orElseIfEmptyStream;
var orElseSucceed4 = orElseSucceed3;
var paginate2 = paginate;
var paginateChunk2 = paginateChunk;
var paginateChunkEffect2 = paginateChunkEffect;
var paginateEffect2 = paginateEffect;
var partition10 = partition9;
var partitionEither2 = partitionEither;
var peel2 = peel;
var pipeThrough2 = pipeThrough;
var pipeThroughChannel2 = pipeThroughChannel;
var pipeThroughChannelOrFail2 = pipeThroughChannelOrFail;
var prepend6 = prepend5;
var provideContext10 = provideContext6;
var provideLayer4 = provideLayer2;
var provideService10 = provideService8;
var provideServiceEffect4 = provideServiceEffect3;
var provideServiceStream2 = provideServiceStream;
var mapInputContext10 = mapInputContext6;
var provideSomeLayer5 = provideSomeLayer3;
var range3 = range2;
var rechunk2 = rechunk;
var refineOrDie3 = refineOrDie2;
var refineOrDieWith3 = refineOrDieWith2;
var repeat5 = repeat2;
var repeatEffect2 = repeatEffect;
var repeatEffectChunk2 = repeatEffectChunk;
var repeatEffectChunkOption2 = repeatEffectChunkOption;
var repeatEffectOption2 = repeatEffectOption;
var repeatEffectWithSchedule2 = repeatEffectWithSchedule;
var repeatEither2 = repeatEither;
var repeatElements2 = repeatElements;
var repeatElementsWith2 = repeatElementsWith;
var repeatValue2 = repeatValue;
var repeatWith2 = repeatWith;
var retry7 = retry4;
var run10 = run5;
var runCollect4 = runCollect2;
var runCount2 = runCount;
var runDrain4 = runDrain2;
var runFold2 = runFold;
var runFoldEffect2 = runFoldEffect;
var runFoldScoped2 = runFoldScoped;
var runFoldScopedEffect2 = runFoldScopedEffect;
var runFoldWhile2 = runFoldWhile;
var runFoldWhileEffect2 = runFoldWhileEffect;
var runFoldWhileScoped2 = runFoldWhileScoped;
var runFoldWhileScopedEffect2 = runFoldWhileScopedEffect;
var runForEach2 = runForEach;
var runForEachChunk2 = runForEachChunk;
var runForEachChunkScoped2 = runForEachChunkScoped;
var runForEachScoped2 = runForEachScoped;
var runForEachWhile2 = runForEachWhile;
var runForEachWhileScoped2 = runForEachWhileScoped;
var runHead2 = runHead;
var runIntoPubSub2 = runIntoPubSub;
var runIntoPubSubScoped2 = runIntoPubSubScoped;
var runIntoQueue2 = runIntoQueue;
var runIntoQueueElementsScoped2 = runIntoQueueElementsScoped;
var runIntoQueueScoped2 = runIntoQueueScoped;
var runLast2 = runLast;
var runScoped3 = runScoped2;
var runSum2 = runSum;
var scan2 = scan;
var scanEffect2 = scanEffect;
var scanReduce2 = scanReduce;
var scanReduceEffect2 = scanReduceEffect;
var schedule3 = schedule2;
var scheduleWith2 = scheduleWith;
var scoped8 = scoped6;
var sliding6 = sliding5;
var slidingSize2 = slidingSize;
var some11 = some10;
var someOrElse2 = someOrElse;
var someOrFail2 = someOrFail;
var split3 = split2;
var splitOnChunk2 = splitOnChunk;
var splitLines4 = splitLines2;
var succeed23 = succeed17;
var sync18 = sync12;
var suspend11 = suspend7;
var take8 = take7;
var takeRight3 = takeRight2;
var takeUntil4 = takeUntil3;
var takeUntilEffect2 = takeUntilEffect;
var takeWhile5 = takeWhile4;
var tap7 = tap6;
var tapBoth4 = tapBoth3;
var tapError6 = tapError5;
var tapErrorCause6 = tapErrorCause5;
var tapSink2 = tapSink;
var throttle2 = throttle;
var throttleEffect2 = throttleEffect;
var tick2 = tick;
var timeout4 = timeout3;
var timeoutFail4 = timeoutFail3;
var timeoutFailCause4 = timeoutFailCause3;
var timeoutTo4 = timeoutTo3;
var toPubSub4 = toPubSub2;
var toPull4 = toPull2;
var toQueue4 = toQueue2;
var toQueueOfElements2 = toQueueOfElements;
var toReadableStream2 = toReadableStream;
var transduce2 = transduce;
var unfold5 = unfold4;
var unfoldChunk2 = unfoldChunk;
var unfoldChunkEffect2 = unfoldChunkEffect;
var unfoldEffect2 = unfoldEffect;
var void_8 = void_6;
var unwrap8 = unwrap4;
var unwrapScoped7 = unwrapScoped5;
var updateService6 = updateService4;
var when6 = when3;
var whenCase2 = whenCase;
var whenCaseEffect2 = whenCaseEffect;
var whenEffect4 = whenEffect3;
var withSpan8 = withSpan6;
var zip21 = zip13;
var zipFlatten3 = zipFlatten2;
var zipAll2 = zipAll;
var zipAllLeft2 = zipAllLeft;
var zipAllRight2 = zipAllRight;
var zipAllSortedByKey2 = zipAllSortedByKey;
var zipAllSortedByKeyLeft2 = zipAllSortedByKeyLeft;
var zipAllSortedByKeyRight2 = zipAllSortedByKeyRight;
var zipAllSortedByKeyWith2 = zipAllSortedByKeyWith;
var zipAllWith2 = zipAllWith;
var zipLatest2 = zipLatest;
var zipLatestWith2 = zipLatestWith;
var zipLeft13 = zipLeft10;
var zipRight13 = zipRight10;
var zipWith15 = zipWith12;
var zipWithChunks2 = zipWithChunks;
var zipWithNext2 = zipWithNext;
var zipWithPrevious2 = zipWithPrevious;
var zipWithPreviousAndNext2 = zipWithPreviousAndNext;
var zipWithIndex2 = zipWithIndex;
var Do4 = Do3;
var bind4 = bind3;
var bindEffect2 = bindEffect;
var bindTo4 = bindTo3;
var let_4 = let_3;
var decodeText2 = decodeText;
var encodeText2 = encodeText;

// ../node_modules/effect/dist/esm/internal/stm/opCodes/stm.js
var OP_WITH_STM_RUNTIME = "WithSTMRuntime";
var OP_ON_FAILURE2 = "OnFailure";
var OP_ON_RETRY = "OnRetry";
var OP_ON_SUCCESS2 = "OnSuccess";
var OP_PROVIDE3 = "Provide";
var OP_SYNC2 = "Sync";
var OP_SUCCEED2 = "Succeed";
var OP_RETRY = "Retry";
var OP_FAIL4 = "Fail";
var OP_DIE2 = "Die";
var OP_INTERRUPT2 = "Interrupt";

// ../node_modules/effect/dist/esm/internal/stm/opCodes/tExit.js
var OP_FAIL5 = "Fail";
var OP_DIE3 = "Die";
var OP_INTERRUPT3 = "Interrupt";
var OP_SUCCEED3 = "Succeed";
var OP_RETRY2 = "Retry";

// ../node_modules/effect/dist/esm/internal/stm/opCodes/tryCommit.js
var OP_DONE5 = "Done";
var OP_SUSPEND3 = "Suspend";

// ../node_modules/effect/dist/esm/internal/stm/stm/versioned.js
var Versioned = class {
  constructor(value8) {
    __publicField(this, "value");
    this.value = value8;
  }
};

// ../node_modules/effect/dist/esm/internal/stm/stm/entry.js
var make95 = (ref, isNew) => ({
  ref,
  isNew,
  isChanged: false,
  expected: ref.versioned,
  newValue: ref.versioned.value
});
var unsafeGet10 = (self) => {
  return self.newValue;
};
var unsafeSet3 = (self, value8) => {
  self.isChanged = true;
  self.newValue = value8;
};
var commit = (self) => {
  self.ref.versioned = new Versioned(self.newValue);
};
var copy2 = (self) => ({
  ref: self.ref,
  isNew: self.isNew,
  isChanged: self.isChanged,
  expected: self.expected,
  newValue: self.newValue
});
var isInvalid = (self) => {
  return self.ref.versioned !== self.expected;
};
var isChanged = (self) => {
  return self.isChanged;
};

// ../node_modules/effect/dist/esm/internal/stm/stm/journal.js
var JournalAnalysisInvalid = "Invalid";
var JournalAnalysisReadWrite = "ReadWrite";
var JournalAnalysisReadOnly = "ReadOnly";
var commitJournal = (journal) => {
  for (const entry of journal) {
    commit(entry[1]);
  }
};
var analyzeJournal = (journal) => {
  let val = JournalAnalysisReadOnly;
  for (const [, entry] of journal) {
    val = isInvalid(entry) ? JournalAnalysisInvalid : isChanged(entry) ? JournalAnalysisReadWrite : val;
    if (val === JournalAnalysisInvalid) {
      return val;
    }
  }
  return val;
};
var prepareResetJournal = (journal) => {
  const saved = /* @__PURE__ */ new Map();
  for (const entry of journal) {
    saved.set(entry[0], copy2(entry[1]));
  }
  return () => {
    journal.clear();
    for (const entry of saved) {
      journal.set(entry[0], entry[1]);
    }
  };
};
var collectTodos = (journal) => {
  const allTodos = /* @__PURE__ */ new Map();
  for (const [, entry] of journal) {
    for (const todo of entry.ref.todos) {
      allTodos.set(todo[0], todo[1]);
    }
    entry.ref.todos = /* @__PURE__ */ new Map();
  }
  return allTodos;
};
var execTodos = (todos) => {
  const todosSorted = Array.from(todos.entries()).sort((x, y) => x[0] - y[0]);
  for (const [_, todo] of todosSorted) {
    todo();
  }
};
var addTodo = (txnId, journal, todoEffect) => {
  let added = false;
  for (const [, entry] of journal) {
    if (!entry.ref.todos.has(txnId)) {
      entry.ref.todos.set(txnId, todoEffect);
      added = true;
    }
  }
  return added;
};

// ../node_modules/effect/dist/esm/internal/stm/opCodes/stmState.js
var OP_DONE6 = "Done";
var OP_INTERRUPTED = "Interrupted";
var OP_RUNNING2 = "Running";

// ../node_modules/effect/dist/esm/internal/stm/stm/stmState.js
var STMStateSymbolKey = "effect/STM/State";
var STMStateTypeId = Symbol.for(STMStateSymbolKey);
var isSTMState = (u) => hasProperty(u, STMStateTypeId);
var isRunning3 = (self) => {
  return self._tag === OP_RUNNING2;
};
var isDone7 = (self) => {
  return self._tag === OP_DONE6;
};
var done10 = (exit3) => {
  return {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OP_DONE6,
    exit: exit3,
    [symbol2]() {
      return pipe(hash(STMStateSymbolKey), combine(hash(OP_DONE6)), combine(hash(exit3)), cached(this));
    },
    [symbol3](that) {
      return isSTMState(that) && that._tag === OP_DONE6 && equals(exit3, that.exit);
    }
  };
};
var interruptedHash = pipe(hash(STMStateSymbolKey), combine(hash(OP_INTERRUPTED)), combine(hash("interrupted")));
var interrupted3 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_INTERRUPTED,
  [symbol2]() {
    return interruptedHash;
  },
  [symbol3](that) {
    return isSTMState(that) && that._tag === OP_INTERRUPTED;
  }
};
var runningHash = pipe(hash(STMStateSymbolKey), combine(hash(OP_RUNNING2)), combine(hash("running")));
var running3 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_RUNNING2,
  [symbol2]() {
    return runningHash;
  },
  [symbol3](that) {
    return isSTMState(that) && that._tag === OP_RUNNING2;
  }
};
var fromTExit = (tExit) => {
  switch (tExit._tag) {
    case OP_FAIL5: {
      return done10(fail4(tExit.error));
    }
    case OP_DIE3: {
      return done10(die4(tExit.defect));
    }
    case OP_INTERRUPT3: {
      return done10(interrupt4(tExit.fiberId));
    }
    case OP_SUCCEED3: {
      return done10(succeed3(tExit.value));
    }
    case OP_RETRY2: {
      throw new Error("BUG: STM.STMState.fromTExit - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
  }
};

// ../node_modules/effect/dist/esm/internal/stm/stm/tExit.js
var TExitSymbolKey = "effect/TExit";
var TExitTypeId = Symbol.for(TExitSymbolKey);
var variance8 = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _E: (_) => _
};
var isExit2 = (u) => hasProperty(u, TExitTypeId);
var isSuccess5 = (self) => {
  return self._tag === OP_SUCCEED3;
};
var isRetry = (self) => {
  return self._tag === OP_RETRY2;
};
var fail21 = (error4) => ({
  [TExitTypeId]: variance8,
  _tag: OP_FAIL5,
  error: error4,
  [symbol2]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_FAIL5)), combine(hash(error4)), cached(this));
  },
  [symbol3](that) {
    return isExit2(that) && that._tag === OP_FAIL5 && equals(error4, that.error);
  }
});
var die13 = (defect) => ({
  [TExitTypeId]: variance8,
  _tag: OP_DIE3,
  defect,
  [symbol2]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_DIE3)), combine(hash(defect)), cached(this));
  },
  [symbol3](that) {
    return isExit2(that) && that._tag === OP_DIE3 && equals(defect, that.defect);
  }
});
var interrupt8 = (fiberId5) => ({
  [TExitTypeId]: variance8,
  _tag: OP_INTERRUPT3,
  fiberId: fiberId5,
  [symbol2]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_INTERRUPT3)), combine(hash(fiberId5)), cached(this));
  },
  [symbol3](that) {
    return isExit2(that) && that._tag === OP_INTERRUPT3 && equals(fiberId5, that.fiberId);
  }
});
var succeed24 = (value8) => ({
  [TExitTypeId]: variance8,
  _tag: OP_SUCCEED3,
  value: value8,
  [symbol2]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_SUCCEED3)), combine(hash(value8)), cached(this));
  },
  [symbol3](that) {
    return isExit2(that) && that._tag === OP_SUCCEED3 && equals(value8, that.value);
  }
});
var retryHash = pipe(hash(TExitSymbolKey), combine(hash(OP_RETRY2)), combine(hash("retry")));
var retry8 = {
  [TExitTypeId]: variance8,
  _tag: OP_RETRY2,
  [symbol2]() {
    return retryHash;
  },
  [symbol3](that) {
    return isExit2(that) && isRetry(that);
  }
};
var void_9 = succeed24(void 0);

// ../node_modules/effect/dist/esm/internal/stm/stm/tryCommit.js
var done11 = (exit3) => {
  return {
    _tag: OP_DONE5,
    exit: exit3
  };
};
var suspend12 = (journal) => {
  return {
    _tag: OP_SUSPEND3,
    journal
  };
};

// ../node_modules/effect/dist/esm/internal/stm/stm/txnId.js
var txnCounter = {
  ref: 0
};
var make96 = () => {
  const newId = txnCounter.ref + 1;
  txnCounter.ref = newId;
  return newId;
};

// ../node_modules/effect/dist/esm/internal/stm/core.js
var STMSymbolKey2 = "effect/STM";
var STMTypeId2 = Symbol.for(STMSymbolKey2);
var stmVariance = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var _a66, _b17, _c2, _d;
var STMPrimitive = class {
  constructor(effect_instruction_i0) {
    __publicField(this, "effect_instruction_i0");
    __publicField(this, "_tag", OP_COMMIT);
    __publicField(this, "_op", OP_COMMIT);
    __publicField(this, "effect_instruction_i1");
    __publicField(this, "effect_instruction_i2");
    __publicField(this, _a66);
    __publicField(this, _b17);
    __publicField(this, _c2);
    __publicField(this, _d);
    this.effect_instruction_i0 = effect_instruction_i0;
    this[EffectTypeId4] = effectVariance;
    this[StreamTypeId4] = stmVariance;
    this[SinkTypeId3] = stmVariance;
    this[ChannelTypeId3] = stmVariance;
  }
  get [(_a66 = EffectTypeId4, _b17 = StreamTypeId4, _c2 = SinkTypeId3, _d = ChannelTypeId3, STMTypeId2)]() {
    return stmVariance;
  }
  [symbol3](that) {
    return this === that;
  }
  [symbol2]() {
    return cached(this, random(this));
  }
  commit() {
    return unsafeAtomically(this, constVoid, constVoid);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isSTM = (u) => hasProperty(u, STMTypeId2);
var commit2 = (self) => unsafeAtomically(self, constVoid, constVoid);
var unsafeAtomically = (self, onDone3, onInterrupt3) => withFiberRuntime((state) => {
  const fiberId5 = state.id();
  const env = state.getFiberRef(currentContext2);
  const scheduler = state.getFiberRef(currentScheduler2);
  const priority = state.getFiberRef(currentSchedulingPriority2);
  const commitResult = tryCommitSync(fiberId5, self, env, scheduler, priority);
  switch (commitResult._tag) {
    case OP_DONE5: {
      onDone3(commitResult.exit);
      return commitResult.exit;
    }
    case OP_SUSPEND3: {
      const txnId = make96();
      const state2 = {
        value: running3
      };
      const effect4 = async2((k) => tryCommitAsync(fiberId5, self, txnId, state2, env, scheduler, priority, k));
      return uninterruptibleMask2((restore) => pipe(restore(effect4), catchAllCause3((cause3) => {
        let currentState = state2.value;
        if (isRunning3(currentState)) {
          state2.value = interrupted3;
        }
        currentState = state2.value;
        if (isDone7(currentState)) {
          onDone3(currentState.exit);
          return currentState.exit;
        }
        onInterrupt3();
        return failCause9(cause3);
      })));
    }
  }
});
var tryCommit = (fiberId5, stm, state, env, scheduler, priority) => {
  const journal = /* @__PURE__ */ new Map();
  const tExit = new STMDriver(stm, journal, fiberId5, env).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommit - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      state.value = fromTExit(tExit);
      return completeTodos(succeed3(tExit.value), journal, scheduler, priority);
    }
    case OP_FAIL5: {
      state.value = fromTExit(tExit);
      const cause3 = fail7(tExit.error);
      return completeTodos(failCause3(cause3), journal, scheduler, priority);
    }
    case OP_DIE3: {
      state.value = fromTExit(tExit);
      const cause3 = die5(tExit.defect);
      return completeTodos(failCause3(cause3), journal, scheduler, priority);
    }
    case OP_INTERRUPT3: {
      state.value = fromTExit(tExit);
      const cause3 = interrupt5(fiberId5);
      return completeTodos(failCause3(cause3), journal, scheduler, priority);
    }
    case OP_RETRY2: {
      return suspend12(journal);
    }
  }
};
var tryCommitSync = (fiberId5, stm, env, scheduler, priority) => {
  const journal = /* @__PURE__ */ new Map();
  const tExit = new STMDriver(stm, journal, fiberId5, env).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite && isSuccess5(tExit)) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommitSync - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      return completeTodos(succeed3(tExit.value), journal, scheduler, priority);
    }
    case OP_FAIL5: {
      const cause3 = fail7(tExit.error);
      return completeTodos(failCause3(cause3), journal, scheduler, priority);
    }
    case OP_DIE3: {
      const cause3 = die5(tExit.defect);
      return completeTodos(failCause3(cause3), journal, scheduler, priority);
    }
    case OP_INTERRUPT3: {
      const cause3 = interrupt5(fiberId5);
      return completeTodos(failCause3(cause3), journal, scheduler, priority);
    }
    case OP_RETRY2: {
      return suspend12(journal);
    }
  }
};
var tryCommitAsync = (fiberId5, self, txnId, state, context13, scheduler, priority, k) => {
  if (isRunning3(state.value)) {
    const result = tryCommit(fiberId5, self, state, context13, scheduler, priority);
    switch (result._tag) {
      case OP_DONE5: {
        completeTryCommit(result.exit, k);
        break;
      }
      case OP_SUSPEND3: {
        addTodo(txnId, result.journal, () => tryCommitAsync(fiberId5, self, txnId, state, context13, scheduler, priority, k));
        break;
      }
    }
  }
};
var completeTodos = (exit3, journal, scheduler, priority) => {
  const todos = collectTodos(journal);
  if (todos.size > 0) {
    scheduler.scheduleTask(() => execTodos(todos), priority);
  }
  return done11(exit3);
};
var completeTryCommit = (exit3, k) => {
  k(exit3);
};
var context10 = () => effect3((_, __, env) => env);
var contextWith8 = (f) => map35(context10(), f);
var contextWithSTM = (f) => flatMap22(context10(), f);
var STMDriver = class {
  constructor(self, journal, fiberId5, r0) {
    __publicField(this, "self");
    __publicField(this, "journal");
    __publicField(this, "fiberId");
    __publicField(this, "contStack", []);
    __publicField(this, "env");
    this.self = self;
    this.journal = journal;
    this.fiberId = fiberId5;
    this.env = r0;
  }
  getEnv() {
    return this.env;
  }
  pushStack(cont) {
    this.contStack.push(cont);
  }
  popStack() {
    return this.contStack.pop();
  }
  nextSuccess() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_SUCCESS2) {
      current2 = this.popStack();
    }
    return current2;
  }
  nextFailure() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_FAILURE2) {
      current2 = this.popStack();
    }
    return current2;
  }
  nextRetry() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_RETRY) {
      current2 = this.popStack();
    }
    return current2;
  }
  run() {
    let curr = this.self;
    let exit3 = void 0;
    while (exit3 === void 0 && curr !== void 0) {
      try {
        const current2 = curr;
        if (current2) {
          switch (current2._tag) {
            case "Tag": {
              curr = effect3((_, __, env) => unsafeGet3(env, current2));
              break;
            }
            case "Left": {
              curr = fail22(current2.left);
              break;
            }
            case "None": {
              curr = fail22(new NoSuchElementException2());
              break;
            }
            case "Right": {
              curr = succeed25(current2.right);
              break;
            }
            case "Some": {
              curr = succeed25(current2.value);
              break;
            }
            case "Commit": {
              switch (current2.effect_instruction_i0) {
                case OP_DIE2: {
                  exit3 = die13(current2.effect_instruction_i1());
                  break;
                }
                case OP_FAIL4: {
                  const cont = this.nextFailure();
                  if (cont === void 0) {
                    exit3 = fail21(current2.effect_instruction_i1());
                  } else {
                    curr = cont.effect_instruction_i2(current2.effect_instruction_i1());
                  }
                  break;
                }
                case OP_RETRY: {
                  const cont = this.nextRetry();
                  if (cont === void 0) {
                    exit3 = retry8;
                  } else {
                    curr = cont.effect_instruction_i2();
                  }
                  break;
                }
                case OP_INTERRUPT2: {
                  exit3 = interrupt8(this.fiberId);
                  break;
                }
                case OP_WITH_STM_RUNTIME: {
                  curr = current2.effect_instruction_i1(this);
                  break;
                }
                case OP_ON_SUCCESS2:
                case OP_ON_FAILURE2:
                case OP_ON_RETRY: {
                  this.pushStack(current2);
                  curr = current2.effect_instruction_i1;
                  break;
                }
                case OP_PROVIDE3: {
                  const env = this.env;
                  this.env = current2.effect_instruction_i2(env);
                  curr = pipe(current2.effect_instruction_i1, ensuring10(sync19(() => this.env = env)));
                  break;
                }
                case OP_SUCCEED2: {
                  const value8 = current2.effect_instruction_i1;
                  const cont = this.nextSuccess();
                  if (cont === void 0) {
                    exit3 = succeed24(value8);
                  } else {
                    curr = cont.effect_instruction_i2(value8);
                  }
                  break;
                }
                case OP_SYNC2: {
                  const value8 = current2.effect_instruction_i1();
                  const cont = this.nextSuccess();
                  if (cont === void 0) {
                    exit3 = succeed24(value8);
                  } else {
                    curr = cont.effect_instruction_i2(value8);
                  }
                  break;
                }
              }
              break;
            }
          }
        }
      } catch (e) {
        curr = die14(e);
      }
    }
    return exit3;
  }
};
var catchAll9 = dual(2, (self, f) => {
  const stm = new STMPrimitive(OP_ON_FAILURE2);
  stm.effect_instruction_i1 = self;
  stm.effect_instruction_i2 = f;
  return stm;
});
var mapInputContext11 = dual(2, (self, f) => {
  const stm = new STMPrimitive(OP_PROVIDE3);
  stm.effect_instruction_i1 = self;
  stm.effect_instruction_i2 = f;
  return stm;
});
var die14 = (defect) => dieSync9(() => defect);
var dieMessage7 = (message) => dieSync9(() => new RuntimeException2(message));
var dieSync9 = (evaluate3) => {
  const stm = new STMPrimitive(OP_DIE2);
  stm.effect_instruction_i1 = evaluate3;
  return stm;
};
var effect3 = (f) => withSTMRuntime((_) => succeed25(f(_.journal, _.fiberId, _.getEnv())));
var ensuring10 = dual(2, (self, finalizer3) => matchSTM(self, {
  onFailure: (e) => zipRight14(finalizer3, fail22(e)),
  onSuccess: (a) => zipRight14(finalizer3, succeed25(a))
}));
var fail22 = (error4) => failSync11(() => error4);
var failSync11 = (evaluate3) => {
  const stm = new STMPrimitive(OP_FAIL4);
  stm.effect_instruction_i1 = evaluate3;
  return stm;
};
var flatMap22 = dual(2, (self, f) => {
  const stm = new STMPrimitive(OP_ON_SUCCESS2);
  stm.effect_instruction_i1 = self;
  stm.effect_instruction_i2 = f;
  return stm;
});
var matchSTM = dual(2, (self, {
  onFailure,
  onSuccess
}) => pipe(self, map35(right), catchAll9((e) => pipe(onFailure(e), map35(left))), flatMap22((either13) => {
  switch (either13._tag) {
    case "Left": {
      return succeed25(either13.left);
    }
    case "Right": {
      return onSuccess(either13.right);
    }
  }
})));
var withSTMRuntime = (f) => {
  const stm = new STMPrimitive(OP_WITH_STM_RUNTIME);
  stm.effect_instruction_i1 = f;
  return stm;
};
var interrupt9 = withSTMRuntime((_) => {
  const stm = new STMPrimitive(OP_INTERRUPT2);
  stm.effect_instruction_i1 = _.fiberId;
  return stm;
});
var interruptAs2 = (fiberId5) => {
  const stm = new STMPrimitive(OP_INTERRUPT2);
  stm.effect_instruction_i1 = fiberId5;
  return stm;
};
var map35 = dual(2, (self, f) => pipe(self, flatMap22((a) => sync19(() => f(a)))));
var orTry = dual(2, (self, that) => {
  const stm = new STMPrimitive(OP_ON_RETRY);
  stm.effect_instruction_i1 = self;
  stm.effect_instruction_i2 = that;
  return stm;
});
var retry9 = new STMPrimitive(OP_RETRY);
var succeed25 = (value8) => {
  const stm = new STMPrimitive(OP_SUCCEED2);
  stm.effect_instruction_i1 = value8;
  return stm;
};
var sync19 = (evaluate3) => {
  const stm = new STMPrimitive(OP_SYNC2);
  stm.effect_instruction_i1 = evaluate3;
  return stm;
};
var zip22 = dual(2, (self, that) => pipe(self, zipWith16(that, (a, a1) => [a, a1])));
var zipLeft14 = dual(2, (self, that) => pipe(self, flatMap22((a) => pipe(that, map35(() => a)))));
var zipRight14 = dual(2, (self, that) => pipe(self, flatMap22(() => that)));
var zipWith16 = dual(3, (self, that, f) => pipe(self, flatMap22((a) => pipe(that, map35((b) => f(a, b))))));

// ../node_modules/effect/dist/esm/internal/stm/stm.js
var acquireUseRelease5 = dual(3, (acquire3, use2, release3) => uninterruptibleMask2((restore) => {
  let state = running3;
  return pipe(restore(unsafeAtomically(acquire3, (exit3) => {
    state = done10(exit3);
  }, () => {
    state = interrupted3;
  })), matchCauseEffect2({
    onFailure: (cause3) => {
      if (isDone7(state) && isSuccess(state.exit)) {
        return pipe(release3(state.exit.value), matchCauseEffect2({
          onFailure: (cause22) => failCause9(parallel4(cause3, cause22)),
          onSuccess: () => failCause9(cause3)
        }));
      }
      return failCause9(cause3);
    },
    onSuccess: (a) => pipe(restore(use2(a)), matchCauseEffect2({
      onFailure: (cause3) => pipe(release3(a), matchCauseEffect2({
        onFailure: (cause22) => failCause9(parallel4(cause3, cause22)),
        onSuccess: () => failCause9(cause3)
      })),
      onSuccess: (a2) => pipe(release3(a), as6(a2))
    }))
  }));
}));
var as13 = dual(2, (self, value8) => pipe(self, map35(() => value8)));
var asSome3 = (self) => pipe(self, map35(some2));
var asSomeError3 = (self) => pipe(self, mapError11(some2));
var asVoid8 = (self) => pipe(self, map35(constVoid));
var attempt = (evaluate3) => suspend13(() => {
  try {
    return succeed25(evaluate3());
  } catch (defect) {
    return fail22(defect);
  }
});
var bind5 = dual(3, (self, tag4, f) => flatMap22(self, (k) => map35(f(k), (a) => ({
  ...k,
  [tag4]: a
}))));
var bindTo5 = dual(2, (self, tag4) => map35(self, (a) => ({
  [tag4]: a
})));
var let_5 = dual(3, (self, tag4, f) => map35(self, (k) => ({
  ...k,
  [tag4]: f(k)
})));
var catchSome5 = dual(2, (self, pf) => catchAll9(self, (e) => getOrElse(pf(e), () => fail22(e))));
var catchTag5 = dual(3, (self, k, f) => catchAll9(self, (e) => {
  if ("_tag" in e && e["_tag"] === k) {
    return f(e);
  }
  return fail22(e);
}));
var catchTags5 = dual(2, (self, cases) => catchAll9(self, (e) => {
  const keys10 = Object.keys(cases);
  if ("_tag" in e && keys10.includes(e["_tag"])) {
    return cases[e["_tag"]](e);
  }
  return fail22(e);
}));
var check3 = (predicate) => suspend13(() => predicate() ? void_10 : retry9);
var collect3 = dual(2, (self, pf) => collectSTM(self, (a) => map2(pf(a), succeed25)));
var collectSTM = dual(2, (self, pf) => matchSTM(self, {
  onFailure: fail22,
  onSuccess: (a) => {
    const option9 = pf(a);
    return isSome(option9) ? option9.value : retry9;
  }
}));
var commitEither = (self) => flatten9(commit2(either11(self)));
var cond = (predicate, error4, result) => {
  return suspend13(() => predicate() ? sync19(result) : failSync11(error4));
};
var either11 = (self) => match33(self, {
  onFailure: left,
  onSuccess: right
});
var eventually3 = (self) => matchSTM(self, {
  onFailure: () => eventually3(self),
  onSuccess: succeed25
});
var every11 = dual(2, (iterable, predicate) => pipe(flatMap22(sync19(() => iterable[Symbol.iterator]()), (iterator) => {
  const loop5 = suspend13(() => {
    const next6 = iterator.next();
    if (next6.done) {
      return succeed25(true);
    }
    return pipe(predicate(next6.value), flatMap22((bool) => bool ? loop5 : succeed25(bool)));
  });
  return loop5;
})));
var exists4 = dual(2, (iterable, predicate) => flatMap22(sync19(() => iterable[Symbol.iterator]()), (iterator) => {
  const loop5 = suspend13(() => {
    const next6 = iterator.next();
    if (next6.done) {
      return succeed25(false);
    }
    return flatMap22(predicate(next6.value), (bool) => bool ? succeed25(bool) : loop5);
  });
  return loop5;
}));
var fiberId3 = effect3((_, fiberId5) => fiberId5);
var filter17 = dual(2, (iterable, predicate) => Array.from(iterable).reduce((acc, curr) => pipe(acc, zipWith16(predicate(curr), (as16, p) => {
  if (p) {
    as16.push(curr);
    return as16;
  }
  return as16;
})), succeed25([])));
var filterNot = dual(2, (iterable, predicate) => filter17(iterable, (a) => negate4(predicate(a))));
var filterOrDie3 = dual(3, (self, predicate, defect) => filterOrElse3(self, predicate, () => dieSync9(defect)));
var filterOrDieMessage3 = dual(3, (self, predicate, message) => filterOrElse3(self, predicate, () => dieMessage7(message)));
var filterOrElse3 = dual(3, (self, predicate, orElse22) => flatMap22(self, (a) => predicate(a) ? succeed25(a) : orElse22(a)));
var filterOrFail3 = dual(3, (self, predicate, orFailWith) => filterOrElse3(self, predicate, (a) => failSync11(() => orFailWith(a))));
var flatten15 = (self) => flatMap22(self, identity);
var flip3 = (self) => matchSTM(self, {
  onFailure: succeed25,
  onSuccess: fail22
});
var flipWith3 = dual(2, (self, f) => flip3(f(flip3(self))));
var match33 = dual(2, (self, {
  onFailure,
  onSuccess
}) => matchSTM(self, {
  onFailure: (e) => succeed25(onFailure(e)),
  onSuccess: (a) => succeed25(onSuccess(a))
}));
var forEach15 = dual((args) => isIterable(args[0]), (iterable, f, options) => {
  if (options == null ? void 0 : options.discard) {
    return pipe(sync19(() => iterable[Symbol.iterator]()), flatMap22((iterator) => {
      const loop5 = suspend13(() => {
        const next6 = iterator.next();
        if (next6.done) {
          return void_10;
        }
        return pipe(f(next6.value), flatMap22(() => loop5));
      });
      return loop5;
    }));
  }
  return suspend13(() => fromIterable(iterable).reduce((acc, curr) => zipWith16(acc, f(curr), (array6, elem) => {
    array6.push(elem);
    return array6;
  }), succeed25([])));
});
var fromEither4 = (either13) => {
  switch (either13._tag) {
    case "Left": {
      return fail22(either13.left);
    }
    case "Right": {
      return succeed25(either13.right);
    }
  }
};
var fromOption5 = (option9) => match2(option9, {
  onNone: () => fail22(none2()),
  onSome: succeed25
});
var STMGen = class {
  constructor(value8) {
    __publicField(this, "value");
    this.value = value8;
  }
  [Symbol.iterator]() {
    return new SingleShotGen(this);
  }
};
var adapter2 = function() {
  let x = arguments[0];
  for (let i = 1; i < arguments.length; i++) {
    x = arguments[i](x);
  }
  return new STMGen(x);
};
var gen3 = (f) => suspend13(() => {
  const iterator = f(adapter2);
  const state = iterator.next();
  const run11 = (state2) => state2.done ? succeed25(state2.value) : flatMap22(state2.value.value, (val) => run11(iterator.next(val)));
  return run11(state);
});
var head8 = (self) => pipe(self, matchSTM({
  onFailure: (e) => fail22(some2(e)),
  onSuccess: (a) => {
    const i = a[Symbol.iterator]();
    const res = i.next();
    if (res.done) {
      return fail22(none2());
    } else {
      return succeed25(res.value);
    }
  }
}));
var if_3 = dual((args) => typeof args[0] === "boolean" || isSTM(args[0]), (self, {
  onFalse,
  onTrue
}) => {
  if (typeof self === "boolean") {
    return self ? onTrue : onFalse;
  }
  return flatMap22(self, (bool) => bool ? onTrue : onFalse);
});
var ignore3 = (self) => match33(self, {
  onFailure: () => void_10,
  onSuccess: () => void_10
});
var isFailure8 = (self) => match33(self, {
  onFailure: constTrue,
  onSuccess: constFalse
});
var isSuccess6 = (self) => match33(self, {
  onFailure: constFalse,
  onSuccess: constTrue
});
var iterate5 = (initial, options) => iterateLoop(initial, options.while, options.body);
var iterateLoop = (initial, cont, body) => {
  if (cont(initial)) {
    return pipe(body(initial), flatMap22((z) => iterateLoop(z, cont, body)));
  }
  return succeed25(initial);
};
var loop3 = (initial, options) => options.discard ? loopDiscardLoop(initial, options.while, options.step, options.body) : map35(loopLoop(initial, options.while, options.step, options.body), (a) => Array.from(a));
var loopLoop = (initial, cont, inc, body) => {
  if (cont(initial)) {
    return pipe(body(initial), flatMap22((a) => pipe(loopLoop(inc(initial), cont, inc, body), map35(append2(a)))));
  }
  return succeed25(empty5());
};
var loopDiscardLoop = (initial, cont, inc, body) => {
  if (cont(initial)) {
    return pipe(body(initial), flatMap22(() => loopDiscardLoop(inc(initial), cont, inc, body)));
  }
  return void_10;
};
var mapAttempt3 = dual(2, (self, f) => matchSTM(self, {
  onFailure: (e) => fail22(e),
  onSuccess: (a) => attempt(() => f(a))
}));
var mapBoth8 = dual(2, (self, {
  onFailure,
  onSuccess
}) => matchSTM(self, {
  onFailure: (e) => fail22(onFailure(e)),
  onSuccess: (a) => succeed25(onSuccess(a))
}));
var mapError11 = dual(2, (self, f) => matchSTM(self, {
  onFailure: (e) => fail22(f(e)),
  onSuccess: succeed25
}));
var merge11 = (self) => matchSTM(self, {
  onFailure: (e) => succeed25(e),
  onSuccess: succeed25
});
var mergeAll9 = dual(3, (iterable, zero3, f) => suspend13(() => Array.from(iterable).reduce((acc, curr) => pipe(acc, zipWith16(curr, f)), succeed25(zero3))));
var negate4 = (self) => pipe(self, map35((b) => !b));
var none12 = (self) => matchSTM(self, {
  onFailure: (e) => fail22(some2(e)),
  onSuccess: match2({
    onNone: () => void_10,
    onSome: () => fail22(none2())
  })
});
var option7 = (self) => match33(self, {
  onFailure: () => none2(),
  onSuccess: some2
});
var orDie9 = (self) => pipe(self, orDieWith7(identity));
var orDieWith7 = dual(2, (self, f) => pipe(self, mapError11(f), catchAll9(die14)));
var orElse19 = dual(2, (self, that) => flatMap22(effect3((journal) => prepareResetJournal(journal)), (reset3) => pipe(orTry(self, () => flatMap22(sync19(reset3), that)), catchAll9(() => flatMap22(sync19(reset3), that)))));
var orElseEither7 = dual(2, (self, that) => orElse19(map35(self, left), () => map35(that(), right)));
var orElseFail5 = dual(2, (self, error4) => orElse19(self, () => failSync11(error4)));
var orElseOptional = dual(2, (self, that) => catchAll9(self, match2({
  onNone: that,
  onSome: (e) => fail22(some2(e))
})));
var orElseSucceed5 = dual(2, (self, value8) => orElse19(self, () => sync19(value8)));
var provideContext11 = dual(2, (self, env) => mapInputContext11(self, (_) => env));
var provideSomeContext2 = dual(2, (self, context13) => mapInputContext11(self, (parent) => merge3(parent, context13)));
var provideService11 = dual(3, (self, tag4, resource) => provideServiceSTM(self, tag4, succeed25(resource)));
var provideServiceSTM = dual(3, (self, tag4, stm) => contextWithSTM((env) => flatMap22(stm, (service3) => provideContext11(self, add2(env, tag4, service3)))));
var reduce18 = dual(3, (iterable, zero3, f) => suspend13(() => Array.from(iterable).reduce((acc, curr) => pipe(acc, flatMap22((s) => f(s, curr))), succeed25(zero3))));
var reduceAll = dual(3, (iterable, initial, f) => suspend13(() => Array.from(iterable).reduce((acc, curr) => pipe(acc, zipWith16(curr, f)), initial)));
var reduceRight6 = dual(3, (iterable, zero3, f) => suspend13(() => Array.from(iterable).reduceRight((acc, curr) => pipe(acc, flatMap22((s) => f(s, curr))), succeed25(zero3))));
var refineOrDie4 = dual(2, (self, pf) => refineOrDieWith4(self, pf, identity));
var refineOrDieWith4 = dual(3, (self, pf, f) => catchAll9(self, (e) => match2(pf(e), {
  onNone: () => die14(f(e)),
  onSome: fail22
})));
var reject = dual(2, (self, pf) => rejectSTM(self, (a) => map2(pf(a), fail22)));
var rejectSTM = dual(2, (self, pf) => flatMap22(self, (a) => match2(pf(a), {
  onNone: () => succeed25(a),
  onSome: flatMap22(fail22)
})));
var repeatUntil = dual(2, (self, predicate) => repeatUntilLoop(self, predicate));
var repeatUntilLoop = (self, predicate) => flatMap22(self, (a) => predicate(a) ? succeed25(a) : repeatUntilLoop(self, predicate));
var repeatWhile = dual(2, (self, predicate) => repeatWhileLoop(self, predicate));
var repeatWhileLoop = (self, predicate) => pipe(flatMap22(self, (a) => predicate(a) ? repeatWhileLoop(self, predicate) : succeed25(a)));
var replicate3 = dual(2, (self, n) => Array.from({
  length: n
}, () => self));
var replicateSTM = dual(2, (self, n) => all10(replicate3(self, n)));
var replicateSTMDiscard = dual(2, (self, n) => all10(replicate3(self, n), {
  discard: true
}));
var retryUntil = dual(2, (self, predicate) => matchSTM(self, {
  onFailure: fail22,
  onSuccess: (a) => predicate(a) ? succeed25(a) : retry9
}));
var retryWhile = dual(2, (self, predicate) => matchSTM(self, {
  onFailure: fail22,
  onSuccess: (a) => !predicate(a) ? succeed25(a) : retry9
}));
var partition11 = dual(2, (elements, f) => pipe(forEach15(elements, (a) => either11(f(a))), map35((as16) => partitionMap4(as16, identity))));
var some12 = (self) => matchSTM(self, {
  onFailure: (e) => fail22(some2(e)),
  onSuccess: match2({
    onNone: () => fail22(none2()),
    onSome: succeed25
  })
});
var all10 = (input, options) => {
  if (Symbol.iterator in input) {
    return forEach15(input, identity, options);
  } else if (options == null ? void 0 : options.discard) {
    return forEach15(Object.values(input), identity, options);
  }
  return map35(forEach15(Object.entries(input), ([_, e]) => map35(e, (a) => [_, a])), (values13) => {
    const res = {};
    for (const [k, v] of values13) {
      ;
      res[k] = v;
    }
    return res;
  });
};
var succeedNone3 = succeed25(none2());
var succeedSome3 = (value8) => succeed25(some2(value8));
var summarized4 = dual(3, (self, summary11, f) => flatMap22(summary11, (start5) => flatMap22(self, (value8) => map35(summary11, (end7) => [f(start5, end7), value8]))));
var suspend13 = (evaluate3) => flatten15(sync19(evaluate3));
var tap8 = dual(2, (self, f) => flatMap22(self, (a) => as13(f(a), a)));
var tapBoth5 = dual(2, (self, {
  onFailure,
  onSuccess
}) => matchSTM(self, {
  onFailure: (e) => pipe(onFailure(e), zipRight14(fail22(e))),
  onSuccess: (a) => pipe(onSuccess(a), as13(a))
}));
var tapError7 = dual(2, (self, f) => matchSTM(self, {
  onFailure: (e) => zipRight14(f(e), fail22(e)),
  onSuccess: succeed25
}));
var try_3 = (arg) => {
  const evaluate3 = typeof arg === "function" ? arg : arg.try;
  return suspend13(() => {
    try {
      return succeed25(evaluate3());
    } catch (error4) {
      return fail22("catch" in arg ? arg.catch(error4) : error4);
    }
  });
};
var void_10 = succeed25(void 0);
var unless3 = dual(2, (self, predicate) => suspend13(() => predicate() ? succeedNone3 : asSome3(self)));
var unlessSTM = dual(2, (self, predicate) => flatMap22(predicate, (bool) => bool ? succeedNone3 : asSome3(self)));
var unsome2 = (self) => matchSTM(self, {
  onFailure: match2({
    onNone: () => succeed25(none2()),
    onSome: fail22
  }),
  onSuccess: (a) => succeed25(some2(a))
});
var validateAll3 = dual(2, (elements, f) => flatMap22(partition11(elements, f), ([errors2, values13]) => isNonEmptyArray(errors2) ? fail22(errors2) : succeed25(values13)));
var validateFirst3 = dual(2, (elements, f) => flip3(forEach15(elements, (a) => flip3(f(a)))));
var when7 = dual(2, (self, predicate) => suspend13(() => predicate() ? asSome3(self) : succeedNone3));
var whenSTM = dual(2, (self, predicate) => flatMap22(predicate, (bool) => bool ? asSome3(self) : succeedNone3));

// ../node_modules/effect/dist/esm/STM.js
var STMTypeId3 = STMTypeId2;
var isSTM2 = isSTM;
var acquireUseRelease6 = acquireUseRelease5;
var all11 = all10;
var as14 = as13;
var asSome4 = asSome3;
var asSomeError4 = asSomeError3;
var asVoid9 = asVoid8;
var attempt2 = attempt;
var catchAll10 = catchAll9;
var catchSome6 = catchSome5;
var catchTag6 = catchTag5;
var catchTags6 = catchTags5;
var check4 = check3;
var collect4 = collect3;
var collectSTM2 = collectSTM;
var commit3 = commit2;
var commitEither2 = commitEither;
var cond2 = cond;
var context11 = context10;
var contextWith9 = contextWith8;
var contextWithSTM2 = contextWithSTM;
var mapInputContext12 = mapInputContext11;
var die15 = die14;
var dieMessage8 = dieMessage7;
var dieSync10 = dieSync9;
var either12 = either11;
var ensuring11 = ensuring10;
var eventually4 = eventually3;
var every12 = every11;
var exists5 = exists4;
var fail23 = fail22;
var failSync12 = failSync11;
var fiberId4 = fiberId3;
var filter18 = filter17;
var filterNot2 = filterNot;
var filterOrDie4 = filterOrDie3;
var filterOrDieMessage4 = filterOrDieMessage3;
var filterOrElse4 = filterOrElse3;
var filterOrFail4 = filterOrFail3;
var flatMap23 = flatMap22;
var flatten16 = flatten15;
var flip4 = flip3;
var flipWith4 = flipWith3;
var match34 = match33;
var matchSTM2 = matchSTM;
var forEach16 = forEach15;
var fromEither5 = fromEither4;
var fromOption6 = fromOption5;
var gen4 = gen3;
var head9 = head8;
var if_4 = if_3;
var ignore4 = ignore3;
var interrupt10 = interrupt9;
var interruptAs3 = interruptAs2;
var isFailure9 = isFailure8;
var isSuccess7 = isSuccess6;
var iterate6 = iterate5;
var loop4 = loop3;
var map36 = map35;
var mapAttempt4 = mapAttempt3;
var mapBoth9 = mapBoth8;
var mapError12 = mapError11;
var merge12 = merge11;
var mergeAll10 = mergeAll9;
var negate5 = negate4;
var none13 = none12;
var option8 = option7;
var orDie10 = orDie9;
var orDieWith8 = orDieWith7;
var orElse20 = orElse19;
var orElseEither8 = orElseEither7;
var orElseFail6 = orElseFail5;
var orElseOptional2 = orElseOptional;
var orElseSucceed6 = orElseSucceed5;
var orTry2 = orTry;
var partition12 = partition11;
var provideContext12 = provideContext11;
var provideSomeContext3 = provideSomeContext2;
var provideService12 = provideService11;
var provideServiceSTM2 = provideServiceSTM;
var reduce19 = reduce18;
var reduceAll2 = reduceAll;
var reduceRight7 = reduceRight6;
var refineOrDie5 = refineOrDie4;
var refineOrDieWith5 = refineOrDieWith4;
var reject2 = reject;
var rejectSTM2 = rejectSTM;
var repeatUntil2 = repeatUntil;
var repeatWhile2 = repeatWhile;
var replicate4 = replicate3;
var replicateSTM2 = replicateSTM;
var replicateSTMDiscard2 = replicateSTMDiscard;
var retry10 = retry9;
var retryUntil2 = retryUntil;
var retryWhile2 = retryWhile;
var some13 = some12;
var succeed26 = succeed25;
var succeedNone4 = succeedNone3;
var succeedSome4 = succeedSome3;
var summarized5 = summarized4;
var suspend14 = suspend13;
var sync20 = sync19;
var tap9 = tap8;
var tapBoth6 = tapBoth5;
var tapError8 = tapError7;
var try_4 = try_3;
var unless4 = unless3;
var unlessSTM2 = unlessSTM;
var unsome3 = unsome2;
var void_11 = void_10;
var validateAll4 = validateAll3;
var validateFirst4 = validateFirst3;
var when8 = when7;
var whenSTM2 = whenSTM;
var zip23 = zip22;
var zipLeft15 = zipLeft14;
var zipRight15 = zipRight14;
var zipWith17 = zipWith16;
var firstSuccessOf3 = (effects) => suspend14(() => {
  const list = fromIterable2(effects);
  if (!isNonEmpty2(list)) {
    return dieSync10(() => new IllegalArgumentException2(`Received an empty collection of effects`));
  }
  return reduce2(tailNonEmpty2(list), headNonEmpty2(list), (left2, right2) => orElse20(left2, () => right2));
});
var Do5 = succeed26({});
var bind6 = bind5;
var let_6 = let_5;
var bindTo6 = bindTo5;

// ../node_modules/effect/dist/esm/ScopedCache.js
var ScopedCache_exports = {};
__export(ScopedCache_exports, {
  ScopedCacheTypeId: () => ScopedCacheTypeId2,
  make: () => make98,
  makeWith: () => makeWith8
});

// ../node_modules/effect/dist/esm/internal/scopedCache.js
var makeCacheState2 = (map43, keys10, accesses, updating, hits, misses) => ({
  map: map43,
  keys: keys10,
  accesses,
  updating,
  hits,
  misses
});
var initialCacheState2 = () => makeCacheState2(empty21(), makeKeySet(), unbounded(), make13(false), 0, 0);
var complete5 = (key, exit3, ownerCount, entryStats, timeToLive) => struct5({
  _tag: "Complete",
  key,
  exit: exit3,
  ownerCount,
  entryStats,
  timeToLive
});
var pending3 = (key, scoped9) => struct5({
  _tag: "Pending",
  key,
  scoped: scoped9
});
var refreshing2 = (scoped9, complete6) => struct5({
  _tag: "Refreshing",
  scoped: scoped9,
  complete: complete6
});
var toScoped = (self) => matchEffect2(self.exit, {
  onFailure: (cause3) => failCause(cause3),
  onSuccess: ([value8]) => acquireRelease(as2(sync(() => incrementAndGet(self.ownerCount)), value8), () => releaseOwner(self))
});
var releaseOwner = (self) => matchEffect2(self.exit, {
  onFailure: () => void_,
  onSuccess: ([, finalizer3]) => flatMap10(sync(() => decrementAndGet(self.ownerCount)), (numOwner) => when(finalizer3(void_2), () => numOwner === 0))
});
var ScopedCacheSymbolKey = "effect/ScopedCache";
var ScopedCacheTypeId = Symbol.for(ScopedCacheSymbolKey);
var scopedCacheVariance = {
  /* c8 ignore next */
  _Key: (_) => _,
  /* c8 ignore next */
  _Error: (_) => _,
  /* c8 ignore next */
  _Value: (_) => _
};
var _a67;
var ScopedCacheImpl = class {
  constructor(capacity10, scopedLookup, clock3, timeToLive, context13) {
    __publicField(this, "capacity");
    __publicField(this, "scopedLookup");
    __publicField(this, "clock");
    __publicField(this, "timeToLive");
    __publicField(this, "context");
    __publicField(this, _a67, scopedCacheVariance);
    __publicField(this, "cacheState");
    this.capacity = capacity10;
    this.scopedLookup = scopedLookup;
    this.clock = clock3;
    this.timeToLive = timeToLive;
    this.context = context13;
    this.cacheState = initialCacheState2();
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  get cacheStats() {
    return sync(() => makeCacheStats({
      hits: this.cacheState.hits,
      misses: this.cacheState.misses,
      size: size8(this.cacheState.map)
    }));
  }
  getOption(key) {
    return suspend(() => match2(get7(this.cacheState.map, key), {
      onNone: () => succeedNone,
      onSome: (value8) => flatten5(this.resolveMapValue(value8))
    }));
  }
  getOptionComplete(key) {
    return suspend(() => match2(get7(this.cacheState.map, key), {
      onNone: () => succeedNone,
      onSome: (value8) => flatten5(this.resolveMapValue(value8, true))
    }));
  }
  contains(key) {
    return sync(() => has5(this.cacheState.map, key));
  }
  entryStats(key) {
    return sync(() => {
      const value8 = getOrUndefined(get7(this.cacheState.map, key));
      if (value8 === void 0) {
        return none2();
      }
      switch (value8._tag) {
        case "Complete": {
          return some2(makeEntryStats(value8.entryStats.loadedMillis));
        }
        case "Pending": {
          return none2();
        }
        case "Refreshing": {
          return some2(makeEntryStats(value8.complete.entryStats.loadedMillis));
        }
      }
    });
  }
  get(key) {
    return pipe(this.lookupValueOf(key), memoize, flatMap10((lookupValue) => suspend(() => {
      let k = void 0;
      let value8 = getOrUndefined(get7(this.cacheState.map, key));
      if (value8 === void 0) {
        k = makeMapKey(key);
        if (has5(this.cacheState.map, key)) {
          value8 = getOrUndefined(get7(this.cacheState.map, key));
        } else {
          set4(this.cacheState.map, key, pending3(k, lookupValue));
        }
      }
      if (value8 === void 0) {
        this.trackMiss();
        return zipRight(this.ensureMapSizeNotExceeded(k), lookupValue);
      }
      return map11(this.resolveMapValue(value8), flatMap10(match2({
        onNone: () => {
          const val = value8;
          const current2 = getOrUndefined(get7(this.cacheState.map, key));
          if (equals(current2, value8)) {
            remove7(this.cacheState.map, key);
          }
          return pipe(this.ensureMapSizeNotExceeded(val.key), zipRight(releaseOwner(val)), zipRight(this.get(key)));
        },
        onSome: succeed
      })));
    })), flatten5);
  }
  invalidate(key) {
    return suspend(() => {
      if (has5(this.cacheState.map, key)) {
        const mapValue = getOrUndefined(get7(this.cacheState.map, key));
        remove7(this.cacheState.map, key);
        switch (mapValue._tag) {
          case "Complete": {
            return releaseOwner(mapValue);
          }
          case "Pending": {
            return void_;
          }
          case "Refreshing": {
            return releaseOwner(mapValue.complete);
          }
        }
      }
      return void_;
    });
  }
  get invalidateAll() {
    return forEachConcurrentDiscard(fromIterable5(Array.from(this.cacheState.map).map(([key]) => key)), (key) => this.invalidate(key), false, false);
  }
  refresh(key) {
    return pipe(this.lookupValueOf(key), memoize, flatMap10((scoped9) => {
      let value8 = getOrUndefined(get7(this.cacheState.map, key));
      let newKey = void 0;
      if (value8 === void 0) {
        newKey = makeMapKey(key);
        if (has5(this.cacheState.map, key)) {
          value8 = getOrUndefined(get7(this.cacheState.map, key));
        } else {
          set4(this.cacheState.map, key, pending3(newKey, scoped9));
        }
      }
      let finalScoped;
      if (value8 === void 0) {
        finalScoped = zipRight(this.ensureMapSizeNotExceeded(newKey), scoped9);
      } else {
        switch (value8._tag) {
          case "Complete": {
            if (this.hasExpired(value8.timeToLive)) {
              finalScoped = succeed(this.get(key));
            } else {
              const current2 = getOrUndefined(get7(this.cacheState.map, key));
              if (equals(current2, value8)) {
                const mapValue = refreshing2(scoped9, value8);
                set4(this.cacheState.map, key, mapValue);
                finalScoped = scoped9;
              } else {
                finalScoped = succeed(this.get(key));
              }
            }
            break;
          }
          case "Pending": {
            finalScoped = value8.scoped;
            break;
          }
          case "Refreshing": {
            finalScoped = value8.scoped;
            break;
          }
        }
      }
      return flatMap10(finalScoped, (s) => scopedEffect(asVoid(s)));
    }));
  }
  get size() {
    return sync(() => size8(this.cacheState.map));
  }
  resolveMapValue(value8, ignorePending = false) {
    switch (value8._tag) {
      case "Complete": {
        this.trackHit();
        if (this.hasExpired(value8.timeToLive)) {
          return succeed(succeedNone);
        }
        return as2(this.ensureMapSizeNotExceeded(value8.key), asSome(toScoped(value8)));
      }
      case "Pending": {
        this.trackHit();
        if (ignorePending) {
          return succeed(succeedNone);
        }
        return zipRight(this.ensureMapSizeNotExceeded(value8.key), map11(value8.scoped, asSome));
      }
      case "Refreshing": {
        this.trackHit();
        if (this.hasExpired(value8.complete.timeToLive)) {
          if (ignorePending) {
            return succeed(succeedNone);
          }
          return zipRight(this.ensureMapSizeNotExceeded(value8.complete.key), map11(value8.scoped, asSome));
        }
        return as2(this.ensureMapSizeNotExceeded(value8.complete.key), asSome(toScoped(value8.complete)));
      }
    }
  }
  lookupValueOf(key) {
    return pipe(onInterrupt(flatMap10(make54(), (scope5) => pipe(this.scopedLookup(key), provideContext(pipe(this.context, add2(Scope, scope5))), exit, map11((exit3) => [exit3, (exit4) => close(scope5, exit4)]))), () => sync(() => remove7(this.cacheState.map, key))), flatMap10(([exit3, release3]) => {
      const now = this.clock.unsafeCurrentTimeMillis();
      const expiredAt = now + toMillis(this.timeToLive(exit3));
      switch (exit3._tag) {
        case "Success": {
          const exitWithFinalizer = succeed3([exit3.value, release3]);
          const completedResult = complete5(makeMapKey(key), exitWithFinalizer, make13(1), makeEntryStats(now), expiredAt);
          let previousValue = void 0;
          if (has5(this.cacheState.map, key)) {
            previousValue = getOrUndefined(get7(this.cacheState.map, key));
          }
          set4(this.cacheState.map, key, completedResult);
          return sync(() => flatten5(as2(this.cleanMapValue(previousValue), toScoped(completedResult))));
        }
        case "Failure": {
          const completedResult = complete5(makeMapKey(key), exit3, make13(0), makeEntryStats(now), expiredAt);
          let previousValue = void 0;
          if (has5(this.cacheState.map, key)) {
            previousValue = getOrUndefined(get7(this.cacheState.map, key));
          }
          set4(this.cacheState.map, key, completedResult);
          return zipRight(release3(exit3), sync(() => flatten5(as2(this.cleanMapValue(previousValue), toScoped(completedResult)))));
        }
      }
    }), memoize, flatten5);
  }
  hasExpired(timeToLive) {
    return this.clock.unsafeCurrentTimeMillis() > timeToLive;
  }
  trackHit() {
    this.cacheState.hits = this.cacheState.hits + 1;
  }
  trackMiss() {
    this.cacheState.misses = this.cacheState.misses + 1;
  }
  trackAccess(key) {
    const cleanedKeys = [];
    offer(this.cacheState.accesses, key);
    if (compareAndSet(this.cacheState.updating, false, true)) {
      let loop5 = true;
      while (loop5) {
        const key2 = poll2(this.cacheState.accesses, EmptyMutableQueue);
        if (key2 === EmptyMutableQueue) {
          loop5 = false;
        } else {
          this.cacheState.keys.add(key2);
        }
      }
      let size38 = size8(this.cacheState.map);
      loop5 = size38 > this.capacity;
      while (loop5) {
        const key2 = this.cacheState.keys.remove();
        if (key2 === void 0) {
          loop5 = false;
        } else {
          if (has5(this.cacheState.map, key2.current)) {
            const removed = getOrUndefined(get7(this.cacheState.map, key2.current));
            remove7(this.cacheState.map, key2.current);
            size38 = size38 - 1;
            cleanedKeys.push(removed);
            loop5 = size38 > this.capacity;
          }
        }
      }
      set2(this.cacheState.updating, false);
    }
    return cleanedKeys;
  }
  cleanMapValue(mapValue) {
    if (mapValue === void 0) {
      return void_;
    }
    switch (mapValue._tag) {
      case "Complete": {
        return releaseOwner(mapValue);
      }
      case "Pending": {
        return void_;
      }
      case "Refreshing": {
        return releaseOwner(mapValue.complete);
      }
    }
  }
  ensureMapSizeNotExceeded(key) {
    return forEachConcurrentDiscard(this.trackAccess(key), (cleanedMapValue) => this.cleanMapValue(cleanedMapValue), false, false);
  }
};
_a67 = ScopedCacheTypeId;
var make97 = (options) => {
  const timeToLive = decode(options.timeToLive);
  return makeWith7({
    capacity: options.capacity,
    lookup: options.lookup,
    timeToLive: () => timeToLive
  });
};
var makeWith7 = (options) => flatMap10(clock, (clock3) => buildWith(options.capacity, options.lookup, clock3, (exit3) => decode(options.timeToLive(exit3))));
var buildWith = (capacity10, scopedLookup, clock3, timeToLive) => acquireRelease(flatMap10(context(), (context13) => sync(() => new ScopedCacheImpl(capacity10, scopedLookup, clock3, timeToLive, context13))), (cache) => cache.invalidateAll);

// ../node_modules/effect/dist/esm/ScopedCache.js
var ScopedCacheTypeId2 = ScopedCacheTypeId;
var make98 = make97;
var makeWith8 = makeWith7;

// ../node_modules/effect/dist/esm/ScopedRef.js
var ScopedRef_exports = {};
__export(ScopedRef_exports, {
  ScopedRefTypeId: () => ScopedRefTypeId2,
  fromAcquire: () => fromAcquire2,
  get: () => get24,
  make: () => make99,
  set: () => set13
});
var ScopedRefTypeId2 = ScopedRefTypeId;
var fromAcquire2 = fromAcquire;
var get24 = get19;
var make99 = make90;
var set13 = set12;

// ../node_modules/effect/dist/esm/Secret.js
var Secret_exports = {};
__export(Secret_exports, {
  SecretTypeId: () => SecretTypeId2,
  fromIterable: () => fromIterable21,
  fromString: () => fromString4,
  isSecret: () => isSecret2,
  make: () => make100,
  unsafeWipe: () => unsafeWipe2,
  value: () => value7
});
var SecretTypeId2 = SecretTypeId;
var isSecret2 = isSecret;
var make100 = make65;
var fromIterable21 = fromIterable17;
var fromString4 = fromString3;
var value7 = value2;
var unsafeWipe2 = unsafeWipe;

// ../node_modules/effect/dist/esm/SingleProducerAsyncInput.js
var SingleProducerAsyncInput_exports = {};
__export(SingleProducerAsyncInput_exports, {
  make: () => make101
});
var make101 = make59;

// ../node_modules/effect/dist/esm/Sink.js
var Sink_exports = {};
__export(Sink_exports, {
  SinkTypeId: () => SinkTypeId4,
  as: () => as15,
  collectAll: () => collectAll4,
  collectAllFrom: () => collectAllFrom2,
  collectAllN: () => collectAllN2,
  collectAllToMap: () => collectAllToMap2,
  collectAllToMapN: () => collectAllToMapN2,
  collectAllToSet: () => collectAllToSet2,
  collectAllToSetN: () => collectAllToSetN2,
  collectAllUntil: () => collectAllUntil2,
  collectAllUntilEffect: () => collectAllUntilEffect2,
  collectAllWhile: () => collectAllWhile2,
  collectAllWhileEffect: () => collectAllWhileEffect2,
  collectAllWhileWith: () => collectAllWhileWith2,
  collectLeftover: () => collectLeftover2,
  context: () => context12,
  contextWith: () => contextWith10,
  contextWithEffect: () => contextWithEffect8,
  contextWithSink: () => contextWithSink2,
  count: () => count6,
  die: () => die16,
  dieMessage: () => dieMessage9,
  dieSync: () => dieSync11,
  dimap: () => dimap2,
  dimapChunks: () => dimapChunks2,
  dimapChunksEffect: () => dimapChunksEffect2,
  dimapEffect: () => dimapEffect2,
  drain: () => drain6,
  drop: () => drop7,
  dropUntil: () => dropUntil6,
  dropUntilEffect: () => dropUntilEffect4,
  dropWhile: () => dropWhile7,
  dropWhileEffect: () => dropWhileEffect4,
  ensuring: () => ensuring12,
  ensuringWith: () => ensuringWith6,
  every: () => every13,
  fail: () => fail24,
  failCause: () => failCause18,
  failCauseSync: () => failCauseSync11,
  failSync: () => failSync13,
  filterInput: () => filterInput2,
  filterInputEffect: () => filterInputEffect2,
  findEffect: () => findEffect4,
  flatMap: () => flatMap24,
  fold: () => fold2,
  foldChunks: () => foldChunks2,
  foldChunksEffect: () => foldChunksEffect2,
  foldEffect: () => foldEffect2,
  foldLeft: () => foldLeft2,
  foldLeftChunks: () => foldLeftChunks2,
  foldLeftChunksEffect: () => foldLeftChunksEffect2,
  foldLeftEffect: () => foldLeftEffect2,
  foldSink: () => foldSink2,
  foldUntil: () => foldUntil2,
  foldUntilEffect: () => foldUntilEffect2,
  foldWeighted: () => foldWeighted2,
  foldWeightedDecompose: () => foldWeightedDecompose2,
  foldWeightedDecomposeEffect: () => foldWeightedDecomposeEffect2,
  foldWeightedEffect: () => foldWeightedEffect2,
  forEach: () => forEach17,
  forEachChunk: () => forEachChunk2,
  forEachChunkWhile: () => forEachChunkWhile2,
  forEachWhile: () => forEachWhile2,
  fromChannel: () => fromChannel4,
  fromEffect: () => fromEffect14,
  fromPubSub: () => fromPubSub6,
  fromPush: () => fromPush2,
  fromQueue: () => fromQueue6,
  head: () => head10,
  ignoreLeftover: () => ignoreLeftover2,
  last: () => last7,
  leftover: () => leftover2,
  map: () => map37,
  mapEffect: () => mapEffect10,
  mapError: () => mapError13,
  mapInput: () => mapInput12,
  mapInputChunks: () => mapInputChunks2,
  mapInputChunksEffect: () => mapInputChunksEffect2,
  mapInputEffect: () => mapInputEffect6,
  mapLeftover: () => mapLeftover2,
  mkString: () => mkString4,
  never: () => never12,
  orElse: () => orElse21,
  provideContext: () => provideContext13,
  race: () => race6,
  raceBoth: () => raceBoth2,
  raceWith: () => raceWith4,
  refineOrDie: () => refineOrDie6,
  refineOrDieWith: () => refineOrDieWith6,
  some: () => some14,
  splitWhere: () => splitWhere3,
  succeed: () => succeed27,
  sum: () => sum5,
  summarized: () => summarized6,
  suspend: () => suspend15,
  sync: () => sync21,
  take: () => take9,
  timed: () => timed4,
  toChannel: () => toChannel4,
  unwrap: () => unwrap9,
  unwrapScoped: () => unwrapScoped8,
  withDuration: () => withDuration2,
  zip: () => zip24,
  zipLeft: () => zipLeft16,
  zipRight: () => zipRight16,
  zipWith: () => zipWith18
});
var SinkTypeId4 = SinkTypeId3;
var as15 = as8;
var collectAll4 = collectAll;
var collectAllN2 = collectAllN;
var collectAllFrom2 = collectAllFrom;
var collectAllToMap2 = collectAllToMap;
var collectAllToMapN2 = collectAllToMapN;
var collectAllToSet2 = collectAllToSet;
var collectAllToSetN2 = collectAllToSetN;
var collectAllUntil2 = collectAllUntil;
var collectAllUntilEffect2 = collectAllUntilEffect;
var collectAllWhile2 = collectAllWhile;
var collectAllWhileEffect2 = collectAllWhileEffect;
var collectAllWhileWith2 = collectAllWhileWith;
var collectLeftover2 = collectLeftover;
var mapInput12 = mapInput7;
var mapInputEffect6 = mapInputEffect3;
var mapInputChunks2 = mapInputChunks;
var mapInputChunksEffect2 = mapInputChunksEffect;
var count6 = count3;
var die16 = die9;
var dieMessage9 = dieMessage3;
var dieSync11 = dieSync6;
var dimap2 = dimap;
var dimapEffect2 = dimapEffect;
var dimapChunks2 = dimapChunks;
var dimapChunksEffect2 = dimapChunksEffect;
var drain6 = drain2;
var drop7 = drop4;
var dropUntil6 = dropUntil3;
var dropUntilEffect4 = dropUntilEffect;
var dropWhile7 = dropWhile4;
var dropWhileEffect4 = dropWhileEffect;
var ensuring12 = ensuring5;
var ensuringWith6 = ensuringWith2;
var context12 = context6;
var contextWith10 = contextWith4;
var contextWithEffect8 = contextWithEffect4;
var contextWithSink2 = contextWithSink;
var every13 = every10;
var fail24 = fail14;
var failSync13 = failSync7;
var failCause18 = failCause12;
var failCauseSync11 = failCauseSync7;
var filterInput2 = filterInput;
var filterInputEffect2 = filterInputEffect;
var findEffect4 = findEffect;
var fold2 = fold;
var foldSink2 = foldSink;
var foldChunks2 = foldChunks;
var foldChunksEffect2 = foldChunksEffect;
var foldEffect2 = foldEffect;
var foldLeft2 = foldLeft;
var foldLeftChunks2 = foldLeftChunks;
var foldLeftChunksEffect2 = foldLeftChunksEffect;
var foldLeftEffect2 = foldLeftEffect;
var foldUntil2 = foldUntil;
var foldUntilEffect2 = foldUntilEffect;
var foldWeighted2 = foldWeighted;
var foldWeightedDecompose2 = foldWeightedDecompose;
var foldWeightedDecomposeEffect2 = foldWeightedDecomposeEffect;
var foldWeightedEffect2 = foldWeightedEffect;
var forEach17 = forEach13;
var forEachChunk2 = forEachChunk;
var forEachChunkWhile2 = forEachChunkWhile;
var forEachWhile2 = forEachWhile;
var flatMap24 = flatMap18;
var fromChannel4 = fromChannel;
var toChannel4 = toChannel;
var fromEffect14 = fromEffect7;
var fromPubSub6 = fromPubSub2;
var fromPush2 = fromPush;
var fromQueue6 = fromQueue2;
var head10 = head7;
var ignoreLeftover2 = ignoreLeftover;
var last7 = last6;
var leftover2 = leftover;
var map37 = map25;
var mapEffect10 = mapEffect6;
var mapError13 = mapError7;
var mapLeftover2 = mapLeftover;
var mkString4 = mkString;
var never12 = never6;
var orElse21 = orElse10;
var provideContext13 = provideContext4;
var race6 = race3;
var raceBoth2 = raceBoth;
var raceWith4 = raceWith3;
var refineOrDie6 = refineOrDie;
var refineOrDieWith6 = refineOrDieWith;
var some14 = some9;
var splitWhere3 = splitWhere2;
var succeed27 = succeed15;
var sum5 = sum4;
var summarized6 = summarized3;
var suspend15 = suspend6;
var sync21 = sync10;
var take9 = take5;
var timed4 = timed3;
var unwrap9 = unwrap3;
var unwrapScoped8 = unwrapScoped4;
var withDuration2 = withDuration;
var zip24 = zip12;
var zipLeft16 = zipLeft8;
var zipRight16 = zipRight8;
var zipWith18 = zipWith10;

// ../node_modules/effect/dist/esm/SortedMap.js
var SortedMap_exports = {};
__export(SortedMap_exports, {
  empty: () => empty45,
  entries: () => entries3,
  fromIterable: () => fromIterable22,
  get: () => get25,
  getOrder: () => getOrder3,
  has: () => has11,
  headOption: () => headOption,
  isEmpty: () => isEmpty16,
  isNonEmpty: () => isNonEmpty7,
  isSortedMap: () => isSortedMap,
  keys: () => keys5,
  make: () => make102,
  map: () => map38,
  reduce: () => reduce20,
  remove: () => remove13,
  set: () => set14,
  size: () => size22,
  values: () => values8
});
var TypeId21 = Symbol.for("effect/SortedMap");
var SortedMapProto = {
  [TypeId21]: {
    _K: (_) => _,
    _V: (_) => _
  },
  [symbol2]() {
    return pipe(hash(this.tree), combine(hash("effect/SortedMap")), cached(this));
  },
  [symbol3](that) {
    return isSortedMap(that) && equals(this.tree, that.tree);
  },
  [Symbol.iterator]() {
    return this.tree[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl5 = (tree) => {
  const self = Object.create(SortedMapProto);
  self.tree = tree;
  return self;
};
var isSortedMap = (u) => hasProperty(u, TypeId21);
var empty45 = (ord) => makeImpl5(empty29(ord));
var fromIterable22 = dual(2, (iterable, ord) => makeImpl5(fromIterable12(iterable, ord)));
var make102 = (ord) => (...entries6) => fromIterable22(ord)(entries6);
var isEmpty16 = (self) => size22(self) === 0;
var isNonEmpty7 = (self) => size22(self) > 0;
var get25 = dual(2, (self, key) => findFirst8(self.tree, key));
var getOrder3 = (self) => getOrder2(self.tree);
var has11 = dual(2, (self, key) => isSome(get25(self, key)));
var headOption = (self) => first2(self.tree);
var map38 = dual(2, (self, f) => reduce20(self, empty45(getOrder2(self.tree)), (acc, v, k) => set14(acc, k, f(v, k))));
var reduce20 = dual(3, (self, zero3, f) => reduce12(self.tree, zero3, f));
var remove13 = dual(2, (self, key) => makeImpl5(removeFirst2(self.tree, key)));
var set14 = dual(3, (self, key, value8) => has7(self.tree, key) ? makeImpl5(insert2(removeFirst2(self.tree, key), key, value8)) : makeImpl5(insert2(self.tree, key, value8)));
var size22 = (self) => size10(self.tree);
var keys5 = (self) => keys4(self.tree);
var values8 = (self) => values6(self.tree);
var entries3 = (self) => {
  const iterator = self.tree[Symbol.iterator]();
  iterator[Symbol.iterator] = () => entries3(self);
  return iterator;
};

// ../node_modules/effect/dist/esm/StreamEmit.js
var StreamEmit_exports = {};

// ../node_modules/effect/dist/esm/Streamable.js
var Streamable_exports = {};
__export(Streamable_exports, {
  Class: () => Class5
});
var streamVariance2 = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var _a68;
var Class5 = class {
  constructor() {
    /**
     * @since 2.0.0
     */
    __publicField(this, _a68, streamVariance2);
  }
  /**
   * @since 2.0.0
   */
  pipe() {
    return pipeArguments(this, arguments);
  }
  /**
   * @internal
   */
  get channel() {
    return toChannel3(this.toStream());
  }
};
_a68 = StreamTypeId4;

// ../node_modules/effect/dist/esm/Struct.js
var Struct_exports = {};
__export(Struct_exports, {
  evolve: () => evolve,
  get: () => get26,
  getEquivalence: () => getEquivalence5,
  getOrder: () => getOrder4,
  omit: () => omit3,
  pick: () => pick3
});
var pick3 = dual((args) => isObject(args[0]), (s, ...keys10) => {
  const out = {};
  for (const k of keys10) {
    if (k in s) {
      out[k] = s[k];
    }
  }
  return out;
});
var omit3 = dual((args) => isObject(args[0]), (s, ...keys10) => {
  const out = {
    ...s
  };
  for (const k of keys10) {
    delete out[k];
  }
  return out;
});
var getEquivalence5 = struct;
var getOrder4 = struct2;
var evolve = dual(2, (obj, t) => {
  const out = {
    ...obj
  };
  for (const k in t) {
    if (Object.prototype.hasOwnProperty.call(obj, k)) {
      out[k] = t[k](obj[k]);
    }
  }
  return out;
});
var get26 = (key) => (s) => s[key];

// ../node_modules/effect/dist/esm/Subscribable.js
var Subscribable_exports = {};
__export(Subscribable_exports, {
  TypeId: () => TypeId22,
  isSubscribable: () => isSubscribable,
  make: () => make103,
  map: () => map39,
  mapEffect: () => mapEffect11,
  unwrap: () => unwrap10
});
var TypeId22 = Symbol.for("effect/Subscribable");
var isSubscribable = (u) => hasProperty(u, TypeId22);
var Proto5 = {
  [TypeId11]: TypeId11,
  [TypeId22]: TypeId22,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make103 = (options) => Object.assign(Object.create(Proto5), options);
var map39 = dual(2, (self, f) => make103({
  get: map22(self.get, f),
  changes: map34(self.changes, f)
}));
var mapEffect11 = dual(2, (self, f) => make103({
  get: flatMap15(self.get, f),
  changes: mapEffect9(self.changes, f)
}));
var unwrap10 = (effect4) => make103({
  get: flatMap15(effect4, (s) => s.get),
  changes: unwrap8(map22(effect4, (s) => s.changes))
});

// ../node_modules/effect/dist/esm/SubscriptionRef.js
var SubscriptionRef_exports = {};
__export(SubscriptionRef_exports, {
  SubscriptionRefTypeId: () => SubscriptionRefTypeId2,
  get: () => get29,
  getAndSet: () => getAndSet6,
  getAndUpdate: () => getAndUpdate6,
  getAndUpdateEffect: () => getAndUpdateEffect3,
  getAndUpdateSome: () => getAndUpdateSome5,
  getAndUpdateSomeEffect: () => getAndUpdateSomeEffect3,
  make: () => make106,
  modify: () => modify11,
  modifyEffect: () => modifyEffect4,
  modifySome: () => modifySome5,
  modifySomeEffect: () => modifySomeEffect3,
  set: () => set17,
  setAndGet: () => setAndGet5,
  update: () => update10,
  updateAndGet: () => updateAndGet6,
  updateAndGetEffect: () => updateAndGetEffect3,
  updateEffect: () => updateEffect3,
  updateSome: () => updateSome5,
  updateSomeAndGet: () => updateSomeAndGet5,
  updateSomeAndGetEffect: () => updateSomeAndGetEffect2,
  updateSomeEffect: () => updateSomeEffect3
});

// ../node_modules/effect/dist/esm/SynchronizedRef.js
var SynchronizedRef_exports = {};
__export(SynchronizedRef_exports, {
  SynchronizedRefTypeId: () => SynchronizedRefTypeId,
  get: () => get27,
  getAndSet: () => getAndSet5,
  getAndUpdate: () => getAndUpdate5,
  getAndUpdateEffect: () => getAndUpdateEffect2,
  getAndUpdateSome: () => getAndUpdateSome4,
  getAndUpdateSomeEffect: () => getAndUpdateSomeEffect2,
  make: () => make104,
  modify: () => modify9,
  modifyEffect: () => modifyEffect2,
  modifySome: () => modifySome4,
  modifySomeEffect: () => modifySomeEffect2,
  set: () => set15,
  setAndGet: () => setAndGet4,
  unsafeMake: () => unsafeMake17,
  update: () => update9,
  updateAndGet: () => updateAndGet5,
  updateAndGetEffect: () => updateAndGetEffect2,
  updateEffect: () => updateEffect2,
  updateSome: () => updateSome4,
  updateSomeAndGet: () => updateSomeAndGet4,
  updateSomeAndGetEffect: () => updateSomeAndGetEffect,
  updateSomeEffect: () => updateSomeEffect2
});
var SynchronizedRefTypeId = SynchronizedTypeId;
var make104 = makeSynchronized;
var get27 = get10;
var getAndSet5 = getAndSet2;
var getAndUpdate5 = getAndUpdate2;
var getAndUpdateEffect2 = getAndUpdateEffect;
var getAndUpdateSome4 = getAndUpdateSome;
var getAndUpdateSomeEffect2 = getAndUpdateSomeEffect;
var modify9 = modify7;
var modifyEffect2 = modifyEffect;
var modifySome4 = modifySome;
var modifySomeEffect2 = modifySomeEffect;
var set15 = set5;
var setAndGet4 = setAndGet2;
var update9 = update3;
var updateEffect2 = updateEffect;
var updateAndGet5 = updateAndGet2;
var updateAndGetEffect2 = updateAndGetEffect;
var updateSome4 = updateSome;
var updateSomeEffect2 = updateSomeEffect;
var updateSomeAndGet4 = updateSomeAndGet;
var updateSomeAndGetEffect = updateSomeAndGetEffectSynchronized;
var unsafeMake17 = unsafeMakeSynchronized;

// ../node_modules/effect/dist/esm/internal/subscriptionRef.js
var SubscriptionRefSymbolKey = "effect/SubscriptionRef";
var SubscriptionRefTypeId = Symbol.for(SubscriptionRefSymbolKey);
var subscriptionRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var _a69, _b18, _c3, _d2, _e;
var SubscriptionRefImpl = class {
  constructor(ref, pubsub, semaphore) {
    __publicField(this, "ref");
    __publicField(this, "pubsub");
    __publicField(this, "semaphore");
    __publicField(this, _a69);
    __publicField(this, _b18);
    __publicField(this, _c3, refVariance);
    __publicField(this, _d2, synchronizedVariance);
    __publicField(this, _e, subscriptionRefVariance);
    __publicField(this, "get");
    this.ref = ref;
    this.pubsub = pubsub;
    this.semaphore = semaphore;
    this[TypeId11] = TypeId11;
    this[TypeId22] = TypeId22;
    this.get = get11(this.ref);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  get changes() {
    return pipe(get11(this.ref), flatMap15((a) => map22(fromPubSub3(this.pubsub, {
      scoped: true
    }), (s) => concat2(make64(a), s))), this.semaphore.withPermits(1), unwrapScoped5);
  }
  modify(f) {
    return this.modifyEffect((a) => succeed12(f(a)));
  }
  modifyEffect(f) {
    return pipe(get11(this.ref), flatMap15(f), flatMap15(([b, a]) => pipe(set6(this.ref, a), as6(b), zipLeft6(publish2(this.pubsub, a)))), this.semaphore.withPermits(1));
  }
};
_a69 = TypeId11, _b18 = TypeId22, _c3 = RefTypeId2, _d2 = SynchronizedRefTypeId, _e = SubscriptionRefTypeId;
var get28 = (self) => get11(self.ref);
var make105 = (value8) => pipe(all7([unbounded4(), make36(value8), makeSemaphore2(1)]), map22(([pubsub, ref, semaphore]) => new SubscriptionRefImpl(ref, pubsub, semaphore)));
var modify10 = dual(2, (self, f) => self.modify(f));
var modifyEffect3 = dual(2, (self, f) => self.modifyEffect(f));
var set16 = dual(2, (self, value8) => pipe(set6(self.ref, value8), zipLeft6(publish2(self.pubsub, value8)), self.semaphore.withPermits(1)));

// ../node_modules/effect/dist/esm/SubscriptionRef.js
var SubscriptionRefTypeId2 = SubscriptionRefTypeId;
var get29 = get28;
var getAndSet6 = getAndSet3;
var getAndUpdate6 = getAndUpdate3;
var getAndUpdateEffect3 = getAndUpdateEffect2;
var getAndUpdateSome5 = getAndUpdateSome2;
var getAndUpdateSomeEffect3 = getAndUpdateSomeEffect2;
var make106 = make105;
var modify11 = modify10;
var modifyEffect4 = modifyEffect3;
var modifySome5 = modifySome2;
var modifySomeEffect3 = modifySomeEffect2;
var set17 = set16;
var setAndGet5 = setAndGet3;
var update10 = update4;
var updateEffect3 = updateEffect2;
var updateAndGet6 = updateAndGet3;
var updateAndGetEffect3 = updateAndGetEffect2;
var updateSome5 = updateSome2;
var updateSomeEffect3 = updateSomeEffect2;
var updateSomeAndGet5 = updateSomeAndGet2;
var updateSomeAndGetEffect2 = updateSomeAndGetEffect;

// ../node_modules/effect/dist/esm/Supervisor.js
var Supervisor_exports = {};
__export(Supervisor_exports, {
  AbstractSupervisor: () => AbstractSupervisor,
  SupervisorTypeId: () => SupervisorTypeId2,
  addSupervisor: () => addSupervisor2,
  fibersIn: () => fibersIn2,
  fromEffect: () => fromEffect15,
  none: () => none14,
  track: () => track2,
  unsafeTrack: () => unsafeTrack2
});
var SupervisorTypeId2 = SupervisorTypeId;
var addSupervisor2 = addSupervisor;
var fibersIn2 = fibersIn;
var fromEffect15 = fromEffect2;
var none14 = none8;
var track2 = track;
var unsafeTrack2 = unsafeTrack;
var _a70;
var AbstractSupervisor = class {
  constructor() {
    /**
     * @since 2.0.0
     */
    __publicField(this, _a70, supervisorVariance);
  }
  /**
   * @since 2.0.0
   */
  onStart(_context, _effect, _parent, _fiber) {
  }
  /**
   * @since 2.0.0
   */
  onEnd(_value, _fiber) {
  }
  /**
   * @since 2.0.0
   */
  onEffect(_fiber, _effect) {
  }
  /**
   * @since 2.0.0
   */
  onSuspend(_fiber) {
  }
  /**
   * @since 2.0.0
   */
  onResume(_fiber) {
  }
  /**
   * @since 2.0.0
   */
  map(f) {
    return new ProxySupervisor(this, map11(this.value, f));
  }
  /**
   * @since 2.0.0
   */
  zip(right2) {
    return new Zip(this, right2);
  }
  /**
   * @since 2.0.0
   */
  onRun(execution, _fiber) {
    return execution();
  }
};
_a70 = SupervisorTypeId2;

// ../node_modules/effect/dist/esm/Symbol.js
var Symbol_exports = {};
__export(Symbol_exports, {
  Equivalence: () => Equivalence6,
  isSymbol: () => isSymbol2
});
var isSymbol2 = isSymbol;
var Equivalence6 = symbol;

// ../node_modules/effect/dist/esm/TArray.js
var TArray_exports = {};
__export(TArray_exports, {
  TArrayTypeId: () => TArrayTypeId2,
  collectFirst: () => collectFirst2,
  collectFirstSTM: () => collectFirstSTM2,
  contains: () => contains7,
  count: () => count8,
  countSTM: () => countSTM2,
  empty: () => empty47,
  every: () => every15,
  everySTM: () => everySTM2,
  findFirst: () => findFirst11,
  findFirstIndex: () => findFirstIndex4,
  findFirstIndexFrom: () => findFirstIndexFrom2,
  findFirstIndexWhere: () => findFirstIndexWhere2,
  findFirstIndexWhereFrom: () => findFirstIndexWhereFrom2,
  findFirstIndexWhereFromSTM: () => findFirstIndexWhereFromSTM2,
  findFirstIndexWhereSTM: () => findFirstIndexWhereSTM2,
  findFirstSTM: () => findFirstSTM2,
  findLast: () => findLast4,
  findLastIndex: () => findLastIndex4,
  findLastIndexFrom: () => findLastIndexFrom2,
  findLastSTM: () => findLastSTM2,
  forEach: () => forEach19,
  fromIterable: () => fromIterable24,
  get: () => get32,
  headOption: () => headOption3,
  lastOption: () => lastOption2,
  make: () => make109,
  maxOption: () => maxOption2,
  minOption: () => minOption2,
  reduce: () => reduce22,
  reduceOption: () => reduceOption2,
  reduceOptionSTM: () => reduceOptionSTM2,
  reduceSTM: () => reduceSTM2,
  size: () => size24,
  some: () => some16,
  someSTM: () => someSTM2,
  toArray: () => toArray4,
  transform: () => transform4,
  transformSTM: () => transformSTM2,
  update: () => update13,
  updateSTM: () => updateSTM2
});

// ../node_modules/effect/dist/esm/internal/stm/tRef.js
var TRefSymbolKey = "effect/TRef";
var TRefTypeId = Symbol.for(TRefSymbolKey);
var tRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var _a71;
var TRefImpl = class {
  constructor(value8) {
    __publicField(this, _a71, tRefVariance);
    /** @internal */
    __publicField(this, "todos");
    /** @internal */
    __publicField(this, "versioned");
    this.versioned = new Versioned(value8);
    this.todos = /* @__PURE__ */ new Map();
  }
  modify(f) {
    return effect3((journal) => {
      const entry = getOrMakeEntry(this, journal);
      const [retValue, newValue] = f(unsafeGet10(entry));
      unsafeSet3(entry, newValue);
      return retValue;
    });
  }
};
_a71 = TRefTypeId;
var make107 = (value8) => effect3((journal) => {
  const ref = new TRefImpl(value8);
  journal.set(ref, make95(ref, true));
  return ref;
});
var get30 = (self) => self.modify((a) => [a, a]);
var set18 = dual(2, (self, value8) => self.modify(() => [void 0, value8]));
var getAndSet7 = dual(2, (self, value8) => self.modify((a) => [a, value8]));
var getAndUpdate7 = dual(2, (self, f) => self.modify((a) => [a, f(a)]));
var getAndUpdateSome6 = dual(2, (self, f) => self.modify((a) => match2(f(a), {
  onNone: () => [a, a],
  onSome: (b) => [a, b]
})));
var setAndGet6 = dual(2, (self, value8) => self.modify(() => [value8, value8]));
var modify12 = dual(2, (self, f) => self.modify(f));
var modifySome6 = dual(3, (self, fallback, f) => self.modify((a) => match2(f(a), {
  onNone: () => [fallback, a],
  onSome: (b) => b
})));
var update11 = dual(2, (self, f) => self.modify((a) => [void 0, f(a)]));
var updateAndGet7 = dual(2, (self, f) => self.modify((a) => {
  const b = f(a);
  return [b, b];
}));
var updateSome6 = dual(2, (self, f) => self.modify((a) => [void 0, match2(f(a), {
  onNone: () => a,
  onSome: (b) => b
})]));
var updateSomeAndGet6 = dual(2, (self, f) => self.modify((a) => match2(f(a), {
  onNone: () => [a, a],
  onSome: (b) => [b, b]
})));
var getOrMakeEntry = (self, journal) => {
  if (journal.has(self)) {
    return journal.get(self);
  }
  const entry = make95(self, false);
  journal.set(self, entry);
  return entry;
};
var unsafeGet11 = dual(2, (self, journal) => unsafeGet10(getOrMakeEntry(self, journal)));
var unsafeSet4 = dual(3, (self, value8, journal) => {
  const entry = getOrMakeEntry(self, journal);
  unsafeSet3(entry, value8);
  return void 0;
});

// ../node_modules/effect/dist/esm/internal/stm/tArray.js
var TArraySymbolKey = "effect/TArray";
var TArrayTypeId = Symbol.for(TArraySymbolKey);
var tArrayVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var _a72;
var TArrayImpl = class {
  constructor(chunk7) {
    __publicField(this, "chunk");
    __publicField(this, _a72, tArrayVariance);
    this.chunk = chunk7;
  }
};
_a72 = TArrayTypeId;
var collectFirst = dual(2, (self, pf) => collectFirstSTM(self, (a) => pipe(pf(a), map2(succeed25))));
var collectFirstSTM = dual(2, (self, pf) => withSTMRuntime((runtime8) => {
  let index = 0;
  let result = none2();
  while (isNone(result) && index < self.chunk.length) {
    const element = pipe(self.chunk[index], unsafeGet11(runtime8.journal));
    const option9 = pf(element);
    if (isSome(option9)) {
      result = option9;
    }
    index = index + 1;
  }
  return pipe(result, match2({
    onNone: () => succeedNone3,
    onSome: map35(some2)
  }));
}));
var contains6 = dual(2, (self, value8) => some15(self, (a) => equals(a)(value8)));
var count7 = dual(2, (self, predicate) => reduce21(self, 0, (n, a) => predicate(a) ? n + 1 : n));
var countSTM = dual(2, (self, predicate) => reduceSTM(self, 0, (n, a) => map35(predicate(a), (bool) => bool ? n + 1 : n)));
var empty46 = () => fromIterable23([]);
var every14 = dual(2, (self, predicate) => negate4(some15(self, (a) => !predicate(a))));
var everySTM = dual(2, (self, predicate) => map35(countSTM(self, predicate), (count9) => count9 === self.chunk.length));
var findFirst10 = dual(2, (self, predicate) => collectFirst(self, (a) => predicate(a) ? some2(a) : none2()));
var findFirstIndex3 = dual(2, (self, value8) => findFirstIndexFrom(self, value8, 0));
var findFirstIndexFrom = dual(3, (self, value8, from) => findFirstIndexWhereFrom(self, (a) => equals(a)(value8), from));
var findFirstIndexWhere = dual(2, (self, predicate) => findFirstIndexWhereFrom(self, predicate, 0));
var findFirstIndexWhereFrom = dual(3, (self, predicate, from) => {
  if (from < 0) {
    return succeedNone3;
  }
  return effect3((journal) => {
    let index = from;
    let found = false;
    while (!found && index < self.chunk.length) {
      const element = unsafeGet11(self.chunk[index], journal);
      found = predicate(element);
      index = index + 1;
    }
    if (found) {
      return some2(index - 1);
    }
    return none2();
  });
});
var findFirstIndexWhereSTM = dual(2, (self, predicate) => findFirstIndexWhereFromSTM(self, predicate, 0));
var findFirstIndexWhereFromSTM = dual(3, (self, predicate, from) => {
  const forIndex = (index) => index < self.chunk.length ? pipe(get30(self.chunk[index]), flatMap22(predicate), flatMap22((bool) => bool ? succeed25(some2(index)) : forIndex(index + 1))) : succeedNone3;
  return from < 0 ? succeedNone3 : forIndex(from);
});
var findFirstSTM = dual(2, (self, predicate) => {
  const init = [none2(), 0];
  const cont = (state) => isNone(state[0]) && state[1] < self.chunk.length - 1;
  return map35(iterate5(init, {
    while: cont,
    body: (state) => {
      const index = state[1];
      return pipe(get30(self.chunk[index]), flatMap22((value8) => map35(predicate(value8), (bool) => [bool ? some2(value8) : none2(), index + 1])));
    }
  }), (state) => state[0]);
});
var findLast3 = dual(2, (self, predicate) => effect3((journal) => {
  let index = self.chunk.length - 1;
  let result = none2();
  while (isNone(result) && index >= 0) {
    const element = unsafeGet11(self.chunk[index], journal);
    if (predicate(element)) {
      result = some2(element);
    }
    index = index - 1;
  }
  return result;
}));
var findLastIndex3 = dual(2, (self, value8) => findLastIndexFrom(self, value8, self.chunk.length - 1));
var findLastIndexFrom = dual(3, (self, value8, end7) => {
  if (end7 >= self.chunk.length) {
    return succeedNone3;
  }
  return effect3((journal) => {
    let index = end7;
    let found = false;
    while (!found && index >= 0) {
      const element = unsafeGet11(self.chunk[index], journal);
      found = equals(element)(value8);
      index = index - 1;
    }
    if (found) {
      return some2(index + 1);
    }
    return none2();
  });
});
var findLastSTM = dual(2, (self, predicate) => {
  const init = [none2(), self.chunk.length - 1];
  const cont = (state) => isNone(state[0]) && state[1] >= 0;
  return map35(iterate5(init, {
    while: cont,
    body: (state) => {
      const index = state[1];
      return pipe(get30(self.chunk[index]), flatMap22((value8) => map35(predicate(value8), (bool) => [bool ? some2(value8) : none2(), index - 1])));
    }
  }), (state) => state[0]);
});
var forEach18 = dual(2, (self, f) => reduceSTM(self, void 0, (_, a) => f(a)));
var fromIterable23 = (iterable) => map35(forEach15(iterable, make107), (chunk7) => new TArrayImpl(chunk7));
var get31 = dual(2, (self, index) => {
  if (index < 0 || index >= self.chunk.length) {
    return dieMessage7("Index out of bounds");
  }
  return get30(self.chunk[index]);
});
var headOption2 = (self) => self.chunk.length === 0 ? succeed25(none2()) : map35(get30(self.chunk[0]), some2);
var lastOption = (self) => self.chunk.length === 0 ? succeedNone3 : map35(get30(self.chunk[self.chunk.length - 1]), some2);
var make108 = (...elements) => fromIterable23(elements);
var maxOption = dual(2, (self, order) => {
  const greaterThan8 = greaterThan(order);
  return reduceOption(self, (acc, curr) => greaterThan8(acc)(curr) ? curr : acc);
});
var minOption = dual(2, (self, order) => {
  const lessThan12 = lessThan(order);
  return reduceOption(self, (acc, curr) => lessThan12(acc)(curr) ? curr : acc);
});
var reduce21 = dual(3, (self, zero3, f) => effect3((journal) => {
  let index = 0;
  let result = zero3;
  while (index < self.chunk.length) {
    const element = unsafeGet11(self.chunk[index], journal);
    result = f(result, element);
    index = index + 1;
  }
  return result;
}));
var reduceOption = dual(2, (self, f) => effect3((journal) => {
  let index = 0;
  let result = void 0;
  while (index < self.chunk.length) {
    const element = unsafeGet11(self.chunk[index], journal);
    result = result === void 0 ? element : f(result, element);
    index = index + 1;
  }
  return fromNullable(result);
}));
var reduceOptionSTM = dual(2, (self, f) => reduceSTM(self, none2(), (acc, curr) => isSome(acc) ? map35(f(acc.value, curr), some2) : succeedSome3(curr)));
var reduceSTM = dual(3, (self, zero3, f) => flatMap22(toArray3(self), reduce18(zero3, f)));
var size23 = (self) => self.chunk.length;
var some15 = dual(2, (self, predicate) => map35(findFirst10(self, predicate), isSome));
var someSTM = dual(2, (self, predicate) => map35(countSTM(self, predicate), (n) => n > 0));
var toArray3 = (self) => forEach15(self.chunk, get30);
var transform3 = dual(2, (self, f) => effect3((journal) => {
  let index = 0;
  while (index < self.chunk.length) {
    const ref = self.chunk[index];
    unsafeSet4(ref, f(unsafeGet11(ref, journal)), journal);
    index = index + 1;
  }
  return void 0;
}));
var transformSTM = dual(2, (self, f) => flatMap22(forEach15(self.chunk, (ref) => flatMap22(get30(ref), f)), (chunk7) => effect3((journal) => {
  const iterator = chunk7[Symbol.iterator]();
  let index = 0;
  let next6;
  while ((next6 = iterator.next()) && !next6.done) {
    unsafeSet4(self.chunk[index], next6.value, journal);
    index = index + 1;
  }
  return void 0;
})));
var update12 = dual(3, (self, index, f) => {
  if (index < 0 || index >= self.chunk.length) {
    return dieMessage7("Index out of bounds");
  }
  return update11(self.chunk[index], f);
});
var updateSTM = dual(3, (self, index, f) => {
  if (index < 0 || index >= self.chunk.length) {
    return dieMessage7("Index out of bounds");
  }
  return pipe(get30(self.chunk[index]), flatMap22(f), flatMap22((updated) => set18(self.chunk[index], updated)));
});

// ../node_modules/effect/dist/esm/TArray.js
var TArrayTypeId2 = TArrayTypeId;
var collectFirst2 = collectFirst;
var collectFirstSTM2 = collectFirstSTM;
var contains7 = contains6;
var count8 = count7;
var countSTM2 = countSTM;
var empty47 = empty46;
var every15 = every14;
var everySTM2 = everySTM;
var findFirst11 = findFirst10;
var findFirstIndex4 = findFirstIndex3;
var findFirstIndexFrom2 = findFirstIndexFrom;
var findFirstIndexWhere2 = findFirstIndexWhere;
var findFirstIndexWhereFrom2 = findFirstIndexWhereFrom;
var findFirstIndexWhereSTM2 = findFirstIndexWhereSTM;
var findFirstIndexWhereFromSTM2 = findFirstIndexWhereFromSTM;
var findFirstSTM2 = findFirstSTM;
var findLast4 = findLast3;
var findLastIndex4 = findLastIndex3;
var findLastIndexFrom2 = findLastIndexFrom;
var findLastSTM2 = findLastSTM;
var forEach19 = forEach18;
var fromIterable24 = fromIterable23;
var get32 = get31;
var headOption3 = headOption2;
var lastOption2 = lastOption;
var make109 = make108;
var maxOption2 = maxOption;
var minOption2 = minOption;
var reduce22 = reduce21;
var reduceOption2 = reduceOption;
var reduceOptionSTM2 = reduceOptionSTM;
var reduceSTM2 = reduceSTM;
var size24 = size23;
var some16 = some15;
var someSTM2 = someSTM;
var toArray4 = toArray3;
var transform4 = transform3;
var transformSTM2 = transformSTM;
var update13 = update12;
var updateSTM2 = updateSTM;

// ../node_modules/effect/dist/esm/TDeferred.js
var TDeferred_exports = {};
__export(TDeferred_exports, {
  TDeferredTypeId: () => TDeferredTypeId2,
  await: () => _await5,
  done: () => done13,
  fail: () => fail26,
  make: () => make111,
  poll: () => poll10,
  succeed: () => succeed29
});

// ../node_modules/effect/dist/esm/internal/stm/tDeferred.js
var TDeferredSymbolKey = "effect/TDeferred";
var TDeferredTypeId = Symbol.for(TDeferredSymbolKey);
var tDeferredVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _E: (_) => _
};
var _a73;
var TDeferredImpl = class {
  constructor(ref) {
    __publicField(this, "ref");
    __publicField(this, _a73, tDeferredVariance);
    this.ref = ref;
  }
};
_a73 = TDeferredTypeId;
var _await4 = (self) => flatten15(collect3(get30(self.ref), (option9) => isSome(option9) ? some2(fromEither4(option9.value)) : none2()));
var done12 = dual(2, (self, either13) => flatMap22(get30(self.ref), match2({
  onNone: () => zipRight14(set18(self.ref, some2(either13)), succeed25(true)),
  onSome: () => succeed25(false)
})));
var fail25 = dual(2, (self, error4) => done12(self, left(error4)));
var make110 = () => map35(make107(none2()), (ref) => new TDeferredImpl(ref));
var poll9 = (self) => get30(self.ref);
var succeed28 = dual(2, (self, value8) => done12(self, right(value8)));

// ../node_modules/effect/dist/esm/TDeferred.js
var TDeferredTypeId2 = TDeferredTypeId;
var _await5 = _await4;
var done13 = done12;
var fail26 = fail25;
var make111 = make110;
var poll10 = poll9;
var succeed29 = succeed28;

// ../node_modules/effect/dist/esm/TMap.js
var TMap_exports = {};
__export(TMap_exports, {
  TMapTypeId: () => TMapTypeId2,
  empty: () => empty49,
  find: () => find6,
  findAll: () => findAll4,
  findAllSTM: () => findAllSTM2,
  findSTM: () => findSTM2,
  forEach: () => forEach21,
  fromIterable: () => fromIterable26,
  get: () => get34,
  getOrElse: () => getOrElse6,
  has: () => has13,
  isEmpty: () => isEmpty18,
  keys: () => keys7,
  make: () => make113,
  merge: () => merge14,
  reduce: () => reduce24,
  reduceSTM: () => reduceSTM4,
  remove: () => remove15,
  removeAll: () => removeAll2,
  removeIf: () => removeIf2,
  retainIf: () => retainIf2,
  set: () => set20,
  setIfAbsent: () => setIfAbsent2,
  size: () => size26,
  takeFirst: () => takeFirst2,
  takeFirstSTM: () => takeFirstSTM2,
  takeSome: () => takeSome2,
  takeSomeSTM: () => takeSomeSTM2,
  toArray: () => toArray6,
  toChunk: () => toChunk3,
  toHashMap: () => toHashMap2,
  toMap: () => toMap2,
  transform: () => transform6,
  transformSTM: () => transformSTM4,
  transformValues: () => transformValues2,
  transformValuesSTM: () => transformValuesSTM2,
  updateWith: () => updateWith4,
  values: () => values10
});

// ../node_modules/effect/dist/esm/internal/stm/tMap.js
var TMapSymbolKey = "effect/TMap";
var TMapTypeId = Symbol.for(TMapSymbolKey);
var tMapVariance = {
  /* c8 ignore next */
  _K: (_) => _,
  /* c8 ignore next */
  _V: (_) => _
};
var _a74;
var TMapImpl = class {
  constructor(tBuckets, tSize) {
    __publicField(this, "tBuckets");
    __publicField(this, "tSize");
    __publicField(this, _a74, tMapVariance);
    this.tBuckets = tBuckets;
    this.tSize = tSize;
  }
};
_a74 = TMapTypeId;
var isTMap = (u) => hasProperty(u, TMapTypeId);
var InitialCapacity = 16;
var LoadFactor = 0.75;
var nextPowerOfTwo = (size38) => {
  const n = -1 >>> Math.clz32(size38 - 1);
  return n < 0 ? 1 : n + 1;
};
var hash2 = (key) => {
  const h = hash(key);
  return h ^ h >>> 16;
};
var indexOf = (k, capacity10) => hash2(k) & capacity10 - 1;
var allocate3 = (capacity10, data) => {
  const buckets = Array.from({
    length: capacity10
  }, () => empty5());
  const distinct = new Map(data);
  let size38 = 0;
  for (const entry of distinct) {
    const index = indexOf(entry[0], capacity10);
    buckets[index] = pipe(buckets[index], prepend2(entry));
    size38 = size38 + 1;
  }
  return pipe(fromIterable23(buckets), flatMap22((buckets2) => pipe(make107(buckets2), flatMap22((tBuckets) => pipe(make107(size38), map35((tSize) => new TMapImpl(tBuckets, tSize)))))));
};
var empty48 = () => fromIterable25([]);
var find5 = dual(2, (self, pf) => findSTM(self, (key, value8) => {
  const option9 = pf(key, value8);
  if (isSome(option9)) {
    return succeed25(option9.value);
  }
  return fail22(none2());
}));
var findSTM = dual(2, (self, f) => reduceSTM3(self, none2(), (acc, value8, key) => isNone(acc) ? matchSTM(f(key, value8), {
  onFailure: match2({
    onNone: () => succeedNone3,
    onSome: fail22
  }),
  onSuccess: succeedSome3
}) : succeed26(acc)));
var findAll3 = dual(2, (self, pf) => findAllSTM(self, (key, value8) => {
  const option9 = pf(key, value8);
  if (isSome(option9)) {
    return succeed25(option9.value);
  }
  return fail22(none2());
}));
var findAllSTM = dual(2, (self, pf) => map35(reduceSTM3(self, empty5(), (acc, value8, key) => matchSTM(pf(key, value8), {
  onFailure: match2({
    onNone: () => succeed25(acc),
    onSome: fail22
  }),
  onSuccess: (a) => succeed25(append2(acc, a))
})), (a) => Array.from(a)));
var forEach20 = dual(2, (self, f) => reduceSTM3(self, void 0, (_, value8, key) => asVoid8(f(key, value8))));
var fromIterable25 = (iterable) => suspend13(() => {
  const data = fromIterable2(iterable);
  const capacity10 = data.length < InitialCapacity ? InitialCapacity : nextPowerOfTwo(data.length);
  return allocate3(capacity10, data);
});
var get33 = dual(2, (self, key) => effect3((journal) => {
  const buckets = unsafeGet11(self.tBuckets, journal);
  const index = indexOf(key, buckets.chunk.length);
  const bucket = unsafeGet11(buckets.chunk[index], journal);
  return pipe(findFirst2(bucket, (entry) => equals(entry[0])(key)), map2((entry) => entry[1]));
}));
var getOrElse5 = dual(3, (self, key, fallback) => map35(get33(self, key), getOrElse(fallback)));
var has12 = dual(2, (self, key) => map35(get33(self, key), isSome));
var isEmpty17 = (self) => map35(get30(self.tSize), (size38) => size38 === 0);
var keys6 = (self) => map35(toReadonlyArray2(self), map3((entry) => entry[0]));
var make112 = (...entries6) => fromIterable25(entries6);
var merge13 = dual(4, (self, key, value8, f) => flatMap22(get33(self, key), match2({
  onNone: () => as13(set19(self, key, value8), value8),
  onSome: (v0) => {
    const v1 = f(v0, value8);
    return as13(set19(self, key, v1), v1);
  }
})));
var reduce23 = dual(3, (self, zero3, f) => effect3((journal) => {
  const buckets = unsafeGet11(self.tBuckets, journal);
  let result = zero3;
  let index = 0;
  while (index < buckets.chunk.length) {
    const bucket = buckets.chunk[index];
    const items = unsafeGet11(bucket, journal);
    result = reduce2(items, result, (acc, entry) => f(acc, entry[1], entry[0]));
    index = index + 1;
  }
  return result;
}));
var reduceSTM3 = dual(3, (self, zero3, f) => flatMap22(toReadonlyArray2(self), reduce18(zero3, (acc, entry) => f(acc, entry[1], entry[0]))));
var remove14 = dual(2, (self, key) => effect3((journal) => {
  const buckets = unsafeGet11(self.tBuckets, journal);
  const index = indexOf(key, buckets.chunk.length);
  const bucket = unsafeGet11(buckets.chunk[index], journal);
  const [toRemove, toRetain] = partition2(bucket, (entry) => equals(entry[1], key));
  if (isNonEmpty2(toRemove)) {
    const currentSize = unsafeGet11(self.tSize, journal);
    unsafeSet4(buckets.chunk[index], toRetain, journal);
    unsafeSet4(self.tSize, currentSize - 1, journal);
  }
}));
var removeAll = dual(2, (self, keys10) => effect3((journal) => {
  const iterator = keys10[Symbol.iterator]();
  let next6;
  while ((next6 = iterator.next()) && !next6.done) {
    const buckets = unsafeGet11(self.tBuckets, journal);
    const index = indexOf(next6.value, buckets.chunk.length);
    const bucket = unsafeGet11(buckets.chunk[index], journal);
    const [toRemove, toRetain] = partition2(bucket, (entry) => equals(next6.value)(entry[0]));
    if (isNonEmpty2(toRemove)) {
      const currentSize = unsafeGet11(self.tSize, journal);
      unsafeSet4(buckets.chunk[index], toRetain, journal);
      unsafeSet4(self.tSize, currentSize - 1, journal);
    }
  }
}));
var removeIf = dual((args) => isTMap(args[0]), (self, predicate, options) => effect3((journal) => {
  const discard3 = (options == null ? void 0 : options.discard) === true;
  const buckets = unsafeGet11(self.tBuckets, journal);
  const capacity10 = buckets.chunk.length;
  const removed = [];
  let index = 0;
  let newSize = 0;
  while (index < capacity10) {
    const bucket = unsafeGet11(buckets.chunk[index], journal);
    const iterator = bucket[Symbol.iterator]();
    let next6;
    let newBucket = empty5();
    while ((next6 = iterator.next()) && !next6.done) {
      const [k, v] = next6.value;
      if (!predicate(k, v)) {
        newBucket = prepend2(newBucket, next6.value);
        newSize = newSize + 1;
      } else {
        if (!discard3) {
          removed.push([k, v]);
        }
      }
    }
    unsafeSet4(buckets.chunk[index], newBucket, journal);
    index = index + 1;
  }
  unsafeSet4(self.tSize, newSize, journal);
  if (!discard3) {
    return removed;
  }
}));
var retainIf = dual((args) => isTMap(args[0]), (self, predicate, options) => removeIf(self, (key, value8) => !predicate(key, value8), options));
var set19 = dual(3, (self, key, value8) => {
  const resize = (journal, buckets) => {
    const capacity10 = buckets.chunk.length;
    const newCapacity = capacity10 << 1;
    const newBuckets = Array.from({
      length: newCapacity
    }, () => empty5());
    let index = 0;
    while (index < capacity10) {
      const pairs = unsafeGet11(buckets.chunk[index], journal);
      const iterator = pairs[Symbol.iterator]();
      let next6;
      while ((next6 = iterator.next()) && !next6.done) {
        const newIndex2 = indexOf(next6.value[0], newCapacity);
        newBuckets[newIndex2] = prepend2(newBuckets[newIndex2], next6.value);
      }
      index = index + 1;
    }
    const newIndex = indexOf(key, newCapacity);
    newBuckets[newIndex] = prepend2(newBuckets[newIndex], [key, value8]);
    const newArray = [];
    index = 0;
    while (index < newCapacity) {
      newArray[index] = new TRefImpl(newBuckets[index]);
      index = index + 1;
    }
    const newTArray = new TArrayImpl(newArray);
    unsafeSet4(self.tBuckets, newTArray, journal);
  };
  return effect3((journal) => {
    const buckets = unsafeGet11(self.tBuckets, journal);
    const capacity10 = buckets.chunk.length;
    const index = indexOf(key, capacity10);
    const bucket = unsafeGet11(buckets.chunk[index], journal);
    const shouldUpdate = some4(bucket, (entry) => equals(key)(entry[0]));
    if (shouldUpdate) {
      const newBucket = map4(bucket, (entry) => equals(key)(entry[0]) ? [key, value8] : entry);
      unsafeSet4(buckets.chunk[index], newBucket, journal);
    } else {
      const newSize = unsafeGet11(self.tSize, journal) + 1;
      unsafeSet4(self.tSize, newSize, journal);
      if (capacity10 * LoadFactor < newSize) {
        resize(journal, buckets);
      } else {
        const newBucket = prepend2(bucket, [key, value8]);
        unsafeSet4(buckets.chunk[index], newBucket, journal);
      }
    }
  });
});
var setIfAbsent = dual(3, (self, key, value8) => flatMap22(get33(self, key), match2({
  onNone: () => set19(self, key, value8),
  onSome: () => void_10
})));
var size25 = (self) => get30(self.tSize);
var takeFirst = dual(2, (self, pf) => pipe(effect3((journal) => {
  const buckets = unsafeGet11(self.tBuckets, journal);
  const capacity10 = buckets.chunk.length;
  const size38 = unsafeGet11(self.tSize, journal);
  let result = none2();
  let index = 0;
  while (index < capacity10 && isNone(result)) {
    const bucket = unsafeGet11(buckets.chunk[index], journal);
    const recreate = some4(bucket, (entry) => isSome(pf(entry[0], entry[1])));
    if (recreate) {
      const iterator = bucket[Symbol.iterator]();
      let newBucket = empty5();
      let next6;
      while ((next6 = iterator.next()) && !next6.done && isNone(result)) {
        const option9 = pf(next6.value[0], next6.value[1]);
        if (isSome(option9) && isNone(result)) {
          result = option9;
        } else {
          newBucket = prepend2(newBucket, next6.value);
        }
      }
      unsafeSet4(buckets.chunk[index], newBucket, journal);
    }
    index = index + 1;
  }
  if (isSome(result)) {
    unsafeSet4(self.tSize, size38 - 1, journal);
  }
  return result;
}), collect3((option9) => isSome(option9) ? some2(option9.value) : none2())));
var takeFirstSTM = dual(2, (self, pf) => pipe(findSTM(self, (key, value8) => map35(pf(key, value8), (a) => [key, a])), collect3((option9) => isSome(option9) ? some2(option9.value) : none2()), flatMap22((entry) => as13(remove14(self, entry[0]), entry[1]))));
var takeSome = dual(2, (self, pf) => pipe(effect3((journal) => {
  const buckets = unsafeGet11(self.tBuckets, journal);
  const capacity10 = buckets.chunk.length;
  const builder = [];
  let newSize = 0;
  let index = 0;
  while (index < capacity10) {
    const bucket = unsafeGet11(buckets.chunk[index], journal);
    const recreate = some4(bucket, (entry) => isSome(pf(entry[0], entry[1])));
    if (recreate) {
      const iterator = bucket[Symbol.iterator]();
      let newBucket = empty5();
      let next6;
      while ((next6 = iterator.next()) && !next6.done) {
        const option9 = pf(next6.value[0], next6.value[1]);
        if (isSome(option9)) {
          builder.push(option9.value);
        } else {
          newBucket = prepend2(newBucket, next6.value);
          newSize = newSize + 1;
        }
      }
      unsafeSet4(buckets.chunk[index], newBucket, journal);
    } else {
      newSize = newSize + bucket.length;
    }
    index = index + 1;
  }
  unsafeSet4(self.tSize, newSize, journal);
  if (builder.length > 0) {
    return some2(builder);
  }
  return none2();
}), collect3((option9) => isSome(option9) ? some2(option9.value) : none2())));
var takeSomeSTM = dual(2, (self, pf) => pipe(findAllSTM(self, (key, value8) => map35(pf(key, value8), (a) => [key, a])), map35((chunk7) => isNonEmptyArray(chunk7) ? some2(chunk7) : none2()), collect3((option9) => isSome(option9) ? some2(option9.value) : none2()), flatMap22((entries6) => as13(removeAll(self, entries6.map((entry) => entry[0])), map3(entries6, (entry) => entry[1])))));
var toReadonlyArray2 = (self) => effect3((journal) => {
  const buckets = unsafeGet11(self.tBuckets, journal);
  const capacity10 = buckets.chunk.length;
  const builder = [];
  let index = 0;
  while (index < capacity10) {
    const bucket = buckets.chunk[index];
    for (const entry of unsafeGet11(bucket, journal)) {
      builder.push(entry);
    }
    index = index + 1;
  }
  return builder;
});
var toChunk2 = (self) => reduce23(self, empty5(), (acc, value8, key) => append2(acc, [key, value8]));
var toHashMap = (self) => reduce23(self, empty9(), (acc, value8, key) => pipe(acc, set3(key, value8)));
var toArray5 = (self) => reduce23(self, [], (acc, value8, key) => {
  acc.unshift([key, value8]);
  return acc;
});
var toMap = (self) => reduce23(self, /* @__PURE__ */ new Map(), (acc, value8, key) => acc.set(key, value8));
var transform5 = dual(2, (self, f) => effect3((journal) => {
  const buckets = pipe(self.tBuckets, unsafeGet11(journal));
  const capacity10 = buckets.chunk.length;
  const newBuckets = Array.from({
    length: capacity10
  }, () => empty5());
  let newSize = 0;
  let index = 0;
  while (index < capacity10) {
    const bucket = buckets.chunk[index];
    const pairs = unsafeGet11(bucket, journal);
    const iterator = pairs[Symbol.iterator]();
    let next6;
    while ((next6 = iterator.next()) && !next6.done) {
      const newPair = f(next6.value[0], next6.value[1]);
      const index2 = indexOf(newPair[0], capacity10);
      const newBucket = newBuckets[index2];
      if (!some4(newBucket, (entry) => equals(entry[0], newPair[0]))) {
        newBuckets[index2] = prepend2(newBucket, newPair);
        newSize = newSize + 1;
      }
    }
    index = index + 1;
  }
  index = 0;
  while (index < capacity10) {
    unsafeSet4(buckets.chunk[index], newBuckets[index], journal);
    index = index + 1;
  }
  unsafeSet4(self.tSize, newSize, journal);
}));
var transformSTM3 = dual(2, (self, f) => pipe(flatMap22(toReadonlyArray2(self), forEach15((entry) => f(entry[0], entry[1]))), flatMap22((newData) => effect3((journal) => {
  const buckets = unsafeGet11(self.tBuckets, journal);
  const capacity10 = buckets.chunk.length;
  const newBuckets = Array.from({
    length: capacity10
  }, () => empty5());
  const iterator = newData[Symbol.iterator]();
  let newSize = 0;
  let next6;
  while ((next6 = iterator.next()) && !next6.done) {
    const index2 = indexOf(next6.value[0], capacity10);
    const newBucket = newBuckets[index2];
    if (!some4(newBucket, (entry) => equals(entry[0])(next6.value[0]))) {
      newBuckets[index2] = prepend2(newBucket, next6.value);
      newSize = newSize + 1;
    }
  }
  let index = 0;
  while (index < capacity10) {
    unsafeSet4(buckets.chunk[index], newBuckets[index], journal);
    index = index + 1;
  }
  unsafeSet4(self.tSize, newSize, journal);
}))));
var transformValues = dual(2, (self, f) => transform5(self, (key, value8) => [key, f(value8)]));
var transformValuesSTM = dual(2, (self, f) => transformSTM3(self, (key, value8) => map35(f(value8), (value9) => [key, value9])));
var updateWith3 = dual(3, (self, key, f) => flatMap22(get33(self, key), (option9) => match2(f(option9), {
  onNone: () => as13(remove14(self, key), none2()),
  onSome: (value8) => as13(set19(self, key, value8), some2(value8))
})));
var values9 = (self) => map35(toReadonlyArray2(self), map3((entry) => entry[1]));

// ../node_modules/effect/dist/esm/TMap.js
var TMapTypeId2 = TMapTypeId;
var empty49 = empty48;
var find6 = find5;
var findSTM2 = findSTM;
var findAll4 = findAll3;
var findAllSTM2 = findAllSTM;
var forEach21 = forEach20;
var fromIterable26 = fromIterable25;
var get34 = get33;
var getOrElse6 = getOrElse5;
var has13 = has12;
var isEmpty18 = isEmpty17;
var keys7 = keys6;
var make113 = make112;
var merge14 = merge13;
var reduce24 = reduce23;
var reduceSTM4 = reduceSTM3;
var remove15 = remove14;
var removeAll2 = removeAll;
var removeIf2 = removeIf;
var retainIf2 = retainIf;
var set20 = set19;
var setIfAbsent2 = setIfAbsent;
var size26 = size25;
var takeFirst2 = takeFirst;
var takeFirstSTM2 = takeFirstSTM;
var takeSome2 = takeSome;
var takeSomeSTM2 = takeSomeSTM;
var toChunk3 = toChunk2;
var toHashMap2 = toHashMap;
var toArray6 = toArray5;
var toMap2 = toMap;
var transform6 = transform5;
var transformSTM4 = transformSTM3;
var transformValues2 = transformValues;
var transformValuesSTM2 = transformValuesSTM;
var updateWith4 = updateWith3;
var values10 = values9;

// ../node_modules/effect/dist/esm/TPriorityQueue.js
var TPriorityQueue_exports = {};
__export(TPriorityQueue_exports, {
  TPriorityQueueTypeId: () => TPriorityQueueTypeId2,
  empty: () => empty51,
  fromIterable: () => fromIterable28,
  isEmpty: () => isEmpty20,
  isNonEmpty: () => isNonEmpty9,
  make: () => make115,
  offer: () => offer6,
  offerAll: () => offerAll5,
  peek: () => peek2,
  peekOption: () => peekOption2,
  removeIf: () => removeIf4,
  retainIf: () => retainIf4,
  size: () => size28,
  take: () => take11,
  takeAll: () => takeAll4,
  takeOption: () => takeOption2,
  takeUpTo: () => takeUpTo4,
  toArray: () => toArray8,
  toChunk: () => toChunk5
});

// ../node_modules/effect/dist/esm/internal/stm/tPriorityQueue.js
var TPriorityQueueSymbolKey = "effect/TPriorityQueue";
var TPriorityQueueTypeId = Symbol.for(TPriorityQueueSymbolKey);
var tPriorityQueueVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var _a75;
var TPriorityQueueImpl = class {
  constructor(ref) {
    __publicField(this, "ref");
    __publicField(this, _a75, tPriorityQueueVariance);
    this.ref = ref;
  }
};
_a75 = TPriorityQueueTypeId;
var empty50 = (order) => pipe(make107(empty45(order)), map35((ref) => new TPriorityQueueImpl(ref)));
var fromIterable27 = (order) => (iterable) => pipe(make107(fromIterable(iterable).reduce((map43, value8) => pipe(map43, set14(value8, pipe(map43, get25(value8), match2({
  onNone: () => of(value8),
  onSome: prepend(value8)
})))), empty45(order))), map35((ref) => new TPriorityQueueImpl(ref)));
var isEmpty19 = (self) => map35(get30(self.ref), isEmpty16);
var isNonEmpty8 = (self) => map35(get30(self.ref), isNonEmpty7);
var make114 = (order) => (...elements) => fromIterable27(order)(elements);
var offer5 = dual(2, (self, value8) => update11(self.ref, (map43) => set14(map43, value8, match2(get25(map43, value8), {
  onNone: () => of(value8),
  onSome: prepend(value8)
}))));
var offerAll4 = dual(2, (self, values13) => update11(self.ref, (map43) => fromIterable(values13).reduce((map44, value8) => set14(map44, value8, match2(get25(map44, value8), {
  onNone: () => of(value8),
  onSome: prepend(value8)
})), map43)));
var peek = (self) => withSTMRuntime((runtime8) => {
  const map43 = unsafeGet11(self.ref, runtime8.journal);
  return match2(headOption(map43), {
    onNone: () => retry9,
    onSome: (elements) => succeed25(elements[0])
  });
});
var peekOption = (self) => modify12(self.ref, (map43) => [map2(headOption(map43), (elements) => elements[0]), map43]);
var removeIf3 = dual(2, (self, predicate) => retainIf3(self, (a) => !predicate(a)));
var retainIf3 = dual(2, (self, predicate) => update11(self.ref, (map43) => reduce20(map43, empty45(getOrder3(map43)), (map44, value8, key) => {
  const filtered = filter(value8, predicate);
  return filtered.length > 0 ? set14(map44, key, filtered) : remove13(map44, key);
})));
var size27 = (self) => modify12(self.ref, (map43) => [reduce20(map43, 0, (n, as16) => n + as16.length), map43]);
var take10 = (self) => withSTMRuntime((runtime8) => {
  const map43 = unsafeGet11(self.ref, runtime8.journal);
  return match2(headOption(map43), {
    onNone: () => retry9,
    onSome: (values13) => {
      const head11 = values13[1][0];
      const tail4 = values13[1].slice(1);
      unsafeSet4(self.ref, tail4.length > 0 ? set14(map43, head11, tail4) : remove13(map43, head11), runtime8.journal);
      return succeed25(head11);
    }
  });
});
var takeAll3 = (self) => modify12(self.ref, (map43) => {
  const builder = [];
  for (const entry of map43) {
    for (const value8 of entry[1]) {
      builder.push(value8);
    }
  }
  return [builder, empty45(getOrder3(map43))];
});
var takeOption = (self) => effect3((journal) => {
  const map43 = pipe(self.ref, unsafeGet11(journal));
  return match2(headOption(map43), {
    onNone: () => none2(),
    onSome: ([key, value8]) => {
      const tail4 = value8.slice(1);
      unsafeSet4(self.ref, tail4.length > 0 ? set14(map43, key, tail4) : remove13(map43, key), journal);
      return some2(value8[0]);
    }
  });
});
var takeUpTo3 = dual(2, (self, n) => modify12(self.ref, (map43) => {
  const builder = [];
  const iterator = map43[Symbol.iterator]();
  let updated = map43;
  let index = 0;
  let next6;
  while ((next6 = iterator.next()) && !next6.done && index < n) {
    const [key, value8] = next6.value;
    const [left2, right2] = pipe(value8, splitAt(n - index));
    for (const value9 of left2) {
      builder.push(value9);
    }
    if (right2.length > 0) {
      updated = set14(updated, key, right2);
    } else {
      updated = remove13(updated, key);
    }
    index = index + left2.length;
  }
  return [builder, updated];
}));
var toChunk4 = (self) => modify12(self.ref, (map43) => {
  const builder = [];
  for (const entry of map43) {
    for (const value8 of entry[1]) {
      builder.push(value8);
    }
  }
  return [unsafeFromArray(builder), map43];
});
var toArray7 = (self) => modify12(self.ref, (map43) => {
  const builder = [];
  for (const entry of map43) {
    for (const value8 of entry[1]) {
      builder.push(value8);
    }
  }
  return [builder, map43];
});

// ../node_modules/effect/dist/esm/TPriorityQueue.js
var TPriorityQueueTypeId2 = TPriorityQueueTypeId;
var empty51 = empty50;
var fromIterable28 = fromIterable27;
var isEmpty20 = isEmpty19;
var isNonEmpty9 = isNonEmpty8;
var make115 = make114;
var offer6 = offer5;
var offerAll5 = offerAll4;
var peek2 = peek;
var peekOption2 = peekOption;
var removeIf4 = removeIf3;
var retainIf4 = retainIf3;
var size28 = size27;
var take11 = take10;
var takeAll4 = takeAll3;
var takeOption2 = takeOption;
var takeUpTo4 = takeUpTo3;
var toChunk5 = toChunk4;
var toArray8 = toArray7;

// ../node_modules/effect/dist/esm/TPubSub.js
var TPubSub_exports = {};
__export(TPubSub_exports, {
  TPubSubTypeId: () => TPubSubTypeId2,
  awaitShutdown: () => awaitShutdown7,
  bounded: () => bounded8,
  capacity: () => capacity8,
  dropping: () => dropping7,
  isEmpty: () => isEmpty23,
  isFull: () => isFull8,
  isShutdown: () => isShutdown7,
  publish: () => publish4,
  publishAll: () => publishAll4,
  size: () => size31,
  sliding: () => sliding9,
  subscribe: () => subscribe4,
  subscribeScoped: () => subscribeScoped2,
  unbounded: () => unbounded8
});

// ../node_modules/effect/dist/esm/internal/stm/opCodes/strategy.js
var OP_BACKPRESSURE_STRATEGY = "BackPressure";
var OP_DROPPING_STRATEGY = "Dropping";
var OP_SLIDING_STRATEGY = "Sliding";

// ../node_modules/effect/dist/esm/internal/stm/tQueue.js
var TEnqueueSymbolKey = "effect/TQueue/TEnqueue";
var TEnqueueTypeId = Symbol.for(TEnqueueSymbolKey);
var TDequeueSymbolKey = "effect/TQueue/TDequeue";
var TDequeueTypeId = Symbol.for(TDequeueSymbolKey);
var BackPressure3 = {
  _tag: OP_BACKPRESSURE_STRATEGY
};
var Dropping = {
  _tag: OP_DROPPING_STRATEGY
};
var Sliding = {
  _tag: OP_SLIDING_STRATEGY
};
var tDequeueVariance = {
  /* c8 ignore next */
  _Out: (_) => _
};
var tEnqueueVariance = {
  /* c8 ignore next */
  _In: (_) => _
};
var _a76, _b19;
var TQueueImpl = class {
  constructor(ref, requestedCapacity, strategy) {
    __publicField(this, "ref");
    __publicField(this, "requestedCapacity");
    __publicField(this, "strategy");
    __publicField(this, _a76, tDequeueVariance);
    __publicField(this, _b19, tEnqueueVariance);
    __publicField(this, "size", withSTMRuntime((runtime8) => {
      const queue = unsafeGet11(this.ref, runtime8.journal);
      if (queue === void 0) {
        return interruptAs3(runtime8.fiberId);
      }
      return succeed25(queue.length);
    }));
    __publicField(this, "isFull", map35(this.size, (size38) => size38 === this.requestedCapacity));
    __publicField(this, "isEmpty", map35(this.size, (size38) => size38 === 0));
    __publicField(this, "shutdown", withSTMRuntime((runtime8) => {
      unsafeSet4(this.ref, void 0, runtime8.journal);
      return void_10;
    }));
    __publicField(this, "isShutdown", effect3((journal) => {
      const queue = unsafeGet11(this.ref, journal);
      return queue === void 0;
    }));
    __publicField(this, "awaitShutdown", flatMap22(this.isShutdown, (isShutdown9) => isShutdown9 ? void_10 : retry9));
    __publicField(this, "peek", withSTMRuntime((runtime8) => {
      const queue = unsafeGet11(this.ref, runtime8.journal);
      if (queue === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      if (queue.length === 0) {
        return retry9;
      }
      return succeed25(queue[0]);
    }));
    __publicField(this, "peekOption", withSTMRuntime((runtime8) => {
      const queue = unsafeGet11(this.ref, runtime8.journal);
      if (queue === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      return succeed25(fromNullable(queue[0]));
    }));
    __publicField(this, "take", withSTMRuntime((runtime8) => {
      const queue = unsafeGet11(this.ref, runtime8.journal);
      if (queue === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      if (queue.length === 0) {
        return retry9;
      }
      const dequeued = queue.shift();
      unsafeSet4(this.ref, queue, runtime8.journal);
      return succeed25(dequeued);
    }));
    __publicField(this, "takeAll", withSTMRuntime((runtime8) => {
      const queue = unsafeGet11(this.ref, runtime8.journal);
      if (queue === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      unsafeSet4(this.ref, [], runtime8.journal);
      return succeed25(queue);
    }));
    this.ref = ref;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
  }
  capacity() {
    return this.requestedCapacity;
  }
  offer(value8) {
    return withSTMRuntime((runtime8) => {
      const queue = pipe(this.ref, unsafeGet11(runtime8.journal));
      if (queue === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      if (queue.length < this.requestedCapacity) {
        queue.push(value8);
        unsafeSet4(this.ref, queue, runtime8.journal);
        return succeed25(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry9;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed25(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (queue.length === 0) {
            return succeed25(true);
          }
          queue.shift();
          queue.push(value8);
          unsafeSet4(this.ref, queue, runtime8.journal);
          return succeed25(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return withSTMRuntime((runtime8) => {
      const as16 = Array.from(iterable);
      const queue = unsafeGet11(this.ref, runtime8.journal);
      if (queue === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      if (queue.length + as16.length <= this.requestedCapacity) {
        unsafeSet4(this.ref, [...queue, ...as16], runtime8.journal);
        return succeed25(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry9;
        }
        case OP_DROPPING_STRATEGY: {
          const forQueue = as16.slice(0, this.requestedCapacity - queue.length);
          unsafeSet4(this.ref, [...queue, ...forQueue], runtime8.journal);
          return succeed25(false);
        }
        case OP_SLIDING_STRATEGY: {
          const forQueue = as16.slice(0, this.requestedCapacity - queue.length);
          const toDrop = queue.length + forQueue.length - this.requestedCapacity;
          const newQueue = queue.slice(toDrop);
          unsafeSet4(this.ref, [...newQueue, ...forQueue], runtime8.journal);
          return succeed25(true);
        }
      }
    });
  }
  takeUpTo(max9) {
    return withSTMRuntime((runtime8) => {
      const queue = unsafeGet11(this.ref, runtime8.journal);
      if (queue === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      const [toTake, remaining] = splitAt2(unsafeFromArray(queue), max9);
      unsafeSet4(this.ref, Array.from(remaining), runtime8.journal);
      return succeed25(Array.from(toTake));
    });
  }
};
_a76 = TDequeueTypeId, _b19 = TEnqueueTypeId;
var isTQueue = (u) => {
  return isTEnqueue(u) && isTDequeue(u);
};
var isTEnqueue = (u) => hasProperty(u, TEnqueueTypeId);
var isTDequeue = (u) => hasProperty(u, TDequeueTypeId);
var awaitShutdown5 = (self) => self.awaitShutdown;
var bounded6 = (requestedCapacity) => makeQueue(requestedCapacity, BackPressure3);
var capacity6 = (self) => {
  return self.capacity();
};
var dropping5 = (requestedCapacity) => makeQueue(requestedCapacity, Dropping);
var isEmpty21 = (self) => self.isEmpty;
var isFull6 = (self) => self.isFull;
var isShutdown5 = (self) => self.isShutdown;
var offer7 = dual(2, (self, value8) => self.offer(value8));
var offerAll6 = dual(2, (self, iterable) => self.offerAll(iterable));
var peek3 = (self) => self.peek;
var peekOption3 = (self) => self.peekOption;
var poll11 = (self) => pipe(self.takeUpTo(1), map35(head));
var seek = dual(2, (self, predicate) => seekLoop(self, predicate));
var seekLoop = (self, predicate) => flatMap22(self.take, (a) => predicate(a) ? succeed25(a) : seekLoop(self, predicate));
var shutdown6 = (self) => self.shutdown;
var size29 = (self) => self.size;
var sliding7 = (requestedCapacity) => makeQueue(requestedCapacity, Sliding);
var take12 = (self) => self.take;
var takeAll5 = (self) => self.takeAll;
var takeBetween3 = dual(3, (self, min7, max9) => suspend13(() => {
  const takeRemainder = (min8, max10, acc) => {
    if (max10 < min8) {
      return succeed25(acc);
    }
    return pipe(self.takeUpTo(max10), flatMap22((taken) => {
      const remaining = min8 - taken.length;
      if (remaining === 1) {
        return pipe(self.take, map35((a) => pipe(acc, appendAll2(unsafeFromArray(taken)), append2(a))));
      }
      if (remaining > 1) {
        return pipe(self.take, flatMap22((a) => takeRemainder(remaining - 1, max10 - taken.length - 1, pipe(acc, appendAll2(unsafeFromArray(taken)), append2(a)))));
      }
      return succeed25(pipe(acc, appendAll2(unsafeFromArray(taken))));
    }));
  };
  return map35(takeRemainder(min7, max9, empty5()), (c) => Array.from(c));
}));
var takeN3 = dual(2, (self, n) => pipe(self, takeBetween3(n, n)));
var takeUpTo5 = dual(2, (self, max9) => self.takeUpTo(max9));
var unbounded6 = () => makeQueue(Number.MAX_SAFE_INTEGER, Dropping);
var makeQueue = (requestedCapacity, strategy) => map35(make107([]), (ref) => new TQueueImpl(ref, requestedCapacity, strategy));

// ../node_modules/effect/dist/esm/internal/stm/tPubSub.js
var TPubSubSymbolKey = "effect/TPubSub";
var TPubSubTypeId = Symbol.for(TPubSubSymbolKey);
var AbsentValue2 = Symbol.for("effect/TPubSub/AbsentValue");
var makeNode2 = (head11, subscribers, tail4) => ({
  head: head11,
  subscribers,
  tail: tail4
});
var _a77, _b20;
var TPubSubImpl = class {
  constructor(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers) {
    __publicField(this, "pubsubSize");
    __publicField(this, "publisherHead");
    __publicField(this, "publisherTail");
    __publicField(this, "requestedCapacity");
    __publicField(this, "strategy");
    __publicField(this, "subscriberCount");
    __publicField(this, "subscribers");
    __publicField(this, _a77, {
      _A: (_) => _
    });
    __publicField(this, _b20, tEnqueueVariance);
    __publicField(this, "isShutdown", effect3((journal) => {
      const currentPublisherTail = unsafeGet11(this.publisherTail, journal);
      return currentPublisherTail === void 0;
    }));
    __publicField(this, "awaitShutdown", flatMap22(this.isShutdown, (isShutdown9) => isShutdown9 ? void_10 : retry9));
    __publicField(this, "size", withSTMRuntime((runtime8) => {
      const currentPublisherTail = unsafeGet11(this.publisherTail, runtime8.journal);
      if (currentPublisherTail === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      return succeed25(unsafeGet11(this.pubsubSize, runtime8.journal));
    }));
    __publicField(this, "isEmpty", map35(this.size, (size38) => size38 === 0));
    __publicField(this, "isFull", map35(this.size, (size38) => size38 === this.capacity()));
    __publicField(this, "shutdown", effect3((journal) => {
      const currentPublisherTail = unsafeGet11(this.publisherTail, journal);
      if (currentPublisherTail !== void 0) {
        unsafeSet4(this.publisherTail, void 0, journal);
        const currentSubscribers = unsafeGet11(this.subscribers, journal);
        forEach4(currentSubscribers, (subscriber) => {
          unsafeSet4(subscriber, void 0, journal);
        });
        unsafeSet4(this.subscribers, empty8(), journal);
      }
    }));
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.publisherTail = publisherTail;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  capacity() {
    return this.requestedCapacity;
  }
  offer(value8) {
    return withSTMRuntime((runtime8) => {
      const currentPublisherTail = unsafeGet11(this.publisherTail, runtime8.journal);
      if (currentPublisherTail === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      const currentSubscriberCount = unsafeGet11(this.subscriberCount, runtime8.journal);
      if (currentSubscriberCount === 0) {
        return succeed25(true);
      }
      const currentPubSubSize = unsafeGet11(this.pubsubSize, runtime8.journal);
      if (currentPubSubSize < this.requestedCapacity) {
        const updatedPublisherTail = new TRefImpl(void 0);
        const updatedNode = makeNode2(value8, currentSubscriberCount, updatedPublisherTail);
        unsafeSet4(currentPublisherTail, updatedNode, runtime8.journal);
        unsafeSet4(this.publisherTail, updatedPublisherTail, runtime8.journal);
        unsafeSet4(this.pubsubSize, currentPubSubSize + 1, runtime8.journal);
        return succeed25(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry9;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed25(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (this.requestedCapacity > 0) {
            let currentPublisherHead = unsafeGet11(this.publisherHead, runtime8.journal);
            let loop5 = true;
            while (loop5) {
              const node = unsafeGet11(currentPublisherHead, runtime8.journal);
              if (node === void 0) {
                return retry9;
              }
              const head11 = node.head;
              const tail4 = node.tail;
              if (head11 !== AbsentValue2) {
                const updatedNode2 = makeNode2(AbsentValue2, node.subscribers, node.tail);
                unsafeSet4(currentPublisherHead, updatedNode2, runtime8.journal);
                unsafeSet4(this.publisherHead, tail4, runtime8.journal);
                loop5 = false;
              } else {
                currentPublisherHead = tail4;
              }
            }
          }
          const updatedPublisherTail = new TRefImpl(void 0);
          const updatedNode = makeNode2(value8, currentSubscriberCount, updatedPublisherTail);
          unsafeSet4(currentPublisherTail, updatedNode, runtime8.journal);
          unsafeSet4(this.publisherTail, updatedPublisherTail, runtime8.journal);
          return succeed25(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return map35(forEach15(iterable, (a) => this.offer(a)), every(identity));
  }
};
_a77 = TPubSubTypeId, _b20 = TEnqueueTypeId;
var _a78, _b21;
var TPubSubSubscriptionImpl = class {
  constructor(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers) {
    __publicField(this, "pubsubSize");
    __publicField(this, "publisherHead");
    __publicField(this, "requestedCapacity");
    __publicField(this, "subscriberHead");
    __publicField(this, "subscriberCount");
    __publicField(this, "subscribers");
    __publicField(this, _a78, TPubSubTypeId);
    __publicField(this, _b21, tDequeueVariance);
    __publicField(this, "isShutdown", effect3((journal) => {
      const currentSubscriberHead = unsafeGet11(this.subscriberHead, journal);
      return currentSubscriberHead === void 0;
    }));
    __publicField(this, "awaitShutdown", flatMap22(this.isShutdown, (isShutdown9) => isShutdown9 ? void_10 : retry9));
    __publicField(this, "size", withSTMRuntime((runtime8) => {
      let currentSubscriberHead = unsafeGet11(this.subscriberHead, runtime8.journal);
      if (currentSubscriberHead === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      let loop5 = true;
      let size38 = 0;
      while (loop5) {
        const node = unsafeGet11(currentSubscriberHead, runtime8.journal);
        if (node === void 0) {
          loop5 = false;
        } else {
          const head11 = node.head;
          const tail4 = node.tail;
          if (head11 !== AbsentValue2) {
            size38 = size38 + 1;
            if (size38 >= Number.MAX_SAFE_INTEGER) {
              loop5 = false;
            }
          }
          currentSubscriberHead = tail4;
        }
      }
      return succeed25(size38);
    }));
    __publicField(this, "isEmpty", map35(this.size, (size38) => size38 === 0));
    __publicField(this, "isFull", map35(this.size, (size38) => size38 === this.capacity()));
    __publicField(this, "peek", withSTMRuntime((runtime8) => {
      let currentSubscriberHead = unsafeGet11(this.subscriberHead, runtime8.journal);
      if (currentSubscriberHead === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      let value8 = AbsentValue2;
      let loop5 = true;
      while (loop5) {
        const node = unsafeGet11(currentSubscriberHead, runtime8.journal);
        if (node === void 0) {
          return retry9;
        }
        const head11 = node.head;
        const tail4 = node.tail;
        if (head11 !== AbsentValue2) {
          value8 = head11;
          loop5 = false;
        } else {
          currentSubscriberHead = tail4;
        }
      }
      return succeed25(value8);
    }));
    __publicField(this, "peekOption", withSTMRuntime((runtime8) => {
      let currentSubscriberHead = unsafeGet11(this.subscriberHead, runtime8.journal);
      if (currentSubscriberHead === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      let value8 = none2();
      let loop5 = true;
      while (loop5) {
        const node = unsafeGet11(currentSubscriberHead, runtime8.journal);
        if (node === void 0) {
          value8 = none2();
          loop5 = false;
        } else {
          const head11 = node.head;
          const tail4 = node.tail;
          if (head11 !== AbsentValue2) {
            value8 = some2(head11);
            loop5 = false;
          } else {
            currentSubscriberHead = tail4;
          }
        }
      }
      return succeed25(value8);
    }));
    __publicField(this, "shutdown", effect3((journal) => {
      let currentSubscriberHead = unsafeGet11(this.subscriberHead, journal);
      if (currentSubscriberHead !== void 0) {
        unsafeSet4(this.subscriberHead, void 0, journal);
        let loop5 = true;
        while (loop5) {
          const node = unsafeGet11(currentSubscriberHead, journal);
          if (node === void 0) {
            loop5 = false;
          } else {
            const head11 = node.head;
            const tail4 = node.tail;
            if (head11 !== AbsentValue2) {
              const subscribers = node.subscribers;
              if (subscribers === 1) {
                const size38 = unsafeGet11(this.pubsubSize, journal);
                const updatedNode = makeNode2(AbsentValue2, 0, tail4);
                unsafeSet4(currentSubscriberHead, updatedNode, journal);
                unsafeSet4(this.publisherHead, tail4, journal);
                unsafeSet4(this.pubsubSize, size38 - 1, journal);
              } else {
                const updatedNode = makeNode2(head11, subscribers - 1, tail4);
                unsafeSet4(currentSubscriberHead, updatedNode, journal);
              }
            }
            currentSubscriberHead = tail4;
          }
        }
        const currentSubscriberCount = unsafeGet11(this.subscriberCount, journal);
        unsafeSet4(this.subscriberCount, currentSubscriberCount - 1, journal);
        unsafeSet4(this.subscribers, remove5(unsafeGet11(this.subscribers, journal), this.subscriberHead), journal);
      }
    }));
    __publicField(this, "take", withSTMRuntime((runtime8) => {
      let currentSubscriberHead = unsafeGet11(this.subscriberHead, runtime8.journal);
      if (currentSubscriberHead === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      let value8 = AbsentValue2;
      let loop5 = true;
      while (loop5) {
        const node = unsafeGet11(currentSubscriberHead, runtime8.journal);
        if (node === void 0) {
          return retry9;
        }
        const head11 = node.head;
        const tail4 = node.tail;
        if (head11 !== AbsentValue2) {
          const subscribers = node.subscribers;
          if (subscribers === 1) {
            const size38 = unsafeGet11(this.pubsubSize, runtime8.journal);
            const updatedNode = makeNode2(AbsentValue2, 0, tail4);
            unsafeSet4(currentSubscriberHead, updatedNode, runtime8.journal);
            unsafeSet4(this.publisherHead, tail4, runtime8.journal);
            unsafeSet4(this.pubsubSize, size38 - 1, runtime8.journal);
          } else {
            const updatedNode = makeNode2(head11, subscribers - 1, tail4);
            unsafeSet4(currentSubscriberHead, updatedNode, runtime8.journal);
          }
          unsafeSet4(this.subscriberHead, tail4, runtime8.journal);
          value8 = head11;
          loop5 = false;
        } else {
          currentSubscriberHead = tail4;
        }
      }
      return succeed25(value8);
    }));
    __publicField(this, "takeAll", this.takeUpTo(Number.POSITIVE_INFINITY));
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.requestedCapacity = requestedCapacity;
    this.subscriberHead = subscriberHead;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  capacity() {
    return this.requestedCapacity;
  }
  takeUpTo(max9) {
    return withSTMRuntime((runtime8) => {
      let currentSubscriberHead = unsafeGet11(this.subscriberHead, runtime8.journal);
      if (currentSubscriberHead === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      const builder = [];
      let n = 0;
      while (n !== max9) {
        const node = unsafeGet11(currentSubscriberHead, runtime8.journal);
        if (node === void 0) {
          n = max9;
        } else {
          const head11 = node.head;
          const tail4 = node.tail;
          if (head11 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size38 = unsafeGet11(this.pubsubSize, runtime8.journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail4);
              unsafeSet4(currentSubscriberHead, updatedNode, runtime8.journal);
              unsafeSet4(this.publisherHead, tail4, runtime8.journal);
              unsafeSet4(this.pubsubSize, size38 - 1, runtime8.journal);
            } else {
              const updatedNode = makeNode2(head11, subscribers - 1, tail4);
              unsafeSet4(currentSubscriberHead, updatedNode, runtime8.journal);
            }
            builder.push(head11);
            n = n + 1;
          }
          currentSubscriberHead = tail4;
        }
      }
      unsafeSet4(this.subscriberHead, currentSubscriberHead, runtime8.journal);
      return succeed25(builder);
    });
  }
};
_a78 = TPubSubTypeId, _b21 = TDequeueTypeId;
var makeTPubSub = (requestedCapacity, strategy) => pipe(all10([make107(void 0), make107(0)]), flatMap22(([empty57, pubsubSize]) => pipe(all10([make107(empty57), make107(empty57), make107(0), make107(empty8())]), map35(([publisherHead, publisherTail, subscriberCount, subscribers]) => new TPubSubImpl(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers)))));
var makeSubscription2 = (pubsubSize, publisherHead, publisherTail, requestedCapacity, subscriberCount, subscribers) => pipe(get30(publisherTail), flatMap22((currentPublisherTail) => pipe(all10([make107(currentPublisherTail), get30(subscriberCount), get30(subscribers)]), tap8(([_, currentSubscriberCount]) => pipe(subscriberCount, set18(currentSubscriberCount + 1))), tap8(([subscriberHead, _, currentSubscribers]) => pipe(subscribers, set18(pipe(currentSubscribers, add4(subscriberHead))))), map35(([subscriberHead]) => new TPubSubSubscriptionImpl(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers)))));
var awaitShutdown6 = (self) => self.awaitShutdown;
var bounded7 = (requestedCapacity) => makeTPubSub(requestedCapacity, BackPressure3);
var capacity7 = (self) => self.capacity();
var dropping6 = (requestedCapacity) => makeTPubSub(requestedCapacity, Dropping);
var isEmpty22 = (self) => self.isEmpty;
var isFull7 = (self) => self.isFull;
var isShutdown6 = (self) => self.isShutdown;
var publish3 = dual(2, (self, value8) => self.offer(value8));
var publishAll3 = dual(2, (self, iterable) => self.offerAll(iterable));
var size30 = (self) => self.size;
var sliding8 = (requestedCapacity) => makeTPubSub(requestedCapacity, Sliding);
var subscribe3 = (self) => makeSubscription2(self.pubsubSize, self.publisherHead, self.publisherTail, self.requestedCapacity, self.subscriberCount, self.subscribers);
var subscribeScoped = (self) => acquireRelease2(subscribe3(self), (dequeue) => shutdown6(dequeue));
var unbounded7 = () => makeTPubSub(Number.MAX_SAFE_INTEGER, Dropping);

// ../node_modules/effect/dist/esm/TPubSub.js
var TPubSubTypeId2 = TPubSubTypeId;
var awaitShutdown7 = awaitShutdown6;
var bounded8 = bounded7;
var capacity8 = capacity7;
var dropping7 = dropping6;
var isEmpty23 = isEmpty22;
var isFull8 = isFull7;
var isShutdown7 = isShutdown6;
var publish4 = publish3;
var publishAll4 = publishAll3;
var size31 = size30;
var sliding9 = sliding8;
var subscribe4 = subscribe3;
var subscribeScoped2 = subscribeScoped;
var unbounded8 = unbounded7;

// ../node_modules/effect/dist/esm/TQueue.js
var TQueue_exports = {};
__export(TQueue_exports, {
  TDequeueTypeId: () => TDequeueTypeId2,
  TEnqueueTypeId: () => TEnqueueTypeId2,
  awaitShutdown: () => awaitShutdown8,
  bounded: () => bounded9,
  capacity: () => capacity9,
  dropping: () => dropping8,
  isEmpty: () => isEmpty24,
  isFull: () => isFull9,
  isShutdown: () => isShutdown8,
  isTDequeue: () => isTDequeue2,
  isTEnqueue: () => isTEnqueue2,
  isTQueue: () => isTQueue2,
  offer: () => offer8,
  offerAll: () => offerAll7,
  peek: () => peek4,
  peekOption: () => peekOption4,
  poll: () => poll12,
  seek: () => seek2,
  shutdown: () => shutdown7,
  size: () => size32,
  sliding: () => sliding10,
  take: () => take13,
  takeAll: () => takeAll6,
  takeBetween: () => takeBetween4,
  takeN: () => takeN4,
  takeUpTo: () => takeUpTo6,
  unbounded: () => unbounded9
});
var TDequeueTypeId2 = TDequeueTypeId;
var TEnqueueTypeId2 = TEnqueueTypeId;
var isTQueue2 = isTQueue;
var isTDequeue2 = isTDequeue;
var isTEnqueue2 = isTEnqueue;
var awaitShutdown8 = awaitShutdown5;
var bounded9 = bounded6;
var capacity9 = capacity6;
var dropping8 = dropping5;
var isEmpty24 = isEmpty21;
var isFull9 = isFull6;
var isShutdown8 = isShutdown5;
var offer8 = offer7;
var offerAll7 = offerAll6;
var peek4 = peek3;
var peekOption4 = peekOption3;
var poll12 = poll11;
var seek2 = seek;
var shutdown7 = shutdown6;
var size32 = size29;
var sliding10 = sliding7;
var take13 = take12;
var takeAll6 = takeAll5;
var takeBetween4 = takeBetween3;
var takeN4 = takeN3;
var takeUpTo6 = takeUpTo5;
var unbounded9 = unbounded6;

// ../node_modules/effect/dist/esm/TRandom.js
var TRandom_exports = {};
__export(TRandom_exports, {
  TRandomTypeId: () => TRandomTypeId2,
  Tag: () => Tag5,
  live: () => live2,
  next: () => next5,
  nextBoolean: () => nextBoolean4,
  nextInt: () => nextInt4,
  nextIntBetween: () => nextIntBetween4,
  nextRange: () => nextRange4,
  shuffle: () => shuffle4
});

// ../node_modules/effect/dist/esm/internal/stm/tRandom.js
var TRandomSymbolKey = "effect/TRandom";
var TRandomTypeId = Symbol.for(TRandomSymbolKey);
var randomInteger = (state) => {
  const prng = new PCGRandom();
  prng.setState(state);
  return [prng.integer(0), prng.getState()];
};
var randomIntegerBetween = (low, high) => {
  return (state) => {
    const prng = new PCGRandom();
    prng.setState(state);
    return [prng.integer(high - low) + low, prng.getState()];
  };
};
var randomNumber = (state) => {
  const prng = new PCGRandom();
  prng.setState(state);
  return [prng.number(), prng.getState()];
};
var withState = (state, f) => {
  return pipe(state, modify12(f));
};
var shuffleWith2 = (iterable, nextIntBounded) => {
  const swap3 = (buffer5, index1, index2) => pipe(buffer5, get31(index1), flatMap22((tmp) => pipe(buffer5, updateSTM(index1, () => pipe(buffer5, get31(index2))), zipRight14(pipe(buffer5, update12(index2, () => tmp))))));
  return pipe(fromIterable23(iterable), flatMap22((buffer5) => {
    const array6 = [];
    for (let i = array6.length; i >= 2; i = i - 1) {
      array6.push(i);
    }
    return pipe(array6, forEach15((n) => pipe(nextIntBounded(n), flatMap22((k) => swap3(buffer5, n - 1, k))), {
      discard: true
    }), zipRight14(toArray3(buffer5)));
  }));
};
var Tag4 = GenericTag("effect/TRandom");
var _a79;
var TRandomImpl = class {
  constructor(state) {
    __publicField(this, "state");
    __publicField(this, _a79, TRandomTypeId);
    __publicField(this, "next");
    __publicField(this, "nextBoolean");
    __publicField(this, "nextInt");
    this.state = state;
    this.next = withState(this.state, randomNumber);
    this.nextBoolean = flatMap22(this.next, (n) => succeed25(n > 0.5));
    this.nextInt = withState(this.state, randomInteger);
  }
  nextRange(min7, max9) {
    return flatMap22(this.next, (n) => succeed25((max9 - min7) * n + min7));
  }
  nextIntBetween(low, high) {
    return withState(this.state, randomIntegerBetween(low, high));
  }
  shuffle(elements) {
    return shuffleWith2(elements, (n) => this.nextIntBetween(0, n));
  }
};
_a79 = TRandomTypeId;
var live = effect(Tag4, pipe(make107(new PCGRandom(Math.random() * 4294967296 >>> 0).getState()), map35((seed) => new TRandomImpl(seed)), commit2));
var next4 = flatMap22(Tag4, (random4) => random4.next);
var nextBoolean3 = flatMap22(Tag4, (random4) => random4.nextBoolean);
var nextInt3 = flatMap22(Tag4, (random4) => random4.nextInt);
var nextIntBetween3 = (low, high) => flatMap22(Tag4, (random4) => random4.nextIntBetween(low, high));
var nextRange3 = (min7, max9) => flatMap22(Tag4, (random4) => random4.nextRange(min7, max9));
var shuffle3 = (elements) => flatMap22(Tag4, (random4) => random4.shuffle(elements));

// ../node_modules/effect/dist/esm/TRandom.js
var TRandomTypeId2 = TRandomTypeId;
var Tag5 = Tag4;
var live2 = live;
var next5 = next4;
var nextBoolean4 = nextBoolean3;
var nextInt4 = nextInt3;
var nextIntBetween4 = nextIntBetween3;
var nextRange4 = nextRange3;
var shuffle4 = shuffle3;

// ../node_modules/effect/dist/esm/TReentrantLock.js
var TReentrantLock_exports = {};
__export(TReentrantLock_exports, {
  TReentrantLockTypeId: () => TReentrantLockTypeId2,
  acquireRead: () => acquireRead2,
  acquireWrite: () => acquireWrite2,
  fiberReadLocks: () => fiberReadLocks2,
  fiberWriteLocks: () => fiberWriteLocks2,
  lock: () => lock2,
  locked: () => locked2,
  make: () => make117,
  readLock: () => readLock2,
  readLocked: () => readLocked2,
  readLocks: () => readLocks2,
  releaseRead: () => releaseRead2,
  releaseWrite: () => releaseWrite2,
  withLock: () => withLock2,
  withReadLock: () => withReadLock2,
  withWriteLock: () => withWriteLock2,
  writeLock: () => writeLock2,
  writeLocked: () => writeLocked2,
  writeLocks: () => writeLocks2
});

// ../node_modules/effect/dist/esm/internal/stm/tReentrantLock.js
var TReentrantLockSymbolKey = "effect/TReentrantLock";
var TReentrantLockTypeId = Symbol.for(TReentrantLockSymbolKey);
var WriteLockTypeId = Symbol.for("effect/TReentrantLock/WriteLock");
var ReadLockTypeId = Symbol.for("effect/TReentrantLock/ReadLock");
var _a80;
var TReentranLockImpl = class {
  constructor(state) {
    __publicField(this, "state");
    __publicField(this, _a80, TReentrantLockTypeId);
    this.state = state;
  }
};
_a80 = TReentrantLockTypeId;
var _a81;
var ReadLock = class {
  constructor(readers) {
    __publicField(this, "readers");
    __publicField(this, _a81, ReadLockTypeId);
    this.readers = readers;
  }
  get readLocks() {
    return Array.from(this.readers).reduce((acc, curr) => acc + curr[1], 0);
  }
  get writeLocks() {
    return 0;
  }
  readLocksHeld(fiberId5) {
    return getOrElse(get6(this.readers, fiberId5), () => 0);
  }
  writeLocksHeld(_fiberId) {
    return 0;
  }
};
_a81 = ReadLockTypeId;
var _a82;
var WriteLock = class {
  constructor(readLocks3, writeLocks3, fiberId5) {
    __publicField(this, "readLocks");
    __publicField(this, "writeLocks");
    __publicField(this, "fiberId");
    __publicField(this, _a82, WriteLockTypeId);
    this.readLocks = readLocks3;
    this.writeLocks = writeLocks3;
    this.fiberId = fiberId5;
  }
  readLocksHeld(fiberId5) {
    return equals(fiberId5)(this.fiberId) ? this.readLocks : 0;
  }
  writeLocksHeld(fiberId5) {
    return equals(fiberId5)(this.fiberId) ? this.writeLocks : 0;
  }
};
_a82 = WriteLockTypeId;
var isReadLock = (lock3) => {
  return ReadLockTypeId in lock3;
};
var isWriteLock = (lock3) => {
  return WriteLockTypeId in lock3;
};
var emptyReadLock = new ReadLock(empty9());
var makeReadLock = (fiberId5, count9) => {
  if (count9 <= 0) {
    return emptyReadLock;
  }
  return new ReadLock(make16([fiberId5, count9]));
};
var noOtherHolder = (readLock3, fiberId5) => {
  return isEmpty3(readLock3.readers) || size5(readLock3.readers) === 1 && has4(readLock3.readers, fiberId5);
};
var adjustReadLock = (readLock3, fiberId5, adjustment) => {
  const total = readLock3.readLocksHeld(fiberId5);
  const newTotal = total + adjustment;
  if (newTotal < 0) {
    throw new Error("BUG - TReentrantLock.ReadLock.adjust - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  if (newTotal === 0) {
    return new ReadLock(remove6(readLock3.readers, fiberId5));
  }
  return new ReadLock(set3(readLock3.readers, fiberId5, newTotal));
};
var adjustRead = (self, delta) => withSTMRuntime((runtime8) => {
  const lock3 = unsafeGet11(self.state, runtime8.journal);
  if (isReadLock(lock3)) {
    const result = adjustReadLock(lock3, runtime8.fiberId, delta);
    unsafeSet4(self.state, result, runtime8.journal);
    return succeed25(result.readLocksHeld(runtime8.fiberId));
  }
  if (isWriteLock(lock3) && equals(runtime8.fiberId)(lock3.fiberId)) {
    const newTotal = lock3.readLocks + delta;
    if (newTotal < 0) {
      throw new Error(`Defect: Fiber ${threadName2(runtime8.fiberId)} releasing read locks it does not hold, newTotal: ${newTotal}`);
    }
    unsafeSet4(self.state, new WriteLock(newTotal, lock3.writeLocks, runtime8.fiberId), runtime8.journal);
    return succeed25(newTotal);
  }
  return retry9;
});
var acquireRead = (self) => adjustRead(self, 1);
var acquireWrite = (self) => withSTMRuntime((runtime8) => {
  const lock3 = unsafeGet11(self.state, runtime8.journal);
  if (isReadLock(lock3) && noOtherHolder(lock3, runtime8.fiberId)) {
    unsafeSet4(self.state, new WriteLock(lock3.readLocksHeld(runtime8.fiberId), 1, runtime8.fiberId), runtime8.journal);
    return succeed25(1);
  }
  if (isWriteLock(lock3) && equals(runtime8.fiberId)(lock3.fiberId)) {
    unsafeSet4(self.state, new WriteLock(lock3.readLocks, lock3.writeLocks + 1, runtime8.fiberId), runtime8.journal);
    return succeed25(lock3.writeLocks + 1);
  }
  return retry9;
});
var fiberReadLocks = (self) => effect3((journal, fiberId5) => unsafeGet11(self.state, journal).readLocksHeld(fiberId5));
var fiberWriteLocks = (self) => effect3((journal, fiberId5) => unsafeGet11(self.state, journal).writeLocksHeld(fiberId5));
var lock = (self) => writeLock(self);
var locked = (self) => zipWith16(readLocked(self), writeLocked(self), (x, y) => x || y);
var make116 = map35(make107(emptyReadLock), (readLock3) => new TReentranLockImpl(readLock3));
var readLock = (self) => acquireRelease2(commit2(acquireRead(self)), () => commit2(releaseRead(self)));
var readLocks = (self) => map35(get30(self.state), (state) => state.readLocks);
var readLocked = (self) => map35(get30(self.state), (state) => state.readLocks > 0);
var releaseRead = (self) => adjustRead(self, -1);
var releaseWrite = (self) => withSTMRuntime((runtime8) => {
  const lock3 = unsafeGet11(self.state, runtime8.journal);
  if (isWriteLock(lock3) && lock3.writeLocks === 1 && equals(runtime8.fiberId)(lock3.fiberId)) {
    const result = makeReadLock(lock3.fiberId, lock3.readLocks);
    unsafeSet4(self.state, result, runtime8.journal);
    return succeed25(result.writeLocksHeld(runtime8.fiberId));
  }
  if (isWriteLock(lock3) && equals(runtime8.fiberId)(lock3.fiberId)) {
    const result = new WriteLock(lock3.readLocks, lock3.writeLocks - 1, runtime8.fiberId);
    unsafeSet4(self.state, result, runtime8.journal);
    return succeed25(result.writeLocksHeld(runtime8.fiberId));
  }
  throw new Error(`Defect: Fiber ${threadName2(runtime8.fiberId)} releasing write lock it does not hold`);
});
var withLock = dual(2, (effect4, self) => withWriteLock(effect4, self));
var withReadLock = dual(2, (effect4, self) => uninterruptibleMask2((restore) => zipRight6(restore(commit2(acquireRead(self))), ensuring3(effect4, commit2(releaseRead(self))))));
var withWriteLock = dual(2, (effect4, self) => uninterruptibleMask2((restore) => zipRight6(restore(commit2(acquireWrite(self))), ensuring3(effect4, commit2(releaseWrite(self))))));
var writeLock = (self) => acquireRelease2(commit2(acquireWrite(self)), () => commit2(releaseWrite(self)));
var writeLocked = (self) => map35(get30(self.state), (state) => state.writeLocks > 0);
var writeLocks = (self) => map35(get30(self.state), (state) => state.writeLocks);

// ../node_modules/effect/dist/esm/TReentrantLock.js
var TReentrantLockTypeId2 = TReentrantLockTypeId;
var acquireRead2 = acquireRead;
var acquireWrite2 = acquireWrite;
var fiberReadLocks2 = fiberReadLocks;
var fiberWriteLocks2 = fiberWriteLocks;
var lock2 = lock;
var locked2 = locked;
var make117 = make116;
var readLock2 = readLock;
var readLocks2 = readLocks;
var readLocked2 = readLocked;
var releaseRead2 = releaseRead;
var releaseWrite2 = releaseWrite;
var withLock2 = withLock;
var withReadLock2 = withReadLock;
var withWriteLock2 = withWriteLock;
var writeLock2 = writeLock;
var writeLocked2 = writeLocked;
var writeLocks2 = writeLocks;

// ../node_modules/effect/dist/esm/TRef.js
var TRef_exports = {};
__export(TRef_exports, {
  TRefTypeId: () => TRefTypeId2,
  get: () => get35,
  getAndSet: () => getAndSet8,
  getAndUpdate: () => getAndUpdate8,
  getAndUpdateSome: () => getAndUpdateSome7,
  make: () => make118,
  modify: () => modify13,
  modifySome: () => modifySome7,
  set: () => set21,
  setAndGet: () => setAndGet7,
  update: () => update14,
  updateAndGet: () => updateAndGet8,
  updateSome: () => updateSome7,
  updateSomeAndGet: () => updateSomeAndGet7
});
var TRefTypeId2 = TRefTypeId;
var get35 = get30;
var getAndSet8 = getAndSet7;
var getAndUpdate8 = getAndUpdate7;
var getAndUpdateSome7 = getAndUpdateSome6;
var make118 = make107;
var modify13 = modify12;
var modifySome7 = modifySome6;
var set21 = set18;
var setAndGet7 = setAndGet6;
var update14 = update11;
var updateAndGet8 = updateAndGet7;
var updateSome7 = updateSome6;
var updateSomeAndGet7 = updateSomeAndGet6;

// ../node_modules/effect/dist/esm/TSemaphore.js
var TSemaphore_exports = {};
__export(TSemaphore_exports, {
  TSemaphoreTypeId: () => TSemaphoreTypeId2,
  acquire: () => acquire2,
  acquireN: () => acquireN2,
  available: () => available2,
  make: () => make120,
  release: () => release2,
  releaseN: () => releaseN2,
  unsafeMake: () => unsafeMake18,
  withPermit: () => withPermit2,
  withPermitScoped: () => withPermitScoped2,
  withPermits: () => withPermits2,
  withPermitsScoped: () => withPermitsScoped2
});

// ../node_modules/effect/dist/esm/internal/stm/tSemaphore.js
var TSemaphoreSymbolKey = "effect/TSemaphore";
var TSemaphoreTypeId = Symbol.for(TSemaphoreSymbolKey);
var _a83;
var TSemaphoreImpl = class {
  constructor(permits) {
    __publicField(this, "permits");
    __publicField(this, _a83, TSemaphoreTypeId);
    this.permits = permits;
  }
};
_a83 = TSemaphoreTypeId;
var make119 = (permits) => map36(make107(permits), (permits2) => new TSemaphoreImpl(permits2));
var acquire = (self) => acquireN(self, 1);
var acquireN = dual(2, (self, n) => withSTMRuntime((driver3) => {
  if (n < 0) {
    throw new IllegalArgumentException2(`Unexpected negative value ${n} passed to Semaphore.acquireN`);
  }
  const value8 = unsafeGet11(self.permits, driver3.journal);
  if (value8 < n) {
    return retry10;
  } else {
    return succeed26(unsafeSet4(self.permits, value8 - n, driver3.journal));
  }
}));
var available = (self) => get30(self.permits);
var release = (self) => releaseN(self, 1);
var releaseN = dual(2, (self, n) => withSTMRuntime((driver3) => {
  if (n < 0) {
    throw new IllegalArgumentException2(`Unexpected negative value ${n} passed to Semaphore.releaseN`);
  }
  const current2 = unsafeGet11(self.permits, driver3.journal);
  return succeed26(unsafeSet4(self.permits, current2 + n, driver3.journal));
}));
var withPermit = dual(2, (self, semaphore) => withPermits(self, semaphore, 1));
var withPermits = dual(3, (self, semaphore, permits) => uninterruptibleMask2((restore) => zipRight6(restore(commit2(acquireN(permits)(semaphore))), ensuring3(self, commit2(releaseN(permits)(semaphore))))));
var withPermitScoped = (self) => withPermitsScoped(self, 1);
var withPermitsScoped = dual(2, (self, permits) => acquireReleaseInterruptible2(commit2(acquireN(self, permits)), () => commit2(releaseN(self, permits))));
var unsafeMakeSemaphore3 = (permits) => {
  return new TSemaphoreImpl(new TRefImpl(permits));
};

// ../node_modules/effect/dist/esm/TSemaphore.js
var TSemaphoreTypeId2 = TSemaphoreTypeId;
var acquire2 = acquire;
var acquireN2 = acquireN;
var available2 = available;
var make120 = make119;
var release2 = release;
var releaseN2 = releaseN;
var withPermit2 = withPermit;
var withPermits2 = withPermits;
var withPermitScoped2 = withPermitScoped;
var withPermitsScoped2 = withPermitsScoped;
var unsafeMake18 = unsafeMakeSemaphore3;

// ../node_modules/effect/dist/esm/TSet.js
var TSet_exports = {};
__export(TSet_exports, {
  TSetTypeId: () => TSetTypeId2,
  add: () => add10,
  difference: () => difference5,
  empty: () => empty53,
  forEach: () => forEach23,
  fromIterable: () => fromIterable30,
  has: () => has15,
  intersection: () => intersection7,
  isEmpty: () => isEmpty26,
  make: () => make122,
  reduce: () => reduce26,
  reduceSTM: () => reduceSTM6,
  remove: () => remove17,
  removeAll: () => removeAll4,
  removeIf: () => removeIf6,
  retainIf: () => retainIf6,
  size: () => size34,
  takeFirst: () => takeFirst4,
  takeFirstSTM: () => takeFirstSTM4,
  takeSome: () => takeSome4,
  takeSomeSTM: () => takeSomeSTM4,
  toArray: () => toArray10,
  toChunk: () => toChunk7,
  toHashSet: () => toHashSet2,
  toReadonlySet: () => toReadonlySet2,
  transform: () => transform8,
  transformSTM: () => transformSTM6,
  union: () => union15
});

// ../node_modules/effect/dist/esm/internal/stm/tSet.js
var TSetSymbolKey = "effect/TSet";
var TSetTypeId = Symbol.for(TSetSymbolKey);
var tSetVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var _a84;
var TSetImpl = class {
  constructor(tMap) {
    __publicField(this, "tMap");
    __publicField(this, _a84, tSetVariance);
    this.tMap = tMap;
  }
};
_a84 = TSetTypeId;
var isTSet = (u) => hasProperty(u, TSetTypeId);
var add9 = dual(2, (self, value8) => set19(self.tMap, value8, void 0));
var difference4 = dual(2, (self, other) => flatMap22(toHashSet(other), (values13) => removeIf5(self, (value8) => has3(values13, value8), {
  discard: true
})));
var empty52 = () => fromIterable29([]);
var forEach22 = dual(2, (self, f) => reduceSTM5(self, void 0, (_, value8) => f(value8)));
var fromIterable29 = (iterable) => map35(fromIterable25(Array.from(iterable).map((a) => [a, void 0])), (tMap) => new TSetImpl(tMap));
var has14 = dual(2, (self, value8) => has12(self.tMap, value8));
var intersection6 = dual(2, (self, other) => flatMap22(toHashSet(other), (values13) => pipe(self, retainIf5((value8) => pipe(values13, has3(value8)), {
  discard: true
}))));
var isEmpty25 = (self) => isEmpty17(self.tMap);
var make121 = (...elements) => fromIterable29(elements);
var reduce25 = dual(3, (self, zero3, f) => reduce23(self.tMap, zero3, (acc, _, key) => f(acc, key)));
var reduceSTM5 = dual(3, (self, zero3, f) => reduceSTM3(self.tMap, zero3, (acc, _, key) => f(acc, key)));
var remove16 = dual(2, (self, value8) => remove14(self.tMap, value8));
var removeAll3 = dual(2, (self, iterable) => removeAll(self.tMap, iterable));
var removeIf5 = dual((args) => isTSet(args[0]), (self, predicate, options) => (options == null ? void 0 : options.discard) === true ? removeIf(self.tMap, (key) => predicate(key), {
  discard: true
}) : pipe(removeIf(self.tMap, (key) => predicate(key)), map35(map3((entry) => entry[0]))));
var retainIf5 = dual((args) => isTSet(args[0]), (self, predicate, options) => (options == null ? void 0 : options.discard) === true ? retainIf(self.tMap, (key) => predicate(key), {
  discard: true
}) : pipe(retainIf(self.tMap, (key) => predicate(key)), map35(map3((entry) => entry[0]))));
var size33 = (self) => map35(toChunk6(self), (chunk7) => chunk7.length);
var takeFirst3 = dual(2, (self, pf) => takeFirst(self.tMap, (key) => pf(key)));
var takeFirstSTM3 = dual(2, (self, pf) => takeFirstSTM(self.tMap, (key) => pf(key)));
var takeSome3 = dual(2, (self, pf) => takeSome(self.tMap, (key) => pf(key)));
var takeSomeSTM3 = dual(2, (self, pf) => takeSomeSTM(self.tMap, (key) => pf(key)));
var toChunk6 = (self) => keys6(self.tMap).pipe(map36(unsafeFromArray));
var toHashSet = (self) => reduce25(self, empty8(), (acc, value8) => pipe(acc, add4(value8)));
var toArray9 = (self) => reduce25(self, [], (acc, value8) => [...acc, value8]);
var toReadonlySet = (self) => map35(toArray9(self), (values13) => new Set(values13));
var transform7 = dual(2, (self, f) => transform5(self.tMap, (key, value8) => [f(key), value8]));
var transformSTM5 = dual(2, (self, f) => transformSTM3(self.tMap, (key, value8) => map35(f(key), (a) => [a, value8])));
var union14 = dual(2, (self, other) => forEach22(other, (value8) => add9(self, value8)));

// ../node_modules/effect/dist/esm/TSet.js
var TSetTypeId2 = TSetTypeId;
var add10 = add9;
var difference5 = difference4;
var empty53 = empty52;
var forEach23 = forEach22;
var fromIterable30 = fromIterable29;
var has15 = has14;
var intersection7 = intersection6;
var isEmpty26 = isEmpty25;
var make122 = make121;
var reduce26 = reduce25;
var reduceSTM6 = reduceSTM5;
var remove17 = remove16;
var removeAll4 = removeAll3;
var removeIf6 = removeIf5;
var retainIf6 = retainIf5;
var size34 = size33;
var takeFirst4 = takeFirst3;
var takeFirstSTM4 = takeFirstSTM3;
var takeSome4 = takeSome3;
var takeSomeSTM4 = takeSomeSTM3;
var toChunk7 = toChunk6;
var toHashSet2 = toHashSet;
var toArray10 = toArray9;
var toReadonlySet2 = toReadonlySet;
var transform8 = transform7;
var transformSTM6 = transformSTM5;
var union15 = union14;

// ../node_modules/effect/dist/esm/Take.js
var Take_exports = {};
__export(Take_exports, {
  TakeTypeId: () => TakeTypeId2,
  chunk: () => chunk6,
  die: () => die17,
  dieMessage: () => dieMessage10,
  done: () => done14,
  end: () => end6,
  fail: () => fail27,
  failCause: () => failCause19,
  fromEffect: () => fromEffect16,
  fromExit: () => fromExit2,
  fromPull: () => fromPull4,
  isDone: () => isDone8,
  isFailure: () => isFailure10,
  isSuccess: () => isSuccess8,
  make: () => make123,
  map: () => map40,
  match: () => match35,
  matchEffect: () => matchEffect5,
  of: () => of7,
  tap: () => tap10
});
var TakeTypeId2 = TakeTypeId;
var chunk6 = chunk3;
var die17 = die10;
var dieMessage10 = dieMessage4;
var done14 = done9;
var end6 = end4;
var fail27 = fail15;
var failCause19 = failCause13;
var fromEffect16 = fromEffect8;
var fromExit2 = fromExit;
var fromPull4 = fromPull;
var isDone8 = isDone6;
var isFailure10 = isFailure6;
var isSuccess8 = isSuccess4;
var make123 = make63;
var map40 = map27;
var match35 = match28;
var matchEffect5 = matchEffect4;
var of7 = of6;
var tap10 = tap5;

// ../node_modules/effect/dist/esm/TestAnnotation.js
var TestAnnotation_exports = {};
__export(TestAnnotation_exports, {
  TestAnnotationTypeId: () => TestAnnotationTypeId,
  compose: () => compose3,
  fibers: () => fibers,
  ignored: () => ignored,
  isTestAnnotation: () => isTestAnnotation,
  make: () => make124,
  repeated: () => repeated3,
  retried: () => retried,
  tagged: () => tagged8
});
var TestAnnotationSymbolKey = "effect/TestAnnotation";
var TestAnnotationTypeId = Symbol.for(TestAnnotationSymbolKey);
var _a85;
var TestAnnotationImpl = class {
  constructor(identifier, initial, combine18) {
    __publicField(this, "identifier");
    __publicField(this, "initial");
    __publicField(this, "combine");
    __publicField(this, _a85, {
      _A: (_) => _
    });
    this.identifier = identifier;
    this.initial = initial;
    this.combine = combine18;
  }
  [(_a85 = TestAnnotationTypeId, symbol2)]() {
    return pipe(hash(TestAnnotationSymbolKey), combine(hash(this.identifier)), cached(this));
  }
  [symbol3](that) {
    return isTestAnnotation(that) && this.identifier === that.identifier;
  }
};
var isTestAnnotation = (u) => hasProperty(u, TestAnnotationTypeId);
var make124 = (identifier, initial, combine18) => {
  return new TestAnnotationImpl(identifier, initial, combine18);
};
var compose3 = (left2, right2) => {
  if (isLeft(left2) && isLeft(right2)) {
    return left(left2.left + right2.left);
  }
  if (isRight(left2) && isRight(right2)) {
    return right(pipe(left2.right, appendAll2(right2.right)));
  }
  if (isRight(left2) && isLeft(right2)) {
    return right2;
  }
  if (isLeft(left2) && isRight(right2)) {
    return right2;
  }
  throw new Error(getBugErrorMessage("TestAnnotation.compose"));
};
var fibers = make124("fibers", left(0), compose3);
var ignored = make124("ignored", 0, (a, b) => a + b);
var repeated3 = make124("repeated", 0, (a, b) => a + b);
var retried = make124("retried", 0, (a, b) => a + b);
var tagged8 = make124("tagged", empty8(), (a, b) => pipe(a, union5(b)));

// ../node_modules/effect/dist/esm/TestAnnotationMap.js
var TestAnnotationMap_exports = {};
__export(TestAnnotationMap_exports, {
  TestAnnotationMapTypeId: () => TestAnnotationMapTypeId,
  annotate: () => annotate,
  combine: () => combine17,
  empty: () => empty54,
  get: () => get36,
  isTestAnnotationMap: () => isTestAnnotationMap,
  make: () => make125,
  overwrite: () => overwrite,
  update: () => update15
});
var TestAnnotationMapTypeId = Symbol.for("effect/TestAnnotationMap");
var _a86;
var TestAnnotationMapImpl = class {
  constructor(map43) {
    __publicField(this, "map");
    __publicField(this, _a86, TestAnnotationMapTypeId);
    this.map = map43;
  }
};
_a86 = TestAnnotationMapTypeId;
var isTestAnnotationMap = (u) => hasProperty(u, TestAnnotationMapTypeId);
var empty54 = () => new TestAnnotationMapImpl(empty9());
var make125 = (map43) => {
  return new TestAnnotationMapImpl(map43);
};
var overwrite = dual(3, (self, key, value8) => make125(set3(self.map, key, value8)));
var update15 = dual(3, (self, key, f) => {
  let value8 = key.initial;
  if (has4(self.map, key.identifier)) {
    value8 = unsafeGet6(self.map, key.identifier);
  }
  return overwrite(self, key, f(value8));
});
var get36 = dual(2, (self, key) => {
  if (has4(self.map, key.identifier)) {
    return unsafeGet6(self.map, key.identifier);
  }
  return key.initial;
});
var annotate = dual(3, (self, key, value8) => update15(self, key, (_) => key.combine(_, value8)));
var combine17 = dual(2, (self, that) => {
  let result = self.map;
  for (const entry of that.map) {
    if (has4(result, entry[0])) {
      const value8 = get6(result, entry[0]);
      result = set3(result, entry[0], entry[0].combine(value8, entry[1]));
    } else {
      result = set3(result, entry[0], entry[1]);
    }
  }
  return make125(result);
});

// ../node_modules/effect/dist/esm/TestAnnotations.js
var TestAnnotations_exports = {};
__export(TestAnnotations_exports, {
  TestAnnotations: () => TestAnnotations,
  TestAnnotationsTypeId: () => TestAnnotationsTypeId,
  isTestAnnotations: () => isTestAnnotations,
  make: () => make126
});
var TestAnnotationsTypeId = Symbol.for("effect/TestAnnotations");
var _a87;
var AnnotationsImpl = class {
  constructor(ref) {
    __publicField(this, "ref");
    __publicField(this, _a87, TestAnnotationsTypeId);
    this.ref = ref;
  }
  get(key) {
    return map11(get11(this.ref), get36(key));
  }
  annotate(key, value8) {
    return update4(this.ref, annotate(key, value8));
  }
  get supervisedFibers() {
    return descriptorWith((descriptor3) => flatMap10(this.get(fibers), (either13) => {
      switch (either13._tag) {
        case "Left": {
          return succeed(empty30(Order7));
        }
        case "Right": {
          return pipe(either13.right, forEachSequential((ref) => sync(() => get5(ref))), map11(reduce(empty30(Order7), (a, b) => union7(a, b))), map11(filter9((fiber) => !equals(fiber.id(), descriptor3.id))));
        }
      }
    }));
  }
};
_a87 = TestAnnotationsTypeId;
var TestAnnotations = GenericTag("effect/Annotations");
var isTestAnnotations = (u) => hasProperty(u, TestAnnotationsTypeId);
var make126 = (ref) => new AnnotationsImpl(ref);

// ../node_modules/effect/dist/esm/TestClock.js
var TestClock_exports = {};
__export(TestClock_exports, {
  TestClock: () => TestClock,
  TestClockImpl: () => TestClockImpl,
  adjust: () => adjust,
  adjustWith: () => adjustWith,
  currentTimeMillis: () => currentTimeMillis3,
  defaultTestClock: () => defaultTestClock,
  live: () => live3,
  makeData: () => makeData,
  save: () => save,
  setTime: () => setTime,
  sleep: () => sleep5,
  sleeps: () => sleeps,
  testClock: () => testClock,
  testClockWith: () => testClockWith
});

// ../node_modules/effect/dist/esm/internal/testing/suspendedWarningData.js
var OP_SUSPENDED_WARNING_DATA_START = "Start";
var OP_SUSPENDED_WARNING_DATA_PENDING = "Pending";
var OP_SUSPENDED_WARNING_DATA_DONE = "Done";
var start3 = {
  _tag: OP_SUSPENDED_WARNING_DATA_START
};
var pending4 = (fiber) => {
  return {
    _tag: OP_SUSPENDED_WARNING_DATA_PENDING,
    fiber
  };
};
var done15 = {
  _tag: OP_SUSPENDED_WARNING_DATA_DONE
};
var isStart = (self) => {
  return self._tag === OP_SUSPENDED_WARNING_DATA_START;
};
var isPending2 = (self) => {
  return self._tag === OP_SUSPENDED_WARNING_DATA_PENDING;
};

// ../node_modules/effect/dist/esm/internal/testing/warningData.js
var OP_WARNING_DATA_START = "Start";
var OP_WARNING_DATA_PENDING = "Pending";
var OP_WARNING_DATA_DONE = "Done";
var start4 = {
  _tag: OP_WARNING_DATA_START
};
var pending5 = (fiber) => {
  return {
    _tag: OP_WARNING_DATA_PENDING,
    fiber
  };
};
var done16 = {
  _tag: OP_WARNING_DATA_DONE
};
var isStart2 = (self) => {
  return self._tag === OP_WARNING_DATA_START;
};
var isPending3 = (self) => {
  return self._tag === OP_WARNING_DATA_PENDING;
};

// ../node_modules/effect/dist/esm/TestLive.js
var TestLive_exports = {};
__export(TestLive_exports, {
  TestLive: () => TestLive,
  TestLiveTypeId: () => TestLiveTypeId,
  make: () => make127
});
var TestLiveTypeId = Symbol.for("effect/TestLive");
var TestLive = GenericTag("effect/TestLive");
var _a88;
var LiveImpl = class {
  constructor(services) {
    __publicField(this, "services");
    __publicField(this, _a88, TestLiveTypeId);
    this.services = services;
  }
  provide(effect4) {
    return fiberRefLocallyWith(currentServices, merge3(this.services))(effect4);
  }
};
_a88 = TestLiveTypeId;
var make127 = (services) => new LiveImpl(services);

// ../node_modules/effect/dist/esm/TestClock.js
var makeData = (instant, sleeps2) => ({
  instant,
  sleeps: sleeps2
});
var TestClock = GenericTag("effect/TestClock");
var warning = "Warning: A test is using time, but is not advancing the test clock, which may result in the test hanging. Use TestClock.adjust to manually advance the time.";
var suspendedWarning = "Warning: A test is advancing the test clock, but a fiber is not suspending, which may result in the test hanging. Use TestAspect.diagnose to identity the fiber that is not suspending.";
var _a89;
var TestClockImpl = class {
  constructor(clockState, live6, annotations2, warningState, suspendedWarningState) {
    __publicField(this, "clockState");
    __publicField(this, "live");
    __publicField(this, "annotations");
    __publicField(this, "warningState");
    __publicField(this, "suspendedWarningState");
    __publicField(this, _a89, ClockTypeId);
    /**
     * Returns the current clock time in milliseconds.
     */
    __publicField(this, "currentTimeMillis");
    /**
     * Returns the current clock time in nanoseconds.
     */
    __publicField(this, "currentTimeNanos");
    this.clockState = clockState;
    this.live = live6;
    this.annotations = annotations2;
    this.warningState = warningState;
    this.suspendedWarningState = suspendedWarningState;
    this.currentTimeMillis = map11(get10(this.clockState), (data) => data.instant);
    this.currentTimeNanos = map11(get10(this.clockState), (data) => BigInt(data.instant * 1e6));
  }
  /**
   * Unsafely returns the current time in milliseconds.
   */
  unsafeCurrentTimeMillis() {
    return unsafeGet7(this.clockState).instant;
  }
  /**
   * Unsafely returns the current time in nanoseconds.
   */
  unsafeCurrentTimeNanos() {
    return BigInt(unsafeGet7(this.clockState).instant * 1e6);
  }
  /**
   * Saves the `TestClock`'s current state in an effect which, when run, will
   * restore the `TestClock` state to the saved state.
   */
  get save() {
    return map11(get10(this.clockState), (data) => set5(this.clockState, data));
  }
  /**
   * Sets the current clock time to the specified instant. Any effects that
   * were scheduled to occur on or before the new time will be run in order.
   */
  setTime(instant) {
    return zipRight(this.warningDone(), this.run(() => instant));
  }
  /**
   * Semantically blocks the current fiber until the clock time is equal to or
   * greater than the specified duration. Once the clock time is adjusted to
   * on or after the duration, the fiber will automatically be resumed.
   */
  sleep(durationInput) {
    const duration5 = decode(durationInput);
    return flatMap10(deferredMake(), (deferred) => pipe(modify5(this.clockState, (data) => {
      const end7 = data.instant + toMillis(duration5);
      if (end7 > data.instant) {
        return [true, makeData(data.instant, pipe(data.sleeps, prepend2([end7, deferred])))];
      }
      return [false, data];
    }), flatMap10((shouldAwait) => shouldAwait ? pipe(this.warningStart(), zipRight(deferredAwait(deferred))) : pipe(deferredSucceed(deferred, void 0), asVoid))));
  }
  /**
   * Returns a list of the times at which all queued effects are scheduled to
   * resume.
   */
  get sleeps() {
    return map11(get10(this.clockState), (data) => map4(data.sleeps, (_) => _[0]));
  }
  /**
   * Increments the current clock time by the specified duration. Any effects
   * that were scheduled to occur on or before the new time will be run in
   * order.
   */
  adjust(durationInput) {
    const duration5 = decode(durationInput);
    return zipRight(this.warningDone(), this.run((n) => n + toMillis(duration5)));
  }
  /**
   * Increments the current clock time by the specified duration. Any effects
   * that were scheduled to occur on or before the new time will be run in
   * order.
   */
  adjustWith(durationInput) {
    const duration5 = decode(durationInput);
    return (effect4) => zipLeftOptions(effect4, this.adjust(duration5), {
      concurrent: true
    });
  }
  /**
   * Returns a set of all fibers in this test.
   */
  supervisedFibers() {
    return this.annotations.supervisedFibers;
  }
  /**
   * Captures a "snapshot" of the identifier and status of all fibers in this
   * test other than the current fiber. Fails with the `void` value if any of
   * these fibers are not done or suspended. Note that because we cannot
   * synchronize on the status of multiple fibers at the same time this
   * snapshot may not be fully consistent.
   */
  freeze() {
    return flatMap10(this.supervisedFibers(), (fibers2) => pipe(fibers2, reduce10(empty9(), (map43, fiber) => pipe(fiber.status, flatMap10((status3) => {
      if (isDone3(status3)) {
        return succeed(set3(map43, fiber.id(), status3));
      }
      if (isSuspended2(status3)) {
        return succeed(set3(map43, fiber.id(), status3));
      }
      return fail2(void 0);
    })))));
  }
  /**
   * Forks a fiber that will display a warning message if a test is using time
   * but is not advancing the `TestClock`.
   */
  warningStart() {
    return updateSomeEffect(this.warningState, (data) => isStart2(data) ? some2(pipe(this.live.provide(pipe(logWarning(warning), delay(seconds(5)))), interruptible2, fork, map11((fiber) => pending5(fiber)))) : none2());
  }
  /**
   * Cancels the warning message that is displayed if a test is using time but
   * is not advancing the `TestClock`.
   */
  warningDone() {
    return updateSomeEffect(this.warningState, (warningData) => {
      if (isStart2(warningData)) {
        return some2(succeed(done16));
      }
      if (isPending3(warningData)) {
        return some2(pipe(interruptFiber(warningData.fiber), as2(done16)));
      }
      return none2();
    });
  }
  /**
   * Returns whether all descendants of this fiber are done or suspended.
   */
  suspended() {
    return pipe(this.freeze(), zip4(this.live.provide(pipe(sleep3(millis(5)), zipRight(this.freeze())))), flatMap10(([first5, last8]) => equals(first5, last8) ? succeed(first5) : fail2(void 0)));
  }
  /**
   * Polls until all descendants of this fiber are done or suspended.
   */
  awaitSuspended() {
    return pipe(this.suspendedWarningStart(), zipRight(pipe(this.suspended(), zipWith3(pipe(this.live.provide(sleep3(millis(10))), zipRight(this.suspended())), equals), filterOrFail(identity, constVoid), eventually)), zipRight(this.suspendedWarningDone()));
  }
  /**
   * Forks a fiber that will display a warning message if a test is advancing
   * the `TestClock` but a fiber is not suspending.
   */
  suspendedWarningStart() {
    return updateSomeEffect(this.suspendedWarningState, (suspendedWarningData) => {
      if (isStart(suspendedWarningData)) {
        return some2(pipe(this.live.provide(pipe(logWarning(suspendedWarning), zipRight(set5(this.suspendedWarningState, done15)), delay(seconds(5)))), interruptible2, fork, map11((fiber) => pending4(fiber))));
      }
      return none2();
    });
  }
  /**
   * Cancels the warning message that is displayed if a test is advancing the
   * `TestClock` but a fiber is not suspending.
   */
  suspendedWarningDone() {
    return updateSomeEffect(this.suspendedWarningState, (suspendedWarningData) => {
      if (isPending2(suspendedWarningData)) {
        return some2(pipe(interruptFiber(suspendedWarningData.fiber), as2(start3)));
      }
      return none2();
    });
  }
  /**
   * Runs all effects scheduled to occur on or before the specified instant,
   * which may depend on the current time, in order.
   */
  run(f) {
    return pipe(this.awaitSuspended(), zipRight(pipe(modify5(this.clockState, (data) => {
      const end7 = f(data.instant);
      const sorted = pipe(data.sleeps, sort2(pipe(Order, mapInput2((_) => _[0]))));
      if (isNonEmpty2(sorted)) {
        const [instant, deferred] = headNonEmpty2(sorted);
        if (instant <= end7) {
          return [some2([end7, deferred]), makeData(instant, tailNonEmpty2(sorted))];
        }
      }
      return [none2(), makeData(end7, data.sleeps)];
    }), flatMap10((option9) => {
      switch (option9._tag) {
        case "None": {
          return void_;
        }
        case "Some": {
          const [end7, deferred] = option9.value;
          return pipe(deferredSucceed(deferred, void 0), zipRight(yieldNow()), zipRight(this.run(() => end7)));
        }
      }
    }))));
  }
};
_a89 = ClockTypeId;
var live3 = (data) => scoped2(TestClock, gen(function* ($) {
  const live6 = yield* $(TestLive);
  const annotations2 = yield* $(TestAnnotations);
  const clockState = yield* $(sync(() => unsafeMake7(data)));
  const warningState = yield* $(makeSynchronized(start4));
  const suspendedWarningState = yield* $(makeSynchronized(start3));
  const testClock2 = new TestClockImpl(clockState, live6, annotations2, warningState, suspendedWarningState);
  yield* $(withClockScoped(testClock2));
  yield* $(addFinalizer(() => zipRight(testClock2.warningDone(), testClock2.suspendedWarningDone())));
  return testClock2;
}));
var defaultTestClock = live3(makeData((/* @__PURE__ */ new Date(0)).getTime(), empty5()));
var adjust = (durationInput) => {
  const duration5 = decode(durationInput);
  return testClockWith((testClock2) => testClock2.adjust(duration5));
};
var adjustWith = dual(2, (effect4, durationInput) => {
  const duration5 = decode(durationInput);
  return testClockWith((testClock2) => testClock2.adjustWith(duration5)(effect4));
});
var save = () => testClockWith((testClock2) => testClock2.save);
var setTime = (instant) => testClockWith((testClock2) => testClock2.setTime(instant));
var sleep5 = (durationInput) => {
  const duration5 = decode(durationInput);
  return testClockWith((testClock2) => testClock2.sleep(duration5));
};
var sleeps = () => testClockWith((testClock2) => testClock2.sleeps);
var testClock = () => testClockWith(succeed);
var testClockWith = (f) => fiberRefGetWith(currentServices, (services) => f(pipe(services, get2(clockTag))));
var currentTimeMillis3 = testClockWith((testClock2) => testClock2.currentTimeMillis);

// ../node_modules/effect/dist/esm/TestConfig.js
var TestConfig_exports = {};
__export(TestConfig_exports, {
  TestConfig: () => TestConfig,
  make: () => make128
});
var TestConfig = GenericTag("effect/TestConfig");
var make128 = (params) => params;

// ../node_modules/effect/dist/esm/TestContext.js
var TestContext_exports = {};
__export(TestContext_exports, {
  LiveContext: () => LiveContext,
  TestContext: () => TestContext,
  live: () => live5
});

// ../node_modules/effect/dist/esm/TestServices.js
var TestServices_exports = {};
__export(TestServices_exports, {
  annotate: () => annotate2,
  annotations: () => annotations,
  annotationsLayer: () => annotationsLayer,
  annotationsWith: () => annotationsWith,
  currentServices: () => currentServices3,
  get: () => get37,
  live: () => live4,
  liveLayer: () => liveLayer,
  liveServices: () => liveServices3,
  liveWith: () => liveWith,
  provideLive: () => provideLive,
  provideWithLive: () => provideWithLive,
  repeats: () => repeats,
  retries: () => retries,
  samples: () => samples,
  shrinks: () => shrinks,
  size: () => size35,
  sized: () => sized,
  sizedLayer: () => sizedLayer,
  sizedWith: () => sizedWith,
  supervisedFibers: () => supervisedFibers,
  testConfig: () => testConfig,
  testConfigLayer: () => testConfigLayer,
  testConfigWith: () => testConfigWith,
  withAnnotations: () => withAnnotations,
  withAnnotationsScoped: () => withAnnotationsScoped,
  withLive: () => withLive,
  withLiveScoped: () => withLiveScoped,
  withSize: () => withSize,
  withSized: () => withSized,
  withSizedScoped: () => withSizedScoped,
  withTestConfig: () => withTestConfig,
  withTestConfigScoped: () => withTestConfigScoped
});

// ../node_modules/effect/dist/esm/TestSized.js
var TestSized_exports = {};
__export(TestSized_exports, {
  TestSized: () => TestSized,
  TestSizedTypeId: () => TestSizedTypeId,
  fromFiberRef: () => fromFiberRef,
  make: () => make129
});
var TestSizedTypeId = Symbol.for("effect/TestSized");
var TestSized = GenericTag("effect/TestSized");
var _a90;
var SizedImpl = class {
  constructor(fiberRef) {
    __publicField(this, "fiberRef");
    __publicField(this, _a90, TestSizedTypeId);
    this.fiberRef = fiberRef;
  }
  get size() {
    return fiberRefGet(this.fiberRef);
  }
  withSize(size38) {
    return (effect4) => fiberRefLocally(this.fiberRef, size38)(effect4);
  }
};
_a90 = TestSizedTypeId;
var make129 = (size38) => new SizedImpl(fiberRefUnsafeMake(size38));
var fromFiberRef = (fiberRef) => new SizedImpl(fiberRef);

// ../node_modules/effect/dist/esm/TestServices.js
var liveServices3 = pipe(make7(TestAnnotations, make126(unsafeMake7(empty54()))), add2(TestLive, make127(liveServices)), add2(TestSized, make129(100)), add2(TestConfig, make128({
  repeats: 100,
  retries: 100,
  samples: 200,
  shrinks: 1e3
})));
var currentServices3 = fiberRefUnsafeMakeContext(liveServices3);
var annotations = () => annotationsWith(succeed);
var annotationsWith = (f) => fiberRefGetWith(currentServices3, (services) => f(get2(services, TestAnnotations)));
var withAnnotations = dual(2, (effect4, annotations2) => fiberRefLocallyWith(currentServices3, add2(TestAnnotations, annotations2))(effect4));
var withAnnotationsScoped = (annotations2) => fiberRefLocallyScopedWith(currentServices3, add2(TestAnnotations, annotations2));
var annotationsLayer = () => scoped2(TestAnnotations, pipe(sync(() => unsafeMake7(empty54())), map11(make126), tap(withAnnotationsScoped)));
var get37 = (key) => annotationsWith((annotations2) => annotations2.get(key));
var annotate2 = (key, value8) => annotationsWith((annotations2) => annotations2.annotate(key, value8));
var supervisedFibers = () => annotationsWith((annotations2) => annotations2.supervisedFibers);
var liveWith = (f) => fiberRefGetWith(currentServices3, (services) => f(get2(services, TestLive)));
var live4 = liveWith(succeed);
var withLive = dual(2, (effect4, live6) => fiberRefLocallyWith(currentServices3, add2(TestLive, live6))(effect4));
var withLiveScoped = (live6) => fiberRefLocallyScopedWith(currentServices3, add2(TestLive, live6));
var liveLayer = () => scoped2(TestLive, pipe(context(), map11(make127), tap(withLiveScoped)));
var provideLive = (effect4) => liveWith((live6) => live6.provide(effect4));
var provideWithLive = dual(2, (self, f) => fiberRefGetWith(currentServices, (services) => provideLive(f(fiberRefLocally(currentServices, services)(self)))));
var sizedWith = (f) => fiberRefGetWith(currentServices3, (services) => f(get2(services, TestSized)));
var sized = sizedWith(succeed);
var withSized = dual(2, (effect4, sized2) => fiberRefLocallyWith(currentServices3, add2(TestSized, sized2))(effect4));
var withSizedScoped = (sized2) => fiberRefLocallyScopedWith(currentServices3, add2(TestSized, sized2));
var sizedLayer = (size38) => scoped2(TestSized, pipe(fiberRefMake(size38), map11(fromFiberRef), tap(withSizedScoped)));
var size35 = sizedWith((sized2) => sized2.size);
var withSize = dual(2, (effect4, size38) => sizedWith((sized2) => sized2.withSize(size38)(effect4)));
var testConfigWith = (f) => fiberRefGetWith(currentServices3, (services) => f(get2(services, TestConfig)));
var testConfig = testConfigWith(succeed);
var withTestConfig = dual(2, (effect4, config2) => fiberRefLocallyWith(currentServices3, add2(TestConfig, config2))(effect4));
var withTestConfigScoped = (config2) => fiberRefLocallyScopedWith(currentServices3, add2(TestConfig, config2));
var testConfigLayer = (params) => scoped2(TestConfig, suspend3(() => {
  const testConfig2 = make128(params);
  return pipe(withTestConfigScoped(testConfig2), as2(testConfig2));
}));
var repeats = testConfigWith((config2) => succeed(config2.repeats));
var retries = testConfigWith((config2) => succeed(config2.retries));
var samples = testConfigWith((config2) => succeed(config2.samples));
var shrinks = testConfigWith((config2) => succeed(config2.shrinks));

// ../node_modules/effect/dist/esm/TestContext.js
var live5 = pipe(annotationsLayer(), merge6(liveLayer()), merge6(sizedLayer(100)), merge6(pipe(defaultTestClock, provideMerge(merge6(liveLayer(), annotationsLayer())))), merge6(testConfigLayer({
  repeats: 100,
  retries: 100,
  samples: 200,
  shrinks: 1e3
})));
var LiveContext = syncContext(() => liveServices);
var TestContext = provideMerge(live5, LiveContext);

// ../node_modules/effect/dist/esm/Trie.js
var Trie_exports = {};
__export(Trie_exports, {
  compact: () => compact6,
  empty: () => empty56,
  entries: () => entries5,
  entriesWithPrefix: () => entriesWithPrefix2,
  filter: () => filter20,
  filterMap: () => filterMap11,
  forEach: () => forEach25,
  fromIterable: () => fromIterable32,
  get: () => get39,
  has: () => has17,
  insert: () => insert4,
  insertMany: () => insertMany2,
  isEmpty: () => isEmpty28,
  keys: () => keys9,
  keysWithPrefix: () => keysWithPrefix2,
  longestPrefixOf: () => longestPrefixOf2,
  make: () => make131,
  map: () => map42,
  modify: () => modify15,
  reduce: () => reduce28,
  remove: () => remove19,
  removeMany: () => removeMany4,
  size: () => size37,
  toEntries: () => toEntries2,
  toEntriesWithPrefix: () => toEntriesWithPrefix2,
  unsafeGet: () => unsafeGet13,
  values: () => values12,
  valuesWithPrefix: () => valuesWithPrefix2
});

// ../node_modules/effect/dist/esm/internal/trie.js
var TrieSymbolKey = "effect/Trie";
var TrieTypeId = Symbol.for(TrieSymbolKey);
var trieVariance = {
  /* c8 ignore next */
  _Value: (_) => _
};
var TrieProto = {
  [TrieTypeId]: trieVariance,
  [Symbol.iterator]() {
    return new TrieIterator(this, (k, v) => [k, v], () => true);
  },
  [symbol2]() {
    let hash3 = hash(TrieSymbolKey);
    for (const item of this) {
      hash3 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash3);
  },
  [symbol3](that) {
    if (isTrie(that)) {
      const entries6 = Array.from(that);
      return Array.from(this).every((itemSelf, i) => {
        const itemThat = entries6[i];
        return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Trie",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl6 = (root) => {
  const trie = Object.create(TrieProto);
  trie._root = root;
  trie._count = (root == null ? void 0 : root.count) ?? 0;
  return trie;
};
var TrieIterator = class _TrieIterator {
  constructor(trie, f, filter21) {
    __publicField(this, "trie");
    __publicField(this, "f");
    __publicField(this, "filter");
    __publicField(this, "stack", []);
    this.trie = trie;
    this.f = f;
    this.filter = filter21;
    const root = trie._root !== void 0 ? trie._root : void 0;
    if (root !== void 0) {
      this.stack.push([root, "", false]);
    }
  }
  next() {
    while (this.stack.length > 0) {
      const [node, keyString, isAdded] = this.stack.pop();
      if (isAdded) {
        const value8 = node.value;
        if (value8 !== void 0) {
          const key = keyString + node.key;
          if (this.filter(key, value8)) {
            return {
              done: false,
              value: this.f(key, value8)
            };
          }
        }
      } else {
        this.addToStack(node, keyString);
      }
    }
    return {
      done: true,
      value: void 0
    };
  }
  addToStack(node, keyString) {
    if (node.right !== void 0) {
      this.stack.push([node.right, keyString, false]);
    }
    if (node.mid !== void 0) {
      this.stack.push([node.mid, keyString + node.key, false]);
    }
    this.stack.push([node, keyString, true]);
    if (node.left !== void 0) {
      this.stack.push([node.left, keyString, false]);
    }
  }
  [Symbol.iterator]() {
    return new _TrieIterator(this.trie, this.f, this.filter);
  }
};
var isTrie = (u) => hasProperty(u, TrieTypeId);
var empty55 = () => makeImpl6(void 0);
var fromIterable31 = (entries6) => {
  let trie = empty55();
  for (const [key, value8] of entries6) {
    trie = insert3(trie, key, value8);
  }
  return trie;
};
var make130 = (...entries6) => {
  return fromIterable31(entries6);
};
var insert3 = dual(3, (self, key, value8) => {
  if (key.length === 0)
    return self;
  const dStack = [];
  const nStack = [];
  let n = self._root ?? {
    key: key[0],
    count: 0
  };
  const count9 = n.count + 1;
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    nStack.push(n);
    if (c > n.key) {
      dStack.push(1);
      if (n.right === void 0) {
        n = {
          key: c,
          count: count9
        };
      } else {
        n = n.right;
      }
    } else if (c < n.key) {
      dStack.push(-1);
      if (n.left === void 0) {
        n = {
          key: c,
          count: count9
        };
      } else {
        n = n.left;
      }
    } else {
      if (cIndex === key.length - 1) {
        n.value = value8;
      } else if (n.mid === void 0) {
        dStack.push(0);
        n = {
          key: key[cIndex + 1],
          count: count9
        };
      } else {
        dStack.push(0);
        n = n.mid;
      }
      cIndex += 1;
    }
  }
  for (let s = nStack.length - 2; s >= 0; --s) {
    const n2 = nStack[s];
    const d = dStack[s];
    if (d === -1) {
      nStack[s] = {
        key: n2.key,
        count: count9,
        value: n2.value,
        left: nStack[s + 1],
        mid: n2.mid,
        right: n2.right
      };
    } else if (d === 1) {
      nStack[s] = {
        key: n2.key,
        count: count9,
        value: n2.value,
        left: n2.left,
        mid: n2.mid,
        right: nStack[s + 1]
      };
    } else {
      nStack[s] = {
        key: n2.key,
        count: count9,
        value: n2.value,
        left: n2.left,
        mid: nStack[s + 1],
        right: n2.right
      };
    }
  }
  nStack[0].count = count9;
  return makeImpl6(nStack[0]);
});
var size36 = (self) => {
  var _a91;
  return ((_a91 = self._root) == null ? void 0 : _a91.count) ?? 0;
};
var isEmpty27 = (self) => size36(self) === 0;
var keys8 = (self) => new TrieIterator(self, (key) => key, () => true);
var values11 = (self) => new TrieIterator(self, (_, value8) => value8, () => true);
var entries4 = (self) => new TrieIterator(self, (key, value8) => [key, value8], () => true);
var reduce27 = dual(3, (self, zero3, f) => {
  let accumulator = zero3;
  for (const entry of self) {
    accumulator = f(accumulator, entry[1], entry[0]);
  }
  return accumulator;
});
var map41 = dual(2, (self, f) => reduce27(self, empty55(), (trie, value8, key) => insert3(trie, key, f(value8, key))));
var filter19 = dual(2, (self, f) => reduce27(self, empty55(), (trie, value8, key) => f(value8, key) ? insert3(trie, key, value8) : trie));
var filterMap10 = dual(2, (self, f) => reduce27(self, empty55(), (trie, value8, key) => {
  const option9 = f(value8, key);
  return isSome(option9) ? insert3(trie, key, option9.value) : trie;
}));
var compact5 = (self) => filterMap10(self, identity);
var forEach24 = dual(2, (self, f) => reduce27(self, void 0, (_, value8, key) => f(value8, key)));
var keysWithPrefix = dual(2, (self, prefix) => new TrieIterator(self, (key) => key, (key) => key.startsWith(prefix)));
var valuesWithPrefix = dual(2, (self, prefix) => new TrieIterator(self, (_, value8) => value8, (key) => key.startsWith(prefix)));
var entriesWithPrefix = dual(2, (self, prefix) => new TrieIterator(self, (key, value8) => [key, value8], (key) => key.startsWith(prefix)));
var toEntriesWithPrefix = dual(2, (self, prefix) => Array.from(entriesWithPrefix(self, prefix)));
var get38 = dual(2, (self, key) => {
  let n = self._root;
  if (n === void 0 || key.length === 0)
    return none2();
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    if (c > n.key) {
      if (n.right === void 0) {
        return none2();
      } else {
        n = n.right;
      }
    } else if (c < n.key) {
      if (n.left === void 0) {
        return none2();
      } else {
        n = n.left;
      }
    } else {
      if (cIndex === key.length - 1) {
        return fromNullable(n.value);
      } else {
        if (n.mid === void 0) {
          return none2();
        } else {
          n = n.mid;
          cIndex += 1;
        }
      }
    }
  }
  return none2();
});
var has16 = dual(2, (self, key) => isSome(get38(self, key)));
var unsafeGet12 = dual(2, (self, key) => {
  const element = get38(self, key);
  if (isNone(element)) {
    throw new Error("Expected trie to contain key");
  }
  return element.value;
});
var remove18 = dual(2, (self, key) => {
  let n = self._root;
  if (n === void 0 || key.length === 0)
    return self;
  const count9 = n.count - 1;
  const dStack = [];
  const nStack = [];
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    if (c > n.key) {
      if (n.right === void 0) {
        return self;
      } else {
        nStack.push(n);
        dStack.push(1);
        n = n.right;
      }
    } else if (c < n.key) {
      if (n.left === void 0) {
        return self;
      } else {
        nStack.push(n);
        dStack.push(-1);
        n = n.left;
      }
    } else {
      if (cIndex === key.length - 1) {
        if (n.value !== void 0) {
          nStack.push(n);
          dStack.push(0);
          cIndex += 1;
        } else {
          return self;
        }
      } else {
        if (n.mid === void 0) {
          return self;
        } else {
          nStack.push(n);
          dStack.push(0);
          n = n.mid;
          cIndex += 1;
        }
      }
    }
  }
  const removeNode = nStack[nStack.length - 1];
  nStack[nStack.length - 1] = {
    key: removeNode.key,
    count: count9,
    left: removeNode.left,
    mid: removeNode.mid,
    right: removeNode.right
  };
  for (let s = nStack.length - 2; s >= 0; --s) {
    const n2 = nStack[s];
    const d = dStack[s];
    const child = nStack[s + 1];
    const nc = child.left === void 0 && child.mid === void 0 && child.right === void 0 ? void 0 : child;
    if (d === -1) {
      nStack[s] = {
        key: n2.key,
        count: count9,
        value: n2.value,
        left: nc,
        mid: n2.mid,
        right: n2.right
      };
    } else if (d === 1) {
      nStack[s] = {
        key: n2.key,
        count: count9,
        value: n2.value,
        left: n2.left,
        mid: n2.mid,
        right: nc
      };
    } else {
      nStack[s] = {
        key: n2.key,
        count: count9,
        value: n2.value,
        left: n2.left,
        mid: nc,
        right: n2.right
      };
    }
  }
  nStack[0].count = count9;
  return makeImpl6(nStack[0]);
});
var removeMany3 = dual(2, (self, keys10) => {
  let trie = self;
  for (const key of keys10) {
    trie = remove18(key)(trie);
  }
  return trie;
});
var insertMany = dual(2, (self, iter) => {
  let trie = self;
  for (const [key, value8] of iter) {
    trie = insert3(key, value8)(trie);
  }
  return trie;
});
var modify14 = dual(3, (self, key, f) => {
  let n = self._root;
  if (n === void 0 || key.length === 0)
    return self;
  const dStack = [];
  const nStack = [];
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    if (c > n.key) {
      if (n.right === void 0) {
        return self;
      } else {
        nStack.push(n);
        dStack.push(1);
        n = n.right;
      }
    } else if (c < n.key) {
      if (n.left === void 0) {
        return self;
      } else {
        nStack.push(n);
        dStack.push(-1);
        n = n.left;
      }
    } else {
      if (cIndex === key.length - 1) {
        if (n.value !== void 0) {
          nStack.push(n);
          dStack.push(0);
          cIndex += 1;
        } else {
          return self;
        }
      } else {
        if (n.mid === void 0) {
          return self;
        } else {
          nStack.push(n);
          dStack.push(0);
          n = n.mid;
          cIndex += 1;
        }
      }
    }
  }
  const updateNode = nStack[nStack.length - 1];
  if (updateNode.value === void 0) {
    return self;
  }
  nStack[nStack.length - 1] = {
    key: updateNode.key,
    count: updateNode.count,
    value: f(updateNode.value),
    // Update
    left: updateNode.left,
    mid: updateNode.mid,
    right: updateNode.right
  };
  for (let s = nStack.length - 2; s >= 0; --s) {
    const n2 = nStack[s];
    const d = dStack[s];
    const child = nStack[s + 1];
    if (d === -1) {
      nStack[s] = {
        key: n2.key,
        count: n2.count,
        value: n2.value,
        left: child,
        mid: n2.mid,
        right: n2.right
      };
    } else if (d === 1) {
      nStack[s] = {
        key: n2.key,
        count: n2.count,
        value: n2.value,
        left: n2.left,
        mid: n2.mid,
        right: child
      };
    } else {
      nStack[s] = {
        key: n2.key,
        count: n2.count,
        value: n2.value,
        left: n2.left,
        mid: child,
        right: n2.right
      };
    }
  }
  return makeImpl6(nStack[0]);
});
var longestPrefixOf = dual(2, (self, key) => {
  let n = self._root;
  if (n === void 0 || key.length === 0)
    return none2();
  let longestPrefixNode = void 0;
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    if (n.value !== void 0) {
      longestPrefixNode = [key.slice(0, cIndex + 1), n.value];
    }
    if (c > n.key) {
      if (n.right === void 0) {
        break;
      } else {
        n = n.right;
      }
    } else if (c < n.key) {
      if (n.left === void 0) {
        break;
      } else {
        n = n.left;
      }
    } else {
      if (n.mid === void 0) {
        break;
      } else {
        n = n.mid;
        cIndex += 1;
      }
    }
  }
  return fromNullable(longestPrefixNode);
});

// ../node_modules/effect/dist/esm/Trie.js
var empty56 = empty55;
var fromIterable32 = fromIterable31;
var make131 = make130;
var insert4 = insert3;
var keys9 = keys8;
var values12 = values11;
var entries5 = entries4;
var toEntries2 = (self) => Array.from(entries5(self));
var keysWithPrefix2 = keysWithPrefix;
var valuesWithPrefix2 = valuesWithPrefix;
var entriesWithPrefix2 = entriesWithPrefix;
var toEntriesWithPrefix2 = toEntriesWithPrefix;
var longestPrefixOf2 = longestPrefixOf;
var size37 = size36;
var get39 = get38;
var has17 = has16;
var isEmpty28 = isEmpty27;
var unsafeGet13 = unsafeGet12;
var remove19 = remove18;
var reduce28 = reduce27;
var map42 = map41;
var filter20 = filter19;
var filterMap11 = filterMap10;
var compact6 = compact5;
var forEach25 = forEach24;
var modify15 = modify14;
var removeMany4 = removeMany3;
var insertMany2 = insertMany;

// ../node_modules/effect/dist/esm/Types.js
var Types_exports = {};

// ../node_modules/effect/dist/esm/Unify.js
var Unify_exports = {};
__export(Unify_exports, {
  unify: () => unify
});
var unify = identity;

// ../node_modules/effect/dist/esm/UpstreamPullRequest.js
var UpstreamPullRequest_exports = {};
__export(UpstreamPullRequest_exports, {
  NoUpstream: () => NoUpstream2,
  Pulled: () => Pulled2,
  UpstreamPullRequestTypeId: () => UpstreamPullRequestTypeId2,
  isNoUpstream: () => isNoUpstream2,
  isPulled: () => isPulled2,
  isUpstreamPullRequest: () => isUpstreamPullRequest2,
  match: () => match36
});
var UpstreamPullRequestTypeId2 = UpstreamPullRequestTypeId;
var Pulled2 = Pulled;
var NoUpstream2 = NoUpstream;
var isUpstreamPullRequest2 = isUpstreamPullRequest;
var isPulled2 = isPulled;
var isNoUpstream2 = isNoUpstream;
var match36 = match21;

// ../node_modules/effect/dist/esm/UpstreamPullStrategy.js
var UpstreamPullStrategy_exports = {};
__export(UpstreamPullStrategy_exports, {
  PullAfterAllEnqueued: () => PullAfterAllEnqueued2,
  PullAfterNext: () => PullAfterNext2,
  UpstreamPullStrategyTypeId: () => UpstreamPullStrategyTypeId2,
  isPullAfterAllEnqueued: () => isPullAfterAllEnqueued2,
  isPullAfterNext: () => isPullAfterNext2,
  isUpstreamPullStrategy: () => isUpstreamPullStrategy2,
  match: () => match37
});
var UpstreamPullStrategyTypeId2 = UpstreamPullStrategyTypeId;
var PullAfterNext2 = PullAfterNext;
var PullAfterAllEnqueued2 = PullAfterAllEnqueued;
var isUpstreamPullStrategy2 = isUpstreamPullStrategy;
var isPullAfterNext2 = isPullAfterNext;
var isPullAfterAllEnqueued2 = isPullAfterAllEnqueued;
var match37 = match20;
export {
  Array_exports as Array,
  BigDecimal_exports as BigDecimal,
  BigInt_exports as BigInt,
  Boolean_exports as Boolean,
  Brand_exports as Brand,
  Cache_exports as Cache,
  Cause_exports as Cause,
  Channel_exports as Channel,
  ChildExecutorDecision_exports as ChildExecutorDecision,
  Chunk_exports as Chunk,
  Clock_exports as Clock,
  Config_exports as Config,
  ConfigError_exports as ConfigError,
  ConfigProvider_exports as ConfigProvider,
  ConfigProviderPathPatch_exports as ConfigProviderPathPatch,
  Console_exports as Console,
  Context_exports as Context,
  Cron_exports as Cron,
  Data_exports as Data,
  DefaultServices_exports as DefaultServices,
  Deferred_exports as Deferred,
  Differ_exports as Differ,
  Duration_exports as Duration,
  Effect_exports as Effect,
  Effectable_exports as Effectable,
  Either_exports as Either,
  Encoding_exports as Encoding,
  Equal_exports as Equal,
  Equivalence_exports as Equivalence,
  ExecutionStrategy_exports as ExecutionStrategy,
  Exit_exports as Exit,
  Fiber_exports as Fiber,
  FiberHandle_exports as FiberHandle,
  FiberId_exports as FiberId,
  FiberMap_exports as FiberMap,
  FiberRef_exports as FiberRef,
  FiberRefs_exports as FiberRefs,
  FiberRefsPatch_exports as FiberRefsPatch,
  FiberSet_exports as FiberSet,
  FiberStatus_exports as FiberStatus,
  Function_exports as Function,
  GlobalValue_exports as GlobalValue,
  GroupBy_exports as GroupBy,
  HKT_exports as HKT,
  Hash_exports as Hash,
  HashMap_exports as HashMap,
  HashSet_exports as HashSet,
  Inspectable_exports as Inspectable,
  Iterable_exports as Iterable,
  KeyedPool_exports as KeyedPool,
  Layer_exports as Layer,
  List_exports as List,
  LogLevel_exports as LogLevel,
  LogSpan_exports as LogSpan,
  Logger_exports as Logger,
  ManagedRuntime_exports as ManagedRuntime,
  Match_exports as Match,
  MergeDecision_exports as MergeDecision,
  MergeState_exports as MergeState,
  MergeStrategy_exports as MergeStrategy,
  Metric_exports as Metric,
  MetricBoundaries_exports as MetricBoundaries,
  MetricHook_exports as MetricHook,
  MetricKey_exports as MetricKey,
  MetricKeyType_exports as MetricKeyType,
  MetricLabel_exports as MetricLabel,
  MetricPair_exports as MetricPair,
  MetricPolling_exports as MetricPolling,
  MetricRegistry_exports as MetricRegistry,
  MetricState_exports as MetricState,
  ModuleVersion_exports as ModuleVersion,
  MutableHashMap_exports as MutableHashMap,
  MutableHashSet_exports as MutableHashSet,
  MutableList_exports as MutableList,
  MutableQueue_exports as MutableQueue,
  MutableRef_exports as MutableRef,
  NonEmptyIterable_exports as NonEmptyIterable,
  Number_exports as Number,
  Option_exports as Option,
  Order_exports as Order,
  Ordering_exports as Ordering,
  Pipeable_exports as Pipeable,
  Pool_exports as Pool,
  Predicate_exports as Predicate,
  PrimaryKey_exports as PrimaryKey,
  PubSub_exports as PubSub,
  Queue_exports as Queue,
  Random_exports as Random,
  RateLimiter_exports as RateLimiter,
  Readable_exports as Readable,
  Record_exports as Record,
  RedBlackTree_exports as RedBlackTree,
  Ref_exports as Ref,
  RegExp_exports as RegExp,
  Reloadable_exports as Reloadable,
  Request_exports as Request,
  RequestBlock_exports as RequestBlock,
  RequestResolver_exports as RequestResolver,
  Resource_exports as Resource,
  Runtime_exports as Runtime,
  RuntimeFlags_exports as RuntimeFlags,
  RuntimeFlagsPatch_exports as RuntimeFlagsPatch,
  STM_exports as STM,
  Schedule_exports as Schedule,
  ScheduleDecision_exports as ScheduleDecision,
  ScheduleInterval_exports as ScheduleInterval,
  ScheduleIntervals_exports as ScheduleIntervals,
  Scheduler_exports as Scheduler,
  Scope_exports as Scope,
  ScopedCache_exports as ScopedCache,
  ScopedRef_exports as ScopedRef,
  Secret_exports as Secret,
  SingleProducerAsyncInput_exports as SingleProducerAsyncInput,
  Sink_exports as Sink,
  SortedMap_exports as SortedMap,
  SortedSet_exports as SortedSet,
  Stream_exports as Stream,
  StreamEmit_exports as StreamEmit,
  StreamHaltStrategy_exports as StreamHaltStrategy,
  Streamable_exports as Streamable,
  String_exports as String,
  Struct_exports as Struct,
  Subscribable_exports as Subscribable,
  SubscriptionRef_exports as SubscriptionRef,
  Supervisor_exports as Supervisor,
  Symbol_exports as Symbol,
  SynchronizedRef_exports as SynchronizedRef,
  TArray_exports as TArray,
  TDeferred_exports as TDeferred,
  TMap_exports as TMap,
  TPriorityQueue_exports as TPriorityQueue,
  TPubSub_exports as TPubSub,
  TQueue_exports as TQueue,
  TRandom_exports as TRandom,
  TReentrantLock_exports as TReentrantLock,
  TRef_exports as TRef,
  TSemaphore_exports as TSemaphore,
  TSet_exports as TSet,
  Take_exports as Take,
  TestAnnotation_exports as TestAnnotation,
  TestAnnotationMap_exports as TestAnnotationMap,
  TestAnnotations_exports as TestAnnotations,
  TestClock_exports as TestClock,
  TestConfig_exports as TestConfig,
  TestContext_exports as TestContext,
  TestLive_exports as TestLive,
  TestServices_exports as TestServices,
  TestSized_exports as TestSized,
  Tracer_exports as Tracer,
  Trie_exports as Trie,
  Tuple_exports as Tuple,
  Types_exports as Types,
  Unify_exports as Unify,
  UpstreamPullRequest_exports as UpstreamPullRequest,
  UpstreamPullStrategy_exports as UpstreamPullStrategy,
  Utils_exports as Utils,
  absurd,
  flow,
  hole,
  identity,
  pipe,
  unsafeCoerce
};
//# sourceMappingURL=effect.js.map
