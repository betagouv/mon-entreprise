{
  "version": 3,
  "sources": ["../../../../node_modules/effect/src/Number.ts"],
  "sourcesContent": ["/**\n * This module provides utility functions and type class instances for working with the `number` type in TypeScript.\n * It includes functions for basic arithmetic operations, as well as type class instances for\n * `Equivalence` and `Order`.\n *\n * @since 2.0.0\n */\nimport * as equivalence from \"./Equivalence.js\"\nimport { dual } from \"./Function.js\"\nimport * as option from \"./internal/option.js\"\nimport type { Option } from \"./Option.js\"\nimport * as order from \"./Order.js\"\nimport type { Ordering } from \"./Ordering.js\"\nimport * as predicate from \"./Predicate.js\"\n\n/**\n * Tests if a value is a `number`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNumber } from 'effect/Number'\n *\n * assert.deepStrictEqual(isNumber(2), true)\n * assert.deepStrictEqual(isNumber(\"2\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNumber: (input: unknown) => input is number = predicate.isNumber\n\n/**\n * Provides an addition operation on `number`s.\n *\n * @param self - The first operand.\n * @param that - The second operand.\n *\n * @example\n * import { sum } from 'effect/Number'\n *\n * assert.deepStrictEqual(sum(2, 3), 5)\n *\n * @category math\n * @since 2.0.0\n */\nexport const sum: {\n  (that: number): (self: number) => number\n  (self: number, that: number): number\n} = dual(2, (self: number, that: number): number => self + that)\n\n/**\n * Provides a multiplication operation on `number`s.\n *\n * @param self - The first operand.\n * @param that - The second operand.\n *\n * @example\n * import { multiply } from 'effect/Number'\n *\n * assert.deepStrictEqual(multiply(2, 3), 6)\n *\n * @category math\n * @since 2.0.0\n */\nexport const multiply: {\n  (that: number): (self: number) => number\n  (self: number, that: number): number\n} = dual(2, (self: number, that: number): number => self * that)\n\n/**\n * Provides a subtraction operation on `number`s.\n *\n * @param self - The first operand.\n * @param that - The second operand.\n *\n * @example\n * import { subtract } from 'effect/Number'\n *\n * assert.deepStrictEqual(subtract(2, 3), -1)\n *\n * @category math\n * @since 2.0.0\n */\nexport const subtract: {\n  (that: number): (self: number) => number\n  (self: number, that: number): number\n} = dual(2, (self: number, that: number): number => self - that)\n\n/**\n * Provides a division operation on `number`s.\n *\n * @param self - The dividend operand.\n * @param that - The divisor operand.\n *\n * @example\n * import { divide } from 'effect/Number'\n * import { some, none } from 'effect/Option'\n *\n * assert.deepStrictEqual(divide(6, 3), some(2))\n * assert.deepStrictEqual(divide(6, 0), none())\n *\n * @category math\n * @since 2.0.0\n */\nexport const divide: {\n  (that: number): (self: number) => Option<number>\n  (self: number, that: number): Option<number>\n} = dual(\n  2,\n  (self: number, that: number): Option<number> => that === 0 ? option.none : option.some(self / that)\n)\n\n/**\n * Provides a division operation on `number`s.\n *\n * Throws a `RangeError` if the divisor is `0`.\n *\n * @param self - The dividend operand.\n * @param that - The divisor operand.\n *\n * @example\n * import { unsafeDivide } from 'effect/Number'\n *\n * assert.deepStrictEqual(unsafeDivide(6, 3), 2)\n *\n * @category math\n * @since 2.0.0\n */\nexport const unsafeDivide: {\n  (that: number): (self: number) => number\n  (self: number, that: number): number\n} = dual(2, (self: number, that: number): number => self / that)\n\n/**\n * Returns the result of adding `1` to a given number.\n *\n * @param n - A `number` to be incremented.\n *\n * @example\n * import { increment } from 'effect/Number'\n *\n * assert.deepStrictEqual(increment(2), 3)\n *\n * @category math\n * @since 2.0.0\n */\nexport const increment = (n: number): number => n + 1\n\n/**\n * Decrements a number by `1`.\n *\n * @param n - A `number` to be decremented.\n *\n * @example\n * import { decrement } from 'effect/Number'\n *\n * assert.deepStrictEqual(decrement(3), 2)\n *\n * @category math\n * @since 2.0.0\n */\nexport const decrement = (n: number): number => n - 1\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Equivalence: equivalence.Equivalence<number> = equivalence.number\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Order: order.Order<number> = order.number\n\n/**\n * Returns `true` if the first argument is less than the second, otherwise `false`.\n *\n * @param self - The first argument.\n * @param that - The second argument.\n *\n * @example\n * import { lessThan } from 'effect/Number'\n *\n * assert.deepStrictEqual(lessThan(2, 3), true)\n * assert.deepStrictEqual(lessThan(3, 3), false)\n * assert.deepStrictEqual(lessThan(4, 3), false)\n *\n * @category predicates\n * @since 2.0.0\n */\nexport const lessThan: {\n  (that: number): (self: number) => boolean\n  (self: number, that: number): boolean\n} = order.lessThan(Order)\n\n/**\n * Returns a function that checks if a given `number` is less than or equal to the provided one.\n *\n * @param self - The first `number` to compare with.\n * @param that - The second `number` to compare with.\n *\n * @example\n * import { lessThanOrEqualTo } from 'effect/Number'\n *\n * assert.deepStrictEqual(lessThanOrEqualTo(2, 3), true)\n * assert.deepStrictEqual(lessThanOrEqualTo(3, 3), true)\n * assert.deepStrictEqual(lessThanOrEqualTo(4, 3), false)\n *\n * @category predicates\n * @since 2.0.0\n */\nexport const lessThanOrEqualTo: {\n  (that: number): (self: number) => boolean\n  (self: number, that: number): boolean\n} = order.lessThanOrEqualTo(Order)\n\n/**\n * Returns `true` if the first argument is greater than the second, otherwise `false`.\n *\n * @param self - The first argument.\n * @param that - The second argument.\n *\n * @example\n * import { greaterThan } from 'effect/Number'\n *\n * assert.deepStrictEqual(greaterThan(2, 3), false)\n * assert.deepStrictEqual(greaterThan(3, 3), false)\n * assert.deepStrictEqual(greaterThan(4, 3), true)\n *\n * @category predicates\n * @since 2.0.0\n */\nexport const greaterThan: {\n  (that: number): (self: number) => boolean\n  (self: number, that: number): boolean\n} = order.greaterThan(Order)\n\n/**\n * Returns a function that checks if a given `number` is greater than or equal to the provided one.\n *\n * @param self - The first `number` to compare with.\n * @param that - The second `number` to compare with.\n *\n * @example\n * import { greaterThanOrEqualTo } from 'effect/Number'\n *\n * assert.deepStrictEqual(greaterThanOrEqualTo(2, 3), false)\n * assert.deepStrictEqual(greaterThanOrEqualTo(3, 3), true)\n * assert.deepStrictEqual(greaterThanOrEqualTo(4, 3), true)\n *\n * @category predicates\n * @since 2.0.0\n */\nexport const greaterThanOrEqualTo: {\n  (that: number): (self: number) => boolean\n  (self: number, that: number): boolean\n} = order.greaterThanOrEqualTo(Order)\n\n/**\n * Checks if a `number` is between a `minimum` and `maximum` value (inclusive).\n *\n * @param self - The `number` to check.\n * @param minimum - The `minimum` value to check.\n * @param maximum - The `maximum` value to check.\n *\n * @example\n * import * as Number from 'effect/Number'\n *\n * const between = Number.between({ minimum: 0, maximum: 5 })\n *\n * assert.deepStrictEqual(between(3), true)\n * assert.deepStrictEqual(between(-1), false)\n * assert.deepStrictEqual(between(6), false)\n *\n * @category predicates\n * @since 2.0.0\n */\nexport const between: {\n  (options: {\n    minimum: number\n    maximum: number\n  }): (self: number) => boolean\n  (self: number, options: {\n    minimum: number\n    maximum: number\n  }): boolean\n} = order.between(Order)\n\n/**\n * Restricts the given `number` to be within the range specified by the `minimum` and `maximum` values.\n *\n * - If the `number` is less than the `minimum` value, the function returns the `minimum` value.\n * - If the `number` is greater than the `maximum` value, the function returns the `maximum` value.\n * - Otherwise, it returns the original `number`.\n *\n * @param self - The `number` to be clamped.\n * @param minimum - The lower end of the range.\n * @param maximum - The upper end of the range.\n *\n * @example\n * import * as Number from 'effect/Number'\n *\n * const clamp = Number.clamp({ minimum: 1, maximum: 5 })\n *\n * assert.equal(clamp(3), 3)\n * assert.equal(clamp(0), 1)\n * assert.equal(clamp(6), 5)\n *\n * @since 2.0.0\n */\nexport const clamp: {\n  (options: {\n    minimum: number\n    maximum: number\n  }): (self: number) => number\n  (self: number, options: {\n    minimum: number\n    maximum: number\n  }): number\n} = order.clamp(Order)\n\n/**\n * Returns the minimum between two `number`s.\n *\n * @param self - The first `number`.\n * @param that - The second `number`.\n *\n * @example\n * import { min } from 'effect/Number'\n *\n * assert.deepStrictEqual(min(2, 3), 2)\n *\n * @since 2.0.0\n */\nexport const min: {\n  (that: number): (self: number) => number\n  (self: number, that: number): number\n} = order.min(Order)\n\n/**\n * Returns the maximum between two `number`s.\n *\n * @param self - The first `number`.\n * @param that - The second `number`.\n *\n * @example\n * import { max } from 'effect/Number'\n *\n * assert.deepStrictEqual(max(2, 3), 3)\n *\n * @since 2.0.0\n */\nexport const max: {\n  (that: number): (self: number) => number\n  (self: number, that: number): number\n} = order.max(Order)\n\n/**\n * Determines the sign of a given `number`.\n *\n * @param n - The `number` to determine the sign of.\n *\n * @example\n * import { sign } from 'effect/Number'\n *\n * assert.deepStrictEqual(sign(-5), -1)\n * assert.deepStrictEqual(sign(0), 0)\n * assert.deepStrictEqual(sign(5), 1)\n *\n * @category math\n * @since 2.0.0\n */\nexport const sign = (n: number): Ordering => Order(n, 0)\n\n/**\n * Takes an `Iterable` of `number`s and returns their sum as a single `number`.\n *\n * @param collection - The collection of `number`s to sum.\n *\n * @example\n * import { sumAll } from 'effect/Number'\n *\n * assert.deepStrictEqual(sumAll([2, 3, 4]), 9)\n *\n * @category math\n * @since 2.0.0\n */\nexport const sumAll = (collection: Iterable<number>): number => {\n  let out = 0\n  for (const n of collection) {\n    out += n\n  }\n  return out\n}\n\n/**\n * Takes an `Iterable` of `number`s and returns their multiplication as a single `number`.\n *\n * @param collection - The collection of `number`s to multiply.\n *\n * @example\n * import { multiplyAll } from \"effect/Number\"\n *\n * assert.deepStrictEqual(multiplyAll([2, 3, 4]), 24)\n *\n * @category math\n * @since 2.0.0\n */\nexport const multiplyAll = (collection: Iterable<number>): number => {\n  let out = 1\n  for (const n of collection) {\n    if (n === 0) {\n      return 0\n    }\n    out *= n\n  }\n  return out\n}\n\n/**\n * Returns the remainder left over when one operand is divided by a second operand.\n *\n * It always takes the sign of the dividend.\n *\n * @param self - The dividend.\n * @param divisor - The divisor.\n *\n * @example\n * import { remainder } from \"effect/Number\"\n *\n * assert.deepStrictEqual(remainder(2, 2), 0)\n * assert.deepStrictEqual(remainder(3, 2), 1)\n * assert.deepStrictEqual(remainder(-4, 2), -0)\n *\n * @category math\n * @since 2.0.0\n */\nexport const remainder: {\n  (divisor: number): (self: number) => number\n  (self: number, divisor: number): number\n} = dual(2, (self: number, divisor: number): number => {\n  // https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\n  const selfDecCount = (self.toString().split(\".\")[1] || \"\").length\n  const divisorDecCount = (divisor.toString().split(\".\")[1] || \"\").length\n  const decCount = selfDecCount > divisorDecCount ? selfDecCount : divisorDecCount\n  const selfInt = parseInt(self.toFixed(decCount).replace(\".\", \"\"))\n  const divisorInt = parseInt(divisor.toFixed(decCount).replace(\".\", \"\"))\n  return (selfInt % divisorInt) / Math.pow(10, decCount)\n})\n\n/**\n * Returns the next power of 2 from the given number.\n *\n * @param self - The number to find the next power of 2 from.\n *\n * @example\n * import { nextPow2 } from \"effect/Number\"\n *\n * assert.deepStrictEqual(nextPow2(5), 8)\n * assert.deepStrictEqual(nextPow2(17), 32)\n *\n * @category math\n * @since 2.0.0\n */\nexport const nextPow2 = (n: number): number => {\n  const nextPow = Math.ceil(Math.log(n) / Math.log(2))\n  return Math.max(Math.pow(2, nextPow), 2)\n}\n\n/**\n * Tries to parse a `number` from a `string` using the `Number()` function.\n * The following special string values are supported: \"NaN\", \"Infinity\", \"-Infinity\".\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const parse = (s: string): Option<number> => {\n  if (s === \"NaN\") {\n    return option.some(NaN)\n  }\n  if (s === \"Infinity\") {\n    return option.some(Infinity)\n  }\n  if (s === \"-Infinity\") {\n    return option.some(-Infinity)\n  }\n  if (s.trim() === \"\") {\n    return option.none\n  }\n  const n = Number(s)\n  return Number.isNaN(n)\n    ? option.none\n    : option.some(n)\n}\n"],
  "mappings": "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",
  "names": ["between", "clamp", "greaterThan", "greaterThanOrEqualTo", "isNumber", "lessThan", "lessThanOrEqualTo", "max", "min", "isNumber", "sum", "dual", "self", "that", "multiply", "subtract", "divide", "none", "some", "unsafeDivide", "increment", "n", "decrement", "Equivalence", "number", "Order", "lessThan", "lessThanOrEqualTo", "greaterThan", "greaterThanOrEqualTo", "between", "clamp", "min", "max", "sign", "sumAll", "collection", "out", "multiplyAll", "remainder", "divisor", "selfDecCount", "toString", "split", "length", "divisorDecCount", "decCount", "selfInt", "parseInt", "toFixed", "replace", "divisorInt", "Math", "pow", "nextPow2", "nextPow", "ceil", "log", "parse", "s", "NaN", "Infinity", "trim", "Number", "isNaN"]
}
