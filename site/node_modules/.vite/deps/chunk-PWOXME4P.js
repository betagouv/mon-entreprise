import {
  TypeId,
  fromOption,
  getLeft,
  getRight,
  isEither,
  isLeft,
  isRight,
  isSome,
  left,
  none,
  right,
  some
} from "./chunk-GMICS55Q.js";
import {
  adapter,
  equivalence,
  make
} from "./chunk-PMMD7ZWW.js";
import {
  constNull,
  constUndefined,
  dual,
  identity,
  isFunction2 as isFunction
} from "./chunk-KURLOJT7.js";
import {
  __export
} from "./chunk-2LSFTFF7.js";

// ../node_modules/effect/dist/esm/Record.js
var Record_exports = {};
__export(Record_exports, {
  collect: () => collect,
  difference: () => difference,
  empty: () => empty,
  every: () => every,
  filter: () => filter,
  filterMap: () => filterMap,
  fromEntries: () => fromEntries,
  fromIterableBy: () => fromIterableBy,
  fromIterableWith: () => fromIterableWith,
  get: () => get,
  getEquivalence: () => getEquivalence2,
  getLefts: () => getLefts,
  getRights: () => getRights,
  getSomes: () => getSomes,
  has: () => has,
  intersection: () => intersection,
  isEmptyReadonlyRecord: () => isEmptyReadonlyRecord,
  isEmptyRecord: () => isEmptyRecord,
  isSubrecord: () => isSubrecord,
  isSubrecordBy: () => isSubrecordBy,
  keys: () => keys,
  map: () => map2,
  mapEntries: () => mapEntries,
  mapKeys: () => mapKeys,
  modify: () => modify,
  modifyOption: () => modifyOption,
  partition: () => partition,
  partitionMap: () => partitionMap,
  pop: () => pop,
  reduce: () => reduce,
  remove: () => remove,
  replace: () => replace,
  replaceOption: () => replaceOption,
  separate: () => separate,
  set: () => set,
  singleton: () => singleton,
  size: () => size,
  some: () => some2,
  toEntries: () => toEntries,
  union: () => union,
  values: () => values
});

// ../node_modules/effect/dist/esm/Either.js
var Either_exports = {};
__export(Either_exports, {
  Do: () => Do,
  TypeId: () => TypeId2,
  all: () => all,
  andThen: () => andThen,
  ap: () => ap,
  bind: () => bind,
  bindTo: () => bindTo,
  filterOrLeft: () => filterOrLeft,
  flatMap: () => flatMap,
  flip: () => flip,
  fromNullable: () => fromNullable,
  fromOption: () => fromOption2,
  gen: () => gen,
  getEquivalence: () => getEquivalence,
  getLeft: () => getLeft2,
  getOrElse: () => getOrElse,
  getOrNull: () => getOrNull,
  getOrThrow: () => getOrThrow,
  getOrThrowWith: () => getOrThrowWith,
  getOrUndefined: () => getOrUndefined,
  getRight: () => getRight2,
  isEither: () => isEither2,
  isLeft: () => isLeft2,
  isRight: () => isRight2,
  left: () => left2,
  let: () => let_,
  map: () => map,
  mapBoth: () => mapBoth,
  mapLeft: () => mapLeft,
  match: () => match,
  merge: () => merge,
  orElse: () => orElse,
  right: () => right2,
  try: () => try_,
  zipWith: () => zipWith
});
var TypeId2 = TypeId;
var right2 = right;
var left2 = left;
var fromNullable = dual(2, (self, onNullable) => self == null ? left2(onNullable(self)) : right2(self));
var fromOption2 = fromOption;
var try_ = (evaluate) => {
  if (isFunction(evaluate)) {
    try {
      return right2(evaluate());
    } catch (e) {
      return left2(e);
    }
  } else {
    try {
      return right2(evaluate.try());
    } catch (e) {
      return left2(evaluate.catch(e));
    }
  }
};
var isEither2 = isEither;
var isLeft2 = isLeft;
var isRight2 = isRight;
var getRight2 = getRight;
var getLeft2 = getLeft;
var getEquivalence = ({
  left: left3,
  right: right3
}) => make((x, y) => x === y || (isLeft2(x) ? isLeft2(y) && left3(x.left, y.left) : isRight2(y) && right3(x.right, y.right)));
var mapBoth = dual(2, (self, {
  onLeft,
  onRight
}) => isLeft2(self) ? left2(onLeft(self.left)) : right2(onRight(self.right)));
var mapLeft = dual(2, (self, f) => isLeft2(self) ? left2(f(self.left)) : right2(self.right));
var map = dual(2, (self, f) => isRight2(self) ? right2(f(self.right)) : left2(self.left));
var match = dual(2, (self, {
  onLeft,
  onRight
}) => isLeft2(self) ? onLeft(self.left) : onRight(self.right));
var filterOrLeft = dual(3, (self, predicate, orLeftWith) => flatMap(self, (r) => predicate(r) ? right2(r) : left2(orLeftWith(r))));
var merge = match({
  onLeft: identity,
  onRight: identity
});
var getOrElse = dual(2, (self, onLeft) => isLeft2(self) ? onLeft(self.left) : self.right);
var getOrNull = getOrElse(constNull);
var getOrUndefined = getOrElse(constUndefined);
var getOrThrowWith = dual(2, (self, onLeft) => {
  if (isRight2(self)) {
    return self.right;
  }
  throw onLeft(self.left);
});
var getOrThrow = getOrThrowWith(() => new Error("getOrThrow called on a Left"));
var orElse = dual(2, (self, that) => isLeft2(self) ? that(self.left) : right2(self.right));
var flatMap = dual(2, (self, f) => isLeft2(self) ? left2(self.left) : f(self.right));
var andThen = dual(2, (self, f) => flatMap(self, (a) => {
  const b = isFunction(f) ? f(a) : f;
  return isEither2(b) ? b : right2(b);
}));
var zipWith = dual(3, (self, that, f) => flatMap(self, (r) => map(that, (r2) => f(r, r2))));
var ap = dual(2, (self, that) => zipWith(self, that, (f, a) => f(a)));
var all = (input) => {
  if (Symbol.iterator in input) {
    const out2 = [];
    for (const e of input) {
      if (isLeft2(e)) {
        return e;
      }
      out2.push(e.right);
    }
    return right2(out2);
  }
  const out = {};
  for (const key of Object.keys(input)) {
    const e = input[key];
    if (isLeft2(e)) {
      return e;
    }
    out[key] = e.right;
  }
  return right2(out);
};
var flip = (self) => isLeft2(self) ? right2(self.left) : left2(self.right);
var adapter2 = adapter();
var gen = (f) => {
  const iterator = f(adapter2);
  let state = iterator.next();
  if (state.done) {
    return right2(state.value);
  } else {
    let current = state.value.value;
    if (isLeft2(current)) {
      return current;
    }
    while (!state.done) {
      state = iterator.next(current.right);
      if (!state.done) {
        current = state.value.value;
        if (isLeft2(current)) {
          return current;
        }
      }
    }
    return right2(state.value);
  }
};
var Do = right2({});
var bind = dual(3, (self, tag, f) => flatMap(self, (k) => map(f(k), (a) => ({
  ...k,
  [tag]: a
}))));
var bindTo = dual(2, (self, tag) => map(self, (a) => ({
  [tag]: a
})));
var let_ = dual(3, (self, tag, f) => map(self, (k) => ({
  ...k,
  [tag]: f(k)
})));

// ../node_modules/effect/dist/esm/Record.js
var empty = () => ({});
var isEmptyRecord = (self) => keys(self).length === 0;
var isEmptyReadonlyRecord = isEmptyRecord;
var fromIterableWith = dual(2, (self, f) => {
  const out = empty();
  for (const a of self) {
    const [k, b] = f(a);
    out[k] = b;
  }
  return out;
});
var fromIterableBy = (items, f) => fromIterableWith(items, (a) => [f(a), a]);
var fromEntries = Object.fromEntries;
var collect = dual(2, (self, f) => {
  const out = [];
  for (const key of keys(self)) {
    out.push(f(key, self[key]));
  }
  return out;
});
var toEntries = collect((key, value) => [key, value]);
var size = (self) => keys(self).length;
var has = dual(2, (self, key) => Object.prototype.hasOwnProperty.call(self, key));
var get = dual(2, (self, key) => has(self, key) ? some(self[key]) : none());
var modify = dual(3, (self, key, f) => {
  if (!has(self, key)) {
    return {
      ...self
    };
  }
  return {
    ...self,
    [key]: f(self[key])
  };
});
var modifyOption = dual(3, (self, key, f) => {
  if (!has(self, key)) {
    return none();
  }
  return some({
    ...self,
    [key]: f(self[key])
  });
});
var replaceOption = dual(3, (self, key, b) => modifyOption(self, key, () => b));
var remove = dual(2, (self, key) => {
  if (!has(self, key)) {
    return {
      ...self
    };
  }
  const out = {
    ...self
  };
  delete out[key];
  return out;
});
var pop = dual(2, (self, key) => has(self, key) ? some([self[key], remove(self, key)]) : none());
var map2 = dual(2, (self, f) => {
  const out = {
    ...self
  };
  for (const key of keys(self)) {
    out[key] = f(self[key], key);
  }
  return out;
});
var mapKeys = dual(2, (self, f) => {
  const out = {};
  for (const key of keys(self)) {
    const a = self[key];
    out[f(key, a)] = a;
  }
  return out;
});
var mapEntries = dual(2, (self, f) => {
  const out = {};
  for (const key of keys(self)) {
    const [k, b] = f(self[key], key);
    out[k] = b;
  }
  return out;
});
var filterMap = dual(2, (self, f) => {
  const out = empty();
  for (const key of keys(self)) {
    const o = f(self[key], key);
    if (isSome(o)) {
      out[key] = o.value;
    }
  }
  return out;
});
var filter = dual(2, (self, predicate) => {
  const out = empty();
  for (const key of keys(self)) {
    if (predicate(self[key], key)) {
      out[key] = self[key];
    }
  }
  return out;
});
var getSomes = filterMap(identity);
var getLefts = (self) => {
  const out = empty();
  for (const key of keys(self)) {
    const value = self[key];
    if (isLeft2(value)) {
      out[key] = value.left;
    }
  }
  return out;
};
var getRights = (self) => {
  const out = empty();
  for (const key of keys(self)) {
    const value = self[key];
    if (isRight2(value)) {
      out[key] = value.right;
    }
  }
  return out;
};
var partitionMap = dual(2, (self, f) => {
  const left3 = empty();
  const right3 = empty();
  for (const key of keys(self)) {
    const e = f(self[key], key);
    if (isLeft2(e)) {
      left3[key] = e.left;
    } else {
      right3[key] = e.right;
    }
  }
  return [left3, right3];
});
var separate = partitionMap(identity);
var partition = dual(2, (self, predicate) => {
  const left3 = empty();
  const right3 = empty();
  for (const key of keys(self)) {
    if (predicate(self[key], key)) {
      right3[key] = self[key];
    } else {
      left3[key] = self[key];
    }
  }
  return [left3, right3];
});
var keys = (self) => Object.keys(self);
var values = (self) => collect(self, (_, a) => a);
var set = dual(3, (self, key, value) => {
  return {
    ...self,
    [key]: value
  };
});
var replace = dual(3, (self, key, value) => {
  if (has(self, key)) {
    return {
      ...self,
      [key]: value
    };
  }
  return {
    ...self
  };
});
var isSubrecordBy = (equivalence2) => dual(2, (self, that) => {
  for (const key of keys(self)) {
    if (!has(that, key) || !equivalence2(self[key], that[key])) {
      return false;
    }
  }
  return true;
});
var isSubrecord = isSubrecordBy(equivalence());
var reduce = dual(3, (self, zero, f) => {
  let out = zero;
  for (const key of keys(self)) {
    out = f(out, self[key], key);
  }
  return out;
});
var every = dual(2, (self, refinement) => {
  for (const key of keys(self)) {
    if (!refinement(self[key], key)) {
      return false;
    }
  }
  return true;
});
var some2 = dual(2, (self, predicate) => {
  for (const key of keys(self)) {
    if (predicate(self[key], key)) {
      return true;
    }
  }
  return false;
});
var union = dual(3, (self, that, combine) => {
  if (isEmptyRecord(self)) {
    return {
      ...that
    };
  }
  if (isEmptyRecord(that)) {
    return {
      ...self
    };
  }
  const out = empty();
  for (const key of keys(self)) {
    if (has(that, key)) {
      out[key] = combine(self[key], that[key]);
    } else {
      out[key] = self[key];
    }
  }
  for (const key of keys(that)) {
    if (!has(out, key)) {
      out[key] = that[key];
    }
  }
  return out;
});
var intersection = dual(3, (self, that, combine) => {
  const out = empty();
  if (isEmptyRecord(self) || isEmptyRecord(that)) {
    return out;
  }
  for (const key of keys(self)) {
    if (has(that, key)) {
      out[key] = combine(self[key], that[key]);
    }
  }
  return out;
});
var difference = dual(2, (self, that) => {
  if (isEmptyRecord(self)) {
    return {
      ...that
    };
  }
  if (isEmptyRecord(that)) {
    return {
      ...self
    };
  }
  const out = {};
  for (const key of keys(self)) {
    if (!has(that, key)) {
      out[key] = self[key];
    }
  }
  for (const key of keys(that)) {
    if (!has(self, key)) {
      out[key] = that[key];
    }
  }
  return out;
});
var getEquivalence2 = (equivalence2) => {
  const is = isSubrecordBy(equivalence2);
  return (self, that) => is(self, that) && is(that, self);
};
var singleton = (key, value) => ({
  [key]: value
});

export {
  right2 as right,
  left2 as left,
  fromOption2 as fromOption,
  isEither2 as isEither,
  isLeft2 as isLeft,
  isRight2 as isRight,
  getRight2 as getRight,
  getLeft2 as getLeft,
  map,
  match,
  merge,
  getOrThrowWith,
  all,
  Either_exports,
  empty,
  isEmptyRecord,
  isEmptyReadonlyRecord,
  fromIterableWith,
  fromIterableBy,
  fromEntries,
  collect,
  toEntries,
  size,
  has,
  get,
  modify,
  modifyOption,
  replaceOption,
  remove,
  pop,
  map2,
  mapKeys,
  mapEntries,
  filterMap,
  filter,
  getSomes,
  getLefts,
  getRights,
  partitionMap,
  separate,
  partition,
  keys,
  values,
  set,
  replace,
  isSubrecordBy,
  isSubrecord,
  reduce,
  every,
  some2 as some,
  union,
  intersection,
  difference,
  getEquivalence2 as getEquivalence,
  singleton,
  Record_exports
};
//# sourceMappingURL=chunk-PWOXME4P.js.map
