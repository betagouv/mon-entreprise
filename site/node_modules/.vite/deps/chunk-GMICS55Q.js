import {
  EffectPrototype,
  NodeInspectSymbol,
  adapter,
  combine,
  equals,
  equivalence,
  format,
  hash,
  isNone,
  isOption,
  isSome,
  make,
  make2,
  none,
  some,
  symbol2 as symbol,
  symbol3 as symbol2,
  toJSON
} from "./chunk-PMMD7ZWW.js";
import {
  constNull,
  constUndefined,
  dual,
  hasProperty,
  identity,
  isFunction
} from "./chunk-KURLOJT7.js";
import {
  __export
} from "./chunk-2LSFTFF7.js";

// ../node_modules/effect/dist/esm/Option.js
var Option_exports = {};
__export(Option_exports, {
  Do: () => Do,
  TypeId: () => TypeId2,
  all: () => all,
  andThen: () => andThen,
  ap: () => ap,
  as: () => as,
  asVoid: () => asVoid,
  bind: () => bind,
  bindTo: () => bindTo,
  composeK: () => composeK,
  contains: () => contains,
  containsWith: () => containsWith,
  exists: () => exists,
  filter: () => filter,
  filterMap: () => filterMap,
  firstSomeOf: () => firstSomeOf,
  flatMap: () => flatMap,
  flatMapNullable: () => flatMapNullable,
  flatten: () => flatten,
  fromIterable: () => fromIterable,
  fromNullable: () => fromNullable,
  gen: () => gen,
  getEquivalence: () => getEquivalence,
  getLeft: () => getLeft2,
  getOrElse: () => getOrElse,
  getOrNull: () => getOrNull,
  getOrThrow: () => getOrThrow,
  getOrThrowWith: () => getOrThrowWith,
  getOrUndefined: () => getOrUndefined,
  getOrder: () => getOrder,
  getRight: () => getRight2,
  isNone: () => isNone2,
  isOption: () => isOption2,
  isSome: () => isSome2,
  let: () => let_,
  lift2: () => lift2,
  liftNullable: () => liftNullable,
  liftPredicate: () => liftPredicate,
  liftThrowable: () => liftThrowable,
  map: () => map,
  match: () => match,
  none: () => none2,
  orElse: () => orElse,
  orElseEither: () => orElseEither,
  orElseSome: () => orElseSome,
  partitionMap: () => partitionMap,
  product: () => product,
  productMany: () => productMany,
  reduceCompact: () => reduceCompact,
  some: () => some2,
  tap: () => tap,
  toArray: () => toArray,
  toRefinement: () => toRefinement,
  void: () => void_,
  zipLeft: () => zipLeft,
  zipRight: () => zipRight,
  zipWith: () => zipWith
});

// ../node_modules/effect/dist/esm/internal/either.js
var TypeId = Symbol.for("effect/Either");
var CommonProto = {
  ...EffectPrototype,
  [TypeId]: {
    _R: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var RightProto = Object.assign(Object.create(CommonProto), {
  _tag: "Right",
  _op: "Right",
  [symbol2](that) {
    return isEither(that) && isRight(that) && equals(that.right, this.right);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON(this.right)
    };
  }
});
var LeftProto = Object.assign(Object.create(CommonProto), {
  _tag: "Left",
  _op: "Left",
  [symbol2](that) {
    return isEither(that) && isLeft(that) && equals(that.left, this.left);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON(this.left)
    };
  }
});
var isEither = (input) => hasProperty(input, TypeId);
var isLeft = (ma) => ma._tag === "Left";
var isRight = (ma) => ma._tag === "Right";
var left = (left2) => {
  const a = Object.create(LeftProto);
  a.left = left2;
  return a;
};
var right = (right2) => {
  const a = Object.create(RightProto);
  a.right = right2;
  return a;
};
var getLeft = (self) => isRight(self) ? none : some(self.left);
var getRight = (self) => isLeft(self) ? none : some(self.right);
var fromOption = dual(2, (self, onNone) => isNone(self) ? left(onNone()) : right(self.value));

// ../node_modules/effect/dist/esm/Option.js
var TypeId2 = Symbol.for("effect/Option");
var none2 = () => none;
var some2 = some;
var isOption2 = isOption;
var isNone2 = isNone;
var isSome2 = isSome;
var match = dual(2, (self, {
  onNone,
  onSome
}) => isNone2(self) ? onNone() : onSome(self.value));
var toRefinement = (f) => (a) => isSome2(f(a));
var fromIterable = (collection) => {
  for (const a of collection) {
    return some2(a);
  }
  return none2();
};
var getRight2 = getRight;
var getLeft2 = getLeft;
var getOrElse = dual(2, (self, onNone) => isNone2(self) ? onNone() : self.value);
var orElse = dual(2, (self, that) => isNone2(self) ? that() : self);
var orElseSome = dual(2, (self, onNone) => isNone2(self) ? some2(onNone()) : self);
var orElseEither = dual(2, (self, that) => isNone2(self) ? map(that(), right) : map(self, left));
var firstSomeOf = (collection) => {
  let out = none2();
  for (out of collection) {
    if (isSome2(out)) {
      return out;
    }
  }
  return out;
};
var fromNullable = (nullableValue) => nullableValue == null ? none2() : some2(nullableValue);
var liftNullable = (f) => (...a) => fromNullable(f(...a));
var getOrNull = getOrElse(constNull);
var getOrUndefined = getOrElse(constUndefined);
var liftThrowable = (f) => (...a) => {
  try {
    return some2(f(...a));
  } catch (e) {
    return none2();
  }
};
var getOrThrowWith = dual(2, (self, onNone) => {
  if (isSome2(self)) {
    return self.value;
  }
  throw onNone();
});
var getOrThrow = getOrThrowWith(() => new Error("getOrThrow called on a None"));
var map = dual(2, (self, f) => isNone2(self) ? none2() : some2(f(self.value)));
var as = dual(2, (self, b) => map(self, () => b));
var asVoid = as(void 0);
var void_ = some2(void 0);
var flatMap = dual(2, (self, f) => isNone2(self) ? none2() : f(self.value));
var andThen = dual(2, (self, f) => flatMap(self, (a) => {
  const b = isFunction(f) ? f(a) : f;
  return isOption2(b) ? b : some2(b);
}));
var flatMapNullable = dual(2, (self, f) => isNone2(self) ? none2() : fromNullable(f(self.value)));
var flatten = flatMap(identity);
var zipRight = dual(2, (self, that) => flatMap(self, () => that));
var composeK = dual(2, (afb, bfc) => (a) => flatMap(afb(a), bfc));
var zipLeft = dual(2, (self, that) => tap(self, () => that));
var tap = dual(2, (self, f) => flatMap(self, (a) => map(f(a), () => a)));
var product = (self, that) => isSome2(self) && isSome2(that) ? some2([self.value, that.value]) : none2();
var productMany = (self, collection) => {
  if (isNone2(self)) {
    return none2();
  }
  const out = [self.value];
  for (const o of collection) {
    if (isNone2(o)) {
      return none2();
    }
    out.push(o.value);
  }
  return some2(out);
};
var all = (input) => {
  if (Symbol.iterator in input) {
    const out2 = [];
    for (const o of input) {
      if (isNone2(o)) {
        return none2();
      }
      out2.push(o.value);
    }
    return some2(out2);
  }
  const out = {};
  for (const key of Object.keys(input)) {
    const o = input[key];
    if (isNone2(o)) {
      return none2();
    }
    out[key] = o.value;
  }
  return some2(out);
};
var zipWith = dual(3, (self, that, f) => map(product(self, that), ([a, b]) => f(a, b)));
var ap = dual(2, (self, that) => zipWith(self, that, (f, a) => f(a)));
var reduceCompact = dual(3, (self, b, f) => {
  let out = b;
  for (const oa of self) {
    if (isSome2(oa)) {
      out = f(out, oa.value);
    }
  }
  return out;
});
var toArray = (self) => isNone2(self) ? [] : [self.value];
var partitionMap = dual(2, (self, f) => {
  if (isNone2(self)) {
    return [none2(), none2()];
  }
  const e = f(self.value);
  return isLeft(e) ? [some2(e.left), none2()] : [none2(), some2(e.right)];
});
var filterMap = dual(2, (self, f) => isNone2(self) ? none2() : f(self.value));
var filter = dual(2, (self, predicate) => filterMap(self, (b) => predicate(b) ? some(b) : none));
var getEquivalence = (isEquivalent) => make((x, y) => x === y || (isNone2(x) ? isNone2(y) : isNone2(y) ? false : isEquivalent(x.value, y.value)));
var getOrder = (O) => make2((self, that) => isSome2(self) ? isSome2(that) ? O(self.value, that.value) : 1 : -1);
var lift2 = (f) => dual(2, (self, that) => zipWith(self, that, f));
var liftPredicate = (predicate) => (b) => predicate(b) ? some2(b) : none2();
var containsWith = (isEquivalent) => dual(2, (self, a) => isNone2(self) ? false : isEquivalent(self.value, a));
var _equivalence = equivalence();
var contains = containsWith(_equivalence);
var exists = dual(2, (self, refinement) => isNone2(self) ? false : refinement(self.value));
var bindTo = dual(2, (self, name) => map(self, (a) => ({
  [name]: a
})));
var let_ = dual(3, (self, name, f) => map(self, (a) => Object.assign({}, a, {
  [name]: f(a)
})));
var bind = dual(3, (self, name, f) => flatMap(self, (a) => map(f(a), (b) => Object.assign({}, a, {
  [name]: b
}))));
var Do = some2({});
var adapter2 = adapter();
var gen = (f) => {
  const iterator = f(adapter2);
  let state = iterator.next();
  if (state.done) {
    return some2(state.value);
  } else {
    let current = state.value.value;
    if (isNone2(current)) {
      return current;
    }
    while (!state.done) {
      state = iterator.next(current.value);
      if (!state.done) {
        current = state.value.value;
        if (isNone2(current)) {
          return current;
        }
      }
    }
    return some2(state.value);
  }
};

export {
  TypeId,
  isEither,
  isLeft,
  isRight,
  left,
  right,
  getLeft,
  getRight,
  fromOption,
  none2 as none,
  some2 as some,
  isNone2 as isNone,
  isSome2 as isSome,
  match,
  getRight2,
  getOrElse,
  orElse,
  orElseSome,
  fromNullable,
  getOrUndefined,
  liftThrowable,
  getOrThrowWith,
  getOrThrow,
  map,
  flatMap,
  all,
  toArray,
  filter,
  liftPredicate,
  contains,
  Option_exports
};
//# sourceMappingURL=chunk-GMICS55Q.js.map
