{
  "version": 3,
  "sources": ["../../../../node_modules/effect/src/Option.ts", "../../../../node_modules/effect/src/internal/either.ts"],
  "sourcesContent": ["/**\n * @since 2.0.0\n */\nimport type { Either } from \"./Either.js\"\nimport * as Equal from \"./Equal.js\"\nimport * as Equivalence from \"./Equivalence.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport { constNull, constUndefined, dual, identity, isFunction } from \"./Function.js\"\nimport type { TypeLambda } from \"./HKT.js\"\nimport type { Inspectable } from \"./Inspectable.js\"\nimport * as either from \"./internal/either.js\"\nimport * as option from \"./internal/option.js\"\nimport type { Order } from \"./Order.js\"\nimport * as order from \"./Order.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type { Predicate, Refinement } from \"./Predicate.js\"\nimport type { Covariant, NotFunction } from \"./Types.js\"\nimport type * as Unify from \"./Unify.js\"\nimport * as Gen from \"./Utils.js\"\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport type Option<A> = None<A> | Some<A>\n\n/**\n * @category symbols\n * @since 2.0.0\n */\nexport const TypeId = Symbol.for(\"effect/Option\")\n\n/**\n * @category symbols\n * @since 2.0.0\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface None<out A> extends Pipeable, Inspectable {\n  readonly _tag: \"None\"\n  readonly _op: \"None\"\n  readonly [TypeId]: {\n    readonly _A: Covariant<A>\n  }\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: OptionUnify<this>\n  [Unify.ignoreSymbol]?: OptionUnifyIgnore\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface Some<out A> extends Pipeable, Inspectable {\n  readonly _tag: \"Some\"\n  readonly _op: \"Some\"\n  readonly value: A\n  readonly [TypeId]: {\n    readonly _A: Covariant<A>\n  }\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: OptionUnify<this>\n  [Unify.ignoreSymbol]?: OptionUnifyIgnore\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface OptionUnify<A extends { [Unify.typeSymbol]?: any }> {\n  Option?: () => A[Unify.typeSymbol] extends Option<infer A0> | infer _ ? Option<A0> : never\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Option {\n  /**\n   * @since 2.0.0\n   * @category type-level\n   */\n  export type Value<T extends Option<any>> = [T] extends [Option<infer _A>] ? _A : never\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface OptionUnifyIgnore {}\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface OptionTypeLambda extends TypeLambda {\n  readonly type: Option<this[\"Target\"]>\n}\n\n/**\n * Creates a new `Option` that represents the absence of a value.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const none = <A = never>(): Option<A> => option.none\n\n/**\n * Creates a new `Option` that wraps the given value.\n *\n * @param value - The value to wrap.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const some: <A>(value: A) => Option<A> = option.some\n\n/**\n * Tests if a value is a `Option`.\n *\n * @param input - The value to check.\n *\n * @example\n * import { some, none, isOption } from 'effect/Option'\n *\n * assert.deepStrictEqual(isOption(some(1)), true)\n * assert.deepStrictEqual(isOption(none()), true)\n * assert.deepStrictEqual(isOption({}), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isOption: (input: unknown) => input is Option<unknown> = option.isOption\n\n/**\n * Determine if a `Option` is a `None`.\n *\n * @param self - The `Option` to check.\n *\n * @example\n * import { some, none, isNone } from 'effect/Option'\n *\n * assert.deepStrictEqual(isNone(some(1)), false)\n * assert.deepStrictEqual(isNone(none()), true)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNone: <A>(self: Option<A>) => self is None<A> = option.isNone\n\n/**\n * Determine if a `Option` is a `Some`.\n *\n * @param self - The `Option` to check.\n *\n * @example\n * import { some, none, isSome } from 'effect/Option'\n *\n * assert.deepStrictEqual(isSome(some(1)), true)\n * assert.deepStrictEqual(isSome(none()), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isSome: <A>(self: Option<A>) => self is Some<A> = option.isSome\n\n/**\n * Matches the given `Option` and returns either the provided `onNone` value or the result of the provided `onSome`\n * function when passed the `Option`'s value.\n *\n * @param self - The `Option` to match\n * @param onNone - The value to be returned if the `Option` is `None`\n * @param onSome - The function to be called if the `Option` is `Some`, it will be passed the `Option`'s value and its result will be returned\n *\n * @example\n * import { some, none, match } from 'effect/Option'\n * import { pipe } from \"effect/Function\"\n *\n * assert.deepStrictEqual(\n *   pipe(some(1), match({ onNone: () => 'a none', onSome: (a) => `a some containing ${a}` })),\n *   'a some containing 1'\n * )\n *\n * assert.deepStrictEqual(\n *   pipe(none(), match({ onNone: () => 'a none', onSome: (a) => `a some containing ${a}` })),\n *   'a none'\n * )\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport const match: {\n  <B, A, C = B>(options: {\n    readonly onNone: LazyArg<B>\n    readonly onSome: (a: A) => C\n  }): (self: Option<A>) => B | C\n  <A, B, C = B>(self: Option<A>, options: {\n    readonly onNone: LazyArg<B>\n    readonly onSome: (a: A) => C\n  }): B | C\n} = dual(\n  2,\n  <A, B, C = B>(self: Option<A>, { onNone, onSome }: {\n    readonly onNone: LazyArg<B>\n    readonly onSome: (a: A) => C\n  }): B | C => isNone(self) ? onNone() : onSome(self.value)\n)\n\n/**\n * Returns a type guard from a `Option` returning function.\n * This function ensures that a type guard definition is type-safe.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * const parsePositive = (n: number): O.Option<number> =>\n *   n > 0 ? O.some(n) : O.none()\n *\n * const isPositive = O.toRefinement(parsePositive)\n *\n * assert.deepStrictEqual(isPositive(1), true)\n * assert.deepStrictEqual(isPositive(-1), false)\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const toRefinement = <A, B extends A>(f: (a: A) => Option<B>): (a: A) => a is B => (a: A): a is B => isSome(f(a))\n\n/**\n * Converts an `Iterable` of values into an `Option`. Returns the first value of the `Iterable` wrapped in a `Some`\n * if the `Iterable` is not empty, otherwise returns `None`.\n *\n * @param collection - The `Iterable` to be converted to an `Option`.\n *\n * @example\n * import { fromIterable, some, none } from 'effect/Option'\n *\n * assert.deepStrictEqual(fromIterable([1, 2, 3]), some(1))\n * assert.deepStrictEqual(fromIterable([]), none())\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromIterable = <A>(collection: Iterable<A>): Option<A> => {\n  for (const a of collection) {\n    return some(a)\n  }\n  return none()\n}\n\n/**\n * Converts a `Either` to an `Option` discarding the error.\n *\n * Alias of {@link fromEither}.\n *\n * @example\n * import * as O from \"effect/Option\"\n * import * as E from \"effect/Either\"\n *\n * assert.deepStrictEqual(O.getRight(E.right('ok')), O.some('ok'))\n * assert.deepStrictEqual(O.getRight(E.left('err')), O.none())\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const getRight: <R, L>(self: Either<R, L>) => Option<R> = either.getRight\n\n/**\n * Converts a `Either` to an `Option` discarding the value.\n *\n * @example\n * import * as O from \"effect/Option\"\n * import * as E from \"effect/Either\"\n *\n * assert.deepStrictEqual(O.getLeft(E.right(\"ok\")), O.none())\n * assert.deepStrictEqual(O.getLeft(E.left(\"a\")), O.some(\"a\"))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const getLeft: <R, L>(self: Either<R, L>) => Option<L> = either.getLeft\n\n/**\n * Returns the value of the `Option` if it is `Some`, otherwise returns `onNone`\n *\n * @param self - The `Option` to get the value of.\n * @param onNone - Function that returns the default value to return if the `Option` is `None`.\n *\n * @example\n * import { some, none, getOrElse } from 'effect/Option'\n * import { pipe } from \"effect/Function\"\n *\n * assert.deepStrictEqual(pipe(some(1), getOrElse(() => 0)), 1)\n * assert.deepStrictEqual(pipe(none(), getOrElse(() => 0)), 0)\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrElse: {\n  <B>(onNone: LazyArg<B>): <A>(self: Option<A>) => B | A\n  <A, B>(self: Option<A>, onNone: LazyArg<B>): A | B\n} = dual(\n  2,\n  <A, B>(self: Option<A>, onNone: LazyArg<B>): A | B => isNone(self) ? onNone() : self.value\n)\n\n/**\n * Returns the provided `Option` `that` if `self` is `None`, otherwise returns `self`.\n *\n * @param self - The first `Option` to be checked.\n * @param that - The `Option` to return if `self` is `None`.\n *\n * @example\n * import * as O from \"effect/Option\"\n * import { pipe } from \"effect/Function\"\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none(),\n *     O.orElse(() => O.none())\n *   ),\n *   O.none()\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some('a'),\n *     O.orElse(() => O.none())\n *   ),\n *   O.some('a')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none(),\n *     O.orElse(() => O.some('b'))\n *   ),\n *   O.some('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some('a'),\n *     O.orElse(() => O.some('b'))\n *   ),\n *   O.some('a')\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport const orElse: {\n  <B>(that: LazyArg<Option<B>>): <A>(self: Option<A>) => Option<B | A>\n  <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<A | B>\n} = dual(\n  2,\n  <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<A | B> => isNone(self) ? that() : self\n)\n\n/**\n * Returns the provided default value as `Some` if `self` is `None`, otherwise returns `self`.\n *\n * @param self - The first `Option` to be checked.\n * @param onNone - Function that returns the default value to return if the `Option` is `None`.\n *\n * @example\n * import * as O from \"effect/Option\"\n * import { pipe } from \"effect/Function\"\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none(),\n *     O.orElseSome(() => 'b')\n *   ),\n *   O.some('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some('a'),\n *     O.orElseSome(() => 'b')\n *   ),\n *   O.some('a')\n * )\n *\n * @category error handling\n * @since 2.0.0\n */\nexport const orElseSome: {\n  <B>(onNone: LazyArg<B>): <A>(self: Option<A>) => Option<B | A>\n  <A, B>(self: Option<A>, onNone: LazyArg<B>): Option<A | B>\n} = dual(\n  2,\n  <A, B>(self: Option<A>, onNone: LazyArg<B>): Option<A | B> => isNone(self) ? some(onNone()) : self\n)\n\n/**\n * Similar to `orElse`, but instead of returning a simple union, it returns an `Either` object,\n * which contains information about which of the two `Option`s has been chosen.\n *\n * This is useful when it's important to know whether the value was retrieved from the first `Option` or the second option.\n *\n * @param self - The first `Option` to be checked.\n * @param that - The second `Option` to be considered if the first `Option` is `None`.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport const orElseEither: {\n  <B>(that: LazyArg<Option<B>>): <A>(self: Option<A>) => Option<Either<B, A>>\n  <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<Either<B, A>>\n} = dual(\n  2,\n  <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<Either<B, A>> =>\n    isNone(self) ? map(that(), either.right) : map(self, either.left)\n)\n\n/**\n * Given an `Iterable` collection of `Option`s, returns the first `Some` found in the collection.\n *\n * @param collection - An iterable collection of `Option` to be searched.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * assert.deepStrictEqual(O.firstSomeOf([O.none(), O.some(1), O.some(2)]), O.some(1))\n *\n * @category error handling\n * @since 2.0.0\n */\nexport const firstSomeOf = <A>(collection: Iterable<Option<A>>): Option<A> => {\n  let out: Option<A> = none()\n  for (out of collection) {\n    if (isSome(out)) {\n      return out\n    }\n  }\n  return out\n}\n\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`.\n *\n * @param nullableValue - The nullable value to be converted to an `Option`.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * assert.deepStrictEqual(O.fromNullable(undefined), O.none())\n * assert.deepStrictEqual(O.fromNullable(null), O.none())\n * assert.deepStrictEqual(O.fromNullable(1), O.some(1))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const fromNullable = <A>(\n  nullableValue: A\n): Option<\n  NonNullable<A>\n> => (nullableValue == null ? none() : some(nullableValue as NonNullable<A>))\n\n/**\n * This API is useful for lifting a function that returns `null` or `undefined` into the `Option` context.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * const parse = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const parseOption = O.liftNullable(parse)\n *\n * assert.deepStrictEqual(parseOption('1'), O.some(1))\n * assert.deepStrictEqual(parseOption('not a number'), O.none())\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const liftNullable = <A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => B | null | undefined\n): (...a: A) => Option<NonNullable<B>> =>\n(...a) => fromNullable(f(...a))\n\n/**\n * Returns the value of the `Option` if it is a `Some`, otherwise returns `null`.\n *\n * @param self - The `Option` to extract the value from.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * assert.deepStrictEqual(O.getOrNull(O.some(1)), 1)\n * assert.deepStrictEqual(O.getOrNull(O.none()), null)\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrNull: <A>(self: Option<A>) => A | null = getOrElse(constNull)\n\n/**\n * Returns the value of the `Option` if it is a `Some`, otherwise returns `undefined`.\n *\n * @param self - The `Option` to extract the value from.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * assert.deepStrictEqual(O.getOrUndefined(O.some(1)), 1)\n * assert.deepStrictEqual(O.getOrUndefined(O.none()), undefined)\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrUndefined: <A>(self: Option<A>) => A | undefined = getOrElse(constUndefined)\n\n/**\n * A utility function that lifts a function that throws exceptions into a function that returns an `Option`.\n *\n * This function is useful for any function that might throw an exception, allowing the developer to handle\n * the exception in a more functional way.\n *\n * @param f - the function that can throw exceptions.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * const parse = O.liftThrowable(JSON.parse)\n *\n * assert.deepStrictEqual(parse(\"1\"), O.some(1))\n * assert.deepStrictEqual(parse(\"\"), O.none())\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const liftThrowable = <A extends ReadonlyArray<unknown>, B>(\n  f: (...a: A) => B\n): (...a: A) => Option<B> =>\n(...a) => {\n  try {\n    return some(f(...a))\n  } catch (e) {\n    return none()\n  }\n}\n\n/**\n * Extracts the value of an `Option` or throws if the `Option` is `None`.\n *\n * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.\n *\n * @param self - The `Option` to extract the value from.\n * @param onNone - A function that will be called if the `Option` is `None`. It returns the error to be thrown.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * assert.deepStrictEqual(\n *   O.getOrThrowWith(O.some(1), () => new Error('Unexpected None')),\n *   1\n * )\n * assert.throws(() => O.getOrThrowWith(O.none(), () => new Error('Unexpected None')))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const getOrThrowWith: {\n  (onNone: () => unknown): <A>(self: Option<A>) => A\n  <A>(self: Option<A>, onNone: () => unknown): A\n} = dual(2, <A>(self: Option<A>, onNone: () => unknown): A => {\n  if (isSome(self)) {\n    return self.value\n  }\n  throw onNone()\n})\n\n/**\n * Extracts the value of an `Option` or throws if the `Option` is `None`.\n *\n * The thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.\n *\n * @param self - The `Option` to extract the value from.\n * @throws `Error(\"getOrThrow called on a None\")`\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * assert.deepStrictEqual(O.getOrThrow(O.some(1)), 1)\n * assert.throws(() => O.getOrThrow(O.none()))\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const getOrThrow: <A>(self: Option<A>) => A = getOrThrowWith(() => new Error(\"getOrThrow called on a None\"))\n\n/**\n * Maps the `Some` side of an `Option` value to a new `Option` value.\n *\n * @param self - An `Option` to map\n * @param f - The function to map over the value of the `Option`\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const map: {\n  <A, B>(f: (a: A) => B): (self: Option<A>) => Option<B>\n  <A, B>(self: Option<A>, f: (a: A) => B): Option<B>\n} = dual(\n  2,\n  <A, B>(self: Option<A>, f: (a: A) => B): Option<B> => isNone(self) ? none() : some(f(self.value))\n)\n\n/**\n * Maps the `Some` value of this `Option` to the specified constant value.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const as: {\n  <B>(b: B): <X>(self: Option<X>) => Option<B>\n} = dual(2, <X, B>(self: Option<X>, b: B): Option<B> => map(self, () => b))\n\n/**\n * Maps the `Some` value of this `Option` to the `void` constant value.\n *\n * This is useful when the value of the `Option` is not needed, but the presence or absence of the value is important.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const asVoid: <_>(self: Option<_>) => Option<void> = as(undefined)\n\nconst void_: Option<void> = some(undefined)\nexport {\n  /**\n   * @since 2.0.0\n   */\n  void_ as void\n}\n\n/**\n * Applies a function to the value of an `Option` and flattens the result, if the input is `Some`.\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport const flatMap: {\n  <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>\n  <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>\n} = dual(\n  2,\n  <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B> => isNone(self) ? none() : f(self.value)\n)\n\n/**\n * Executes a sequence of two `Option`s. The second `Option` can be dependent on the result of the first `Option`.\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport const andThen: {\n  <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>\n  <B>(f: Option<B>): <A>(self: Option<A>) => Option<B>\n  <A, B>(f: (a: A) => B): (self: Option<A>) => Option<B>\n  <B>(f: NotFunction<B>): <A>(self: Option<A>) => Option<B>\n  <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>\n  <A, B>(self: Option<A>, f: Option<B>): Option<B>\n  <A, B>(self: Option<A>, f: (a: A) => B): Option<B>\n  <A, B>(self: Option<A>, f: NotFunction<B>): Option<B>\n} = dual(\n  2,\n  <A, B>(self: Option<A>, f: (a: A) => Option<B> | Option<B>): Option<B> =>\n    flatMap(self, (a) => {\n      const b = isFunction(f) ? f(a) : f\n      return isOption(b) ? b : some(b)\n    })\n)\n\n/**\n * This is `flatMap` + `fromNullable`, useful when working with optional values.\n *\n * @example\n * import { some, none, flatMapNullable } from 'effect/Option'\n * import { pipe } from \"effect/Function\"\n *\n * interface Employee {\n *   company?: {\n *     address?: {\n *       street?: {\n *         name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     some(employee1),\n *     flatMapNullable(employee => employee.company?.address?.street?.name),\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     some(employee2),\n *     flatMapNullable(employee => employee.company?.address?.street?.name),\n *   ),\n *   none()\n * )\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport const flatMapNullable: {\n  <A, B>(f: (a: A) => B | null | undefined): (self: Option<A>) => Option<NonNullable<B>>\n  <A, B>(self: Option<A>, f: (a: A) => B | null | undefined): Option<NonNullable<B>>\n} = dual(\n  2,\n  <A, B>(self: Option<A>, f: (a: A) => B | null | undefined): Option<NonNullable<B>> =>\n    isNone(self) ? none() : fromNullable(f(self.value))\n)\n\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport const flatten: <A>(self: Option<Option<A>>) => Option<A> = flatMap(identity)\n\n/**\n * @category zipping\n * @since 2.0.0\n */\nexport const zipRight: {\n  <B>(that: Option<B>): <_>(self: Option<_>) => Option<B>\n  <X, B>(self: Option<X>, that: Option<B>): Option<B>\n} = dual(2, <X, B>(self: Option<X>, that: Option<B>): Option<B> => flatMap(self, () => that))\n\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport const composeK: {\n  <B, C>(bfc: (b: B) => Option<C>): <A>(afb: (a: A) => Option<B>) => (a: A) => Option<C>\n  <A, B, C>(afb: (a: A) => Option<B>, bfc: (b: B) => Option<C>): (a: A) => Option<C>\n} = dual(2, <A, B, C>(afb: (a: A) => Option<B>, bfc: (b: B) => Option<C>) => (a: A): Option<C> => flatMap(afb(a), bfc))\n\n/**\n * Sequences the specified `that` `Option` but ignores its value.\n *\n * It is useful when we want to chain multiple operations, but only care about the result of `self`.\n *\n * @param that - The `Option` that will be ignored in the chain and discarded\n * @param self - The `Option` we care about\n *\n * @category zipping\n * @since 2.0.0\n */\nexport const zipLeft: {\n  <_>(that: Option<_>): <A>(self: Option<A>) => Option<A>\n  <A, X>(self: Option<A>, that: Option<X>): Option<A>\n} = dual(2, <A, X>(self: Option<A>, that: Option<X>): Option<A> => tap(self, () => that))\n\n/**\n * Applies the provided function `f` to the value of the `Option` if it is `Some` and returns the original `Option`\n * unless `f` returns `None`, in which case it returns `None`.\n *\n * This function is useful for performing additional computations on the value of the input `Option` without affecting its value.\n *\n * @param f - Function to apply to the value of the `Option` if it is `Some`\n * @param self - The `Option` to apply the function to\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * const getInteger = (n: number) => Number.isInteger(n) ? O.some(n) : O.none()\n *\n * assert.deepStrictEqual(O.tap(O.none(), getInteger), O.none())\n * assert.deepStrictEqual(O.tap(O.some(1), getInteger), O.some(1))\n * assert.deepStrictEqual(O.tap(O.some(1.14), getInteger), O.none())\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport const tap: {\n  <A, X>(f: (a: A) => Option<X>): (self: Option<A>) => Option<A>\n  <A, X>(self: Option<A>, f: (a: A) => Option<X>): Option<A>\n} = dual(2, <A, X>(self: Option<A>, f: (a: A) => Option<X>): Option<A> => flatMap(self, (a) => map(f(a), () => a)))\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const product = <A, B>(self: Option<A>, that: Option<B>): Option<[A, B]> =>\n  isSome(self) && isSome(that) ? some([self.value, that.value]) : none()\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const productMany = <A>(\n  self: Option<A>,\n  collection: Iterable<Option<A>>\n): Option<[A, ...Array<A>]> => {\n  if (isNone(self)) {\n    return none()\n  }\n  const out: [A, ...Array<A>] = [self.value]\n  for (const o of collection) {\n    if (isNone(o)) {\n      return none()\n    }\n    out.push(o.value)\n  }\n  return some(out)\n}\n\n/**\n * Takes a structure of `Option`s and returns an `Option` of values with the same structure.\n *\n * - If a tuple is supplied, then the returned `Option` will contain a tuple with the same length.\n * - If a struct is supplied, then the returned `Option` will contain a struct with the same keys.\n * - If an iterable is supplied, then the returned `Option` will contain an array.\n *\n * @param fields - the struct of `Option`s to be sequenced.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * assert.deepStrictEqual(O.all([O.some(1), O.some(2)]), O.some([1, 2]))\n * assert.deepStrictEqual(O.all({ a: O.some(1), b: O.some(\"hello\") }), O.some({ a: 1, b: \"hello\" }))\n * assert.deepStrictEqual(O.all({ a: O.some(1), b: O.none() }), O.none())\n *\n * @category combining\n * @since 2.0.0\n */\n// @ts-expect-error\nexport const all: <const I extends Iterable<Option<any>> | Record<string, Option<any>>>(\n  input: I\n) => [I] extends [ReadonlyArray<Option<any>>] ? Option<\n    { -readonly [K in keyof I]: [I[K]] extends [Option<infer A>] ? A : never }\n  >\n  : [I] extends [Iterable<Option<infer A>>] ? Option<Array<A>>\n  : Option<{ -readonly [K in keyof I]: [I[K]] extends [Option<infer A>] ? A : never }> = (\n    input: Iterable<Option<any>> | Record<string, Option<any>>\n  ): Option<any> => {\n    if (Symbol.iterator in input) {\n      const out: Array<Option<any>> = []\n      for (const o of (input as Iterable<Option<any>>)) {\n        if (isNone(o)) {\n          return none()\n        }\n        out.push(o.value)\n      }\n      return some(out)\n    }\n\n    const out: Record<string, any> = {}\n    for (const key of Object.keys(input)) {\n      const o = input[key]\n      if (isNone(o)) {\n        return none()\n      }\n      out[key] = o.value\n    }\n    return some(out)\n  }\n\n/**\n * Zips two `Option` values together using a provided function, returning a new `Option` of the result.\n *\n * @param self - The left-hand side of the zip operation\n * @param that - The right-hand side of the zip operation\n * @param f - The function used to combine the values of the two `Option`s\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * type Complex = [real: number, imaginary: number]\n *\n * const complex = (real: number, imaginary: number): Complex => [real, imaginary]\n *\n * assert.deepStrictEqual(O.zipWith(O.none(), O.none(), complex), O.none())\n * assert.deepStrictEqual(O.zipWith(O.some(1), O.none(), complex), O.none())\n * assert.deepStrictEqual(O.zipWith(O.none(), O.some(1), complex), O.none())\n * assert.deepStrictEqual(O.zipWith(O.some(1), O.some(2), complex), O.some([1, 2]))\n *\n * assert.deepStrictEqual(O.zipWith(O.some(1), complex)(O.some(2)), O.some([2, 1]))\n *\n * @category zipping\n * @since 2.0.0\n */\nexport const zipWith: {\n  <B, A, C>(that: Option<B>, f: (a: A, b: B) => C): (self: Option<A>) => Option<C>\n  <A, B, C>(self: Option<A>, that: Option<B>, f: (a: A, b: B) => C): Option<C>\n} = dual(\n  3,\n  <A, B, C>(self: Option<A>, that: Option<B>, f: (a: A, b: B) => C): Option<C> =>\n    map(product(self, that), ([a, b]) => f(a, b))\n)\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const ap: {\n  <A>(that: Option<A>): <B>(self: Option<(a: A) => B>) => Option<B>\n  <A, B>(self: Option<(a: A) => B>, that: Option<A>): Option<B>\n} = dual(2, <A, B>(self: Option<(a: A) => B>, that: Option<A>): Option<B> => zipWith(self, that, (f, a) => f(a)))\n\n/**\n * Reduces an `Iterable` of `Option<A>` to a single value of type `B`, elements that are `None` are ignored.\n *\n * @param self - The Iterable of `Option<A>` to be reduced.\n * @param b - The initial value of the accumulator.\n * @param f - The reducing function that takes the current accumulator value and the unwrapped value of an `Option<A>`.\n *\n * @example\n * import { some, none, reduceCompact } from 'effect/Option'\n * import { pipe } from \"effect/Function\"\n *\n * const iterable = [some(1), none(), some(2), none()]\n * assert.deepStrictEqual(pipe(iterable, reduceCompact(0, (b, a) => b + a)), 3)\n *\n * @category folding\n * @since 2.0.0\n */\nexport const reduceCompact: {\n  <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<Option<A>>) => B\n  <A, B>(self: Iterable<Option<A>>, b: B, f: (b: B, a: A) => B): B\n} = dual(\n  3,\n  <A, B>(self: Iterable<Option<A>>, b: B, f: (b: B, a: A) => B): B => {\n    let out: B = b\n    for (const oa of self) {\n      if (isSome(oa)) {\n        out = f(out, oa.value)\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Transforms an `Option` into an `Array`.\n * If the input is `None`, an empty array is returned.\n * If the input is `Some`, the value is wrapped in an array.\n *\n * @param self - The `Option` to convert to an array.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * assert.deepStrictEqual(O.toArray(O.some(1)), [1])\n * assert.deepStrictEqual(O.toArray(O.none()), [])\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const toArray = <A>(self: Option<A>): Array<A> => isNone(self) ? [] : [self.value]\n\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport const partitionMap: {\n  <A, B, C>(f: (a: A) => Either<C, B>): (self: Option<A>) => [left: Option<B>, right: Option<C>]\n  <A, B, C>(self: Option<A>, f: (a: A) => Either<C, B>): [left: Option<B>, right: Option<C>]\n} = dual(2, <A, B, C>(\n  self: Option<A>,\n  f: (a: A) => Either<C, B>\n): [excluded: Option<B>, satisfying: Option<C>] => {\n  if (isNone(self)) {\n    return [none(), none()]\n  }\n  const e = f(self.value)\n  return either.isLeft(e) ? [some(e.left), none()] : [none(), some(e.right)]\n})\n\n/**\n * Maps over the value of an `Option` and filters out `None`s.\n *\n * Useful when in addition to filtering you also want to change the type of the `Option`.\n *\n * @param self - The `Option` to map over.\n * @param f - A function to apply to the value of the `Option`.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * const evenNumber = (n: number) => n % 2 === 0 ? O.some(n) : O.none()\n *\n * assert.deepStrictEqual(O.filterMap(O.none(), evenNumber), O.none())\n * assert.deepStrictEqual(O.filterMap(O.some(3), evenNumber), O.none())\n * assert.deepStrictEqual(O.filterMap(O.some(2), evenNumber), O.some(2))\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const filterMap: {\n  <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>\n  <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>\n} = dual(\n  2,\n  <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B> => isNone(self) ? none() : f(self.value)\n)\n\n/**\n * Filters an `Option` using a predicate. If the predicate is not satisfied or the `Option` is `None` returns `None`.\n *\n * If you need to change the type of the `Option` in addition to filtering, see `filterMap`.\n *\n * @param predicate - A predicate function to apply to the `Option` value.\n * @param fb - The `Option` to filter.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * // predicate\n * const isEven = (n: number) => n % 2 === 0\n *\n * assert.deepStrictEqual(O.filter(O.none(), isEven), O.none())\n * assert.deepStrictEqual(O.filter(O.some(3), isEven), O.none())\n * assert.deepStrictEqual(O.filter(O.some(2), isEven), O.some(2))\n *\n * // refinement\n * const isNumber = (v: unknown): v is number => typeof v === \"number\"\n *\n * assert.deepStrictEqual(O.filter(O.none(), isNumber), O.none())\n * assert.deepStrictEqual(O.filter(O.some('hello'), isNumber), O.none())\n * assert.deepStrictEqual(O.filter(O.some(2), isNumber), O.some(2))\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const filter: {\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Option<A>) => Option<B>\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Option<A>) => Option<A>\n  <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): Option<B>\n  <A>(self: Option<A>, predicate: Predicate<A>): Option<A>\n} = dual(\n  2,\n  <A>(self: Option<A>, predicate: Predicate<A>): Option<A> =>\n    filterMap(self, (b) => (predicate(b) ? option.some(b) : option.none))\n)\n\n/**\n * @example\n * import { none, some, getEquivalence } from 'effect/Option'\n * import * as N from 'effect/Number'\n *\n * const isEquivalent = getEquivalence(N.Equivalence)\n * assert.deepStrictEqual(isEquivalent(none(), none()), true)\n * assert.deepStrictEqual(isEquivalent(none(), some(1)), false)\n * assert.deepStrictEqual(isEquivalent(some(1), none()), false)\n * assert.deepStrictEqual(isEquivalent(some(1), some(2)), false)\n * assert.deepStrictEqual(isEquivalent(some(1), some(1)), true)\n *\n * @category equivalence\n * @since 2.0.0\n */\nexport const getEquivalence = <A>(isEquivalent: Equivalence.Equivalence<A>): Equivalence.Equivalence<Option<A>> =>\n  Equivalence.make((x, y) => x === y || (isNone(x) ? isNone(y) : isNone(y) ? false : isEquivalent(x.value, y.value)))\n\n/**\n * The `Order` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Order` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n * @example\n * import { none, some, getOrder } from 'effect/Option'\n * import * as N from 'effect/Number'\n * import { pipe } from \"effect/Function\"\n *\n * const O = getOrder(N.Order)\n * assert.deepStrictEqual(O(none(), none()), 0)\n * assert.deepStrictEqual(O(none(), some(1)), -1)\n * assert.deepStrictEqual(O(some(1), none()), 1)\n * assert.deepStrictEqual(O(some(1), some(2)), -1)\n * assert.deepStrictEqual(O(some(1), some(1)), 0)\n *\n * @category sorting\n * @since 2.0.0\n */\nexport const getOrder = <A>(O: Order<A>): Order<Option<A>> =>\n  order.make((self, that) => isSome(self) ? (isSome(that) ? O(self.value, that.value) : 1) : -1)\n\n/**\n * Lifts a binary function into `Option`.\n *\n * @param f - The function to lift.\n *\n * @category lifting\n * @since 2.0.0\n */\nexport const lift2 = <A, B, C>(f: (a: A, b: B) => C): {\n  (that: Option<B>): (self: Option<A>) => Option<C>\n  (self: Option<A>, that: Option<B>): Option<C>\n} => dual(2, (self: Option<A>, that: Option<B>): Option<C> => zipWith(self, that, f))\n\n/**\n * Transforms a `Predicate` function into a `Some` of the input value if the predicate returns `true` or `None`\n * if the predicate returns `false`.\n *\n * @param predicate - A `Predicate` function that takes in a value of type `A` and returns a boolean.\n *\n * @example\n * import * as O from \"effect/Option\"\n *\n * const getOption = O.liftPredicate((n: number) => n >= 0)\n *\n * assert.deepStrictEqual(getOption(-1), O.none())\n * assert.deepStrictEqual(getOption(1), O.some(1))\n *\n * @category lifting\n * @since 2.0.0\n */\nexport const liftPredicate: { // Note: I intentionally avoid using the NoInfer pattern here.\n  <A, B extends A>(refinement: Refinement<A, B>): (a: A) => Option<B>\n  <B extends A, A = B>(predicate: Predicate<A>): (b: B) => Option<B>\n} = <B extends A, A = B>(predicate: Predicate<A>) => (b: B): Option<B> => predicate(b) ? some(b) : none()\n\n/**\n * Returns a function that checks if a `Option` contains a given value using a provided `isEquivalent` function.\n *\n * @param equivalent - An `Equivalence` instance to compare values of the `Option`.\n * @param self - The `Option` to apply the comparison to.\n * @param a - The value to compare against the `Option`.\n *\n * @example\n * import { some, none, containsWith } from 'effect/Option'\n * import { Equivalence } from 'effect/Number'\n * import { pipe } from \"effect/Function\"\n *\n * assert.deepStrictEqual(pipe(some(2), containsWith(Equivalence)(2)), true)\n * assert.deepStrictEqual(pipe(some(1), containsWith(Equivalence)(2)), false)\n * assert.deepStrictEqual(pipe(none(), containsWith(Equivalence)(2)), false)\n *\n * @category elements\n * @since 2.0.0\n */\nexport const containsWith = <A>(isEquivalent: (self: A, that: A) => boolean): {\n  (a: A): (self: Option<A>) => boolean\n  (self: Option<A>, a: A): boolean\n} => dual(2, (self: Option<A>, a: A): boolean => isNone(self) ? false : isEquivalent(self.value, a))\n\nconst _equivalence = Equal.equivalence()\n\n/**\n * Returns a function that checks if an `Option` contains a given value using the default `Equivalence`.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const contains: {\n  <A>(a: A): (self: Option<A>) => boolean\n  <A>(self: Option<A>, a: A): boolean\n} = containsWith(_equivalence)\n\n/**\n * Check if a value in an `Option` type meets a certain predicate.\n *\n * @param self - The `Option` to check.\n * @param predicate - The condition to check.\n *\n * @example\n * import { some, none, exists } from 'effect/Option'\n * import { pipe } from \"effect/Function\"\n *\n * const isEven = (n: number) => n % 2 === 0\n *\n * assert.deepStrictEqual(pipe(some(2), exists(isEven)), true)\n * assert.deepStrictEqual(pipe(some(1), exists(isEven)), false)\n * assert.deepStrictEqual(pipe(none(), exists(isEven)), false)\n *\n * @since 2.0.0\n */\nexport const exists: {\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Option<A>) => self is Option<B>\n  <A>(predicate: Predicate<NoInfer<A>>): (self: Option<A>) => boolean\n  <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): self is Option<B>\n  <A>(self: Option<A>, predicate: Predicate<A>): boolean\n} = dual(\n  2,\n  <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): self is Option<B> =>\n    isNone(self) ? false : refinement(self.value)\n)\n\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n\n/**\n * @category do notation\n * @since 2.0.0\n */\nexport const bindTo: {\n  <N extends string>(name: N): <A>(self: Option<A>) => Option<{ [K in N]: A }>\n  <A, N extends string>(self: Option<A>, name: N): Option<{ [K in N]: A }>\n} = dual(\n  2,\n  <A, N extends string>(self: Option<A>, name: N): Option<{ [K in N]: A }> => map(self, (a) => ({ [name]: a } as any))\n)\n\nconst let_: {\n  <N extends string, A extends object, B>(\n    name: Exclude<N, keyof A>,\n    f: (a: A) => B\n  ): (self: Option<A>) => Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n  <A extends object, N extends string, B>(\n    self: Option<A>,\n    name: Exclude<N, keyof A>,\n    f: (a: A) => B\n  ): Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n} = dual(3, <A extends object, N extends string, B>(\n  self: Option<A>,\n  name: Exclude<N, keyof A>,\n  f: (a: A) => B\n): Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }> =>\n  map(self, (a) => Object.assign({}, a, { [name]: f(a) }) as any))\n\nexport {\n  /**\n   * @category do notation\n   * @since 2.0.0\n   */\n  let_ as let\n}\n\n/**\n * @category do notation\n * @since 2.0.0\n */\nexport const bind: {\n  <N extends string, A extends object, B>(\n    name: Exclude<N, keyof A>,\n    f: (a: A) => Option<B>\n  ): (self: Option<A>) => Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n  <A extends object, N extends string, B>(\n    self: Option<A>,\n    name: Exclude<N, keyof A>,\n    f: (a: A) => Option<B>\n  ): Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }>\n} = dual(3, <A, N extends string, B>(\n  self: Option<A>,\n  name: Exclude<N, keyof A>,\n  f: (a: A) => Option<B>\n): Option<{ [K in keyof A | N]: K extends keyof A ? A[K] : B }> =>\n  flatMap(self, (a) => map(f(a), (b) => Object.assign({}, a, { [name]: b }) as any)))\n\n/**\n * @category do notation\n * @since 2.0.0\n */\nexport const Do: Option<{}> = some({})\n\nconst adapter = Gen.adapter<OptionTypeLambda>()\n\n/**\n * @category generators\n * @since 2.0.0\n */\nexport const gen: Gen.Gen<OptionTypeLambda, Gen.Adapter<OptionTypeLambda>> = (f) => {\n  const iterator = f(adapter)\n  let state: IteratorYieldResult<any> | IteratorReturnResult<any> = iterator.next()\n  if (state.done) {\n    return some(state.value)\n  } else {\n    let current = state.value.value\n    if (isNone(current)) {\n      return current\n    }\n    while (!state.done) {\n      state = iterator.next(current.value)\n      if (!state.done) {\n        current = state.value.value\n        if (isNone(current)) {\n          return current\n        }\n      }\n    }\n    return some(state.value)\n  }\n}\n", "/**\n * @since 2.0.0\n */\n\nimport type * as Either from \"../Either.js\"\nimport * as Equal from \"../Equal.js\"\nimport { dual } from \"../Function.js\"\nimport * as Hash from \"../Hash.js\"\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\"\nimport type { Option } from \"../Option.js\"\nimport { hasProperty } from \"../Predicate.js\"\nimport { EffectPrototype } from \"./effectable.js\"\nimport * as option from \"./option.js\"\n\n/**\n * @internal\n */\nexport const TypeId: Either.TypeId = Symbol.for(\"effect/Either\") as Either.TypeId\n\nconst CommonProto = {\n  ...EffectPrototype,\n  [TypeId]: {\n    _R: (_: never) => _\n  },\n  [NodeInspectSymbol]<L, R>(this: Either.Either<R, L>) {\n    return this.toJSON()\n  },\n  toString<L, R>(this: Either.Left<L, R>) {\n    return format(this.toJSON())\n  }\n}\n\nconst RightProto = Object.assign(Object.create(CommonProto), {\n  _tag: \"Right\",\n  _op: \"Right\",\n  [Equal.symbol]<L, R>(this: Either.Right<L, R>, that: unknown): boolean {\n    return isEither(that) && isRight(that) && Equal.equals(that.right, this.right)\n  },\n  [Hash.symbol]<L, R>(this: Either.Right<L, R>) {\n    return Hash.combine(Hash.hash(this._tag))(Hash.hash(this.right))\n  },\n  toJSON<L, R>(this: Either.Right<L, R>) {\n    return {\n      _id: \"Either\",\n      _tag: this._tag,\n      right: toJSON(this.right)\n    }\n  }\n})\n\nconst LeftProto = Object.assign(Object.create(CommonProto), {\n  _tag: \"Left\",\n  _op: \"Left\",\n  [Equal.symbol]<L, R>(this: Either.Left<L, R>, that: unknown): boolean {\n    return isEither(that) && isLeft(that) && Equal.equals(that.left, this.left)\n  },\n  [Hash.symbol]<L, R>(this: Either.Left<L, R>) {\n    return Hash.combine(Hash.hash(this._tag))(Hash.hash(this.left))\n  },\n  toJSON<E, A>(this: Either.Left<E, A>) {\n    return {\n      _id: \"Either\",\n      _tag: this._tag,\n      left: toJSON(this.left)\n    }\n  }\n})\n\n/** @internal */\nexport const isEither = (input: unknown): input is Either.Either<unknown, unknown> => hasProperty(input, TypeId)\n\n/** @internal */\nexport const isLeft = <R, L>(ma: Either.Either<R, L>): ma is Either.Left<L, R> => ma._tag === \"Left\"\n\n/** @internal */\nexport const isRight = <R, L>(ma: Either.Either<R, L>): ma is Either.Right<L, R> => ma._tag === \"Right\"\n\n/** @internal */\nexport const left = <L>(left: L): Either.Either<never, L> => {\n  const a = Object.create(LeftProto)\n  a.left = left\n  return a\n}\n\n/** @internal */\nexport const right = <R>(right: R): Either.Either<R> => {\n  const a = Object.create(RightProto)\n  a.right = right\n  return a\n}\n\n/** @internal */\nexport const getLeft = <R, L>(\n  self: Either.Either<R, L>\n): Option<L> => (isRight(self) ? option.none : option.some(self.left))\n\n/** @internal */\nexport const getRight = <R, L>(\n  self: Either.Either<R, L>\n): Option<R> => (isLeft(self) ? option.none : option.some(self.right))\n\n/** @internal */\nexport const fromOption: {\n  <L>(onNone: () => L): <R>(self: Option<R>) => Either.Either<R, L>\n  <R, L>(self: Option<R>, onNone: () => L): Either.Either<R, L>\n} = dual(\n  2,\n  <R, L>(self: Option<R>, onNone: () => L): Either.Either<R, L> =>\n    option.isNone(self) ? left(onNone()) : right(self.value)\n)\n"],
  "mappings": "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",
  "names": ["TypeId", "getLeft", "getRight", "isNone", "isOption", "isSome", "none", "some", "TypeId", "Symbol", "for", "CommonProto", "EffectPrototype", "_R", "_", "NodeInspectSymbol", "toJSON", "toString", "format", "RightProto", "Object", "assign", "create", "_tag", "_op", "symbol", "that", "isEither", "isRight", "equals", "right", "combine", "hash", "_id", "LeftProto", "isLeft", "left", "input", "hasProperty", "ma", "a", "getLeft", "self", "none", "some", "getRight", "fromOption", "dual", "onNone", "isNone", "value", "TypeId", "Symbol", "for", "none", "some", "isOption", "isNone", "isSome", "match", "dual", "self", "onNone", "onSome", "value", "toRefinement", "f", "a", "fromIterable", "collection", "getRight", "getLeft", "getOrElse", "orElse", "that", "orElseSome", "orElseEither", "map", "right", "left", "firstSomeOf", "out", "fromNullable", "nullableValue", "liftNullable", "getOrNull", "constNull", "getOrUndefined", "constUndefined", "liftThrowable", "e", "getOrThrowWith", "getOrThrow", "Error", "as", "b", "asVoid", "undefined", "void_", "flatMap", "dual", "self", "f", "isNone", "none", "value", "andThen", "a", "b", "isFunction", "isOption", "some", "flatMapNullable", "fromNullable", "flatten", "identity", "zipRight", "that", "composeK", "afb", "bfc", "zipLeft", "tap", "map", "product", "isSome", "productMany", "collection", "out", "o", "push", "all", "input", "Symbol", "iterator", "key", "Object", "keys", "zipWith", "ap", "reduceCompact", "oa", "toArray", "partitionMap", "e", "isLeft", "left", "right", "filterMap", "filter", "predicate", "getEquivalence", "isEquivalent", "make", "x", "y", "getOrder", "O", "lift2", "liftPredicate", "containsWith", "_equivalence", "equivalence", "contains", "exists", "refinement", "bindTo", "name", "let_", "assign", "bind", "dual", "self", "name", "f", "flatMap", "a", "map", "b", "Object", "assign", "Do", "some", "adapter", "gen", "iterator", "state", "next", "done", "value", "current", "isNone"]
}
