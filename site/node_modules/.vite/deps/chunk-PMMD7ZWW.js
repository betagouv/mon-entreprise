import {
  dual,
  hasProperty,
  identity,
  isFunction2 as isFunction,
  isNullable,
  pipe
} from "./chunk-KURLOJT7.js";
import {
  __export,
  __publicField
} from "./chunk-2LSFTFF7.js";

// ../node_modules/effect/dist/esm/Equivalence.js
var Equivalence_exports = {};
__export(Equivalence_exports, {
  Date: () => Date,
  all: () => all,
  array: () => array,
  bigint: () => bigint,
  boolean: () => boolean,
  combine: () => combine,
  combineAll: () => combineAll,
  combineMany: () => combineMany,
  make: () => make,
  mapInput: () => mapInput,
  number: () => number,
  product: () => product,
  productMany: () => productMany,
  strict: () => strict,
  string: () => string,
  struct: () => struct,
  symbol: () => symbol,
  tuple: () => tuple
});
var make = (isEquivalent) => (self, that) => self === that || isEquivalent(self, that);
var isStrictEquivalent = (x, y) => x === y;
var strict = () => isStrictEquivalent;
var string = strict();
var number = strict();
var boolean = strict();
var bigint = strict();
var symbol = strict();
var combine = dual(2, (self, that) => make((x, y) => self(x, y) && that(x, y)));
var combineMany = dual(2, (self, collection) => make((x, y) => {
  if (!self(x, y)) {
    return false;
  }
  for (const equivalence2 of collection) {
    if (!equivalence2(x, y)) {
      return false;
    }
  }
  return true;
}));
var isAlwaysEquivalent = (_x, _y) => true;
var combineAll = (collection) => combineMany(isAlwaysEquivalent, collection);
var mapInput = dual(2, (self, f) => make((x, y) => self(f(x), f(y))));
var Date = mapInput(number, (date) => date.getTime());
var product = dual(2, (self, that) => make(([xa, xb], [ya, yb]) => self(xa, ya) && that(xb, yb)));
var all = (collection) => {
  return make((x, y) => {
    const len = Math.min(x.length, y.length);
    let collectionLength = 0;
    for (const equivalence2 of collection) {
      if (collectionLength >= len) {
        break;
      }
      if (!equivalence2(x[collectionLength], y[collectionLength])) {
        return false;
      }
      collectionLength++;
    }
    return true;
  });
};
var productMany = (self, collection) => {
  const equivalence2 = all(collection);
  return make((x, y) => !self(x[0], y[0]) ? false : equivalence2(x.slice(1), y.slice(1)));
};
var tuple = (...elements) => all(elements);
var array = (item) => make((self, that) => {
  if (self.length !== that.length) {
    return false;
  }
  for (let i = 0; i < self.length; i++) {
    const isEq = item(self[i], that[i]);
    if (!isEq) {
      return false;
    }
  }
  return true;
});
var struct = (fields) => {
  const keys = Object.keys(fields);
  return make((self, that) => {
    for (const key of keys) {
      if (!fields[key](self[key], that[key])) {
        return false;
      }
    }
    return true;
  });
};

// ../node_modules/effect/dist/esm/GlobalValue.js
var GlobalValue_exports = {};
__export(GlobalValue_exports, {
  globalValue: () => globalValue
});

// ../node_modules/effect/dist/esm/internal/version.js
var moduleVersion = "3.0.1";
var getCurrentVersion = () => moduleVersion;
var setCurrentVersion = (version) => {
  moduleVersion = version;
};

// ../node_modules/effect/dist/esm/GlobalValue.js
var globalStoreId = Symbol.for(`effect/GlobalValue/globalStoreId/${getCurrentVersion()}`);
if (!(globalStoreId in globalThis)) {
  ;
  globalThis[globalStoreId] = /* @__PURE__ */ new Map();
}
var globalStore = globalThis[globalStoreId];
var globalValue = (id, compute) => {
  if (!globalStore.has(id)) {
    globalStore.set(id, compute());
  }
  return globalStore.get(id);
};

// ../node_modules/effect/dist/esm/Utils.js
var Utils_exports = {};
__export(Utils_exports, {
  GenKindImpl: () => GenKindImpl,
  GenKindTypeId: () => GenKindTypeId,
  PCGRandom: () => PCGRandom,
  SingleShotGen: () => SingleShotGen,
  adapter: () => adapter,
  makeGenKind: () => makeGenKind
});
var GenKindTypeId = Symbol.for("effect/Gen/GenKind");
var _a;
var GenKindImpl = class {
  constructor(value) {
    __publicField(this, "value");
    /**
     * @since 2.0.0
     */
    __publicField(this, _a, GenKindTypeId);
    this.value = value;
  }
  /**
   * @since 2.0.0
   */
  get _F() {
    return identity;
  }
  /**
   * @since 2.0.0
   */
  get _R() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _O() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _E() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  [(_a = GenKindTypeId, Symbol.iterator)]() {
    return new SingleShotGen(this);
  }
};
var SingleShotGen = class _SingleShotGen {
  constructor(self) {
    __publicField(this, "self");
    __publicField(this, "called", false);
    this.self = self;
  }
  /**
   * @since 2.0.0
   */
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  /**
   * @since 2.0.0
   */
  throw(e) {
    throw e;
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};
var makeGenKind = (kind) => new GenKindImpl(kind);
var adapter = () => (
  // @ts-expect-error
  function() {
    let x = arguments[0];
    for (let i = 1; i < arguments.length; i++) {
      x = arguments[i](x);
    }
    return new GenKindImpl(x);
  }
);
var defaultIncHi = 335903614;
var defaultIncLo = 4150755663;
var MUL_HI = 1481765933 >>> 0;
var MUL_LO = 1284865837 >>> 0;
var BIT_53 = 9007199254740992;
var BIT_27 = 134217728;
var PCGRandom = class {
  constructor(seedHi, seedLo, incHi, incLo) {
    __publicField(this, "_state");
    if (isNullable(seedLo) && isNullable(seedHi)) {
      seedLo = Math.random() * 4294967295 >>> 0;
      seedHi = 0;
    } else if (isNullable(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if (isNullable(incLo) && isNullable(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo;
      incHi = this._state ? this._state[2] : defaultIncHi;
    } else if (isNullable(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  /**
   * Returns a copy of the internal state of this random number generator as a
   * JavaScript Array.
   *
   * @category getters
   * @since 2.0.0
   */
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  /**
   * Restore state previously retrieved using `getState()`.
   *
   * @since 2.0.0
   */
  setState(state) {
    this._state[0] = state[0];
    this._state[1] = state[1];
    this._state[2] = state[2];
    this._state[3] = state[3] | 1;
  }
  /**
   * Get a uniformly distributed 32 bit integer between [0, max).
   *
   * @category getter
   * @since 2.0.0
   */
  integer(max2) {
    if (!max2) {
      return this._next();
    }
    max2 = max2 >>> 0;
    if ((max2 & max2 - 1) === 0) {
      return this._next() & max2 - 1;
    }
    let num = 0;
    const skew = (-max2 >>> 0) % max2 >>> 0;
    for (num = this._next(); num < skew; num = this._next()) {
    }
    return num % max2;
  }
  /**
   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
   * 53 bits of precision (every bit of the mantissa is randomized).
   *
   * @category getters
   * @since 2.0.0
   */
  number() {
    const hi = (this._next() & 67108863) * 1;
    const lo = (this._next() & 134217727) * 1;
    return (hi * BIT_27 + lo) / BIT_53;
  }
  /** @internal */
  _next() {
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
};
function mul64(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
  let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out[0] = hi;
  out[1] = lo;
}
function add64(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out[0] = hi;
  out[1] = lo;
}

// ../node_modules/effect/dist/esm/Hash.js
var Hash_exports = {};
__export(Hash_exports, {
  array: () => array2,
  cached: () => cached,
  combine: () => combine2,
  hash: () => hash,
  isHash: () => isHash,
  number: () => number2,
  optimize: () => optimize,
  random: () => random,
  string: () => string2,
  structure: () => structure,
  structureKeys: () => structureKeys,
  symbol: () => symbol2
});
var randomHashCache = globalValue(Symbol.for("effect/Hash/randomHashCache"), () => /* @__PURE__ */ new WeakMap());
var pcgr = globalValue(Symbol.for("effect/Hash/pcgr"), () => new PCGRandom());
var symbol2 = Symbol.for("effect/Hash");
var hash = (self) => {
  switch (typeof self) {
    case "number":
      return number2(self);
    case "bigint":
      return string2(self.toString(10));
    case "boolean":
      return string2(String(self));
    case "symbol":
      return string2(String(self));
    case "string":
      return string2(self);
    case "undefined":
      return string2("undefined");
    case "function":
    case "object": {
      if (self === null) {
        return string2("null");
      }
      if (isHash(self)) {
        return self[symbol2]();
      } else {
        return random(self);
      }
    }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
};
var random = (self) => {
  if (!randomHashCache.has(self)) {
    randomHashCache.set(self, number2(pcgr.integer(Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self);
};
var combine2 = (b) => (self) => self * 53 ^ b;
var optimize = (n) => n & 3221225471 | n >>> 1 & 1073741824;
var isHash = (u) => hasProperty(u, symbol2);
var number2 = (n) => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h = n | 0;
  if (h !== n) {
    h ^= n * 4294967295;
  }
  while (n > 4294967295) {
    h ^= n /= 4294967295;
  }
  return optimize(n);
};
var string2 = (str) => {
  let h = 5381, i = str.length;
  while (i) {
    h = h * 33 ^ str.charCodeAt(--i);
  }
  return optimize(h);
};
var structureKeys = (o, keys) => {
  let h = 12289;
  for (let i = 0; i < keys.length; i++) {
    h ^= pipe(string2(keys[i]), combine2(hash(o[keys[i]])));
  }
  return optimize(h);
};
var structure = (o) => structureKeys(o, Object.keys(o));
var array2 = (arr) => {
  let h = 6151;
  for (let i = 0; i < arr.length; i++) {
    h = pipe(h, combine2(hash(arr[i])));
  }
  return optimize(h);
};
var cached = function() {
  if (arguments.length === 1) {
    const self2 = arguments[0];
    return function(hash3) {
      Object.defineProperty(self2, symbol2, {
        value() {
          return hash3;
        },
        enumerable: false
      });
      return hash3;
    };
  }
  const self = arguments[0];
  const hash2 = arguments[1];
  Object.defineProperty(self, symbol2, {
    value() {
      return hash2;
    },
    enumerable: false
  });
  return hash2;
};

// ../node_modules/effect/dist/esm/Equal.js
var Equal_exports = {};
__export(Equal_exports, {
  equals: () => equals,
  equivalence: () => equivalence,
  isEqual: () => isEqual,
  symbol: () => symbol3
});
var symbol3 = Symbol.for("effect/Equal");
function equals() {
  if (arguments.length === 1) {
    return (self) => compareBoth(self, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self, that) {
  if (self === that) {
    return true;
  }
  const selfType = typeof self;
  if (selfType !== typeof that) {
    return false;
  }
  if ((selfType === "object" || selfType === "function") && self !== null && that !== null) {
    if (isEqual(self) && isEqual(that)) {
      return hash(self) === hash(that) && self[symbol3](that);
    }
  }
  return false;
}
var isEqual = (u) => hasProperty(u, symbol3);
var equivalence = () => equals;

// ../node_modules/effect/dist/esm/Inspectable.js
var Inspectable_exports = {};
__export(Inspectable_exports, {
  BaseProto: () => BaseProto,
  Class: () => Class,
  NodeInspectSymbol: () => NodeInspectSymbol,
  format: () => format,
  stringifyCircular: () => stringifyCircular,
  toJSON: () => toJSON,
  toStringUnknown: () => toStringUnknown
});
var NodeInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
var toJSON = (x) => {
  if (hasProperty(x, "toJSON") && isFunction(x["toJSON"]) && x["toJSON"].length === 0) {
    return x.toJSON();
  } else if (Array.isArray(x)) {
    return x.map(toJSON);
  }
  return x;
};
var format = (x) => JSON.stringify(x, null, 2);
var BaseProto = {
  toJSON() {
    return toJSON(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var Class = class {
  /**
   * @since 2.0.0
   */
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  /**
   * @since 2.0.0
   */
  toString() {
    return format(this.toJSON());
  }
};
var toStringUnknown = (u, whitespace = 2) => {
  try {
    return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
  } catch (_) {
    return String(u);
  }
};
var stringifyCircular = (obj, whitespace) => {
  let cache = [];
  const retVal = JSON.stringify(obj, (_key, value) => typeof value === "object" && value !== null ? cache.includes(value) ? void 0 : cache.push(value) && value : value, whitespace);
  cache = void 0;
  return retVal;
};

// ../node_modules/effect/dist/esm/Pipeable.js
var Pipeable_exports = {};
__export(Pipeable_exports, {
  pipeArguments: () => pipeArguments
});
var pipeArguments = (self, args) => {
  switch (args.length) {
    case 1:
      return args[0](self);
    case 2:
      return args[1](args[0](self));
    case 3:
      return args[2](args[1](args[0](self)));
    case 4:
      return args[3](args[2](args[1](args[0](self))));
    case 5:
      return args[4](args[3](args[2](args[1](args[0](self)))));
    case 6:
      return args[5](args[4](args[3](args[2](args[1](args[0](self))))));
    case 7:
      return args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))));
    case 8:
      return args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self))))))));
    case 9:
      return args[8](args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))))));
    default: {
      let ret = self;
      for (let i = 0, len = args.length; i < len; i++) {
        ret = args[i](ret);
      }
      return ret;
    }
  }
};

// ../node_modules/effect/dist/esm/internal/opCodes/effect.js
var OP_ASYNC = "Async";
var OP_COMMIT = "Commit";
var OP_FAILURE = "Failure";
var OP_ON_FAILURE = "OnFailure";
var OP_ON_SUCCESS = "OnSuccess";
var OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
var OP_SUCCESS = "Success";
var OP_SYNC = "Sync";
var OP_TAG = "Tag";
var OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
var OP_WHILE = "While";
var OP_WITH_RUNTIME = "WithRuntime";
var OP_YIELD = "Yield";
var OP_REVERT_FLAGS = "RevertFlags";

// ../node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId = Symbol.for("effect/Effect");
var StreamTypeId = Symbol.for("effect/Stream");
var SinkTypeId = Symbol.for("effect/Sink");
var ChannelTypeId = Symbol.for("effect/Channel");
var effectVariance = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _,
  _V: getCurrentVersion()
};
var sinkVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _L: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var channelVariance = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _
};
var EffectPrototype = {
  [EffectTypeId]: effectVariance,
  [StreamTypeId]: effectVariance,
  [SinkTypeId]: sinkVariance,
  [ChannelTypeId]: channelVariance,
  [symbol3](that) {
    return this === that;
  },
  [symbol2]() {
    return cached(this, random(this));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var StructuralPrototype = {
  [symbol2]() {
    return cached(this, structure(this));
  },
  [symbol3](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!(key in that && equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
var CommitPrototype = {
  ...EffectPrototype,
  _op: OP_COMMIT
};
var StructuralCommitPrototype = {
  ...CommitPrototype,
  ...StructuralPrototype
};
var Base = function() {
  function Base2() {
  }
  Base2.prototype = CommitPrototype;
  return Base2;
}();
var StructuralBase = function() {
  function Base2() {
  }
  Base2.prototype = StructuralCommitPrototype;
  return Base2;
}();

// ../node_modules/effect/dist/esm/internal/option.js
var TypeId = Symbol.for("effect/Option");
var CommonProto = {
  ...EffectPrototype,
  [TypeId]: {
    _A: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var SomeProto = Object.assign(Object.create(CommonProto), {
  _tag: "Some",
  _op: "Some",
  [symbol3](that) {
    return isOption(that) && isSome(that) && equals(that.value, this.value);
  },
  [symbol2]() {
    return cached(this, combine2(hash(this._tag))(hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON(this.value)
    };
  }
});
var NoneHash = hash("None");
var NoneProto = Object.assign(Object.create(CommonProto), {
  _tag: "None",
  _op: "None",
  [symbol3](that) {
    return isOption(that) && isNone(that);
  },
  [symbol2]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
var isOption = (input) => hasProperty(input, TypeId);
var isNone = (fa) => fa._tag === "None";
var isSome = (fa) => fa._tag === "Some";
var none = Object.create(NoneProto);
var some = (value) => {
  const a = Object.create(SomeProto);
  a.value = value;
  return a;
};

// ../node_modules/effect/dist/esm/Order.js
var Order_exports = {};
__export(Order_exports, {
  Date: () => Date2,
  all: () => all2,
  array: () => array3,
  between: () => between,
  bigint: () => bigint2,
  boolean: () => boolean2,
  clamp: () => clamp,
  combine: () => combine3,
  combineAll: () => combineAll2,
  combineMany: () => combineMany2,
  empty: () => empty,
  greaterThan: () => greaterThan,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo,
  lessThan: () => lessThan,
  lessThanOrEqualTo: () => lessThanOrEqualTo,
  make: () => make2,
  mapInput: () => mapInput2,
  max: () => max,
  min: () => min,
  number: () => number3,
  product: () => product2,
  productMany: () => productMany2,
  reverse: () => reverse,
  string: () => string3,
  struct: () => struct2,
  tuple: () => tuple2
});
var make2 = (compare) => (self, that) => self === that ? 0 : compare(self, that);
var string3 = make2((self, that) => self < that ? -1 : 1);
var number3 = make2((self, that) => self < that ? -1 : 1);
var boolean2 = make2((self, that) => self < that ? -1 : 1);
var bigint2 = make2((self, that) => self < that ? -1 : 1);
var reverse = (O) => make2((self, that) => O(that, self));
var combine3 = dual(2, (self, that) => make2((a1, a2) => {
  const out = self(a1, a2);
  if (out !== 0) {
    return out;
  }
  return that(a1, a2);
}));
var combineMany2 = dual(2, (self, collection) => make2((a1, a2) => {
  let out = self(a1, a2);
  if (out !== 0) {
    return out;
  }
  for (const O of collection) {
    out = O(a1, a2);
    if (out !== 0) {
      return out;
    }
  }
  return out;
}));
var empty = () => make2(() => 0);
var combineAll2 = (collection) => combineMany2(empty(), collection);
var mapInput2 = dual(2, (self, f) => make2((b1, b2) => self(f(b1), f(b2))));
var Date2 = mapInput2(number3, (date) => date.getTime());
var product2 = dual(2, (self, that) => make2(([xa, xb], [ya, yb]) => {
  const o = self(xa, ya);
  return o !== 0 ? o : that(xb, yb);
}));
var all2 = (collection) => {
  return make2((x, y) => {
    const len = Math.min(x.length, y.length);
    let collectionLength = 0;
    for (const O of collection) {
      if (collectionLength >= len) {
        break;
      }
      const o = O(x[collectionLength], y[collectionLength]);
      if (o !== 0) {
        return o;
      }
      collectionLength++;
    }
    return 0;
  });
};
var productMany2 = dual(2, (self, collection) => {
  const O = all2(collection);
  return make2((x, y) => {
    const o = self(x[0], y[0]);
    return o !== 0 ? o : O(x.slice(1), y.slice(1));
  });
});
var tuple2 = (...elements) => all2(elements);
var array3 = (O) => make2((self, that) => {
  const aLen = self.length;
  const bLen = that.length;
  const len = Math.min(aLen, bLen);
  for (let i = 0; i < len; i++) {
    const o = O(self[i], that[i]);
    if (o !== 0) {
      return o;
    }
  }
  return number3(aLen, bLen);
});
var struct2 = (fields) => {
  const keys = Object.keys(fields);
  return make2((self, that) => {
    for (const key of keys) {
      const o = fields[key](self[key], that[key]);
      if (o !== 0) {
        return o;
      }
    }
    return 0;
  });
};
var lessThan = (O) => dual(2, (self, that) => O(self, that) === -1);
var greaterThan = (O) => dual(2, (self, that) => O(self, that) === 1);
var lessThanOrEqualTo = (O) => dual(2, (self, that) => O(self, that) !== 1);
var greaterThanOrEqualTo = (O) => dual(2, (self, that) => O(self, that) !== -1);
var min = (O) => dual(2, (self, that) => self === that || O(self, that) < 1 ? self : that);
var max = (O) => dual(2, (self, that) => self === that || O(self, that) > -1 ? self : that);
var clamp = (O) => dual(2, (self, options) => min(O)(options.maximum, max(O)(options.minimum, self)));
var between = (O) => dual(2, (self, options) => !lessThan(O)(self, options.minimum) && !greaterThan(O)(self, options.maximum));

export {
  make,
  string,
  number,
  boolean,
  bigint,
  symbol,
  mapInput,
  tuple,
  array,
  struct,
  Equivalence_exports,
  getCurrentVersion,
  setCurrentVersion,
  globalValue,
  GlobalValue_exports,
  adapter,
  PCGRandom,
  Utils_exports,
  symbol2,
  hash,
  random,
  combine2 as combine,
  number2,
  string2,
  structure,
  array2,
  cached,
  Hash_exports,
  symbol3,
  equals,
  isEqual,
  equivalence,
  Equal_exports,
  NodeInspectSymbol,
  toJSON,
  format,
  toStringUnknown,
  stringifyCircular,
  Inspectable_exports,
  pipeArguments,
  Pipeable_exports,
  OP_ASYNC,
  OP_COMMIT,
  OP_FAILURE,
  OP_ON_FAILURE,
  OP_ON_SUCCESS,
  OP_ON_SUCCESS_AND_FAILURE,
  OP_SUCCESS,
  OP_SYNC,
  OP_TAG,
  OP_UPDATE_RUNTIME_FLAGS,
  OP_WHILE,
  OP_WITH_RUNTIME,
  OP_YIELD,
  OP_REVERT_FLAGS,
  EffectTypeId,
  StreamTypeId,
  SinkTypeId,
  ChannelTypeId,
  effectVariance,
  EffectPrototype,
  StructuralPrototype,
  CommitPrototype,
  StructuralCommitPrototype,
  Base,
  StructuralBase,
  isOption,
  isNone,
  isSome,
  none,
  some,
  make2,
  string3,
  number3,
  boolean2,
  bigint2,
  combineAll2 as combineAll,
  mapInput2,
  tuple2,
  array3,
  struct2,
  lessThan,
  greaterThan,
  lessThanOrEqualTo,
  greaterThanOrEqualTo,
  min,
  max,
  clamp,
  between,
  Order_exports
};
//# sourceMappingURL=chunk-PMMD7ZWW.js.map
