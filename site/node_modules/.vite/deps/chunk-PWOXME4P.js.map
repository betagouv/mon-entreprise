{
  "version": 3,
  "sources": ["../../../../node_modules/effect/src/Record.ts", "../../../../node_modules/effect/src/Either.ts"],
  "sourcesContent": ["/**\n * This module provides utility functions for working with records in TypeScript.\n *\n * @since 2.0.0\n */\n\nimport type { Either } from \"./Either.js\"\nimport * as E from \"./Either.js\"\nimport * as Equal from \"./Equal.js\"\nimport type { Equivalence } from \"./Equivalence.js\"\nimport { dual, identity } from \"./Function.js\"\nimport type { TypeLambda } from \"./HKT.js\"\nimport * as Option from \"./Option.js\"\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport type ReadonlyRecord<in out K extends string | symbol, out A> = {\n  readonly [P in K]: A\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace ReadonlyRecord {\n  type IsFiniteString<T extends string> = T extends \"\" ? true :\n    [T] extends [`${infer Head}${infer Rest}`]\n      ? string extends Head ? false : `${number}` extends Head ? false : Rest extends \"\" ? true : IsFiniteString<Rest>\n    : false\n\n  /**\n   * @since 2.0.0\n   */\n  export type NonLiteralKey<K extends string | symbol> = K extends string ? IsFiniteString<K> extends true ? string : K\n    : symbol\n\n  /**\n   * @since 2.0.0\n   */\n  export type IntersectKeys<K1 extends string, K2 extends string> = [string] extends [K1 | K2] ?\n    NonLiteralKey<K1> & NonLiteralKey<K2>\n    : K1 & K2\n}\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface ReadonlyRecordTypeLambda<K extends string = string> extends TypeLambda {\n  readonly type: ReadonlyRecord<K, this[\"Target\"]>\n}\n\n/**\n * Creates a new, empty record.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const empty = <K extends string | symbol = never, V = never>(): Record<\n  ReadonlyRecord.NonLiteralKey<K>,\n  V\n> => ({} as any)\n\n/**\n * Determine if a record is empty.\n *\n * @param self - record to test for emptiness.\n *\n * @example\n * import { isEmptyRecord } from \"effect/Record\"\n *\n * assert.deepStrictEqual(isEmptyRecord({}), true);\n * assert.deepStrictEqual(isEmptyRecord({ a: 3 }), false);\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isEmptyRecord = <K extends string, A>(self: Record<K, A>): self is Record<K, never> =>\n  keys(self).length === 0\n\n/**\n * Determine if a record is empty.\n *\n * @param self - record to test for emptiness.\n *\n * @example\n * import { isEmptyReadonlyRecord } from \"effect/Record\"\n *\n * assert.deepStrictEqual(isEmptyReadonlyRecord({}), true);\n * assert.deepStrictEqual(isEmptyReadonlyRecord({ a: 3 }), false);\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isEmptyReadonlyRecord: <K extends string, A>(\n  self: ReadonlyRecord<K, A>\n) => self is ReadonlyRecord<K, never> = isEmptyRecord\n\n/**\n * Takes an iterable and a projection function and returns a record.\n * The projection function maps each value of the iterable to a tuple of a key and a value, which is then added to the resulting record.\n *\n * @param self - An iterable of values to be mapped to a record.\n * @param f - A projection function that maps values of the iterable to a tuple of a key and a value.\n *\n * @example\n * import { fromIterableWith } from \"effect/Record\"\n *\n * const input = [1, 2, 3, 4]\n *\n * assert.deepStrictEqual(\n *   fromIterableWith(input, a => [String(a), a * 2]),\n *   { '1': 2, '2': 4, '3': 6, '4': 8 }\n * )\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromIterableWith: {\n  <A, K extends string | symbol, B>(\n    f: (a: A) => readonly [K, B]\n  ): (self: Iterable<A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>\n  <A, K extends string | symbol, B>(\n    self: Iterable<A>,\n    f: (a: A) => readonly [K, B]\n  ): Record<ReadonlyRecord.NonLiteralKey<K>, B>\n} = dual(\n  2,\n  <A, K extends string, B>(\n    self: Iterable<A>,\n    f: (a: A) => readonly [K, B]\n  ): Record<ReadonlyRecord.NonLiteralKey<K>, B> => {\n    const out: Record<string, B> = empty()\n    for (const a of self) {\n      const [k, b] = f(a)\n      out[k] = b\n    }\n    return out\n  }\n)\n\n/**\n * Creates a new record from an iterable, utilizing the provided function to determine the key for each element.\n *\n * @param items - An iterable containing elements.\n * @param f - A function that extracts the key for each element.\n *\n * @example\n * import { fromIterableBy } from \"effect/Record\"\n *\n * const users = [\n *   { id: \"2\", name: \"name2\" },\n *   { id: \"1\", name: \"name1\" }\n * ]\n *\n * assert.deepStrictEqual(\n *   fromIterableBy(users, user => user.id),\n *   {\n *     \"2\": { id: \"2\", name: \"name2\" },\n *     \"1\": { id: \"1\", name: \"name1\" }\n *   }\n * )\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromIterableBy = <A, K extends string | symbol>(\n  items: Iterable<A>,\n  f: (a: A) => K\n): Record<ReadonlyRecord.NonLiteralKey<K>, A> => fromIterableWith(items, (a) => [f(a), a])\n\n/**\n * Builds a record from an iterable of key-value pairs.\n *\n * If there are conflicting keys when using `fromEntries`, the last occurrence of the key/value pair will overwrite the\n * previous ones. So the resulting record will only have the value of the last occurrence of each key.\n *\n * @param self - The iterable of key-value pairs.\n *\n * @example\n * import { fromEntries } from \"effect/Record\"\n *\n * const input: Array<[string, number]> = [[\"a\", 1], [\"b\", 2]]\n *\n * assert.deepStrictEqual(fromEntries(input), { a: 1, b: 2 })\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromEntries: <Entry extends readonly [string | symbol, any]>(\n  entries: Iterable<Entry>\n) => Record<ReadonlyRecord.NonLiteralKey<Entry[0]>, Entry[1]> = Object.fromEntries\n\n/**\n * Transforms the values of a record into an `Array` with a custom mapping function.\n *\n * @param self - The record to transform.\n * @param f - The custom mapping function to apply to each key/value of the record.\n *\n * @example\n * import { collect } from \"effect/Record\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * assert.deepStrictEqual(collect(x, (key, n) => [key, n]), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const collect: {\n  <K extends string, A, B>(f: (key: K, a: A) => B): (self: ReadonlyRecord<K, A>) => Array<B>\n  <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (key: K, a: A) => B): Array<B>\n} = dual(\n  2,\n  <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (key: K, a: A) => B): Array<B> => {\n    const out: Array<B> = []\n    for (const key of keys(self)) {\n      out.push(f(key, self[key]))\n    }\n    return out\n  }\n)\n\n/**\n * Takes a record and returns an array of tuples containing its keys and values.\n *\n * @param self - The record to transform.\n *\n * @example\n * import { toEntries } from \"effect/Record\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * assert.deepStrictEqual(toEntries(x), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const toEntries: <K extends string, A>(self: ReadonlyRecord<K, A>) => Array<[K, A]> = collect((\n  key,\n  value\n) => [key, value])\n\n/**\n * Returns the number of key/value pairs in a record.\n *\n * @param self - A record to calculate the number of key/value pairs in.\n *\n * @example\n * import { size } from \"effect/Record\";\n *\n * assert.deepStrictEqual(size({ a: \"a\", b: 1, c: true }), 3);\n *\n * @since 2.0.0\n */\nexport const size = <K extends string, A>(self: ReadonlyRecord<K, A>): number => keys(self).length\n\n/**\n * Check if a given `key` exists in a record.\n *\n * @param self - the record to look in.\n * @param key - the key to look for in the record.\n *\n * @example\n * import { empty, has } from \"effect/Record\"\n *\n * assert.deepStrictEqual(has({ a: 1, b: 2 }, \"a\"), true);\n * assert.deepStrictEqual(has(empty<string>(), \"c\"), false);\n *\n * @since 2.0.0\n */\nexport const has: {\n  <K extends string | symbol>(\n    key: NoInfer<K>\n  ): <A>(self: ReadonlyRecord<K, A>) => boolean\n  <K extends string | symbol, A>(\n    self: ReadonlyRecord<K, A>,\n    key: NoInfer<K>\n  ): boolean\n} = dual(\n  2,\n  <K extends string | symbol, A>(\n    self: ReadonlyRecord<K, A>,\n    key: NoInfer<K>\n  ): boolean => Object.prototype.hasOwnProperty.call(self, key)\n)\n\n/**\n * Retrieve a value at a particular key from a record, returning it wrapped in an `Option`.\n *\n * @param self - The record to retrieve value from.\n * @param key - Key to retrieve from record.\n *\n * @example\n * import { get } from \"effect/Record\"\n * import { some, none } from \"effect/Option\"\n *\n * const person: Record<string, unknown> = { name: \"John Doe\", age: 35 }\n *\n * assert.deepStrictEqual(get(person, \"name\"), some(\"John Doe\"))\n * assert.deepStrictEqual(get(person, \"email\"), none())\n *\n * @since 2.0.0\n */\nexport const get: {\n  <K extends string | symbol>(key: NoInfer<K>): <A>(self: ReadonlyRecord<K, A>) => Option.Option<A>\n  <K extends string | symbol, A>(self: ReadonlyRecord<K, A>, key: NoInfer<K>): Option.Option<A>\n} = dual(\n  2,\n  <K extends string | symbol, A>(self: ReadonlyRecord<K, A>, key: NoInfer<K>): Option.Option<A> =>\n    has(self, key) ? Option.some(self[key]) : Option.none()\n)\n\n/**\n * Apply a function to the element at the specified key, creating a new record.\n * If the key does not exist, the record is returned unchanged.\n *\n * @param self - The record to be updated.\n * @param key - The key of the element to modify.\n * @param f - The function to apply to the element.\n *\n * @example\n * import { modify } from \"effect/Record\"\n * import { some, none } from \"effect/Option\"\n *\n * const f = (x: number) => x * 2\n *\n * assert.deepStrictEqual(\n *  modify({ a: 3 }, 'a', f),\n *  { a: 6 }\n * )\n * assert.deepStrictEqual(\n *  modify({ a: 3 } as Record<string, number>, 'b', f),\n *  { a: 3 }\n * )\n *\n * @since 2.0.0\n */\nexport const modify: {\n  <K extends string | symbol, A, B>(\n    key: NoInfer<K>,\n    f: (a: A) => B\n  ): (self: ReadonlyRecord<K, A>) => Record<K, A | B>\n  <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, f: (a: A) => B): Record<K, A | B>\n} = dual(\n  3,\n  <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, f: (a: A) => B): Record<K, A | B> => {\n    if (!has(self, key)) {\n      return { ...self }\n    }\n    return { ...self, [key]: f(self[key]) }\n  }\n)\n\n/**\n * Apply a function to the element at the specified key, creating a new record,\n * or return `None` if the key doesn't exist.\n *\n * @param self - The record to be updated.\n * @param key - The key of the element to modify.\n * @param f - The function to apply to the element.\n *\n * @example\n * import { modifyOption } from \"effect/Record\"\n * import { some, none } from \"effect/Option\"\n *\n * const f = (x: number) => x * 2\n *\n * assert.deepStrictEqual(\n *  modifyOption({ a: 3 }, 'a', f),\n *  some({ a: 6 })\n * )\n * assert.deepStrictEqual(\n *  modifyOption({ a: 3 } as Record<string, number>, 'b', f),\n *  none()\n * )\n *\n * @since 2.0.0\n */\nexport const modifyOption: {\n  <K extends string | symbol, A, B>(\n    key: NoInfer<K>,\n    f: (a: A) => B\n  ): (self: ReadonlyRecord<K, A>) => Option.Option<Record<K, A | B>>\n  <K extends string | symbol, A, B>(\n    self: ReadonlyRecord<K, A>,\n    key: NoInfer<K>,\n    f: (a: A) => B\n  ): Option.Option<Record<K, A | B>>\n} = dual(\n  3,\n  <K extends string | symbol, A, B>(\n    self: ReadonlyRecord<K, A>,\n    key: NoInfer<K>,\n    f: (a: A) => B\n  ): Option.Option<Record<K, A | B>> => {\n    if (!has(self, key)) {\n      return Option.none()\n    }\n    return Option.some({ ...self, [key]: f(self[key]) })\n  }\n)\n\n/**\n * Replaces a value in the record with the new value passed as parameter.\n *\n * @param self - The record to be updated.\n * @param key - The key to search for in the record.\n * @param b - The new value to replace the existing value with.\n *\n * @example\n * import { empty, replaceOption } from \"effect/Record\"\n * import { some, none } from \"effect/Option\"\n *\n * assert.deepStrictEqual(\n *   replaceOption({ a: 1, b: 2, c: 3 }, 'a', 10),\n *   some({ a: 10, b: 2, c: 3 })\n * )\n * assert.deepStrictEqual(replaceOption(empty<string>(), 'a', 10), none())\n *\n * @since 2.0.0\n */\nexport const replaceOption: {\n  <K extends string | symbol, B>(\n    key: NoInfer<K>,\n    b: B\n  ): <A>(self: ReadonlyRecord<K, A>) => Option.Option<Record<K, A | B>>\n  <K extends string | symbol, A, B>(\n    self: ReadonlyRecord<K, A>,\n    key: NoInfer<K>,\n    b: B\n  ): Option.Option<Record<K, A | B>>\n} = dual(\n  3,\n  <K extends string | symbol, A, B>(\n    self: ReadonlyRecord<K, A>,\n    key: NoInfer<K>,\n    b: B\n  ): Option.Option<Record<K, A | B>> => modifyOption(self, key, () => b)\n)\n\n/**\n * If the given key exists in the record, returns a new record with the key removed,\n * otherwise returns a copy of the original record.\n *\n * @param self - the record to remove the key from.\n * @param key - the key to remove from the record.\n *\n * @example\n * import { remove } from \"effect/Record\"\n *\n * assert.deepStrictEqual(remove({ a: 1, b: 2 }, \"a\"), { b: 2 })\n *\n * @since 2.0.0\n */\nexport const remove: {\n  <K extends string | symbol, X extends K>(key: X): <A>(self: ReadonlyRecord<K, A>) => Record<Exclude<K, X>, A>\n  <K extends string | symbol, A, X extends K>(self: ReadonlyRecord<K, A>, key: X): Record<Exclude<K, X>, A>\n} = dual(\n  2,\n  <K extends string | symbol, A, X extends K>(self: ReadonlyRecord<K, A>, key: X): Record<Exclude<K, X>, A> => {\n    if (!has(self, key)) {\n      return { ...self }\n    }\n    const out = { ...self }\n    delete out[key]\n    return out\n  }\n)\n\n/**\n * Retrieves the value of the property with the given `key` from a record and returns an `Option`\n * of a tuple with the value and the record with the removed property.\n * If the key is not present, returns `O.none`.\n *\n * @param self - The input record.\n * @param key - The key of the property to retrieve.\n *\n * @example\n * import { pop } from \"effect/Record\"\n * import { some, none } from 'effect/Option'\n *\n * assert.deepStrictEqual(pop({ a: 1, b: 2 }, \"a\"), some([1, { b: 2 }]))\n * assert.deepStrictEqual(pop({ a: 1, b: 2 } as Record<string, number>, \"c\"), none())\n *\n * @category record\n * @since 2.0.0\n */\nexport const pop: {\n  <K extends string | symbol, X extends K>(\n    key: X\n  ): <A>(self: ReadonlyRecord<K, A>) => Option.Option<[A, Record<Exclude<K, X>, A>]>\n  <K extends string | symbol, A, X extends K>(\n    self: ReadonlyRecord<K, A>,\n    key: X\n  ): Option.Option<[A, Record<Exclude<K, X>, A>]>\n} = dual(2, <K extends string | symbol, A, X extends K>(\n  self: ReadonlyRecord<K, A>,\n  key: X\n): Option.Option<[A, Record<Exclude<K, X>, A>]> =>\n  has(self, key) ? Option.some([self[key], remove(self, key)]) : Option.none())\n\n/**\n * Maps a record into another record by applying a transformation function to each of its values.\n *\n * @param self - The record to be mapped.\n * @param f - A transformation function that will be applied to each of the values in the record.\n *\n * @example\n * import { map } from \"effect/Record\"\n *\n * const f = (n: number) => `-${n}`\n *\n * assert.deepStrictEqual(map({ a: 3, b: 5 }, f), { a: \"-3\", b: \"-5\" })\n *\n * const g = (n: number, key: string) => `${key.toUpperCase()}-${n}`\n *\n * assert.deepStrictEqual(map({ a: 3, b: 5 }, g), { a: \"A-3\", b: \"B-5\" })\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const map: {\n  <K extends string, A, B>(f: (a: A, key: NoInfer<K>) => B): (self: ReadonlyRecord<K, A>) => Record<K, B>\n  <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: NoInfer<K>) => B): Record<K, B>\n} = dual(\n  2,\n  <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: NoInfer<K>) => B): Record<K, B> => {\n    const out: Record<K, B> = { ...self } as any\n    for (const key of keys(self)) {\n      out[key] = f(self[key], key)\n    }\n    return out\n  }\n)\n\n/**\n * Maps the keys of a `ReadonlyRecord` while preserving the corresponding values.\n *\n * @example\n * import { mapKeys } from \"effect/Record\"\n *\n * assert.deepStrictEqual(mapKeys({ a: 3, b: 5 }, (key) => key.toUpperCase()), { A: 3, B: 5 })\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const mapKeys: {\n  <K extends string, A, K2 extends string>(\n    f: (key: K, a: A) => K2\n  ): (self: ReadonlyRecord<K, A>) => Record<K2, A>\n  <K extends string, A, K2 extends string>(\n    self: ReadonlyRecord<K, A>,\n    f: (key: K, a: A) => K2\n  ): Record<K2, A>\n} = dual(\n  2,\n  <K extends string, A, K2 extends string>(\n    self: ReadonlyRecord<K, A>,\n    f: (key: K, a: A) => K2\n  ): Record<K2, A> => {\n    const out: Record<K2, A> = {} as any\n    for (const key of keys(self)) {\n      const a = self[key]\n      out[f(key, a)] = a\n    }\n    return out\n  }\n)\n\n/**\n * Maps entries of a `ReadonlyRecord` using the provided function, allowing modification of both keys and corresponding values.\n *\n * @example\n * import { mapEntries } from \"effect/Record\"\n *\n * assert.deepStrictEqual(mapEntries({ a: 3, b: 5 }, (a, key) => [key.toUpperCase(), a + 1]), { A: 4, B: 6 })\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const mapEntries: {\n  <K extends string, A, K2 extends string, B>(\n    f: (a: A, key: K) => readonly [K2, B]\n  ): (self: ReadonlyRecord<K, A>) => Record<K2, B>\n  <K extends string, A, K2 extends string, B>(\n    self: ReadonlyRecord<K, A>,\n    f: (a: A, key: K) => [K2, B]\n  ): Record<K2, B>\n} = dual(\n  2,\n  <K extends string, A, K2 extends string, B>(\n    self: ReadonlyRecord<K, A>,\n    f: (a: A, key: K) => [K2, B]\n  ): Record<K2, B> => {\n    const out = <Record<K2, B>> {}\n    for (const key of keys(self)) {\n      const [k, b] = f(self[key], key)\n      out[k] = b\n    }\n    return out\n  }\n)\n\n/**\n * Transforms a record into a record by applying the function `f` to each key and value in the original record.\n * If the function returns `Some`, the key-value pair is included in the output record.\n *\n * @param self - The input record.\n * @param f - The transformation function.\n *\n * @example\n * import { filterMap } from \"effect/Record\"\n * import { some, none } from 'effect/Option'\n *\n * const x = { a: 1, b: 2, c: 3 }\n * const f = (a: number, key: string) => a > 2 ? some(a * 2) : none()\n * assert.deepStrictEqual(filterMap(x, f), { c: 6 })\n *\n * @since 2.0.0\n */\nexport const filterMap: {\n  <K extends string, A, B>(\n    f: (a: A, key: K) => Option.Option<B>\n  ): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>\n  <K extends string, A, B>(\n    self: ReadonlyRecord<K, A>,\n    f: (a: A, key: K) => Option.Option<B>\n  ): Record<ReadonlyRecord.NonLiteralKey<K>, B>\n} = dual(\n  2,\n  <K extends string, A, B>(\n    self: ReadonlyRecord<K, A>,\n    f: (a: A, key: K) => Option.Option<B>\n  ): Record<ReadonlyRecord.NonLiteralKey<K>, B> => {\n    const out: Record<string, B> = empty()\n    for (const key of keys(self)) {\n      const o = f(self[key], key)\n      if (Option.isSome(o)) {\n        out[key] = o.value\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Selects properties from a record whose values match the given predicate.\n *\n * @param self - The record to filter.\n * @param predicate - A function that returns a `boolean` value to determine if the entry should be included in the new record.\n *\n * @example\n * import { filter } from \"effect/Record\"\n *\n * const x = { a: 1, b: 2, c: 3, d: 4 }\n * assert.deepStrictEqual(filter(x, (n) => n > 2), { c: 3, d: 4 })\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const filter: {\n  <K extends string, A, B extends A>(\n    refinement: (a: NoInfer<A>, key: K) => a is B\n  ): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>\n  <K extends string, A>(\n    predicate: (A: NoInfer<A>, key: K) => boolean\n  ): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, A>\n  <K extends string, A, B extends A>(\n    self: ReadonlyRecord<K, A>,\n    refinement: (a: A, key: K) => a is B\n  ): Record<ReadonlyRecord.NonLiteralKey<K>, B>\n  <K extends string, A>(\n    self: ReadonlyRecord<K, A>,\n    predicate: (a: A, key: K) => boolean\n  ): Record<ReadonlyRecord.NonLiteralKey<K>, A>\n} = dual(\n  2,\n  <K extends string, A>(\n    self: ReadonlyRecord<K, A>,\n    predicate: (a: A, key: K) => boolean\n  ): Record<ReadonlyRecord.NonLiteralKey<K>, A> => {\n    const out: Record<string, A> = empty()\n    for (const key of keys(self)) {\n      if (predicate(self[key], key)) {\n        out[key] = self[key]\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Given a record with `Option` values, returns a new record containing only the `Some` values, preserving the original keys.\n *\n * @param self - A record with `Option` values.\n *\n * @example\n * import { getSomes } from \"effect/Record\"\n * import { some, none } from \"effect/Option\"\n *\n * assert.deepStrictEqual(\n *   getSomes({ a: some(1), b: none(), c: some(2) }),\n *   { a: 1, c: 2 }\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const getSomes: <K extends string, A>(\n  self: ReadonlyRecord<K, Option.Option<A>>\n) => Record<ReadonlyRecord.NonLiteralKey<K>, A> = filterMap(\n  identity\n)\n\n/**\n * Given a record with `Either` values, returns a new record containing only the `Left` values, preserving the original keys.\n *\n * @example\n * import { getLefts } from \"effect/Record\"\n * import { right, left } from \"effect/Either\"\n *\n * assert.deepStrictEqual(\n *   getLefts({ a: right(1), b: left(\"err\"), c: right(2) }),\n *   { b: \"err\" }\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const getLefts = <K extends string, R, L>(\n  self: ReadonlyRecord<K, Either<R, L>>\n): Record<ReadonlyRecord.NonLiteralKey<K>, L> => {\n  const out: Record<string, L> = empty()\n  for (const key of keys(self)) {\n    const value = self[key]\n    if (E.isLeft(value)) {\n      out[key] = value.left\n    }\n  }\n\n  return out\n}\n\n/**\n * Given a record with `Either` values, returns a new record containing only the `Right` values, preserving the original keys.\n *\n * @example\n * import { getRights } from \"effect/Record\"\n * import { right, left } from \"effect/Either\"\n *\n * assert.deepStrictEqual(\n *   getRights({ a: right(1), b: left(\"err\"), c: right(2) }),\n *   { a: 1, c: 2 }\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const getRights = <K extends string, R, L>(\n  self: ReadonlyRecord<K, Either<R, L>>\n): Record<string, R> => {\n  const out: Record<string, R> = empty()\n  for (const key of keys(self)) {\n    const value = self[key]\n    if (E.isRight(value)) {\n      out[key] = value.right\n    }\n  }\n\n  return out\n}\n\n/**\n * Partitions the elements of a record into two groups: those that match a predicate, and those that don't.\n *\n * @param self - The record to partition.\n * @param f - The predicate function to apply to each element.\n *\n * @example\n * import { partitionMap } from \"effect/Record\"\n * import { left, right } from 'effect/Either'\n *\n * const x = { a: 1, b: 2, c: 3 }\n * const f = (n: number) => (n % 2 === 0 ? right(n) : left(n))\n * assert.deepStrictEqual(partitionMap(x, f), [{ a: 1, c: 3 }, { b: 2}])\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const partitionMap: {\n  <K extends string, A, B, C>(\n    f: (a: A, key: K) => Either<C, B>\n  ): (\n    self: ReadonlyRecord<K, A>\n  ) => [left: Record<ReadonlyRecord.NonLiteralKey<K>, B>, right: Record<ReadonlyRecord.NonLiteralKey<K>, C>]\n  <K extends string, A, B, C>(\n    self: ReadonlyRecord<K, A>,\n    f: (a: A, key: K) => Either<C, B>\n  ): [left: Record<ReadonlyRecord.NonLiteralKey<K>, B>, right: Record<ReadonlyRecord.NonLiteralKey<K>, C>]\n} = dual(\n  2,\n  <K extends string, A, B, C>(\n    self: ReadonlyRecord<K, A>,\n    f: (a: A, key: K) => Either<C, B>\n  ): [left: Record<ReadonlyRecord.NonLiteralKey<K>, B>, right: Record<ReadonlyRecord.NonLiteralKey<K>, C>] => {\n    const left: Record<string, B> = empty()\n    const right: Record<string, C> = empty()\n    for (const key of keys(self)) {\n      const e = f(self[key], key)\n      if (E.isLeft(e)) {\n        left[key] = e.left\n      } else {\n        right[key] = e.right\n      }\n    }\n    return [left, right]\n  }\n)\n\n/**\n * Partitions a record of `Either` values into two separate records,\n * one with the `Left` values and one with the `Right` values.\n *\n * @param self - the record to partition.\n *\n * @example\n * import { separate } from \"effect/Record\"\n * import { left, right } from 'effect/Either'\n *\n * assert.deepStrictEqual(\n *   separate({ a: left(\"e\"), b: right(1) }),\n *   [{ a: \"e\" }, { b: 1 }]\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const separate: <K extends string, A, B>(\n  self: ReadonlyRecord<K, Either<B, A>>\n) => [Record<ReadonlyRecord.NonLiteralKey<K>, A>, Record<ReadonlyRecord.NonLiteralKey<K>, B>] = partitionMap(identity)\n\n/**\n * Partitions a record into two separate records based on the result of a predicate function.\n *\n * @param self - The input record to partition.\n * @param predicate - The partitioning function to determine the partitioning of each value of the record.\n *\n * @example\n * import { partition } from \"effect/Record\"\n *\n * assert.deepStrictEqual(\n *   partition({ a: 1, b: 3 }, (n) => n > 2),\n *   [{ a: 1 }, { b: 3 }]\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const partition: {\n  <K extends string, A, B extends A>(refinement: (a: NoInfer<A>, key: K) => a is B): (\n    self: ReadonlyRecord<K, A>\n  ) => [\n    excluded: Record<ReadonlyRecord.NonLiteralKey<K>, Exclude<A, B>>,\n    satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, B>\n  ]\n  <K extends string, A>(\n    predicate: (a: NoInfer<A>, key: K) => boolean\n  ): (\n    self: ReadonlyRecord<K, A>\n  ) => [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, A>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, A>]\n  <K extends string, A, B extends A>(\n    self: ReadonlyRecord<K, A>,\n    refinement: (a: A, key: K) => a is B\n  ): [\n    excluded: Record<ReadonlyRecord.NonLiteralKey<K>, Exclude<A, B>>,\n    satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, B>\n  ]\n  <K extends string, A>(\n    self: ReadonlyRecord<K, A>,\n    predicate: (a: A, key: K) => boolean\n  ): [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, A>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, A>]\n} = dual(\n  2,\n  <K extends string, A>(\n    self: ReadonlyRecord<K, A>,\n    predicate: (a: A, key: K) => boolean\n  ): [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, A>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, A>] => {\n    const left: Record<string, A> = empty()\n    const right: Record<string, A> = empty()\n    for (const key of keys(self)) {\n      if (predicate(self[key], key)) {\n        right[key] = self[key]\n      } else {\n        left[key] = self[key]\n      }\n    }\n    return [left, right]\n  }\n)\n\n/**\n * Retrieve the keys of a given record as an array.\n *\n * @param self - The object for which you want to get the keys.\n *\n * @since 2.0.0\n */\nexport const keys = <K extends string, A>(self: ReadonlyRecord<K, A>): Array<K> => Object.keys(self) as Array<K>\n\n/**\n * Retrieve the values of a given record as an array.\n *\n * @param self - The object for which you want to get the values.\n *\n * @since 2.0.0\n */\nexport const values = <K extends string, A>(self: ReadonlyRecord<K, A>): Array<A> => collect(self, (_, a) => a)\n\n/**\n * Add a new key-value pair or update an existing key's value in a record.\n *\n * @param self - The record to which you want to add or update a key-value pair.\n * @param key - The key you want to add or update.\n * @param values - The value you want to associate with the key.\n *\n * @example\n * import { set } from \"effect/Record\"\n *\n * assert.deepStrictEqual(set(\"a\", 5)({ a: 1, b: 2 }), { a: 5, b: 2 });\n * assert.deepStrictEqual(set(\"c\", 5)({ a: 1, b: 2 }), { a: 1, b: 2, c: 5 });\n *\n * @since 2.0.0\n */\nexport const set: {\n  <K extends string | symbol, K1 extends K | ((string | symbol) & {}), B>(\n    key: K1,\n    value: B\n  ): <A>(self: ReadonlyRecord<K, A>) => Record<K | K1, A | B>\n  <K extends string | symbol, A, K1 extends K | ((string | symbol) & {}), B>(\n    self: ReadonlyRecord<K, A>,\n    key: K1,\n    value: B\n  ): Record<K | K1, A | B>\n} = dual(\n  3,\n  <K extends string | symbol, A, K1 extends K | ((string | symbol) & {}), B>(\n    self: ReadonlyRecord<K, A>,\n    key: K1,\n    value: B\n  ): Record<K | K1, A | B> => {\n    return { ...self, [key]: value } as any\n  }\n)\n\n/**\n * Replace a key's value in a record and return the updated record.\n * If the key does not exist in the record, a copy of the original record is returned.\n *\n * @param self - The original record.\n * @param key - The key to replace.\n * @param value - The new value to associate with the key.\n *\n * @example\n * import { replace } from \"effect/Record\"\n * import { some, none } from \"effect/Option\"\n *\n * assert.deepStrictEqual(replace(\"a\", 3)({ a: 1, b: 2 }), { a: 3, b: 2 });\n * assert.deepStrictEqual(replace(\"c\", 3)({ a: 1, b: 2 }), { a: 1, b: 2 });\n *\n * @since 2.0.0\n */\nexport const replace: {\n  <K extends string | symbol, B>(key: NoInfer<K>, value: B): <A>(self: ReadonlyRecord<K, A>) => Record<K, A | B>\n  <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, value: B): Record<K, A | B>\n} = dual(\n  3,\n  <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, value: B): Record<K, A | B> => {\n    if (has(self, key)) {\n      return { ...self, [key]: value }\n    }\n    return { ...self }\n  }\n)\n\n/**\n * Check if all the keys and values in one record are also found in another record.\n *\n * @param self - The first record to check.\n * @param that - The second record to compare against.\n * @param equivalence - A function to compare values.\n *\n * @since 2.0.0\n */\nexport const isSubrecordBy = <A>(equivalence: Equivalence<A>): {\n  <K extends string>(that: ReadonlyRecord<K, A>): (self: ReadonlyRecord<K, A>) => boolean\n  <K extends string>(self: ReadonlyRecord<K, A>, that: ReadonlyRecord<K, A>): boolean\n} =>\n  dual(2, <K extends string>(self: ReadonlyRecord<K, A>, that: ReadonlyRecord<K, A>): boolean => {\n    for (const key of keys(self)) {\n      if (!has(that, key) || !equivalence(self[key], that[key])) {\n        return false\n      }\n    }\n    return true\n  })\n\n/**\n * Check if one record is a subrecord of another, meaning it contains all the keys and values found in the second record.\n * This comparison uses default equality checks (`Equal.equivalence()`).\n *\n * @param self - The first record to check.\n * @param that - The second record to compare against.\n *\n * @since 2.0.0\n */\nexport const isSubrecord: {\n  <K extends string, A>(that: ReadonlyRecord<K, A>): (self: ReadonlyRecord<K, A>) => boolean\n  <K extends string, A>(self: ReadonlyRecord<K, A>, that: ReadonlyRecord<K, A>): boolean\n} = isSubrecordBy(Equal.equivalence())\n\n/**\n * Reduce a record to a single value by combining its entries with a specified function.\n *\n * @param self - The record to reduce.\n * @param zero - The initial value of the accumulator.\n * @param f - The function to combine entries (accumulator, value, key).\n *\n * @category folding\n * @since 2.0.0\n */\nexport const reduce: {\n  <Z, V, K extends string>(\n    zero: Z,\n    f: (accumulator: Z, value: V, key: K) => Z\n  ): (self: ReadonlyRecord<K, V>) => Z\n  <K extends string, V, Z>(self: ReadonlyRecord<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z): Z\n} = dual(\n  3,\n  <K extends string, V, Z>(\n    self: ReadonlyRecord<K, V>,\n    zero: Z,\n    f: (accumulator: Z, value: V, key: K) => Z\n  ): Z => {\n    let out: Z = zero\n    for (const key of keys(self)) {\n      out = f(out, self[key], key)\n    }\n    return out\n  }\n)\n\n/**\n * Check if all entries in a record meet a specific condition.\n *\n * @param self - The record to check.\n * @param predicate - The condition to test entries (value, key).\n *\n * @since 2.0.0\n */\nexport const every: {\n  <A, K extends string, B extends A>(\n    refinement: (value: A, key: K) => value is B\n  ): (self: ReadonlyRecord<K, A>) => self is ReadonlyRecord<K, B>\n  <A, K extends string>(predicate: (value: A, key: K) => boolean): (self: ReadonlyRecord<K, A>) => boolean\n  <A, K extends string, B extends A>(\n    self: ReadonlyRecord<K, A>,\n    refinement: (value: A, key: K) => value is B\n  ): self is ReadonlyRecord<K, B>\n  <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (value: A, key: K) => boolean): boolean\n} = dual(\n  2,\n  <A, K extends string, B extends A>(\n    self: ReadonlyRecord<K, A>,\n    refinement: (value: A, key: K) => value is B\n  ): self is ReadonlyRecord<K, B> => {\n    for (const key of keys(self)) {\n      if (!refinement(self[key], key)) {\n        return false\n      }\n    }\n    return true\n  }\n)\n\n/**\n * Check if any entry in a record meets a specific condition.\n *\n * @param self - The record to check.\n * @param predicate - The condition to test entries (value, key).\n *\n * @since 2.0.0\n */\nexport const some: {\n  <A, K extends string>(predicate: (value: A, key: K) => boolean): (self: ReadonlyRecord<K, A>) => boolean\n  <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (value: A, key: K) => boolean): boolean\n} = dual(\n  2,\n  <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (value: A, key: K) => boolean): boolean => {\n    for (const key of keys(self)) {\n      if (predicate(self[key], key)) {\n        return true\n      }\n    }\n    return false\n  }\n)\n\n/**\n * Merge two records, preserving entries that exist in either of the records.\n *\n * @param self - The first record.\n * @param that - The second record to combine with the first.\n * @param combine - A function to specify how to merge entries with the same key.\n *\n * @since 2.0.0\n */\nexport const union: {\n  <K1 extends string, A, B, C>(\n    that: ReadonlyRecord<K1, B>,\n    combine: (selfValue: A, thatValue: B) => C\n  ): <K0 extends string>(self: ReadonlyRecord<K0, A>) => Record<K0 | K1, A | B | C>\n  <K0 extends string, A, K1 extends string, B, C>(\n    self: ReadonlyRecord<K0, A>,\n    that: ReadonlyRecord<K1, B>,\n    combine: (selfValue: A, thatValue: B) => C\n  ): Record<K0 | K1, A | B | C>\n} = dual(\n  3,\n  <K0 extends string, A, K1 extends string, B, C>(\n    self: ReadonlyRecord<K0, A>,\n    that: ReadonlyRecord<K1, B>,\n    combine: (selfValue: A, thatValue: B) => C\n  ): Record<K0 | K1, A | B | C> => {\n    if (isEmptyRecord(self)) {\n      return { ...that } as any\n    }\n    if (isEmptyRecord(that)) {\n      return { ...self } as any\n    }\n    const out: Record<string, A | B | C> = empty()\n    for (const key of keys(self)) {\n      if (has(that, key as any)) {\n        out[key] = combine(self[key], that[key as unknown as K1])\n      } else {\n        out[key] = self[key]\n      }\n    }\n    for (const key of keys(that)) {\n      if (!has(out, key)) {\n        out[key] = that[key]\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Merge two records, retaining only the entries that exist in both records.\n *\n * @param self - The first record.\n * @param that - The second record to merge with the first.\n * @param combine - A function to specify how to merge entries with the same key.\n *\n * @since 2.0.0\n */\nexport const intersection: {\n  <K1 extends string, A, B, C>(\n    that: ReadonlyRecord<K1, B>,\n    combine: (selfValue: A, thatValue: B) => C\n  ): <K0 extends string>(self: ReadonlyRecord<K0, A>) => Record<ReadonlyRecord.IntersectKeys<K0, K1>, C>\n  <K0 extends string, A, K1 extends string, B, C>(\n    self: ReadonlyRecord<K0, A>,\n    that: ReadonlyRecord<K1, B>,\n    combine: (selfValue: A, thatValue: B) => C\n  ): Record<ReadonlyRecord.IntersectKeys<K0, K1>, C>\n} = dual(\n  3,\n  <K0 extends string, A, K1 extends string, B, C>(\n    self: ReadonlyRecord<K0, A>,\n    that: ReadonlyRecord<K1, B>,\n    combine: (selfValue: A, thatValue: B) => C\n  ): Record<ReadonlyRecord.IntersectKeys<K0, K1>, C> => {\n    const out: Record<string, C> = empty()\n    if (isEmptyRecord(self) || isEmptyRecord(that)) {\n      return out\n    }\n    for (const key of keys(self)) {\n      if (has(that, key as any)) {\n        out[key] = combine(self[key], that[key as unknown as K1])\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Merge two records, preserving only the entries that are unique to each record.\n *\n * @param self - The first record.\n * @param that - The second record to compare with the first.\n *\n * @since 2.0.0\n */\nexport const difference: {\n  <K1 extends string, B>(\n    that: ReadonlyRecord<K1, B>\n  ): <K0 extends string, A>(self: ReadonlyRecord<K0, A>) => Record<K0 | K1, A | B>\n  <K0 extends string, A, K1 extends string, B>(\n    self: ReadonlyRecord<K0, A>,\n    that: ReadonlyRecord<K1, B>\n  ): Record<K0 | K1, A | B>\n} = dual(2, <K0 extends string, A, K1 extends string, B>(\n  self: ReadonlyRecord<K0, A>,\n  that: ReadonlyRecord<K1, B>\n): Record<K0 | K1, A | B> => {\n  if (isEmptyRecord(self)) {\n    return { ...that } as any\n  }\n  if (isEmptyRecord(that)) {\n    return { ...self } as any\n  }\n  const out = <Record<K0 | K1, A | B>> {}\n  for (const key of keys(self)) {\n    if (!has(that, key as any)) {\n      out[key] = self[key]\n    }\n  }\n  for (const key of keys(that)) {\n    if (!has(self, key as any)) {\n      out[key] = that[key]\n    }\n  }\n  return out\n})\n\n/**\n * Create an `Equivalence` for records using the provided `Equivalence` for values.\n *\n * @param equivalence - An `Equivalence` for the values contained in the records.\n *\n * @category instances\n * @since 2.0.0\n */\nexport const getEquivalence = <K extends string, A>(\n  equivalence: Equivalence<A>\n): Equivalence<ReadonlyRecord<K, A>> => {\n  const is = isSubrecordBy(equivalence)\n  return (self, that) => is(self, that) && is(that, self)\n}\n\n/**\n * Create a non-empty record from a single element.\n *\n * @param key - The key for the element.\n * @param value - The value associated with the key.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const singleton = <K extends string | symbol, A>(key: K, value: A): Record<K, A> => ({\n  [key]: value\n} as any)\n", "/**\n * @since 2.0.0\n */\n\nimport * as Equivalence from \"./Equivalence.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport { constNull, constUndefined, dual, identity } from \"./Function.js\"\nimport type { TypeLambda } from \"./HKT.js\"\nimport type { Inspectable } from \"./Inspectable.js\"\nimport * as either from \"./internal/either.js\"\nimport type { Option } from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type { Predicate, Refinement } from \"./Predicate.js\"\nimport { isFunction } from \"./Predicate.js\"\nimport type { Covariant, MergeRecord, NotFunction } from \"./Types.js\"\nimport type * as Unify from \"./Unify.js\"\nimport * as Gen from \"./Utils.js\"\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport type Either<R, L = never> = Left<L, R> | Right<L, R>\n\n/**\n * @category symbols\n * @since 2.0.0\n */\nexport const TypeId: unique symbol = either.TypeId\n\n/**\n * @category symbols\n * @since 2.0.0\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface Left<out L, out R> extends Pipeable, Inspectable {\n  readonly _tag: \"Left\"\n  readonly _op: \"Left\"\n  readonly left: L\n  readonly [TypeId]: {\n    readonly _R: Covariant<R>\n    readonly _L: Covariant<L>\n  }\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: EitherUnify<this>\n  [Unify.ignoreSymbol]?: EitherUnifyIgnore\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface Right<out L, out R> extends Pipeable, Inspectable {\n  readonly _tag: \"Right\"\n  readonly _op: \"Right\"\n  readonly right: R\n  readonly [TypeId]: {\n    readonly _R: Covariant<R>\n    readonly _L: Covariant<L>\n  }\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: EitherUnify<this>\n  [Unify.ignoreSymbol]?: EitherUnifyIgnore\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface EitherUnify<A extends { [Unify.typeSymbol]?: any }> {\n  Either?: () => A[Unify.typeSymbol] extends Either<infer R0, infer L0> | infer _ ? Either<R0, L0> : never\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface EitherUnifyIgnore {}\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface EitherTypeLambda extends TypeLambda {\n  readonly type: Either<this[\"Target\"], this[\"Out1\"]>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Either {\n  /**\n   * @since 2.0.0\n   * @category type-level\n   */\n  export type Left<T extends Either<any, any>> = [T] extends [Either<infer _A, infer _E>] ? _E : never\n  /**\n   * @since 2.0.0\n   * @category type-level\n   */\n  export type Right<T extends Either<any, any>> = [T] extends [Either<infer _A, infer _E>] ? _A : never\n}\n\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const right: <R>(right: R) => Either<R> = either.right\n\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const left: <L>(left: L) => Either<never, L> = either.left\n\n/**\n * Takes a lazy default and a nullable value, if the value is not nully (`null` or `undefined`), turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import * as Either from 'effect/Either'\n *\n * assert.deepStrictEqual(Either.fromNullable(1, () => 'fallback'), Either.right(1))\n * assert.deepStrictEqual(Either.fromNullable(null, () => 'fallback'), Either.left('fallback'))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromNullable: {\n  <R, L>(onNullable: (right: R) => L): (self: R) => Either<NonNullable<R>, L>\n  <R, L>(self: R, onNullable: (right: R) => L): Either<NonNullable<R>, L>\n} = dual(\n  2,\n  <R, L>(self: R, onNullable: (right: R) => L): Either<NonNullable<R>, L> =>\n    self == null ? left(onNullable(self)) : right(self as NonNullable<R>)\n)\n\n/**\n * @example\n * import * as Either from 'effect/Either'\n * import * as Option from 'effect/Option'\n *\n * assert.deepStrictEqual(Either.fromOption(Option.some(1), () => 'error'), Either.right(1))\n * assert.deepStrictEqual(Either.fromOption(Option.none(), () => 'error'), Either.left('error'))\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromOption: {\n  <L>(onNone: () => L): <R>(self: Option<R>) => Either<R, L>\n  <R, L>(self: Option<R>, onNone: () => L): Either<R, L>\n} = either.fromOption\n\nconst try_: {\n  <R, L>(\n    options: {\n      readonly try: LazyArg<R>\n      readonly catch: (error: unknown) => L\n    }\n  ): Either<R, L>\n  <R>(evaluate: LazyArg<R>): Either<R, unknown>\n} = (<R, L>(\n  evaluate: LazyArg<R> | {\n    readonly try: LazyArg<R>\n    readonly catch: (error: unknown) => L\n  }\n) => {\n  if (isFunction(evaluate)) {\n    try {\n      return right(evaluate())\n    } catch (e) {\n      return left(e)\n    }\n  } else {\n    try {\n      return right(evaluate.try())\n    } catch (e) {\n      return left(evaluate.catch(e))\n    }\n  }\n}) as any\n\nexport {\n  /**\n   * Imports a synchronous side-effect into a pure `Either` value, translating any\n   * thrown exceptions into typed failed eithers creating with `Either.left`.\n   *\n   * @category constructors\n   * @since 2.0.0\n   */\n  try_ as try\n}\n\n/**\n * Tests if a value is a `Either`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isEither, left, right } from 'effect/Either'\n *\n * assert.deepStrictEqual(isEither(right(1)), true)\n * assert.deepStrictEqual(isEither(left(\"a\")), true)\n * assert.deepStrictEqual(isEither({ right: 1 }), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isEither: (input: unknown) => input is Either<unknown, unknown> = either.isEither\n\n/**\n * Determine if a `Either` is a `Left`.\n *\n * @param self - The `Either` to check.\n *\n * @example\n * import { isLeft, left, right } from 'effect/Either'\n *\n * assert.deepStrictEqual(isLeft(right(1)), false)\n * assert.deepStrictEqual(isLeft(left(\"a\")), true)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isLeft: <R, L>(self: Either<R, L>) => self is Left<L, R> = either.isLeft\n\n/**\n * Determine if a `Either` is a `Right`.\n *\n * @param self - The `Either` to check.\n *\n * @example\n * import { isRight, left, right } from 'effect/Either'\n *\n * assert.deepStrictEqual(isRight(right(1)), true)\n * assert.deepStrictEqual(isRight(left(\"a\")), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isRight: <R, L>(self: Either<R, L>) => self is Right<L, R> = either.isRight\n\n/**\n * Converts a `Either` to an `Option` discarding the `Left`.\n *\n * Alias of {@link toOption}.\n *\n * @example\n * import * as O from 'effect/Option'\n * import * as E from 'effect/Either'\n *\n * assert.deepStrictEqual(E.getRight(E.right('ok')), O.some('ok'))\n * assert.deepStrictEqual(E.getRight(E.left('err')), O.none())\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getRight: <R, L>(self: Either<R, L>) => Option<R> = either.getRight\n\n/**\n * Converts a `Either` to an `Option` discarding the value.\n *\n * @example\n * import * as O from 'effect/Option'\n * import * as E from 'effect/Either'\n *\n * assert.deepStrictEqual(E.getLeft(E.right('ok')), O.none())\n * assert.deepStrictEqual(E.getLeft(E.left('err')), O.some('err'))\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getLeft: <R, L>(self: Either<R, L>) => Option<L> = either.getLeft\n\n/**\n * @category equivalence\n * @since 2.0.0\n */\nexport const getEquivalence = <R, L>({ left, right }: {\n  right: Equivalence.Equivalence<R>\n  left: Equivalence.Equivalence<L>\n}): Equivalence.Equivalence<Either<R, L>> =>\n  Equivalence.make((x, y) =>\n    x === y ||\n    (isLeft(x) ?\n      isLeft(y) && left(x.left, y.left) :\n      isRight(y) && right(x.right, y.right))\n  )\n\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport const mapBoth: {\n  <L, L2, R, R2>(options: {\n    readonly onLeft: (left: L) => L2\n    readonly onRight: (right: R) => R2\n  }): (self: Either<R, L>) => Either<R2, L2>\n  <L, R, L2, R2>(self: Either<R, L>, options: {\n    readonly onLeft: (left: L) => L2\n    readonly onRight: (right: R) => R2\n  }): Either<R2, L2>\n} = dual(\n  2,\n  <L, R, L2, R2>(self: Either<R, L>, { onLeft, onRight }: {\n    readonly onLeft: (left: L) => L2\n    readonly onRight: (right: R) => R2\n  }): Either<R2, L2> => isLeft(self) ? left(onLeft(self.left)) : right(onRight(self.right))\n)\n\n/**\n * Maps the `Left` side of an `Either` value to a new `Either` value.\n *\n * @param self - The input `Either` value to map.\n * @param f - A transformation function to apply to the `Left` value of the input `Either`.\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const mapLeft: {\n  <L, L2>(f: (left: L) => L2): <R>(self: Either<R, L>) => Either<R, L2>\n  <R, L, L2>(self: Either<R, L>, f: (left: L) => L2): Either<R, L2>\n} = dual(\n  2,\n  <R, L1, L2>(self: Either<R, L1>, f: (left: L1) => L2): Either<R, L2> =>\n    isLeft(self) ? left(f(self.left)) : right(self.right)\n)\n\n/**\n * Maps the `Right` side of an `Either` value to a new `Either` value.\n *\n * @param self - An `Either` to map\n * @param f - The function to map over the value of the `Either`\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const map: {\n  <R, R2>(f: (right: R) => R2): <L>(self: Either<R, L>) => Either<R2, L>\n  <R, L, R2>(self: Either<R, L>, f: (right: R) => R2): Either<R2, L>\n} = dual(\n  2,\n  <R1, L, R2>(self: Either<R1, L>, f: (right: R1) => R2): Either<R2, L> =>\n    isRight(self) ? right(f(self.right)) : left(self.left)\n)\n\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the `onLeft function,\n * if the value is a `Right` the inner value is applied to the `onRight` function.\n *\n * @example\n * import * as E from 'effect/Either'\n * import { pipe } from 'effect/Function'\n *\n * const onLeft  = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(', ')}`\n *\n * const onRight = (value: number): string => `Ok: ${value}`\n *\n * assert.deepStrictEqual(pipe(E.right(1), E.match({ onLeft, onRight })), 'Ok: 1')\n * assert.deepStrictEqual(\n *   pipe(E.left(['string 1', 'string 2']), E.match({ onLeft, onRight })),\n *   'strings: string 1, string 2'\n * )\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport const match: {\n  <L, B, R, C = B>(options: {\n    readonly onLeft: (left: L) => B\n    readonly onRight: (right: R) => C\n  }): (self: Either<R, L>) => B | C\n  <R, L, B, C = B>(self: Either<R, L>, options: {\n    readonly onLeft: (left: L) => B\n    readonly onRight: (right: R) => C\n  }): B | C\n} = dual(\n  2,\n  <R, L, B, C = B>(self: Either<R, L>, { onLeft, onRight }: {\n    readonly onLeft: (left: L) => B\n    readonly onRight: (right: R) => C\n  }): B | C => isLeft(self) ? onLeft(self.left) : onRight(self.right)\n)\n\n/**\n * Filter the right value with the provided function.\n * If the predicate fails, set the left value with the result of the provided function.\n *\n * @example\n * import * as E from 'effect/Either'\n * import { pipe } from 'effect/Function'\n *\n * const isPositive = (n: number): boolean => n > 0\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.filterOrLeft(isPositive, n => `${n} is not positive`)\n *   ),\n *   E.right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(0),\n *     E.filterOrLeft(isPositive, n => `${n} is not positive`)\n *   ),\n *   E.left(\"0 is not positive\")\n * )\n *\n * @since 2.0.0\n * @category filtering & conditionals\n */\nexport const filterOrLeft: {\n  <R, B extends R, L2>(\n    refinement: Refinement<NoInfer<R>, B>,\n    orLeftWith: (right: NoInfer<R>) => L2\n  ): <L>(self: Either<R, L>) => Either<B, L2 | L>\n  <R, L2>(\n    predicate: Predicate<NoInfer<R>>,\n    orLeftWith: (right: NoInfer<R>) => L2\n  ): <L>(self: Either<R, L>) => Either<R, L2 | L>\n  <R, L, B extends R, L2>(\n    self: Either<R, L>,\n    refinement: Refinement<R, B>,\n    orLeftWith: (right: R) => L2\n  ): Either<B, L | L2>\n  <R, L, E2>(self: Either<R, L>, predicate: Predicate<R>, orLeftWith: (right: R) => E2): Either<R, L | E2>\n} = dual(3, <R, L, E2>(\n  self: Either<R, L>,\n  predicate: Predicate<R>,\n  orLeftWith: (right: R) => E2\n): Either<R, L | E2> => flatMap(self, (r) => predicate(r) ? right(r) : left(orLeftWith(r))))\n\n/**\n * @category getters\n * @since 2.0.0\n */\nexport const merge: <R, L>(self: Either<R, L>) => L | R = match({\n  onLeft: identity,\n  onRight: identity\n})\n\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import * as Either from 'effect/Either'\n *\n * assert.deepStrictEqual(Either.getOrElse(Either.right(1), (error) => error + \"!\"), 1)\n * assert.deepStrictEqual(Either.getOrElse(Either.left(\"not a number\"), (error) => error + \"!\"), \"not a number!\")\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrElse: {\n  <L, R2>(onLeft: (left: L) => R2): <R>(self: Either<R, L>) => R2 | R\n  <R, L, R2>(self: Either<R, L>, onLeft: (left: L) => R2): R | R2\n} = dual(\n  2,\n  <R, L, B>(self: Either<R, L>, onLeft: (left: L) => B): R | B => isLeft(self) ? onLeft(self.left) : self.right\n)\n\n/**\n * @example\n * import * as Either from 'effect/Either'\n *\n * assert.deepStrictEqual(Either.getOrNull(Either.right(1)), 1)\n * assert.deepStrictEqual(Either.getOrNull(Either.left(\"a\")), null)\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrNull: <R, L>(self: Either<R, L>) => R | null = getOrElse(constNull)\n\n/**\n * @example\n * import * as Either from 'effect/Either'\n *\n * assert.deepStrictEqual(Either.getOrUndefined(Either.right(1)), 1)\n * assert.deepStrictEqual(Either.getOrUndefined(Either.left(\"a\")), undefined)\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrUndefined: <R, L>(self: Either<R, L>) => R | undefined = getOrElse(constUndefined)\n\n/**\n * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n *\n * If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.\n *\n * @param self - The `Either` to extract the value from.\n * @param onLeft - A function that will be called if the `Either` is `Left`. It returns the error to be thrown.\n *\n * @example\n * import * as E from \"effect/Either\"\n *\n * assert.deepStrictEqual(\n *   E.getOrThrowWith(E.right(1), () => new Error('Unexpected Left')),\n *   1\n * )\n * assert.throws(() => E.getOrThrowWith(E.left(\"error\"), () => new Error('Unexpected Left')))\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrThrowWith: {\n  <L>(onLeft: (left: L) => unknown): <A>(self: Either<A, L>) => A\n  <R, L>(self: Either<R, L>, onLeft: (left: L) => unknown): R\n} = dual(2, <R, L>(self: Either<R, L>, onLeft: (left: L) => unknown): R => {\n  if (isRight(self)) {\n    return self.right\n  }\n  throw onLeft(self.left)\n})\n\n/**\n * Extracts the value of an `Either` or throws if the `Either` is `Left`.\n *\n * The thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.\n *\n * @param self - The `Either` to extract the value from.\n * @throws `Error(\"getOrThrow called on a Left\")`\n *\n * @example\n * import * as E from \"effect/Either\"\n *\n * assert.deepStrictEqual(E.getOrThrow(E.right(1)), 1)\n * assert.throws(() => E.getOrThrow(E.left(\"error\")))\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getOrThrow: <R, L>(self: Either<R, L>) => R = getOrThrowWith(() =>\n  new Error(\"getOrThrow called on a Left\")\n)\n\n/**\n * Returns `self` if it is a `Right` or `that` otherwise.\n *\n * @param self - The input `Either` value to check and potentially return.\n * @param that - A function that takes the error value from `self` (if it's a `Left`) and returns a new `Either` value.\n *\n * @category error handling\n * @since 2.0.0\n */\nexport const orElse: {\n  <L, R2, L2>(that: (left: L) => Either<R2, L2>): <R>(self: Either<R, L>) => Either<R | R2, L2>\n  <R, L, R2, L2>(self: Either<R, L>, that: (left: L) => Either<R2, L2>): Either<R | R2, L2>\n} = dual(\n  2,\n  <R1, L1, R2, L2>(self: Either<R1, L1>, that: (left: L1) => Either<R2, L2>): Either<R1 | R2, L2> =>\n    isLeft(self) ? that(self.left) : right(self.right)\n)\n\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport const flatMap: {\n  <R, R2, L2>(f: (right: R) => Either<R2, L2>): <L>(self: Either<R, L>) => Either<R2, L | L2>\n  <R, L, R2, L2>(self: Either<R, L>, f: (right: R) => Either<R2, L2>): Either<R2, L | L2>\n} = dual(\n  2,\n  <R1, L1, R2, L2>(self: Either<R1, L1>, f: (right: R1) => Either<R2, L2>): Either<R2, L1 | L2> =>\n    isLeft(self) ? left(self.left) : f(self.right)\n)\n\n/**\n * Executes a sequence of two `Either`s. The second `Either` can be dependent on the result of the first `Either`.\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport const andThen: {\n  <R, R2, L2>(f: (right: R) => Either<R2, L2>): <L>(self: Either<R, L>) => Either<R2, L | L2>\n  <R2, L2>(f: Either<R2, L2>): <L, R1>(self: Either<R1, L>) => Either<R2, L | L2>\n  <R, R2>(f: (right: R) => R2): <L>(self: Either<R, L>) => Either<R2, L>\n  <R2>(right: NotFunction<R2>): <R1, L>(self: Either<R1, L>) => Either<R2, L>\n  <R, L, R2, L2>(self: Either<R, L>, f: (right: R) => Either<R2, L2>): Either<R2, L | L2>\n  <R, L, R2, L2>(self: Either<R, L>, f: Either<R2, L2>): Either<R2, L | L2>\n  <R, L, R2>(self: Either<R, L>, f: (right: R) => R2): Either<R2, L>\n  <R, L, R2>(self: Either<R, L>, f: NotFunction<R2>): Either<R2, L>\n} = dual(\n  2,\n  <R, L, R2, L2>(self: Either<R, L>, f: (right: R) => Either<R2, L2> | Either<R2, L2>): Either<R2, L | L2> =>\n    flatMap(self, (a) => {\n      const b = isFunction(f) ? f(a) : f\n      return isEither(b) ? b : right(b)\n    })\n)\n\n/**\n * @category zipping\n * @since 2.0.0\n */\nexport const zipWith: {\n  <R2, L2, R, B>(\n    that: Either<R2, L2>,\n    f: (right: R, right2: R2) => B\n  ): <L>(self: Either<R, L>) => Either<B, L2 | L>\n  <R, L, R2, L2, B>(\n    self: Either<R, L>,\n    that: Either<R2, L2>,\n    f: (right: R, right2: R2) => B\n  ): Either<B, L | L2>\n} = dual(\n  3,\n  <R, L, R2, L2, B>(self: Either<R, L>, that: Either<R2, L2>, f: (right: R, right2: R2) => B): Either<B, L | L2> =>\n    flatMap(self, (r) => map(that, (r2) => f(r, r2)))\n)\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const ap: {\n  <R, L2>(that: Either<R, L2>): <R2, L>(self: Either<(right: R) => R2, L>) => Either<R2, L | L2>\n  <R, R2, L, L2>(self: Either<(right: R) => R2, L>, that: Either<R, L2>): Either<R2, L | L2>\n} = dual(\n  2,\n  <R, R2, L, L2>(self: Either<(right: R) => R2, L>, that: Either<R, L2>): Either<R2, L | L2> =>\n    zipWith(self, that, (f, a) => f(a))\n)\n\n/**\n * Takes a structure of `Either`s and returns an `Either` of values with the same structure.\n *\n * - If a tuple is supplied, then the returned `Either` will contain a tuple with the same length.\n * - If a struct is supplied, then the returned `Either` will contain a struct with the same keys.\n * - If an iterable is supplied, then the returned `Either` will contain an array.\n *\n * @param fields - the struct of `Either`s to be sequenced.\n *\n * @example\n * import * as Either from \"effect/Either\"\n *\n * assert.deepStrictEqual(Either.all([Either.right(1), Either.right(2)]), Either.right([1, 2]))\n * assert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.right(\"hello\") }), Either.right({ right: 1, b: \"hello\" }))\n * assert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.left(\"error\") }), Either.left(\"error\"))\n *\n * @category combining\n * @since 2.0.0\n */\n// @ts-expect-error\nexport const all: <const I extends Iterable<Either<any, any>> | Record<string, Either<any, any>>>(\n  input: I\n) => [I] extends [ReadonlyArray<Either<any, any>>] ? Either<\n    { -readonly [K in keyof I]: [I[K]] extends [Either<infer R, any>] ? R : never },\n    I[number] extends never ? never : [I[number]] extends [Either<any, infer L>] ? L : never\n  >\n  : [I] extends [Iterable<Either<infer R, infer L>>] ? Either<Array<R>, L>\n  : Either<\n    { -readonly [K in keyof I]: [I[K]] extends [Either<infer R, any>] ? R : never },\n    I[keyof I] extends never ? never : [I[keyof I]] extends [Either<any, infer L>] ? L : never\n  > = (\n    input: Iterable<Either<any, any>> | Record<string, Either<any, any>>\n  ): Either<any, any> => {\n    if (Symbol.iterator in input) {\n      const out: Array<Either<any, any>> = []\n      for (const e of (input as Iterable<Either<any, any>>)) {\n        if (isLeft(e)) {\n          return e\n        }\n        out.push(e.right)\n      }\n      return right(out)\n    }\n\n    const out: Record<string, any> = {}\n    for (const key of Object.keys(input)) {\n      const e = input[key]\n      if (isLeft(e)) {\n        return e\n      }\n      out[key] = e.right\n    }\n    return right(out)\n  }\n\n/**\n * Returns an `Either` that swaps the error/success cases. This allows you to\n * use all methods on the error channel, possibly before flipping back.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const flip = <R, L>(self: Either<R, L>): Either<L, R> => isLeft(self) ? right(self.left) : left(self.right)\n\nconst adapter = Gen.adapter<EitherTypeLambda>()\n\n/**\n * @category generators\n * @since 2.0.0\n */\nexport const gen: Gen.Gen<EitherTypeLambda, Gen.Adapter<EitherTypeLambda>> = (f) => {\n  const iterator = f(adapter)\n  let state: IteratorYieldResult<any> | IteratorReturnResult<any> = iterator.next()\n  if (state.done) {\n    return right(state.value) as any\n  } else {\n    let current = state.value.value\n    if (isLeft(current)) {\n      return current\n    }\n    while (!state.done) {\n      state = iterator.next(current.right)\n      if (!state.done) {\n        current = state.value.value\n        if (isLeft(current)) {\n          return current\n        }\n      }\n    }\n    return right(state.value)\n  }\n}\n\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n\n/**\n * @since 2.4.0\n * @category do notation\n */\nexport const Do: Either<{}> = right({})\n\n/**\n * Binds an effectful value in a `do` scope\n *\n * @since 2.4.0\n * @category do notation\n */\nexport const bind: {\n  <N extends string, K, A, E2>(\n    tag: Exclude<N, keyof K>,\n    f: (_: K) => Either<A, E2>\n  ): <E>(self: Either<K, E>) => Either<MergeRecord<K, { [k in N]: A }>, E2 | E>\n  <K, E, N extends string, A, E2>(\n    self: Either<E, K>,\n    tag: Exclude<N, keyof K>,\n    f: (_: K) => Either<A, E2>\n  ): Either<MergeRecord<K, { [k in N]: A }>, E2 | E>\n} = dual(3, <K, E, N extends string, A, E2>(\n  self: Either<K, E>,\n  tag: Exclude<N, keyof K>,\n  f: (_: K) => Either<A, E2>\n): Either<MergeRecord<K, { [k in N]: A }>, E2 | E> =>\n  flatMap(self, (k) =>\n    map(\n      f(k),\n      (a): MergeRecord<K, { [k in N]: A }> => ({ ...k, [tag]: a } as any)\n    )))\n\n/**\n * @category do notation\n * @since 2.4.0\n */\nexport const bindTo: {\n  <N extends string>(tag: N): <A, E>(self: Either<A, E>) => Either<Record<N, A>, E>\n  <A, E, N extends string>(self: Either<A, E>, tag: N): Either<Record<N, A>, E>\n} = dual(\n  2,\n  <A, E, N extends string>(self: Either<A, E>, tag: N): Either<Record<N, A>, E> =>\n    map(self, (a) => ({ [tag]: a } as Record<N, A>))\n)\n\nconst let_: {\n  <N extends string, K, A>(\n    tag: Exclude<N, keyof K>,\n    f: (_: K) => A\n  ): <E>(self: Either<K, E>) => Either<MergeRecord<K, { [k in N]: A }>, E>\n  <K, E, N extends string, A>(\n    self: Either<K, E>,\n    tag: Exclude<N, keyof K>,\n    f: (_: K) => A\n  ): Either<MergeRecord<K, { [k in N]: A }>, E>\n} = dual(3, <K, E, N extends string, A>(\n  self: Either<K, E>,\n  tag: Exclude<N, keyof K>,\n  f: (_: K) => A\n): Either<MergeRecord<K, { [k in N]: A }>, E> =>\n  map(\n    self,\n    (k): MergeRecord<K, { [k in N]: A }> => ({ ...k, [tag]: f(k) } as any)\n  ))\n\nexport {\n  /**\n   * Like bind for values\n   *\n   * @since 2.4.0\n   * @category do notation\n   */\n  let_ as let\n}\n"],
  "mappings": "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",
  "names": ["getEquivalence", "map", "some", "TypeId", "fromOption", "getLeft", "getRight", "isEither", "isLeft", "isRight", "left", "right", "TypeId", "right", "left", "fromNullable", "dual", "self", "onNullable", "fromOption", "try_", "evaluate", "isFunction", "e", "try", "catch", "isEither", "isLeft", "isRight", "getRight", "getLeft", "getEquivalence", "left", "right", "make", "x", "y", "mapBoth", "dual", "self", "onLeft", "onRight", "mapLeft", "f", "map", "match", "filterOrLeft", "predicate", "orLeftWith", "flatMap", "r", "merge", "identity", "getOrElse", "getOrNull", "constNull", "getOrUndefined", "constUndefined", "getOrThrowWith", "getOrThrow", "Error", "orElse", "that", "andThen", "a", "b", "isFunction", "zipWith", "r2", "ap", "all", "input", "Symbol", "iterator", "out", "e", "push", "key", "Object", "keys", "flip", "adapter", "gen", "state", "next", "done", "value", "current", "Do", "bind", "tag", "k", "bindTo", "let_", "empty", "isEmptyRecord", "self", "keys", "length", "isEmptyReadonlyRecord", "fromIterableWith", "dual", "f", "out", "a", "k", "b", "fromIterableBy", "items", "fromEntries", "Object", "collect", "key", "push", "toEntries", "value", "size", "has", "prototype", "hasOwnProperty", "call", "get", "some", "none", "modify", "modifyOption", "replaceOption", "remove", "pop", "map", "mapKeys", "mapEntries", "filterMap", "o", "isSome", "filter", "predicate", "getSomes", "identity", "getLefts", "isLeft", "left", "getRights", "isRight", "right", "partitionMap", "e", "separate", "partition", "values", "_", "set", "replace", "isSubrecordBy", "equivalence", "that", "isSubrecord", "reduce", "zero", "every", "refinement", "union", "combine", "intersection", "difference", "getEquivalence", "is", "singleton"]
}
