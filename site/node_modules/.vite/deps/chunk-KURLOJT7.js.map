{
  "version": 3,
  "sources": ["../../../../node_modules/effect/src/Predicate.ts", "../../../../node_modules/effect/src/Function.ts"],
  "sourcesContent": ["/**\n * @since 2.0.0\n */\nimport { dual, isFunction as isFunction_ } from \"./Function.js\"\nimport type { TypeLambda } from \"./HKT.js\"\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface Predicate<in A> {\n  (a: A): boolean\n}\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface PredicateTypeLambda extends TypeLambda {\n  readonly type: Predicate<this[\"Target\"]>\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface Refinement<in A, out B extends A> {\n  (a: A): a is B\n}\n\n/**\n * Given a `Predicate<A>` returns a `Predicate<B>`\n *\n * @param self - the `Predicate<A>` to be transformed to `Predicate<B>`.\n * @param f - a function to transform `B` to `A`.\n *\n * @example\n * import * as P from \"effect/Predicate\"\n * import * as N from \"effect/Number\"\n *\n * const minLength3 = P.mapInput(N.greaterThan(2), (s: string) => s.length)\n *\n * assert.deepStrictEqual(minLength3(\"a\"), false)\n * assert.deepStrictEqual(minLength3(\"aa\"), false)\n * assert.deepStrictEqual(minLength3(\"aaa\"), true)\n * assert.deepStrictEqual(minLength3(\"aaaa\"), true)\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const mapInput: {\n  <B, A>(f: (b: B) => A): (self: Predicate<A>) => Predicate<B>\n  <A, B>(self: Predicate<A>, f: (b: B) => A): Predicate<B>\n} = dual(2, <A, B>(self: Predicate<A>, f: (b: B) => A): Predicate<B> => (b) => self(f(b)))\n\n/**\n * Tests if a value is `truthy`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isTruthy } from 'effect/Predicate'\n *\n * assert.deepStrictEqual(isTruthy(1), true)\n * assert.deepStrictEqual(isTruthy(0), false)\n * assert.deepStrictEqual(isTruthy(\"\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isTruthy = (input: unknown) => !!input\n\n/**\n * Tests if a value is a `Set`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isSet } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isSet(new Set([1, 2])), true)\n * assert.deepStrictEqual(isSet(new Set()), true)\n * assert.deepStrictEqual(isSet({}), false)\n * assert.deepStrictEqual(isSet(null), false)\n * assert.deepStrictEqual(isSet(undefined), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isSet = (input: unknown): input is Set<unknown> => input instanceof Set\n\n/**\n * Tests if a value is a `Map`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isMap } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isMap(new Map()), true)\n * assert.deepStrictEqual(isMap({}), false)\n * assert.deepStrictEqual(isMap(null), false)\n * assert.deepStrictEqual(isMap(undefined), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isMap = (input: unknown): input is Map<unknown, unknown> => input instanceof Map\n\n/**\n * Tests if a value is a `string`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isString } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isString(\"a\"), true)\n *\n * assert.deepStrictEqual(isString(1), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isString = (input: unknown): input is string => typeof input === \"string\"\n\n/**\n * Tests if a value is a `number`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNumber } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNumber(2), true)\n *\n * assert.deepStrictEqual(isNumber(\"2\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNumber = (input: unknown): input is number => typeof input === \"number\"\n\n/**\n * Tests if a value is a `boolean`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isBoolean } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isBoolean(true), true)\n *\n * assert.deepStrictEqual(isBoolean(\"true\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isBoolean = (input: unknown): input is boolean => typeof input === \"boolean\"\n\n/**\n * Tests if a value is a `bigint`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isBigInt } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isBigInt(1n), true)\n *\n * assert.deepStrictEqual(isBigInt(1), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isBigInt = (input: unknown): input is bigint => typeof input === \"bigint\"\n\n/**\n * Tests if a value is a `symbol`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isSymbol } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isSymbol(Symbol.for(\"a\")), true)\n *\n * assert.deepStrictEqual(isSymbol(\"a\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isSymbol = (input: unknown): input is symbol => typeof input === \"symbol\"\n\n/**\n * Tests if a value is a `function`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isFunction } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isFunction(isFunction), true)\n *\n * assert.deepStrictEqual(isFunction(\"function\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isFunction: (input: unknown) => input is Function = isFunction_\n\n/**\n * Tests if a value is `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isUndefined } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isUndefined(undefined), true)\n *\n * assert.deepStrictEqual(isUndefined(null), false)\n * assert.deepStrictEqual(isUndefined(\"undefined\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isUndefined = (input: unknown): input is undefined => input === undefined\n\n/**\n * Tests if a value is not `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNotUndefined } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNotUndefined(null), true)\n * assert.deepStrictEqual(isNotUndefined(\"undefined\"), true)\n *\n * assert.deepStrictEqual(isNotUndefined(undefined), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNotUndefined = <A>(input: A): input is Exclude<A, undefined> => input !== undefined\n\n/**\n * Tests if a value is `null`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNull } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNull(null), true)\n *\n * assert.deepStrictEqual(isNull(undefined), false)\n * assert.deepStrictEqual(isNull(\"null\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNull = (input: unknown): input is null => input === null\n\n/**\n * Tests if a value is not `null`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNotNull } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNotNull(undefined), true)\n * assert.deepStrictEqual(isNotNull(\"null\"), true)\n *\n * assert.deepStrictEqual(isNotNull(null), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNotNull = <A>(input: A): input is Exclude<A, null> => input !== null\n\n/**\n * A guard that always fails.\n *\n * @param _ - The value to test.\n *\n * @example\n * import { isNever } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNever(null), false)\n * assert.deepStrictEqual(isNever(undefined), false)\n * assert.deepStrictEqual(isNever({}), false)\n * assert.deepStrictEqual(isNever([]), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNever: (input: unknown) => input is never = (_: unknown): _ is never => false\n\n/**\n * A guard that always succeeds.\n *\n * @param _ - The value to test.\n *\n * @example\n * import { isUnknown } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isUnknown(null), true)\n * assert.deepStrictEqual(isUnknown(undefined), true)\n *\n * assert.deepStrictEqual(isUnknown({}), true)\n * assert.deepStrictEqual(isUnknown([]), true)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isUnknown: (input: unknown) => input is unknown = (_): _ is unknown => true\n\nconst isRecordOrArray = (input: unknown) => typeof input === \"object\" && input !== null\n\n/**\n * Tests if a value is an `object`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isObject } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isObject({}), true)\n * assert.deepStrictEqual(isObject([]), true)\n *\n * assert.deepStrictEqual(isObject(null), false)\n * assert.deepStrictEqual(isObject(undefined), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isObject = (input: unknown): input is object => isRecordOrArray(input) || isFunction(input)\n\n/**\n * Checks whether a value is an `object` containing a specified property key.\n *\n * @param property - The field to check within the object.\n * @param self - The value to examine.\n *\n * @category guards\n * @since 2.0.0\n */\nexport const hasProperty: {\n  <P extends PropertyKey>(property: P): (self: unknown) => self is { [K in P]: unknown }\n  <P extends PropertyKey>(self: unknown, property: P): self is { [K in P]: unknown }\n} = dual(\n  2,\n  <P extends PropertyKey>(self: unknown, property: P): self is { [K in P]: unknown } =>\n    isObject(self) && (property in self)\n)\n\n/**\n * Tests if a value is an `object` with a property `_tag` that matches the given tag.\n *\n * @param input - The value to test.\n * @param tag - The tag to test for.\n *\n * @example\n * import { isTagged } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isTagged(1, \"a\"), false)\n * assert.deepStrictEqual(isTagged(null, \"a\"), false)\n * assert.deepStrictEqual(isTagged({}, \"a\"), false)\n * assert.deepStrictEqual(isTagged({ a: \"a\" }, \"a\"), false)\n * assert.deepStrictEqual(isTagged({ _tag: \"a\" }, \"a\"), true)\n * assert.deepStrictEqual(isTagged(\"a\")({ _tag: \"a\" }), true)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isTagged: {\n  <K extends string>(tag: K): (self: unknown) => self is { _tag: K }\n  <K extends string>(self: unknown, tag: K): self is { _tag: K }\n} = dual(\n  2,\n  <K extends string>(self: unknown, tag: K): self is { _tag: K } => hasProperty(self, \"_tag\") && self[\"_tag\"] === tag\n)\n\n/**\n * A guard that succeeds when the input is `null` or `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNullable } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNullable(null), true)\n * assert.deepStrictEqual(isNullable(undefined), true)\n *\n * assert.deepStrictEqual(isNullable({}), false)\n * assert.deepStrictEqual(isNullable([]), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNullable = <A>(input: A): input is Extract<A, null | undefined> => input === null || input === undefined\n\n/**\n * A guard that succeeds when the input is not `null` or `undefined`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isNotNullable } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isNotNullable({}), true)\n * assert.deepStrictEqual(isNotNullable([]), true)\n *\n * assert.deepStrictEqual(isNotNullable(null), false)\n * assert.deepStrictEqual(isNotNullable(undefined), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNotNullable = <A>(input: A): input is NonNullable<A> => input !== null && input !== undefined\n\n/**\n * A guard that succeeds when the input is an `Error`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isError } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isError(new Error()), true)\n *\n * assert.deepStrictEqual(isError(null), false)\n * assert.deepStrictEqual(isError({}), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isError = (input: unknown): input is Error => input instanceof Error\n\n/**\n * A guard that succeeds when the input is a `Uint8Array`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isUint8Array } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isUint8Array(new Uint8Array()), true)\n *\n * assert.deepStrictEqual(isUint8Array(null), false)\n * assert.deepStrictEqual(isUint8Array({}), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isUint8Array = (input: unknown): input is Uint8Array => input instanceof Uint8Array\n\n/**\n * A guard that succeeds when the input is a `Date`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isDate } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isDate(new Date()), true)\n *\n * assert.deepStrictEqual(isDate(null), false)\n * assert.deepStrictEqual(isDate({}), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isDate = (input: unknown): input is Date => input instanceof Date\n\n/**\n * A guard that succeeds when the input is an `Iterable`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isIterable } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isIterable([]), true)\n * assert.deepStrictEqual(isIterable(new Set()), true)\n *\n * assert.deepStrictEqual(isIterable(null), false)\n * assert.deepStrictEqual(isIterable({}), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isIterable = (input: unknown): input is Iterable<unknown> => hasProperty(input, Symbol.iterator)\n\n/**\n * A guard that succeeds when the input is a record.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isRecord } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isRecord({}), true)\n * assert.deepStrictEqual(isRecord({ a: 1 }), true)\n *\n * assert.deepStrictEqual(isRecord([]), false)\n * assert.deepStrictEqual(isRecord([1, 2, 3]), false)\n * assert.deepStrictEqual(isRecord(null), false)\n * assert.deepStrictEqual(isRecord(undefined), false)\n * assert.deepStrictEqual(isRecord(() => null), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isRecord = (input: unknown): input is { [x: string | symbol]: unknown } =>\n  isRecordOrArray(input) && !Array.isArray(input)\n\n/**\n * A guard that succeeds when the input is a readonly record.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isReadonlyRecord } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isReadonlyRecord({}), true)\n * assert.deepStrictEqual(isReadonlyRecord({ a: 1 }), true)\n *\n * assert.deepStrictEqual(isReadonlyRecord([]), false)\n * assert.deepStrictEqual(isReadonlyRecord([1, 2, 3]), false)\n * assert.deepStrictEqual(isReadonlyRecord(null), false)\n * assert.deepStrictEqual(isReadonlyRecord(undefined), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isReadonlyRecord: (\n  input: unknown\n) => input is { readonly [x: string | symbol]: unknown } = isRecord\n\n/**\n * A guard that succeeds when the input is a Promise.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isPromise } from \"effect/Predicate\"\n *\n * assert.deepStrictEqual(isPromise({}), false)\n * assert.deepStrictEqual(isPromise(Promise.resolve(\"hello\")), true)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isPromise = (\n  input: unknown\n): input is Promise<unknown> =>\n  hasProperty(input, \"then\") && \"catch\" in input && isFunction(input.then) && isFunction(input.catch)\n\n/**\n * @category guards\n * @since 2.0.0\n */\nexport const isPromiseLike = (\n  input: unknown\n): input is PromiseLike<unknown> => hasProperty(input, \"then\") && isFunction(input.then)\n\n/**\n * @since 2.0.0\n */\nexport const compose: {\n  <A, B extends A, C extends B>(bc: Refinement<B, C>): (ab: Refinement<A, B>) => Refinement<A, C>\n  <A, B extends A, C extends B>(ab: Refinement<A, B>, bc: Refinement<B, C>): Refinement<A, C>\n} = dual(\n  2,\n  <A, B extends A, C extends B>(ab: Refinement<A, B>, bc: Refinement<B, C>): Refinement<A, C> => (a): a is C =>\n    ab(a) && bc(a)\n)\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const product =\n  <A, B>(self: Predicate<A>, that: Predicate<B>): Predicate<readonly [A, B]> /* readonly because contravariant */ =>\n  ([a, b]) => self(a) && that(b)\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const all = <A>(\n  collection: Iterable<Predicate<A>>\n): Predicate<ReadonlyArray<A>> => {\n  return (as) => {\n    let collectionIndex = 0\n    for (const p of collection) {\n      if (collectionIndex >= as.length) {\n        break\n      }\n      if (p(as[collectionIndex]) === false) {\n        return false\n      }\n      collectionIndex++\n    }\n    return true\n  }\n}\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const productMany = <A>(\n  self: Predicate<A>,\n  collection: Iterable<Predicate<A>>\n): Predicate<readonly [A, ...Array<A>]> /* readonly because contravariant */ => {\n  const rest = all(collection)\n  return ([head, ...tail]) => self(head) === false ? false : rest(tail)\n}\n\n/**\n * Similar to `Promise.all` but operates on `Predicate`s.\n *\n * ```\n * [Predicate<A>, Predicate<B>, ...] -> Predicate<[A, B, ...]>\n * ```\n *\n * @since 2.0.0\n */\nexport const tuple = <T extends ReadonlyArray<Predicate<any>>>(\n  ...elements: T\n): Predicate<Readonly<{ [I in keyof T]: [T[I]] extends [Predicate<infer A>] ? A : never }>> => all(elements) as any\n\n/**\n * @since 2.0.0\n */\nexport const struct = <R extends Record<string, Predicate<any>>>(\n  fields: R\n): Predicate<{ readonly [K in keyof R]: [R[K]] extends [Predicate<infer A>] ? A : never }> => {\n  const keys = Object.keys(fields)\n  return (a) => {\n    for (const key of keys) {\n      if (!fields[key](a[key])) {\n        return false\n      }\n    }\n    return true\n  }\n}\n\n/**\n * Negates the result of a given predicate.\n *\n * @param self - A predicate.\n *\n * @example\n * import * as P from \"effect/Predicate\"\n * import * as N from \"effect/Number\"\n *\n * const isPositive = P.not(N.lessThan(0))\n *\n * assert.deepStrictEqual(isPositive(-1), false)\n * assert.deepStrictEqual(isPositive(0), true)\n * assert.deepStrictEqual(isPositive(1), true)\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const not = <A>(self: Predicate<A>): Predicate<A> => (a) => !self(a)\n\n/**\n * Combines two predicates into a new predicate that returns `true` if at least one of the predicates returns `true`.\n *\n * @param self - A predicate.\n * @param that - A predicate.\n *\n * @example\n * import * as P from \"effect/Predicate\"\n * import * as N from \"effect/Number\"\n *\n * const nonZero = P.or(N.lessThan(0), N.greaterThan(0))\n *\n * assert.deepStrictEqual(nonZero(-1), true)\n * assert.deepStrictEqual(nonZero(0), false)\n * assert.deepStrictEqual(nonZero(1), true)\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const or: {\n  <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>\n} = dual(2, <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A> => (a) => self(a) || that(a))\n\n/**\n * Combines two predicates into a new predicate that returns `true` if both of the predicates returns `true`.\n *\n * @param self - A predicate.\n * @param that - A predicate.\n *\n * @example\n * import * as P from \"effect/Predicate\"\n *\n * const minLength = (n: number) => (s: string) => s.length >= n\n * const maxLength = (n: number) => (s: string) => s.length <= n\n *\n * const length = (n: number) => P.and(minLength(n), maxLength(n))\n *\n * assert.deepStrictEqual(length(2)(\"aa\"), true)\n * assert.deepStrictEqual(length(2)(\"a\"), false)\n * assert.deepStrictEqual(length(2)(\"aaa\"), false)\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const and: {\n  <A, C extends A>(that: Refinement<A, C>): <B extends A>(self: Refinement<A, B>) => Refinement<A, B & C>\n  <A, B extends A, C extends A>(self: Refinement<A, B>, that: Refinement<A, C>): Refinement<A, B & C>\n  <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>\n} = dual(2, <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A> => (a) => self(a) && that(a))\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport const xor: {\n  <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>\n} = dual(2, <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A> => (a) => self(a) !== that(a))\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport const eqv: {\n  <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>\n} = dual(2, <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A> => (a) => self(a) === that(a))\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport const implies: {\n  <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>\n} = dual(\n  2,\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A> => (a) => self(a) ? that(a) : true\n)\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport const nor: {\n  <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>\n} = dual(\n  2,\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A> => (a) => !(self(a) || that(a))\n)\n\n/**\n * @category combinators\n * @since 2.0.0\n */\nexport const nand: {\n  <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>\n} = dual(\n  2,\n  <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A> => (a) => !(self(a) && that(a))\n)\n\n/**\n * @category elements\n * @since 2.0.0\n */\nexport const every = <A>(collection: Iterable<Predicate<A>>): Predicate<A> => (a: A) => {\n  for (const p of collection) {\n    if (!p(a)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * @category elements\n * @since 2.0.0\n */\nexport const some = <A>(collection: Iterable<Predicate<A>>): Predicate<A> => (a) => {\n  for (const p of collection) {\n    if (p(a)) {\n      return true\n    }\n  }\n  return false\n}\n", "/**\n * @since 2.0.0\n */\nimport type { TypeLambda } from \"./HKT.js\"\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface FunctionTypeLambda extends TypeLambda {\n  readonly type: (a: this[\"In\"]) => this[\"Target\"]\n}\n\n/**\n * Tests if a value is a `function`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isFunction } from 'effect/Predicate'\n *\n * assert.deepStrictEqual(isFunction(isFunction), true)\n * assert.deepStrictEqual(isFunction(\"function\"), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isFunction = (input: unknown): input is Function => typeof input === \"function\"\n\n/**\n * Creates a function that can be used in a data-last (aka `pipe`able) or\n * data-first style.\n *\n * The first parameter to `dual` is either the arity of the uncurried function\n * or a predicate that determines if the function is being used in a data-first\n * or data-last style.\n *\n * Using the arity is the most common use case, but there are some cases where\n * you may want to use a predicate. For example, if you have a function that\n * takes an optional argument, you can use a predicate to determine if the\n * function is being used in a data-first or data-last style.\n *\n * @param arity - Either the arity of the uncurried function or a predicate\n *                which determines if the function is being used in a data-first\n *                or data-last style.\n * @param body - The definition of the uncurried function.\n *\n * @example\n * import { dual, pipe } from \"effect/Function\"\n *\n * // Exampe using arity to determine data-first or data-last style\n * const sum: {\n *   (that: number): (self: number) => number\n *   (self: number, that: number): number\n * } = dual(2, (self: number, that: number): number => self + that)\n *\n * assert.deepStrictEqual(sum(2, 3), 5)\n * assert.deepStrictEqual(pipe(2, sum(3)), 5)\n *\n * // Example using a predicate to determine data-first or data-last style\n * const sum2: {\n *   (that: number): (self: number) => number\n *   (self: number, that: number): number\n * } = dual((args) => args.length === 1, (self: number, that: number): number => self + that)\n *\n * assert.deepStrictEqual(sum(2, 3), 5)\n * assert.deepStrictEqual(pipe(2, sum(3)), 5)\n *\n * @since 2.0.0\n */\nexport const dual: {\n  <DataLast extends (...args: Array<any>) => any, DataFirst extends (...args: Array<any>) => any>(\n    arity: Parameters<DataFirst>[\"length\"],\n    body: DataFirst\n  ): DataLast & DataFirst\n  <DataLast extends (...args: Array<any>) => any, DataFirst extends (...args: Array<any>) => any>(\n    isDataFirst: (args: IArguments) => boolean,\n    body: DataFirst\n  ): DataLast & DataFirst\n} = function(arity, body) {\n  if (typeof arity === \"function\") {\n    return function() {\n      if (arity(arguments)) {\n        // @ts-expect-error\n        return body.apply(this, arguments)\n      }\n      return ((self: any) => body(self, ...arguments)) as any\n    }\n  }\n\n  switch (arity) {\n    case 0:\n    case 1:\n      throw new RangeError(`Invalid arity ${arity}`)\n\n    case 2:\n      return function(a, b) {\n        if (arguments.length >= 2) {\n          return body(a, b)\n        }\n        return function(self: any) {\n          return body(self, a)\n        }\n      }\n\n    case 3:\n      return function(a, b, c) {\n        if (arguments.length >= 3) {\n          return body(a, b, c)\n        }\n        return function(self: any) {\n          return body(self, a, b)\n        }\n      }\n\n    case 4:\n      return function(a, b, c, d) {\n        if (arguments.length >= 4) {\n          return body(a, b, c, d)\n        }\n        return function(self: any) {\n          return body(self, a, b, c)\n        }\n      }\n\n    case 5:\n      return function(a, b, c, d, e) {\n        if (arguments.length >= 5) {\n          return body(a, b, c, d, e)\n        }\n        return function(self: any) {\n          return body(self, a, b, c, d)\n        }\n      }\n\n    default:\n      return function() {\n        if (arguments.length >= arity) {\n          // @ts-expect-error\n          return body.apply(this, arguments)\n        }\n        const args = arguments\n        return function(self: any) {\n          return body(self, ...args)\n        }\n      }\n  }\n}\n/**\n * Apply a function to a given value.\n *\n * @param a - The value that the function will be applied to.\n * @param self - The function to be applied to a value.\n *\n * @example\n * import { pipe, apply } from \"effect/Function\"\n * import { length } from 'effect/String'\n *\n * assert.deepStrictEqual(pipe(length, apply(\"hello\")), 5)\n *\n * @since 2.0.0\n */\nexport const apply = <A>(a: A) => <B>(self: (a: A) => B): B => self(a)\n\n/**\n * A lazy argument.\n *\n * @example\n * import { LazyArg, constant } from \"effect/Function\"\n *\n * const constNull: LazyArg<null> = constant(null)\n *\n * @since 2.0.0\n */\nexport interface LazyArg<A> {\n  (): A\n}\n\n/**\n * @example\n * import { FunctionN } from \"effect/Function\"\n *\n * const sum: FunctionN<[number, number], number> = (a, b) => a + b\n *\n * @since 2.0.0\n */\nexport interface FunctionN<A extends ReadonlyArray<unknown>, B> {\n  (...args: A): B\n}\n\n/**\n * The identity function, i.e. A function that returns its input argument.\n *\n * @param a - The input argument.\n *\n * @example\n * import { identity } from \"effect/Function\"\n *\n * assert.deepStrictEqual(identity(5), 5)\n *\n * @since 2.0.0\n */\nexport const identity = <A>(a: A): A => a\n\n/**\n * A function that ensures that the type of an expression matches some type,\n * without changing the resulting type of that expression.\n *\n * @example\n * import { satisfies } from \"effect/Function\"\n *\n * const test1 = satisfies<number>()(5 as const)\n *     //^? const test: 5\n *     // @ts-expect-error\n * const test2 = satisfies<string>()(5)\n *     //^? Argument of type 'number' is not assignable to parameter of type 'string'\n *\n * assert.deepStrictEqual(satisfies<number>()(5), 5)\n *\n * @since 2.0.0\n */\nexport const satisfies = <A>() => <B extends A>(b: B) => b\n\n/**\n * Casts the result to the specified type.\n *\n * @param a - The value to be casted to the target type.\n *\n * @example\n * import { unsafeCoerce, identity } from \"effect/Function\"\n *\n * assert.deepStrictEqual(unsafeCoerce, identity)\n *\n * @since 2.0.0\n */\nexport const unsafeCoerce: <A, B>(a: A) => B = identity as any\n\n/**\n * Creates a constant value that never changes.\n *\n * This is useful when you want to pass a value to a higher-order function (a function that takes another function as its argument)\n * and want that inner function to always use the same value, no matter how many times it is called.\n *\n * @param value - The constant value to be returned.\n *\n * @example\n * import { constant } from \"effect/Function\"\n *\n * const constNull = constant(null)\n *\n * assert.deepStrictEqual(constNull(), null)\n * assert.deepStrictEqual(constNull(), null)\n *\n * @since 2.0.0\n */\nexport const constant = <A>(value: A): LazyArg<A> => () => value\n\n/**\n * A thunk that returns always `true`.\n *\n * @example\n * import { constTrue } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constTrue(), true)\n *\n * @since 2.0.0\n */\nexport const constTrue: LazyArg<boolean> = constant(true)\n\n/**\n * A thunk that returns always `false`.\n *\n * @example\n * import { constFalse } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constFalse(), false)\n *\n * @since 2.0.0\n */\nexport const constFalse: LazyArg<boolean> = constant(false)\n\n/**\n * A thunk that returns always `null`.\n *\n * @example\n * import { constNull } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constNull(), null)\n *\n * @since 2.0.0\n */\nexport const constNull: LazyArg<null> = constant(null)\n\n/**\n * A thunk that returns always `undefined`.\n *\n * @example\n * import { constUndefined } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constUndefined(), undefined)\n *\n * @since 2.0.0\n */\nexport const constUndefined: LazyArg<undefined> = constant(undefined)\n\n/**\n * A thunk that returns always `void`.\n *\n * @example\n * import { constVoid } from \"effect/Function\"\n *\n * assert.deepStrictEqual(constVoid(), undefined)\n *\n * @since 2.0.0\n */\nexport const constVoid: LazyArg<void> = constUndefined\n\n/**\n * Reverses the order of arguments for a curried function.\n *\n * @param f - A curried function that takes multiple arguments.\n *\n * @example\n * import { flip } from \"effect/Function\"\n *\n * const f = (a: number) => (b: string) => a - b.length\n *\n * assert.deepStrictEqual(flip(f)('aaa')(2), -1)\n *\n * @since 2.0.0\n */\nexport const flip = <A extends Array<unknown>, B extends Array<unknown>, C>(\n  f: (...a: A) => (...b: B) => C\n): (...b: B) => (...a: A) => C =>\n(...b) =>\n(...a) => f(...a)(...b)\n\n/**\n * Composes two functions, `ab` and `bc` into a single function that takes in an argument `a` of type `A` and returns a result of type `C`.\n * The result is obtained by first applying the `ab` function to `a` and then applying the `bc` function to the result of `ab`.\n *\n * @param ab - A function that maps from `A` to `B`.\n * @param bc - A function that maps from `B` to `C`.\n *\n * @example\n * import { compose } from \"effect/Function\"\n *\n * const increment = (n: number) => n + 1;\n * const square = (n: number) => n * n;\n *\n * assert.strictEqual(compose(increment, square)(2), 9);\n *\n * @since 2.0.0\n */\nexport const compose: {\n  <B, C>(bc: (b: B) => C): <A>(self: (a: A) => B) => (a: A) => C\n  <A, B, C>(self: (a: A) => B, bc: (b: B) => C): (a: A) => C\n} = dual(2, <A, B, C>(ab: (a: A) => B, bc: (b: B) => C): (a: A) => C => (a) => bc(ab(a)))\n\n/**\n * The `absurd` function is a stub for cases where a value of type `never` is encountered in your code,\n * meaning that it should be impossible for this code to be executed.\n *\n * This function is particularly when it's necessary to specify that certain cases are impossible.\n *\n * @since 2.0.0\n */\nexport const absurd = <A>(_: never): A => {\n  throw new Error(\"Called `absurd` function which should be uncallable\")\n}\n\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from \"effect/Function\"\n *\n * const sumTupled = tupled((x: number, y: number): number => x + y)\n *\n * assert.deepStrictEqual(sumTupled([1, 2]), 3)\n *\n * @since 2.0.0\n */\nexport const tupled = <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B): (a: A) => B => (a) => f(...a)\n\n/**\n * Inverse function of `tupled`\n *\n * @example\n * import { untupled } from \"effect/Function\"\n *\n * const getFirst = untupled(<A, B>(tuple: [A, B]): A => tuple[0])\n *\n * assert.deepStrictEqual(getFirst(1, 2), 1)\n *\n * @since 2.0.0\n */\nexport const untupled = <A extends ReadonlyArray<unknown>, B>(f: (a: A) => B): (...a: A) => B => (...a) => f(a)\n\n/**\n * Pipes the value of an expression into a pipeline of functions.\n *\n * This is useful in combination with data-last functions as a simulation of methods:\n *\n * ```\n * as.map(f).filter(g) -> pipe(as, map(f), filter(g))\n * ```\n *\n * @example\n * import { pipe } from \"effect/Function\"\n *\n * const length = (s: string): number => s.length\n * const double = (n: number): number => n * 2\n * const decrement = (n: number): number => n - 1\n *\n * assert.deepStrictEqual(pipe(length(\"hello\"), double, decrement), 9)\n *\n * @since 2.0.0\n */\nexport function pipe<A>(a: A): A\nexport function pipe<A, B>(a: A, ab: (a: A) => B): B\nexport function pipe<A, B, C>(a: A, ab: (a: A) => B, bc: (b: B) => C): C\nexport function pipe<A, B, C, D>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D): D\nexport function pipe<A, B, C, D, E>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E\n): E\nexport function pipe<A, B, C, D, E, F>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F\n): F\nexport function pipe<A, B, C, D, E, F, G>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G\n): G\nexport function pipe<A, B, C, D, E, F, G, H>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H\n): H\nexport function pipe<A, B, C, D, E, F, G, H, I>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I\n): I\nexport function pipe<A, B, C, D, E, F, G, H, I, J>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J\n): J\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K\n): K\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L\n): L\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M\n): M\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N\n): N\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O\n): O\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n  op: (o: O) => P\n): P\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n  op: (o: O) => P,\n  pq: (p: P) => Q\n): Q\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n  op: (o: O) => P,\n  pq: (p: P) => Q,\n  qr: (q: Q) => R\n): R\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n  op: (o: O) => P,\n  pq: (p: P) => Q,\n  qr: (q: Q) => R,\n  rs: (r: R) => S\n): S\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(\n  a: A,\n  ab: (a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J,\n  jk: (j: J) => K,\n  kl: (k: K) => L,\n  lm: (l: L) => M,\n  mn: (m: M) => N,\n  no: (n: N) => O,\n  op: (o: O) => P,\n  pq: (p: P) => Q,\n  qr: (q: Q) => R,\n  rs: (r: R) => S,\n  st: (s: S) => T\n): T\nexport function pipe(\n  a: unknown,\n  ab?: Function,\n  bc?: Function,\n  cd?: Function,\n  de?: Function,\n  ef?: Function,\n  fg?: Function,\n  gh?: Function,\n  hi?: Function\n): unknown {\n  switch (arguments.length) {\n    case 1:\n      return a\n    case 2:\n      return ab!(a)\n    case 3:\n      return bc!(ab!(a))\n    case 4:\n      return cd!(bc!(ab!(a)))\n    case 5:\n      return de!(cd!(bc!(ab!(a))))\n    case 6:\n      return ef!(de!(cd!(bc!(ab!(a)))))\n    case 7:\n      return fg!(ef!(de!(cd!(bc!(ab!(a))))))\n    case 8:\n      return gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))))\n    case 9:\n      return hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a))))))))\n    default: {\n      let ret = arguments[0]\n      for (let i = 1; i < arguments.length; i++) {\n        ret = arguments[i](ret)\n      }\n      return ret\n    }\n  }\n}\n\n/**\n * Performs left-to-right function composition. The first argument may have any arity, the remaining arguments must be unary.\n *\n * See also [`pipe`](#pipe).\n *\n * @example\n * import { flow } from \"effect/Function\"\n *\n * const len = (s: string): number => s.length\n * const double = (n: number): number => n * 2\n *\n * const f = flow(len, double)\n *\n * assert.strictEqual(f('aaa'), 6)\n *\n * @since 2.0.0\n */\nexport function flow<A extends ReadonlyArray<unknown>, B>(ab: (...a: A) => B): (...a: A) => B\nexport function flow<A extends ReadonlyArray<unknown>, B, C>(ab: (...a: A) => B, bc: (b: B) => C): (...a: A) => C\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D\n): (...a: A) => D\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E\n): (...a: A) => E\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F\n): (...a: A) => F\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G\n): (...a: A) => G\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G, H>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H\n): (...a: A) => H\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G, H, I>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I\n): (...a: A) => I\nexport function flow<A extends ReadonlyArray<unknown>, B, C, D, E, F, G, H, I, J>(\n  ab: (...a: A) => B,\n  bc: (b: B) => C,\n  cd: (c: C) => D,\n  de: (d: D) => E,\n  ef: (e: E) => F,\n  fg: (f: F) => G,\n  gh: (g: G) => H,\n  hi: (h: H) => I,\n  ij: (i: I) => J\n): (...a: A) => J\nexport function flow(\n  ab: Function,\n  bc?: Function,\n  cd?: Function,\n  de?: Function,\n  ef?: Function,\n  fg?: Function,\n  gh?: Function,\n  hi?: Function,\n  ij?: Function\n): unknown {\n  switch (arguments.length) {\n    case 1:\n      return ab\n    case 2:\n      return function(this: unknown) {\n        return bc!(ab.apply(this, arguments))\n      }\n    case 3:\n      return function(this: unknown) {\n        return cd!(bc!(ab.apply(this, arguments)))\n      }\n    case 4:\n      return function(this: unknown) {\n        return de!(cd!(bc!(ab.apply(this, arguments))))\n      }\n    case 5:\n      return function(this: unknown) {\n        return ef!(de!(cd!(bc!(ab.apply(this, arguments)))))\n      }\n    case 6:\n      return function(this: unknown) {\n        return fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments))))))\n      }\n    case 7:\n      return function(this: unknown) {\n        return gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments)))))))\n      }\n    case 8:\n      return function(this: unknown) {\n        return hi!(gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments))))))))\n      }\n    case 9:\n      return function(this: unknown) {\n        return ij!(hi!(gh!(fg!(ef!(de!(cd!(bc!(ab.apply(this, arguments)))))))))\n      }\n  }\n  return\n}\n\n/**\n * Type hole simulation.\n *\n * @since 2.0.0\n */\nexport const hole: <T>() => T = unsafeCoerce(absurd)\n\n/**\n * The SK combinator, also known as the \"S-K combinator\" or \"S-combinator\", is a fundamental combinator in the\n * lambda calculus and the SKI combinator calculus.\n *\n * This function is useful for discarding the first argument passed to it and returning the second argument.\n *\n * @param _ - The first argument to be discarded.\n * @param b - The second argument to be returned.\n *\n * @example\n * import { SK } from \"effect/Function\";\n *\n * assert.deepStrictEqual(SK(0, \"hello\"), \"hello\")\n *\n * @since 2.0.0\n */\nexport const SK = <A, B>(_: A, b: B): B => b\n"],
  "mappings": "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",
  "names": ["compose", "isFunction", "isFunction", "input", "dual", "arity", "body", "arguments", "apply", "self", "RangeError", "a", "b", "length", "c", "d", "e", "args", "identity", "satisfies", "unsafeCoerce", "constant", "value", "constTrue", "constFalse", "constNull", "constUndefined", "undefined", "constVoid", "flip", "f", "compose", "ab", "bc", "absurd", "_", "Error", "tupled", "untupled", "pipe", "cd", "de", "ef", "fg", "gh", "hi", "ret", "i", "flow", "ij", "hole", "SK", "mapInput", "dual", "self", "f", "b", "isTruthy", "input", "isSet", "Set", "isMap", "Map", "isString", "isNumber", "isBoolean", "isBigInt", "isSymbol", "isFunction", "isFunction_", "isUndefined", "undefined", "isNotUndefined", "isNull", "isNotNull", "isNever", "_", "isUnknown", "isRecordOrArray", "isObject", "hasProperty", "property", "isTagged", "tag", "isNullable", "isNotNullable", "isError", "Error", "isUint8Array", "Uint8Array", "isDate", "Date", "isIterable", "Symbol", "iterator", "isRecord", "Array", "isArray", "isReadonlyRecord", "isPromise", "then", "catch", "isPromiseLike", "compose", "ab", "bc", "a", "product", "that", "all", "collection", "as", "collectionIndex", "p", "length", "productMany", "rest", "head", "tail", "tuple", "elements", "struct", "fields", "keys", "Object", "key", "not", "or", "and", "xor", "eqv", "implies", "nor", "nand", "every", "some"]
}
