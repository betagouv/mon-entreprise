{
  "version": 3,
  "sources": ["../../../../node_modules/isbot/src/amend/index.js", "../../../../node_modules/isbot/src/isbot/index.js", "../../../../node_modules/isbot/src/index.js"],
  "sourcesContent": ["/**\n * Mutate given list of patter strings\n * @param {string[]} list\n * @returns {string[]}\n */\nexport function amend (list) {\n  try {\n    // Risk: Uses lookbehind assertion, avoid breakage in parsing by using RegExp constructor\n    new RegExp('(?<! cu)bot').test('dangerbot') // eslint-disable-line prefer-regex-literals\n  } catch (error) {\n    // Skip regex fixes\n    return list\n  }\n\n  [\n    // Addresses: Cubot device\n    ['bot', '(?<! cu)bot'],\n    // Addresses: Android webview\n    ['google', '(?<! (?:channel/|google/))google(?!(app|/google| pixel))'],\n    // Addresses: libhttp browser\n    ['http', '(?<!(?:lib))http'],\n    // Addresses: java based browsers\n    ['java', 'java(?!;)'],\n    // Addresses: Yandex Search App\n    ['search', '(?<! ya(?:yandex)?)search']\n  ].forEach(\n    ([search, replace]) => {\n      const index = list.lastIndexOf(search)\n      if (~index) {\n        list.splice(index, 1, replace)\n      }\n    }\n  )\n\n  return list\n}\n", "import list from '../list.json' assert { type: 'json' }\nimport { amend } from '../amend/index.js'\n\namend(list)\n\nconst flags = 'i'\n\n/**\n * Test user agents for matching patterns\n */\nexport class Isbot {\n  /**\n   * @type {string[]}\n   */\n  #list\n\n  /**\n   * @type {RegExp}\n   */\n  #pattern\n\n  constructor (patterns) {\n    this.#list = patterns || list.slice()\n    this.#update()\n\n    const isbot = ua => this.test(ua)\n\n    return Object.defineProperties(\n      isbot,\n      Object.entries(Object.getOwnPropertyDescriptors(Isbot.prototype)).reduce(\n        (accumulator, [prop, descriptor]) => {\n          if (typeof descriptor.value === 'function') {\n            Object.assign(\n              accumulator,\n              { [prop]: { value: this[prop].bind(this) } }\n            )\n          }\n          if (typeof descriptor.get === 'function') {\n            Object.assign(\n              accumulator,\n              { [prop]: { get: () => this[prop] } }\n            )\n          }\n          return accumulator\n        },\n        {}\n      )\n    )\n  }\n\n  /**\n   * Recreate the pattern from rules list\n   */\n  #update () {\n    this.#pattern = new RegExp(\n      this.#list.join('|'),\n      flags\n    )\n  }\n\n  /**\n   * Find the first index of an existing rule or -1 if not found\n   * @param  {string} rule\n   * @returns {number}\n   */\n  #index (rule) {\n    return this.#list.indexOf(rule.toLowerCase())\n  }\n\n  /**\n   * Get a clone of the pattern\n   * @type RegExp\n   */\n  get pattern () {\n    return new RegExp(this.#pattern)\n  }\n\n  /**\n   * Match given string against out pattern\n   * @param  {string} ua User Agent string\n   * @returns {boolean}\n   */\n  test (ua) {\n    return Boolean(ua) && this.#pattern.test(ua)\n  }\n\n  /**\n   * Get the match for strings' known crawler pattern\n   * @param  {string} ua User Agent string\n   * @returns {string|null}\n   */\n  find (ua = '') {\n    const match = ua.match(this.#pattern)\n    return match && match[0]\n  }\n\n  /**\n   * Get the patterns that match user agent string if any\n   * @param  {string} ua User Agent string\n   * @returns {string[]}\n   */\n  matches (ua = '') {\n    return this.#list.filter(\n      entry => new RegExp(entry, flags).test(ua)\n    )\n  }\n\n  /**\n   * Clear all patterns that match user agent\n   * @param  {string} ua User Agent string\n   * @returns {void}\n   */\n  clear (ua = '') {\n    this.exclude(this.matches(ua))\n  }\n\n  /**\n   * Extent patterns for known crawlers\n   * @param  {string[]} filters\n   * @returns {void}\n   */\n  extend (filters = []) {\n    [].push.apply(\n      this.#list,\n      filters.filter(\n        rule => this.#index(rule) === -1\n      ).map(\n        filter => filter.toLowerCase()\n      )\n    )\n    this.#update()\n  }\n\n  /**\n   * Exclude patterns from bot pattern rule\n   * @param  {string[]} filters\n   * @returns {void}\n   */\n  exclude (filters = []) {\n    let { length } = filters\n    while (length--) {\n      const index = this.#index(filters[length])\n      if (index > -1) {\n        this.#list.splice(index, 1)\n      }\n    }\n    this.#update()\n  }\n\n  /**\n   * Create a new Isbot instance using given list or self's list\n   * @param  {string[]} [list]\n   * @returns {Isbot}\n   */\n  spawn (list) {\n    return new Isbot(list || this.#list)\n  }\n}\n", "import { Isbot } from './isbot/index.js'\n\nconst isbot = new Isbot()\n\nexport default isbot\n"],
  "mappings": "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",
  "names": ["amend", "list", "RegExp", "test", "error", "forEach", "_ref", "search", "replace", "index", "lastIndexOf", "splice", "flags", "_list", "WeakMap", "_pattern", "_update", "WeakSet", "_index", "Isbot", "constructor", "patterns", "_classPrivateMethodInitSpec", "_classPrivateFieldInitSpec", "writable", "value", "_classPrivateFieldSet", "slice", "_classPrivateMethodGet", "_update2", "call", "isbot", "ua", "Object", "defineProperties", "entries", "getOwnPropertyDescriptors", "prototype", "reduce", "accumulator", "prop", "descriptor", "assign", "bind", "get", "pattern", "_classPrivateFieldGet", "Boolean", "find", "arguments", "length", "undefined", "match", "matches", "filter", "entry", "clear", "exclude", "extend", "filters", "push", "apply", "rule", "_index2", "map", "toLowerCase", "spawn", "join", "indexOf"]
}
