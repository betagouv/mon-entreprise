import {
  __export
} from "./chunk-2LSFTFF7.js";

// ../node_modules/effect/dist/esm/Predicate.js
var Predicate_exports = {};
__export(Predicate_exports, {
  all: () => all,
  and: () => and,
  compose: () => compose2,
  eqv: () => eqv,
  every: () => every,
  hasProperty: () => hasProperty,
  implies: () => implies,
  isBigInt: () => isBigInt,
  isBoolean: () => isBoolean,
  isDate: () => isDate,
  isError: () => isError,
  isFunction: () => isFunction2,
  isIterable: () => isIterable,
  isMap: () => isMap,
  isNever: () => isNever,
  isNotNull: () => isNotNull,
  isNotNullable: () => isNotNullable,
  isNotUndefined: () => isNotUndefined,
  isNull: () => isNull,
  isNullable: () => isNullable,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isPromise: () => isPromise,
  isPromiseLike: () => isPromiseLike,
  isReadonlyRecord: () => isReadonlyRecord,
  isRecord: () => isRecord,
  isSet: () => isSet,
  isString: () => isString,
  isSymbol: () => isSymbol,
  isTagged: () => isTagged,
  isTruthy: () => isTruthy,
  isUint8Array: () => isUint8Array,
  isUndefined: () => isUndefined,
  isUnknown: () => isUnknown,
  mapInput: () => mapInput,
  nand: () => nand,
  nor: () => nor,
  not: () => not,
  or: () => or,
  product: () => product,
  productMany: () => productMany,
  some: () => some,
  struct: () => struct,
  tuple: () => tuple,
  xor: () => xor
});

// ../node_modules/effect/dist/esm/Function.js
var Function_exports = {};
__export(Function_exports, {
  SK: () => SK,
  absurd: () => absurd,
  apply: () => apply,
  compose: () => compose,
  constFalse: () => constFalse,
  constNull: () => constNull,
  constTrue: () => constTrue,
  constUndefined: () => constUndefined,
  constVoid: () => constVoid,
  constant: () => constant,
  dual: () => dual,
  flip: () => flip,
  flow: () => flow,
  hole: () => hole,
  identity: () => identity,
  isFunction: () => isFunction,
  pipe: () => pipe,
  satisfies: () => satisfies,
  tupled: () => tupled,
  unsafeCoerce: () => unsafeCoerce,
  untupled: () => untupled
});
var isFunction = (input) => typeof input === "function";
var dual = function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        return body.apply(this, arguments);
      }
      return (self) => body(self, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function(a, b) {
        if (arguments.length >= 2) {
          return body(a, b);
        }
        return function(self) {
          return body(self, a);
        };
      };
    case 3:
      return function(a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c);
        }
        return function(self) {
          return body(self, a, b);
        };
      };
    case 4:
      return function(a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d);
        }
        return function(self) {
          return body(self, a, b, c);
        };
      };
    case 5:
      return function(a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e);
        }
        return function(self) {
          return body(self, a, b, c, d);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity) {
          return body.apply(this, arguments);
        }
        const args = arguments;
        return function(self) {
          return body(self, ...args);
        };
      };
  }
};
var apply = (a) => (self) => self(a);
var identity = (a) => a;
var satisfies = () => (b) => b;
var unsafeCoerce = identity;
var constant = (value) => () => value;
var constTrue = constant(true);
var constFalse = constant(false);
var constNull = constant(null);
var constUndefined = constant(void 0);
var constVoid = constUndefined;
var flip = (f) => (...b) => (...a) => f(...a)(...b);
var compose = dual(2, (ab, bc) => (a) => bc(ab(a)));
var absurd = (_) => {
  throw new Error("Called `absurd` function which should be uncallable");
};
var tupled = (f) => (a) => f(...a);
var untupled = (f) => (...a) => f(a);
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}
function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
  switch (arguments.length) {
    case 1:
      return ab;
    case 2:
      return function() {
        return bc(ab.apply(this, arguments));
      };
    case 3:
      return function() {
        return cd(bc(ab.apply(this, arguments)));
      };
    case 4:
      return function() {
        return de(cd(bc(ab.apply(this, arguments))));
      };
    case 5:
      return function() {
        return ef(de(cd(bc(ab.apply(this, arguments)))));
      };
    case 6:
      return function() {
        return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
      };
    case 7:
      return function() {
        return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
      };
    case 8:
      return function() {
        return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
      };
    case 9:
      return function() {
        return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
      };
  }
  return;
}
var hole = unsafeCoerce(absurd);
var SK = (_, b) => b;

// ../node_modules/effect/dist/esm/Predicate.js
var mapInput = dual(2, (self, f) => (b) => self(f(b)));
var isTruthy = (input) => !!input;
var isSet = (input) => input instanceof Set;
var isMap = (input) => input instanceof Map;
var isString = (input) => typeof input === "string";
var isNumber = (input) => typeof input === "number";
var isBoolean = (input) => typeof input === "boolean";
var isBigInt = (input) => typeof input === "bigint";
var isSymbol = (input) => typeof input === "symbol";
var isFunction2 = isFunction;
var isUndefined = (input) => input === void 0;
var isNotUndefined = (input) => input !== void 0;
var isNull = (input) => input === null;
var isNotNull = (input) => input !== null;
var isNever = (_) => false;
var isUnknown = (_) => true;
var isRecordOrArray = (input) => typeof input === "object" && input !== null;
var isObject = (input) => isRecordOrArray(input) || isFunction2(input);
var hasProperty = dual(2, (self, property) => isObject(self) && property in self);
var isTagged = dual(2, (self, tag) => hasProperty(self, "_tag") && self["_tag"] === tag);
var isNullable = (input) => input === null || input === void 0;
var isNotNullable = (input) => input !== null && input !== void 0;
var isError = (input) => input instanceof Error;
var isUint8Array = (input) => input instanceof Uint8Array;
var isDate = (input) => input instanceof Date;
var isIterable = (input) => hasProperty(input, Symbol.iterator);
var isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input);
var isReadonlyRecord = isRecord;
var isPromise = (input) => hasProperty(input, "then") && "catch" in input && isFunction2(input.then) && isFunction2(input.catch);
var isPromiseLike = (input) => hasProperty(input, "then") && isFunction2(input.then);
var compose2 = dual(2, (ab, bc) => (a) => ab(a) && bc(a));
var product = (self, that) => ([a, b]) => self(a) && that(b);
var all = (collection) => {
  return (as) => {
    let collectionIndex = 0;
    for (const p of collection) {
      if (collectionIndex >= as.length) {
        break;
      }
      if (p(as[collectionIndex]) === false) {
        return false;
      }
      collectionIndex++;
    }
    return true;
  };
};
var productMany = (self, collection) => {
  const rest = all(collection);
  return ([head, ...tail]) => self(head) === false ? false : rest(tail);
};
var tuple = (...elements) => all(elements);
var struct = (fields) => {
  const keys = Object.keys(fields);
  return (a) => {
    for (const key of keys) {
      if (!fields[key](a[key])) {
        return false;
      }
    }
    return true;
  };
};
var not = (self) => (a) => !self(a);
var or = dual(2, (self, that) => (a) => self(a) || that(a));
var and = dual(2, (self, that) => (a) => self(a) && that(a));
var xor = dual(2, (self, that) => (a) => self(a) !== that(a));
var eqv = dual(2, (self, that) => (a) => self(a) === that(a));
var implies = dual(2, (self, that) => (a) => self(a) ? that(a) : true);
var nor = dual(2, (self, that) => (a) => !(self(a) || that(a)));
var nand = dual(2, (self, that) => (a) => !(self(a) && that(a)));
var every = (collection) => (a) => {
  for (const p of collection) {
    if (!p(a)) {
      return false;
    }
  }
  return true;
};
var some = (collection) => (a) => {
  for (const p of collection) {
    if (p(a)) {
      return true;
    }
  }
  return false;
};

export {
  isFunction,
  dual,
  identity,
  unsafeCoerce,
  constant,
  constTrue,
  constFalse,
  constNull,
  constUndefined,
  constVoid,
  absurd,
  pipe,
  flow,
  hole,
  Function_exports,
  mapInput,
  isTruthy,
  isSet,
  isMap,
  isString,
  isNumber,
  isBoolean,
  isBigInt,
  isSymbol,
  isFunction2,
  isUndefined,
  isNotUndefined,
  isNull,
  isNotNull,
  isNever,
  isUnknown,
  isObject,
  hasProperty,
  isTagged,
  isNullable,
  isNotNullable,
  isError,
  isUint8Array,
  isDate,
  isIterable,
  isRecord,
  isReadonlyRecord,
  isPromise,
  isPromiseLike,
  compose2 as compose,
  product,
  all,
  productMany,
  tuple,
  struct,
  not,
  or,
  and,
  xor,
  eqv,
  implies,
  nor,
  nand,
  every,
  some,
  Predicate_exports
};
//# sourceMappingURL=chunk-KURLOJT7.js.map
