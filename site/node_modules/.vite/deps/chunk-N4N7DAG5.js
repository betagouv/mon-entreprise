import {
  isNonEmptyArray
} from "./chunk-5OEZIP3U.js";
import {
  greaterThanOrEqualTo,
  sign
} from "./chunk-ODPGYV6G.js";
import {
  filter,
  fromNullable,
  some
} from "./chunk-GMICS55Q.js";
import {
  string,
  string3 as string2
} from "./chunk-PMMD7ZWW.js";
import {
  dual,
  isString
} from "./chunk-KURLOJT7.js";
import {
  __export,
  __publicField
} from "./chunk-2LSFTFF7.js";

// ../node_modules/effect/dist/esm/String.js
var String_exports = {};
__export(String_exports, {
  Equivalence: () => Equivalence,
  Order: () => Order,
  at: () => at,
  camelToSnake: () => camelToSnake,
  capitalize: () => capitalize,
  charAt: () => charAt,
  charCodeAt: () => charCodeAt,
  codePointAt: () => codePointAt,
  concat: () => concat,
  empty: () => empty,
  endsWith: () => endsWith,
  includes: () => includes,
  indexOf: () => indexOf,
  isEmpty: () => isEmpty,
  isNonEmpty: () => isNonEmpty,
  isString: () => isString2,
  kebabToSnake: () => kebabToSnake,
  lastIndexOf: () => lastIndexOf,
  length: () => length,
  linesIterator: () => linesIterator,
  linesWithSeparators: () => linesWithSeparators,
  localeCompare: () => localeCompare,
  match: () => match,
  matchAll: () => matchAll,
  normalize: () => normalize,
  padEnd: () => padEnd,
  padStart: () => padStart,
  pascalToSnake: () => pascalToSnake,
  repeat: () => repeat,
  replace: () => replace,
  replaceAll: () => replaceAll,
  search: () => search,
  slice: () => slice,
  snakeToCamel: () => snakeToCamel,
  snakeToKebab: () => snakeToKebab,
  snakeToPascal: () => snakeToPascal,
  split: () => split,
  startsWith: () => startsWith,
  stripMargin: () => stripMargin,
  stripMarginWith: () => stripMarginWith,
  substring: () => substring,
  takeLeft: () => takeLeft,
  takeRight: () => takeRight,
  toLocaleLowerCase: () => toLocaleLowerCase,
  toLocaleUpperCase: () => toLocaleUpperCase,
  toLowerCase: () => toLowerCase,
  toUpperCase: () => toUpperCase,
  trim: () => trim,
  trimEnd: () => trimEnd,
  trimStart: () => trimStart,
  uncapitalize: () => uncapitalize
});
var isString2 = isString;
var Equivalence = string;
var Order = string2;
var empty = "";
var concat = dual(2, (self, that) => self + that);
var toUpperCase = (self) => self.toUpperCase();
var toLowerCase = (self) => self.toLowerCase();
var capitalize = (self) => {
  if (self.length === 0)
    return self;
  return toUpperCase(self[0]) + self.slice(1);
};
var uncapitalize = (self) => {
  if (self.length === 0)
    return self;
  return toLowerCase(self[0]) + self.slice(1);
};
var replace = (searchValue, replaceValue) => (self) => self.replace(searchValue, replaceValue);
var trim = (self) => self.trim();
var trimStart = (self) => self.trimStart();
var trimEnd = (self) => self.trimEnd();
var slice = (start, end) => (self) => self.slice(start, end);
var isEmpty = (self) => self.length === 0;
var isNonEmpty = (self) => self.length > 0;
var length = (self) => self.length;
var split = dual(2, (self, separator) => {
  const out = self.split(separator);
  return isNonEmptyArray(out) ? out : [self];
});
var includes = (searchString, position) => (self) => self.includes(searchString, position);
var startsWith = (searchString, position) => (self) => self.startsWith(searchString, position);
var endsWith = (searchString, position) => (self) => self.endsWith(searchString, position);
var charCodeAt = dual(2, (self, index) => filter(some(self.charCodeAt(index)), (charCode) => !isNaN(charCode)));
var substring = (start, end) => (self) => self.substring(start, end);
var at = dual(2, (self, index) => fromNullable(self.at(index)));
var charAt = dual(2, (self, index) => filter(some(self.charAt(index)), isNonEmpty));
var codePointAt = dual(2, (self, index) => fromNullable(self.codePointAt(index)));
var indexOf = (searchString) => (self) => filter(some(self.indexOf(searchString)), greaterThanOrEqualTo(0));
var lastIndexOf = (searchString) => (self) => filter(some(self.lastIndexOf(searchString)), greaterThanOrEqualTo(0));
var localeCompare = (that, locales, options) => (self) => sign(self.localeCompare(that, locales, options));
var match = (regexp) => (self) => fromNullable(self.match(regexp));
var matchAll = (regexp) => (self) => self.matchAll(regexp);
var normalize = (form) => (self) => self.normalize(form);
var padEnd = (maxLength, fillString) => (self) => self.padEnd(maxLength, fillString);
var padStart = (maxLength, fillString) => (self) => self.padStart(maxLength, fillString);
var repeat = (count) => (self) => self.repeat(count);
var replaceAll = (searchValue, replaceValue) => (self) => self.replaceAll(searchValue, replaceValue);
var search = dual(2, (self, regexp) => filter(some(self.search(regexp)), greaterThanOrEqualTo(0)));
var toLocaleLowerCase = (locale) => (self) => self.toLocaleLowerCase(locale);
var toLocaleUpperCase = (locale) => (self) => self.toLocaleUpperCase(locale);
var takeLeft = dual(2, (self, n) => self.slice(0, Math.max(n, 0)));
var takeRight = dual(2, (self, n) => self.slice(Math.max(0, self.length - Math.floor(n)), Infinity));
var CR = 13;
var LF = 10;
var linesIterator = (self) => linesSeparated(self, true);
var linesWithSeparators = (s) => linesSeparated(s, false);
var stripMarginWith = dual(2, (self, marginChar) => {
  let out = "";
  for (const line of linesWithSeparators(self)) {
    let index = 0;
    while (index < line.length && line.charAt(index) <= " ") {
      index = index + 1;
    }
    const stripped = index < line.length && line.charAt(index) === marginChar ? line.substring(index + 1) : line;
    out = out + stripped;
  }
  return out;
});
var stripMargin = (self) => stripMarginWith(self, "|");
var snakeToCamel = (self) => {
  let str = self[0];
  for (let i = 1; i < self.length; i++) {
    str += self[i] === "_" ? self[++i].toUpperCase() : self[i];
  }
  return str;
};
var snakeToPascal = (self) => {
  let str = self[0].toUpperCase();
  for (let i = 1; i < self.length; i++) {
    str += self[i] === "_" ? self[++i].toUpperCase() : self[i];
  }
  return str;
};
var snakeToKebab = (self) => self.replace(/_/g, "-");
var camelToSnake = (self) => self.replace(/([A-Z])/g, "_$1").toLowerCase();
var pascalToSnake = (self) => (self.slice(0, 1) + self.slice(1).replace(/([A-Z])/g, "_$1")).toLowerCase();
var kebabToSnake = (self) => self.replace(/-/g, "_");
var LinesIterator = class _LinesIterator {
  constructor(s, stripped = false) {
    __publicField(this, "s");
    __publicField(this, "stripped");
    __publicField(this, "index");
    __publicField(this, "length");
    this.s = s;
    this.stripped = stripped;
    this.index = 0;
    this.length = s.length;
  }
  next() {
    if (this.done) {
      return {
        done: true,
        value: void 0
      };
    }
    const start = this.index;
    while (!this.done && !isLineBreak(this.s[this.index])) {
      this.index = this.index + 1;
    }
    let end = this.index;
    if (!this.done) {
      const char = this.s[this.index];
      this.index = this.index + 1;
      if (!this.done && isLineBreak2(char, this.s[this.index])) {
        this.index = this.index + 1;
      }
      if (!this.stripped) {
        end = this.index;
      }
    }
    return {
      done: false,
      value: this.s.substring(start, end)
    };
  }
  [Symbol.iterator]() {
    return new _LinesIterator(this.s, this.stripped);
  }
  get done() {
    return this.index >= this.length;
  }
};
var isLineBreak = (char) => {
  const code = char.charCodeAt(0);
  return code === CR || code === LF;
};
var isLineBreak2 = (char0, char1) => char0.charCodeAt(0) === CR && char1.charCodeAt(0) === LF;
var linesSeparated = (self, stripped) => new LinesIterator(self, stripped);

export {
  isString2 as isString,
  Equivalence,
  Order,
  empty,
  concat,
  toUpperCase,
  toLowerCase,
  capitalize,
  uncapitalize,
  replace,
  trim,
  trimStart,
  trimEnd,
  slice,
  isEmpty,
  isNonEmpty,
  length,
  split,
  includes,
  startsWith,
  endsWith,
  charCodeAt,
  substring,
  at,
  charAt,
  codePointAt,
  indexOf,
  lastIndexOf,
  localeCompare,
  match,
  matchAll,
  normalize,
  padEnd,
  padStart,
  repeat,
  replaceAll,
  search,
  toLocaleLowerCase,
  toLocaleUpperCase,
  takeLeft,
  takeRight,
  linesIterator,
  linesWithSeparators,
  stripMarginWith,
  stripMargin,
  snakeToCamel,
  snakeToPascal,
  snakeToKebab,
  camelToSnake,
  pascalToSnake,
  kebabToSnake,
  String_exports
};
//# sourceMappingURL=chunk-N4N7DAG5.js.map
