{
  "version": 3,
  "sources": ["../../../../node_modules/effect/src/String.ts"],
  "sourcesContent": ["/**\n * This module provides utility functions and type class instances for working with the `string` type in TypeScript.\n * It includes functions for basic string manipulation, as well as type class instances for\n * `Equivalence` and `Order`.\n *\n * @since 2.0.0\n */\n\nimport type { NonEmptyArray } from \"./Array.js\"\nimport * as equivalence from \"./Equivalence.js\"\nimport { dual } from \"./Function.js\"\nimport * as readonlyArray from \"./internal/array.js\"\nimport * as number from \"./Number.js\"\nimport * as Option from \"./Option.js\"\nimport * as order from \"./Order.js\"\nimport type * as Ordering from \"./Ordering.js\"\nimport type { Refinement } from \"./Predicate.js\"\nimport * as predicate from \"./Predicate.js\"\n\n/**\n * Tests if a value is a `string`.\n *\n * @param input - The value to test.\n *\n * @example\n * import { isString } from 'effect/String'\n *\n * assert.deepStrictEqual(isString(\"a\"), true)\n * assert.deepStrictEqual(isString(1), false)\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isString: Refinement<unknown, string> = predicate.isString\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Equivalence: equivalence.Equivalence<string> = equivalence.string\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Order: order.Order<string> = order.string\n\n/**\n * The empty string `\"\"`.\n *\n * @since 2.0.0\n */\nexport const empty: \"\" = \"\" as const\n\n/**\n * Concatenates two strings at the type level.\n *\n * @since 2.0.0\n */\nexport type Concat<A extends string, B extends string> = `${A}${B}`\n\n/**\n * Concatenates two strings at runtime.\n *\n * @since 2.0.0\n */\nexport const concat: {\n  <B extends string>(that: B): <A extends string>(self: A) => Concat<A, B>\n  <A extends string, B extends string>(self: A, that: B): Concat<A, B>\n} = dual(2, (self: string, that: string): string => self + that)\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe('a', S.toUpperCase), 'A')\n *\n * @since 2.0.0\n */\nexport const toUpperCase = <S extends string>(self: S): Uppercase<S> => self.toUpperCase() as Uppercase<S>\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe('A', S.toLowerCase), 'a')\n *\n * @since 2.0.0\n */\nexport const toLowerCase = <T extends string>(self: T): Lowercase<T> => self.toLowerCase() as Lowercase<T>\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe('abc', S.capitalize), 'Abc')\n *\n * @since 2.0.0\n */\nexport const capitalize = <T extends string>(self: T): Capitalize<T> => {\n  if (self.length === 0) return self as Capitalize<T>\n\n  return (toUpperCase(self[0]) + self.slice(1)) as Capitalize<T>\n}\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe('ABC', S.uncapitalize), 'aBC')\n *\n * @since 2.0.0\n */\nexport const uncapitalize = <T extends string>(self: T): Uncapitalize<T> => {\n  if (self.length === 0) return self as Uncapitalize<T>\n\n  return (toLowerCase(self[0]) + self.slice(1)) as Uncapitalize<T>\n}\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe('abc', S.replace('b', 'd')), 'adc')\n *\n * @since 2.0.0\n */\nexport const replace = (searchValue: string | RegExp, replaceValue: string) => (self: string): string =>\n  self.replace(searchValue, replaceValue)\n\n/**\n * @since 2.0.0\n */\nexport type Trim<A extends string> = TrimEnd<TrimStart<A>>\n\n/**\n * @example\n * import * as S from 'effect/String'\n *\n * assert.deepStrictEqual(S.trim(' a '), 'a')\n *\n * @since 2.0.0\n */\nexport const trim = <A extends string>(self: A): Trim<A> => self.trim() as Trim<A>\n\n/**\n * @since 2.0.0\n */\nexport type TrimStart<A extends string> = A extends ` ${infer B}` ? TrimStart<B>\n  : A extends `\\n${infer B}` ? TrimStart<B>\n  : A extends `\\t${infer B}` ? TrimStart<B>\n  : A extends `\\r${infer B}` ? TrimStart<B>\n  : A\n\n/**\n * @example\n * import * as S from 'effect/String'\n *\n * assert.deepStrictEqual(S.trimStart(' a '), 'a ')\n *\n * @since 2.0.0\n */\nexport const trimStart = <A extends string>(self: A): TrimStart<A> => self.trimStart() as TrimStart<A>\n\n/**\n * @since 2.0.0\n */\nexport type TrimEnd<A extends string> = A extends `${infer B} ` ? TrimEnd<B>\n  : A extends `${infer B}\\n` ? TrimEnd<B>\n  : A extends `${infer B}\\t` ? TrimEnd<B>\n  : A extends `${infer B}\\r` ? TrimEnd<B>\n  : A\n\n/**\n * @example\n * import * as S from 'effect/String'\n *\n * assert.deepStrictEqual(S.trimEnd(' a '), ' a')\n *\n * @since 2.0.0\n */\nexport const trimEnd = <A extends string>(self: A): TrimEnd<A> => self.trimEnd() as TrimEnd<A>\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe('abcd', S.slice(1, 3)), 'bc')\n *\n * @since 2.0.0\n */\nexport const slice = (start?: number, end?: number) => (self: string): string => self.slice(start, end)\n\n/**\n * Test whether a `string` is empty.\n *\n * @example\n * import * as S from 'effect/String'\n *\n * assert.deepStrictEqual(S.isEmpty(''), true)\n * assert.deepStrictEqual(S.isEmpty('a'), false)\n *\n * @since 2.0.0\n */\nexport const isEmpty = (self: string): self is \"\" => self.length === 0\n\n/**\n * Test whether a `string` is non empty.\n *\n * @since 2.0.0\n */\nexport const isNonEmpty = (self: string): boolean => self.length > 0\n\n/**\n * Calculate the number of characters in a `string`.\n *\n * @example\n * import * as S from 'effect/String'\n *\n * assert.deepStrictEqual(S.length('abc'), 3)\n *\n * @since 2.0.0\n */\nexport const length = (self: string): number => self.length\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe('abc', S.split('')), ['a', 'b', 'c'])\n * assert.deepStrictEqual(pipe('', S.split('')), [''])\n *\n * @since 2.0.0\n */\nexport const split: {\n  (separator: string | RegExp): (self: string) => NonEmptyArray<string>\n  (self: string, separator: string | RegExp): NonEmptyArray<string>\n} = dual(2, (self: string, separator: string | RegExp): NonEmptyArray<string> => {\n  const out = self.split(separator)\n  return readonlyArray.isNonEmptyArray(out) ? out : [self]\n})\n\n/**\n * Returns `true` if `searchString` appears as a substring of `self`, at one or more positions that are\n * greater than or equal to `position`; otherwise, returns `false`.\n *\n * @since 2.0.0\n */\nexport const includes = (searchString: string, position?: number) => (self: string): boolean =>\n  self.includes(searchString, position)\n\n/**\n * @since 2.0.0\n */\nexport const startsWith = (searchString: string, position?: number) => (self: string): boolean =>\n  self.startsWith(searchString, position)\n\n/**\n * @since 2.0.0\n */\nexport const endsWith = (searchString: string, position?: number) => (self: string): boolean =>\n  self.endsWith(searchString, position)\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import * as Option from 'effect/Option'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"abc\", S.charCodeAt(1)), Option.some(98))\n * assert.deepStrictEqual(pipe(\"abc\", S.charCodeAt(4)), Option.none())\n *\n * @since 2.0.0\n */\nexport const charCodeAt: {\n  (index: number): (self: string) => Option.Option<number>\n  (self: string, index: number): Option.Option<number>\n} = dual(\n  2,\n  (self: string, index: number): Option.Option<number> =>\n    Option.filter(Option.some(self.charCodeAt(index)), (charCode) => !isNaN(charCode))\n)\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"abcd\", S.substring(1)), \"bcd\")\n * assert.deepStrictEqual(pipe(\"abcd\", S.substring(1, 3)), \"bc\")\n *\n * @since 2.0.0\n */\nexport const substring = (start: number, end?: number) => (self: string): string => self.substring(start, end)\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import * as Option from 'effect/Option'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"abc\", S.at(1)), Option.some(\"b\"))\n * assert.deepStrictEqual(pipe(\"abc\", S.at(4)), Option.none())\n *\n * @since 2.0.0\n */\nexport const at: {\n  (index: number): (self: string) => Option.Option<string>\n  (self: string, index: number): Option.Option<string>\n} = dual(2, (self: string, index: number): Option.Option<string> => Option.fromNullable(self.at(index)))\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import * as Option from 'effect/Option'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"abc\", S.charAt(1)), Option.some(\"b\"))\n * assert.deepStrictEqual(pipe(\"abc\", S.charAt(4)), Option.none())\n *\n * @since 2.0.0\n */\nexport const charAt: {\n  (index: number): (self: string) => Option.Option<string>\n  (self: string, index: number): Option.Option<string>\n} = dual(\n  2,\n  (self: string, index: number): Option.Option<string> => Option.filter(Option.some(self.charAt(index)), isNonEmpty)\n)\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import * as Option from 'effect/Option'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"abc\", S.codePointAt(1)), Option.some(98))\n *\n * @since 2.0.0\n */\nexport const codePointAt: {\n  (index: number): (self: string) => Option.Option<number>\n  (self: string, index: number): Option.Option<number>\n} = dual(2, (self: string, index: number): Option.Option<number> => Option.fromNullable(self.codePointAt(index)))\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import * as Option from 'effect/Option'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"abbbc\", S.indexOf(\"b\")), Option.some(1))\n *\n * @since 2.0.0\n */\nexport const indexOf = (searchString: string) => (self: string): Option.Option<number> =>\n  Option.filter(Option.some(self.indexOf(searchString)), number.greaterThanOrEqualTo(0))\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import * as Option from 'effect/Option'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"abbbc\", S.lastIndexOf(\"b\")), Option.some(3))\n * assert.deepStrictEqual(pipe(\"abbbc\", S.lastIndexOf(\"d\")), Option.none())\n *\n * @since 2.0.0\n */\nexport const lastIndexOf = (searchString: string) => (self: string): Option.Option<number> =>\n  Option.filter(Option.some(self.lastIndexOf(searchString)), number.greaterThanOrEqualTo(0))\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"a\", S.localeCompare(\"b\")), -1)\n * assert.deepStrictEqual(pipe(\"b\", S.localeCompare(\"a\")), 1)\n * assert.deepStrictEqual(pipe(\"a\", S.localeCompare(\"a\")), 0)\n *\n * @since 2.0.0\n */\nexport const localeCompare =\n  (that: string, locales?: Array<string>, options?: Intl.CollatorOptions) => (self: string): Ordering.Ordering =>\n    number.sign(self.localeCompare(that, locales, options))\n\n/**\n * It is the `pipe`-able version of the native `match` method.\n *\n * @since 2.0.0\n */\nexport const match = (regexp: RegExp | string) => (self: string): Option.Option<RegExpMatchArray> =>\n  Option.fromNullable(self.match(regexp))\n\n/**\n * It is the `pipe`-able version of the native `matchAll` method.\n *\n * @since 2.0.0\n */\nexport const matchAll = (regexp: RegExp) => (self: string): IterableIterator<RegExpMatchArray> => self.matchAll(regexp)\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * const str = \"\\u1E9B\\u0323\";\n * assert.deepStrictEqual(pipe(str, S.normalize()), \"\\u1E9B\\u0323\")\n * assert.deepStrictEqual(pipe(str, S.normalize(\"NFC\")), \"\\u1E9B\\u0323\")\n * assert.deepStrictEqual(pipe(str, S.normalize(\"NFD\")), \"\\u017F\\u0323\\u0307\")\n * assert.deepStrictEqual(pipe(str, S.normalize(\"NFKC\")), \"\\u1E69\")\n * assert.deepStrictEqual(pipe(str, S.normalize(\"NFKD\")), \"\\u0073\\u0323\\u0307\")\n *\n * @since 2.0.0\n */\nexport const normalize = (form?: \"NFC\" | \"NFD\" | \"NFKC\" | \"NFKD\") => (self: string): string => self.normalize(form)\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"a\", S.padEnd(5)), \"a    \")\n * assert.deepStrictEqual(pipe(\"a\", S.padEnd(5, \"_\")), \"a____\")\n *\n * @since 2.0.0\n */\nexport const padEnd = (maxLength: number, fillString?: string) => (self: string): string =>\n  self.padEnd(maxLength, fillString)\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"a\", S.padStart(5)), \"    a\")\n * assert.deepStrictEqual(pipe(\"a\", S.padStart(5, \"_\")), \"____a\")\n *\n * @since 2.0.0\n */\nexport const padStart = (maxLength: number, fillString?: string) => (self: string): string =>\n  self.padStart(maxLength, fillString)\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"a\", S.repeat(5)), \"aaaaa\")\n *\n * @since 2.0.0\n */\nexport const repeat = (count: number) => (self: string): string => self.repeat(count)\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"ababb\", S.replaceAll(\"b\", \"c\")), \"acacc\")\n * assert.deepStrictEqual(pipe(\"ababb\", S.replaceAll(/ba/g, \"cc\")), \"accbb\")\n *\n * @since 2.0.0\n */\nexport const replaceAll = (searchValue: string | RegExp, replaceValue: string) => (self: string): string =>\n  self.replaceAll(searchValue, replaceValue)\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import * as Option from 'effect/Option'\n * import { pipe } from 'effect/Function'\n *\n * assert.deepStrictEqual(pipe(\"ababb\", S.search(\"b\")), Option.some(1))\n * assert.deepStrictEqual(pipe(\"ababb\", S.search(/abb/)), Option.some(2))\n * assert.deepStrictEqual(pipe(\"ababb\", S.search(\"d\")), Option.none())\n *\n * @since 2.0.0\n */\nexport const search: {\n  (regexp: RegExp | string): (self: string) => Option.Option<number>\n  (self: string, regexp: RegExp | string): Option.Option<number>\n} = dual(\n  2,\n  (self: string, regexp: RegExp | string): Option.Option<number> =>\n    Option.filter(Option.some(self.search(regexp)), number.greaterThanOrEqualTo(0))\n)\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * const str = \"\\u0130\"\n * assert.deepStrictEqual(pipe(str, S.toLocaleLowerCase(\"tr\")), \"i\")\n *\n * @since 2.0.0\n */\nexport const toLocaleLowerCase = (locale?: string | Array<string>) => (self: string): string =>\n  self.toLocaleLowerCase(locale)\n\n/**\n * @example\n * import * as S from 'effect/String'\n * import { pipe } from 'effect/Function'\n *\n * const str = \"i\\u0307\"\n * assert.deepStrictEqual(pipe(str, S.toLocaleUpperCase(\"lt-LT\")), \"I\")\n *\n * @since 2.0.0\n */\nexport const toLocaleUpperCase = (locale?: string | Array<string>) => (self: string): string =>\n  self.toLocaleUpperCase(locale)\n\n/**\n * Keep the specified number of characters from the start of a string.\n *\n * If `n` is larger than the available number of characters, the string will\n * be returned whole.\n *\n * If `n` is not a positive number, an empty string will be returned.\n *\n * If `n` is a float, it will be rounded down to the nearest integer.\n *\n * @example\n * import * as S from 'effect/String'\n *\n * assert.deepStrictEqual(S.takeLeft(\"Hello World\", 5), \"Hello\")\n *\n * @since 2.0.0\n */\nexport const takeLeft: {\n  (n: number): (self: string) => string\n  (self: string, n: number): string\n} = dual(2, (self: string, n: number): string => self.slice(0, Math.max(n, 0)))\n\n/**\n * Keep the specified number of characters from the end of a string.\n *\n * If `n` is larger than the available number of characters, the string will\n * be returned whole.\n *\n * If `n` is not a positive number, an empty string will be returned.\n *\n * If `n` is a float, it will be rounded down to the nearest integer.\n *\n * @example\n * import * as S from 'effect/String'\n *\n * assert.deepStrictEqual(S.takeRight(\"Hello World\", 5), \"World\")\n *\n * @since 2.0.0\n */\nexport const takeRight: {\n  (n: number): (self: string) => string\n  (self: string, n: number): string\n} = dual(\n  2,\n  (self: string, n: number): string => self.slice(Math.max(0, self.length - Math.floor(n)), Infinity)\n)\n\nconst CR = 0x0d\nconst LF = 0x0a\n\n/**\n * Returns an `IterableIterator` which yields each line contained within the\n * string, trimming off the trailing newline character.\n *\n * @since 2.0.0\n */\nexport const linesIterator = (self: string): LinesIterator => linesSeparated(self, true)\n\n/**\n * Returns an `IterableIterator` which yields each line contained within the\n * string as well as the trailing newline character.\n *\n * @since 2.0.0\n */\nexport const linesWithSeparators = (s: string): LinesIterator => linesSeparated(s, false)\n\n/**\n * For every line in this string, strip a leading prefix consisting of blanks\n * or control characters followed by the character specified by `marginChar`\n * from the line.\n *\n * @since 2.0.0\n */\nexport const stripMarginWith: {\n  (marginChar: string): (self: string) => string\n  (self: string, marginChar: string): string\n} = dual(2, (self: string, marginChar: string): string => {\n  let out = \"\"\n\n  for (const line of linesWithSeparators(self)) {\n    let index = 0\n\n    while (index < line.length && line.charAt(index) <= \" \") {\n      index = index + 1\n    }\n\n    const stripped = index < line.length && line.charAt(index) === marginChar\n      ? line.substring(index + 1)\n      : line\n\n    out = out + stripped\n  }\n\n  return out\n})\n\n/**\n * For every line in this string, strip a leading prefix consisting of blanks\n * or control characters followed by the `\"|\"` character from the line.\n *\n * @since 2.0.0\n */\nexport const stripMargin = (self: string): string => stripMarginWith(self, \"|\")\n\n/**\n * @since 2.0.0\n */\nexport const snakeToCamel = (self: string): string => {\n  let str = self[0]\n  for (let i = 1; i < self.length; i++) {\n    str += self[i] === \"_\" ? self[++i].toUpperCase() : self[i]\n  }\n  return str\n}\n\n/**\n * @since 2.0.0\n */\nexport const snakeToPascal = (self: string): string => {\n  let str = self[0].toUpperCase()\n  for (let i = 1; i < self.length; i++) {\n    str += self[i] === \"_\" ? self[++i].toUpperCase() : self[i]\n  }\n  return str\n}\n\n/**\n * @since 2.0.0\n */\nexport const snakeToKebab = (self: string): string => self.replace(/_/g, \"-\")\n\n/**\n * @since 2.0.0\n */\nexport const camelToSnake = (self: string): string => self.replace(/([A-Z])/g, \"_$1\").toLowerCase()\n\n/**\n * @since 2.0.0\n */\nexport const pascalToSnake = (self: string): string =>\n  (self.slice(0, 1) + self.slice(1).replace(/([A-Z])/g, \"_$1\")).toLowerCase()\n\n/**\n * @since 2.0.0\n */\nexport const kebabToSnake = (self: string): string => self.replace(/-/g, \"_\")\n\nclass LinesIterator implements IterableIterator<string> {\n  private index: number\n  private readonly length: number\n\n  constructor(readonly s: string, readonly stripped: boolean = false) {\n    this.index = 0\n    this.length = s.length\n  }\n\n  next(): IteratorResult<string> {\n    if (this.done) {\n      return { done: true, value: undefined }\n    }\n    const start = this.index\n    while (!this.done && !isLineBreak(this.s[this.index]!)) {\n      this.index = this.index + 1\n    }\n    let end = this.index\n    if (!this.done) {\n      const char = this.s[this.index]!\n      this.index = this.index + 1\n      if (!this.done && isLineBreak2(char, this.s[this.index]!)) {\n        this.index = this.index + 1\n      }\n      if (!this.stripped) {\n        end = this.index\n      }\n    }\n    return { done: false, value: this.s.substring(start, end) }\n  }\n\n  [Symbol.iterator](): IterableIterator<string> {\n    return new LinesIterator(this.s, this.stripped)\n  }\n\n  private get done(): boolean {\n    return this.index >= this.length\n  }\n}\n\n/**\n * Test if the provided character is a line break character (i.e. either `\"\\r\"`\n * or `\"\\n\"`).\n */\nconst isLineBreak = (char: string): boolean => {\n  const code = char.charCodeAt(0)\n  return code === CR || code === LF\n}\n\n/**\n * Test if the provided characters combine to form a carriage return/line-feed\n * (i.e. `\"\\r\\n\"`).\n */\nconst isLineBreak2 = (char0: string, char1: string): boolean => char0.charCodeAt(0) === CR && char1.charCodeAt(0) === LF\n\nconst linesSeparated = (self: string, stripped: boolean): LinesIterator => new LinesIterator(self, stripped)\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;kBAAAA;EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCO,IAAMC,YAAkDA;AAMxD,IAAMC,cAA2DC;AAMjE,IAAMC,QAAmCD;AAOzC,IAAME,QAAY;AAclB,IAAMC,SAGTC,KAAK,GAAG,CAACC,MAAcC,SAAyBD,OAAOC,IAAI;AAWxD,IAAMC,cAAiCF,UAA0BA,KAAKE,YAAW;AAWjF,IAAMC,cAAiCH,UAA0BA,KAAKG,YAAW;AAWjF,IAAMC,aAAgCJ,UAA0B;AACrE,MAAIA,KAAKK,WAAW;AAAG,WAAOL;AAE9B,SAAQE,YAAYF,KAAK,CAAC,CAAC,IAAIA,KAAKM,MAAM,CAAC;AAC7C;AAWO,IAAMC,eAAkCP,UAA4B;AACzE,MAAIA,KAAKK,WAAW;AAAG,WAAOL;AAE9B,SAAQG,YAAYH,KAAK,CAAC,CAAC,IAAIA,KAAKM,MAAM,CAAC;AAC7C;AAWO,IAAME,UAAUA,CAACC,aAA8BC,iBAA0BV,UAC9EA,KAAKQ,QAAQC,aAAaC,YAAY;AAejC,IAAMC,OAA0BX,UAAqBA,KAAKW,KAAI;AAmB9D,IAAMC,YAA+BZ,UAA0BA,KAAKY,UAAS;AAmB7E,IAAMC,UAA6Bb,UAAwBA,KAAKa,QAAO;AAWvE,IAAMP,QAAQA,CAACQ,OAAgBC,QAAkBf,UAAyBA,KAAKM,MAAMQ,OAAOC,GAAG;AAa/F,IAAMC,UAAWhB,UAA6BA,KAAKK,WAAW;AAO9D,IAAMY,aAAcjB,UAA0BA,KAAKK,SAAS;AAY5D,IAAMA,SAAUL,UAAyBA,KAAKK;AAY9C,IAAMa,QAGTnB,KAAK,GAAG,CAACC,MAAcmB,cAAqD;AAC9E,QAAMC,MAAMpB,KAAKkB,MAAMC,SAAS;AAChC,SAAqBE,gBAAgBD,GAAG,IAAIA,MAAM,CAACpB,IAAI;AACzD,CAAC;AAQM,IAAMsB,WAAWA,CAACC,cAAsBC,aAAuBxB,UACpEA,KAAKsB,SAASC,cAAcC,QAAQ;AAK/B,IAAMC,aAAaA,CAACF,cAAsBC,aAAuBxB,UACtEA,KAAKyB,WAAWF,cAAcC,QAAQ;AAKjC,IAAME,WAAWA,CAACH,cAAsBC,aAAuBxB,UACpEA,KAAK0B,SAASH,cAAcC,QAAQ;AAa/B,IAAMG,aAGT5B,KACF,GACA,CAACC,MAAc4B,UACNC,OAAcC,KAAK9B,KAAK2B,WAAWC,KAAK,CAAC,GAAIG,cAAa,CAACC,MAAMD,QAAQ,CAAC,CAAC;AAa/E,IAAME,YAAYA,CAACnB,OAAeC,QAAkBf,UAAyBA,KAAKiC,UAAUnB,OAAOC,GAAG;AAatG,IAAMmB,KAGTnC,KAAK,GAAG,CAACC,MAAc4B,UAAgDO,aAAanC,KAAKkC,GAAGN,KAAK,CAAC,CAAC;AAahG,IAAMQ,SAGTrC,KACF,GACA,CAACC,MAAc4B,UAAgDC,OAAcC,KAAK9B,KAAKoC,OAAOR,KAAK,CAAC,GAAGX,UAAU,CAAC;AAa7G,IAAMoB,cAGTtC,KAAK,GAAG,CAACC,MAAc4B,UAAgDO,aAAanC,KAAKqC,YAAYT,KAAK,CAAC,CAAC;AAYzG,IAAMU,UAAWf,kBAA0BvB,UACzC6B,OAAcC,KAAK9B,KAAKsC,QAAQf,YAAY,CAAC,GAAUgB,qBAAqB,CAAC,CAAC;AAahF,IAAMC,cAAejB,kBAA0BvB,UAC7C6B,OAAcC,KAAK9B,KAAKwC,YAAYjB,YAAY,CAAC,GAAUgB,qBAAqB,CAAC,CAAC;AAapF,IAAME,gBACXA,CAACxC,MAAcyC,SAAyBC,YAAoC3C,UACnE4C,KAAK5C,KAAKyC,cAAcxC,MAAMyC,SAASC,OAAO,CAAC;AAOnD,IAAME,QAASC,YAA6B9C,UAC1CmC,aAAanC,KAAK6C,MAAMC,MAAM,CAAC;AAOjC,IAAMC,WAAYD,YAAoB9C,UAAqDA,KAAK+C,SAASD,MAAM;AAgB/G,IAAME,YAAaC,UAA4CjD,UAAyBA,KAAKgD,UAAUC,IAAI;AAY3G,IAAMC,SAASA,CAACC,WAAmBC,eAAyBpD,UACjEA,KAAKkD,OAAOC,WAAWC,UAAU;AAY5B,IAAMC,WAAWA,CAACF,WAAmBC,eAAyBpD,UACnEA,KAAKqD,SAASF,WAAWC,UAAU;AAW9B,IAAME,SAAUC,WAAmBvD,UAAyBA,KAAKsD,OAAOC,KAAK;AAY7E,IAAMC,aAAaA,CAAC/C,aAA8BC,iBAA0BV,UACjFA,KAAKwD,WAAW/C,aAAaC,YAAY;AAcpC,IAAM+C,SAGT1D,KACF,GACA,CAACC,MAAc8C,WACNjB,OAAcC,KAAK9B,KAAKyD,OAAOX,MAAM,CAAC,GAAUP,qBAAqB,CAAC,CAAC,CAAC;AAa5E,IAAMmB,oBAAqBC,YAAqC3D,UACrEA,KAAK0D,kBAAkBC,MAAM;AAYxB,IAAMC,oBAAqBD,YAAqC3D,UACrEA,KAAK4D,kBAAkBD,MAAM;AAmBxB,IAAME,WAGT9D,KAAK,GAAG,CAACC,MAAc8D,MAAsB9D,KAAKM,MAAM,GAAGyD,KAAKC,IAAIF,GAAG,CAAC,CAAC,CAAC;AAmBvE,IAAMG,YAGTlE,KACF,GACA,CAACC,MAAc8D,MAAsB9D,KAAKM,MAAMyD,KAAKC,IAAI,GAAGhE,KAAKK,SAAS0D,KAAKG,MAAMJ,CAAC,CAAC,GAAGK,QAAQ,CAAC;AAGrG,IAAMC,KAAK;AACX,IAAMC,KAAK;AAQJ,IAAMC,gBAAiBtE,UAAgCuE,eAAevE,MAAM,IAAI;AAQhF,IAAMwE,sBAAuBC,OAA6BF,eAAeE,GAAG,KAAK;AASjF,IAAMC,kBAGT3E,KAAK,GAAG,CAACC,MAAc2E,eAA8B;AACvD,MAAIvD,MAAM;AAEV,aAAWwD,QAAQJ,oBAAoBxE,IAAI,GAAG;AAC5C,QAAI4B,QAAQ;AAEZ,WAAOA,QAAQgD,KAAKvE,UAAUuE,KAAKxC,OAAOR,KAAK,KAAK,KAAK;AACvDA,cAAQA,QAAQ;IAClB;AAEA,UAAMiD,WAAWjD,QAAQgD,KAAKvE,UAAUuE,KAAKxC,OAAOR,KAAK,MAAM+C,aAC3DC,KAAK3C,UAAUL,QAAQ,CAAC,IACxBgD;AAEJxD,UAAMA,MAAMyD;EACd;AAEA,SAAOzD;AACT,CAAC;AAQM,IAAM0D,cAAe9E,UAAyB0E,gBAAgB1E,MAAM,GAAG;AAKvE,IAAM+E,eAAgB/E,UAAwB;AACnD,MAAIgF,MAAMhF,KAAK,CAAC;AAChB,WAASiF,IAAI,GAAGA,IAAIjF,KAAKK,QAAQ4E,KAAK;AACpCD,WAAOhF,KAAKiF,CAAC,MAAM,MAAMjF,KAAK,EAAEiF,CAAC,EAAE/E,YAAW,IAAKF,KAAKiF,CAAC;EAC3D;AACA,SAAOD;AACT;AAKO,IAAME,gBAAiBlF,UAAwB;AACpD,MAAIgF,MAAMhF,KAAK,CAAC,EAAEE,YAAW;AAC7B,WAAS+E,IAAI,GAAGA,IAAIjF,KAAKK,QAAQ4E,KAAK;AACpCD,WAAOhF,KAAKiF,CAAC,MAAM,MAAMjF,KAAK,EAAEiF,CAAC,EAAE/E,YAAW,IAAKF,KAAKiF,CAAC;EAC3D;AACA,SAAOD;AACT;AAKO,IAAMG,eAAgBnF,UAAyBA,KAAKQ,QAAQ,MAAM,GAAG;AAKrE,IAAM4E,eAAgBpF,UAAyBA,KAAKQ,QAAQ,YAAY,KAAK,EAAEL,YAAW;AAK1F,IAAMkF,gBAAiBrF,WAC3BA,KAAKM,MAAM,GAAG,CAAC,IAAIN,KAAKM,MAAM,CAAC,EAAEE,QAAQ,YAAY,KAAK,GAAGL,YAAW;AAKpE,IAAMmF,eAAgBtF,UAAyBA,KAAKQ,QAAQ,MAAM,GAAG;AAE5E,IAAM+E,gBAAN,MAAMA,eAAa;EAIjBC,YAAqBf,GAAoBI,WAAoB,OAAK;AAA7CJ;AAAoBI;AAHjCjD;AACSvB;AAEI,SAAAoE,IAAAA;AAAoB,SAAAI,WAAAA;AACvC,SAAKjD,QAAQ;AACb,SAAKvB,SAASoE,EAAEpE;EAClB;EAEAoF,OAAI;AACF,QAAI,KAAKC,MAAM;AACb,aAAO;QAAEA,MAAM;QAAMC,OAAOC;MAAS;IACvC;AACA,UAAM9E,QAAQ,KAAKc;AACnB,WAAO,CAAC,KAAK8D,QAAQ,CAACG,YAAY,KAAKpB,EAAE,KAAK7C,KAAK,CAAE,GAAG;AACtD,WAAKA,QAAQ,KAAKA,QAAQ;IAC5B;AACA,QAAIb,MAAM,KAAKa;AACf,QAAI,CAAC,KAAK8D,MAAM;AACd,YAAMI,OAAO,KAAKrB,EAAE,KAAK7C,KAAK;AAC9B,WAAKA,QAAQ,KAAKA,QAAQ;AAC1B,UAAI,CAAC,KAAK8D,QAAQK,aAAaD,MAAM,KAAKrB,EAAE,KAAK7C,KAAK,CAAE,GAAG;AACzD,aAAKA,QAAQ,KAAKA,QAAQ;MAC5B;AACA,UAAI,CAAC,KAAKiD,UAAU;AAClB9D,cAAM,KAAKa;MACb;IACF;AACA,WAAO;MAAE8D,MAAM;MAAOC,OAAO,KAAKlB,EAAExC,UAAUnB,OAAOC,GAAG;IAAC;EAC3D;EAEA,CAACiF,OAAOC,QAAQ,IAAC;AACf,WAAO,IAAIV,eAAc,KAAKd,GAAG,KAAKI,QAAQ;EAChD;EAEA,IAAYa,OAAI;AACd,WAAO,KAAK9D,SAAS,KAAKvB;EAC5B;;AAOF,IAAMwF,cAAeC,UAAyB;AAC5C,QAAMI,OAAOJ,KAAKnE,WAAW,CAAC;AAC9B,SAAOuE,SAAS9B,MAAM8B,SAAS7B;AACjC;AAMA,IAAM0B,eAAeA,CAACI,OAAeC,UAA2BD,MAAMxE,WAAW,CAAC,MAAMyC,MAAMgC,MAAMzE,WAAW,CAAC,MAAM0C;AAEtH,IAAME,iBAAiBA,CAACvE,MAAc6E,aAAqC,IAAIU,cAAcvF,MAAM6E,QAAQ;",
  "names": ["isString", "isString", "Equivalence", "string", "Order", "empty", "concat", "dual", "self", "that", "toUpperCase", "toLowerCase", "capitalize", "length", "slice", "uncapitalize", "replace", "searchValue", "replaceValue", "trim", "trimStart", "trimEnd", "start", "end", "isEmpty", "isNonEmpty", "split", "separator", "out", "isNonEmptyArray", "includes", "searchString", "position", "startsWith", "endsWith", "charCodeAt", "index", "filter", "some", "charCode", "isNaN", "substring", "at", "fromNullable", "charAt", "codePointAt", "indexOf", "greaterThanOrEqualTo", "lastIndexOf", "localeCompare", "locales", "options", "sign", "match", "regexp", "matchAll", "normalize", "form", "padEnd", "maxLength", "fillString", "padStart", "repeat", "count", "replaceAll", "search", "toLocaleLowerCase", "locale", "toLocaleUpperCase", "takeLeft", "n", "Math", "max", "takeRight", "floor", "Infinity", "CR", "LF", "linesIterator", "linesSeparated", "linesWithSeparators", "s", "stripMarginWith", "marginChar", "line", "stripped", "stripMargin", "snakeToCamel", "str", "i", "snakeToPascal", "snakeToKebab", "camelToSnake", "pascalToSnake", "kebabToSnake", "LinesIterator", "constructor", "next", "done", "value", "undefined", "isLineBreak", "char", "isLineBreak2", "Symbol", "iterator", "code", "char0", "char1"]
}
