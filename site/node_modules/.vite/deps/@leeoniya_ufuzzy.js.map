{
  "version": 3,
  "sources": ["../../../../node_modules/@leeoniya/ufuzzy/dist/uFuzzy.esm.js"],
  "sourcesContent": ["/**\n* Copyright (c) 2023, Leon Sorokin\n* All rights reserved. (MIT Licensed)\n*\n* uFuzzy.js (μFuzzy)\n* A tiny, efficient fuzzy matcher that doesn't suck\n* https://github.com/leeoniya/uFuzzy (v1.0.10)\n*/\n\nconst cmp = new Intl.Collator('en').compare;\n\nconst inf = Infinity;\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions#escaping\nconst escapeRegExp = str => str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n\n// meh, magic tmp placeholder, must be tolerant to toLocaleLowerCase(), interSplit, and intraSplit\nconst EXACT_HERE = 'eexxaacctt';\n\nconst LATIN_UPPER = 'A-Z';\nconst LATIN_LOWER = 'a-z';\n\nconst swapAlpha = (str, upper, lower) => str.replace(LATIN_UPPER, upper).replace(LATIN_LOWER, lower);\n\nconst OPTS = {\n\t// whether regexps use a /u unicode flag\n\tunicode: false,\n\n\talpha: null,\n\n\t// term segmentation & punct/whitespace merging\n\tinterSplit: \"[^A-Za-z\\\\d']+\",\n\tintraSplit: \"[a-z][A-Z]\",\n\n\t// intra bounds that will be used to increase lft1/rgt1 info counters\n\tintraBound: \"[A-Za-z]\\\\d|\\\\d[A-Za-z]|[a-z][A-Z]\",\n\n\t// inter-bounds mode\n\t// 2 = strict (will only match 'man' on whitepace and punct boundaries: Mega Man, Mega_Man, mega.man)\n\t// 1 = loose  (plus allowance for alpha-num and case-change boundaries: MegaMan, 0007man)\n\t// 0 = any    (will match 'man' as any substring: megamaniac)\n\tinterLft: 0,\n\tinterRgt: 0,\n\n\t// allowance between terms\n\tinterChars: '.',\n\tinterIns: inf,\n\n\t// allowance between chars in terms\n\tintraChars: \"[a-z\\\\d']\", // internally case-insensitive\n\tintraIns: 0,\n\n\tintraContr: \"'[a-z]{1,2}\\\\b\",\n\n\t// multi-insert or single-error mode\n\tintraMode: 0,\n\n\t// single-error bounds for errors within terms, default requires exact first char\n\tintraSlice: [1, inf],\n\n\t// single-error tolerance toggles\n\tintraSub: 0,\n\tintraTrn: 0,\n\tintraDel: 0,\n\n\t// can post-filter matches that are too far apart in distance or length\n\t// (since intraIns is between each char, it can accum to nonsense matches)\n\tintraFilt: (term, match, index) => true, // should this also accept WIP info?\n\n\t// final sorting fn\n\tsort: (info, haystack, needle) => {\n\t\tlet {\n\t\t\tidx,\n\t\t\tchars,\n\t\t\tterms,\n\t\t\tinterLft2,\n\t\t\tinterLft1,\n\t\t//\tinterRgt2,\n\t\t//\tinterRgt1,\n\t\t\tstart,\n\t\t\tintraIns,\n\t\t\tinterIns,\n\t\t} = info;\n\n\t\treturn idx.map((v, i) => i).sort((ia, ib) => (\n\t\t\t// most contig chars matched\n\t\t\tchars[ib] - chars[ia] ||\n\t\t\t// least char intra-fuzz (most contiguous)\n\t\t\tintraIns[ia] - intraIns[ib] ||\n\t\t\t// most prefix bounds, boosted by full term matches\n\t\t\t(\n\t\t\t\t(terms[ib] + interLft2[ib] + 0.5 * interLft1[ib]) -\n\t\t\t\t(terms[ia] + interLft2[ia] + 0.5 * interLft1[ia])\n\t\t\t) ||\n\t\t\t// highest density of match (least span)\n\t\t//\tspan[ia] - span[ib] ||\n\t\t\t// highest density of match (least term inter-fuzz)\n\t\t\tinterIns[ia] - interIns[ib] ||\n\t\t\t// earliest start of match\n\t\t\tstart[ia] - start[ib] ||\n\t\t\t// alphabetic\n\t\t\tcmp(haystack[idx[ia]], haystack[idx[ib]])\n\t\t));\n\t},\n};\n\nconst lazyRepeat = (chars, limit) => (\n\tlimit == 0   ? ''           :\n\tlimit == 1   ? chars + '??' :\n\tlimit == inf ? chars + '*?' :\n\t               chars + `{0,${limit}}?`\n);\n\nconst mode2Tpl = '(?:\\\\b|_)';\n\nfunction uFuzzy(opts) {\n\topts = Object.assign({}, OPTS, opts);\n\n\tlet {\n\t\tunicode,\n\t\tinterLft,\n\t\tinterRgt,\n\t\tintraMode,\n\t\tintraSlice,\n\t\tintraIns,\n\t\tintraSub,\n\t\tintraTrn,\n\t\tintraDel,\n\t\tintraContr,\n\t\tintraSplit: _intraSplit,\n\t\tinterSplit: _interSplit,\n\t\tintraBound: _intraBound,\n\t\tintraChars,\n\t} = opts;\n\n\tlet alpha = opts.letters ?? opts.alpha;\n\n\tif (alpha != null) {\n\t\tlet upper = alpha.toLocaleUpperCase();\n\t\tlet lower = alpha.toLocaleLowerCase();\n\n\t\t_interSplit = swapAlpha(_interSplit, upper, lower);\n\t\t_intraSplit = swapAlpha(_intraSplit, upper, lower);\n\t\t_intraBound = swapAlpha(_intraBound, upper, lower);\n\t\tintraChars = swapAlpha(intraChars, upper, lower);\n\t\tintraContr = swapAlpha(intraContr, upper, lower);\n\t}\n\n\tlet uFlag = unicode ? 'u' : '';\n\n\tconst EXACTS_RE = new RegExp('\".+?\"', 'gi' + uFlag);\n\tconst NEGS_RE = new RegExp(`(?:\\\\s+|^)-${intraChars}+`, 'gi' + uFlag);\n\n\tlet { intraRules } = opts;\n\n\tif (intraRules == null) {\n\t\tintraRules = p => {\n\t\t\t// default is exact term matches only\n\t\t\tlet _intraSlice = OPTS.intraSlice, // requires first char\n\t\t\t\t_intraIns = 0,\n\t\t\t\t_intraSub = 0,\n\t\t\t\t_intraTrn = 0,\n\t\t\t\t_intraDel = 0;\n\n\t\t\tlet plen = p.length;\n\n\t\t\t// prevent junk matches by requiring stricter rules for short terms\n\t\t\tif (plen <= 4) {\n\t\t\t\tif (plen >= 3) {\n\t\t\t\t\t// one swap in non-first char when 3-4 chars\n\t\t\t\t\t_intraTrn = Math.min(intraTrn, 1);\n\n\t\t\t\t\t// or one insertion when 4 chars\n\t\t\t\t\tif (plen == 4)\n\t\t\t\t\t\t_intraIns = Math.min(intraIns, 1);\n\t\t\t\t}\n\t\t\t\t// else exact match when 1-2 chars\n\t\t\t}\n\t\t\t// use supplied opts\n\t\t\telse {\n\t\t\t\t_intraSlice = intraSlice;\n\t\t\t\t_intraIns = intraIns,\n\t\t\t\t_intraSub = intraSub,\n\t\t\t\t_intraTrn = intraTrn,\n\t\t\t\t_intraDel = intraDel;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tintraSlice: _intraSlice,\n\t\t\t\tintraIns: _intraIns,\n\t\t\t\tintraSub: _intraSub,\n\t\t\t\tintraTrn: _intraTrn,\n\t\t\t\tintraDel: _intraDel,\n\t\t\t};\n\t\t};\n\t}\n\n\tlet withIntraSplit = !!_intraSplit;\n\n\tlet intraSplit = new RegExp(_intraSplit, 'g' + uFlag);\n\tlet interSplit = new RegExp(_interSplit, 'g' + uFlag);\n\n\tlet trimRe = new RegExp('^' + _interSplit + '|' + _interSplit + '$', 'g' + uFlag);\n\tlet contrsRe = new RegExp(intraContr, 'gi' + uFlag);\n\n\tconst split = needle => {\n\t\tlet exacts = [];\n\n\t\tneedle = needle.replace(EXACTS_RE, m => {\n\t\t\texacts.push(m);\n\t\t\treturn EXACT_HERE;\n\t\t});\n\n\t\tneedle = needle.replace(trimRe, '').toLocaleLowerCase();\n\n\t\tif (withIntraSplit)\n\t\t\tneedle = needle.replace(intraSplit, m => m[0] + ' ' + m[1]);\n\n\t\tlet j = 0;\n\t\treturn needle.split(interSplit).filter(t => t != '').map(v => v === EXACT_HERE ? exacts[j++] : v);\n\t};\n\n\tconst prepQuery = (needle, capt = 0, interOR = false) => {\n\t\t// split on punct, whitespace, num-alpha, and upper-lower boundaries\n\t\tlet parts = split(needle);\n\n\t\tif (parts.length == 0)\n\t\t\treturn [];\n\n\t\t// split out any detected contractions for each term that become required suffixes\n\t\tlet contrs = Array(parts.length).fill('');\n\t\tparts = parts.map((p, pi) => p.replace(contrsRe, m => {\n\t\t\tcontrs[pi] = m;\n\t\t\treturn '';\n\t\t}));\n\n\t\t// array of regexp tpls for each term\n\t\tlet reTpl;\n\n\t\t// allows single mutations within each term\n\t\tif (intraMode == 1) {\n\t\t\treTpl = parts.map((p, pi) => {\n\t\t\t\tlet {\n\t\t\t\t\tintraSlice,\n\t\t\t\t\tintraIns,\n\t\t\t\t\tintraSub,\n\t\t\t\t\tintraTrn,\n\t\t\t\t\tintraDel,\n\t\t\t\t} = intraRules(p);\n\n\t\t\t\tif (intraIns + intraSub + intraTrn + intraDel == 0)\n\t\t\t\t\treturn p + contrs[pi];\n\n\t\t\t\tif (p[0] === '\"')\n\t\t\t\t\treturn escapeRegExp(p.slice(1, -1));\n\n\t\t\t\tlet [lftIdx, rgtIdx] = intraSlice;\n\t\t\t\tlet lftChar = p.slice(0, lftIdx); // prefix\n\t\t\t\tlet rgtChar = p.slice(rgtIdx);    // suffix\n\n\t\t\t\tlet chars = p.slice(lftIdx, rgtIdx);\n\n\t\t\t\t// neg lookahead to prefer matching 'Test' instead of 'tTest' in ManifestTest or fittest\n\t\t\t\t// but skip when search term contains leading repetition (aardvark, aaa)\n\t\t\t\tif (intraIns == 1 && lftChar.length == 1 && lftChar != chars[0])\n\t\t\t\t\tlftChar += '(?!' + lftChar + ')';\n\n\t\t\t\tlet numChars = chars.length;\n\n\t\t\t\tlet variants = [p];\n\n\t\t\t\t// variants with single char substitutions\n\t\t\t\tif (intraSub) {\n\t\t\t\t\tfor (let i = 0; i < numChars; i++)\n\t\t\t\t\t\tvariants.push(lftChar + chars.slice(0, i) + intraChars + chars.slice(i + 1) + rgtChar);\n\t\t\t\t}\n\n\t\t\t\t// variants with single transpositions\n\t\t\t\tif (intraTrn) {\n\t\t\t\t\tfor (let i = 0; i < numChars - 1; i++) {\n\t\t\t\t\t\tif (chars[i] != chars[i+1])\n\t\t\t\t\t\t\tvariants.push(lftChar + chars.slice(0, i) + chars[i+1] + chars[i] + chars.slice(i + 2) + rgtChar);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// variants with single char omissions\n\t\t\t\tif (intraDel) {\n\t\t\t\t\tfor (let i = 0; i < numChars; i++)\n\t\t\t\t\t\tvariants.push(lftChar + chars.slice(0, i + 1) + '?' + chars.slice(i + 1) + rgtChar);\n\t\t\t\t}\n\n\t\t\t\t// variants with single char insertions\n\t\t\t\tif (intraIns) {\n\t\t\t\t\tlet intraInsTpl = lazyRepeat(intraChars, 1);\n\n\t\t\t\t\tfor (let i = 0; i < numChars; i++)\n\t\t\t\t\t\tvariants.push(lftChar + chars.slice(0, i) + intraInsTpl + chars.slice(i) + rgtChar);\n\t\t\t\t}\n\n\t\t\t\tlet reTpl = '(?:' + variants.join('|') + ')' + contrs[pi];\n\n\t\t\t//\tconsole.log(reTpl);\n\n\t\t\t\treturn reTpl;\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tlet intraInsTpl = lazyRepeat(intraChars, intraIns);\n\n\t\t\t// capture at char level\n\t\t\tif (capt == 2 && intraIns > 0) {\n\t\t\t\t// sadly, we also have to capture the inter-term junk via parenth-wrapping .*?\n\t\t\t\t// to accum other capture groups' indices for \\b boosting during scoring\n\t\t\t\tintraInsTpl = ')(' + intraInsTpl + ')(';\n\t\t\t}\n\n\t\t\treTpl = parts.map((p, pi) => p[0] === '\"' ? escapeRegExp(p.slice(1, -1)) :  p.split('').map((c, i, chars) => {\n\t\t\t\t// neg lookahead to prefer matching 'Test' instead of 'tTest' in ManifestTest or fittest\n\t\t\t\t// but skip when search term contains leading repetition (aardvark, aaa)\n\t\t\t\tif (intraIns == 1 && i == 0 && chars.length > 1 && c != chars[i+1])\n\t\t\t\t\tc += '(?!' + c + ')';\n\n\t\t\t\treturn c;\n\t\t\t}).join(intraInsTpl) + contrs[pi]);\n\t\t}\n\n\t//\tconsole.log(reTpl);\n\n\t\t// this only helps to reduce initial matches early when they can be detected\n\t\t// TODO: might want a mode 3 that excludes _\n\t\tlet preTpl = interLft == 2 ? mode2Tpl : '';\n\t\tlet sufTpl = interRgt == 2 ? mode2Tpl : '';\n\n\t\tlet interCharsTpl = sufTpl + lazyRepeat(opts.interChars, opts.interIns) + preTpl;\n\n\t\t// capture at word level\n\t\tif (capt > 0) {\n\t\t\tif (interOR) {\n\t\t\t\t// this is basically for doing .matchAll() occurence counting and highlighting without needing permuted ooo needles\n\t\t\t\treTpl = preTpl + '(' + reTpl.join(')' + sufTpl + '|' + preTpl + '(') + ')' + sufTpl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// sadly, we also have to capture the inter-term junk via parenth-wrapping .*?\n\t\t\t\t// to accum other capture groups' indices for \\b boosting during scoring\n\t\t\t\treTpl = '(' + reTpl.join(')(' + interCharsTpl + ')(') + ')';\n\t\t\t\treTpl = '(.??' + preTpl + ')' + reTpl + '(' + sufTpl + '.*)'; // nit: trailing capture here assumes interIns = Inf\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treTpl = reTpl.join(interCharsTpl);\n\t\t\treTpl = preTpl + reTpl + sufTpl;\n\t\t}\n\n\t//\tconsole.log(reTpl);\n\n\t\treturn [new RegExp(reTpl, 'i' + uFlag), parts, contrs];\n\t};\n\n\tconst filter = (haystack, needle, idxs) => {\n\n\t\tlet [query] = prepQuery(needle);\n\n\t\tif (query == null)\n\t\t\treturn null;\n\n\t\tlet out = [];\n\n\t\tif (idxs != null) {\n\t\t\tfor (let i = 0; i < idxs.length; i++) {\n\t\t\t\tlet idx = idxs[i];\n\t\t\t\tquery.test(haystack[idx]) && out.push(idx);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (let i = 0; i < haystack.length; i++)\n\t\t\t\tquery.test(haystack[i]) && out.push(i);\n\t\t}\n\n\t\treturn out;\n\t};\n\n\tlet withIntraBound = !!_intraBound;\n\n\tlet interBound = new RegExp(_interSplit, uFlag);\n\tlet intraBound = new RegExp(_intraBound, uFlag);\n\n\tconst info = (idxs, haystack, needle) => {\n\n\t\tlet [query, parts, contrs] = prepQuery(needle, 1);\n\t\tlet [queryR] = prepQuery(needle, 2);\n\t\tlet partsLen = parts.length;\n\n\t\tlet len = idxs.length;\n\n\t\tlet field = Array(len).fill(0);\n\n\t\tlet info = {\n\t\t\t// idx in haystack\n\t\t\tidx: Array(len),\n\n\t\t\t// start of match\n\t\t\tstart: field.slice(),\n\t\t\t// length of match\n\t\t//\tspan: field.slice(),\n\n\t\t\t// contiguous chars matched\n\t\t\tchars: field.slice(),\n\n\t\t\t// contiguous (no fuzz) and bounded terms (intra=0, lft2/1, rgt2/1)\n\t\t\t// excludes terms that are contiguous but have < 2 bounds (substrings)\n\t\t\tterms: field.slice(),\n\n\t\t\t// cumulative length of unmatched chars (fuzz) within span\n\t\t\tinterIns: field.slice(), // between terms\n\t\t\tintraIns: field.slice(), // within terms\n\n\t\t\t// interLft/interRgt counters\n\t\t\tinterLft2: field.slice(),\n\t\t\tinterRgt2: field.slice(),\n\t\t\tinterLft1: field.slice(),\n\t\t\tinterRgt1: field.slice(),\n\n\t\t\tranges: Array(len),\n\t\t};\n\n\t\t// might discard idxs based on bounds checks\n\t\tlet mayDiscard = interLft == 1 || interRgt == 1;\n\n\t\tlet ii = 0;\n\n\t\tfor (let i = 0; i < idxs.length; i++) {\n\t\t\tlet mhstr = haystack[idxs[i]];\n\n\t\t\t// the matched parts are [full, junk, term, junk, term, junk]\n\t\t\tlet m = mhstr.match(query);\n\n\t\t\t// leading junk\n\t\t\tlet start = m.index + m[1].length;\n\n\t\t\tlet idxAcc = start;\n\t\t//\tlet span = m[0].length;\n\n\t\t\tlet disc = false;\n\t\t\tlet lft2 = 0;\n\t\t\tlet lft1 = 0;\n\t\t\tlet rgt2 = 0;\n\t\t\tlet rgt1 = 0;\n\t\t\tlet chars = 0;\n\t\t\tlet terms = 0;\n\t\t\tlet inter = 0;\n\t\t\tlet intra = 0;\n\n\t\t\tlet refine = [];\n\n\t\t\tfor (let j = 0, k = 2; j < partsLen; j++, k+=2) {\n\t\t\t\tlet group = m[k].toLocaleLowerCase();\n\t\t\t\tlet part = parts[j];\n\t\t\t\tlet term = part[0] == '\"' ? part.slice(1, -1) : part + contrs[j];\n\t\t\t\tlet termLen = term.length;\n\t\t\t\tlet groupLen = group.length;\n\t\t\t\tlet fullMatch = group == term;\n\n\t\t\t\t// this won't handle the case when an exact match exists across the boundary of the current group and the next junk\n\t\t\t\t// e.g. blob,ob when searching for 'bob' but finding the earlier `blob` (with extra insertion)\n\t\t\t\tif (!fullMatch && m[k+1].length >= termLen) {\n\t\t\t\t\t// probe for exact match in inter junk (TODO: maybe even in this matched part?)\n\t\t\t\t\tlet idxOf = m[k+1].toLocaleLowerCase().indexOf(term);\n\n\t\t\t\t\tif (idxOf > -1) {\n\t\t\t\t\t\trefine.push(idxAcc, groupLen, idxOf, termLen);\n\t\t\t\t\t\tidxAcc += refineMatch(m, k, idxOf, termLen);\n\t\t\t\t\t\tgroup = term;\n\t\t\t\t\t\tgroupLen = termLen;\n\t\t\t\t\t\tfullMatch = true;\n\n\t\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\t\tstart = idxAcc;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (mayDiscard || fullMatch) {\n\t\t\t\t\t// does group's left and/or right land on \\b\n\t\t\t\t\tlet lftCharIdx = idxAcc - 1;\n\t\t\t\t\tlet rgtCharIdx = idxAcc + groupLen;\n\n\t\t\t\t\tlet isPre = false;\n\t\t\t\t\tlet isSuf = false;\n\n\t\t\t\t\t// prefix info\n\t\t\t\t\tif (lftCharIdx == -1           || interBound.test(mhstr[lftCharIdx])) {\n\t\t\t\t\t\tfullMatch && lft2++;\n\t\t\t\t\t\tisPre = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (interLft == 2) {\n\t\t\t\t\t\t\tdisc = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (withIntraBound && intraBound.test(mhstr[lftCharIdx] + mhstr[lftCharIdx + 1])) {\n\t\t\t\t\t\t\tfullMatch && lft1++;\n\t\t\t\t\t\t\tisPre = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (interLft == 1) {\n\t\t\t\t\t\t\t\t// regexps are eager, so try to improve the match by probing forward inter junk for exact match at a boundary\n\t\t\t\t\t\t\t\tlet junk = m[k+1];\n\t\t\t\t\t\t\t\tlet junkIdx = idxAcc + groupLen;\n\n\t\t\t\t\t\t\t\tif (junk.length >= termLen) {\n\t\t\t\t\t\t\t\t\tlet idxOf = 0;\n\t\t\t\t\t\t\t\t\tlet found = false;\n\t\t\t\t\t\t\t\t\tlet re = new RegExp(term, 'ig' + uFlag);\n\n\t\t\t\t\t\t\t\t\tlet m2;\n\t\t\t\t\t\t\t\t\twhile (m2 = re.exec(junk)) {\n\t\t\t\t\t\t\t\t\t\tidxOf = m2.index;\n\n\t\t\t\t\t\t\t\t\t\tlet charIdx = junkIdx + idxOf;\n\t\t\t\t\t\t\t\t\t\tlet lftCharIdx = charIdx - 1;\n\n\t\t\t\t\t\t\t\t\t\tif (lftCharIdx == -1 || interBound.test(mhstr[lftCharIdx])) {\n\t\t\t\t\t\t\t\t\t\t\tlft2++;\n\t\t\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse if (intraBound.test(mhstr[lftCharIdx] + mhstr[charIdx])) {\n\t\t\t\t\t\t\t\t\t\t\tlft1++;\n\t\t\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (found) {\n\t\t\t\t\t\t\t\t\t\tisPre = true;\n\n\t\t\t\t\t\t\t\t\t\t// identical to exact term refinement pass above\n\t\t\t\t\t\t\t\t\t\trefine.push(idxAcc, groupLen, idxOf, termLen);\n\t\t\t\t\t\t\t\t\t\tidxAcc += refineMatch(m, k, idxOf, termLen);\n\t\t\t\t\t\t\t\t\t\tgroup = term;\n\t\t\t\t\t\t\t\t\t\tgroupLen = termLen;\n\t\t\t\t\t\t\t\t\t\tfullMatch = true;\n\n\t\t\t\t\t\t\t\t\t\tif (j == 0)\n\t\t\t\t\t\t\t\t\t\t\tstart = idxAcc;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (!isPre) {\n\t\t\t\t\t\t\t\t\tdisc = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// suffix info\n\t\t\t\t\tif (rgtCharIdx == mhstr.length || interBound.test(mhstr[rgtCharIdx])) {\n\t\t\t\t\t\tfullMatch && rgt2++;\n\t\t\t\t\t\tisSuf = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (interRgt == 2) {\n\t\t\t\t\t\t\tdisc = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (withIntraBound && intraBound.test(mhstr[rgtCharIdx - 1] + mhstr[rgtCharIdx])) {\n\t\t\t\t\t\t\tfullMatch && rgt1++;\n\t\t\t\t\t\t\tisSuf = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (interRgt == 1) {\n\t\t\t\t\t\t\t\tdisc = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (fullMatch) {\n\t\t\t\t\t\tchars += termLen;\n\n\t\t\t\t\t\tif (isPre && isSuf)\n\t\t\t\t\t\t\tterms++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (groupLen > termLen)\n\t\t\t\t\tintra += groupLen - termLen; // intraFuzz\n\n\t\t\t\tif (j > 0)\n\t\t\t\t\tinter += m[k-1].length; // interFuzz\n\n\t\t\t\t// TODO: group here is lowercased, which is okay for length cmp, but not more case-sensitive filts\n\t\t\t\tif (!opts.intraFilt(term, group, idxAcc)) {\n\t\t\t\t\tdisc = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (j < partsLen - 1)\n\t\t\t\t\tidxAcc += groupLen + m[k+1].length;\n\t\t\t}\n\n\t\t\tif (!disc) {\n\t\t\t\tinfo.idx[ii]       = idxs[i];\n\t\t\t\tinfo.interLft2[ii] = lft2;\n\t\t\t\tinfo.interLft1[ii] = lft1;\n\t\t\t\tinfo.interRgt2[ii] = rgt2;\n\t\t\t\tinfo.interRgt1[ii] = rgt1;\n\t\t\t\tinfo.chars[ii]     = chars;\n\t\t\t\tinfo.terms[ii]     = terms;\n\t\t\t\tinfo.interIns[ii]  = inter;\n\t\t\t\tinfo.intraIns[ii]  = intra;\n\n\t\t\t\tinfo.start[ii] = start;\n\t\t\t//\tinfo.span[ii] = span;\n\n\t\t\t\t// ranges\n\t\t\t\tlet m = mhstr.match(queryR);\n\n\t\t\t\tlet idxAcc = m.index + m[1].length;\n\n\t\t\t\tlet refLen = refine.length;\n\t\t\t\tlet ri = refLen > 0 ? 0 : Infinity;\n\t\t\t\tlet lastRi = refLen - 4;\n\n\t\t\t\tfor (let i = 2; i < m.length;) {\n\t\t\t\t\tlet len = m[i].length;\n\n\t\t\t\t\tif (ri <= lastRi && refine[ri] == idxAcc) {\n\t\t\t\t\t\tlet groupLen = refine[ri+1];\n\t\t\t\t\t\tlet idxOf    = refine[ri+2];\n\t\t\t\t\t\tlet termLen  = refine[ri+3];\n\n\t\t\t\t\t\t// advance to end of original (full) group match that includes intra-junk\n\t\t\t\t\t\tlet j = i;\n\t\t\t\t\t\tlet v = '';\n\t\t\t\t\t\tfor (let _len = 0; _len < groupLen; j++) {\n\t\t\t\t\t\t\tv += m[j];\n\t\t\t\t\t\t\t_len += m[j].length;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tm.splice(i, j - i, v);\n\n\t\t\t\t\t\tidxAcc += refineMatch(m, i, idxOf, termLen);\n\n\t\t\t\t\t\tri += 4;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tidxAcc += len;\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tidxAcc = m.index + m[1].length;\n\n\t\t\t\tlet ranges = info.ranges[ii] = [];\n\t\t\t\tlet from = idxAcc;\n\t\t\t\tlet to = idxAcc;\n\n\t\t\t\tfor (let i = 2; i < m.length; i++) {\n\t\t\t\t\tlet len = m[i].length;\n\n\t\t\t\t\tidxAcc += len;\n\n\t\t\t\t\tif (i % 2 == 0)\n\t\t\t\t\t\tto = idxAcc;\n\t\t\t\t\telse if (len > 0) {\n\t\t\t\t\t\tranges.push(from, to);\n\t\t\t\t\t\tfrom = to = idxAcc;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (to > from)\n\t\t\t\t\tranges.push(from, to);\n\n\t\t\t\tii++;\n\t\t\t}\n\t\t}\n\n\t\t// trim arrays\n\t\tif (ii < idxs.length) {\n\t\t\tfor (let k in info)\n\t\t\t\tinfo[k] = info[k].slice(0, ii);\n\t\t}\n\n\t\treturn info;\n\t};\n\n\tconst refineMatch = (m, k, idxInNext, termLen) => {\n\t\t// shift the current group into the prior junk\n\t\tlet prepend = m[k] + m[k+1].slice(0, idxInNext);\n\t\tm[k-1] += prepend;\n\t\tm[k]    = m[k+1].slice(idxInNext, idxInNext + termLen);\n\t\tm[k+1]  = m[k+1].slice(idxInNext + termLen);\n\t\treturn prepend.length;\n\t};\n\n\t// returns [idxs, info, order]\n\tconst _search = (haystack, needle, outOfOrder = false, infoThresh = 1e3, preFiltered) => {\n\t\tlet needles = null;\n\t\tlet matches = null;\n\n\t\tlet negs = [];\n\n\t\tneedle = needle.replace(NEGS_RE, m => {\n\t\t\tnegs.push(m.trim().slice(1));\n\t\t\treturn '';\n\t\t});\n\n\t\tlet terms = split(needle);\n\n\t\tlet negsRe;\n\n\t\tif (negs.length > 0) {\n\t\t\tnegsRe = new RegExp(negs.join('|'), 'i' + uFlag);\n\n\t\t\tif (terms.length == 0) {\n\t\t\t\tlet idxs = [];\n\n\t\t\t\tfor (let i = 0; i < haystack.length; i++) {\n\t\t\t\t\tif (!negsRe.test(haystack[i]))\n\t\t\t\t\t\tidxs.push(i);\n\t\t\t\t}\n\n\t\t\t\treturn [idxs, null, null];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// abort search (needle is empty after pre-processing, e.g. no alpha-numeric chars)\n\t\t\tif (terms.length == 0)\n\t\t\t\treturn [null, null, null];\n\t\t}\n\n\t//\tconsole.log(negs);\n\t//\tconsole.log(needle);\n\n\t\tif (outOfOrder) {\n\t\t\t// since uFuzzy is an AND-based search, we can iteratively pre-reduce the haystack by searching\n\t\t\t// for each term in isolation before running permutations on what's left.\n\t\t\t// this is a major perf win. e.g. searching \"test man ger pp a\" goes from 570ms -> 14ms\n\t\t\tlet terms = split(needle);\n\n\t\t\tif (terms.length > 1) {\n\t\t\t\t// longest -> shortest\n\t\t\t\tlet terms2 = terms.slice().sort((a, b) => b.length - a.length);\n\n\t\t\t\tfor (let ti = 0; ti < terms2.length; ti++) {\n\t\t\t\t\t// no haystack item contained all terms\n\t\t\t\t\tif (preFiltered?.length == 0)\n\t\t\t\t\t\treturn [[], null, null];\n\n\t\t\t\t\tpreFiltered = filter(haystack, terms2[ti], preFiltered);\n\t\t\t\t}\n\n\t\t\t\tneedles = permute(terms).map(perm => perm.join(' '));\n\n\t\t\t\t// filtered matches for each needle excluding same matches for prior needles\n\t\t\t\tmatches = [];\n\n\t\t\t\t// keeps track of already-matched idxs to skip in follow-up permutations\n\t\t\t\tlet matchedIdxs = new Set();\n\n\t\t\t\tfor (let ni = 0; ni < needles.length; ni++) {\n\t\t\t\t\tif (matchedIdxs.size < preFiltered.length) {\n\t\t\t\t\t\t// filter further for this needle, exclude already-matched\n\t\t\t\t\t\tlet preFiltered2 = preFiltered.filter(idx => !matchedIdxs.has(idx));\n\n\t\t\t\t\t\tlet matched = filter(haystack, needles[ni], preFiltered2);\n\n\t\t\t\t\t\tfor (let j = 0; j < matched.length; j++)\n\t\t\t\t\t\t\tmatchedIdxs.add(matched[j]);\n\n\t\t\t\t\t\tmatches.push(matched);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tmatches.push([]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// interOR\n\t//\tconsole.log(prepQuery(needle, 1, null, true));\n\n\t\t// non-ooo or ooo w/single term\n\t\tif (needles == null) {\n\t\t\tneedles = [needle];\n\t\t\tmatches = [preFiltered?.length > 0 ? preFiltered : filter(haystack, needle)];\n\t\t}\n\n\t\tlet retInfo = null;\n\t\tlet retOrder = null;\n\n\t\tif (negs.length > 0)\n\t\t\tmatches = matches.map(idxs => idxs.filter(idx => !negsRe.test(haystack[idx])));\n\n\t\tlet matchCount = matches.reduce((acc, idxs) => acc + idxs.length, 0);\n\n\t\t// rank, sort, concat\n\t\tif (matchCount <= infoThresh) {\n\t\t\tretInfo = {};\n\t\t\tretOrder = [];\n\n\t\t\tfor (let ni = 0; ni < matches.length; ni++) {\n\t\t\t\tlet idxs = matches[ni];\n\n\t\t\t\tif (idxs == null || idxs.length == 0)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tlet needle = needles[ni];\n\t\t\t\tlet _info = info(idxs, haystack, needle);\n\t\t\t\tlet order = opts.sort(_info, haystack, needle);\n\n\t\t\t\t// offset idxs for concat'ing infos\n\t\t\t\tif (ni > 0) {\n\t\t\t\t\tfor (let i = 0; i < order.length; i++)\n\t\t\t\t\t\torder[i] += retOrder.length;\n\t\t\t\t}\n\n\t\t\t\tfor (let k in _info)\n\t\t\t\t\tretInfo[k] = (retInfo[k] ?? []).concat(_info[k]);\n\n\t\t\t\tretOrder = retOrder.concat(order);\n\t\t\t}\n\t\t}\n\n\t\treturn [\n\t\t\t[].concat(...matches),\n\t\t\tretInfo,\n\t\t\tretOrder,\n\t\t];\n\t};\n\n\treturn {\n\t\tsearch: (...args) => {\n\t\t\tlet out = _search(...args);\n\t\t\treturn out;\n\t\t},\n\t\tsplit,\n\t\tfilter,\n\t\tinfo,\n\t\tsort: opts.sort,\n\t};\n}\n\nconst latinize = (() => {\n\tlet accents = {\n\t\tA: 'ÁÀÃÂÄĄ',\n\t\ta: 'áàãâäą',\n\t\tE: 'ÉÈÊËĖ',\n\t\te: 'éèêëę',\n\t\tI: 'ÍÌÎÏĮ',\n\t\ti: 'íìîïį',\n\t\tO: 'ÓÒÔÕÖ',\n\t\to: 'óòôõö',\n\t\tU: 'ÚÙÛÜŪŲ',\n\t\tu: 'úùûüūų',\n\t\tC: 'ÇČ',\n\t\tc: 'çč',\n\t\tN: 'Ñ',\n\t\tn: 'ñ',\n\t\tS: 'Š',\n\t\ts: 'š'\n\t};\n\n\tlet accentsMap = new Map();\n\tlet accentsTpl = '';\n\n\tfor (let r in accents) {\n\t\taccents[r].split('').forEach(a => {\n\t\t\taccentsTpl += a;\n\t\t\taccentsMap.set(a, r);\n\t\t});\n\t}\n\n\tlet accentsRe = new RegExp(`[${accentsTpl}]`, 'g');\n\tlet replacer = m => accentsMap.get(m);\n\n\treturn strings => {\n\t\tif (typeof strings == 'string')\n\t\t\treturn strings.replace(accentsRe, replacer);\n\n\t\tlet out = Array(strings.length);\n\t\tfor (let i = 0; i < strings.length; i++)\n\t\t\tout[i] = strings[i].replace(accentsRe, replacer);\n\t\treturn out;\n\t};\n})();\n\n// https://stackoverflow.com/questions/9960908/permutations-in-javascript/37580979#37580979\nfunction permute(arr) {\n\tarr = arr.slice();\n\n\tlet length = arr.length,\n\t\tresult = [arr.slice()],\n\t\tc = new Array(length).fill(0),\n\t\ti = 1, k, p;\n\n\twhile (i < length) {\n\t\tif (c[i] < i) {\n\t\t\tk = i % 2 && c[i];\n\t\t\tp = arr[i];\n\t\t\tarr[i] = arr[k];\n\t\t\tarr[k] = p;\n\t\t\t++c[i];\n\t\t\ti = 1;\n\t\t\tresult.push(arr.slice());\n\t\t} else {\n\t\t\tc[i] = 0;\n\t\t\t++i;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nconst _mark = (part, matched) => matched ? `<mark>${part}</mark>` : part;\nconst _append = (acc, part) => acc + part;\n\nfunction highlight(str, ranges, mark = _mark, accum = '', append = _append) {\n\taccum = append(accum, mark(str.substring(0, ranges[0]), false)) ?? accum;\n\n\tfor (let i = 0; i < ranges.length; i+=2) {\n\t\tlet fr = ranges[i];\n\t\tlet to = ranges[i+1];\n\n\t\taccum = append(accum, mark(str.substring(fr, to), true)) ?? accum;\n\n\t\tif (i < ranges.length - 3)\n\t\t\taccum = append(accum, mark(str.substring(ranges[i+1], ranges[i+2]), false)) ?? accum;\n\t}\n\n\taccum = append(accum, mark(str.substring(ranges[ranges.length - 1]), false)) ?? accum;\n\n\treturn accum;\n}\n\nuFuzzy.latinize = latinize;\nuFuzzy.permute = arr => {\n\tlet idxs = permute([...Array(arr.length).keys()]).sort((a,b) => {\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tif (a[i] != b[i])\n\t\t\t\treturn a[i] - b[i];\n\t\t}\n\t\treturn 0;\n\t});\n\n\treturn idxs.map(pi => pi.map(i => arr[i]));\n};\nuFuzzy.highlight = highlight;\n\nexport { uFuzzy as default };\n"],
  "mappings": "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",
  "names": ["intraSlice", "intraIns", "intraSub", "intraTrn", "intraDel", "reTpl", "info", "lftCharIdx", "m", "idxAcc", "i", "len", "terms", "terms2", "needle"]
}
