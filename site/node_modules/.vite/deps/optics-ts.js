import "./chunk-2LSFTFF7.js";

// ../node_modules/optics-ts/dist/mjs/internals.js
var id = (x) => x;
var Left = (value) => ({
  _tag: "Left",
  value
});
var Right = (value) => ({
  _tag: "Right",
  value
});
var either = (mapLeft, mapRight, e) => e._tag === "Left" ? mapLeft(e.value) : mapRight(e.value);
var profunctorFn = {
  dimap: (f, g, fn) => (x) => g(fn(f(x))),
  first: (f) => ([x, y]) => [f(x), y],
  right: (f) => (e) => e._tag === "Left" ? e : Right(f(e.value)),
  wander: (f) => (xs) => xs.map(f)
};
var monoidFirst = {
  empty: () => void 0,
  foldMap: (f, xs) => {
    for (let i = 0; i < xs.length; i++) {
      const x = f(xs[i]);
      if (x != void 0)
        return x;
    }
    return void 0;
  }
};
var monoidArray = {
  empty: () => [],
  foldMap: (f, xs) => {
    let acc = [];
    xs.forEach((x) => {
      acc = acc.concat(f(x));
    });
    return acc;
  }
};
var profunctorConst = (monoid) => ({
  dimap: (f, _g, toF) => (x) => toF(f(x)),
  first: (toF) => ([x, _y]) => toF(x),
  right: (toF) => (e) => e._tag === "Left" ? monoid.empty() : toF(e.value),
  wander: (toF) => (xs) => monoid.foldMap(toF, xs)
});
var compositionType = {
  Equivalence: {
    Equivalence: "Equivalence",
    Iso: "Iso",
    Lens: "Lens",
    Prism: "Prism",
    Traversal: "Traversal",
    Getter: "Getter",
    AffineFold: "AffineFold",
    Fold: "Fold",
    Setter: "Setter"
  },
  Iso: {
    Equivalence: "Iso",
    Iso: "Iso",
    Lens: "Lens",
    Prism: "Prism",
    Traversal: "Traversal",
    Getter: "Getter",
    AffineFold: "AffineFold",
    Fold: "Fold",
    Setter: "Setter"
  },
  Lens: {
    Equivalence: "Lens",
    Iso: "Lens",
    Lens: "Lens",
    Prism: "Prism",
    Traversal: "Traversal",
    Getter: "Getter",
    AffineFold: "AffineFold",
    Fold: "Fold",
    Setter: "Setter"
  },
  Prism: {
    Equivalence: "Prism",
    Iso: "Prism",
    Lens: "Prism",
    Prism: "Prism",
    Traversal: "Traversal",
    Getter: "AffineFold",
    AffineFold: "AffineFold",
    Fold: "Fold",
    Setter: "Setter"
  },
  Traversal: {
    Equivalence: "Traversal",
    Iso: "Traversal",
    Lens: "Traversal",
    Prism: "Traversal",
    Traversal: "Traversal",
    Getter: "Fold",
    AffineFold: "Fold",
    Fold: "Fold",
    Setter: "Setter"
  },
  Getter: {
    Equivalence: "Getter",
    Iso: "Getter",
    Lens: "Getter",
    Prism: "AffineFold",
    Traversal: "Fold",
    Getter: "Getter",
    AffineFold: "AffineFold",
    Fold: "Fold",
    Setter: void 0
  },
  AffineFold: {
    Equivalence: "AffineFold",
    Iso: "AffineFold",
    Lens: "AffineFold",
    Prism: "AffineFold",
    Traversal: "Fold",
    Getter: "AffineFold",
    AffineFold: "AffineFold",
    Fold: "Fold",
    Setter: void 0
  },
  Fold: {
    Equivalence: "Fold",
    Iso: "Fold",
    Lens: "Fold",
    Prism: "Fold",
    Traversal: "Fold",
    Getter: "Fold",
    AffineFold: "Fold",
    Fold: "Fold",
    Setter: void 0
  },
  Setter: {
    Equivalence: void 0,
    Iso: void 0,
    Lens: void 0,
    Prism: void 0,
    Traversal: void 0,
    Getter: void 0,
    AffineFold: void 0,
    Fold: void 0,
    Setter: void 0
  }
};
var withTag = (tag, optic3) => {
  const result = optic3;
  result._tag = tag;
  return result;
};
var removable = (optic3) => {
  optic3._removable = true;
  return optic3;
};
function compose(optic1, optic22, optic3) {
  switch (arguments.length) {
    case 2: {
      const next = (P, optic4) => optic1(P, optic22(P, optic4));
      next._tag = compositionType[optic1._tag][optic22._tag];
      next._removable = optic22._removable || false;
      return next;
    }
    default: {
      const tag1 = compositionType[optic1._tag][optic22._tag];
      const next = (P, optic4) => optic1(P, optic22(P, optic3(P, optic4)));
      next._tag = compositionType[tag1][optic3._tag];
      next._removable = optic3._removable || false;
      return next;
    }
  }
}
var eq = withTag("Equivalence", (_P, optic3) => optic3);
var iso = (there, back) => withTag("Iso", (P, optic3) => P.dimap(there, back, optic3));
var lens = (view, update) => withTag("Lens", (P, optic3) => P.dimap((x) => [view(x), x], update, P.first(optic3)));
var prism = (match, build) => withTag("Prism", (P, optic3) => P.dimap(match, (x) => either(id, build, x), P.right(optic3)));
var elems = withTag("Traversal", (P, optic3) => P.dimap(id, id, P.wander(optic3)));
var to = (fn) => withTag("Getter", (P, optic3) => P.dimap(fn, id, optic3));
var modify = (optic3, fn, source) => optic3(profunctorFn, fn)(source);
var set = (optic3, value, source) => optic3(profunctorFn, () => value)(source);
var remove = (optic3, source) => set(optic3, removeMe, source);
var get = (optic3, source) => optic3(profunctorConst({}), id)(source);
var preview = (optic3, source) => optic3(profunctorConst(monoidFirst), id)(source);
var collect = (optic3, source) => optic3(profunctorConst(monoidArray), (x) => [x])(source);
var indexed = iso((value) => value.map((v, k) => [k, v]), (value) => {
  const sorted = [...value].sort((a, b) => a[0] - b[0]);
  const result = [];
  for (let i = 0; i < sorted.length; ++i) {
    if (i === sorted.length - 1 || sorted[i][0] !== sorted[i + 1][0]) {
      result.push(sorted[i][1]);
    }
  }
  return result;
});
var prop = (key) => lens((source) => source[key], ([value, source]) => Object.assign(Object.assign({}, source), { [key]: value }));
var pick = (keys) => lens((source) => {
  const value = {};
  for (const key of keys) {
    value[key] = source[key];
  }
  return value;
}, ([value, source]) => {
  const result = Object.assign({}, source);
  for (const key of keys) {
    delete result[key];
  }
  return Object.assign(result, value);
});
var nth = (n) => lens((value) => value[n], ([value, source]) => {
  const result = source.slice();
  result[n] = value;
  return result;
});
var fst = nth(0);
var when = (pred) => prism((x) => pred(x) ? Right(x) : Left(x), id);
var noMatch = Symbol("__no_match__");
var mustMatch = when((source) => source !== noMatch);
var removeMe = Symbol("__remove_me__");
var at = (i) => removable(compose(lens((source) => 0 <= i && i < source.length ? source[i] : noMatch, ([value, source]) => {
  if (value === noMatch) {
    return source;
  }
  if (value === removeMe) {
    if (typeof source === "string") {
      return source.substring(0, i) + source.substring(i + 1);
    } else {
      return [...source.slice(0, i), ...source.slice(i + 1)];
    }
  }
  if (typeof source === "string") {
    if (i === 0) {
      return value + source.substring(1);
    }
    if (i === source.length) {
      return source.substring(0, i - 1) + value;
    }
    return source.substring(0, i) + value + source.substring(i + 1);
  } else {
    const result = source.slice();
    result[i] = value;
    return result;
  }
}), mustMatch));
var optional = prism((source) => source === void 0 ? Left(void 0) : Right(source), id);
var guard = (fn) => prism((source) => fn(source) ? Right(source) : Left(source), id);
var find = (predicate) => removable(compose(lens((source) => {
  const index = source.findIndex(predicate);
  if (index === -1) {
    return [noMatch, -1];
  }
  return [source[index], index];
}, ([[value, index], source]) => {
  if (value === noMatch) {
    return source;
  }
  if (value === removeMe) {
    return [...source.slice(0, index), ...source.slice(index + 1)];
  }
  const result = source.slice();
  result[index] = value;
  return result;
}), fst, mustMatch));
var filter = (predicate) => compose(lens((source) => {
  const indexes = source.map((item, index) => predicate(item) ? index : null).filter((index) => index != null);
  return [indexes.map((index) => source[index]), indexes];
}, ([[values, indexes], source]) => {
  const sn = source.length, vn = values.length;
  let si = 0, ii = 0, vi = 0;
  const result = [];
  while (si < sn) {
    if (indexes[ii] === si) {
      ++ii;
      if (vi < vn) {
        result.push(values[vi]);
        ++vi;
      }
    } else {
      result.push(source[si]);
    }
    ++si;
  }
  while (vi < vn) {
    result.push(values[vi++]);
  }
  return result;
}), fst);
var valueOr = (defaultValue) => lens((source) => source === void 0 ? defaultValue : source, ([value, _source]) => value);
var partsOf = (traversal) => compose(lens((source) => {
  const value = collect(traversal, source);
  return [value, value.length];
}, ([[value, originalLength], source]) => {
  if (value.length !== originalLength) {
    throw new Error("cannot add/remove elements through partsOf");
  }
  let i = 0;
  return modify(traversal, () => value[i++], source);
}), fst);
var reread = (fn) => lens((source) => fn(source), ([value, _]) => value);
var rewrite = (fn) => lens((source) => source, ([value, _]) => fn(value));
var prependTo = lens((_source) => void 0, ([value, source]) => {
  if (value === void 0)
    return source;
  return [value, ...source];
});
var appendTo = lens((_source) => void 0, ([value, source]) => {
  if (value === void 0)
    return source;
  return [...source, value];
});
var chars = compose(iso((s) => s.split(""), (a) => a.join("")), elems);
var words = compose(iso((s) => s.split(/\b/), (a) => a.join("")), elems, when((s) => !/\s+/.test(s)));
var Optic = class _Optic {
  constructor(_ref) {
    this._ref = _ref;
  }
  get _tag() {
    return this._ref._tag;
  }
  get _removable() {
    return this._ref._removable;
  }
  compose(other) {
    return new _Optic(compose(this._ref, other._ref));
  }
  iso(there, back) {
    return new _Optic(compose(this._ref, iso(there, back)));
  }
  lens(view, set3) {
    return new _Optic(compose(this._ref, lens(view, ([value, source]) => set3(source, value))));
  }
  indexed() {
    return new _Optic(compose(this._ref, indexed));
  }
  prop(key) {
    return new _Optic(compose(this._ref, prop(key)));
  }
  path(...keys) {
    if (keys.length === 1) {
      keys = keys[0].split(".");
    }
    return new _Optic(keys.reduce((ref, key) => compose(ref, prop(key)), this._ref));
  }
  pick(keys) {
    return new _Optic(compose(this._ref, pick(keys)));
  }
  nth(n) {
    return new _Optic(compose(this._ref, nth(n)));
  }
  filter(predicate) {
    return new _Optic(compose(this._ref, filter(predicate)));
  }
  valueOr(defaultValue) {
    return new _Optic(compose(this._ref, valueOr(defaultValue)));
  }
  partsOf(traversalOrFn) {
    const traversal = typeof traversalOrFn === "function" ? traversalOrFn(optic) : traversalOrFn;
    return new _Optic(compose(this._ref, partsOf(traversal._ref)));
  }
  reread(fn) {
    return new _Optic(compose(this._ref, reread(fn)));
  }
  rewrite(fn) {
    return new _Optic(compose(this._ref, rewrite(fn)));
  }
  optional() {
    return new _Optic(compose(this._ref, optional));
  }
  guard_() {
    return (fn) => this.guard(fn);
  }
  guard(fn) {
    return new _Optic(compose(this._ref, guard(fn)));
  }
  at(i) {
    return new _Optic(compose(this._ref, at(i)));
  }
  head() {
    return new _Optic(compose(this._ref, at(0)));
  }
  index(i) {
    return new _Optic(compose(this._ref, at(i)));
  }
  find(predicate) {
    return new _Optic(compose(this._ref, find(predicate)));
  }
  elems() {
    return new _Optic(compose(this._ref, elems));
  }
  to(fn) {
    return new _Optic(compose(this._ref, to(fn)));
  }
  when(predicate) {
    return new _Optic(compose(this._ref, when(predicate)));
  }
  chars() {
    return new _Optic(compose(this._ref, chars));
  }
  words() {
    return new _Optic(compose(this._ref, words));
  }
  prependTo() {
    return new _Optic(compose(this._ref, prependTo));
  }
  appendTo() {
    return new _Optic(compose(this._ref, appendTo));
  }
};
var optic = new Optic(eq);

// ../node_modules/optics-ts/dist/mjs/standalone/pipe.js
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi, ij) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    case 10:
      return ij(hi(gh(fg(ef(de(cd(bc(ab(a)))))))));
  }
  return;
}

// ../node_modules/optics-ts/dist/mjs/index.js
function compose2(optic1, optic22) {
  return optic1.compose(optic22);
}
function optic2() {
  return optic;
}
function optic_() {
  return optic;
}
function get2(optic3) {
  return (source) => get(optic3._ref, source);
}
function preview2(optic3) {
  return (source) => preview(optic3._ref, source);
}
function collect2(optic3) {
  return (source) => collect(optic3._ref, source);
}
function modify2(optic3) {
  return (f) => (source) => modify(optic3._ref, f, source);
}
function set2(optic3) {
  return (value) => (source) => set(optic3._ref, value, source);
}
function remove2(optic3) {
  return (source) => remove(optic3._ref, source);
}
export {
  collect2 as collect,
  compose2 as compose,
  get2 as get,
  modify2 as modify,
  optic2 as optic,
  optic_,
  pipe,
  preview2 as preview,
  remove2 as remove,
  set2 as set
};
//# sourceMappingURL=optics-ts.js.map
