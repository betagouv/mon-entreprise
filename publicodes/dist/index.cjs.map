{"version":3,"sources":["../../../node_modules/nearley/lib/nearley.js","../../../node_modules/moo/moo.js","../src/index.ts","../src/error.ts","../src/utils.ts","../src/AST/index.ts","../src/evaluationFunctions.ts","../src/inferNodeType.ts","../src/evaluationUtils.ts","../src/mecanisms/inlineMecanism.ts","../src/mecanisms/abattement.ts","../src/mecanisms/applicable.ts","../src/units.ts","../src/mecanisms/arrondi.ts","../src/nodeUnits.ts","../src/format.ts","../src/ruleUtils.ts","../src/AST/findCycles.ts","../src/AST/graph.ts","../src/rule.ts","../src/mecanisms/avec.ts","../src/mecanisms/trancheUtils.ts","../src/mecanisms/barème.ts","../src/mecanisms/condition.ts","../src/mecanisms/contexte.ts","../src/date.ts","../src/mecanisms/durée.ts","../src/mecanisms/est.ts","../src/mecanisms/est-non-applicable.ts","../src/mecanisms/grille.ts","../src/uniroot.ts","../src/mecanisms/inversion.ts","../src/mecanisms/max-min.ts","../src/mecanisms/somme.tsx","../src/mecanisms/moyenne.ts","../src/mecanisms/non-applicable.ts","../src/mecanisms/one-possibility.ts","../src/mecanisms/operation.ts","../src/mecanisms/parDéfaut.ts","../src/mecanisms/plafond.ts","../src/mecanisms/plancher.ts","../src/mecanisms/product.ts","../src/mecanisms/résoudre-référence-circulaire.ts","../src/mecanisms/simplifier-unité.ts","../src/mecanisms/situation.ts","../src/mecanisms/tauxProgressif.ts","../src/mecanisms/texte.ts","../src/mecanisms/toutes-ces-conditions.ts","../src/mecanisms/une-de-ces-conditions.ts","../src/mecanisms/unité.ts","../src/mecanisms/variablesManquantes.ts","../src/mecanisms/variations.ts","../src/parseExpression.ts","../src/grammarFunctions.js","../src/grammar.codegen.js","../src/reference.ts","../src/parse.ts","../src/replacement.ts","../src/parsePublicodes.ts","../src/traversedVariables.ts","../src/serializeEvaluation.ts"],"sourcesContent":["(function(root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        root.nearley = factory();\n    }\n}(this, function() {\n\n    function Rule(name, symbols, postprocess) {\n        this.id = ++Rule.highestId;\n        this.name = name;\n        this.symbols = symbols;        // a list of literal | regex class | nonterminal\n        this.postprocess = postprocess;\n        return this;\n    }\n    Rule.highestId = 0;\n\n    Rule.prototype.toString = function(withCursorAt) {\n        var symbolSequence = (typeof withCursorAt === \"undefined\")\n                             ? this.symbols.map(getSymbolShortDisplay).join(' ')\n                             : (   this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(' ')\n                                 + \" ● \"\n                                 + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(' ')     );\n        return this.name + \" → \" + symbolSequence;\n    }\n\n\n    // a State is a rule at a position from a given starting point in the input stream (reference)\n    function State(rule, dot, reference, wantedBy) {\n        this.rule = rule;\n        this.dot = dot;\n        this.reference = reference;\n        this.data = [];\n        this.wantedBy = wantedBy;\n        this.isComplete = this.dot === rule.symbols.length;\n    }\n\n    State.prototype.toString = function() {\n        return \"{\" + this.rule.toString(this.dot) + \"}, from: \" + (this.reference || 0);\n    };\n\n    State.prototype.nextState = function(child) {\n        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n        state.left = this;\n        state.right = child;\n        if (state.isComplete) {\n            state.data = state.build();\n            // Having right set here will prevent the right state and its children\n            // form being garbage collected\n            state.right = undefined;\n        }\n        return state;\n    };\n\n    State.prototype.build = function() {\n        var children = [];\n        var node = this;\n        do {\n            children.push(node.right.data);\n            node = node.left;\n        } while (node.left);\n        children.reverse();\n        return children;\n    };\n\n    State.prototype.finish = function() {\n        if (this.rule.postprocess) {\n            this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n        }\n    };\n\n\n    function Column(grammar, index) {\n        this.grammar = grammar;\n        this.index = index;\n        this.states = [];\n        this.wants = {}; // states indexed by the non-terminal they expect\n        this.scannable = []; // list of states that expect a token\n        this.completed = {}; // states that are nullable\n    }\n\n\n    Column.prototype.process = function(nextColumn) {\n        var states = this.states;\n        var wants = this.wants;\n        var completed = this.completed;\n\n        for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n            var state = states[w];\n\n            if (state.isComplete) {\n                state.finish();\n                if (state.data !== Parser.fail) {\n                    // complete\n                    var wantedBy = state.wantedBy;\n                    for (var i = wantedBy.length; i--; ) { // this line is hot\n                        var left = wantedBy[i];\n                        this.complete(left, state);\n                    }\n\n                    // special-case nullables\n                    if (state.reference === this.index) {\n                        // make sure future predictors of this rule get completed.\n                        var exp = state.rule.name;\n                        (this.completed[exp] = this.completed[exp] || []).push(state);\n                    }\n                }\n\n            } else {\n                // queue scannable states\n                var exp = state.rule.symbols[state.dot];\n                if (typeof exp !== 'string') {\n                    this.scannable.push(state);\n                    continue;\n                }\n\n                // predict\n                if (wants[exp]) {\n                    wants[exp].push(state);\n\n                    if (completed.hasOwnProperty(exp)) {\n                        var nulls = completed[exp];\n                        for (var i = 0; i < nulls.length; i++) {\n                            var right = nulls[i];\n                            this.complete(state, right);\n                        }\n                    }\n                } else {\n                    wants[exp] = [state];\n                    this.predict(exp);\n                }\n            }\n        }\n    }\n\n    Column.prototype.predict = function(exp) {\n        var rules = this.grammar.byName[exp] || [];\n\n        for (var i = 0; i < rules.length; i++) {\n            var r = rules[i];\n            var wantedBy = this.wants[exp];\n            var s = new State(r, 0, this.index, wantedBy);\n            this.states.push(s);\n        }\n    }\n\n    Column.prototype.complete = function(left, right) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n\n\n    function Grammar(rules, start) {\n        this.rules = rules;\n        this.start = start || this.rules[0].name;\n        var byName = this.byName = {};\n        this.rules.forEach(function(rule) {\n            if (!byName.hasOwnProperty(rule.name)) {\n                byName[rule.name] = [];\n            }\n            byName[rule.name].push(rule);\n        });\n    }\n\n    // So we can allow passing (rules, start) directly to Parser for backwards compatibility\n    Grammar.fromCompiled = function(rules, start) {\n        var lexer = rules.Lexer;\n        if (rules.ParserStart) {\n          start = rules.ParserStart;\n          rules = rules.ParserRules;\n        }\n        var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n        var g = new Grammar(rules, start);\n        g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n        return g;\n    }\n\n\n    function StreamLexer() {\n      this.reset(\"\");\n    }\n\n    StreamLexer.prototype.reset = function(data, state) {\n        this.buffer = data;\n        this.index = 0;\n        this.line = state ? state.line : 1;\n        this.lastLineBreak = state ? -state.col : 0;\n    }\n\n    StreamLexer.prototype.next = function() {\n        if (this.index < this.buffer.length) {\n            var ch = this.buffer[this.index++];\n            if (ch === '\\n') {\n              this.line += 1;\n              this.lastLineBreak = this.index;\n            }\n            return {value: ch};\n        }\n    }\n\n    StreamLexer.prototype.save = function() {\n      return {\n        line: this.line,\n        col: this.index - this.lastLineBreak,\n      }\n    }\n\n    StreamLexer.prototype.formatError = function(token, message) {\n        // nb. this gets called after consuming the offending token,\n        // so the culprit is index-1\n        var buffer = this.buffer;\n        if (typeof buffer === 'string') {\n            var lines = buffer\n                .split(\"\\n\")\n                .slice(\n                    Math.max(0, this.line - 5), \n                    this.line\n                );\n\n            var nextLineBreak = buffer.indexOf('\\n', this.index);\n            if (nextLineBreak === -1) nextLineBreak = buffer.length;\n            var col = this.index - this.lastLineBreak;\n            var lastLineDigits = String(this.line).length;\n            message += \" at line \" + this.line + \" col \" + col + \":\\n\\n\";\n            message += lines\n                .map(function(line, i) {\n                    return pad(this.line - lines.length + i + 1, lastLineDigits) + \" \" + line;\n                }, this)\n                .join(\"\\n\");\n            message += \"\\n\" + pad(\"\", lastLineDigits + col) + \"^\\n\";\n            return message;\n        } else {\n            return message + \" at index \" + (this.index - 1);\n        }\n\n        function pad(n, length) {\n            var s = String(n);\n            return Array(length - s.length + 1).join(\" \") + s;\n        }\n    }\n\n    function Parser(rules, start, options) {\n        if (rules instanceof Grammar) {\n            var grammar = rules;\n            var options = start;\n        } else {\n            var grammar = Grammar.fromCompiled(rules, start);\n        }\n        this.grammar = grammar;\n\n        // Read options\n        this.options = {\n            keepHistory: false,\n            lexer: grammar.lexer || new StreamLexer,\n        };\n        for (var key in (options || {})) {\n            this.options[key] = options[key];\n        }\n\n        // Setup lexer\n        this.lexer = this.options.lexer;\n        this.lexerState = undefined;\n\n        // Setup a table\n        var column = new Column(grammar, 0);\n        var table = this.table = [column];\n\n        // I could be expecting anything.\n        column.wants[grammar.start] = [];\n        column.predict(grammar.start);\n        // TODO what if start rule is nullable?\n        column.process();\n        this.current = 0; // token index\n    }\n\n    // create a reserved token for indicating a parse fail\n    Parser.fail = {};\n\n    Parser.prototype.feed = function(chunk) {\n        var lexer = this.lexer;\n        lexer.reset(chunk, this.lexerState);\n\n        var token;\n        while (true) {\n            try {\n                token = lexer.next();\n                if (!token) {\n                    break;\n                }\n            } catch (e) {\n                // Create the next column so that the error reporter\n                // can display the correctly predicted states.\n                var nextColumn = new Column(this.grammar, this.current + 1);\n                this.table.push(nextColumn);\n                var err = new Error(this.reportLexerError(e));\n                err.offset = this.current;\n                err.token = e.token;\n                throw err;\n            }\n            // We add new states to table[current+1]\n            var column = this.table[this.current];\n\n            // GC unused states\n            if (!this.options.keepHistory) {\n                delete this.table[this.current - 1];\n            }\n\n            var n = this.current + 1;\n            var nextColumn = new Column(this.grammar, n);\n            this.table.push(nextColumn);\n\n            // Advance all tokens that expect the symbol\n            var literal = token.text !== undefined ? token.text : token.value;\n            var value = lexer.constructor === StreamLexer ? token.value : token;\n            var scannable = column.scannable;\n            for (var w = scannable.length; w--; ) {\n                var state = scannable[w];\n                var expect = state.rule.symbols[state.dot];\n                // Try to consume the token\n                // either regex or literal\n                if (expect.test ? expect.test(value) :\n                    expect.type ? expect.type === token.type\n                                : expect.literal === literal) {\n                    // Add it\n                    var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                    nextColumn.states.push(next);\n                }\n            }\n\n            // Next, for each of the rules, we either\n            // (a) complete it, and try to see if the reference row expected that\n            //     rule\n            // (b) predict the next nonterminal it expects by adding that\n            //     nonterminal's start state\n            // To prevent duplication, we also keep track of rules we have already\n            // added\n\n            nextColumn.process();\n\n            // If needed, throw an error:\n            if (nextColumn.states.length === 0) {\n                // No states at all! This is not good.\n                var err = new Error(this.reportError(token));\n                err.offset = this.current;\n                err.token = token;\n                throw err;\n            }\n\n            // maybe save lexer state\n            if (this.options.keepHistory) {\n              column.lexerState = lexer.save()\n            }\n\n            this.current++;\n        }\n        if (column) {\n          this.lexerState = lexer.save()\n        }\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n\n        // Allow chaining, for whatever it's worth\n        return this;\n    };\n\n    Parser.prototype.reportLexerError = function(lexerError) {\n        var tokenDisplay, lexerMessage;\n        // Planning to add a token property to moo's thrown error\n        // even on erroring tokens to be used in error display below\n        var token = lexerError.token;\n        if (token) {\n            tokenDisplay = \"input \" + JSON.stringify(token.text[0]) + \" (lexer error)\";\n            lexerMessage = this.lexer.formatError(token, \"Syntax error\");\n        } else {\n            tokenDisplay = \"input (lexer error)\";\n            lexerMessage = lexerError.message;\n        }\n        return this.reportErrorCommon(lexerMessage, tokenDisplay);\n    };\n\n    Parser.prototype.reportError = function(token) {\n        var tokenDisplay = (token.type ? token.type + \" token: \" : \"\") + JSON.stringify(token.value !== undefined ? token.value : token);\n        var lexerMessage = this.lexer.formatError(token, \"Syntax error\");\n        return this.reportErrorCommon(lexerMessage, tokenDisplay);\n    };\n\n    Parser.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {\n        var lines = [];\n        lines.push(lexerMessage);\n        var lastColumnIndex = this.table.length - 2;\n        var lastColumn = this.table[lastColumnIndex];\n        var expectantStates = lastColumn.states\n            .filter(function(state) {\n                var nextSymbol = state.rule.symbols[state.dot];\n                return nextSymbol && typeof nextSymbol !== \"string\";\n            });\n\n        if (expectantStates.length === 0) {\n            lines.push('Unexpected ' + tokenDisplay + '. I did not expect any more input. Here is the state of my parse table:\\n');\n            this.displayStateStack(lastColumn.states, lines);\n        } else {\n            lines.push('Unexpected ' + tokenDisplay + '. Instead, I was expecting to see one of the following:\\n');\n            // Display a \"state stack\" for each expectant state\n            // - which shows you how this state came to be, step by step.\n            // If there is more than one derivation, we only display the first one.\n            var stateStacks = expectantStates\n                .map(function(state) {\n                    return this.buildFirstStateStack(state, []) || [state];\n                }, this);\n            // Display each state that is expecting a terminal symbol next.\n            stateStacks.forEach(function(stateStack) {\n                var state = stateStack[0];\n                var nextSymbol = state.rule.symbols[state.dot];\n                var symbolDisplay = this.getSymbolDisplay(nextSymbol);\n                lines.push('A ' + symbolDisplay + ' based on:');\n                this.displayStateStack(stateStack, lines);\n            }, this);\n        }\n        lines.push(\"\");\n        return lines.join(\"\\n\");\n    }\n    \n    Parser.prototype.displayStateStack = function(stateStack, lines) {\n        var lastDisplay;\n        var sameDisplayCount = 0;\n        for (var j = 0; j < stateStack.length; j++) {\n            var state = stateStack[j];\n            var display = state.rule.toString(state.dot);\n            if (display === lastDisplay) {\n                sameDisplayCount++;\n            } else {\n                if (sameDisplayCount > 0) {\n                    lines.push('    ^ ' + sameDisplayCount + ' more lines identical to this');\n                }\n                sameDisplayCount = 0;\n                lines.push('    ' + display);\n            }\n            lastDisplay = display;\n        }\n    };\n\n    Parser.prototype.getSymbolDisplay = function(symbol) {\n        return getSymbolLongDisplay(symbol);\n    };\n\n    /*\n    Builds a the first state stack. You can think of a state stack as the call stack\n    of the recursive-descent parser which the Nearley parse algorithm simulates.\n    A state stack is represented as an array of state objects. Within a\n    state stack, the first item of the array will be the starting\n    state, with each successive item in the array going further back into history.\n\n    This function needs to be given a starting state and an empty array representing\n    the visited states, and it returns an single state stack.\n\n    */\n    Parser.prototype.buildFirstStateStack = function(state, visited) {\n        if (visited.indexOf(state) !== -1) {\n            // Found cycle, return null\n            // to eliminate this path from the results, because\n            // we don't know how to display it meaningfully\n            return null;\n        }\n        if (state.wantedBy.length === 0) {\n            return [state];\n        }\n        var prevState = state.wantedBy[0];\n        var childVisited = [state].concat(visited);\n        var childResult = this.buildFirstStateStack(prevState, childVisited);\n        if (childResult === null) {\n            return null;\n        }\n        return [state].concat(childResult);\n    };\n\n    Parser.prototype.save = function() {\n        var column = this.table[this.current];\n        column.lexerState = this.lexerState;\n        return column;\n    };\n\n    Parser.prototype.restore = function(column) {\n        var index = column.index;\n        this.current = index;\n        this.table[index] = column;\n        this.table.splice(index + 1);\n        this.lexerState = column.lexerState;\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n    };\n\n    // nb. deprecated: use save/restore instead!\n    Parser.prototype.rewind = function(index) {\n        if (!this.options.keepHistory) {\n            throw new Error('set option `keepHistory` to enable rewinding')\n        }\n        // nb. recall column (table) indicies fall between token indicies.\n        //        col 0   --   token 0   --   col 1\n        this.restore(this.table[index]);\n    };\n\n    Parser.prototype.finish = function() {\n        // Return the possible parsings\n        var considerations = [];\n        var start = this.grammar.start;\n        var column = this.table[this.table.length - 1]\n        column.states.forEach(function (t) {\n            if (t.rule.name === start\n                    && t.dot === t.rule.symbols.length\n                    && t.reference === 0\n                    && t.data !== Parser.fail) {\n                considerations.push(t);\n            }\n        });\n        return considerations.map(function(c) {return c.data; });\n    };\n\n    function getSymbolLongDisplay(symbol) {\n        var type = typeof symbol;\n        if (type === \"string\") {\n            return symbol;\n        } else if (type === \"object\") {\n            if (symbol.literal) {\n                return JSON.stringify(symbol.literal);\n            } else if (symbol instanceof RegExp) {\n                return 'character matching ' + symbol;\n            } else if (symbol.type) {\n                return symbol.type + ' token';\n            } else if (symbol.test) {\n                return 'token matching ' + String(symbol.test);\n            } else {\n                throw new Error('Unknown symbol type: ' + symbol);\n            }\n        }\n    }\n\n    function getSymbolShortDisplay(symbol) {\n        var type = typeof symbol;\n        if (type === \"string\") {\n            return symbol;\n        } else if (type === \"object\") {\n            if (symbol.literal) {\n                return JSON.stringify(symbol.literal);\n            } else if (symbol instanceof RegExp) {\n                return symbol.toString();\n            } else if (symbol.type) {\n                return '%' + symbol.type;\n            } else if (symbol.test) {\n                return '<' + String(symbol.test) + '>';\n            } else {\n                throw new Error('Unknown symbol type: ' + symbol);\n            }\n        }\n    }\n\n    return {\n        Parser: Parser,\n        Grammar: Grammar,\n        Rule: Rule,\n    };\n\n}));\n","(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory) /* global define */\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = factory()\n  } else {\n    root.moo = factory()\n  }\n}(this, function() {\n  'use strict';\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty\n  var toString = Object.prototype.toString\n  var hasSticky = typeof new RegExp().sticky === 'boolean'\n\n  /***************************************************************************/\n\n  function isRegExp(o) { return o && toString.call(o) === '[object RegExp]' }\n  function isObject(o) { return o && typeof o === 'object' && !isRegExp(o) && !Array.isArray(o) }\n\n  function reEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n  }\n  function reGroups(s) {\n    var re = new RegExp('|' + s)\n    return re.exec('').length - 1\n  }\n  function reCapture(s) {\n    return '(' + s + ')'\n  }\n  function reUnion(regexps) {\n    if (!regexps.length) return '(?!)'\n    var source =  regexps.map(function(s) {\n      return \"(?:\" + s + \")\"\n    }).join('|')\n    return \"(?:\" + source + \")\"\n  }\n\n  function regexpOrLiteral(obj) {\n    if (typeof obj === 'string') {\n      return '(?:' + reEscape(obj) + ')'\n\n    } else if (isRegExp(obj)) {\n      // TODO: consider /u support\n      if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed')\n      if (obj.global) throw new Error('RegExp /g flag is implied')\n      if (obj.sticky) throw new Error('RegExp /y flag is implied')\n      if (obj.multiline) throw new Error('RegExp /m flag is implied')\n      return obj.source\n\n    } else {\n      throw new Error('Not a pattern: ' + obj)\n    }\n  }\n\n  function pad(s, length) {\n    if (s.length > length) {\n      return s\n    }\n    return Array(length - s.length + 1).join(\" \") + s\n  }\n\n  function lastNLines(string, numLines) {\n    var position = string.length\n    var lineBreaks = 0;\n    while (true) {\n      var idx = string.lastIndexOf(\"\\n\", position - 1)\n      if (idx === -1) {\n        break;\n      } else {\n        lineBreaks++\n      }\n      position = idx\n      if (lineBreaks === numLines) {\n        break;\n      }\n      if (position === 0) {\n        break;\n      }\n    }\n    var startPosition = \n      lineBreaks < numLines ?\n      0 : \n      position + 1\n    return string.substring(startPosition).split(\"\\n\")\n  }\n\n  function objectToRules(object) {\n    var keys = Object.getOwnPropertyNames(object)\n    var result = []\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var thing = object[key]\n      var rules = [].concat(thing)\n      if (key === 'include') {\n        for (var j = 0; j < rules.length; j++) {\n          result.push({include: rules[j]})\n        }\n        continue\n      }\n      var match = []\n      rules.forEach(function(rule) {\n        if (isObject(rule)) {\n          if (match.length) result.push(ruleOptions(key, match))\n          result.push(ruleOptions(key, rule))\n          match = []\n        } else {\n          match.push(rule)\n        }\n      })\n      if (match.length) result.push(ruleOptions(key, match))\n    }\n    return result\n  }\n\n  function arrayToRules(array) {\n    var result = []\n    for (var i = 0; i < array.length; i++) {\n      var obj = array[i]\n      if (obj.include) {\n        var include = [].concat(obj.include)\n        for (var j = 0; j < include.length; j++) {\n          result.push({include: include[j]})\n        }\n        continue\n      }\n      if (!obj.type) {\n        throw new Error('Rule has no type: ' + JSON.stringify(obj))\n      }\n      result.push(ruleOptions(obj.type, obj))\n    }\n    return result\n  }\n\n  function ruleOptions(type, obj) {\n    if (!isObject(obj)) {\n      obj = { match: obj }\n    }\n    if (obj.include) {\n      throw new Error('Matching rules cannot also include states')\n    }\n\n    // nb. error and fallback imply lineBreaks\n    var options = {\n      defaultType: type,\n      lineBreaks: !!obj.error || !!obj.fallback,\n      pop: false,\n      next: null,\n      push: null,\n      error: false,\n      fallback: false,\n      value: null,\n      type: null,\n      shouldThrow: false,\n    }\n\n    // Avoid Object.assign(), so we support IE9+\n    for (var key in obj) {\n      if (hasOwnProperty.call(obj, key)) {\n        options[key] = obj[key]\n      }\n    }\n\n    // type transform cannot be a string\n    if (typeof options.type === 'string' && type !== options.type) {\n      throw new Error(\"Type transform cannot be a string (type '\" + options.type + \"' for token '\" + type + \"')\")\n    }\n\n    // convert to array\n    var match = options.match\n    options.match = Array.isArray(match) ? match : match ? [match] : []\n    options.match.sort(function(a, b) {\n      return isRegExp(a) && isRegExp(b) ? 0\n           : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length\n    })\n    return options\n  }\n\n  function toRules(spec) {\n    return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec)\n  }\n\n  var defaultErrorRule = ruleOptions('error', {lineBreaks: true, shouldThrow: true})\n  function compileRules(rules, hasStates) {\n    var errorRule = null\n    var fast = Object.create(null)\n    var fastAllowed = true\n    var unicodeFlag = null\n    var groups = []\n    var parts = []\n\n    // If there is a fallback rule, then disable fast matching\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].fallback) {\n        fastAllowed = false\n      }\n    }\n\n    for (var i = 0; i < rules.length; i++) {\n      var options = rules[i]\n\n      if (options.include) {\n        // all valid inclusions are removed by states() preprocessor\n        throw new Error('Inheritance is not allowed in stateless lexers')\n      }\n\n      if (options.error || options.fallback) {\n        // errorRule can only be set once\n        if (errorRule) {\n          if (!options.fallback === !errorRule.fallback) {\n            throw new Error(\"Multiple \" + (options.fallback ? \"fallback\" : \"error\") + \" rules not allowed (for token '\" + options.defaultType + \"')\")\n          } else {\n            throw new Error(\"fallback and error are mutually exclusive (for token '\" + options.defaultType + \"')\")\n          }\n        }\n        errorRule = options\n      }\n\n      var match = options.match.slice()\n      if (fastAllowed) {\n        while (match.length && typeof match[0] === 'string' && match[0].length === 1) {\n          var word = match.shift()\n          fast[word.charCodeAt(0)] = options\n        }\n      }\n\n      // Warn about inappropriate state-switching options\n      if (options.pop || options.push || options.next) {\n        if (!hasStates) {\n          throw new Error(\"State-switching options are not allowed in stateless lexers (for token '\" + options.defaultType + \"')\")\n        }\n        if (options.fallback) {\n          throw new Error(\"State-switching options are not allowed on fallback tokens (for token '\" + options.defaultType + \"')\")\n        }\n      }\n\n      // Only rules with a .match are included in the RegExp\n      if (match.length === 0) {\n        continue\n      }\n      fastAllowed = false\n\n      groups.push(options)\n\n      // Check unicode flag is used everywhere or nowhere\n      for (var j = 0; j < match.length; j++) {\n        var obj = match[j]\n        if (!isRegExp(obj)) {\n          continue\n        }\n\n        if (unicodeFlag === null) {\n          unicodeFlag = obj.unicode\n        } else if (unicodeFlag !== obj.unicode && options.fallback === false) {\n          throw new Error('If one rule is /u then all must be')\n        }\n      }\n\n      // convert to RegExp\n      var pat = reUnion(match.map(regexpOrLiteral))\n\n      // validate\n      var regexp = new RegExp(pat)\n      if (regexp.test(\"\")) {\n        throw new Error(\"RegExp matches empty string: \" + regexp)\n      }\n      var groupCount = reGroups(pat)\n      if (groupCount > 0) {\n        throw new Error(\"RegExp has capture groups: \" + regexp + \"\\nUse (?: … ) instead\")\n      }\n\n      // try and detect rules matching newlines\n      if (!options.lineBreaks && regexp.test('\\n')) {\n        throw new Error('Rule should declare lineBreaks: ' + regexp)\n      }\n\n      // store regex\n      parts.push(reCapture(pat))\n    }\n\n\n    // If there's no fallback rule, use the sticky flag so we only look for\n    // matches at the current index.\n    //\n    // If we don't support the sticky flag, then fake it using an irrefutable\n    // match (i.e. an empty pattern).\n    var fallbackRule = errorRule && errorRule.fallback\n    var flags = hasSticky && !fallbackRule ? 'ym' : 'gm'\n    var suffix = hasSticky || fallbackRule ? '' : '|'\n\n    if (unicodeFlag === true) flags += \"u\"\n    var combined = new RegExp(reUnion(parts) + suffix, flags)\n    return {regexp: combined, groups: groups, fast: fast, error: errorRule || defaultErrorRule}\n  }\n\n  function compile(rules) {\n    var result = compileRules(toRules(rules))\n    return new Lexer({start: result}, 'start')\n  }\n\n  function checkStateGroup(g, name, map) {\n    var state = g && (g.push || g.next)\n    if (state && !map[state]) {\n      throw new Error(\"Missing state '\" + state + \"' (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n    if (g && g.pop && +g.pop !== 1) {\n      throw new Error(\"pop must be 1 (in token '\" + g.defaultType + \"' of state '\" + name + \"')\")\n    }\n  }\n  function compileStates(states, start) {\n    var all = states.$all ? toRules(states.$all) : []\n    delete states.$all\n\n    var keys = Object.getOwnPropertyNames(states)\n    if (!start) start = keys[0]\n\n    var ruleMap = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      ruleMap[key] = toRules(states[key]).concat(all)\n    }\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      var rules = ruleMap[key]\n      var included = Object.create(null)\n      for (var j = 0; j < rules.length; j++) {\n        var rule = rules[j]\n        if (!rule.include) continue\n        var splice = [j, 1]\n        if (rule.include !== key && !included[rule.include]) {\n          included[rule.include] = true\n          var newRules = ruleMap[rule.include]\n          if (!newRules) {\n            throw new Error(\"Cannot include nonexistent state '\" + rule.include + \"' (in state '\" + key + \"')\")\n          }\n          for (var k = 0; k < newRules.length; k++) {\n            var newRule = newRules[k]\n            if (rules.indexOf(newRule) !== -1) continue\n            splice.push(newRule)\n          }\n        }\n        rules.splice.apply(rules, splice)\n        j--\n      }\n    }\n\n    var map = Object.create(null)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      map[key] = compileRules(ruleMap[key], true)\n    }\n\n    for (var i = 0; i < keys.length; i++) {\n      var name = keys[i]\n      var state = map[name]\n      var groups = state.groups\n      for (var j = 0; j < groups.length; j++) {\n        checkStateGroup(groups[j], name, map)\n      }\n      var fastKeys = Object.getOwnPropertyNames(state.fast)\n      for (var j = 0; j < fastKeys.length; j++) {\n        checkStateGroup(state.fast[fastKeys[j]], name, map)\n      }\n    }\n\n    return new Lexer(map, start)\n  }\n\n  function keywordTransform(map) {\n\n    // Use a JavaScript Map to map keywords to their corresponding token type\n    // unless Map is unsupported, then fall back to using an Object:\n    var isMap = typeof Map !== 'undefined'\n    var reverseMap = isMap ? new Map : Object.create(null)\n\n    var types = Object.getOwnPropertyNames(map)\n    for (var i = 0; i < types.length; i++) {\n      var tokenType = types[i]\n      var item = map[tokenType]\n      var keywordList = Array.isArray(item) ? item : [item]\n      keywordList.forEach(function(keyword) {\n        if (typeof keyword !== 'string') {\n          throw new Error(\"keyword must be string (in keyword '\" + tokenType + \"')\")\n        }\n        if (isMap) {\n          reverseMap.set(keyword, tokenType)\n        } else {\n          reverseMap[keyword] = tokenType\n        }\n      })\n    }\n    return function(k) {\n      return isMap ? reverseMap.get(k) : reverseMap[k]\n    }\n  }\n\n  /***************************************************************************/\n\n  var Lexer = function(states, state) {\n    this.startState = state\n    this.states = states\n    this.buffer = ''\n    this.stack = []\n    this.reset()\n  }\n\n  Lexer.prototype.reset = function(data, info) {\n    this.buffer = data || ''\n    this.index = 0\n    this.line = info ? info.line : 1\n    this.col = info ? info.col : 1\n    this.queuedToken = info ? info.queuedToken : null\n    this.queuedText = info ? info.queuedText: \"\";\n    this.queuedThrow = info ? info.queuedThrow : null\n    this.setState(info ? info.state : this.startState)\n    this.stack = info && info.stack ? info.stack.slice() : []\n    return this\n  }\n\n  Lexer.prototype.save = function() {\n    return {\n      line: this.line,\n      col: this.col,\n      state: this.state,\n      stack: this.stack.slice(),\n      queuedToken: this.queuedToken,\n      queuedText: this.queuedText,\n      queuedThrow: this.queuedThrow,\n    }\n  }\n\n  Lexer.prototype.setState = function(state) {\n    if (!state || this.state === state) return\n    this.state = state\n    var info = this.states[state]\n    this.groups = info.groups\n    this.error = info.error\n    this.re = info.regexp\n    this.fast = info.fast\n  }\n\n  Lexer.prototype.popState = function() {\n    this.setState(this.stack.pop())\n  }\n\n  Lexer.prototype.pushState = function(state) {\n    this.stack.push(this.state)\n    this.setState(state)\n  }\n\n  var eat = hasSticky ? function(re, buffer) { // assume re is /y\n    return re.exec(buffer)\n  } : function(re, buffer) { // assume re is /g\n    var match = re.exec(buffer)\n    // will always match, since we used the |(?:) trick\n    if (match[0].length === 0) {\n      return null\n    }\n    return match\n  }\n\n  Lexer.prototype._getGroup = function(match) {\n    var groupCount = this.groups.length\n    for (var i = 0; i < groupCount; i++) {\n      if (match[i + 1] !== undefined) {\n        return this.groups[i]\n      }\n    }\n    throw new Error('Cannot find token type for matched text')\n  }\n\n  function tokenToString() {\n    return this.value\n  }\n\n  Lexer.prototype.next = function() {\n    var index = this.index\n\n    // If a fallback token matched, we don't need to re-run the RegExp\n    if (this.queuedGroup) {\n      var token = this._token(this.queuedGroup, this.queuedText, index)\n      this.queuedGroup = null\n      this.queuedText = \"\"\n      return token\n    }\n\n    var buffer = this.buffer\n    if (index === buffer.length) {\n      return // EOF\n    }\n\n    // Fast matching for single characters\n    var group = this.fast[buffer.charCodeAt(index)]\n    if (group) {\n      return this._token(group, buffer.charAt(index), index)\n    }\n\n    // Execute RegExp\n    var re = this.re\n    re.lastIndex = index\n    var match = eat(re, buffer)\n\n    // Error tokens match the remaining buffer\n    var error = this.error\n    if (match == null) {\n      return this._token(error, buffer.slice(index, buffer.length), index)\n    }\n\n    var group = this._getGroup(match)\n    var text = match[0]\n\n    if (error.fallback && match.index !== index) {\n      this.queuedGroup = group\n      this.queuedText = text\n\n      // Fallback tokens contain the unmatched portion of the buffer\n      return this._token(error, buffer.slice(index, match.index), index)\n    }\n\n    return this._token(group, text, index)\n  }\n\n  Lexer.prototype._token = function(group, text, offset) {\n    // count line breaks\n    var lineBreaks = 0\n    if (group.lineBreaks) {\n      var matchNL = /\\n/g\n      var nl = 1\n      if (text === '\\n') {\n        lineBreaks = 1\n      } else {\n        while (matchNL.exec(text)) { lineBreaks++; nl = matchNL.lastIndex }\n      }\n    }\n\n    var token = {\n      type: (typeof group.type === 'function' && group.type(text)) || group.defaultType,\n      value: typeof group.value === 'function' ? group.value(text) : text,\n      text: text,\n      toString: tokenToString,\n      offset: offset,\n      lineBreaks: lineBreaks,\n      line: this.line,\n      col: this.col,\n    }\n    // nb. adding more props to token object will make V8 sad!\n\n    var size = text.length\n    this.index += size\n    this.line += lineBreaks\n    if (lineBreaks !== 0) {\n      this.col = size - nl + 1\n    } else {\n      this.col += size\n    }\n\n    // throw, if no rule with {error: true}\n    if (group.shouldThrow) {\n      var err = new Error(this.formatError(token, \"invalid syntax\"))\n      throw err;\n    }\n\n    if (group.pop) this.popState()\n    else if (group.push) this.pushState(group.push)\n    else if (group.next) this.setState(group.next)\n\n    return token\n  }\n\n  if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n    var LexerIterator = function(lexer) {\n      this.lexer = lexer\n    }\n\n    LexerIterator.prototype.next = function() {\n      var token = this.lexer.next()\n      return {value: token, done: !token}\n    }\n\n    LexerIterator.prototype[Symbol.iterator] = function() {\n      return this\n    }\n\n    Lexer.prototype[Symbol.iterator] = function() {\n      return new LexerIterator(this)\n    }\n  }\n\n  Lexer.prototype.formatError = function(token, message) {\n    if (token == null) {\n      // An undefined token indicates EOF\n      var text = this.buffer.slice(this.index)\n      var token = {\n        text: text,\n        offset: this.index,\n        lineBreaks: text.indexOf('\\n') === -1 ? 0 : 1,\n        line: this.line,\n        col: this.col,\n      }\n    }\n    \n    var numLinesAround = 2\n    var firstDisplayedLine = Math.max(token.line - numLinesAround, 1)\n    var lastDisplayedLine = token.line + numLinesAround\n    var lastLineDigits = String(lastDisplayedLine).length\n    var displayedLines = lastNLines(\n        this.buffer, \n        (this.line - token.line) + numLinesAround + 1\n      )\n      .slice(0, 5)\n    var errorLines = []\n    errorLines.push(message + \" at line \" + token.line + \" col \" + token.col + \":\")\n    errorLines.push(\"\")\n    for (var i = 0; i < displayedLines.length; i++) {\n      var line = displayedLines[i]\n      var lineNo = firstDisplayedLine + i\n      errorLines.push(pad(String(lineNo), lastLineDigits) + \"  \" + line);\n      if (lineNo === token.line) {\n        errorLines.push(pad(\"\", lastLineDigits + token.col + 1) + \"^\")\n      }\n    }\n    return errorLines.join(\"\\n\")\n  }\n\n  Lexer.prototype.clone = function() {\n    return new Lexer(this.states, this.state)\n  }\n\n  Lexer.prototype.has = function(tokenType) {\n    return true\n  }\n\n\n  return {\n    compile: compile,\n    states: compileStates,\n    error: Object.freeze({error: true}),\n    fallback: Object.freeze({fallback: true}),\n    keywords: keywordTransform,\n  }\n\n}));\n","import { makeASTVisitor } from './AST/index'\nimport { type ASTNode, type EvaluatedNode, type NodeKind } from './AST/types'\nimport { PublicodesError, experimentalRuleWarning } from './error'\nimport { evaluationFunctions } from './evaluationFunctions'\nimport parsePublicodes, {\n\tContext,\n\tRawPublicodes,\n\tcopyContext,\n\tcreateContext,\n} from './parsePublicodes'\nimport { type Rule, type RuleNode } from './rule'\nimport * as utils from './ruleUtils'\nimport {\n\tcomputeTraversedVariableAfterEval,\n\tcomputeTraversedVariableBeforeEval,\n\tisTraversedVariablesBoundary,\n} from './traversedVariables'\n\nconst emptyCache = (): Cache => ({\n\t_meta: {\n\t\tevaluationRuleStack: [],\n\t\tparentRuleStack: [],\n\t},\n\ttraversedVariablesStack: undefined,\n\tnodes: new Map(),\n})\n\ntype Cache = {\n\tinversionFail?: boolean\n\t_meta: {\n\t\tevaluationRuleStack: Array<string>\n\t\tparentRuleStack: Array<string>\n\t\tcurrentContexteSituation?: string\n\t}\n\t/**\n\t * Every time we encounter a reference to a rule in an expression we add it\n\t * to the current Set of traversed variables. Because we evaluate the\n\t * expression graph “top to bottom” (ie. we start by the high-level goal and\n\t * recursively evaluate its dependencies), we need to handle rule\n\t * “boundaries”, so that when we “enter” in the evaluation of a dependency,\n\t * we start with a clear empty set of traversed variables. Then, when we go\n\t * back to the referencer rule, we need to add all to merge the two sets :\n\t * rules already traversed in the current expression and the one from the\n\t * reference.\n\t */\n\ttraversedVariablesStack?: Array<Set<string>>\n\tnodes: Map<PublicodesExpression | ASTNode, EvaluatedNode>\n}\n\nexport {\n\treduceAST,\n\tmakeASTTransformer as transformAST,\n\ttraverseASTNode,\n} from './AST/index'\nexport { type Evaluation, type Unit } from './AST/types'\nexport { PublicodesError, isPublicodesError } from './error'\nexport { capitalise0, formatValue } from './format'\nexport { simplifyNodeUnit } from './nodeUnits'\nexport { parseExpression, type ExprAST } from './parseExpression'\nexport { default as serializeEvaluation } from './serializeEvaluation'\nexport { parseUnit, serializeUnit } from './units'\nexport { parsePublicodes, utils }\n\nexport { type ASTNode, type EvaluatedNode, type Rule, type RuleNode }\n\nexport type PublicodesExpression = string | Record<string, unknown> | number\n\nexport type Logger = {\n\tlog(message: string): void\n\twarn(message: string): void\n\terror(message: string): void\n}\n\ntype Options = Partial<\n\tPick<Context, 'logger' | 'getUnitKey' | 'allowOrphanRules'>\n>\n\nexport type EvaluationFunction<Kind extends NodeKind = NodeKind> = (\n\tthis: Engine,\n\tnode: ASTNode & { nodeKind: Kind },\n) => { nodeKind: Kind } & EvaluatedNode\n\nexport type ParsedRules<Name extends string> = Record<Name, RuleNode<Name>>\n\nexport default class Engine<Name extends string = string> {\n\tbaseContext: Context<Name>\n\tcontext: Context<string>\n\tpublicParsedRules: ParsedRules<Name>\n\n\tcache: Cache = emptyCache()\n\n\t// The subEngines attribute is used to get an outside reference to the\n\t// `contexte` intermediate calculations. The `contexte` mechanism uses\n\t// `shallowCopy` to instanciate a new engine, and we want to keep a reference\n\t// to it for the documentation.\n\t//\n\t// TODO: A better implementation would to remove the \"runtime\" concept of\n\t// \"subEngines\" and instead duplicate all rules names in the scope of the\n\t// `contexte` as described in\n\t// https://github.com/publicodes/publicodes/discussions/92\n\tsubEngines: Array<Engine<Name>> = []\n\tsubEngineId: number | undefined\n\n\tconstructor(rules: RawPublicodes<Name> = {}, options: Options = {}) {\n\t\tconst initialContext = {\n\t\t\tdottedName: '' as const,\n\t\t\t...options,\n\t\t}\n\t\tthis.baseContext = createContext({\n\t\t\t...initialContext,\n\t\t\t...parsePublicodes<never, Name>(rules, initialContext),\n\t\t})\n\t\tthis.context = this.baseContext\n\n\t\tthis.publicParsedRules = {} as ParsedRules<Name>\n\t\tfor (const name in this.baseContext.parsedRules) {\n\t\t\tconst rule = this.baseContext.parsedRules[name]\n\t\t\tif (\n\t\t\t\t!(rule as RuleNode).private &&\n\t\t\t\tutils.isAccessible(this.baseContext.parsedRules, '', name)\n\t\t\t) {\n\t\t\t\tthis.publicParsedRules[name] = rule as RuleNode<Name>\n\t\t\t}\n\t\t}\n\t}\n\n\tresetCache() {\n\t\tthis.cache = emptyCache()\n\t}\n\n\tsetSituation(\n\t\tsituation: Partial<Record<Name, PublicodesExpression | ASTNode>> = {},\n\t\toptions: { keepPreviousSituation?: boolean } = {},\n\t) {\n\t\tthis.resetCache()\n\n\t\tconst keepPreviousSituation = options.keepPreviousSituation ?? false\n\n\t\tObject.keys(situation).forEach((name) => {\n\t\t\tif (!(name in this.baseContext.parsedRules)) {\n\t\t\t\tthrow new PublicodesError(\n\t\t\t\t\t'EvaluationError',\n\t\t\t\t\t`Erreur lors de la mise à jour de la situation : ${name} n'existe pas dans la base de règle.`,\n\t\t\t\t\t{ dottedName: name },\n\t\t\t\t)\n\t\t\t}\n\t\t\tif (this.baseContext.parsedRules[name].private) {\n\t\t\t\tthrow new PublicodesError(\n\t\t\t\t\t'EvaluationError',\n\t\t\t\t\t`Erreur lors de la mise à jour de la situation : ${name} est une règle privée (il n'est pas possible de modifier une règle privée).`,\n\t\t\t\t\t{ dottedName: name },\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\n\t\t// The situation is implemented as a special sub namespace `$SITUATION`,\n\t\t// present on each non-private rules\n\t\tconst situationToParse = Object.fromEntries(\n\t\t\tObject.entries(situation).map(([nom, value]) => [\n\t\t\t\t`[privé] ${nom} . $SITUATION`,\n\t\t\t\tvalue && typeof value === 'object' && 'nodeKind' in value ?\n\t\t\t\t\t{ valeur: value }\n\t\t\t\t:\tvalue,\n\t\t\t]),\n\t\t)\n\n\t\tconst savedBaseContext = copyContext(this.baseContext)\n\n\t\ttry {\n\t\t\tthis.context = {\n\t\t\t\t...this.baseContext,\n\t\t\t\t...parsePublicodes(\n\t\t\t\t\tsituationToParse as RawPublicodes<Name>,\n\t\t\t\t\tkeepPreviousSituation ? this.context : this.baseContext,\n\t\t\t\t),\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.baseContext = savedBaseContext\n\n\t\t\tthrow error\n\t\t}\n\t\tthis.baseContext = savedBaseContext\n\n\t\tObject.keys(situation).forEach((nom) => {\n\t\t\tif (utils.isExperimental(this.context.parsedRules, nom)) {\n\t\t\t\texperimentalRuleWarning(this.baseContext.logger, nom)\n\t\t\t}\n\t\t\tthis.checkExperimentalRule(\n\t\t\t\tthis.context.parsedRules[`${nom} . $SITUATION`],\n\t\t\t)\n\t\t})\n\t\treturn this\n\t}\n\n\tinversionFail(): boolean {\n\t\treturn !!this.cache.inversionFail\n\t}\n\n\tgetRule(dottedName: Name): ParsedRules<Name>[Name] {\n\t\tif (!(dottedName in this.baseContext.parsedRules)) {\n\t\t\tthrow new PublicodesError(\n\t\t\t\t'UnknownRule',\n\t\t\t\t`La règle '${dottedName}' n'existe pas`,\n\t\t\t\t{ dottedName },\n\t\t\t)\n\t\t}\n\n\t\tif (!(dottedName in this.publicParsedRules)) {\n\t\t\tthrow new PublicodesError(\n\t\t\t\t'PrivateRule',\n\t\t\t\t`La règle ${dottedName} est une règle privée.`,\n\t\t\t\t{ dottedName },\n\t\t\t)\n\t\t}\n\n\t\treturn this.publicParsedRules[dottedName]\n\t}\n\n\tgetParsedRules(): ParsedRules<Name> {\n\t\treturn this.publicParsedRules\n\t}\n\n\tevaluate(value: PublicodesExpression): EvaluatedNode {\n\t\tconst cachedNode = this.cache.nodes.get(value)\n\t\tif (cachedNode) {\n\t\t\treturn cachedNode\n\t\t}\n\t\tthis.context = Object.assign(\n\t\t\tthis.context,\n\t\t\tparsePublicodes(\n\t\t\t\t{\n\t\t\t\t\t'[privé] $EVALUATION':\n\t\t\t\t\t\tvalue && typeof value === 'object' && 'nodeKind' in value ?\n\t\t\t\t\t\t\t{ valeur: value }\n\t\t\t\t\t\t:\tvalue,\n\t\t\t\t},\n\t\t\t\tthis.context,\n\t\t\t),\n\t\t)\n\t\tthis.checkExperimentalRule(this.context.parsedRules['$EVALUATION'])\n\t\tthis.cache._meta = emptyCache()._meta\n\n\t\tconst evaluation = this.evaluateNode(\n\t\t\tthis.context.parsedRules['$EVALUATION'].explanation.valeur,\n\t\t)\n\t\tthis.cache.nodes.set(value, evaluation)\n\t\treturn evaluation\n\t}\n\n\tevaluateNode<T extends ASTNode>(parsedNode: T): EvaluatedNode & T {\n\t\tconst cachedNode = this.cache.nodes.get(parsedNode)\n\t\tlet traversedVariableBoundary: boolean = false\n\t\tif (this.cache.traversedVariablesStack) {\n\t\t\ttraversedVariableBoundary = isTraversedVariablesBoundary(\n\t\t\t\tthis.cache.traversedVariablesStack,\n\t\t\t\tparsedNode,\n\t\t\t)\n\t\t\tcomputeTraversedVariableBeforeEval(\n\t\t\t\tthis.cache.traversedVariablesStack,\n\t\t\t\tparsedNode,\n\t\t\t\tcachedNode,\n\t\t\t\tthis.publicParsedRules,\n\t\t\t\ttraversedVariableBoundary,\n\t\t\t)\n\t\t}\n\n\t\tif (cachedNode !== undefined) {\n\t\t\treturn cachedNode\n\t\t}\n\n\t\tif (!evaluationFunctions[parsedNode.nodeKind]) {\n\t\t\tthrow new PublicodesError(\n\t\t\t\t'EvaluationError',\n\t\t\t\t`Unknown \"nodeKind\": ${parsedNode.nodeKind}`,\n\t\t\t\t{ dottedName: '' },\n\t\t\t)\n\t\t}\n\n\t\tconst evaluatedNode = evaluationFunctions[parsedNode.nodeKind].call(\n\t\t\tthis,\n\t\t\tparsedNode,\n\t\t)\n\t\tif (this.cache.traversedVariablesStack) {\n\t\t\tcomputeTraversedVariableAfterEval(\n\t\t\t\tthis.cache.traversedVariablesStack,\n\t\t\t\tevaluatedNode,\n\t\t\t\ttraversedVariableBoundary,\n\t\t\t)\n\t\t}\n\n\t\tthis.cache.nodes.set(parsedNode, evaluatedNode)\n\t\treturn evaluatedNode\n\t}\n\n\t/**\n\t * Shallow Engine instance copy. Keeps references to the original Engine instance attributes.\n\t */\n\tshallowCopy(): Engine<Name> {\n\t\tconst newEngine = new Engine<Name>()\n\t\tnewEngine.baseContext = copyContext(this.baseContext)\n\t\tnewEngine.context = copyContext(this.context)\n\t\tnewEngine.publicParsedRules = this.publicParsedRules\n\t\tnewEngine.cache = {\n\t\t\t...emptyCache(),\n\n\t\t\tnodes: new Map(this.cache.nodes),\n\t\t}\n\t\treturn newEngine\n\t}\n\n\tprivate checkExperimentalRule = makeASTVisitor((node) => {\n\t\tif (\n\t\t\tnode.nodeKind === 'reference' &&\n\t\t\tutils.isExperimental(this.context.parsedRules, node.dottedName as string)\n\t\t) {\n\t\t\texperimentalRuleWarning(\n\t\t\t\tthis.baseContext.logger,\n\t\t\t\tnode.dottedName as string,\n\t\t\t)\n\t\t}\n\t\treturn 'continue'\n\t})\n}\n","import { Logger } from '.'\n\n/**\n * Each error name with corresponding type in info value\n */\ninterface PublicodesErrorTypes {\n\tInternalError: {\n\t\tdottedName?: string\n\t}\n\tEngineError: Record<string, never>\n\tSyntaxError: {\n\t\tdottedName: string\n\t}\n\tEvaluationError: {\n\t\tdottedName: string\n\t}\n\tUnknownRule: {\n\t\tdottedName: string\n\t}\n\tPrivateRule: {\n\t\tdottedName: string\n\t}\n}\n\n/**\n * Return true if `error` is a PublicodesError,\n * use `name` parameter to check and narow error type\n * @example\n * try {\n * \tnew Engine().evaluate()\n * } catch (error) {\n * \tif (isPublicodesError(error, 'EngineError')) {\n * \t\tconsole.log(error.info)\n * \t}\n * }\n */\nexport const isPublicodesError = <Name extends keyof PublicodesErrorTypes>(\n\terror: unknown,\n\tname?: Name,\n): error is PublicodesError<\n\ttypeof name extends undefined ? keyof PublicodesErrorTypes : Name\n> =>\n\terror instanceof PublicodesError &&\n\t(name === undefined ? true : error.name === name)\n\n/**\n * Generic error for Publicodes\n */\nexport class PublicodesError<\n\tName extends keyof PublicodesErrorTypes,\n> extends Error {\n\tname: Name\n\tinfo: PublicodesErrorTypes[Name]\n\n\tconstructor(\n\t\tname: Name,\n\t\tmessage: string,\n\t\tinfo: PublicodesErrorTypes[Name],\n\t\toriginalError?: Error,\n\t) {\n\t\tsuper(buildMessage(name, message, info, originalError))\n\t\tthis.name = name\n\t\tthis.info = info\n\t}\n}\n\nconst buildMessage = (\n\tname: string,\n\tmessage: string,\n\tinfo?: PublicodesErrorTypes[keyof PublicodesErrorTypes],\n\toriginalError?: Error,\n) => {\n\tconst types: Partial<Record<keyof PublicodesErrorTypes, string>> = {\n\t\tSyntaxError: 'Erreur syntaxique',\n\t\tEvaluationError: \"Erreur d'évaluation\",\n\t\tUnknownRule: 'Règle inconnue',\n\t\tPrivateRule: 'Règle privée',\n\t}\n\tconst isError = /error/i.test(name)\n\n\treturn (\n\t\t`\\n[ ${types[name] ?? name} ]` +\n\t\t(info && 'dottedName' in info && info.dottedName?.length ?\n\t\t\t`\\n➡️  Dans la règle \"${info.dottedName}\"`\n\t\t:\t'') +\n\t\t`\\n${isError ? '✖️' : '⚠️'}  ${message}` +\n\t\t(originalError ?\n\t\t\t'\\n' + (isError ? '    ' : 'ℹ️  ') + originalError.message\n\t\t:\t'')\n\t)\n}\n\n/**\n * @deprecated Throw an internal server error, replace this by `throw new PublicodesError('InternalError', ...)`\n */\nexport class PublicodesInternalError extends PublicodesError<'InternalError'> {\n\tconstructor(payload: Record<string, unknown>) {\n\t\tsuper(\n\t\t\t'InternalError',\n\t\t\t`\nErreur interne du moteur.\n\nCette erreur est le signe d'un bug dans publicodes. Pour nous aider à le résoudre, vous pouvez copier ce texte dans un nouveau ticket : https://github.com/betagouv/mon-entreprise/issues/new.\n\npayload:\n${JSON.stringify(payload, null, 2)}\n`,\n\t\t\tpayload,\n\t\t)\n\t}\n}\n\n/**\n * Use this error in default case of a switch to check exhaustivity statically\n * inspired by https://github.com/ts-essentials/ts-essentials#exhaustive-switch-cases\n */\nexport class UnreachableCaseError extends PublicodesInternalError {\n\tconstructor(value: never) {\n\t\tsuper(value)\n\t}\n}\n\nexport function warning(\n\tlogger: Logger,\n\tmessage: string,\n\tinformation: { dottedName: string },\n\toriginalError?: Error,\n) {\n\tlogger.warn(\n\t\tbuildMessage('Avertissement', message, information, originalError),\n\t)\n}\n\nexport function experimentalRuleWarning(logger: Logger, dottedName: string) {\n\tlogger.warn(\n\t\tbuildMessage(\n\t\t\t'Avertissement',\n\t\t\t\"Cette règle est tagguée comme experimentale. \\n\\nCela veut dire qu'elle peut être modifiée, renommée, ou supprimée sans qu'il n'y ait de changement de version majeure dans l'API.\\n\",\n\t\t\t{ dottedName },\n\t\t),\n\t)\n}\n","export function addToMapSet<T>(map: Map<T, Set<T>>, key: T, value: T) {\n\tif (map.has(key)) {\n\t\tmap.get(key)!.add(value)\n\t\treturn\n\t}\n\tmap.set(key, new Set([value]))\n}\n\nexport function mergeWithArray<\n\tN extends string | number | symbol,\n\tM extends string | number | symbol,\n\tT,\n>(obj1: Record<N, Array<T>>, obj2: Record<M, Array<T>>): Record<N | M, Array<T>>\n\nexport function mergeWithArray<\n\tN extends string | number | symbol,\n\tM extends string | number | symbol,\n\tT,\n>(\n\tobj1: Partial<Record<N, Array<T>>>,\n\tobj2: Partial<Record<M, Array<T>>>,\n): Partial<Record<N | M, Array<T>>>\n\nexport function mergeWithArray<K extends string | number | symbol, T>(\n\tobj1: Partial<Record<K, Array<T>>>,\n\tobj2: Partial<Record<K, Array<T>>>,\n): Partial<Record<K, Array<T>>> {\n\treturn (Object.entries(obj2) as Array<[K, Array<T>]>).reduce(\n\t\t(obj, [key, value]) => ({\n\t\t\t...obj,\n\t\t\t[key]: [...(obj[key] ?? []), ...value],\n\t\t}),\n\t\tobj1,\n\t) as Partial<Record<K, Array<T>>>\n}\n\nexport const weakCopyObj = <T extends Record<string, unknown>>(obj: T): T => {\n\tconst copy = {} as T\n\tfor (const key in obj) {\n\t\tcopy[key] = obj[key]\n\t}\n\n\treturn copy\n}\n","import { ParsedRules } from '..'\nimport { UnreachableCaseError } from '../error'\nimport { TrancheNodes } from '../mecanisms/trancheUtils'\nimport { ReferenceNode } from '../reference'\nimport { ReplacementRule } from '../replacement'\nimport { weakCopyObj } from '../utils'\nimport {\n\tASTNode,\n\tASTTransformer,\n\tASTVisitor,\n\tNodeKind,\n\tTraverseFunction,\n} from './types'\n\n/**\n\tThis function creates a transormation of the AST from on a simpler\n\tcallback function `fn`\n\n\t`fn` will be called with the nodes of the ASTTree during the exploration\n\n\tThe outcome of the callback function has an influence on the exploration of the AST :\n\t- `false`, the node is not updated and the exploration does not continue further down this branch\n\t- `undefined`, the node is not updated but the exploration continues and its children will be transformed\n\t- `ASTNode`, the node is transformed to the new value and the exploration does not continue further down the branch\n\n\t`updateFn` : It is possible to specifically use the updated version of a child\n\tby using the function passed as second argument. The returned value will be the\n\ttransformed version of the node.\n\t*/\nexport function makeASTTransformer(\n\tfn: (node: ASTNode, transform: ASTTransformer) => ASTNode | undefined | false,\n\tstopOnUpdate = true,\n): ASTTransformer {\n\tfunction transform(node: ASTNode): ASTNode {\n\t\tconst updatedNode = fn(node, transform)\n\t\tif (updatedNode === false) {\n\t\t\treturn node\n\t\t}\n\t\tif (updatedNode === undefined) {\n\t\t\treturn traverseASTNode(transform, node)\n\t\t}\n\t\treturn stopOnUpdate ? updatedNode : traverseASTNode(transform, updatedNode)\n\t}\n\treturn transform\n}\nexport function makeASTVisitor(\n\tfn: (node: ASTNode, visit: ASTVisitor) => 'continue' | 'stop',\n): ASTVisitor {\n\tfunction visit(node: ASTNode) {\n\t\tswitch (fn(node, visit)) {\n\t\t\tcase 'continue':\n\t\t\t\ttraverseASTNode(transformizedVisit, node)\n\t\t\t\treturn\n\t\t\tcase 'stop':\n\t\t\t\treturn\n\t\t}\n\t}\n\tconst transformizedVisit: ASTTransformer = (node) => {\n\t\tvisit(node)\n\t\treturn node\n\t}\n\treturn visit\n}\n\n// Can be made more flexible with other args like a filter function (ASTNode -> Bool).\nexport function iterAST(\n\tchildrenSelector: (node: ASTNode) => Iterable<ASTNode>,\n\tnode: ASTNode,\n): ASTNode[] {\n\tfunction* iterate(node: ASTNode): IterableIterator<ASTNode> {\n\t\tyield node\n\t\tconst selectedSubNodes = childrenSelector(node)\n\t\tfor (const subNode of selectedSubNodes) yield* iterate(subNode)\n\t}\n\treturn [...iterate(node)]\n}\n\n/**\n * This function allows to construct a specific value while exploring the AST with\n * a simple reducing function as argument.\n *\n * `fn` will be called with the currently reduced value `acc` and the current node of the AST\n *\n * If the callback function returns:\n * - `undefined`, the exploration continues further down and all the children are reduced\n * \tsuccessively to a single value\n * - `T`, the reduced value is returned\n *\n * `reduceFn` : It is possible to specifically use the reduced value of a child\n * by using the function passed as second argument. The returned value will be the reduced version\n * of the node\n */\nexport function reduceAST<T>(\n\tfn: (acc: T, n: ASTNode, reduceFn: (n: ASTNode) => T) => T | undefined,\n\tstart: T,\n\tnode: ASTNode,\n): T {\n\tfunction traverseFn(acc: T, node: ASTNode): T {\n\t\tconst result = fn(acc, node, traverseFn.bind(null, start))\n\t\tif (result === undefined) {\n\t\t\treturn getChildrenNodes(node).reduce(traverseFn, acc)\n\t\t}\n\t\treturn result\n\t}\n\treturn traverseFn(start, node)\n}\n\nexport function getChildrenNodes(node: ASTNode): ASTNode[] {\n\tconst nodes: ASTNode[] = []\n\ttraverseASTNode((node) => {\n\t\tnodes.push(node)\n\t\treturn node\n\t}, node)\n\treturn nodes\n}\n\nexport function traverseParsedRules<Names extends string>(\n\tfn: ASTTransformer,\n\tparsedRules: ParsedRules<Names>,\n): ParsedRules<Names> {\n\tconst ret = {} as Record<Names, ASTNode>\n\tfor (const name in parsedRules) {\n\t\tret[name] = fn(parsedRules[name])\n\t}\n\n\treturn ret as ParsedRules<Names>\n}\n\n/**\n * Apply a transform function on children. Not recursive.\n */\nexport const traverseASTNode: TraverseFunction<NodeKind> = (fn, node) => {\n\tnode = traverseSourceMap(fn, node)\n\tswitch (node.nodeKind) {\n\t\tcase 'rule':\n\t\t\treturn traverseRuleNode(fn, node)\n\t\tcase 'reference':\n\t\tcase 'constant':\n\t\t\treturn node\n\t\tcase 'arrondi':\n\t\t\treturn traverseArrondiNode(fn, node)\n\t\tcase 'simplifier unité':\n\t\tcase 'variable manquante':\n\t\tcase 'est non applicable':\n\t\tcase 'est non défini':\n\t\t\treturn traverseUnaryOperationNode(fn, node)\n\t\tcase 'barème':\n\t\tcase 'taux progressif':\n\t\tcase 'grille':\n\t\t\treturn traverseNodeWithTranches(fn, node)\n\t\tcase 'une possibilité':\n\t\t\treturn traverseArrayNode(fn, node)\n\t\tcase 'durée':\n\t\t\treturn traverseDuréeNode(fn, node)\n\t\tcase 'résoudre référence circulaire':\n\t\t\treturn traverseRésoudreRéférenceCirculaireNode(fn, node)\n\t\tcase 'inversion':\n\t\t\treturn traverseInversionNode(fn, node)\n\t\tcase 'operation':\n\t\t\treturn traverseOperationNode(fn, node)\n\n\t\tcase 'contexte':\n\t\t\treturn traverseContexteNode(fn, node)\n\t\tcase 'unité':\n\t\t\treturn traverseUnitéNode(fn, node)\n\t\tcase 'variations':\n\t\t\treturn traverseVariationNode(fn, node)\n\t\tcase 'replacementRule':\n\t\t\treturn traverseReplacementNode(fn, node)\n\t\tcase 'texte':\n\t\t\treturn traverseTextNode(fn, node)\n\t\tcase 'condition':\n\t\t\treturn traverseConditionNode(fn, node)\n\n\t\tdefault:\n\t\t\tthrow new UnreachableCaseError(node)\n\t}\n}\n\nconst traverseSourceMap: TraverseFunction<NodeKind> = (fn, node) => {\n\tif (!('sourceMap' in node) || !node.sourceMap || !node.sourceMap.args) {\n\t\treturn node\n\t}\n\tconst sourceMap = node.sourceMap\n\n\tconst args = {}\n\tfor (const key in sourceMap.args) {\n\t\tconst value = sourceMap.args[key]\n\t\targs[key] = Array.isArray(value) ? value.map((v) => fn(v)) : fn(value)\n\t}\n\n\treturn {\n\t\t...node,\n\t\tsourceMap: {\n\t\t\t...sourceMap,\n\t\t\targs,\n\t\t},\n\t}\n}\n\nconst traverseRuleNode: TraverseFunction<'rule'> = (fn, node) => {\n\tconst copy = weakCopyObj(node)\n\tcopy.suggestions = {}\n\tfor (const key in node.suggestions) {\n\t\tcopy.suggestions[key] = fn(node.suggestions[key])\n\t}\n\tcopy.replacements = node.replacements.map(fn) as Array<ReplacementRule>\n\tcopy.explanation = {\n\t\truleDisabledByItsParent: node.explanation.ruleDisabledByItsParent,\n\t\tnullableParent:\n\t\t\tnode.explanation.nullableParent ?\n\t\t\t\tfn(node.explanation.nullableParent)\n\t\t\t:\tundefined,\n\t\tparents: node.explanation.parents.map(fn),\n\t\tvaleur: fn(node.explanation.valeur),\n\t}\n\n\treturn copy\n}\n\nconst traverseReplacementNode: TraverseFunction<'replacementRule'> = (\n\tfn,\n\tnode,\n) =>\n\t({\n\t\t...node,\n\t\tdefinitionRule: fn(node.definitionRule),\n\t\treplacedReference: fn(node.replacedReference),\n\t\twhiteListedNames: node.whiteListedNames.map(fn),\n\t\tblackListedNames: node.blackListedNames.map(fn),\n\t}) as ReplacementRule\n\nconst traverseUnaryOperationNode: TraverseFunction<\n\t| 'simplifier unité'\n\t| 'est non applicable'\n\t| 'est non défini'\n\t| 'variable manquante'\n> = (fn, node) => ({\n\t...node,\n\texplanation: fn(node.explanation),\n})\n\nfunction traverseTranche(fn: (n: ASTNode) => ASTNode, tranches: TrancheNodes) {\n\treturn tranches.map((tranche) => ({\n\t\t...tranche,\n\t\t...(tranche.plafond && { plafond: fn(tranche.plafond) }),\n\t\t...('montant' in tranche && { montant: fn(tranche.montant) }),\n\t\t...('taux' in tranche && { taux: fn(tranche.taux) }),\n\t}))\n}\nconst traverseNodeWithTranches: TraverseFunction<\n\t'barème' | 'taux progressif' | 'grille'\n> = (fn, node) => ({\n\t...node,\n\texplanation: {\n\t\tassiette: fn(node.explanation.assiette),\n\t\tmultiplicateur: fn(node.explanation.multiplicateur),\n\t\ttranches: traverseTranche(fn, node.explanation.tranches),\n\t},\n})\n\nconst traverseArrayNode: TraverseFunction<'une possibilité'> = (fn, node) => ({\n\t...node,\n\texplanation: node.explanation.map(fn),\n})\n\nconst traverseOperationNode: TraverseFunction<'operation'> = (fn, node) => {\n\tconst copy = weakCopyObj(node)\n\tcopy.explanation = [fn(node.explanation[0]), fn(node.explanation[1])]\n\n\treturn copy\n}\n\nconst traverseDuréeNode: TraverseFunction<'durée'> = (fn, node) => ({\n\t...node,\n\texplanation: {\n\t\tdepuis: fn(node.explanation.depuis),\n\t\t\"jusqu'à\": fn(node.explanation[\"jusqu'à\"]),\n\t},\n})\n\nconst traverseInversionNode: TraverseFunction<'inversion'> = (fn, node) => ({\n\t...node,\n\texplanation: {\n\t\t...node.explanation,\n\t\tinversionCandidates: node.explanation.inversionCandidates.map(fn) as any, // TODO\n\t},\n})\n\nconst traverseArrondiNode: TraverseFunction<'arrondi'> = (fn, node) => ({\n\t...node,\n\texplanation: {\n\t\tvaleur: fn(node.explanation.valeur),\n\t\tarrondi: fn(node.explanation.arrondi),\n\t},\n})\n\nconst traverseRésoudreRéférenceCirculaireNode: TraverseFunction<\n\t'résoudre référence circulaire'\n> = (fn, node) => ({\n\t...node,\n\texplanation: {\n\t\t...node.explanation,\n\t\tvaleur: fn(node.explanation.valeur),\n\t},\n})\n\nconst traverseTextNode: TraverseFunction<'texte'> = (fn, node) => ({\n\t...node,\n\texplanation: node.explanation.map((element) =>\n\t\ttypeof element === 'string' ? element : fn(element),\n\t),\n})\n\nconst traverseContexteNode: TraverseFunction<'contexte'> = (fn, node) => ({\n\t...node,\n\texplanation: {\n\t\t...node.explanation,\n\t\tcontexte: node.explanation.contexte.map(([name, value]) => [\n\t\t\tfn(name) as ReferenceNode,\n\t\t\tfn(value),\n\t\t]),\n\t\tvaleur: fn(node.explanation.valeur),\n\t},\n})\n\nconst traverseUnitéNode: TraverseFunction<'unité'> = (fn, node) => {\n\tconst copy = weakCopyObj(node)\n\tcopy.explanation = fn(node.explanation)\n\n\treturn copy\n}\n\nconst traverseVariationNode: TraverseFunction<'variations'> = (fn, node) => ({\n\t...node,\n\texplanation: node.explanation.map(({ condition, consequence }) => ({\n\t\tcondition: fn(condition),\n\t\tconsequence: consequence && fn(consequence),\n\t})),\n})\n\nconst traverseConditionNode: TraverseFunction<'condition'> = (fn, node) => {\n\tconst copy = weakCopyObj(node)\n\tcopy.explanation = {\n\t\tsi: fn(node.explanation.si),\n\t\talors: fn(node.explanation.alors),\n\t\tsinon: fn(node.explanation.sinon),\n\t}\n\n\treturn copy\n}\n","import { EvaluationFunction, PublicodesError } from '.'\nimport { ASTNode } from './AST/types'\n\nexport let evaluationFunctions = {\n\tconstant: (node) => node,\n} as any\n\nexport function registerEvaluationFunction<\n\tNodeName extends ASTNode['nodeKind'],\n>(nodeKind: NodeName, evaluationFunction: EvaluationFunction<NodeName>) {\n\tevaluationFunctions ??= {}\n\tif (evaluationFunctions[nodeKind]) {\n\t\tthrow new PublicodesError(\n\t\t\t'EvaluationError',\n\t\t\t`Multiple evaluation functions registered for the nodeKind \\x1b[4m${nodeKind}`,\n\t\t\t{ dottedName: '' },\n\t\t)\n\t}\n\tevaluationFunctions[nodeKind] = evaluationFunction\n}\n","import { ParsedRules } from '.'\nimport { ASTNode, ConstantNode } from './AST/types'\n\nexport type NodesTypes = WeakMap<ASTNode, InferedType>\n\n// TODO: Currently only handle nullability, but the infering logic should be\n// extended to support the full unit type system.\nexport type InferedType = {\n\tisNullable: boolean | undefined\n} & Pick<ConstantNode, 'type'>\n\nconst UNDEFINED_TYPE = {\n\tisNullable: undefined,\n\ttype: undefined,\n}\n\nexport default function inferNodesTypes(\n\tnewRulesNames: Array<string>,\n\tparsedRules: ParsedRules<string>,\n\tnodesTypes: NodesTypes,\n) {\n\tfunction inferNodeUnitAndCache(node: ASTNode): InferedType {\n\t\tif (!node || typeof node !== 'object') {\n\t\t\treturn UNDEFINED_TYPE\n\t\t}\n\t\tif (nodesTypes.has(node)) {\n\t\t\treturn nodesTypes.get(node)!\n\t\t}\n\t\t// Sometimes there are cycles, so we need to prevent infinite loop by setting a default\n\t\tnodesTypes.set(node, UNDEFINED_TYPE)\n\t\tconst type = inferNodeType(node)\n\t\tnodesTypes.set(node, type)\n\t\treturn type\n\t}\n\n\tfunction inferNodeType(node: ASTNode): InferedType {\n\t\tswitch (node.nodeKind) {\n\t\t\tcase 'barème':\n\t\t\tcase 'durée':\n\t\t\tcase 'grille':\n\t\t\tcase 'taux progressif':\n\t\t\t\treturn { isNullable: false, type: 'number' }\n\t\t\tcase 'est non défini':\n\t\t\tcase 'est non applicable':\n\t\t\t\treturn { isNullable: false, type: 'boolean' }\n\n\t\t\tcase 'constant':\n\t\t\t\treturn {\n\t\t\t\t\tisNullable: node.isNullable ?? node.nodeValue === null,\n\t\t\t\t\ttype: node.type,\n\t\t\t\t}\n\t\t\tcase 'operation':\n\t\t\t\treturn {\n\t\t\t\t\tisNullable:\n\t\t\t\t\t\t['<', '<=', '>', '>=', '/', '*'].includes(node.operationKind) ?\n\t\t\t\t\t\t\tinferNodeUnitAndCache(node.explanation[0]).isNullable ||\n\t\t\t\t\t\t\tinferNodeUnitAndCache(node.explanation[1]).isNullable\n\t\t\t\t\t\t: node.operationKind === '-' ?\n\t\t\t\t\t\t\tinferNodeUnitAndCache(node.explanation[0]).isNullable\n\t\t\t\t\t\t:\tfalse,\n\t\t\t\t\ttype:\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\t['<', '<=', '>', '>=', '=', '!=', 'et', 'ou'].includes(\n\t\t\t\t\t\t\t\tnode.operationKind,\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) ?\n\t\t\t\t\t\t\t'boolean'\n\t\t\t\t\t\t:\t'number',\n\t\t\t\t}\n\n\t\t\tcase 'inversion':\n\t\t\tcase 'replacementRule':\n\t\t\tcase 'résoudre référence circulaire':\n\t\t\t\treturn { isNullable: false, type: 'number' }\n\t\t\tcase 'texte':\n\t\t\tcase 'une possibilité':\n\t\t\t\treturn { isNullable: false, type: 'string' }\n\n\t\t\tcase 'contexte':\n\t\t\tcase 'rule':\n\t\t\tcase 'arrondi':\n\t\t\t\treturn inferNodeUnitAndCache(node.explanation.valeur)\n\t\t\tcase 'unité':\n\t\t\tcase 'simplifier unité':\n\t\t\tcase 'variable manquante':\n\t\t\t\treturn inferNodeUnitAndCache(node.explanation)\n\t\t\tcase 'condition':\n\t\t\t\treturn {\n\t\t\t\t\tisNullable: [\n\t\t\t\t\t\tnode.explanation.si,\n\t\t\t\t\t\tnode.explanation.alors,\n\t\t\t\t\t\tnode.explanation.sinon,\n\t\t\t\t\t].some((n) => inferNodeUnitAndCache(n).isNullable),\n\t\t\t\t\ttype:\n\t\t\t\t\t\tinferNodeUnitAndCache(node.explanation.alors).type ??\n\t\t\t\t\t\tinferNodeUnitAndCache(node.explanation.sinon).type,\n\t\t\t\t}\n\n\t\t\tcase 'variations': {\n\t\t\t\tconst consequencesTypes = node.explanation.map(({ consequence }) =>\n\t\t\t\t\tinferNodeUnitAndCache(consequence),\n\t\t\t\t)\n\t\t\t\treturn {\n\t\t\t\t\tisNullable: consequencesTypes.some(\n\t\t\t\t\t\t(consequence) => consequence.isNullable,\n\t\t\t\t\t),\n\t\t\t\t\ttype: consequencesTypes\n\t\t\t\t\t\t.map((c) => c.type)\n\t\t\t\t\t\t.find((type) => type !== undefined),\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcase 'reference':\n\t\t\t\treturn inferNodeUnitAndCache(parsedRules[node.dottedName as string])\n\t\t}\n\t}\n\n\tnewRulesNames.forEach((name) => {\n\t\tconst rule = parsedRules[name]\n\t\tinferNodeUnitAndCache(rule)\n\t\trule.explanation.parents.forEach(inferNodeUnitAndCache)\n\t})\n\n\treturn nodesTypes\n}\n","import { ASTNode, ConstantNode, EvaluatedNode, Evaluation } from './AST/types'\n\nexport const collectNodeMissing = (\n\tnode: EvaluatedNode | ASTNode,\n): Record<string, number> =>\n\t'missingVariables' in node ? node.missingVariables : {}\n\nexport const bonus = (missings: Record<string, number> = {}) =>\n\tObject.fromEntries(\n\t\tObject.entries(missings).map(([key, value]) => [key, value + 1]),\n\t)\nexport const mergeMissing = (\n\tleft: Record<string, number> | undefined = {},\n\tright: Record<string, number> | undefined = {},\n): Record<string, number> =>\n\tObject.fromEntries(\n\t\t[...Object.keys(left), ...Object.keys(right)].map((key) => [\n\t\t\tkey,\n\t\t\t(left[key] ?? 0) + (right[key] ?? 0),\n\t\t]),\n\t)\n\nexport const mergeAllMissing = (missings: Array<EvaluatedNode | ASTNode>) =>\n\tmissings.map(collectNodeMissing).reduce(mergeMissing, {})\n\nexport const defaultNode = (nodeValue: Evaluation) =>\n\t({\n\t\tnodeValue,\n\t\ttype: typeof nodeValue,\n\t\tisDefault: true,\n\t\tnodeKind: 'constant',\n\t}) as ConstantNode\n\nexport const notApplicableNode = {\n\tnodeKind: 'constant',\n\tnodeValue: null,\n\tmissingVariables: {},\n\ttype: undefined,\n\tisNullable: true,\n} as EvaluatedNode<'constant'>\n\nexport const undefinedNode = {\n\tnodeKind: 'constant',\n\tnodeValue: undefined,\n\tmissingVariables: {},\n\ttype: undefined,\n\tisNullable: false,\n} as EvaluatedNode<'constant'>\n\nexport const undefinedNumberNode = {\n\t...undefinedNode,\n\ttype: 'number',\n} as EvaluatedNode<'constant'>\n","import { PublicodesExpression } from '..'\nimport { makeASTTransformer } from '../AST'\nimport { ASTNode } from '../AST/types'\nimport { PublicodesError } from '../error'\nimport parse from '../parse'\nimport { Context, createContext } from '../parsePublicodes'\n\nexport function createParseInlinedMecanism(\n\tname: string,\n\targs: Record<string, { 'par défaut'?: PublicodesExpression; type?: 'liste' }>,\n\tbody: PublicodesExpression,\n) {\n\tlet parsedBody\n\tlet parsedDefaultArgs\n\tfunction parseInlineMecanism(providedArgs, context) {\n\t\tparsedBody ??= parse(body, createContext({ dottedName: 'INLINE_MECANISM' }))\n\t\tparsedDefaultArgs ??= {}\n\t\tfor (const name in args) {\n\t\t\tif ('par défaut' in args[name]) {\n\t\t\t\tparsedDefaultArgs[name] = parse(\n\t\t\t\t\targs[name]['par défaut'],\n\t\t\t\t\tcreateContext({}),\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\t// Case of unary mecanism\n\t\tif (Object.keys(args).length === 1 && 'valeur' in args) {\n\t\t\tprovidedArgs = {\n\t\t\t\tvaleur: providedArgs,\n\t\t\t}\n\t\t}\n\n\t\tconst parsedProvidedArgs = {}\n\t\tfor (const name in providedArgs) {\n\t\t\tparsedProvidedArgs[name] = parse(providedArgs[name], context)\n\t\t}\n\n\t\tconst parsedInlineMecanism = makeASTTransformer((node) => {\n\t\t\tif (node.nodeKind !== 'reference' || !(node.name in args)) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tconst argName = node.name\n\t\t\tif (argName in parsedProvidedArgs) {\n\t\t\t\treturn parsedProvidedArgs[argName]\n\t\t\t}\n\t\t\tif (argName in parsedDefaultArgs) {\n\t\t\t\treturn parsedDefaultArgs[argName]\n\t\t\t}\n\t\t\tthrow new PublicodesError(\n\t\t\t\t'SyntaxError',\n\t\t\t\t`Il manque la clé '${argName} dans le mécanisme ${name}`,\n\t\t\t\t{ dottedName: argName },\n\t\t\t)\n\t\t})(parsedBody)\n\n\t\tparsedInlineMecanism.sourceMap = {\n\t\t\tmecanismName: name,\n\t\t\targs: parsedProvidedArgs,\n\t\t}\n\n\t\treturn parsedInlineMecanism\n\t}\n\n\tparseInlineMecanism.nom = name\n\n\treturn Object.assign(parseInlineMecanism, 'name', {\n\t\tvalue: `parse${toCamelCase(name)}Inline`,\n\t})\n}\n\n/**\n Note : Les transformations de mécanisme opérant sur les listes sont plus couteuses que celles opérant sur des scalaires.\n\n Cela vient du fait qu'il n'y a pas la possibilité de définir ces transformations dans publicodes : il manque le type liste et les opérations de bases associées (reduce, map).\n\n On doit donc déplier l'opération statiquement, au parsing, ce qui prend plus de temps, au parsing et à l'évaluation. somme: [1,2,3] est transformé en (1 + 2) + 3).\n\n De manière général, les baisse en performances de cette PR sont attenduee : il s'agit d'une contrepartie logique de l'utilisation de mécanisme de base publicodes. Ce qu'on gagne en solidité de l'évaluation & en amélioration du typage, on le perd en performance. C'est logique puisque l'evaluation de ces mécanisme n'est plus du JS natif mais passe par une structure intermédiaire.\n\n Pour améliorer les perfs, il y a plusieurs pistes :\n\n\t- optimiser d'avantage les opérations de bases\n\t- ajouter les listes et les opérations sur les listes dans publicodes\n\t- ajouter une implémentation \"native\" de certains mécanismes utilisés (on gagne quand même à les décomposer en mécanismes de base pour la partie spécification et typage).\n */\nexport function createParseInlinedMecanismWithArray(\n\tname: string,\n\targs: Record<string, { type?: 'liste' }>,\n\tbody: (\n\t\targs: Record<string, ASTNode | Array<ASTNode>>,\n\t) => PublicodesExpression,\n) {\n\tfunction parseInlineMecanism(providedArgs, context: Context) {\n\t\t// Case of unary mecanism\n\t\tif (Object.keys(args).length === 1 && 'valeur' in args) {\n\t\t\tprovidedArgs = {\n\t\t\t\tvaleur: providedArgs,\n\t\t\t}\n\t\t}\n\n\t\tconst parsedProvidedArgs = {}\n\t\tfor (const name in providedArgs) {\n\t\t\tconst value = providedArgs[name]\n\t\t\tparsedProvidedArgs[name] =\n\t\t\t\tArray.isArray(value) ?\n\t\t\t\t\tvalue.map((v) => parse(v, context))\n\t\t\t\t:\tparse(value, context)\n\t\t}\n\n\t\tconst parsedInlineMecanism = parse(body(parsedProvidedArgs), context)\n\t\tparsedInlineMecanism.sourceMap = {\n\t\t\tmecanismName: name,\n\t\t\targs: parsedProvidedArgs,\n\t\t}\n\t\treturn parsedInlineMecanism\n\t}\n\n\tparseInlineMecanism.nom = name\n\n\treturn Object.assign(parseInlineMecanism, 'name', {\n\t\tvalue: `parse${toCamelCase(name)}Inline`,\n\t})\n}\n\nfunction toCamelCase(str: string) {\n\treturn str\n\t\t.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (ltr) => ltr.toUpperCase())\n\t\t.replace(/\\s+/g, '')\n}\n","import { createParseInlinedMecanism } from './inlineMecanism'\n\nexport default createParseInlinedMecanism(\n\t'abattement',\n\t{\n\t\tabattement: {},\n\t\tvaleur: {},\n\t},\n\t{\n\t\t'-': ['valeur', 'abattement'],\n\t\tplancher: 0,\n\t},\n)\n","import { notApplicableNode } from '../evaluationUtils'\nimport { createParseInlinedMecanism } from './inlineMecanism'\n\nexport default createParseInlinedMecanism(\n\t'applicable si',\n\t{\n\t\t'applicable si': {},\n\t\tvaleur: {},\n\t},\n\t{\n\t\tcondition: {\n\t\t\tsi: 'applicable si != non',\n\t\t\talors: 'valeur',\n\t\t\tsinon: notApplicableNode,\n\t\t},\n\t},\n)\n","import { BaseUnit, Evaluation, Unit } from './AST/types'\nimport { PublicodesError } from './error'\n\nexport type getUnitKey = (writtenUnit: string) => string\nexport type formatUnit = (unit: string, count: number) => string\n\nexport const parseUnit = (\n\tstring: string,\n\tgetUnitKey: getUnitKey = (x) => x,\n): Unit => {\n\tif (string.includes(' /') || string.includes('/ ')) {\n\t\tthrow new Error(\n\t\t\t`L'unité \"${string}\" ne doit pas contenir d'espace avant et après \"/\"`,\n\t\t)\n\t}\n\tconst [a, ...b] = string.split('/')\n\t// denominator could be 'x/y' or 'x.y' or 'x.y/z'\n\tconst splitUnit = (string: string): string[] =>\n\t\tdecomposePower(\n\t\t\tstring\n\t\t\t\t.split('.')\n\t\t\t\t.filter(Boolean)\n\t\t\t\t.map((unit) => getUnitKey(unit)),\n\t\t)\n\tconst result = {\n\t\tnumerators: splitUnit(a),\n\t\tdenominators: b.flatMap((u) => splitUnit(u)),\n\t}\n\treturn result\n}\n\nconst lastNumberFromString = /(\\d+)(?!.*[A-Za-z])/g\n\n/**\n * Count the number of each unit, e.g. [m, m, kg, kg] -> {m: 2, kg: 2}\n */\nfunction getUnitCounts(baseUnits: Array<BaseUnit>): Record<string, number> {\n\tconst countUnits = {}\n\tbaseUnits.forEach((e) => {\n\t\tconst powerMatch = e.match(lastNumberFromString)\n\t\tif (powerMatch != null) {\n\t\t\tconst power = powerMatch[0]\n\t\t\tconst primaryUnit = e.split(power)[0]\n\t\t\tcountUnits[primaryUnit] = (countUnits[primaryUnit] ?? 0) + +power\n\t\t} else {\n\t\t\tcountUnits[e] = (countUnits[e] ?? 0) + 1\n\t\t}\n\t})\n\treturn countUnits\n}\n\n/**\n * Decompose power of units, e.g. [m2] -> [m, m] or [kg2, m3] -> [kg, kg, m, m, m]\n */\nfunction decomposePower(baseUnits: Array<BaseUnit>): Array<BaseUnit> {\n\tconst unitCounts = getUnitCounts(baseUnits)\n\treturn Object.entries(unitCounts).flatMap(([primaryUnit, power]) =>\n\t\tArray(power).fill(primaryUnit),\n\t)\n}\n\n/**\n * Combine power of units, e.g. [m2, m] -> [m3] or [m, m, kg, kg] -> [m2, kg2]\n */\nfunction combinePower(baseUnit: Array<BaseUnit>): Array<BaseUnit> {\n\tconst unitCounts = getUnitCounts(baseUnit)\n\treturn Object.entries(unitCounts).map(([primaryUnit, power]) =>\n\t\tpower > 1 ? `${primaryUnit}${power}` : primaryUnit,\n\t)\n}\n\nconst printUnits = (\n\tunits: Array<BaseUnit>,\n\tcount: number,\n\tformatUnit: formatUnit = (x) => x,\n): string => {\n\treturn combinePower(units.map((unit) => formatUnit(unit, count))).join('.')\n}\n\nconst plural = 2\nexport function serializeUnit(\n\trawUnit: Unit | undefined | string,\n\tcount: number = plural,\n\tformatUnit: formatUnit = (x) => x,\n): string | undefined {\n\tif (rawUnit === null || typeof rawUnit !== 'object') {\n\t\treturn typeof rawUnit === 'string' ? formatUnit(rawUnit, count) : rawUnit\n\t}\n\tconst unit = simplify(rawUnit)\n\tconst { numerators = [], denominators = [] } = unit\n\n\tconst n = numerators.length > 0\n\tconst d = denominators.length > 0\n\tconst string =\n\t\t!n && !d ? ''\n\t\t: n && !d ? printUnits(numerators, count, formatUnit)\n\t\t: !n && d ? `/${printUnits(denominators, 1, formatUnit)}`\n\t\t: `${printUnits(numerators, plural, formatUnit)}/${printUnits(\n\t\t\t\tdenominators,\n\t\t\t\t1,\n\t\t\t\tformatUnit,\n\t\t\t)}`\n\n\treturn string\n}\n\ntype SupportedOperators = '*' | '/' | '+' | '-'\n\nconst noUnit = { numerators: [], denominators: [] }\nexport const inferUnit = (\n\toperator: SupportedOperators,\n\trawUnits: Array<Unit | undefined>,\n): Unit | undefined => {\n\tif (operator === '/') {\n\t\tif (rawUnits.length !== 2) {\n\t\t\tthrow new PublicodesError(\n\t\t\t\t'InternalError',\n\t\t\t\t'Infer units of a division with units.length !== 2)',\n\t\t\t\t{},\n\t\t\t)\n\t\t}\n\n\t\treturn inferUnit('*', [\n\t\t\trawUnits[0] || noUnit,\n\t\t\t{\n\t\t\t\tnumerators: (rawUnits[1] || noUnit).denominators,\n\t\t\t\tdenominators: (rawUnits[1] || noUnit).numerators,\n\t\t\t},\n\t\t])\n\t}\n\tconst units = rawUnits.filter(Boolean)\n\tif (units.length <= 1) {\n\t\treturn units[0]\n\t}\n\tif (operator === '*')\n\t\treturn simplify({\n\t\t\tnumerators: units.flatMap((u) => u?.numerators ?? []),\n\t\t\tdenominators: units.flatMap((u) => u?.denominators ?? []),\n\t\t})\n\n\tif (operator === '-' || operator === '+') {\n\t\treturn rawUnits.find((u) => u)\n\t}\n\n\treturn undefined\n}\n\nconst equals = <T>(a: T, b: T) => {\n\tif (Array.isArray(a) && Array.isArray(b)) {\n\t\treturn a.length === b.length && a.every((_, i) => a[i] === b[i])\n\t} else {\n\t\treturn a === b\n\t}\n}\n\nexport const removeOnce =\n\t<T>(element: T, eqFn: (a: T, b: T) => boolean = equals) =>\n\t(list: Array<T>): Array<T> => {\n\t\tconst index = list.findIndex((e) => eqFn(e, element))\n\t\treturn list.filter((_, i) => i !== index)\n\t}\n\nconst simplify = (\n\tunit: Unit,\n\teqFn: (a: string, b: string) => boolean = equals,\n): Unit => {\n\tconst simplifiedUnit = [...unit.numerators, ...unit.denominators].reduce(\n\t\t({ numerators, denominators }, next) =>\n\t\t\t(\n\t\t\t\tnumerators.find((u) => eqFn(next, u)) &&\n\t\t\t\tdenominators.find((u) => eqFn(next, u))\n\t\t\t) ?\n\t\t\t\t{\n\t\t\t\t\tnumerators: removeOnce(next, eqFn)(numerators),\n\t\t\t\t\tdenominators: removeOnce(next, eqFn)(denominators),\n\t\t\t\t}\n\t\t\t:\t{ numerators, denominators },\n\t\tunit,\n\t)\n\treturn simplifiedUnit\n}\n\nconst convertTable: ConvertTable = {\n\t'mois/an': 12,\n\t'jour/an': 365,\n\t'jour/mois': 365 / 12,\n\t'trimestre/an': 4,\n\t'mois/trimestre': 3,\n\t'jour/trimestre': (365 / 12) * 3,\n\t'€/k€': 10 ** 3,\n\t'g/kg': 10 ** 3,\n\t'mg/g': 10 ** 3,\n\t'mg/kg': 10 ** 6,\n\t'm/km': 10 ** 3,\n\t'cm/m': 10 ** 2,\n\t'mm/cm': 10 ** 1,\n\t'mm/m': 10 ** 3,\n\t'cm/km': 10 ** 5,\n\t'mm/km': 10 ** 6,\n}\n\nfunction singleUnitConversionFactor(\n\tfrom: string,\n\tto: string,\n): number | undefined {\n\treturn (\n\t\tconvertTable[`${to}/${from}`] ||\n\t\t(convertTable[`${from}/${to}`] && 1 / convertTable[`${from}/${to}`])\n\t)\n}\nfunction unitsConversionFactor(from: string[], to: string[]): number {\n\tlet factor =\n\t\t100 **\n\t\t// Factor is mutliplied or divided 100 for each '%' in units\n\t\t(to.filter((unit) => unit === '%').length -\n\t\t\tfrom.filter((unit) => unit === '%').length)\n\t;[factor] = from.reduce(\n\t\t([value, toUnits], fromUnit) => {\n\t\t\tconst index = toUnits.findIndex(\n\t\t\t\t(toUnit) => !!singleUnitConversionFactor(fromUnit, toUnit),\n\t\t\t)\n\t\t\tconst factor = singleUnitConversionFactor(fromUnit, toUnits[index]) || 1\n\t\t\treturn [\n\t\t\t\tvalue * factor,\n\t\t\t\t[...toUnits.slice(0, index + 1), ...toUnits.slice(index + 1)],\n\t\t\t]\n\t\t},\n\t\t[factor, to],\n\t)\n\treturn factor\n}\n\n// TODO(@clemog):\n// - Deal with other equivalent units : l: 'dm3',\n// - Convert unit instead of ignore warning\nconst equivalentTable = {\n\t'kW.h': 'kWh',\n\t'mn/h': 'noeud',\n}\n\nfunction areEquivalentSerializedUnit(\n\tserializedFrom: string | undefined,\n\tserializedTo: string | undefined,\n): boolean {\n\tif (!serializedFrom || !serializedTo) return false\n\treturn (\n\t\tserializedFrom === serializedTo ||\n\t\tserializedFrom === equivalentTable[serializedTo] ||\n\t\tserializedTo === equivalentTable[serializedFrom]\n\t)\n}\n\nexport function convertUnit<ValType extends Evaluation<number>>(\n\tfrom: Unit | undefined,\n\tto: Unit | undefined,\n\tvalue: ValType,\n): ValType {\n\tconst serializedFrom = serializeUnit(from)\n\tconst serializedTo = serializeUnit(to)\n\tif (\n\t\t!areEquivalentSerializedUnit(serializedFrom, serializedTo) &&\n\t\t!areUnitConvertible(from, to)\n\t) {\n\t\tthrow new PublicodesError(\n\t\t\t'EngineError',\n\t\t\t`Impossible de convertir l'unité '${serializedFrom}' en '${serializedTo}'`,\n\t\t\t{},\n\t\t)\n\t}\n\tif (!value) {\n\t\treturn value\n\t}\n\tif (from === undefined) {\n\t\treturn value\n\t}\n\tconst [fromSimplified, factorTo] = simplifyUnitWithValue(from || noUnit)\n\tconst [toSimplified, factorFrom] = simplifyUnitWithValue(to || noUnit)\n\treturn round(\n\t\t(((value as number) * factorTo) / factorFrom) *\n\t\t\tunitsConversionFactor(\n\t\t\t\tfromSimplified.numerators,\n\t\t\t\ttoSimplified.numerators,\n\t\t\t) *\n\t\t\tunitsConversionFactor(\n\t\t\t\ttoSimplified.denominators,\n\t\t\t\tfromSimplified.denominators,\n\t\t\t),\n\t) as any\n}\n\nconst convertibleUnitClasses = unitClasses(convertTable)\ntype unitClasses = Array<Set<string>>\ntype ConvertTable = { readonly [index: string]: number }\n\n// Reduce the convertTable provided by the user into a list of compatibles\n// classes.\nfunction unitClasses(convertTable: ConvertTable) {\n\treturn Object.keys(convertTable).reduce(\n\t\t(classes: unitClasses, ratio: string) => {\n\t\t\tconst [a, b] = ratio.split('/')\n\t\t\tconst ia = classes.findIndex((units) => units.has(a))\n\t\t\tconst ib = classes.findIndex((units) => units.has(b))\n\t\t\tif (ia > -1 && ib > -1 && ia !== ib) {\n\t\t\t\tthrow new PublicodesError('EngineError', `Invalid ratio ${ratio}`, {})\n\t\t\t} else if (ia === -1 && ib === -1) {\n\t\t\t\tclasses.push(new Set([a, b]))\n\t\t\t} else if (ia > -1) {\n\t\t\t\tclasses[ia].add(b)\n\t\t\t} else if (ib > -1) {\n\t\t\t\tclasses[ib].add(a)\n\t\t\t}\n\t\t\treturn classes\n\t\t},\n\t\t[],\n\t)\n}\n\nfunction areSameClass(a: string, b: string) {\n\treturn (\n\t\ta === b ||\n\t\tconvertibleUnitClasses.some(\n\t\t\t(unitsClass) => unitsClass.has(a) && unitsClass.has(b),\n\t\t)\n\t)\n}\n\nfunction round(value: number) {\n\treturn +value.toFixed(16)\n}\n\nexport function simplifyUnit(unit: Unit): Unit {\n\tconst { numerators, denominators } = simplify(unit, areSameClass)\n\tif (numerators.length && numerators.every((symb) => symb === '%')) {\n\t\treturn { numerators: ['%'], denominators }\n\t}\n\treturn removePercentages({ numerators, denominators })\n}\n\nfunction simplifyUnitWithValue(unit: Unit, value = 1): [Unit, number] {\n\tconst factor = unitsConversionFactor(unit.numerators, unit.denominators)\n\treturn [\n\t\tsimplify(removePercentages(unit), areSameClass),\n\t\tvalue ? round(value * factor) : value,\n\t]\n}\n\nconst removePercentages = (unit: Unit): Unit => ({\n\tnumerators: unit.numerators.filter((e) => e !== '%'),\n\tdenominators: unit.denominators.filter((e) => e !== '%'),\n})\n\nexport function areUnitConvertible(a: Unit | undefined, b: Unit | undefined) {\n\tif (a == null || b == null) {\n\t\treturn true\n\t}\n\tconst countByUnitClass = (units: Array<BaseUnit>) =>\n\t\tunits.reduce((counters, unit) => {\n\t\t\tconst classIndex = convertibleUnitClasses.findIndex((unitClass) =>\n\t\t\t\tunitClass.has(unit),\n\t\t\t)\n\t\t\tconst key = classIndex === -1 ? unit : '' + classIndex\n\t\t\treturn { ...counters, [key]: 1 + (counters[key] ?? 0) }\n\t\t}, {})\n\n\tconst [numA, denomA, numB, denomB] = [\n\t\ta.numerators,\n\t\ta.denominators,\n\t\tb.numerators,\n\t\tb.denominators,\n\t].map(countByUnitClass)\n\tconst uniq = <T>(arr: Array<T>): Array<T> => [...new Set(arr)]\n\tconst unitClasses = [numA, denomA, numB, denomB].map(Object.keys).flat()\n\treturn uniq(unitClasses).every(\n\t\t(unitClass) =>\n\t\t\t(numA[unitClass] || 0) - (denomA[unitClass] || 0) ===\n\t\t\t\t(numB[unitClass] || 0) - (denomB[unitClass] || 0) || unitClass === '%',\n\t)\n}\n","import { EvaluationFunction, simplifyNodeUnit } from '..'\nimport { ASTNode, EvaluatedNode } from '../AST/types'\nimport { PublicodesError } from '../error'\nimport { registerEvaluationFunction } from '../evaluationFunctions'\nimport { mergeAllMissing } from '../evaluationUtils'\nimport parse from '../parse'\nimport { serializeUnit } from '../units'\n\nexport type ArrondiNode = {\n\texplanation: {\n\t\tarrondi: ASTNode\n\t\tvaleur: ASTNode\n\t}\n\tnodeKind: 'arrondi'\n}\n\nfunction roundWithPrecision(n: number, fractionDigits: number) {\n\treturn +n.toFixed(fractionDigits)\n}\n\nconst evaluate: EvaluationFunction<'arrondi'> = function (node) {\n\t// We need to simplify the node unit to correctly round values containing\n\t// percentages units, see #1358\n\tconst valeur = simplifyNodeUnit(this.evaluateNode(node.explanation.valeur))\n\tconst nodeValue = valeur.nodeValue\n\tlet arrondi = node.explanation.arrondi\n\tif (nodeValue !== false) {\n\t\tarrondi = this.evaluateNode(arrondi)\n\n\t\tif (\n\t\t\ttypeof (arrondi as EvaluatedNode).nodeValue === 'number' &&\n\t\t\t!serializeUnit((arrondi as EvaluatedNode).unit)?.match(/décimales?/)\n\t\t) {\n\t\t\tthrow new PublicodesError(\n\t\t\t\t'EvaluationError',\n\t\t\t\t`L'unité ${serializeUnit(\n\t\t\t\t\t(arrondi as EvaluatedNode).unit,\n\t\t\t\t)} de l'arrondi est inconnu. Vous devez utiliser l'unité “décimales”`,\n\t\t\t\t{ dottedName: this.cache._meta.evaluationRuleStack[0] },\n\t\t\t)\n\t\t}\n\t}\n\n\treturn {\n\t\t...node,\n\t\tnodeValue:\n\t\t\ttypeof valeur.nodeValue !== 'number' || !('nodeValue' in arrondi) ?\n\t\t\t\tvaleur.nodeValue\n\t\t\t: typeof arrondi.nodeValue === 'number' ?\n\t\t\t\troundWithPrecision(valeur.nodeValue, arrondi.nodeValue)\n\t\t\t: arrondi.nodeValue === true ? roundWithPrecision(valeur.nodeValue, 0)\n\t\t\t: arrondi.nodeValue === undefined ? undefined\n\t\t\t: valeur.nodeValue,\n\t\texplanation: { valeur, arrondi },\n\t\tmissingVariables: mergeAllMissing([valeur, arrondi]),\n\t\tunit: valeur.unit,\n\t}\n}\n\nexport default function parseArrondi(v, context) {\n\tconst explanation = {\n\t\tvaleur: parse(v.valeur, context),\n\t\tarrondi: parse(v.arrondi, context),\n\t}\n\treturn {\n\t\texplanation,\n\t\tnodeKind: parseArrondi.nom,\n\t}\n}\n\nparseArrondi.nom = 'arrondi' as const\n\nregisterEvaluationFunction(parseArrondi.nom, evaluate)\n","import { EvaluatedNode, Unit } from './AST/types'\nimport { convertUnit, simplifyUnit } from './units'\n\nexport function simplifyNodeUnit(node) {\n\tif (!node.unit) {\n\t\treturn node\n\t}\n\tconst unit = simplifyUnit(node.unit)\n\n\treturn convertNodeToUnit(unit, node)\n}\n\nexport function convertNodeToUnit<Node extends EvaluatedNode = EvaluatedNode>(\n\tto: Unit | undefined,\n\tnode: Node,\n): Node {\n\treturn {\n\t\t...node,\n\t\tnodeValue:\n\t\t\tnode.unit && typeof node.nodeValue === 'number' ?\n\t\t\t\tconvertUnit(node.unit, to, node.nodeValue)\n\t\t\t:\tnode.nodeValue,\n\t\tunit: to,\n\t}\n}\n","import { Evaluation, Unit } from './AST/types'\nimport { simplifyNodeUnit } from './nodeUnits'\nimport { formatUnit, serializeUnit } from './units'\n\nexport const numberFormatter =\n\t({\n\t\tstyle,\n\t\tmaximumFractionDigits = 2,\n\t\tminimumFractionDigits = 0,\n\t\tlanguage,\n\t}: {\n\t\tstyle?: string\n\t\tmaximumFractionDigits?: number\n\t\tminimumFractionDigits?: number\n\t\tlanguage?: string\n\t}) =>\n\t(value: number) => {\n\t\t// When we format currency we don't want to display a single decimal digit\n\t\t// ie 8,1€ but we want to display 8,10€\n\t\tconst adaptedMinimumFractionDigits =\n\t\t\t(\n\t\t\t\tstyle === 'currency' &&\n\t\t\t\tmaximumFractionDigits >= 2 &&\n\t\t\t\tminimumFractionDigits === 0 &&\n\t\t\t\t!Number.isInteger(value)\n\t\t\t) ?\n\t\t\t\t2\n\t\t\t:\tminimumFractionDigits\n\t\treturn Intl.NumberFormat(language, {\n\t\t\tstyle,\n\t\t\tcurrency: 'EUR',\n\t\t\tmaximumFractionDigits,\n\t\t\tminimumFractionDigits: adaptedMinimumFractionDigits,\n\t\t}).format(value)\n\t}\n\nexport const formatCurrency = (\n\tnodeValue: number | undefined,\n\tlanguage: string,\n) => {\n\treturn nodeValue == undefined ? '' : (\n\t\t\t(formatNumber({ unit: '€', language, nodeValue }) ?? '').replace(\n\t\t\t\t/^(-)?€/,\n\t\t\t\t'$1€\\u00A0',\n\t\t\t)\n\t\t)\n}\n\nexport const formatPercentage = (nodeValue: number | undefined) =>\n\tnodeValue == undefined ? '' : (\n\t\tformatNumber({ unit: '%', nodeValue, maximumFractionDigits: 2 })\n\t)\n\ntype formatValueOptions = {\n\tmaximumFractionDigits?: number\n\tminimumFractionDigits?: number\n\tlanguage?: string\n\tunit?: Unit | string\n\tformatUnit?: formatUnit\n\tnodeValue: number\n}\n\nfunction formatNumber({\n\tmaximumFractionDigits,\n\tminimumFractionDigits,\n\tlanguage,\n\tformatUnit,\n\tunit,\n\tnodeValue,\n}: formatValueOptions) {\n\tif (typeof nodeValue !== 'number') {\n\t\treturn nodeValue\n\t}\n\tconst serializedUnit =\n\t\tunit ? serializeUnit(unit, nodeValue, formatUnit) : undefined\n\tswitch (serializedUnit) {\n\t\tcase '€':\n\t\t\treturn numberFormatter({\n\t\t\t\tstyle: 'currency',\n\t\t\t\tmaximumFractionDigits,\n\t\t\t\tminimumFractionDigits,\n\t\t\t\tlanguage,\n\t\t\t})(nodeValue)\n\t\tcase '%':\n\t\t\treturn numberFormatter({\n\t\t\t\tstyle: 'percent',\n\t\t\t\tmaximumFractionDigits,\n\t\t\t\tlanguage,\n\t\t\t})(nodeValue / 100)\n\t\tdefault:\n\t\t\treturn (\n\t\t\t\tnumberFormatter({\n\t\t\t\t\tstyle: 'decimal',\n\t\t\t\t\tminimumFractionDigits,\n\t\t\t\t\tmaximumFractionDigits,\n\t\t\t\t\tlanguage,\n\t\t\t\t})(nodeValue) +\n\t\t\t\t(typeof serializedUnit === 'string' ? `\\u00A0${serializedUnit}` : '')\n\t\t\t)\n\t}\n}\n\nexport function capitalise0(name: undefined): undefined\nexport function capitalise0(name: string): string\nexport function capitalise0(name?: string) {\n\treturn name && name[0].toUpperCase() + name.slice(1)\n}\n\nconst booleanTranslations = {\n\tfr: { true: 'oui', false: 'non' },\n\ten: { true: 'yes', false: 'no' },\n}\n\ntype Options = {\n\tlanguage?: string\n\tdisplayedUnit?: string\n\tprecision?: number\n\tformatUnit?: formatUnit\n}\n\nexport function formatValue(\n\tvalue: number | { nodeValue: Evaluation; unit?: Unit } | undefined,\n\n\t{ language = 'fr', displayedUnit, formatUnit, precision = 2 }: Options = {},\n) {\n\tlet nodeValue =\n\t\t(\n\t\t\ttypeof value === 'number' ||\n\t\t\ttypeof value === 'undefined' ||\n\t\t\tvalue === null\n\t\t) ?\n\t\t\tvalue\n\t\t:\tvalue.nodeValue\n\n\tif (typeof nodeValue === 'number' && Number.isNaN(nodeValue)) {\n\t\treturn 'Erreur dans le calcul du nombre'\n\t}\n\tif (nodeValue === undefined) {\n\t\treturn 'Pas encore défini'\n\t}\n\tif (nodeValue === null) {\n\t\treturn 'Non applicable'\n\t}\n\tif (typeof nodeValue === 'string') {\n\t\treturn nodeValue.replace('\\\\n', '\\n')\n\t}\n\tif (typeof nodeValue === 'boolean')\n\t\treturn booleanTranslations[language][nodeValue]\n\tif (typeof nodeValue === 'number') {\n\t\tlet unit =\n\t\t\t(\n\t\t\t\ttypeof value === 'number' ||\n\t\t\t\ttypeof value === 'undefined' ||\n\t\t\t\t!('unit' in value)\n\t\t\t) ?\n\t\t\t\tundefined\n\t\t\t:\tvalue.unit\n\t\tif (unit) {\n\t\t\tconst simplifiedNode = simplifyNodeUnit({\n\t\t\t\tunit,\n\t\t\t\tnodeValue,\n\t\t\t})\n\t\t\tunit = simplifiedNode.unit\n\t\t\tnodeValue = simplifiedNode.nodeValue as number\n\t\t}\n\t\treturn formatNumber({\n\t\t\tminimumFractionDigits: 0,\n\t\t\tmaximumFractionDigits: precision,\n\t\t\tlanguage,\n\t\t\tformatUnit,\n\t\t\tnodeValue,\n\t\t\tunit: displayedUnit ?? unit,\n\t\t}).trim()\n\t}\n\treturn undefined\n}\n\nexport function serializeValue(\n\t{ nodeValue, unit }: { nodeValue: Evaluation; unit?: Unit },\n\t{ format }: { format: formatUnit },\n) {\n\tconst serializedUnit = (\n\t\tunit && typeof nodeValue === 'number' ?\n\t\t\tserializeUnit(unit, nodeValue, format)\n\t\t:\t'')?.replace(/\\s*\\/\\s*/g, '/')\n\treturn `${nodeValue} ${serializedUnit}`.trim()\n}\n","import { ParsedRules } from '.'\nimport { ASTNode } from './AST/types'\nimport { PublicodesError } from './error'\nimport { ReferencesMaps } from './parsePublicodes'\nimport { ReferenceNode } from './reference'\nimport { RuleNode } from './rule'\nimport { addToMapSet } from './utils'\n\nexport { cyclicDependencies } from './AST/graph'\n\nconst splitName = (str: string) => str.split(' . ')\nconst joinName = (strs: Array<string>) => strs.join(' . ')\n\n/**\n * Returns the last part of a dottedName (the leaf).\n */\nexport const nameLeaf = (dottedName: string) =>\n\tsplitName(dottedName).slice(-1)?.[0]\n\n/**\n * Encodes a dottedName for the URL to be secure.\n * @see {@link decodeRuleName}\n */\nexport const encodeRuleName = (dottedName: string): string =>\n\tdottedName\n\t\t?.replace(/\\s\\.\\s/g, '/')\n\t\t.replace(/-/g, '\\u2011') // replace with a insecable tiret to differenciate from space\n\t\t.replace(/\\s/g, '-')\n\n/**\n * Decodes an encoded dottedName.\n * @see {@link encodeRuleName}\n */\nexport const decodeRuleName = (dottedName: string): string =>\n\tdottedName\n\t\t.replace(/\\//g, ' . ')\n\t\t.replace(/-/g, ' ')\n\t\t.replace(/\\u2011/g, '-')\n\n/**\n * Return dottedName from contextName\n */\nexport const contextNameToDottedName = (contextName: string) =>\n\tcontextName.endsWith('$SITUATION') ? ruleParent(contextName) : contextName\n\n/**\n * Returns the parent dottedName\n */\nexport const ruleParent = (dottedName: string): string =>\n\tjoinName(splitName(dottedName).slice(0, -1))\n\n/**\n * Returns an array of dottedName from near parent to far parent.\n */\nexport function ruleParents(dottedName: string): Array<string> {\n\treturn splitName(dottedName)\n\t\t.slice(0, -1)\n\t\t.map((_, i, arr) => joinName(arr.slice(0, i + 1)))\n\t\t.reverse()\n}\n\n/**\n * Returns an array of all child rules of a dottedName\n */\nexport const getChildrenRules = (\n\tparsedRules: ParsedRules<string>,\n\tdottedName: string,\n) => {\n\tconst childrenRules = Object.keys(parsedRules).filter(\n\t\t(ruleDottedName) =>\n\t\t\truleDottedName.startsWith(dottedName) &&\n\t\t\tsplitName(ruleDottedName).length === splitName(dottedName).length + 1,\n\t)\n\n\treturn childrenRules\n}\n\n/**\n * Finds the common ancestor of two dottedName\n */\nexport function findCommonAncestor(dottedName1: string, dottedName2: string) {\n\tconst splitDottedName1 = splitName(dottedName1)\n\tconst splitDottedName2 = splitName(dottedName2)\n\tconst index = splitDottedName1.findIndex(\n\t\t(value, i) => splitDottedName2[i] !== value,\n\t)\n\n\treturn index === -1 ? dottedName1 : joinName(splitDottedName1.slice(0, index))\n}\n\n/**\n * Check wether a rule is accessible from a namespace.\n *\n * Takes into account that some namespace can be `private`, i.e. that they can only be\n * accessed by immediate parent, children or siblings.\n *\n * @param rules The parsed rules\n * @param contextName The context of the call\n * @param name The namespace checked for accessibility\n */\nexport function isAccessible(\n\trules: Record<string, RuleNode>,\n\tcontextName: string,\n\tname: string,\n) {\n\tif (!(name in rules)) {\n\t\tthrow new PublicodesError(\n\t\t\t'InternalError',\n\t\t\t`La règle \"${name}\" n'existe pas`,\n\t\t\t{ dottedName: name },\n\t\t)\n\t}\n\n\tconst commonAncestor = findCommonAncestor(contextName, name)\n\tconst parents = [name, ...ruleParents(name), '']\n\tconst rulesToCheckForPrivacy = parents.slice(\n\t\t0,\n\t\tMath.max(parents.indexOf(commonAncestor) - 1, 0),\n\t)\n\n\treturn rulesToCheckForPrivacy.every(\n\t\t(dottedName) =>\n\t\t\t!(dottedName in rules) || rules[dottedName].private === false,\n\t)\n}\n\n/**\n * Check wether a rule is tagged as experimental.\n *\n * Takes into account the a children of an experimental rule is also experimental\n *\n * @param rules The parsed rules\n * @param name The namespace checked for experimental\n */\nexport function isExperimental(rules: Record<string, RuleNode>, name: string) {\n\tif (!(name in rules)) {\n\t\tthrow new PublicodesError(\n\t\t\t'InternalError',\n\t\t\t`La règle \"${name}\" n'existe pas`,\n\t\t\t{ dottedName: name },\n\t\t)\n\t}\n\tconst parents = [name, ...ruleParents(name)]\n\treturn parents.some(\n\t\t(dottedName) =>\n\t\t\tdottedName in rules && rules[dottedName].rawNode?.experimental === 'oui',\n\t)\n}\n\nfunction dottedNameFromContext(context: string, partialName: string) {\n\treturn context ? context + ' . ' + partialName : partialName\n}\nexport function disambiguateReference<R extends Record<string, RuleNode>>(\n\trules: R,\n\treferencedFrom = '',\n\tpartialName: string,\n): keyof R {\n\tconst possibleContexts = ruleParents(referencedFrom)\n\tpossibleContexts.push(referencedFrom)\n\n\t// If the partialName starts with ^ . ^ . ^ . , we want to go up in the parents\n\tif (partialName.startsWith('^ . ')) {\n\t\tconst numberParent = partialName.match(/^(\\^ \\. )+/)![0].length / 4\n\t\tpartialName = partialName.replace(/^(\\^ \\. )+/, '')\n\t\tpossibleContexts.splice(-numberParent)\n\t}\n\n\tconst rootContext = possibleContexts.pop()\n\tpossibleContexts.unshift(rootContext as string)\n\tpossibleContexts.push('')\n\n\tconst context = possibleContexts.find((context) => {\n\t\tconst dottedName = dottedNameFromContext(context, partialName)\n\t\tif (!(dottedName in rules)) {\n\t\t\treturn false\n\t\t}\n\t\tif (dottedName === referencedFrom) {\n\t\t\treturn false\n\t\t}\n\t\treturn isAccessible(rules, referencedFrom, dottedName)\n\t})\n\n\tif (context !== undefined) {\n\t\treturn dottedNameFromContext(context, partialName) as keyof R\n\t}\n\n\t// The last possibility we want to check is if the rule is referencing itself\n\tif (referencedFrom.endsWith(partialName)) {\n\t\treturn referencedFrom as keyof R\n\t}\n\n\tconst possibleDottedName = possibleContexts.map((c) =>\n\t\tdottedNameFromContext(c, partialName),\n\t)\n\n\tif (possibleDottedName.every((dottedName) => !(dottedName in rules))) {\n\t\tthrow new PublicodesError(\n\t\t\t'SyntaxError',\n\t\t\t`La référence \"${partialName}\" est introuvable.\nVérifiez que l'orthographe et l'espace de nom sont corrects`,\n\t\t\t{ dottedName: contextNameToDottedName(referencedFrom) },\n\t\t)\n\t}\n\n\tthrow new PublicodesError(\n\t\t'SyntaxError',\n\t\t`La règle \"${possibleDottedName.find(\n\t\t\t(dottedName) => dottedName in rules,\n\t\t)}\" n'est pas accessible depuis \"${referencedFrom}\".\n\tCela vient du fait qu'elle est privée ou qu'un de ses parent est privé`,\n\t\t{ dottedName: contextNameToDottedName(referencedFrom) },\n\t)\n}\n\nexport function ruleWithDedicatedDocumentationPage(rule) {\n\treturn (\n\t\trule.virtualRule !== true &&\n\t\trule.type !== 'groupe' &&\n\t\trule.type !== 'texte' &&\n\t\trule.type !== 'paragraphe' &&\n\t\trule.type !== 'notification'\n\t)\n}\n\nexport function updateReferencesMapsFromReferenceNode(\n\tnode: ASTNode,\n\treferencesMaps: ReferencesMaps<string>,\n\truleDottedName?: string,\n) {\n\tif (node.nodeKind === 'reference') {\n\t\taddToMapSet(\n\t\t\treferencesMaps.referencesIn,\n\t\t\truleDottedName ?? node.contextDottedName,\n\t\t\tnode.dottedName,\n\t\t)\n\t\taddToMapSet(\n\t\t\treferencesMaps.rulesThatUse,\n\t\t\tnode.dottedName,\n\t\t\truleDottedName ?? node.contextDottedName,\n\t\t)\n\t}\n}\nexport function disambiguateReferenceNode(\n\tnode: ASTNode,\n\tparsedRules: ParsedRules<string>,\n): ReferenceNode | undefined {\n\tif (node.nodeKind !== 'reference') {\n\t\treturn\n\t}\n\tif (node.dottedName) {\n\t\treturn node\n\t}\n\n\tnode.dottedName = disambiguateReference(\n\t\tparsedRules,\n\t\tnode.contextDottedName,\n\t\tnode.name,\n\t)\n\tnode.title = parsedRules[node.dottedName].title\n\tnode.acronym = parsedRules[node.dottedName].rawNode.acronyme\n\treturn node\n}\n","/* eslint-disable prefer-rest-params */\n/* eslint-disable @typescript-eslint/no-this-alias */\n// Adapted from https://github.com/dagrejs/graphlib (MIT license)\n// and https://github.com/lodash/lodash (MIT license)\n\n// TODO: type this\n\nfunction has(obj, key) {\n\treturn obj != null && Object.prototype.hasOwnProperty.call(obj, key)\n}\nfunction constant(value) {\n\treturn function () {\n\t\treturn value\n\t}\n}\n\nconst DEFAULT_EDGE_NAME = '\\x00'\nconst EDGE_KEY_DELIM = '\\x01'\n\nconst incrementOrInitEntry = (map, k) => {\n\tif (map[k]) {\n\t\tmap[k]++\n\t} else {\n\t\tmap[k] = 1\n\t}\n}\n\nconst decrementOrRemoveEntry = (map, k) => {\n\tif (!--map[k]) {\n\t\tdelete map[k]\n\t}\n}\n\nconst edgeArgsToId = (isDirected, v_, w_, name) => {\n\tlet v = '' + v_\n\tlet w = '' + w_\n\tif (!isDirected && v > w) {\n\t\tconst tmp = v\n\t\tv = w\n\t\tw = tmp\n\t}\n\treturn (\n\t\tv +\n\t\tEDGE_KEY_DELIM +\n\t\tw +\n\t\tEDGE_KEY_DELIM +\n\t\t(name === undefined ? DEFAULT_EDGE_NAME : name)\n\t)\n}\n\nconst edgeArgsToObj = (isDirected, v_, w_, name) => {\n\tlet v = '' + v_\n\tlet w = '' + w_\n\tif (!isDirected && v > w) {\n\t\tconst tmp = v\n\t\tv = w\n\t\tw = tmp\n\t}\n\tconst edgeObj: any = { v: v, w: w }\n\tif (name) {\n\t\tedgeObj.name = name\n\t}\n\treturn edgeObj\n}\n\nconst edgeObjToId = (isDirected, edgeObj) => {\n\treturn edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name)\n}\nexport class Graph {\n\tprivate _nodeCount = 0\n\tprivate _edgeCount = 0\n\n\tprivate _isDirected: any\n\n\tprivate _label: undefined\n\tprivate _defaultNodeLabelFn: (...args: any[]) => any\n\tprivate _defaultEdgeLabelFn: (...args: any[]) => any\n\tprivate _nodes: Record<string, any>\n\tprivate _in: Record<string, any>\n\tprivate _preds: Record<string, Record<string, number>>\n\tprivate _out: Record<string, Record<string, string>>\n\tprivate _sucs: Record<string, Record<string, number>>\n\tprivate _edgeObjs: Record<any, any>\n\tprivate _edgeLabels: Record<any, string>\n\n\tconstructor(opts: Record<string, boolean> = {}) {\n\t\tthis._isDirected = has(opts, 'directed') ? opts.directed : true\n\n\t\t// Label for the graph itself\n\t\tthis._label = undefined\n\n\t\t// Defaults to be set when creating a new node\n\t\tthis._defaultNodeLabelFn = constant(undefined)\n\n\t\t// Defaults to be set when creating a new edge\n\t\tthis._defaultEdgeLabelFn = constant(undefined)\n\n\t\t// v -> label\n\t\tthis._nodes = {}\n\n\t\t// v -> edgeObj\n\t\tthis._in = {}\n\n\t\t// u -> v -> Number\n\t\tthis._preds = {}\n\n\t\t// v -> edgeObj\n\t\tthis._out = {} as Record<string, Record<string, string>>\n\n\t\t// v -> w -> Number\n\t\tthis._sucs = {}\n\n\t\t// e -> edgeObj\n\t\tthis._edgeObjs = {}\n\n\t\t// e -> label\n\t\tthis._edgeLabels = {}\n\t}\n\n\t/* === Graph functions ========= */\n\n\tisDirected() {\n\t\treturn this._isDirected\n\t}\n\tsetGraph(label) {\n\t\tthis._label = label\n\t\treturn this\n\t}\n\tgraph() {\n\t\treturn this._label\n\t}\n\n\t/* === Node functions ========== */\n\n\tnodeCount() {\n\t\treturn this._nodeCount\n\t}\n\tnodes() {\n\t\treturn Object.keys(this._nodes)\n\t}\n\tsetNode(v, value: any = undefined) {\n\t\tif (has(this._nodes, v)) {\n\t\t\tif (arguments.length > 1) {\n\t\t\t\tthis._nodes[v] = value\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tthis._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v)\n\t\tthis._in[v] = {}\n\t\tthis._preds[v] = {}\n\t\tthis._out[v] = {}\n\t\tthis._sucs[v] = {}\n\t\t++this._nodeCount\n\t\treturn this\n\t}\n\tsetNodes(vs, value) {\n\t\tvs.forEach((v) => {\n\t\t\tif (value !== undefined) {\n\t\t\t\tthis.setNode(v, value)\n\t\t\t} else {\n\t\t\t\tthis.setNode(v)\n\t\t\t}\n\t\t})\n\t\treturn this\n\t}\n\tnode(v) {\n\t\treturn this._nodes[v]\n\t}\n\thasNode(v) {\n\t\treturn has(this._nodes, v)\n\t}\n\tsuccessors(v) {\n\t\tconst sucsV = this._sucs[v]\n\t\tif (sucsV) {\n\t\t\treturn Object.keys(sucsV)\n\t\t}\n\t}\n\n\t/* === Edge functions ========== */\n\n\tedgeCount() {\n\t\treturn this._edgeCount\n\t}\n\tedges() {\n\t\treturn Object.values(this._edgeObjs)\n\t}\n\tsetEdge(\n\t\tv: string,\n\t\tw: string,\n\t\tvalue: any = undefined,\n\t\tname: string | undefined = undefined,\n\t) {\n\t\tv = '' + v\n\t\tw = '' + w\n\n\t\tconst e = edgeArgsToId(this._isDirected, v, w, name)\n\t\tif (has(this._edgeLabels, e)) {\n\t\t\tif (value !== undefined) {\n\t\t\t\tthis._edgeLabels[e] = value\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\t// It didn't exist, so we need to create it.\n\t\t// First ensure the nodes exist.\n\t\tthis.setNode(v)\n\t\tthis.setNode(w)\n\n\t\tthis._edgeLabels[e] =\n\t\t\tvalue !== undefined ? value : this._defaultEdgeLabelFn(v, w, name)\n\n\t\tconst edgeObj = edgeArgsToObj(this._isDirected, v, w, name)\n\t\t// Ensure we add undirected edges in a consistent way.\n\t\tv = edgeObj.v\n\t\tw = edgeObj.w\n\n\t\tObject.freeze(edgeObj)\n\t\tthis._edgeObjs[e] = edgeObj\n\t\tincrementOrInitEntry(this._preds[w], v)\n\t\tincrementOrInitEntry(this._sucs[v], w)\n\t\tthis._in[w][e] = edgeObj\n\t\tthis._out[v][e] = edgeObj\n\t\tthis._edgeCount++\n\t\treturn this\n\t}\n\n\tedge(v, w, name) {\n\t\tconst e =\n\t\t\targuments.length === 1 ?\n\t\t\t\tedgeObjToId(this._isDirected, arguments[0])\n\t\t\t:\tedgeArgsToId(this._isDirected, v, w, name)\n\t\treturn this._edgeLabels[e]\n\t}\n\n\thasEdge(v, w, name) {\n\t\tconst e =\n\t\t\targuments.length === 1 ?\n\t\t\t\tedgeObjToId(this._isDirected, arguments[0])\n\t\t\t:\tedgeArgsToId(this._isDirected, v, w, name)\n\t\treturn has(this._edgeLabels, e)\n\t}\n\n\tremoveEdge(v, w, name) {\n\t\tconst e =\n\t\t\targuments.length === 1 ?\n\t\t\t\tedgeObjToId(this._isDirected, arguments[0])\n\t\t\t:\tedgeArgsToId(this._isDirected, v, w, name)\n\t\tconst edge = this._edgeObjs[e]\n\t\tif (edge) {\n\t\t\tv = edge.v\n\t\t\tw = edge.w\n\t\t\tdelete this._edgeLabels[e]\n\t\t\tdelete this._edgeObjs[e]\n\t\t\tdecrementOrRemoveEntry(this._preds[w], v)\n\t\t\tdecrementOrRemoveEntry(this._sucs[v], w)\n\t\t\tdelete this._in[w][e]\n\t\t\tdelete this._out[v][e]\n\t\t\tthis._edgeCount--\n\t\t}\n\t\treturn this\n\t}\n\n\toutEdges(v: string, w: string | undefined = undefined) {\n\t\tconst outV = this._out[v]\n\t\tif (outV) {\n\t\t\tconst edges: any = Object.values(outV)\n\t\t\tif (w === undefined) {\n\t\t\t\treturn edges\n\t\t\t}\n\t\t\treturn edges.filter(function (edge) {\n\t\t\t\treturn edge.w === w\n\t\t\t})\n\t\t}\n\t}\n}\n\n/** Cycles stuff **/\n\nfunction tarjan(graph) {\n\tlet index = 0\n\tconst stack: any[] = []\n\tconst visited = {} // node id -> { onStack, lowlink, index }\n\tconst results: any[] = []\n\n\tfunction dfs(v) {\n\t\tconst entry = (visited[v] = {\n\t\t\tonStack: true,\n\t\t\tlowlink: index,\n\t\t\tindex: index++,\n\t\t})\n\t\tstack.push(v)\n\n\t\tgraph.successors(v).forEach(function (w) {\n\t\t\tif (!Object.prototype.hasOwnProperty.call(visited, w)) {\n\t\t\t\tdfs(w)\n\t\t\t\tentry.lowlink = Math.min(entry.lowlink, visited[w].lowlink)\n\t\t\t} else if (visited[w].onStack) {\n\t\t\t\tentry.lowlink = Math.min(entry.lowlink, visited[w].index)\n\t\t\t}\n\t\t})\n\n\t\tif (entry.lowlink === entry.index) {\n\t\t\tconst cmpt: any[] = []\n\t\t\tlet w\n\t\t\tdo {\n\t\t\t\tw = stack.pop()\n\t\t\t\tvisited[w].onStack = false\n\t\t\t\tcmpt.push(w)\n\t\t\t} while (v !== w)\n\t\t\tresults.push(cmpt)\n\t\t}\n\t}\n\n\tgraph.nodes().forEach(function (v) {\n\t\tif (!Object.prototype.hasOwnProperty.call(visited, v)) {\n\t\t\tdfs(v)\n\t\t}\n\t})\n\n\treturn results\n}\n\nexport function findCycles(graph): string[][] {\n\treturn tarjan(graph).filter(function (cmpt) {\n\t\treturn (\n\t\t\tcmpt.length > 1 || (cmpt.length === 1 && graph.hasEdge(cmpt[0], cmpt[0]))\n\t\t)\n\t})\n}\n","import parsePublicodes from '../parsePublicodes'\nimport { findCycles, Graph } from './findCycles'\n\ntype GraphCycles = string[][]\n\nfunction buildDependenciesGraph(rulesDeps: Map<string, Set<string>>) {\n\tconst g = new Graph()\n\t;[...rulesDeps.entries()].forEach(([ruleDottedName, dependencies]) => {\n\t\tdependencies.forEach((depDottedName) => {\n\t\t\tg.setEdge(ruleDottedName, depDottedName)\n\t\t})\n\t})\n\treturn g\n}\n\ntype RawRules = Parameters<typeof parsePublicodes>[0]\n\nexport function cyclesInDependenciesGraph(rawRules: RawRules): GraphCycles {\n\tconst { referencesMaps } = parsePublicodes(rawRules)\n\tconst dependenciesGraph = buildDependenciesGraph(referencesMaps.referencesIn)\n\tconst cycles = findCycles(dependenciesGraph)\n\n\treturn cycles.map((c) => c.reverse())\n}\n\n/**\n * Make the cycle as small as possible.\n */\nexport function squashCycle(\n\trulesDependenciesObject: Map<string, Set<string>>,\n\tcycle: string[],\n): string[] {\n\tfunction* loopFrom(i: number) {\n\t\tlet j = i\n\t\twhile (true) {\n\t\t\tyield cycle[j++ % cycle.length]\n\t\t}\n\t}\n\tconst smallCycleStartingAt: string[][] = []\n\tfor (let i = 0; i < cycle.length; i++) {\n\t\tconst smallCycle: string[] = []\n\t\tlet previousVertex: string | undefined = undefined\n\t\tfor (const vertex of loopFrom(i)) {\n\t\t\tif (previousVertex === undefined) {\n\t\t\t\tsmallCycle.push(vertex)\n\t\t\t\tpreviousVertex = vertex\n\t\t\t} else if (rulesDependenciesObject.get(previousVertex)?.has(vertex)) {\n\t\t\t\tif (smallCycle.includes(vertex)) {\n\t\t\t\t\tsmallCycle.splice(0, smallCycle.lastIndexOf(vertex))\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tsmallCycle.push(vertex)\n\t\t\t\tpreviousVertex = vertex\n\t\t\t}\n\t\t}\n\t\tsmallCycleStartingAt.push(smallCycle)\n\t}\n\n\tconst smallest = smallCycleStartingAt.reduce((minCycle, someCycle) =>\n\t\tsomeCycle.length > minCycle.length ? minCycle : someCycle,\n\t)\n\treturn smallest\n}\n\n/**\n * This function is useful so as to print the dependencies at each node of the\n * cycle.\n * ⚠️  Indeed, the findCycles function returns the cycle found using the\n * Tarjan method, which is **not necessarily the smallest cycle**. However, the\n * smallest cycle is more readable.\n */\nexport function cyclicDependencies(\n\trawRules: RawRules,\n): [GraphCycles, string[]] {\n\tconst { referencesMaps } = parsePublicodes(rawRules)\n\tconst dependenciesGraph = buildDependenciesGraph(referencesMaps.referencesIn)\n\tconst cycles = findCycles(dependenciesGraph)\n\n\tconst reversedCycles = cycles.map((c) => c.reverse())\n\n\tconst smallCycles = reversedCycles.map((cycle) =>\n\t\tsquashCycle(referencesMaps.referencesIn, cycle),\n\t)\n\n\tconst printableStronglyConnectedComponents = reversedCycles.map((c, i) =>\n\t\tprintInDotFormat(dependenciesGraph, c, smallCycles[i]),\n\t)\n\n\treturn [smallCycles, printableStronglyConnectedComponents]\n}\n\n/**\n * Is edge in the cycle, in the same order?\n */\nconst edgeIsInCycle = (cycle: string[], v: string, w: string): boolean => {\n\tfor (let i = 0; i < cycle.length + 1; i++) {\n\t\tif (v === cycle[i] && w === cycle[(i + 1) % cycle.length]) return true\n\t}\n\treturn false\n}\n\nexport function printInDotFormat(\n\tdependenciesGraph: Graph,\n\tcycle: string[],\n\tsubCycleToHighlight: string[],\n) {\n\tconst edgesSet = new Set()\n\tcycle.forEach((vertex) => {\n\t\tdependenciesGraph\n\t\t\t.outEdges(vertex)\n\t\t\t.filter(({ w }) => cycle.includes(w))\n\t\t\t.forEach(({ v, w }) => {\n\t\t\t\tedgesSet.add(\n\t\t\t\t\t`\"${v}\" -> \"${w}\"` +\n\t\t\t\t\t\t(edgeIsInCycle(subCycleToHighlight, v, w) ? ' [color=red]' : ''),\n\t\t\t\t)\n\t\t\t})\n\t})\n\treturn `digraph Cycle {\\n\\t${[...edgesSet].join(';\\n\\t')};\\n}`\n}\n","import Engine from '.'\nimport { ASTNode, EvaluatedNode, MissingVariables } from './AST/types'\nimport { PublicodesError } from './error'\nimport { registerEvaluationFunction } from './evaluationFunctions'\nimport { defaultNode, mergeMissing, undefinedNode } from './evaluationUtils'\nimport { capitalise0 } from './format'\nimport parse, { mecanismKeys } from './parse'\nimport { Context, RawRule } from './parsePublicodes'\nimport {\n\tReplacementRule,\n\tparseRendNonApplicable,\n\tparseReplacements,\n} from './replacement'\nimport { isAccessible, nameLeaf, ruleParents } from './ruleUtils'\nimport { weakCopyObj } from './utils'\n\nexport type Rule = {\n\tformule?: Record<string, unknown> | string\n\tvaleur?: Record<string, unknown> | string\n\tquestion?: string\n\tdescription?: string\n\tunité?: string\n\tacronyme?: string\n\texemples?: any\n\trésumé?: string\n\ticônes?: string\n\ttitre?: string\n\tsévérité?: string\n\ttype?: string\n\texperimental?: 'oui'\n\t'possiblement non applicable'?: 'oui'\n\tprivé?: 'oui'\n\tnote?: string\n\tremplace?: Remplace | Array<Remplace>\n\t'rend non applicable'?: Remplace | Array<Remplace>\n\tsuggestions?: Record<string, string | number | Record<string, unknown>>\n\tréférences?: { [source: string]: string }\n\tAPI?: string\n\t'identifiant court'?: string\n} & Record<string, unknown>\n\ntype Remplace =\n\t| {\n\t\t\t'références à': string\n\t\t\tdans?: Array<string> | string\n\t\t\t'sauf dans'?: Array<string> | string\n\t\t\tpriorité?: number\n\t\t\t// eslint-disable-next-line no-mixed-spaces-and-tabs\n\t  }\n\t| string\n\nexport type RuleNode<Name extends string = string> = {\n\tdottedName: Name\n\ttitle: string\n\tnodeKind: 'rule'\n\tvirtualRule: boolean\n\tprivate: boolean\n\trawNode: Rule\n\treplacements: Array<ReplacementRule>\n\texplanation: {\n\t\tvaleur: ASTNode\n\t\tparents: Array<ASTNode>\n\t\tnullableParent?: ASTNode\n\t\truleDisabledByItsParent: boolean\n\t}\n\tsuggestions: Record<string, ASTNode>\n\t'identifiant court'?: string\n}\n\nfunction parseRule(nom: string, rawRule: Rule, context: Context): RuleNode {\n\tconst privateRule = rawRule.privé === 'oui' || nom.startsWith('[privé] ')\n\tnom = nom.replace(/^\\[privé\\] /, '')\n\tconst dottedName = [context.dottedName, nom].filter(Boolean).join(' . ')\n\n\tconst name = nameLeaf(dottedName)\n\tconst title = capitalise0(rawRule['titre'] ?? name)\n\n\tif (context.parsedRules[dottedName]) {\n\t\tthrow new PublicodesError(\n\t\t\t'EvaluationError',\n\t\t\t`La référence '${dottedName}' a déjà été définie`,\n\t\t\t{ dottedName },\n\t\t)\n\t}\n\n\tconst ruleValue: Record<string, unknown> = {}\n\n\tfor (const key in rawRule) {\n\t\tif (mecanismKeys.includes(key)) {\n\t\t\truleValue[key] = rawRule[key]\n\t\t}\n\t}\n\tif ('formule' in rawRule) {\n\t\truleValue.valeur = rawRule.formule\n\t}\n\tif (!privateRule && !dottedName.endsWith('$SITUATION')) {\n\t\t// We create a $SITUATION child rule for each rule that is not private\n\t\t// This value will be used to evaluate the rule in the current situation (`setSituation`)\n\t\truleValue['dans la situation'] = `${dottedName} . $SITUATION`\n\t\truleValue['avec'] =\n\t\t\tweakCopyObj(ruleValue['avec'] as Record<string, unknown>) ?? {}\n\t\tconst situationValue = weakCopyObj(undefinedNode)\n\t\tsituationValue.isNullable = rawRule['possiblement non applicable'] === 'oui'\n\t\t;(ruleValue['avec'] as Record<string, any>)['[privé] $SITUATION'] = {\n\t\t\tvaleur: situationValue,\n\t\t}\n\n\t\t// If the `par défaut` value is used, then the rule should be listed as a missingVariables\n\t\tif (ruleValue['par défaut'] != null) {\n\t\t\truleValue['par défaut'] = {\n\t\t\t\tvaleur: ruleValue['par défaut'],\n\t\t\t\t'variable manquante': dottedName,\n\t\t\t}\n\t\t}\n\t}\n\n\t// const ruleContext = weakCopyObj(context)\n\t// ruleContext.dottedName = dottedName\n\t// const ruleContext = { ...context, dottedName }\n\tconst currentDottedNameContext = context.dottedName\n\tcontext.dottedName = dottedName\n\n\t// The following ensures that nested rules appears after the root rule when\n\t// iterating over parsedRule\n\tcontext.parsedRules[dottedName] = undefined as any\n\n\tconst explanation = {\n\t\tvaleur: parse(ruleValue, context),\n\t\t// We include a list of references to the parents to implement the branch\n\t\t// desactivation feature. When evaluating a rule we only need to know the\n\t\t// first nullable parent, but this is something that we can't determine at\n\t\t// this stage :\n\t\t// - we need to run remplacements (which works on references in the ASTs\n\t\t//   which is why we insert these “virtual” references)\n\t\t// - we need to infer unit of the rules\n\t\t//\n\t\t// An alternative implementation would be possible that would colocate the\n\t\t// code related to branch desactivation (ie find the first nullable parent\n\t\t// statically after rules parsing)\n\t\tparents: ruleParents(dottedName).map(\n\t\t\t(parent) =>\n\t\t\t\t({\n\t\t\t\t\tdottedName: parent,\n\t\t\t\t\tnodeKind: 'reference',\n\t\t\t\t\tcontextDottedName: context.dottedName,\n\t\t\t\t}) as ASTNode<'reference'>,\n\t\t),\n\t}\n\n\tconst suggestions = {} as Record<string, ASTNode>\n\tif (rawRule.suggestions) {\n\t\tfor (const name in rawRule.suggestions) {\n\t\t\tsuggestions[name] = parse(rawRule.suggestions[name], context)\n\t\t}\n\t}\n\n\tcontext.parsedRules[dottedName] = {\n\t\tdottedName,\n\t\treplacements: [\n\t\t\t...parseRendNonApplicable(rawRule['rend non applicable'], context),\n\t\t\t...parseReplacements(rawRule.remplace, context),\n\t\t],\n\t\ttitle: title,\n\t\tprivate: privateRule,\n\t\tsuggestions,\n\t\tnodeKind: 'rule',\n\t\texplanation,\n\t\trawNode: rawRule,\n\t\tvirtualRule: privateRule,\n\t} as RuleNode\n\tcontext.dottedName = currentDottedNameContext\n\treturn context.parsedRules[dottedName]\n}\n\nexport function parseRules(\n\trules: Partial<Record<string, RawRule>>,\n\tcontext: Context,\n) {\n\tfor (const dottedName in rules) {\n\t\tlet rule = rules[dottedName]\n\n\t\tif (typeof rule === 'string' || typeof rule === 'number') {\n\t\t\trule = { valeur: `${rule}` }\n\t\t}\n\t\tif (typeof rule !== 'object') {\n\t\t\tthrow new PublicodesError(\n\t\t\t\t'SyntaxError',\n\t\t\t\t`Rule ${dottedName} is incorrectly written. Please give it a proper value.`,\n\t\t\t\t{ dottedName },\n\t\t\t)\n\t\t}\n\t\tconst copy = rule === null ? {} : weakCopyObj(rule)\n\t\tparseRule(dottedName, copy, context)\n\t}\n}\n\nregisterEvaluationFunction('rule', function evaluate(node) {\n\tconst { ruleDisabledByItsParent, nullableParent, parentMissingVariables } =\n\t\tevaluateDisablingParent(this, node)\n\n\tlet valeurEvaluation: EvaluatedNode = {\n\t\t...node.explanation.valeur,\n\t\tnodeValue: null,\n\t\tmissingVariables: {},\n\t}\n\tif (!ruleDisabledByItsParent) {\n\t\tif (\n\t\t\tthis.cache._meta.evaluationRuleStack.filter(\n\t\t\t\t(dottedName) => dottedName === node.dottedName,\n\t\t\t).length > 1\n\t\t) {\n\t\t\t//  TODO : remettre ce warning. Je ne sais pas pourquoi, mais la base de règle de mon-entreprise lève un warning sur quasiment toutes les cotisations\n\t\t\t// \t\t\twarning(\n\t\t\t// \t\t\t\tthis.context.logger,\n\t\t\t// \t\t\t\t`Un cycle a été détecté lors de l'évaluation de cette règle.\n\n\t\t\t// Par défaut cette règle sera évaluée à 'null'.\n\t\t\t// Pour indiquer au moteur de résoudre la référence circulaire en trouvant le point fixe\n\t\t\t// de la fonction, il vous suffit d'ajouter l'attribut suivant niveau de la règle :\n\n\t\t\t// \t${node.dottedName}:\n\t\t\t// \t\trésoudre la référence circulaire: oui\"\n\t\t\t// \t\t...\n\t\t\t// `,\n\t\t\t// \t\t\t\t{ dottedName: node.dottedName }\n\t\t\t// \t\t\t)\n\n\t\t\tvaleurEvaluation = {\n\t\t\t\tnodeValue: undefined,\n\t\t\t} as EvaluatedNode\n\t\t} else {\n\t\t\tthis.cache._meta.evaluationRuleStack.unshift(node.dottedName)\n\t\t\tvaleurEvaluation = this.evaluateNode(node.explanation.valeur)\n\t\t\tthis.cache._meta.evaluationRuleStack.shift()\n\t\t}\n\t}\n\tvaleurEvaluation.missingVariables ??= {}\n\tupdateRuleMissingVariables(this, node, valeurEvaluation)\n\tconst evaluation = {\n\t\t...valeurEvaluation,\n\t\tmissingVariables: mergeMissing(\n\t\t\tvaleurEvaluation.missingVariables,\n\t\t\tparentMissingVariables,\n\t\t),\n\t\t...node,\n\t\texplanation: {\n\t\t\tparents: node.explanation.parents,\n\t\t\tvaleur: valeurEvaluation,\n\t\t\tnullableParent,\n\t\t\truleDisabledByItsParent,\n\t\t},\n\t}\n\n\treturn evaluation\n})\n\n/*\n\tWe implement the terminal case for missing variables manually here as\n\ta rule is missing if it is undefined and has no other missing dependencies\n*/\nfunction updateRuleMissingVariables(\n\tengine: Engine,\n\tnode: RuleNode,\n\tvaleurEvaluation: EvaluatedNode,\n): void {\n\tif (\n\t\tnode.private === true ||\n\t\t!isAccessible(engine.context.parsedRules, '', node.dottedName)\n\t) {\n\t\treturn\n\t}\n\n\tif (\n\t\tvaleurEvaluation.nodeValue === undefined &&\n\t\t!Object.keys(valeurEvaluation.missingVariables).length\n\t) {\n\t\tvaleurEvaluation.missingVariables[node.dottedName] = 1\n\t}\n\n\treturn\n}\n\nexport function evaluateDisablingParent(\n\tengine: Engine,\n\tnode: RuleNode,\n): {\n\truleDisabledByItsParent: boolean\n\tparentMissingVariables: MissingVariables\n\tnullableParent?: ASTNode\n} {\n\tif (node.private) {\n\t\t// We do not need to check if a private rule is disabled by its parent :\n\t\t// they are accessible only from its sibling or parent\n\t\t// (which would already be disabled)\n\t\treturn { ruleDisabledByItsParent: false, parentMissingVariables: {} }\n\t}\n\n\tconst nodesTypes = engine.context.nodesTypes\n\tconst nullableParent = node.explanation.parents.find(\n\t\t(ref) =>\n\t\t\tnodesTypes.get(ref)?.isNullable ||\n\t\t\tnodesTypes.get(ref)?.type === 'boolean',\n\t)\n\n\tif (!nullableParent) {\n\t\treturn { ruleDisabledByItsParent: false, parentMissingVariables: {} }\n\t}\n\n\tif (\n\t\t// TODO: remove this condition and the associated \"parentRuleStack\", cycles\n\t\t// should be detected and avoided at parse time.\n\t\t!engine.cache._meta.parentRuleStack.includes(node.dottedName)\n\t) {\n\t\tengine.cache._meta.parentRuleStack.unshift(node.dottedName)\n\t\tlet parentIsNotApplicable = defaultNode(false) as EvaluatedNode\n\t\tif (nodesTypes.get(nullableParent)?.isNullable) {\n\t\t\tparentIsNotApplicable = engine.evaluateNode({\n\t\t\t\tnodeKind: 'est non applicable',\n\t\t\t\texplanation: nullableParent,\n\t\t\t})\n\t\t}\n\t\tif (\n\t\t\tparentIsNotApplicable.nodeValue !== true &&\n\t\t\tnodesTypes.get(nullableParent)?.type === 'boolean'\n\t\t) {\n\t\t\tparentIsNotApplicable = engine.evaluateNode({\n\t\t\t\tnodeKind: 'operation',\n\t\t\t\toperator: '=',\n\t\t\t\toperationKind: '=',\n\t\t\t\texplanation: [nullableParent, defaultNode(false)],\n\t\t\t})\n\t\t}\n\n\t\tengine.cache._meta.parentRuleStack.shift()\n\t\tif (parentIsNotApplicable.nodeValue === true) {\n\t\t\treturn {\n\t\t\t\truleDisabledByItsParent: true,\n\t\t\t\tparentMissingVariables: parentIsNotApplicable.missingVariables ?? {},\n\t\t\t\tnullableParent,\n\t\t\t}\n\t\t}\n\t}\n\n\tlet parentMissingVariables: MissingVariables = {}\n\n\tif (nodesTypes.get(nullableParent)?.type === 'boolean') {\n\t\tconst parentEvaluation = engine.evaluateNode(nullableParent)\n\t\tparentMissingVariables = parentEvaluation.missingVariables ?? {}\n\t\treturn {\n\t\t\truleDisabledByItsParent: parentEvaluation.nodeValue === false,\n\t\t\tparentMissingVariables,\n\t\t\tnullableParent,\n\t\t}\n\t}\n\n\treturn {\n\t\truleDisabledByItsParent: false,\n\t\tparentMissingVariables,\n\t\tnullableParent,\n\t}\n}\n","import parse from '../parse'\nimport { Context } from '../parsePublicodes'\nimport { parseRules } from '../rule'\n\nexport default function parseAvec(v, context: Context) {\n\tparseRules(v.avec, context)\n\tconst valeur = parse(v.valeur, context)\n\treturn valeur\n}\n\nparseAvec.nom = 'avec' as const\n","import Engine from '..'\nimport { ASTNode, Evaluation } from '../AST/types'\nimport { PublicodesError, warning } from '../error'\nimport { mergeAllMissing } from '../evaluationUtils'\nimport parse from '../parse'\nimport { convertUnit, inferUnit } from '../units'\n\ntype TrancheNode = { taux: ASTNode } | { montant: ASTNode }\nexport type TrancheNodes = Array<\n\tTrancheNode & { plafond?: ASTNode; isActive?: boolean }\n>\n\nexport const parseTranches = (tranches, context): TrancheNodes => {\n\treturn tranches.map((node, i) => {\n\t\tif (!node.plafond && i > tranches.length) {\n\t\t\tthrow new PublicodesError(\n\t\t\t\t'SyntaxError',\n\t\t\t\t`La tranche n°${i} du barème n'a pas de plafond précisé. Seule la dernière tranche peut ne pas être plafonnée`,\n\t\t\t\t{ dottedName: '' },\n\t\t\t)\n\t\t}\n\t\treturn {\n\t\t\t...node,\n\t\t\t...(node.taux !== undefined ? { taux: parse(node.taux, context) } : {}),\n\t\t\t...(node.montant !== undefined ?\n\t\t\t\t{ montant: parse(node.montant, context) }\n\t\t\t:\t{}),\n\t\t\tplafond:\n\t\t\t\t'plafond' in node ?\n\t\t\t\t\tparse(node.plafond, context)\n\t\t\t\t:\t{\n\t\t\t\t\t\tnodeValue: Infinity,\n\t\t\t\t\t\tnodeKind: 'constant',\n\t\t\t\t\t\ttype: 'number',\n\t\t\t\t\t\tisNullable: false,\n\t\t\t\t\t},\n\t\t}\n\t})\n}\n\nexport function evaluatePlafondUntilActiveTranche(\n\tthis: Engine,\n\t{ multiplicateur, assiette, parsedTranches },\n) {\n\treturn parsedTranches.reduce(\n\t\t([tranches, activeTrancheFound], parsedTranche, i: number) => {\n\t\t\tif (activeTrancheFound) {\n\t\t\t\treturn [\n\t\t\t\t\t[...tranches, { ...parsedTranche, isAfterActive: true }],\n\t\t\t\t\tactiveTrancheFound,\n\t\t\t\t]\n\t\t\t}\n\n\t\t\tconst plafond = this.evaluateNode(parsedTranche.plafond)\n\t\t\tconst plancher =\n\t\t\t\ttranches[i - 1] ? tranches[i - 1].plafond : { nodeValue: 0 }\n\n\t\t\tlet plafondValue: Evaluation<number> =\n\t\t\t\t(\n\t\t\t\t\tplafond.nodeValue === undefined ||\n\t\t\t\t\tmultiplicateur.nodeValue === undefined\n\t\t\t\t) ?\n\t\t\t\t\tundefined\n\t\t\t\t:\tplafond.nodeValue * multiplicateur.nodeValue\n\n\t\t\ttry {\n\t\t\t\tplafondValue =\n\t\t\t\t\tplafondValue === Infinity || plafondValue === 0 ?\n\t\t\t\t\t\tplafondValue\n\t\t\t\t\t:\tconvertUnit(\n\t\t\t\t\t\t\tinferUnit('*', [plafond.unit, multiplicateur.unit]),\n\t\t\t\t\t\t\tassiette.unit,\n\t\t\t\t\t\t\tplafondValue,\n\t\t\t\t\t\t)\n\t\t\t} catch (e) {\n\t\t\t\twarning(\n\t\t\t\t\tthis.context.logger,\n\t\t\t\t\t`L'unité du plafond de la tranche n°${\n\t\t\t\t\t\ti + 1\n\t\t\t\t\t}  n'est pas compatible avec celle l'assiette`,\n\t\t\t\t\t{ dottedName: this.cache._meta.evaluationRuleStack[0] },\n\t\t\t\t\te,\n\t\t\t\t)\n\t\t\t}\n\t\t\tconst plancherValue = tranches[i - 1] ? tranches[i - 1].plafondValue : 0\n\t\t\tconst isAfterActive =\n\t\t\t\tplancherValue === undefined || assiette.nodeValue === undefined ?\n\t\t\t\t\tundefined\n\t\t\t\t:\tplancherValue > assiette.nodeValue\n\n\t\t\tconst calculationValues = [plafond, assiette, multiplicateur, plancher]\n\t\t\tif (calculationValues.some((node) => node.nodeValue === undefined)) {\n\t\t\t\treturn [\n\t\t\t\t\t[\n\t\t\t\t\t\t...tranches,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t...parsedTranche,\n\t\t\t\t\t\t\tplafond,\n\t\t\t\t\t\t\tplafondValue,\n\t\t\t\t\t\t\tplancherValue,\n\t\t\t\t\t\t\tnodeValue: undefined,\n\t\t\t\t\t\t\tisActive: undefined,\n\t\t\t\t\t\t\tisAfterActive,\n\t\t\t\t\t\t\tmissingVariables: mergeAllMissing(calculationValues),\n\t\t\t\t\t\t},\n\t\t\t\t\t],\n\t\t\t\t\tfalse,\n\t\t\t\t]\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t!!tranches[i - 1] &&\n\t\t\t\t!!plancherValue &&\n\t\t\t\t(plafondValue as number) <= plancherValue\n\t\t\t) {\n\t\t\t\tthrow new PublicodesError(\n\t\t\t\t\t'EvaluationError',\n\t\t\t\t\t`Le plafond de la tranche n°${\n\t\t\t\t\t\ti + 1\n\t\t\t\t\t} a une valeur inférieure à celui de la tranche précédente`,\n\t\t\t\t\t{ dottedName: this.cache._meta.evaluationRuleStack[0] },\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tconst tranche = {\n\t\t\t\t...parsedTranche,\n\t\t\t\tplafond,\n\t\t\t\tplancherValue,\n\t\t\t\tplafondValue,\n\t\t\t\tisAfterActive,\n\t\t\t\tisActive:\n\t\t\t\t\tassiette.nodeValue >= plancherValue &&\n\t\t\t\t\tassiette.nodeValue < (plafondValue as number),\n\t\t\t}\n\n\t\t\treturn [[...tranches, tranche], tranche.isActive]\n\t\t},\n\t\t[[], false],\n\t)[0]\n}\n","import { EvaluationFunction, PublicodesError } from '..'\nimport { ASTNode, EvaluatedNode, NodeKind } from '../AST/types'\nimport { registerEvaluationFunction } from '../evaluationFunctions'\nimport { defaultNode, mergeAllMissing } from '../evaluationUtils'\nimport parse from '../parse'\nimport { convertUnit, parseUnit } from '../units'\nimport {\n\tTrancheNodes,\n\tevaluatePlafondUntilActiveTranche,\n\tparseTranches,\n} from './trancheUtils'\n\n// Barème en taux marginaux.\nexport type BarèmeNode = {\n\texplanation: {\n\t\ttranches: TrancheNodes\n\t\tmultiplicateur: ASTNode\n\t\tassiette: ASTNode\n\t}\n\tnodeKind: 'barème'\n}\nexport default function parseBarème(v, context): BarèmeNode {\n\tconst explanation = {\n\t\tassiette: parse(v.assiette, context),\n\t\tmultiplicateur:\n\t\t\tv.multiplicateur ? parse(v.multiplicateur, context) : defaultNode(1),\n\t\ttranches: parseTranches(v.tranches, context),\n\t}\n\treturn {\n\t\texplanation,\n\t\tnodeKind: 'barème',\n\t}\n}\n\nfunction evaluateBarème(tranches, assiette, evaluate) {\n\treturn tranches.map((tranche) => {\n\t\tif (tranche.isAfterActive) {\n\t\t\treturn { ...tranche, nodeValue: 0 }\n\t\t}\n\t\tconst taux = evaluate(tranche.taux)\n\t\tconst missingVariables = mergeAllMissing([taux, tranche])\n\n\t\tif (\n\t\t\t[\n\t\t\t\tassiette.nodeValue,\n\t\t\t\ttaux.nodeValue,\n\t\t\t\ttranche.plafondValue,\n\t\t\t\ttranche.plancherValue,\n\t\t\t].some((value) => value === undefined)\n\t\t) {\n\t\t\treturn {\n\t\t\t\t...tranche,\n\t\t\t\ttaux,\n\t\t\t\tnodeValue: undefined,\n\t\t\t\tmissingVariables,\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\t...tranche,\n\t\t\ttaux,\n\t\t\t...('unit' in assiette && { unit: assiette.unit }),\n\t\t\tnodeValue:\n\t\t\t\t(Math.min(assiette.nodeValue, tranche.plafondValue) -\n\t\t\t\t\ttranche.plancherValue) *\n\t\t\t\tconvertUnit(taux.unit, parseUnit(''), taux.nodeValue as number),\n\t\t\tmissingVariables,\n\t\t}\n\t})\n}\nconst evaluate: EvaluationFunction<'barème'> = function (node) {\n\tconst evaluate = this.evaluateNode.bind(this)\n\tconst assiette = this.evaluateNode(\n\t\tnode.explanation.assiette,\n\t) as EvaluatedNode<NodeKind, number>\n\tconst multiplicateur = this.evaluateNode(node.explanation.multiplicateur)\n\n\tif (multiplicateur.nodeValue === 0) {\n\t\tthrow new PublicodesError(\n\t\t\t'EvaluationError',\n\t\t\t`Le multiplicateur ne peut pas être nul`,\n\t\t\t{ dottedName: this.cache._meta.evaluationRuleStack[0] },\n\t\t)\n\t}\n\n\tlet tranches: any = node.explanation.tranches\n\tlet nodeValue = assiette.nodeValue\n\n\tif (![0, undefined, null].includes(assiette.nodeValue)) {\n\t\ttranches = evaluateBarème(\n\t\t\tevaluatePlafondUntilActiveTranche.call(this, {\n\t\t\t\tparsedTranches: node.explanation.tranches,\n\t\t\t\tassiette,\n\t\t\t\tmultiplicateur,\n\t\t\t}),\n\t\t\tassiette,\n\t\t\tevaluate,\n\t\t)\n\t\tnodeValue = tranches.reduce(\n\t\t\t(value, { nodeValue }) =>\n\t\t\t\tnodeValue == undefined ? undefined : value + nodeValue,\n\t\t\t0,\n\t\t)\n\t}\n\n\treturn {\n\t\t...node,\n\t\tnodeValue,\n\t\tmissingVariables: mergeAllMissing([assiette, multiplicateur, ...tranches]),\n\t\texplanation: {\n\t\t\tassiette,\n\t\t\tmultiplicateur,\n\t\t\ttranches,\n\t\t},\n\t\tunit: assiette.unit,\n\t} as any\n}\n\nregisterEvaluationFunction('barème', evaluate)\n","import { EvaluationFunction } from '..'\nimport { ASTNode } from '../AST/types'\nimport { PublicodesError } from '../error'\nimport { registerEvaluationFunction } from '../evaluationFunctions'\nimport { bonus, mergeAllMissing, mergeMissing } from '../evaluationUtils'\nimport parse from '../parse'\n\nexport type ConditionNode = {\n\texplanation: {\n\t\tsi: ASTNode\n\t\talors: ASTNode\n\t\tsinon: ASTNode\n\t}\n\tnodeKind: 'condition'\n}\n\nconst evaluate: EvaluationFunction<'condition'> = function (node) {\n\tlet evaluation\n\tconst condition = this.evaluateNode(node.explanation.si)\n\tlet alors = node.explanation.alors\n\tlet sinon = node.explanation.sinon\n\tif ('unit' in condition) {\n\t\tthrow new PublicodesError(\n\t\t\t'EvaluationError',\n\t\t\t'La condition doit être de type booléen',\n\t\t\t{ dottedName: this.cache._meta.evaluationRuleStack[0] },\n\t\t)\n\t}\n\tif (condition.nodeValue === true) {\n\t\talors = this.evaluateNode(node.explanation.alors)\n\t\t;(alors as any).isActive = true\n\t\tevaluation = alors\n\t} else if (condition.nodeValue === false) {\n\t\tsinon = this.evaluateNode(node.explanation.sinon)\n\t\tevaluation = sinon\n\t} else if (condition.nodeValue === null) {\n\t\tevaluation = condition\n\t} else if (condition.nodeValue === undefined) {\n\t\tsinon = this.evaluateNode(node.explanation.sinon)\n\t\talors = this.evaluateNode(node.explanation.alors)\n\t\tevaluation = {\n\t\t\t...condition,\n\t\t\tmissingVariables: mergeAllMissing([sinon, alors]),\n\t\t}\n\t} else {\n\t\tthrow new PublicodesError(\n\t\t\t'EvaluationError',\n\t\t\t'La condition doit être de type booléen',\n\t\t\t{ dottedName: this.cache._meta.evaluationRuleStack[0] },\n\t\t)\n\t}\n\tconst unit = evaluation.unit ?? (alors as any).unit\n\treturn {\n\t\tnodeValue: evaluation.nodeValue,\n\t\tmissingVariables: mergeMissing(\n\t\t\tbonus(condition.missingVariables),\n\t\t\tevaluation.missingVariables,\n\t\t),\n\t\t...(unit != undefined ? { unit } : {}),\n\t\t...node,\n\t\texplanation: { si: condition, alors, sinon },\n\t}\n}\nexport default function parseCondition(v, context) {\n\tconst explanation = {\n\t\tsi: parse(v.si, context),\n\t\talors: parse(v.alors, context),\n\t\tsinon: parse(v.sinon, context),\n\t}\n\treturn {\n\t\texplanation,\n\t\tnodeKind: 'condition',\n\t} as ConditionNode\n}\n\nparseCondition.nom = 'condition'\n\nregisterEvaluationFunction('condition', evaluate)\n","import { EvaluationFunction, PublicodesError } from '..'\nimport { ASTNode } from '../AST/types'\nimport { registerEvaluationFunction } from '../evaluationFunctions'\nimport { notApplicableNode } from '../evaluationUtils'\nimport parse from '../parse'\nimport { ReferenceNode } from '../reference'\nimport { serializeUnit } from '../units'\n\nexport type ContextNode = {\n\texplanation: {\n\t\tvaleur: ASTNode\n\t\tcontexte: Array<[ReferenceNode, ASTNode]>\n\t\tsubEngineId: number\n\t}\n\tnodeKind: 'contexte'\n}\n\nexport default function parseMecanismContexte(v, context) {\n\tconst contexte = Object.keys(v.contexte).map((dottedName) => [\n\t\tparse(dottedName, context),\n\t\tparse(v.contexte[dottedName], context),\n\t])\n\n\tconst node = parse(v.valeur, context)\n\n\treturn {\n\t\texplanation: {\n\t\t\tvaleur: node,\n\t\t\tcontexte,\n\t\t\tsubEngineId: context.subEngineIncrementingNumber++,\n\t\t},\n\t\tnodeKind: parseMecanismContexte.nom,\n\t} as ContextNode\n}\nparseMecanismContexte.nom = 'contexte' as const\n\nconst evaluateContexte: EvaluationFunction<'contexte'> = function (node) {\n\tconst amendedSituation = Object.fromEntries(\n\t\tnode.explanation.contexte\n\t\t\t.filter(([originRule, replacement]) => {\n\t\t\t\tconst originRuleEvaluation = this.evaluateNode(originRule)\n\t\t\t\tconst replacementEvaluation = this.evaluateNode(replacement)\n\t\t\t\treturn (\n\t\t\t\t\toriginRuleEvaluation.nodeValue !== replacementEvaluation.nodeValue ||\n\t\t\t\t\tserializeUnit(originRuleEvaluation.unit) !==\n\t\t\t\t\t\tserializeUnit(replacementEvaluation.unit)\n\t\t\t\t)\n\t\t\t})\n\t\t\t.map(\n\t\t\t\t([originRule, replacement]) =>\n\t\t\t\t\t[originRule.dottedName, replacement] as [string, ASTNode],\n\t\t\t),\n\t)\n\tif (\n\t\tthis.cache._meta.currentContexteSituation ===\n\t\tJSON.stringify(amendedSituation)\n\t) {\n\t\t// If the situation is the same as the last time we evaluated the contexte, it means that\n\t\t// there is a loop\n\t\treturn {\n\t\t\t...notApplicableNode,\n\t\t\t...node,\n\t\t}\n\t}\n\n\tconst engine = this.shallowCopy()\n\tengine.subEngineId = node.explanation.subEngineId\n\tthis.subEngines[node.explanation.subEngineId] = engine\n\tif (Object.keys(amendedSituation).length) {\n\t\tengine.setSituation(amendedSituation, {\n\t\t\tkeepPreviousSituation: true,\n\t\t})\n\n\t\t// The following code ensure that we use the **origin context** evaluation\n\t\t// for the values in the ammended situation\n\n\t\t// We do so by altering the cache so that the situation rule seems to have already\n\t\t// been evaluated\n\n\t\t// This is not an elegant way of doing so, but its temporary.\n\t\t// The correct implementation is discussed in :\n\t\t// https://github.com/publicodes/publicodes/discussions/92\n\t\tObject.entries(amendedSituation).forEach(([originDottedName, value]) => {\n\t\t\tconst evaluation = this.cache.nodes.get(value)\n\t\t\tif (!evaluation) {\n\t\t\t\tthrow new PublicodesError(\n\t\t\t\t\t'InternalError',\n\t\t\t\t\t'The situation should have already been evaluated',\n\t\t\t\t\t{\n\t\t\t\t\t\tdottedName: this.context.dottedName,\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t}\n\t\t\tconst originRule =\n\t\t\t\tengine.context.parsedRules[originDottedName + ' . $SITUATION']\n\t\t\tif (!originRule?.explanation.valeur) {\n\t\t\t\tthrow new PublicodesError(\n\t\t\t\t\t'InternalError',\n\t\t\t\t\t'The origin rule should be defined',\n\t\t\t\t\t{\n\t\t\t\t\t\tdottedName: this.context.dottedName,\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t}\n\t\t\tengine.cache.nodes.set(originRule.explanation.valeur, evaluation)\n\t\t})\n\t}\n\n\tengine.cache._meta.currentContexteSituation = JSON.stringify(amendedSituation)\n\tconst evaluatedNode = engine.evaluateNode(node.explanation.valeur)\n\n\treturn {\n\t\t...node,\n\t\tnodeValue: evaluatedNode.nodeValue,\n\t\texplanation: {\n\t\t\t...node.explanation,\n\t\t\tvaleur: evaluatedNode,\n\t\t},\n\t\tmissingVariables: evaluatedNode.missingVariables,\n\t\t...('unit' in evaluatedNode && { unit: evaluatedNode.unit }),\n\t}\n}\n\nregisterEvaluationFunction('contexte', evaluateContexte)\n","import { PublicodesError } from './error'\n\nexport function normalizeDateString(dateString: string): string {\n\tlet [day, month, year] = dateString.split('/')\n\tif (!year) {\n\t\t;[day, month, year] = ['01', day, month]\n\t}\n\treturn normalizeDate(+year, +month, +day)\n}\n\nconst pad = (n: number): string => (+n < 10 ? `0${n}` : '' + n)\nexport function normalizeDate(\n\tyear: number,\n\tmonth: number,\n\tday: number,\n): string {\n\tconst date = new Date(+year, +month - 1, +day)\n\tif (!+date || date.getDate() !== +day) {\n\t\tthrow new PublicodesError(\n\t\t\t'SyntaxError',\n\t\t\t`La date ${day}/${month}/${year} n'est pas valide`,\n\t\t\t{ dottedName: '' },\n\t\t)\n\t}\n\treturn `${pad(day)}/${pad(month)}/${pad(year)}`\n}\n\nexport function convertToDate(value: string): Date {\n\tconst [day, month, year] = normalizeDateString(value).split('/')\n\tconst result = new Date(+year, +month - 1, +day)\n\t// Reset date to utc midnight for exact calculation of day difference (no\n\t// daylight saving effect)\n\tresult.setMinutes(result.getMinutes() - result.getTimezoneOffset())\n\treturn result\n}\n\nexport function convertToString(date: Date): string {\n\treturn normalizeDate(date.getFullYear(), date.getMonth() + 1, date.getDate())\n}\n\nexport function getRelativeDate(date: string, dayDifferential: number): string {\n\tconst relativeDate = new Date(convertToDate(date))\n\trelativeDate.setDate(relativeDate.getDate() + dayDifferential)\n\treturn convertToString(relativeDate)\n}\n\nexport function getYear(date: string): number {\n\treturn +date.slice(-4)\n}\n\nexport function getTrimestreCivil(date: string) {\n\tconst [, month, year] = date.split('/')\n\tconst trimester = Math.floor((Number.parseInt(month, 10) - 1) / 3)\n\tconst startingMonth = 3 * trimester + 1\n\treturn `01/${startingMonth.toString().padStart(2, '0')}/${year}`\n}\n\nexport function getDifferenceInDays(from: string, to: string): number {\n\tconst millisecondsPerDay = 1000 * 60 * 60 * 24\n\treturn (\n\t\t(convertToDate(to).getTime() - convertToDate(from).getTime()) /\n\t\tmillisecondsPerDay\n\t)\n}\n\nexport function getDifferenceInMonths(from: string, to: string): number {\n\t// We want to compute the difference in actual month between the two dates\n\t// For date that start during a month, a pro-rata will be done depending on\n\t// the duration of the month in days\n\tconst [dayFrom, monthFrom, yearFrom] = from.split('/').map((x) => +x)\n\tconst [dayTo, monthTo, yearTo] = to.split('/').map((x) => +x)\n\tconst numberOfFullMonth = monthTo - monthFrom + 12 * (yearTo - yearFrom)\n\tconst numDayMonthFrom = new Date(yearFrom, monthFrom, 0).getDate()\n\tconst numDayMonthTo = new Date(yearTo, monthTo, 0).getDate()\n\tconst prorataMonthFrom = (dayFrom - 1) / numDayMonthFrom\n\tconst prorataMonthTo = dayTo / numDayMonthTo\n\treturn numberOfFullMonth - prorataMonthFrom + prorataMonthTo\n}\n\nexport function getDifferenceInYears(from: string, to: string): number {\n\tconst differenceInDays = getDifferenceInDays(from, to)\n\n\tconst isLeapYear = (year: number) =>\n\t\t(year % 4 === 0 && year % 100 !== 0) || year % 400 === 0\n\tconst after1stMarch = (date: Date) =>\n\t\tdate >= new Date(date.getFullYear(), 2, 1)\n\n\tconst fromDate = convertToDate(from)\n\tconst toDate = convertToDate(to)\n\n\tconst fromYear = fromDate.getFullYear() + (after1stMarch(fromDate) ? 1 : 0)\n\tconst toYear = toDate.getFullYear() + (after1stMarch(fromDate) ? 0 : -1)\n\n\tconst leapYearsCount = Array.from(\n\t\t{ length: toYear - fromYear + 1 },\n\t\t(_, i) => fromYear + i,\n\t).filter(isLeapYear).length\n\n\treturn (differenceInDays - leapYearsCount) / 365\n}\n\nexport function getDifferenceInTrimestreCivils(\n\tfrom: string,\n\tto: string,\n): number {\n\treturn (\n\t\tMath.floor(\n\t\t\tgetDifferenceInMonths(getTrimestreCivil(from), getTrimestreCivil(to)) / 3,\n\t\t) + 1\n\t)\n}\n\nexport function getDifferenceInYearsCivil(from: string, to: string): number {\n\tconst fromYear = '01/' + getYear(from)\n\tconst toYear = '01/' + getYear(to)\n\treturn Math.floor(getDifferenceInYears(fromYear, toYear)) + 1\n}\n","import { EvaluationFunction, PublicodesError } from '..'\nimport { ASTNode, Evaluation, Unit } from '../AST/types'\nimport {\n\tconvertToString,\n\tgetDifferenceInDays,\n\tgetDifferenceInMonths,\n\tgetDifferenceInTrimestreCivils,\n\tgetDifferenceInYears,\n\tgetDifferenceInYearsCivil,\n} from '../date'\nimport { registerEvaluationFunction } from '../evaluationFunctions'\nimport { defaultNode, mergeAllMissing } from '../evaluationUtils'\nimport parse from '../parse'\nimport { parseUnit } from '../units'\n\nexport type DuréeNode = {\n\texplanation: {\n\t\tdepuis: ASTNode\n\t\t\"jusqu'à\": ASTNode\n\t}\n\tunit: Unit\n\tnodeKind: 'durée'\n}\nconst evaluate: EvaluationFunction<'durée'> = function (node) {\n\tconst fromNode = this.evaluateNode(node.explanation.depuis)\n\tconst toNode = this.evaluateNode(node.explanation[\"jusqu'à\"])\n\n\tconst from = fromNode.nodeValue as Evaluation<string>\n\tconst to = toNode.nodeValue as Evaluation<string>\n\n\tlet nodeValue: Evaluation<number>\n\tif (from === null || to === null) {\n\t\tnodeValue = null\n\t} else if (from === undefined || to === undefined) {\n\t\tnodeValue = undefined\n\t} else {\n\t\tswitch (node.unit.numerators[0] as PossibleUnit) {\n\t\t\tcase 'jour':\n\t\t\t\tnodeValue = getDifferenceInDays(from, to)\n\t\t\t\tbreak\n\t\t\tcase 'mois':\n\t\t\t\tnodeValue = getDifferenceInMonths(from, to)\n\t\t\t\tbreak\n\t\t\tcase 'an':\n\t\t\t\tnodeValue = getDifferenceInYears(from, to)\n\t\t\t\tbreak\n\t\t\tcase 'trimestre':\n\t\t\t\tnodeValue = getDifferenceInMonths(from, to) / 3\n\t\t\t\tbreak\n\t\t\tcase 'trimestre civil':\n\t\t\t\tnodeValue = getDifferenceInTrimestreCivils(from, to)\n\t\t\t\tbreak\n\t\t\tcase 'année civile':\n\t\t\t\tnodeValue = getDifferenceInYearsCivil(from, to)\n\t\t\t\tbreak\n\t\t}\n\t}\n\n\tif (typeof nodeValue === 'number') {\n\t\tnodeValue = Math.max(0, nodeValue)\n\t}\n\n\treturn {\n\t\t...node,\n\t\tmissingVariables: mergeAllMissing([fromNode, toNode]),\n\t\tnodeValue,\n\t\texplanation: {\n\t\t\tdepuis: fromNode,\n\t\t\t\"jusqu'à\": toNode,\n\t\t},\n\t}\n}\n\nconst today = defaultNode(convertToString(new Date()))\nexport default (v, context) => {\n\tconst explanation = {\n\t\tdepuis: parse(v.depuis ?? today, context),\n\t\t\"jusqu'à\": parse(v[\"jusqu'à\"] ?? today, context),\n\t}\n\tconst unit = v.unité ? parseUnit(v.unité) : parseUnit('jour')\n\tif (\n\t\tunit.denominators.length > 0 ||\n\t\tunit.numerators.length > 1 ||\n\t\t!possibleUnit.includes(unit.numerators[0] as PossibleUnit)\n\t) {\n\t\tthrow new PublicodesError(\n\t\t\t'SyntaxError',\n\t\t\t`Seules les unités suivantes sont acceptées pour une durée : ${possibleUnit.join(\n\t\t\t\t', ',\n\t\t\t)}.\n\tL'unité fournie est: ${unit.numerators[0]}`,\n\t\t\t{\n\t\t\t\tdottedName: context.dottedName,\n\t\t\t},\n\t\t)\n\t}\n\treturn {\n\t\texplanation,\n\t\tunit,\n\t\tnodeKind: 'durée',\n\t} as DuréeNode\n}\n\nregisterEvaluationFunction('durée', evaluate)\n\ntype PossibleUnit = (typeof possibleUnit)[number]\nconst possibleUnit = [\n\t'mois',\n\t'jour',\n\t'an',\n\t'trimestre',\n\t'trimestre civil',\n\t'année civile',\n] as const\n","import { EvaluationFunction } from '..'\nimport { ASTNode } from '../AST/types'\nimport { registerEvaluationFunction } from '../evaluationFunctions'\nimport parse from '../parse'\nimport { createParseInlinedMecanism } from './inlineMecanism'\n\nexport type EstNonDéfiniNode = {\n\texplanation: ASTNode\n\tnodeKind: 'est non défini'\n}\n\nexport function parseEstNonDéfini(v, context) {\n\tconst explanation = parse(v, context)\n\treturn {\n\t\texplanation,\n\t\tnodeKind: 'est non défini',\n\t} as EstNonDéfiniNode\n}\nparseEstNonDéfini.nom = 'est non défini'\n\nconst parseEstDéfini = createParseInlinedMecanism(\n\t'est défini',\n\t{\n\t\tvaleur: {},\n\t},\n\t{\n\t\t'=': [{ 'est non défini': 'valeur' }, 'non'],\n\t},\n)\n\nconst parseEstApplicable = createParseInlinedMecanism(\n\t'est applicable',\n\t{\n\t\tvaleur: {},\n\t},\n\t{\n\t\t'=': [{ 'est non applicable': 'valeur' }, 'non'],\n\t},\n)\n\nexport { parseEstDéfini, parseEstApplicable }\n\nconst evaluate: EvaluationFunction<'est non défini'> = function (node) {\n\tconst valeur = this.evaluateNode(node.explanation)\n\tlet nodeValue: boolean | undefined | null = false\n\tif (valeur.nodeValue === undefined) {\n\t\tnodeValue = true\n\t}\n\n\treturn {\n\t\t...node,\n\t\tnodeValue,\n\t\tmissingVariables: valeur.missingVariables,\n\t\texplanation: valeur,\n\t}\n}\nregisterEvaluationFunction('est non défini', evaluate)\n","import { EvaluationFunction } from '..'\nimport { ASTNode } from '../AST/types'\nimport { registerEvaluationFunction } from '../evaluationFunctions'\nimport { mergeMissing } from '../evaluationUtils'\nimport parse from '../parse'\nimport { evaluateDisablingParent } from '../rule'\n\nexport type EstNonApplicableNode = {\n\texplanation: ASTNode\n\tnodeKind: 'est non applicable'\n}\nexport function parseEstNonApplicable(v, context) {\n\tconst explanation = parse(v, context)\n\treturn {\n\t\texplanation,\n\t\tnodeKind: 'est non applicable' as const,\n\t} as EstNonApplicableNode\n}\nparseEstNonApplicable.nom = 'est non applicable'\n\nconst isNotApplicable = (node: ASTNode) => {\n\treturn {\n\t\tnodeKind: 'est non applicable' as const,\n\t\texplanation: node,\n\t}\n}\n\nconst evaluateIsNotApplicable: EvaluationFunction<'est non applicable'> =\n\tfunction (node) {\n\t\tconst valeur = node.explanation\n\n\t\tif (\n\t\t\tthis.context.nodesTypes.get(valeur)?.isNullable === false &&\n\t\t\tvaleur.nodeKind !== 'rule' &&\n\t\t\tvaleur.nodeKind !== 'reference'\n\t\t) {\n\t\t\treturn { ...node, nodeValue: false, missingVariables: {} }\n\t\t}\n\n\t\tif (\n\t\t\tthis.cache.nodes.has(valeur) &&\n\t\t\tthis.cache.nodes.get(valeur) !== undefined\n\t\t) {\n\t\t\treturn {\n\t\t\t\t...node,\n\t\t\t\tnodeValue: this.cache.nodes.get(valeur)?.nodeValue === null,\n\t\t\t\tmissingVariables: this.cache.nodes.get(valeur)?.missingVariables ?? {},\n\t\t\t}\n\t\t}\n\n\t\tswitch (valeur.nodeKind) {\n\t\t\tcase 'rule': {\n\t\t\t\tconst { ruleDisabledByItsParent, parentMissingVariables } =\n\t\t\t\t\tevaluateDisablingParent(this, valeur)\n\n\t\t\t\tif (ruleDisabledByItsParent) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t...node,\n\t\t\t\t\t\tnodeValue: true,\n\t\t\t\t\t\tmissingVariables: parentMissingVariables,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst isNotApplicableEvaluation = this.evaluateNode(\n\t\t\t\t\tisNotApplicable(valeur.explanation.valeur),\n\t\t\t\t)\n\t\t\t\tconst missingVariables = mergeMissing(\n\t\t\t\t\tparentMissingVariables,\n\t\t\t\t\tisNotApplicableEvaluation.missingVariables,\n\t\t\t\t)\n\t\t\t\t// If the rule can be disabled thought the situation, it should be listed inside the missing variables\n\t\t\t\tif (\n\t\t\t\t\tisNotApplicableEvaluation.nodeValue === false &&\n\t\t\t\t\tthis.context.nodesTypes.get(\n\t\t\t\t\t\tthis.context.parsedRules[`${valeur.dottedName} . $SITUATION`],\n\t\t\t\t\t)?.isNullable &&\n\t\t\t\t\t!Object.keys(isNotApplicableEvaluation.missingVariables).length\n\t\t\t\t) {\n\t\t\t\t\tmissingVariables[valeur.dottedName] = 1\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\t...node,\n\t\t\t\t\tnodeValue: isNotApplicableEvaluation.nodeValue,\n\t\t\t\t\tmissingVariables,\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 'reference':\n\t\t\t\treturn {\n\t\t\t\t\t...this.evaluateNode(\n\t\t\t\t\t\tisNotApplicable(this.context.parsedRules[valeur.dottedName!]),\n\t\t\t\t\t),\n\t\t\t\t\t...node,\n\t\t\t\t}\n\n\t\t\tcase 'condition':\n\t\t\t\treturn {\n\t\t\t\t\t...this.evaluateNode({\n\t\t\t\t\t\t...valeur,\n\t\t\t\t\t\texplanation: {\n\t\t\t\t\t\t\tsi: valeur.explanation.si,\n\t\t\t\t\t\t\talors: isNotApplicable(valeur.explanation.alors),\n\t\t\t\t\t\t\tsinon: isNotApplicable(valeur.explanation.sinon),\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t\t...node,\n\t\t\t\t}\n\t\t}\n\t\tconst evaluatedValeur = this.evaluateNode(valeur)\n\n\t\treturn {\n\t\t\t...node,\n\t\t\tnodeValue:\n\t\t\t\tevaluatedValeur.nodeValue === undefined ?\n\t\t\t\t\tundefined\n\t\t\t\t:\tevaluatedValeur.nodeValue === null,\n\t\t\tmissingVariables: evaluatedValeur.missingVariables,\n\t\t}\n\t}\n\nregisterEvaluationFunction('est non applicable', evaluateIsNotApplicable)\n","import { EvaluationFunction, PublicodesError } from '..'\nimport { ASTNode } from '../AST/types'\nimport { registerEvaluationFunction } from '../evaluationFunctions'\nimport { defaultNode, mergeAllMissing } from '../evaluationUtils'\nimport parse from '../parse'\nimport {\n\tevaluatePlafondUntilActiveTranche,\n\tparseTranches,\n\tTrancheNodes,\n} from './trancheUtils'\n\nexport type GrilleNode = {\n\texplanation: {\n\t\tassiette: ASTNode\n\t\tmultiplicateur: ASTNode\n\t\ttranches: TrancheNodes\n\t}\n\tnodeKind: 'grille'\n}\n\nexport default function parseGrille(v, context): GrilleNode {\n\tconst explanation = {\n\t\tassiette: parse(v.assiette, context),\n\t\tmultiplicateur:\n\t\t\tv.multiplicateur ? parse(v.multiplicateur, context) : defaultNode(1),\n\t\ttranches: parseTranches(v.tranches, context),\n\t}\n\treturn {\n\t\texplanation,\n\t\tnodeKind: 'grille',\n\t}\n}\n\nconst evaluate: EvaluationFunction<'grille'> = function (node) {\n\tconst evaluate = this.evaluateNode.bind(this)\n\tconst assiette = this.evaluateNode(node.explanation.assiette)\n\tconst multiplicateur = this.evaluateNode(node.explanation.multiplicateur)\n\n\tif (multiplicateur.nodeValue === 0) {\n\t\tthrow new PublicodesError(\n\t\t\t'EvaluationError',\n\t\t\t`Le multiplicateur ne peut pas être nul`,\n\t\t\t{\n\t\t\t\tdottedName: this.cache._meta.evaluationRuleStack[0],\n\t\t\t},\n\t\t)\n\t}\n\n\tconst tranches = evaluatePlafondUntilActiveTranche\n\t\t.call(this, {\n\t\t\tparsedTranches: node.explanation.tranches,\n\t\t\tassiette,\n\t\t\tmultiplicateur,\n\t\t})\n\t\t.map((tranche) => {\n\t\t\tif (tranche.isActive === false) {\n\t\t\t\treturn tranche\n\t\t\t}\n\t\t\tconst montant = evaluate(tranche.montant)\n\t\t\treturn {\n\t\t\t\t...tranche,\n\t\t\t\tmontant,\n\t\t\t\tnodeValue: montant.nodeValue,\n\t\t\t\tunit: montant.unit,\n\t\t\t\tmissingVariables: mergeAllMissing([montant, tranche]),\n\t\t\t}\n\t\t})\n\n\tlet activeTranches\n\tconst activeTranche = tranches.find((tranche) => tranche.isActive)\n\tif (activeTranche) {\n\t\tactiveTranches = [activeTranche]\n\t} else if (tranches[tranches.length - 1].isAfterActive === false) {\n\t\tactiveTranches = [{ nodeValue: false }]\n\t} else {\n\t\tactiveTranches = tranches.filter(\n\t\t\t(tranche) => tranche.isActive === undefined,\n\t\t)\n\t}\n\n\tconst nodeValue =\n\t\t!activeTranches[0] ? false\n\t\t: activeTranches[0].isActive === undefined ? undefined\n\t\t: activeTranches[0].nodeValue\n\n\treturn {\n\t\t...node,\n\t\tnodeValue,\n\t\tmissingVariables: mergeAllMissing([\n\t\t\tassiette,\n\t\t\tmultiplicateur,\n\t\t\t...activeTranches,\n\t\t]),\n\t\texplanation: {\n\t\t\t...node.explanation,\n\t\t\tassiette,\n\t\t\tmultiplicateur,\n\t\t\ttranches,\n\t\t},\n\t\tunit: activeTranches[0]?.unit ?? undefined,\n\t} as any\n}\n\nregisterEvaluationFunction('grille', evaluate)\n","// We use a JavaScript implementation of the Brent method to find the root (the\n// \"zero\") of a monotone function. There are other methods like the\n// Newton-Raphson method, but they take the derivative of the function as an\n// input, wich in our case is costly to calculate. The Brent method doesn't\n// need to calculate the derivative.\n// An interesting description of the algorithm can be found here:\n// https://blogs.mathworks.com/cleve/2015/10/26/zeroin-part-2-brents-version/\n\n/**\n * Copied from https://gist.github.com/borgar/3317728\n *\n * Searches the interval from <tt>lowerLimit</tt> to <tt>upperLimit</tt>\n * for a root (i.e., zero) of the function <tt>func</tt> with respect to\n * its first argument using Brent's method root-finding algorithm.\n *\n * Translated from zeroin.c in http://www.netlib.org/c/brent.shar.\n *\n * Copyright (c) 2012 Borgar Thorsteinsson <borgar@borgar.net>\n * MIT License, http://www.opensource.org/licenses/mit-license.php\n *\n * @param func function for which the root is sought.\n * @param lowerLimit the lower point of the interval to be searched.\n * @param upperLimit the upper point of the interval to be searched.\n * @param errorTol the desired accuracy (convergence tolerance).\n * @param maxIter the maximum number of iterations.\n * @param acceptableErrorTol return a result even if errorTol isn't reached after maxIter.\n * @returns an estimate for the root within accuracy.\n *\n */\nexport default function uniroot(\n\tfunc: (x: number) => number,\n\tlowerLimit: number,\n\tupperLimit: number,\n\terrorTol = 0,\n\tmaxIter = 100,\n\tacceptableErrorTol = 0,\n) {\n\tlet a = lowerLimit,\n\t\tb = upperLimit,\n\t\tc = a,\n\t\tfa = func(a),\n\t\tfb = func(b),\n\t\tfc = fa,\n\t\tactualTolerance: number,\n\t\tnewStep: number, // Step at this iteration\n\t\tprevStep: number, // Distance from the last but one to the last approximation\n\t\tp: number, // Interpolation step is calculated in the form p/q; division is delayed until the last moment\n\t\tq: number,\n\t\tfallback: number | undefined = undefined\n\n\twhile (maxIter-- > 0) {\n\t\tprevStep = b - a\n\n\t\tif (Math.abs(fc) < Math.abs(fb)) {\n\t\t\t// Swap data for b to be the best approximation\n\t\t\t;(a = b), (b = c), (c = a)\n\t\t\t;(fa = fb), (fb = fc), (fc = fa)\n\t\t}\n\n\t\tactualTolerance = 1e-15 * Math.abs(b) + errorTol / 2\n\t\tnewStep = (c - b) / 2\n\n\t\tif (Math.abs(newStep) <= actualTolerance || fb === 0) {\n\t\t\treturn b // Acceptable approx. is found\n\t\t}\n\n\t\t// Decide if the interpolation can be tried\n\t\tif (Math.abs(prevStep) >= actualTolerance && Math.abs(fa) > Math.abs(fb)) {\n\t\t\t// If prevStep was large enough and was in true direction, Interpolatiom may be tried\n\t\t\tlet t1: number, t2: number\n\t\t\tconst cb = c - b\n\t\t\tif (a === c) {\n\t\t\t\t// If we have only two distinct points linear interpolation can only be applied\n\t\t\t\tt1 = fb / fa\n\t\t\t\tp = cb * t1\n\t\t\t\tq = 1.0 - t1\n\t\t\t} else {\n\t\t\t\t// Quadric inverse interpolation\n\t\t\t\t;(q = fa / fc), (t1 = fb / fc), (t2 = fb / fa)\n\t\t\t\tp = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1))\n\t\t\t\tq = (q - 1) * (t1 - 1) * (t2 - 1)\n\t\t\t}\n\n\t\t\tif (p > 0) {\n\t\t\t\tq = -q // p was calculated with the opposite sign; make p positive\n\t\t\t} else {\n\t\t\t\tp = -p // and assign possible minus to q\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tp < 0.75 * cb * q - Math.abs(actualTolerance * q) / 2 &&\n\t\t\t\tp < Math.abs((prevStep * q) / 2)\n\t\t\t) {\n\t\t\t\t// If (b + p / q) falls in [b,c] and isn't too large it is accepted\n\t\t\t\tnewStep = p / q\n\t\t\t}\n\n\t\t\t// If p/q is too large then the bissection procedure can reduce [b,c] range to more extent\n\t\t}\n\n\t\tif (Math.abs(newStep) < actualTolerance) {\n\t\t\t// Adjust the step to be not less than tolerance\n\t\t\tnewStep = newStep > 0 ? actualTolerance : -actualTolerance\n\t\t}\n\n\t\t;(a = b), (fa = fb) // Save the previous approx.\n\t\t;(b += newStep), (fb = func(b)) // Do step to a new approxim.\n\n\t\tif ((fb > 0 && fc > 0) || (fb < 0 && fc < 0)) {\n\t\t\t;(c = a), (fc = fa) // Adjust c for it to have a sign opposite to that of b\n\t\t}\n\t\tif (Math.abs(fb) < errorTol) {\n\t\t\treturn b\n\t\t}\n\t\tif (Math.abs(fb) < acceptableErrorTol) {\n\t\t\tfallback = b\n\t\t}\n\t}\n\treturn fallback\n}\n","import { EvaluationFunction, PublicodesError } from '..'\nimport { ASTNode, EvaluatedNode, Unit } from '../AST/types'\nimport { registerEvaluationFunction } from '../evaluationFunctions'\nimport { undefinedNumberNode } from '../evaluationUtils'\nimport parse from '../parse'\nimport { Context } from '../parsePublicodes'\nimport { ReferenceNode } from '../reference'\nimport uniroot from '../uniroot'\n\nexport type InversionNode = {\n\texplanation: {\n\t\truleToInverse: string\n\t\tinversionCandidates: Array<ReferenceNode>\n\t\tunit?: Unit\n\n\t\t// Explanation computed during evaluation\n\t\tinversionGoal?: ASTNode\n\t\tnumberOfIteration?: number\n\t\tinversionFail?: boolean\n\t}\n\tnodeKind: 'inversion'\n}\n\n// The user of the inversion mechanism has to define a list of \"inversion\n// candidates\". At runtime, the evaluation function of the mechanism will look\n// at the situation value of these candidates, and use the first one that is\n// defined as its \"goal\" for the inversion\n//\n// The game is then to find an input such as the computed value of the \"goal\" is\n// equal to its situation value, mathematically we search for the zero of the\n// function x → f(x) - goal. The iteration logic between each test is\n// implemented in the `uniroot` file.\nexport const evaluateInversion: EvaluationFunction<'inversion'> = function (\n\tnode,\n) {\n\tconst inversionEngine = this.shallowCopy()\n\tif (\n\t\tthis.cache._meta.evaluationRuleStack\n\t\t\t.slice(1)\n\t\t\t.includes(node.explanation.ruleToInverse)\n\t) {\n\t\treturn {\n\t\t\t...undefinedNumberNode,\n\t\t\t...node,\n\t\t}\n\t}\n\tinversionEngine.cache._meta.parentRuleStack = [\n\t\t...this.cache._meta.parentRuleStack,\n\t]\n\tinversionEngine.cache._meta.evaluationRuleStack = [\n\t\t...this.cache._meta.evaluationRuleStack,\n\t]\n\tconst inversionGoal = node.explanation.inversionCandidates.find(\n\t\t(candidate) => {\n\t\t\tif (\n\t\t\t\tthis.cache._meta.evaluationRuleStack.includes(candidate.dottedName!)\n\t\t\t) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tconst evaluation = inversionEngine.evaluateNode(\n\t\t\t\tinversionEngine.context.parsedRules[\n\t\t\t\t\t`${candidate.dottedName} . $SITUATION`\n\t\t\t\t],\n\t\t\t)\n\t\t\treturn (\n\t\t\t\ttypeof evaluation.nodeValue === 'number' &&\n\t\t\t\t!(candidate.dottedName! in evaluation.missingVariables)\n\t\t\t)\n\t\t},\n\t)\n\n\tif (inversionGoal === undefined) {\n\t\treturn {\n\t\t\t...node,\n\t\t\tnodeValue: undefined,\n\t\t\tmissingVariables: {\n\t\t\t\t...Object.fromEntries(\n\t\t\t\t\tnode.explanation.inversionCandidates.map((candidate) => [\n\t\t\t\t\t\tcandidate.dottedName,\n\t\t\t\t\t\t1,\n\t\t\t\t\t]),\n\t\t\t\t),\n\t\t\t\t[node.explanation.ruleToInverse]: 1,\n\t\t\t},\n\t\t}\n\t}\n\tconst evaluatedInversionGoal = inversionEngine.evaluateNode(inversionGoal)\n\tlet numberOfIteration = 0\n\n\tinversionEngine.setSituation(\n\t\t{\n\t\t\t[inversionGoal.dottedName!]: undefinedNumberNode,\n\t\t},\n\t\t{ keepPreviousSituation: true },\n\t)\n\tinversionEngine.cache.traversedVariablesStack =\n\t\tthis.cache.traversedVariablesStack ? [] : undefined\n\n\tlet lastEvaluation: EvaluatedNode\n\tconst evaluateWithValue = (n: number) => {\n\t\tnumberOfIteration++\n\t\tinversionEngine.setSituation(\n\t\t\t{\n\t\t\t\t[node.explanation.ruleToInverse]: {\n\t\t\t\t\tnodeValue: n,\n\t\t\t\t\tnodeKind: 'constant',\n\t\t\t\t\ttype: 'number',\n\t\t\t\t\tunit: evaluatedInversionGoal.unit,\n\t\t\t\t},\n\t\t\t},\n\t\t\t{ keepPreviousSituation: true },\n\t\t)\n\t\tinversionEngine.cache.traversedVariablesStack =\n\t\t\tthis.cache.traversedVariablesStack ? [] : undefined\n\n\t\tlastEvaluation = inversionEngine.evaluateNode(inversionGoal)\n\t\treturn lastEvaluation\n\t}\n\n\tconst goal = evaluatedInversionGoal.nodeValue as number\n\tlet nodeValue: number | undefined | undefined = undefined\n\n\t// We do some blind attempts here to avoid using the default minimum and\n\t// maximum of +/- 10^8 that are required by the `uniroot` function. For the\n\t// first attempt we use the goal value as a very rough first approximation.\n\t// For the second attempt we do a proportionality coefficient with the result\n\t// from the first try and the goal value. The two attempts are then used in\n\t// the following way:\n\t// - if both results are `undefined` we assume that the inversion is impossible\n\t//   because of missing variables\n\t// - otherwise, we calculate the missing variables of the node as the union of\n\t//   the missings variables of our two attempts\n\t// - we cache the result of our two attempts so that `uniroot` doesn't\n\t//   recompute them\n\tconst x1 = goal\n\tconst y1Node = evaluateWithValue(x1)\n\tconst y1 = y1Node.nodeValue as number\n\tconst coeff = y1 > goal ? 0.9 : 1.2\n\tconst x2 = y1 !== undefined ? (x1 * goal * coeff) / y1 : 2000\n\tconst y2Node = evaluateWithValue(x2)\n\tconst y2 = y2Node.nodeValue as number\n\n\tconst maxIterations = this.context.inversionMaxIterations ?? 10\n\n\tif (y1 !== undefined || y2 !== undefined) {\n\t\t// The `uniroot` function parameter. It will be called with its `min` and\n\t\t// `max` arguments, so we can use our cached nodes if the function is called\n\t\t// with the already computed x1 or x2.\n\t\tconst test = (x: number): number => {\n\t\t\tconst y =\n\t\t\t\tx === x1 ? y1\n\t\t\t\t: x === x2 ? y2\n\t\t\t\t: evaluateWithValue(x).nodeValue\n\t\t\treturn (y as number) - goal\n\t\t}\n\n\t\tconst defaultMin = -1000000\n\t\tconst defaultMax = 100000000\n\t\tconst nearestBelowGoal =\n\t\t\ty2 !== undefined && y2 < goal && (y2 > y1 || y1 > goal) ? x2\n\t\t\t: y1 !== undefined && y1 < goal && (y1 > y2 || y2 > goal) ? x1\n\t\t\t: defaultMin\n\t\tconst nearestAboveGoal =\n\t\t\ty2 !== undefined && y2 > goal && (y2 < y1 || y1 < goal) ? x2\n\t\t\t: y1 !== undefined && y1 > goal && (y1 < y2 || y2 < goal) ? x1\n\t\t\t: defaultMax\n\n\t\tnodeValue = uniroot(\n\t\t\ttest,\n\t\t\tnearestBelowGoal,\n\t\t\tnearestAboveGoal,\n\t\t\t0.1,\n\t\t\tmaxIterations,\n\t\t\t1,\n\t\t)\n\t}\n\n\tif (nodeValue == undefined) {\n\t\tthis.cache.inversionFail = true\n\t}\n\n\t// Uncomment to display the two attempts and their result\n\t// console.table([\n\t// \t{ x: x1, y: y1 },\n\t// \t{ x: x2, y: y2 },\n\t// ])\n\t// console.log('iteration inversion:', numberOfIteration)\n\tif (this.cache.traversedVariablesStack) {\n\t\tconst traversedVariablesStack = this.cache.traversedVariablesStack[0]\n\t\tif (traversedVariablesStack) {\n\t\t\t;(lastEvaluation!.traversedVariables ?? []).forEach((v) =>\n\t\t\t\ttraversedVariablesStack.add(v),\n\t\t\t)\n\t\t}\n\t}\n\treturn {\n\t\t...node,\n\t\tnodeValue,\n\t\tunit: evaluatedInversionGoal.unit,\n\t\texplanation: {\n\t\t\t...node.explanation,\n\t\t\tinversionGoal,\n\t\t\tnumberOfIteration,\n\t\t\tinversionFail: this.cache.inversionFail,\n\t\t},\n\t\tmissingVariables: lastEvaluation!.missingVariables,\n\t}\n}\n\nexport const mecanismInversion = (v, context: Context) => {\n\tlet avec = typeof v === 'object' && 'avec' in v ? v.avec : v\n\tif (v === null) {\n\t\tthrow new PublicodesError(\n\t\t\t'SyntaxError',\n\t\t\t\"Il manque les règles avec laquelle effectuer le calcul d'inversion dans le mécanisme `inversion numérique`\",\n\t\t\t{ dottedName: context.dottedName },\n\t\t)\n\t}\n\tif (!Array.isArray(avec)) {\n\t\tavec = [avec]\n\t}\n\treturn {\n\t\texplanation: {\n\t\t\truleToInverse: context.dottedName,\n\t\t\tinversionCandidates: avec.map((node) => ({\n\t\t\t\t...parse(node, context),\n\t\t\t})),\n\t\t},\n\t\tnodeKind: 'inversion',\n\t} as InversionNode\n}\n\nregisterEvaluationFunction('inversion', evaluateInversion)\n","import { PublicodesExpression } from '..'\nimport { notApplicableNode } from '../evaluationUtils'\nimport { createParseInlinedMecanismWithArray } from './inlineMecanism'\n\nexport const parseMaximumDe = createParseInlinedMecanismWithArray(\n\t'le maximum de',\n\t{\n\t\tvaleur: { type: 'liste' },\n\t},\n\t({ valeur }) =>\n\t\t(valeur as Array<PublicodesExpression>).reduce(\n\t\t\t(acc, value) => ({\n\t\t\t\tcondition: {\n\t\t\t\t\tsi: {\n\t\t\t\t\t\t'est non applicable': '$INTERNAL valeur',\n\t\t\t\t\t},\n\t\t\t\t\talors: '$INTERNAL acc',\n\t\t\t\t\tsinon: {\n\t\t\t\t\t\tcondition: {\n\t\t\t\t\t\t\tsi: {\n\t\t\t\t\t\t\t\tou: [\n\t\t\t\t\t\t\t\t\t{ 'est non applicable': '$INTERNAL acc' },\n\t\t\t\t\t\t\t\t\t{ '>': ['$INTERNAL valeur', '$INTERNAL acc'] },\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\talors: '$INTERNAL valeur',\n\t\t\t\t\t\t\tsinon: '$INTERNAL acc',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tavec: {\n\t\t\t\t\t'[privé] $INTERNAL valeur': { valeur: value },\n\t\t\t\t\t'[privé] $INTERNAL acc': { valeur: acc },\n\t\t\t\t},\n\t\t\t}),\n\t\t\tnotApplicableNode,\n\t\t),\n)\n\nexport const parseMinimumDe = createParseInlinedMecanismWithArray(\n\t'le minimum de',\n\t{\n\t\tvaleur: { type: 'liste' },\n\t},\n\t({ valeur }) =>\n\t\t(valeur as Array<PublicodesExpression>).reduce(\n\t\t\t(acc, value) => ({\n\t\t\t\tcondition: {\n\t\t\t\t\tsi: {\n\t\t\t\t\t\t'est non applicable': '$INTERNAL valeur',\n\t\t\t\t\t},\n\t\t\t\t\talors: '$INTERNAL acc',\n\t\t\t\t\tsinon: {\n\t\t\t\t\t\tcondition: {\n\t\t\t\t\t\t\tsi: {\n\t\t\t\t\t\t\t\tou: [\n\t\t\t\t\t\t\t\t\t{ 'est non applicable': '$INTERNAL acc' },\n\t\t\t\t\t\t\t\t\t{ '<': ['$INTERNAL valeur', '$INTERNAL acc'] },\n\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\talors: '$INTERNAL valeur',\n\t\t\t\t\t\t\tsinon: '$INTERNAL acc',\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tavec: {\n\t\t\t\t\t'[privé] $INTERNAL valeur': { valeur: value },\n\t\t\t\t\t'[privé] $INTERNAL acc': { valeur: acc },\n\t\t\t\t},\n\t\t\t}),\n\t\t\tnotApplicableNode,\n\t\t),\n)\n","import { PublicodesExpression } from '..'\nimport { notApplicableNode } from '../evaluationUtils'\nimport { createParseInlinedMecanismWithArray } from './inlineMecanism'\n\nexport function reduceToSumNodes(\n\tvaleurs: Array<PublicodesExpression>,\n): PublicodesExpression {\n\treturn valeurs\n\t\t.reverse()\n\t\t.reduce((acc, value) => ({ '+': [value, acc] }), notApplicableNode)\n}\n\nexport default createParseInlinedMecanismWithArray(\n\t'somme',\n\t{\n\t\tvaleur: { type: 'liste' },\n\t},\n\t({ valeur }) =>\n\t\treduceToSumNodes([...(valeur as Array<PublicodesExpression>)]),\n)\n","import { PublicodesExpression } from '..'\nimport { createParseInlinedMecanismWithArray } from './inlineMecanism'\nimport { reduceToSumNodes } from './somme'\n\nexport default createParseInlinedMecanismWithArray(\n\t'moyenne',\n\t{\n\t\tvaleur: { type: 'liste' },\n\t},\n\t({ valeur }) => {\n\t\tconst valeurs = [...(valeur as Array<PublicodesExpression>)]\n\n\t\treturn {\n\t\t\t'/': [\n\t\t\t\treduceToSumNodes(valeurs),\n\t\t\t\treduceToSumNodes(valeurs.map(oneIfApplicable)),\n\t\t\t],\n\t\t}\n\t},\n)\n\nfunction oneIfApplicable(exp: PublicodesExpression): PublicodesExpression {\n\treturn {\n\t\t'applicable si': { 'est applicable': exp },\n\t\tvaleur: 1,\n\t}\n}\n","import { notApplicableNode } from '../evaluationUtils'\nimport { createParseInlinedMecanism } from './inlineMecanism'\n\nexport default createParseInlinedMecanism(\n\t'non applicable si',\n\t{\n\t\t'non applicable si': {},\n\t\tvaleur: {},\n\t},\n\t{\n\t\tcondition: {\n\t\t\tsi: 'non applicable si = non',\n\t\t\talors: 'valeur',\n\t\t\tsinon: notApplicableNode,\n\t\t},\n\t},\n)\n","import { ASTNode } from '../AST/types'\nimport { registerEvaluationFunction } from '../evaluationFunctions'\nimport parse from '../parse'\nimport { Context } from '../parsePublicodes'\n\nexport type PossibilityNode = {\n\texplanation: Array<ASTNode>\n\t'choix obligatoire'?: 'oui' | 'non'\n\tcontext: string\n\tnodeKind: 'une possibilité'\n}\n// TODO : This isn't a real mecanism, cf. #963\nexport const mecanismOnePossibility = (v, context: Context) => {\n\tif (Array.isArray(v)) {\n\t\tv = {\n\t\t\tpossibilités: v,\n\t\t}\n\t}\n\treturn {\n\t\t...v,\n\t\texplanation: v.possibilités.map((p) => parse(p, context)),\n\t\tcontext: context.dottedName,\n\t\tnodeKind: 'une possibilité',\n\t} as PossibilityNode\n}\nregisterEvaluationFunction<'une possibilité'>('une possibilité', (node) => ({\n\t...node,\n\tmissingVariables: { [node.context]: 1 },\n\tnodeValue: undefined,\n}))\n","import { EvaluationFunction, PublicodesError } from '..'\nimport { ASTNode, EvaluatedNode } from '../AST/types'\nimport { convertToDate } from '../date'\nimport { warning } from '../error'\nimport { registerEvaluationFunction } from '../evaluationFunctions'\nimport { mergeAllMissing } from '../evaluationUtils'\nimport { convertNodeToUnit } from '../nodeUnits'\nimport parse from '../parse'\nimport { inferUnit, serializeUnit } from '../units'\n\nconst knownOperations = {\n\t'*': [(a, b) => a * b, '×'],\n\t'/': [(a, b) => a / b, '∕'],\n\t'+': [(a, b) => a + b],\n\t'-': [(a, b) => a - b, '−'],\n\t'<': [(a, b) => a < b],\n\t'<=': [(a, b) => a <= b, '≤'],\n\t'>': [(a, b) => a > b],\n\t'>=': [(a, b) => a >= b, '≥'],\n\t'=': [(a, b) => (a ?? false) === (b ?? false)],\n\t'!=': [(a, b) => (a ?? false) !== (b ?? false), '≠'],\n\tet: [(a, b) => (a ?? false) && (b ?? false)],\n\tou: [(a, b) => (a ?? false) || (b ?? false)],\n} as const\n\nexport type OperationNode = {\n\tnodeKind: 'operation'\n\texplanation: [ASTNode, ASTNode]\n\toperationKind: keyof typeof knownOperations\n\toperator: string\n}\n\nconst parseOperation = (k, symbol) => (v, context) => {\n\tconst explanation = v.map((node) => parse(node, context))\n\n\treturn {\n\t\t...v,\n\t\tnodeKind: 'operation',\n\t\toperationKind: k,\n\t\toperator: symbol || k,\n\t\texplanation,\n\t} as OperationNode\n}\n\nconst evaluate: EvaluationFunction<'operation'> = function (node) {\n\tlet node1 = this.evaluateNode(node.explanation[0])\n\n\tlet evaluatedNode: EvaluatedNode & OperationNode = {\n\t\t...node,\n\t\tmissingVariables: {},\n\t} as EvaluatedNode & OperationNode\n\n\t// LAZY EVALUATION\n\tif (\n\t\t(node1.nodeValue === null &&\n\t\t\t['<', '>', '<=', '>=', '/', '*', '-', 'et'].includes(\n\t\t\t\tnode.operationKind,\n\t\t\t)) ||\n\t\t(node1.nodeValue === 0 && ['/', '*'].includes(node.operationKind)) ||\n\t\t(node1.nodeValue === false && node.operationKind === 'et') ||\n\t\t(node1.nodeValue === true && node.operationKind === 'ou')\n\t) {\n\t\treturn {\n\t\t\t...evaluatedNode,\n\t\t\tnodeValue: node.operationKind === 'et' ? false : node1.nodeValue,\n\t\t\tmissingVariables: node1.missingVariables,\n\t\t}\n\t}\n\n\tlet node2 = this.evaluateNode(node.explanation[1])\n\tevaluatedNode.explanation = [node1, node2]\n\n\tif (node.operationKind === '/' && node2.nodeValue === 0) {\n\t\tthrow new PublicodesError('EvaluationError', `Division by zero`, {\n\t\t\tdottedName: this.cache._meta.evaluationRuleStack[0],\n\t\t})\n\t}\n\n\t// LAZY EVALUATION 2\n\tif (\n\t\t(node2.nodeValue === null &&\n\t\t\t['<', '>', '<=', '>=', '/', '*', 'et'].includes(node.operationKind)) ||\n\t\t(node2.nodeValue === 0 && ['*'].includes(node.operationKind)) ||\n\t\t(node2.nodeValue === false && node.operationKind === 'et') ||\n\t\t(node2.nodeValue === true && node.operationKind === 'ou')\n\t) {\n\t\treturn {\n\t\t\t...evaluatedNode,\n\t\t\tnodeValue: node.operationKind === 'et' ? false : node2.nodeValue,\n\t\t\tmissingVariables: node2.missingVariables,\n\t\t}\n\t}\n\n\tevaluatedNode.missingVariables = mergeAllMissing([node1, node2])\n\n\tif (node1.nodeValue === undefined || node2.nodeValue === undefined) {\n\t\tevaluatedNode = {\n\t\t\t...evaluatedNode,\n\t\t\tnodeValue: undefined,\n\t\t}\n\t}\n\n\tconst isAdditionOrSubstractionWithPercentage =\n\t\t['+', '-'].includes(node.operationKind) &&\n\t\tserializeUnit(node2.unit) === '%' &&\n\t\tserializeUnit(node1.unit) !== '%'\n\n\tif (\n\t\t!('nodeValue' in evaluatedNode) &&\n\t\t!['/', '*'].includes(node.operationKind) &&\n\t\t!isAdditionOrSubstractionWithPercentage\n\t) {\n\t\ttry {\n\t\t\tif (node1.unit && 'unit' in node2) {\n\t\t\t\tnode2 = convertNodeToUnit(node1.unit, node2)\n\t\t\t} else if (node2.unit) {\n\t\t\t\tnode1 = convertNodeToUnit(node2.unit, node1)\n\t\t\t}\n\t\t} catch (e) {\n\t\t\twarning(\n\t\t\t\tthis.context.logger,\n\t\t\t\t`Dans l'expression '${\n\t\t\t\t\tnode.operationKind\n\t\t\t\t}', la partie gauche (unité: ${serializeUnit(\n\t\t\t\t\tnode1.unit,\n\t\t\t\t)}) n'est pas compatible avec la partie droite (unité: ${serializeUnit(\n\t\t\t\t\tnode2.unit,\n\t\t\t\t)})`,\n\t\t\t\t{ dottedName: this.cache._meta.evaluationRuleStack[0] },\n\t\t\t\te,\n\t\t\t)\n\t\t}\n\t}\n\n\tconst operatorFunction = knownOperations[node.operationKind][0]\n\n\tconst a = node1.nodeValue as string | boolean | null\n\tconst b = node2.nodeValue as string | boolean | null\n\n\tevaluatedNode.nodeValue =\n\t\t'nodeValue' in evaluatedNode ? evaluatedNode.nodeValue\n\t\t: (\n\t\t\t['<', '>', '<=', '>=', '*', '/'].includes(node.operationKind) &&\n\t\t\tnode2.nodeValue === null\n\t\t) ?\n\t\t\tnull\n\t\t: (\n\t\t\t[a, b].every(\n\t\t\t\t(value) =>\n\t\t\t\t\ttypeof value === 'string' &&\n\t\t\t\t\tvalue.match?.(/^[\\d]{2}\\/[\\d]{2}\\/[\\d]{4}$/),\n\t\t\t)\n\t\t) ?\n\t\t\t// We convert the date objects to timestamps to support comparison with the \"===\" operator:\n\t\t\t// new Date('2020-01-01') !== new Date('2020-01-01')\n\t\t\toperatorFunction(\n\t\t\t\tconvertToDate(a as string).getTime(),\n\t\t\t\tconvertToDate(b as string).getTime(),\n\t\t\t)\n\t\t:\toperatorFunction(a, b)\n\n\tif (\n\t\tnode.operationKind === '*' &&\n\t\tinferUnit('*', [node1.unit, node2.unit])?.numerators.includes('%')\n\t) {\n\t\tconst unit = inferUnit('*', [node1.unit, node2.unit])\n\t\tconst nodeValue = evaluatedNode.nodeValue\n\t\treturn {\n\t\t\t...evaluatedNode,\n\t\t\tnodeValue: typeof nodeValue === 'number' ? nodeValue / 100 : nodeValue,\n\t\t\tunit: inferUnit('*', [unit, { numerators: [], denominators: ['%'] }]),\n\t\t}\n\t}\n\n\t// Addition or substraction of scalar with a percentage is a multiplication\n\t// TODO : this logic should be handle statically by changing sum with percentage into product.\n\t// It can be done when we'll have a sound type/unit inference\n\tif (isAdditionOrSubstractionWithPercentage) {\n\t\tconst unit = inferUnit('*', [node1.unit, node2.unit])\n\t\treturn {\n\t\t\t...evaluatedNode,\n\t\t\tnodeValue:\n\t\t\t\t(\n\t\t\t\t\ttypeof node1.nodeValue === 'number' &&\n\t\t\t\t\ttypeof node2.nodeValue === 'number'\n\t\t\t\t) ?\n\t\t\t\t\tnode1.nodeValue *\n\t\t\t\t\t(1 + (node2.nodeValue / 100) * (node.operationKind === '-' ? -1 : 1))\n\t\t\t\t:\tevaluatedNode.nodeValue,\n\t\t\tunit: inferUnit('*', [unit, { numerators: [], denominators: ['%'] }]),\n\t\t}\n\t}\n\n\tif (\n\t\tnode.operationKind === '*' ||\n\t\tnode.operationKind === '/' ||\n\t\tnode.operationKind === '-' ||\n\t\tnode.operationKind === '+'\n\t) {\n\t\treturn {\n\t\t\t...evaluatedNode,\n\t\t\tunit: inferUnit(node.operationKind, [node1.unit, node2.unit]),\n\t\t}\n\t}\n\n\treturn evaluatedNode\n}\n\nregisterEvaluationFunction('operation', evaluate)\n\nconst operationDispatch = Object.fromEntries(\n\tObject.entries(knownOperations).map(([k, [, symbol]]) => [\n\t\tk,\n\t\tparseOperation(k, symbol),\n\t]),\n)\n\nexport default operationDispatch\n","import { createParseInlinedMecanism } from './inlineMecanism'\n\nexport default createParseInlinedMecanism(\n\t'par défaut',\n\t{\n\t\t'par défaut': {},\n\t\tvaleur: {},\n\t},\n\t{\n\t\tcondition: {\n\t\t\tsi: { 'est non défini': 'valeur' },\n\t\t\talors: 'par défaut',\n\t\t\tsinon: 'valeur',\n\t\t},\n\t},\n)\n","import { createParseInlinedMecanism } from './inlineMecanism'\n\nexport default createParseInlinedMecanism(\n\t'plafond',\n\t{\n\t\tplafond: {},\n\t\tvaleur: {},\n\t},\n\t{\n\t\tcondition: {\n\t\t\tsi: { et: ['plafond != non', 'valeur > plafond'] },\n\t\t\talors: 'plafond',\n\t\t\tsinon: 'valeur',\n\t\t},\n\t},\n)\n","import { createParseInlinedMecanism } from './inlineMecanism'\n\nexport default createParseInlinedMecanism(\n\t'plancher',\n\t{\n\t\tplancher: {},\n\t\tvaleur: {},\n\t},\n\t{\n\t\tcondition: {\n\t\t\tsi: { et: ['plancher != non', 'valeur < plancher'] },\n\t\t\talors: 'plancher',\n\t\t\tsinon: 'valeur',\n\t\t},\n\t},\n)\n","import { PublicodesExpression } from '..'\nimport { defaultNode } from '../evaluationUtils'\nimport { createParseInlinedMecanismWithArray } from './inlineMecanism'\n\nexport function reduceToProduitNodes(\n\tvaleurs: Array<PublicodesExpression>,\n): PublicodesExpression {\n\treturn valeurs.reduce((acc, value) => ({ '*': [value, acc] }), defaultNode(1))\n}\n\nexport default createParseInlinedMecanismWithArray(\n\t'produit',\n\t{\n\t\tvaleur: { type: 'liste' },\n\t},\n\t({ valeur }) => ({\n\t\tvaleur: reduceToProduitNodes([...(valeur as Array<PublicodesExpression>)]),\n\t\t\"simplifier l'unité\": 'oui',\n\t}),\n)\n","import { EvaluationFunction } from '..'\nimport { ASTNode } from '../AST/types'\nimport { registerEvaluationFunction } from '../evaluationFunctions'\nimport { undefinedNumberNode } from '../evaluationUtils'\nimport parse from '../parse'\nimport { Context } from '../parsePublicodes'\nimport uniroot from '../uniroot'\n\nexport type RésoudreRéférenceCirculaireNode = {\n\texplanation: {\n\t\truleToSolve: string\n\t\tvaleur: ASTNode\n\t}\n\tnodeKind: 'résoudre référence circulaire'\n}\n\nexport const evaluateRésoudreRéférenceCirculaire: EvaluationFunction<'résoudre référence circulaire'> =\n\tfunction (node) {\n\t\tif (\n\t\t\tthis.cache._meta.evaluationRuleStack\n\t\t\t\t.slice(1)\n\t\t\t\t.includes(node.explanation.ruleToSolve)\n\t\t) {\n\t\t\treturn {\n\t\t\t\t...undefinedNumberNode,\n\t\t\t\t...node,\n\t\t\t}\n\t\t}\n\n\t\tlet numberOfIterations = 0\n\t\tconst calculationEngine = this.shallowCopy()\n\t\tcalculationEngine.cache._meta.parentRuleStack = [\n\t\t\t...this.cache._meta.parentRuleStack,\n\t\t]\n\t\tcalculationEngine.cache._meta.evaluationRuleStack = [\n\t\t\t...this.cache._meta.evaluationRuleStack,\n\t\t]\n\t\tconst maxIterations = this.context.inversionMaxIterations ?? 25\n\n\t\tconst evaluateWithValue = (n: number) => {\n\t\t\tnumberOfIterations++\n\t\t\tcalculationEngine.setSituation(\n\t\t\t\t{\n\t\t\t\t\t[node.explanation.ruleToSolve]: {\n\t\t\t\t\t\t...undefinedNumberNode,\n\t\t\t\t\t\tnodeValue: n,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{ keepPreviousSituation: true },\n\t\t\t)\n\n\t\t\treturn calculationEngine.evaluateNode(node.explanation.valeur)\n\t\t}\n\n\t\tconst inversionFailed = Symbol('inversion failed')\n\n\t\tlet nodeValue: number | undefined | typeof inversionFailed = inversionFailed\n\n\t\tconst x0 = 1\n\t\tlet valeur = evaluateWithValue(x0)\n\t\tconst y0 = valeur.nodeValue as number\n\t\tconst unit = valeur.unit\n\t\tif (y0 !== undefined) {\n\t\t\t// The `uniroot` function parameter. It will be called with its `min` and\n\t\t\t// `max` arguments, so we can use our cached nodes if the function is called\n\t\t\t// with the already computed x1 or x2.\n\t\t\tconst test = (x: number): number => {\n\t\t\t\tif (x === x0) {\n\t\t\t\t\treturn y0 - x0\n\t\t\t\t}\n\t\t\t\tvaleur = evaluateWithValue(x)\n\t\t\t\tconst y = valeur.nodeValue\n\t\t\t\treturn (y as number) - x\n\t\t\t}\n\n\t\t\tconst defaultMin = -1_000_000\n\t\t\tconst defaultMax = 100_000_000\n\n\t\t\tnodeValue = uniroot(test, defaultMin, defaultMax, 0.5, maxIterations, 2)\n\t\t}\n\n\t\tif (nodeValue === inversionFailed) {\n\t\t\tnodeValue = undefined\n\t\t\tthis.cache.inversionFail = true\n\t\t}\n\t\tif (nodeValue !== undefined) {\n\t\t\tvaleur = evaluateWithValue(nodeValue)\n\t\t}\n\t\treturn {\n\t\t\t...node,\n\t\t\tunit,\n\t\t\tnodeValue,\n\t\t\texplanation: {\n\t\t\t\t...node.explanation,\n\t\t\t\tvaleur,\n\t\t\t\tnumberOfIterations,\n\t\t\t},\n\t\t\tmissingVariables: valeur.missingVariables,\n\t\t}\n\t}\n\nexport default function parseRésoudreRéférenceCirculaire(v, context: Context) {\n\treturn {\n\t\texplanation: {\n\t\t\truleToSolve: context.dottedName,\n\t\t\tvaleur: parse(v.valeur, context),\n\t\t},\n\t\tnodeKind: 'résoudre référence circulaire',\n\t} as RésoudreRéférenceCirculaireNode\n}\n\nparseRésoudreRéférenceCirculaire.nom = 'résoudre la référence circulaire'\n\nregisterEvaluationFunction(\n\t'résoudre référence circulaire',\n\tevaluateRésoudreRéférenceCirculaire,\n)\n","import { ASTNode } from '../AST/types'\nimport { registerEvaluationFunction } from '../evaluationFunctions'\nimport parse from '../parse'\nimport { convertUnit, simplifyUnit } from '../units'\n\nexport type SimplifierUnitéNode = {\n\texplanation: ASTNode\n\tnodeKind: 'simplifier unité'\n}\n\nexport default function parseSimplifierUnité(v, context): SimplifierUnitéNode {\n\tconst explanation = parse(v.valeur, context)\n\treturn {\n\t\texplanation,\n\t\tnodeKind: 'simplifier unité',\n\t}\n}\n\nparseSimplifierUnité.nom = \"simplifier l'unité\" as const\n\nregisterEvaluationFunction('simplifier unité', function evaluate(node) {\n\tconst valeur = this.evaluateNode(node.explanation)\n\tconst nodeValue = valeur.nodeValue\n\tconst defaultReturn = {\n\t\t...valeur,\n\t\t...node,\n\t\texplanation: valeur,\n\t}\n\tif (nodeValue == null) {\n\t\treturn defaultReturn\n\t}\n\n\tif (!valeur.unit) {\n\t\treturn {\n\t\t\t...defaultReturn,\n\t\t\tunit: valeur.unit,\n\t\t}\n\t}\n\tconst unit = simplifyUnit(valeur.unit)\n\n\treturn {\n\t\t...defaultReturn,\n\t\tnodeValue:\n\t\t\ttypeof nodeValue === 'number' ?\n\t\t\t\tconvertUnit(valeur.unit, unit, nodeValue)\n\t\t\t:\tnodeValue,\n\t\tunit,\n\t}\n})\n","import { createParseInlinedMecanism } from './inlineMecanism'\n\nexport default createParseInlinedMecanism(\n\t'dans la situation',\n\t{\n\t\tvaleur: {},\n\t\t'dans la situation': {},\n\t},\n\t{\n\t\tcondition: {\n\t\t\tsi: { 'est non défini': 'dans la situation' },\n\t\t\talors: 'valeur',\n\t\t\tsinon: 'dans la situation',\n\t\t},\n\t},\n)\n","import { EvaluationFunction, PublicodesError } from '..'\nimport { ASTNode } from '../AST/types'\nimport { registerEvaluationFunction } from '../evaluationFunctions'\nimport { defaultNode, mergeAllMissing } from '../evaluationUtils'\nimport { convertNodeToUnit } from '../nodeUnits'\nimport parse from '../parse'\nimport { parseUnit } from '../units'\nimport {\n\tevaluatePlafondUntilActiveTranche,\n\tparseTranches,\n\tTrancheNodes,\n} from './trancheUtils'\n\nexport type TauxProgressifNode = {\n\texplanation: {\n\t\ttranches: TrancheNodes\n\t\tmultiplicateur: ASTNode\n\t\tassiette: ASTNode\n\t}\n\tnodeKind: 'taux progressif'\n}\nexport default function parseTauxProgressif(v, context): TauxProgressifNode {\n\tconst explanation = {\n\t\tassiette: parse(v.assiette, context),\n\t\tmultiplicateur:\n\t\t\tv.multiplicateur ? parse(v.multiplicateur, context) : defaultNode(1),\n\t\ttranches: parseTranches(v.tranches, context),\n\t} as TauxProgressifNode['explanation']\n\treturn {\n\t\texplanation,\n\t\tnodeKind: 'taux progressif',\n\t}\n}\n\nconst evaluate: EvaluationFunction<'taux progressif'> = function (node) {\n\tconst evaluate = this.evaluateNode.bind(this)\n\tconst assiette = this.evaluateNode(node.explanation.assiette)\n\tconst multiplicateur = this.evaluateNode(node.explanation.multiplicateur)\n\tif (multiplicateur.nodeValue === 0) {\n\t\tthrow new PublicodesError('EvaluationError', `Division by zero`, {\n\t\t\tdottedName: '',\n\t\t})\n\t}\n\tconst tranches = evaluatePlafondUntilActiveTranche.call(this, {\n\t\tparsedTranches: node.explanation.tranches,\n\t\tassiette,\n\t\tmultiplicateur,\n\t})\n\n\tconst evaluatedNode = {\n\t\t...node,\n\t\texplanation: {\n\t\t\ttranches,\n\t\t\tassiette,\n\t\t\tmultiplicateur,\n\t\t},\n\t\tunit: parseUnit('%'),\n\t}\n\n\tconst lastTranche = tranches[tranches.length - 1]\n\tif (\n\t\ttranches.every(({ isActive }) => isActive === false) ||\n\t\t(lastTranche.isActive && lastTranche.plafond.nodeValue === Infinity)\n\t) {\n\t\tconst taux = convertNodeToUnit(parseUnit('%'), evaluate(lastTranche.taux))\n\t\tconst { nodeValue, missingVariables } = taux\n\t\tlastTranche.taux = taux\n\t\tlastTranche.nodeValue = nodeValue\n\t\tlastTranche.missingVariables = missingVariables\n\t\treturn {\n\t\t\t...evaluatedNode,\n\t\t\tnodeValue,\n\t\t\tmissingVariables,\n\t\t}\n\t}\n\n\tif (\n\t\ttranches.every(({ isActive }) => isActive !== true) ||\n\t\ttypeof assiette.nodeValue !== 'number'\n\t) {\n\t\treturn {\n\t\t\t...evaluatedNode,\n\t\t\tnodeValue: undefined,\n\t\t\tmissingVariables: mergeAllMissing(tranches),\n\t\t}\n\t}\n\n\tconst activeTrancheIndex = tranches.findIndex(\n\t\t({ isActive }) => isActive === true,\n\t)\n\tconst activeTranche = tranches[activeTrancheIndex]\n\tactiveTranche.taux = convertNodeToUnit(\n\t\tparseUnit('%'),\n\t\tevaluate(activeTranche.taux),\n\t)\n\n\tconst previousTranche = tranches[activeTrancheIndex - 1]\n\tif (previousTranche) {\n\t\tpreviousTranche.taux = convertNodeToUnit(\n\t\t\tparseUnit('%'),\n\t\t\tevaluate(previousTranche.taux),\n\t\t)\n\t\tpreviousTranche.isActive = true\n\t}\n\tconst previousTaux =\n\t\tpreviousTranche ? previousTranche.taux : activeTranche.taux\n\tconst calculationValues = [previousTaux, activeTranche.taux]\n\tif (calculationValues.some((n) => n.nodeValue === undefined)) {\n\t\tactiveTranche.nodeValue = undefined\n\t\treturn {\n\t\t\t...evaluatedNode,\n\t\t\tnodeValue: undefined,\n\t\t\tmissingVariables: mergeAllMissing(calculationValues),\n\t\t}\n\t}\n\n\tconst lowerTaux = previousTaux.nodeValue\n\tconst upperTaux = activeTranche.taux.nodeValue\n\tconst plancher = activeTranche.plancherValue\n\tconst plafond = activeTranche.plafondValue\n\tconst coeff = (upperTaux - lowerTaux) / (plafond - plancher)\n\tconst nodeValue = lowerTaux + (assiette.nodeValue - plancher) * coeff\n\tactiveTranche.nodeValue = nodeValue\n\treturn {\n\t\t...evaluatedNode,\n\t\tnodeValue,\n\t\tmissingVariables: {},\n\t}\n}\n\nregisterEvaluationFunction('taux progressif', evaluate)\n","import { ASTNode, formatValue } from '..'\nimport { registerEvaluationFunction } from '../evaluationFunctions'\nimport { mergeAllMissing } from '../evaluationUtils'\nimport parse from '../parse'\n\nconst NAME = 'texte' as const\n\nexport type TexteNode = {\n\texplanation: Array<ASTNode | string>\n\tnodeKind: typeof NAME\n}\n\nexport default function parseTexte(texte: string, context): TexteNode {\n\tconst explanation = [] as TexteNode['explanation']\n\tlet lastIndex = 0\n\tfor (const { 0: expression, index } of texte.matchAll(/{{(.|\\n)*?}}/g)) {\n\t\tconst publicodeExpression = expression.slice(2, -2).trim()\n\t\tconst parsedNode = parse(publicodeExpression, context)\n\t\texplanation.push(texte.substring(lastIndex, index), parsedNode)\n\t\tlastIndex = (index ?? 0) + expression.length\n\t}\n\texplanation.push(texte.slice(lastIndex))\n\treturn {\n\t\tnodeKind: NAME,\n\t\texplanation,\n\t}\n}\nparseTexte.nom = NAME\n\nregisterEvaluationFunction(NAME, function evaluate(node) {\n\tconst explanation = node.explanation.map((element) =>\n\t\ttypeof element === 'string' ? element : this.evaluateNode(element),\n\t)\n\n\treturn {\n\t\t...node,\n\t\texplanation,\n\t\tmissingVariables: mergeAllMissing(\n\t\t\tnode.explanation.filter(\n\t\t\t\t(element) => typeof element !== 'string',\n\t\t\t) as Array<ASTNode>,\n\t\t),\n\t\tnodeValue: explanation\n\t\t\t.map((element) =>\n\t\t\t\ttypeof element === 'string' ? element : formatValue(element),\n\t\t\t)\n\t\t\t.join(''),\n\t}\n})\n","import { PublicodesExpression } from '..'\nimport { createParseInlinedMecanismWithArray } from './inlineMecanism'\n\nexport default createParseInlinedMecanismWithArray(\n\t'toutes ces conditions',\n\t{\n\t\tvaleur: { type: 'liste' },\n\t},\n\t({ valeur }) =>\n\t\t(valeur as Array<PublicodesExpression>).reduce(\n\t\t\t(acc, value) => ({ et: [acc, value] }),\n\t\t\t'oui',\n\t\t),\n)\n","import { PublicodesExpression } from '..'\nimport { createParseInlinedMecanismWithArray } from './inlineMecanism'\n\nexport default createParseInlinedMecanismWithArray(\n\t'une de ces conditions',\n\t{\n\t\tvaleur: { type: 'liste' },\n\t},\n\t({ valeur }) =>\n\t\t(valeur as Array<PublicodesExpression>).reduce(\n\t\t\t(acc, value) => ({ ou: [acc, value] }),\n\t\t\t'non',\n\t\t),\n)\n","import { ASTNode, Unit } from '../AST/types'\nimport { warning } from '../error'\nimport { registerEvaluationFunction } from '../evaluationFunctions'\nimport parse from '../parse'\nimport { convertUnit, parseUnit } from '../units'\n\nexport type UnitéNode = {\n\tunit: Unit\n\texplanation: ASTNode\n\tnodeKind: 'unité'\n}\n\nexport default function parseUnité(v, context): UnitéNode {\n\tconst explanation = parse(v.valeur, context)\n\tconst unit = parseUnit(v.unité, context.getUnitKey)\n\n\treturn {\n\t\texplanation,\n\t\tunit,\n\t\tnodeKind: parseUnité.nom,\n\t}\n}\n\nparseUnité.nom = 'unité' as const\n\nregisterEvaluationFunction(parseUnité.nom, function evaluate(node) {\n\tconst valeur = this.evaluateNode(node.explanation)\n\n\tlet nodeValue = valeur.nodeValue\n\tif (nodeValue !== null && 'unit' in node) {\n\t\ttry {\n\t\t\tnodeValue = convertUnit(\n\t\t\t\tvaleur.unit,\n\t\t\t\tnode.unit,\n\t\t\t\tvaleur.nodeValue as number,\n\t\t\t)\n\t\t} catch (e) {\n\t\t\twarning(\n\t\t\t\tthis.context.logger,\n\t\t\t\t\"Erreur lors de la conversion d'unité explicite\",\n\t\t\t\t{ dottedName: this.cache._meta.evaluationRuleStack[0] },\n\t\t\t\te,\n\t\t\t)\n\t\t}\n\t}\n\n\treturn {\n\t\t...node,\n\t\tnodeValue,\n\t\texplanation: valeur,\n\t\tmissingVariables: valeur.missingVariables,\n\t}\n})\n","import { ASTNode } from '../AST/types'\nimport { registerEvaluationFunction } from '../evaluationFunctions'\nimport { mergeMissing } from '../evaluationUtils'\nimport parse from '../parse'\n\nexport type VariableManquanteNode = {\n\tmissingVariable: string\n\texplanation: ASTNode\n\tnodeKind: 'variable manquante'\n}\n\nexport default function parseVariableManquante(\n\tv,\n\tcontext,\n): VariableManquanteNode {\n\treturn {\n\t\tmissingVariable: v['variable manquante'],\n\t\tnodeKind: parseVariableManquante.nom,\n\t\texplanation: parse(v.valeur, context),\n\t}\n}\n\nparseVariableManquante.nom = 'variable manquante' as const\n\nregisterEvaluationFunction(parseVariableManquante.nom, function evaluate(node) {\n\tconst valeur = this.evaluateNode(node.explanation)\n\n\tconst maxMissingScore = Object.values(valeur.missingVariables).reduce<number>(\n\t\t(a, b) => (a > b ? a : b),\n\t\t0,\n\t)\n\n\treturn {\n\t\t...node,\n\t\tnodeValue: valeur.nodeValue,\n\t\tunit: valeur.unit,\n\t\texplanation: valeur,\n\t\tmissingVariables: mergeMissing(valeur.missingVariables, {\n\t\t\t[node.missingVariable]: maxMissingScore + 1,\n\t\t}),\n\t}\n})\n","import { EvaluationFunction } from '..'\nimport { ASTNode, EvaluatedNode, Unit } from '../AST/types'\nimport { warning } from '../error'\nimport { registerEvaluationFunction } from '../evaluationFunctions'\nimport { bonus, defaultNode, mergeMissing } from '../evaluationUtils'\nimport { convertNodeToUnit } from '../nodeUnits'\nimport parse from '../parse'\n\nexport type VariationNode = {\n\texplanation: Array<{\n\t\tcondition: ASTNode\n\t\tconsequence: ASTNode\n\t\tsatisfied?: boolean\n\t}>\n\tnodeKind: 'variations'\n}\n\nexport default function parseVariations(v, context): VariationNode {\n\tconst explanation = v.map(({ si, alors, sinon }) =>\n\t\tsinon !== undefined ?\n\t\t\t{ consequence: parse(sinon, context), condition: defaultNode(true) }\n\t\t:\t{ consequence: parse(alors, context), condition: parse(si, context) },\n\t)\n\n\treturn {\n\t\texplanation,\n\t\tnodeKind: 'variations',\n\t}\n}\n\nconst evaluate: EvaluationFunction<'variations'> = function (node) {\n\tconst [nodeValue, explanation, unit] = node.explanation.reduce<\n\t\t[\n\t\t\tEvaluatedNode['nodeValue'],\n\t\t\tVariationNode['explanation'],\n\t\t\tUnit | undefined,\n\t\t\tboolean | undefined,\n\t\t]\n\t>(\n\t\t(\n\t\t\t[evaluation, explanations, unit, previousConditions],\n\t\t\t{ condition, consequence },\n\t\t\ti: number,\n\t\t) => {\n\t\t\tif (previousConditions === true) {\n\t\t\t\treturn [\n\t\t\t\t\tevaluation,\n\t\t\t\t\t[...explanations, { condition, consequence }],\n\t\t\t\t\tunit,\n\t\t\t\t\tpreviousConditions,\n\t\t\t\t]\n\t\t\t}\n\t\t\tconst evaluatedCondition = this.evaluateNode(condition)\n\t\t\tconst currentCondition =\n\t\t\t\tpreviousConditions === undefined ? previousConditions : (\n\t\t\t\t\t!previousConditions &&\n\t\t\t\t\t(evaluatedCondition.nodeValue === undefined ?\n\t\t\t\t\t\tundefined\n\t\t\t\t\t:\tevaluatedCondition.nodeValue !== false &&\n\t\t\t\t\t\tevaluatedCondition.nodeValue !== null)\n\t\t\t\t)\n\n\t\t\tif (currentCondition === false || currentCondition === null) {\n\t\t\t\treturn [\n\t\t\t\t\tevaluation,\n\t\t\t\t\t[...explanations, { condition: evaluatedCondition, consequence }],\n\t\t\t\t\tunit,\n\t\t\t\t\tpreviousConditions,\n\t\t\t\t]\n\t\t\t}\n\t\t\tlet evaluatedConsequence: EvaluatedNode | undefined = undefined\n\t\t\tif (\n\t\t\t\tevaluatedCondition.nodeValue !== false &&\n\t\t\t\tevaluatedCondition.nodeValue !== null\n\t\t\t) {\n\t\t\t\tevaluatedConsequence = this.evaluateNode(consequence!)\n\t\t\t\tif (unit) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tevaluatedConsequence = convertNodeToUnit(\n\t\t\t\t\t\t\tunit,\n\t\t\t\t\t\t\tevaluatedConsequence!,\n\t\t\t\t\t\t)\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\twarning(\n\t\t\t\t\t\t\tthis.context.logger,\n\t\t\t\t\t\t\t`L'unité de la branche n° ${\n\t\t\t\t\t\t\t\ti + 1\n\t\t\t\t\t\t\t} du mécanisme 'variations' n'est pas compatible avec celle d'une branche précédente`,\n\t\t\t\t\t\t\t{ dottedName: this.cache._meta.evaluationRuleStack[0] },\n\t\t\t\t\t\t\te,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn [\n\t\t\t\tcurrentCondition && evaluatedConsequence?.nodeValue,\n\t\t\t\t[\n\t\t\t\t\t...explanations,\n\t\t\t\t\t{\n\t\t\t\t\t\tcondition: evaluatedCondition,\n\t\t\t\t\t\tconsequence: evaluatedConsequence ?? consequence,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tunit || evaluatedConsequence?.unit,\n\t\t\t\tpreviousConditions || currentCondition,\n\t\t\t]\n\t\t},\n\t\t[null, [], undefined, false],\n\t)\n\n\treturn {\n\t\t...node,\n\t\tnodeValue,\n\t\t...(unit !== undefined && { unit }),\n\t\texplanation,\n\t\tmissingVariables: explanation.reduce(\n\t\t\t(values, { condition, consequence }) =>\n\t\t\t\tmergeMissing(\n\t\t\t\t\tvalues,\n\t\t\t\t\tmergeMissing(\n\t\t\t\t\t\tbonus((condition as EvaluatedNode).missingVariables),\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\t'nodeValue' in condition &&\n\t\t\t\t\t\t\t\tcondition.nodeValue !== false &&\n\t\t\t\t\t\t\t\tcondition.nodeValue !== null\n\t\t\t\t\t\t) ?\n\t\t\t\t\t\t\t(consequence as EvaluatedNode).missingVariables\n\t\t\t\t\t\t:\t{},\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t{},\n\t\t),\n\t}\n}\n\nregisterEvaluationFunction('variations', evaluate)\n","import nearley from 'nearley'\nimport { PublicodesError } from './error'\nimport grammar from './grammar.codegen'\n\n// TODO: nearley is currently exported as a CommonJS module which is why we need\n// to destructure the default import instead of directly importing the symbols\n// we need. This is sub-optimal because we our bundler will not tree-shake\n// unused nearley symbols.\n// https://github.com/kach/nearley/issues/535\nconst { Grammar, Parser } = nearley\n\nconst compiledGrammar = Grammar.fromCompiled(grammar)\n\nconst parser = new Parser(compiledGrammar)\nconst initialState = parser.save()\n\ntype BinaryOp =\n\t| { '+': [ExprAST, ExprAST] }\n\t| { '-': [ExprAST, ExprAST] }\n\t| { '*': [ExprAST, ExprAST] }\n\t| { '/': [ExprAST, ExprAST] }\n\t| { '>': [ExprAST, ExprAST] }\n\t| { '<': [ExprAST, ExprAST] }\n\t| { '>=': [ExprAST, ExprAST] }\n\t| { '<=': [ExprAST, ExprAST] }\n\t| { '=': [ExprAST, ExprAST] }\n\t| { '!=': [ExprAST, ExprAST] }\n\ntype UnaryOp = { '-': [{ value: 0 }, ExprAST] }\n\n/** AST of a publicodes expression. */\nexport type ExprAST =\n\t| BinaryOp\n\t| UnaryOp\n\t| { variable: string }\n\t| { constant: { type: 'number'; nodeValue: number }; unité?: string }\n\t| { constant: { type: 'boolean'; nodeValue: boolean } }\n\t| { constant: { type: 'string' | 'date'; nodeValue: string } }\n\n/**\n * Parse a publicodes expression into an JSON object representing the AST.\n *\n * The parsing is done with the [nearley](https://nearley.js.org/) parser\n *\n * @param rawNode The expression to parse\n * @param dottedName The dottedName of the rule being parsed\n *\n * @returns The parsing result as a JSON object\n *\n * @throws A `SyntaxError` if the expression is invalid\n * @throws A `PublicodesInternalError` if the parser is unable to parse the expression\n *\n * @example\n * ```ts\n * parseExpression('20.3 * nombre', 'foo . bar')\n * // returns { \"*\": [ { constant: { type: \"number\", nodeValue: 20.3 } }, { variable:\"nombre\" } ] }\n * ```\n */\nexport function parseExpression(rawNode: string, dottedName: string): ExprAST {\n\t/* Strings correspond to infix expressions.\n\t * Indeed, a subset of expressions like simple arithmetic operations `3 + (quantity * 2)` or like `salary [month]` are more explicit that their prefixed counterparts.\n\t * This function makes them prefixed operations. */\n\tconst singleLineExpression = (rawNode + '').replace(/\\s*\\n\\s*/g, ' ').trim()\n\n\ttry {\n\t\tparser.restore(initialState)\n\t\tconst [parseResult] = parser.feed(singleLineExpression).results\n\n\t\tif (parseResult == null) {\n\t\t\tthrow new PublicodesError(\n\t\t\t\t'InternalError',\n\t\t\t\t`\nUn problème est survenu lors du parsing de l'expression \\`${singleLineExpression}\\` :\n\n\tle parseur Nearley n'a pas réussi à parser l'expression.\n`,\n\t\t\t\t{ dottedName },\n\t\t\t)\n\t\t}\n\t\treturn parseResult\n\t} catch (e) {\n\t\tif (e instanceof PublicodesError) {\n\t\t\tthrow e\n\t\t}\n\t\tthrow new PublicodesError(\n\t\t\t'SyntaxError',\n\t\t\t`\\`${singleLineExpression}\\` n'est pas une expression valide`,\n\t\t\t{ dottedName },\n\t\t\te,\n\t\t)\n\t}\n}\n","/* Those are postprocessor functions for the Nearley grammar.ne.\nThe advantage of putting them here is to get prettier's JS formatting, since Nealrey doesn't support it https://github.com/kach/nearley/issues/310 */\nimport { normalizeDateString } from './date.ts'\n\nexport const binaryOperation = ([A, , operator, , B]) => ({\n\t[operator.value.toLowerCase()]: [A, B],\n})\n\nexport const unaryOperation = ([operator, , A]) => ({\n\t[operator]: [number([{ value: '0' }]), A],\n})\n\nexport const variable = (arg) => {\n\treturn {\n\t\tvariable: arg.value,\n\t}\n}\n\nexport const JSONObject = ([{ value }]) => {\n\tvalue\n\t// TODO\n}\nexport const number = ([{ value }]) => ({\n\tconstant: {\n\t\ttype: 'number',\n\t\tnodeValue: parseFloat(value),\n\t},\n})\n\nexport const numberWithUnit = (value) => ({\n\t...number(value),\n\tunité: value[2].value,\n})\n\nexport const date = ([{ value }]) => {\n\treturn {\n\t\tconstant: {\n\t\t\ttype: 'date',\n\t\t\tnodeValue: normalizeDateString(value),\n\t\t},\n\t}\n}\n\nexport const boolean = ([{ value }]) => ({\n\tconstant: {\n\t\ttype: 'boolean',\n\t\tnodeValue: value === 'oui',\n\t},\n})\n\nexport const string = ([{ value }]) => ({\n\tconstant: {\n\t\ttype: 'string',\n\t\tnodeValue: value.slice(1, -1),\n\t},\n})\n","// Generated automatically by nearley, version 2.20.1\n// http://github.com/Hardmath123/nearley\nfunction id(x) { return x[0]; }\n\nimport {\n  string, date, variable, binaryOperation, unaryOperation, boolean, number, numberWithUnit, JSONObject\n} from './grammarFunctions.js';\nimport moo from \"moo\";\n\n\nconst dateRegexp = `(?:(?:0?[1-9]|[12][0-9]|3[01])\\\\/)?(?:0?[1-9]|1[012])\\\\/\\\\d{4}`\nconst letter = '[a-zA-Z\\u00C0-\\u017F€$%°]';\nconst letterOrNumber = '[a-zA-Z\\u00C0-\\u017F0-9\\',]';\nconst word = `${letter}(?:[-']?${letterOrNumber}+)*`;\n\nconst numberRegExp = '-?(?:[1-9][0-9]+|[0-9])(?:\\\\.[0-9]+)?';\nconst lexer = moo.compile({\n  '(': '(',\n  ')': ')',\n  '[': '[',\n  ']': ']',\n  comparison: ['>','<','>=','<=','=','!='],\n  date: new RegExp(dateRegexp),\n\tboolean: ['oui','non'],\n  number: new RegExp(numberRegExp),\n  word:  new RegExp(word),\n  string: [/'.*'/, /\".*\"/],\n  parentSelector: \"^\",\n  JSONObject: /{.*}/,\n  additionSubstraction: /[\\+-]/,\n  multiplicationDivision: ['*','/'],\n  dot: ' . ',\n  \".\": '.',\n  space: { match: /[\\s]+/, lineBreaks: true },\n});\n\nconst join = (args) => ({value: (args.map(x => x && x.value).join(\"\"))})\nconst flattenJoin = (args) => join(args.flat())\nlet Lexer = lexer;\nlet ParserRules = [\n    {\"name\": \"main\", \"symbols\": [\"Comparison\"], \"postprocess\": id},\n    {\"name\": \"main\", \"symbols\": [\"NumericValue\"], \"postprocess\": id},\n    {\"name\": \"main\", \"symbols\": [\"Date\"], \"postprocess\": id},\n    {\"name\": \"main\", \"symbols\": [\"NonNumericTerminal\"], \"postprocess\": id},\n    {\"name\": \"main\", \"symbols\": [\"JSONObject\"], \"postprocess\": id},\n    {\"name\": \"NumericValue\", \"symbols\": [\"AdditionSubstraction\"], \"postprocess\": id},\n    {\"name\": \"NumericValue\", \"symbols\": [\"Negation\"], \"postprocess\": id},\n    {\"name\": \"NumericTerminal\", \"symbols\": [\"Variable\"], \"postprocess\": id},\n    {\"name\": \"NumericTerminal\", \"symbols\": [\"number\"], \"postprocess\": id},\n    {\"name\": \"Negation\", \"symbols\": [{\"literal\":\"-\"}, (lexer.has(\"space\") ? {type: \"space\"} : space), \"Parentheses\"], \"postprocess\": unaryOperation},\n    {\"name\": \"Parentheses\", \"symbols\": [{\"literal\":\"(\"}, (lexer.has(\"space\") ? {type: \"space\"} : space), \"NumericValue\", (lexer.has(\"space\") ? {type: \"space\"} : space), {\"literal\":\")\"}], \"postprocess\": ([,,e]) => e},\n    {\"name\": \"Parentheses\", \"symbols\": [{\"literal\":\"(\"}, \"NumericValue\", {\"literal\":\")\"}], \"postprocess\": ([,e]) => e},\n    {\"name\": \"Parentheses\", \"symbols\": [\"NumericTerminal\"], \"postprocess\": id},\n    {\"name\": \"Date\", \"symbols\": [\"Variable\"], \"postprocess\": id},\n    {\"name\": \"Date\", \"symbols\": [(lexer.has(\"date\") ? {type: \"date\"} : date)], \"postprocess\": date},\n    {\"name\": \"Comparison\", \"symbols\": [\"Comparable\", (lexer.has(\"space\") ? {type: \"space\"} : space), (lexer.has(\"comparison\") ? {type: \"comparison\"} : comparison), (lexer.has(\"space\") ? {type: \"space\"} : space), \"Comparable\"], \"postprocess\": binaryOperation},\n    {\"name\": \"Comparison\", \"symbols\": [\"Date\", (lexer.has(\"space\") ? {type: \"space\"} : space), (lexer.has(\"comparison\") ? {type: \"comparison\"} : comparison), (lexer.has(\"space\") ? {type: \"space\"} : space), \"Date\"], \"postprocess\": binaryOperation},\n    {\"name\": \"Comparable$subexpression$1\", \"symbols\": [\"AdditionSubstraction\"]},\n    {\"name\": \"Comparable$subexpression$1\", \"symbols\": [\"NonNumericTerminal\"]},\n    {\"name\": \"Comparable\", \"symbols\": [\"Comparable$subexpression$1\"], \"postprocess\": ([[e]]) => e},\n    {\"name\": \"NonNumericTerminal\", \"symbols\": [(lexer.has(\"boolean\") ? {type: \"boolean\"} : boolean)], \"postprocess\": boolean},\n    {\"name\": \"NonNumericTerminal\", \"symbols\": [(lexer.has(\"string\") ? {type: \"string\"} : string)], \"postprocess\": string},\n    {\"name\": \"Variable\", \"symbols\": [\"VariableWithoutParentSelector\"], \"postprocess\": ([x]) => variable(x)},\n    {\"name\": \"Variable$ebnf$1\", \"symbols\": []},\n    {\"name\": \"Variable$ebnf$1$subexpression$1\", \"symbols\": [(lexer.has(\"parentSelector\") ? {type: \"parentSelector\"} : parentSelector), (lexer.has(\"dot\") ? {type: \"dot\"} : dot)], \"postprocess\": join},\n    {\"name\": \"Variable$ebnf$1\", \"symbols\": [\"Variable$ebnf$1\", \"Variable$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"Variable\", \"symbols\": [\"Variable$ebnf$1\", \"VariableWithoutParentSelector\"], \"postprocess\": x => variable(flattenJoin(x))},\n    {\"name\": \"VariableWithoutParentSelector$ebnf$1\", \"symbols\": []},\n    {\"name\": \"VariableWithoutParentSelector$ebnf$1$subexpression$1\", \"symbols\": [(lexer.has(\"dot\") ? {type: \"dot\"} : dot), \"Words\"], \"postprocess\": join},\n    {\"name\": \"VariableWithoutParentSelector$ebnf$1\", \"symbols\": [\"VariableWithoutParentSelector$ebnf$1\", \"VariableWithoutParentSelector$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"VariableWithoutParentSelector\", \"symbols\": [\"Words\", \"VariableWithoutParentSelector$ebnf$1\"], \"postprocess\": x => flattenJoin(x)},\n    {\"name\": \"Words$ebnf$1$subexpression$1$ebnf$1\", \"symbols\": [(lexer.has(\"space\") ? {type: \"space\"} : space)], \"postprocess\": id},\n    {\"name\": \"Words$ebnf$1$subexpression$1$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"Words$ebnf$1$subexpression$1\", \"symbols\": [\"Words$ebnf$1$subexpression$1$ebnf$1\", \"WordOrNumber\"], \"postprocess\": join},\n    {\"name\": \"Words$ebnf$1\", \"symbols\": [\"Words$ebnf$1$subexpression$1\"]},\n    {\"name\": \"Words$ebnf$1$subexpression$2$ebnf$1\", \"symbols\": [(lexer.has(\"space\") ? {type: \"space\"} : space)], \"postprocess\": id},\n    {\"name\": \"Words$ebnf$1$subexpression$2$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"Words$ebnf$1$subexpression$2\", \"symbols\": [\"Words$ebnf$1$subexpression$2$ebnf$1\", \"WordOrNumber\"], \"postprocess\": join},\n    {\"name\": \"Words$ebnf$1\", \"symbols\": [\"Words$ebnf$1\", \"Words$ebnf$1$subexpression$2\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"Words\", \"symbols\": [\"WordOrKeyword\", \"Words$ebnf$1\"], \"postprocess\": flattenJoin},\n    {\"name\": \"Words\", \"symbols\": [(lexer.has(\"word\") ? {type: \"word\"} : word)], \"postprocess\": id},\n    {\"name\": \"WordOrKeyword\", \"symbols\": [(lexer.has(\"word\") ? {type: \"word\"} : word)], \"postprocess\": id},\n    {\"name\": \"WordOrKeyword\", \"symbols\": [(lexer.has(\"boolean\") ? {type: \"boolean\"} : boolean)], \"postprocess\": id},\n    {\"name\": \"WordOrNumber\", \"symbols\": [\"WordOrKeyword\"], \"postprocess\": id},\n    {\"name\": \"WordOrNumber\", \"symbols\": [(lexer.has(\"number\") ? {type: \"number\"} : number)], \"postprocess\": id},\n    {\"name\": \"Unit$ebnf$1\", \"symbols\": []},\n    {\"name\": \"Unit$ebnf$1\", \"symbols\": [\"Unit$ebnf$1\", \"UnitNumerator\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"Unit$ebnf$2\", \"symbols\": []},\n    {\"name\": \"Unit$ebnf$2\", \"symbols\": [\"Unit$ebnf$2\", \"UnitDenominator\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"Unit\", \"symbols\": [\"Unit$ebnf$1\", \"Unit$ebnf$2\"], \"postprocess\": flattenJoin},\n    {\"name\": \"UnitNumerator\", \"symbols\": [\"Words\"], \"postprocess\": id},\n    {\"name\": \"UnitNumerator\", \"symbols\": [{\"literal\":\".\"}, \"UnitNumerator\"], \"postprocess\": join},\n    {\"name\": \"UnitDenominator$ebnf$1\", \"symbols\": []},\n    {\"name\": \"UnitDenominator$ebnf$1$subexpression$1\", \"symbols\": [(lexer.has(\"space\") ? {type: \"space\"} : space)]},\n    {\"name\": \"UnitDenominator$ebnf$1\", \"symbols\": [\"UnitDenominator$ebnf$1\", \"UnitDenominator$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"UnitDenominator$ebnf$2\", \"symbols\": [\"UnitNumerator\"]},\n    {\"name\": \"UnitDenominator$ebnf$2\", \"symbols\": [\"UnitDenominator$ebnf$2\", \"UnitNumerator\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"UnitDenominator\", \"symbols\": [\"UnitDenominator$ebnf$1\", {\"literal\":\"/\"}, \"UnitDenominator$ebnf$2\"], \"postprocess\": flattenJoin},\n    {\"name\": \"AdditionSubstraction\", \"symbols\": [\"AdditionSubstraction\", (lexer.has(\"space\") ? {type: \"space\"} : space), (lexer.has(\"additionSubstraction\") ? {type: \"additionSubstraction\"} : additionSubstraction), (lexer.has(\"space\") ? {type: \"space\"} : space), \"MultiplicationDivision\"], \"postprocess\": binaryOperation},\n    {\"name\": \"AdditionSubstraction\", \"symbols\": [\"MultiplicationDivision\"], \"postprocess\": id},\n    {\"name\": \"MultiplicationDivision\", \"symbols\": [\"MultiplicationDivision\", (lexer.has(\"space\") ? {type: \"space\"} : space), (lexer.has(\"multiplicationDivision\") ? {type: \"multiplicationDivision\"} : multiplicationDivision), (lexer.has(\"space\") ? {type: \"space\"} : space), \"Parentheses\"], \"postprocess\": binaryOperation},\n    {\"name\": \"MultiplicationDivision\", \"symbols\": [\"Parentheses\"], \"postprocess\": id},\n    {\"name\": \"number\", \"symbols\": [(lexer.has(\"number\") ? {type: \"number\"} : number)], \"postprocess\": number},\n    {\"name\": \"number$ebnf$1$subexpression$1\", \"symbols\": [(lexer.has(\"space\") ? {type: \"space\"} : space)]},\n    {\"name\": \"number$ebnf$1\", \"symbols\": [\"number$ebnf$1$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"number$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"number\", \"symbols\": [(lexer.has(\"number\") ? {type: \"number\"} : number), \"number$ebnf$1\", \"Unit\"], \"postprocess\": numberWithUnit},\n    {\"name\": \"JSONObject\", \"symbols\": [(lexer.has(\"JSONObject\") ? {type: \"JSONObject\"} : JSONObject)], \"postprocess\": JSONObject}\n];\nlet ParserStart = \"main\";\nexport default { Lexer, ParserRules, ParserStart };\n","import { PublicodesError, PublicodesInternalError } from './error'\nimport { registerEvaluationFunction } from './evaluationFunctions'\nimport { Context } from './parsePublicodes'\n\nexport type ReferenceNode = {\n\tnodeKind: 'reference'\n\tname: string\n\tcontextDottedName: string\n\tdottedName?: string\n\ttitle?: string\n\tacronym?: string\n}\n\nexport default function parseReference(\n\tv: string,\n\tcontext: Context,\n): ReferenceNode {\n\tif (!context.dottedName) {\n\t\tthrow new PublicodesError(\n\t\t\t'InternalError',\n\t\t\t\"Une référence ne peut pas exister en dehors d'une règle (`context.dottedName` est vide)\",\n\t\t\t{\n\t\t\t\tdottedName: v,\n\t\t\t},\n\t\t)\n\t}\n\tif (!v) {\n\t\tthrow new PublicodesError(\n\t\t\t'SyntaxError',\n\t\t\t'Une référence ne peut pas être vide',\n\t\t\t{\n\t\t\t\tdottedName: context.dottedName,\n\t\t\t},\n\t\t)\n\t}\n\n\treturn {\n\t\tnodeKind: 'reference',\n\t\tname: v,\n\t\tcontextDottedName: context.dottedName,\n\t}\n}\n\nregisterEvaluationFunction('reference', function evaluateReference(node) {\n\tif (!node.dottedName) {\n\t\tthrow new PublicodesInternalError(node)\n\t}\n\tconst explanation = this.evaluateNode(\n\t\tthis.context.parsedRules[node.dottedName],\n\t)\n\tdelete explanation.sourceMap\n\treturn {\n\t\t...explanation,\n\t\t...node,\n\t}\n})\n","import { ASTNode } from './AST/types'\nimport { PublicodesError } from './error'\nimport abattement from './mecanisms/abattement'\nimport applicable from './mecanisms/applicable'\nimport arrondi from './mecanisms/arrondi'\nimport avec from './mecanisms/avec'\nimport barème from './mecanisms/barème'\nimport condition from './mecanisms/condition'\nimport contexte from './mecanisms/contexte'\nimport durée from './mecanisms/durée'\nimport {\n\tparseEstApplicable,\n\tparseEstDéfini,\n\tparseEstNonDéfini,\n} from './mecanisms/est'\nimport { parseEstNonApplicable } from './mecanisms/est-non-applicable'\nimport grille from './mecanisms/grille'\nimport { mecanismInversion } from './mecanisms/inversion'\nimport { parseMaximumDe, parseMinimumDe } from './mecanisms/max-min'\nimport moyenne from './mecanisms/moyenne'\nimport nonApplicable from './mecanisms/non-applicable'\nimport { mecanismOnePossibility } from './mecanisms/one-possibility'\nimport operations from './mecanisms/operation'\nimport parDéfaut from './mecanisms/parDéfaut'\nimport plafond from './mecanisms/plafond'\nimport plancher from './mecanisms/plancher'\nimport produit from './mecanisms/product'\nimport résoudreRéférenceCirculaire from './mecanisms/résoudre-référence-circulaire'\nimport simplifierUnité from './mecanisms/simplifier-unité'\nimport situation from './mecanisms/situation'\nimport somme from './mecanisms/somme'\nimport tauxProgressif from './mecanisms/tauxProgressif'\nimport texte from './mecanisms/texte'\nimport toutesCesConditions from './mecanisms/toutes-ces-conditions'\nimport uneDeCesConditions from './mecanisms/une-de-ces-conditions'\nimport unité from './mecanisms/unité'\nimport variableManquante from './mecanisms/variablesManquantes'\nimport variations from './mecanisms/variations'\nimport { parseExpression } from './parseExpression'\nimport { Context } from './parsePublicodes'\nimport parseReference from './reference'\n\nexport default function parse(rawNode, context: Context): ASTNode {\n\tif (rawNode == undefined) {\n\t\tthrow new PublicodesError(\n\t\t\t'SyntaxError',\n\t\t\t`\n\tUne des valeurs de la formule est vide.\n\tVérifiez que tous les champs à droite des deux points sont remplis`,\n\t\t\t{ dottedName: context.dottedName },\n\t\t)\n\t}\n\tif (typeof rawNode === 'boolean') {\n\t\tthrow new PublicodesError(\n\t\t\t'SyntaxError',\n\t\t\t`\nLes valeurs booléennes true / false ne sont acceptées.\nUtilisez leur contrepartie française : 'oui' / 'non'`,\n\t\t\t{ dottedName: context.dottedName },\n\t\t)\n\t}\n\tconst node =\n\t\ttypeof rawNode === 'object' ? rawNode : (\n\t\t\tparseExpression(rawNode, context.dottedName)\n\t\t)\n\tif ('nodeKind' in node) {\n\t\treturn node\n\t}\n\n\treturn {\n\t\t...parseChainedMecanisms(node, context),\n\t\trawNode,\n\t}\n}\n\nfunction parseMecanism(rawNode, context: Context) {\n\tif (Array.isArray(rawNode)) {\n\t\tthrow new PublicodesError(\n\t\t\t'SyntaxError',\n\t\t\t`\nIl manque le nom du mécanisme pour le tableau : [${rawNode\n\t\t\t\t.map((x) => `'${x}'`)\n\t\t\t\t.join(', ')}]\nLes mécanisme possibles sont : 'somme', 'le maximum de', 'le minimum de', 'toutes ces conditions', 'une de ces conditions'.\n\t\t`,\n\t\t\t{ dottedName: context.dottedName },\n\t\t)\n\t}\n\n\tconst keys = Object.keys(rawNode)\n\tif (keys.length > 1) {\n\t\tthrow new PublicodesError(\n\t\t\t'SyntaxError',\n\t\t\t`\nLes mécanismes suivants se situent au même niveau : ${keys\n\t\t\t\t.map((x) => `'${x}'`)\n\t\t\t\t.join(', ')}\nCela vient probablement d'une erreur dans l'indentation\n\t`,\n\t\t\t{ dottedName: context.dottedName },\n\t\t)\n\t}\n\tif (keys.length === 0) {\n\t\treturn { nodeKind: 'constant', nodeValue: undefined }\n\t}\n\n\tconst mecanismName = keys[0]\n\tconst values = rawNode[mecanismName]\n\tconst parseFn = parseFunctions[mecanismName]\n\n\tif (!parseFn) {\n\t\tthrow new PublicodesError(\n\t\t\t'SyntaxError',\n\t\t\t`Le mécanisme \"${mecanismName}\" est inconnu.\n\nVérifiez qu'il n'y ait pas d'erreur dans l'orthographe du nom.`,\n\t\t\t{ dottedName: context.dottedName },\n\t\t)\n\t}\n\ttry {\n\t\treturn parseFn(values, context)\n\t} catch (e) {\n\t\tif (e instanceof PublicodesError) {\n\t\t\tthrow e\n\t\t}\n\t\tthrow new PublicodesError(\n\t\t\t'SyntaxError',\n\t\t\tmecanismName ?\n\t\t\t\t`➡️ Dans le mécanisme ${mecanismName}\n${e.message}`\n\t\t\t:\te.message,\n\t\t\t{ dottedName: context.dottedName },\n\t\t)\n\t}\n}\n\n// Chainable mecanisme in their composition order (first one is applyied first)\nconst chainableMecanisms = [\n\tcontexte,\n\tvariableManquante,\n\tavec,\n\tapplicable,\n\tnonApplicable,\n\tarrondi,\n\tunité,\n\tsimplifierUnité,\n\tplancher,\n\tplafond,\n\tparDéfaut,\n\tsituation,\n\trésoudreRéférenceCirculaire,\n\tabattement,\n]\n\nfunction parseChainedMecanisms(rawNode, context: Context): ASTNode {\n\tconst parseFn = chainableMecanisms.find((fn) => fn.nom in rawNode)\n\tif (!parseFn) {\n\t\treturn parseMecanism(rawNode, context)\n\t}\n\tconst { [parseFn.nom]: param, ...valeur } = rawNode\n\n\treturn parseMecanism(\n\t\t{\n\t\t\t[parseFn.nom]: {\n\t\t\t\tvaleur,\n\t\t\t\t[parseFn.nom]: param,\n\t\t\t},\n\t\t},\n\t\tcontext,\n\t)\n}\n\nconst parseFunctions = {\n\t...operations,\n\t...chainableMecanisms.reduce((acc, fn) => ({ [fn.nom]: fn, ...acc }), {}),\n\t'inversion numérique': mecanismInversion,\n\t'le maximum de': parseMaximumDe,\n\t'le minimum de': parseMinimumDe,\n\t'taux progressif': tauxProgressif,\n\t'toutes ces conditions': toutesCesConditions,\n\t'est non défini': parseEstNonDéfini,\n\t'est non applicable': parseEstNonApplicable,\n\t'est applicable': parseEstApplicable,\n\t'est défini': parseEstDéfini,\n\t'une de ces conditions': uneDeCesConditions,\n\t'une possibilité': mecanismOnePossibility,\n\tcondition,\n\tbarème,\n\tdurée,\n\tgrille,\n\tmultiplication: produit,\n\tproduit,\n\tsomme,\n\tmoyenne,\n\t[texte.nom]: texte,\n\tvaleur: parse,\n\tvariable: parseReference,\n\tvariations,\n\tconstant: (v) => ({\n\t\ttype: v.type,\n\t\t// In the documentation we want to display constants defined in the source\n\t\t// with their full precision. This is especially useful for percentages like\n\t\t// APEC 0,036 %.\n\t\tfullPrecision: true,\n\t\tisNullable: v.nodeValue == null,\n\t\tmissingVariables: {},\n\t\tnodeValue: v.nodeValue,\n\t\tnodeKind: 'constant',\n\t}),\n}\n\nexport const mecanismKeys = Object.keys(parseFunctions)\n","import { ParsedRules, PublicodesError } from '.'\nimport { makeASTTransformer, makeASTVisitor } from './AST'\nimport { ASTNode } from './AST/types'\nimport { PublicodesInternalError } from './error'\nimport { defaultNode, notApplicableNode } from './evaluationUtils'\nimport parse from './parse'\nimport { Context, ReferencesMaps, RulesReplacements } from './parsePublicodes'\nimport { Rule, RuleNode } from './rule'\nimport { updateReferencesMapsFromReferenceNode } from './ruleUtils'\nimport { mergeWithArray } from './utils'\n\nexport type ReplacementRule = {\n\tnodeKind: 'replacementRule'\n\tdefinitionRule: ASTNode<'reference'> & { dottedName: string }\n\treplacedReference: ASTNode<'reference'>\n\tpriority?: number\n\twhiteListedNames: Array<ASTNode<'reference'>>\n\trawNode: any\n\tblackListedNames: Array<ASTNode<'reference'>>\n\tremplacementRuleId: number\n\treplaceByNonApplicable: boolean\n}\n\n// Replacements depend on the context and their evaluation implies using\n// \"variations\" node everywhere there is a reference to the original rule.\n// However for performance reason we want to mutualize identical \"variations\"\n// nodes instead of duplicating them, to avoid wasteful computations.\n//\n// The implementation works by first attributing an identifier for each\n// replacementRule. We then use this identifier to create a cache key that\n// represents the combinaison of applicables replacements for a given reference.\n// For example if replacements 12, 13 et 643 are applicable we use the key\n// `12-13-643` as the cache identifier in the `inlineReplacements` function.\nlet remplacementRuleId = 0\nconst cache = {}\n\nexport function parseReplacements(\n\treplacements: Rule['remplace'],\n\tcontext: Context,\n): Array<ReplacementRule> {\n\tif (!replacements) {\n\t\treturn []\n\t}\n\n\treturn (Array.isArray(replacements) ? replacements : [replacements]).map(\n\t\t(replacement) => {\n\t\t\tif (typeof replacement === 'string') {\n\t\t\t\treplacement = { 'références à': replacement }\n\t\t\t}\n\n\t\t\tconst replacedReference = parse(replacement['références à'], context)\n\n\t\t\tconst [whiteListedNames, blackListedNames] = [\n\t\t\t\treplacement.dans ?? [],\n\t\t\t\treplacement['sauf dans'] ?? [],\n\t\t\t]\n\t\t\t\t.map((dottedName) =>\n\t\t\t\t\tArray.isArray(dottedName) ? dottedName : [dottedName],\n\t\t\t\t)\n\t\t\t\t.map((refs) => refs.map((ref) => parse(ref, context)))\n\t\t\tif (\n\t\t\t\treplacement.priorité != null &&\n\t\t\t\t(typeof replacement.priorité !== 'number' || replacement.priorité < 0)\n\t\t\t) {\n\t\t\t\tthrow new PublicodesError(\n\t\t\t\t\t'SyntaxError',\n\t\t\t\t\t'La priorité du remplacement doit être un nombre positif',\n\t\t\t\t\tcontext,\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tnodeKind: 'replacementRule',\n\t\t\t\trawNode: replacement,\n\t\t\t\tpriority: replacement.priorité,\n\t\t\t\tdefinitionRule: parse(context.dottedName, context),\n\t\t\t\treplacedReference,\n\t\t\t\treplaceByNonApplicable: false,\n\t\t\t\twhiteListedNames,\n\t\t\t\tblackListedNames,\n\t\t\t\tremplacementRuleId: remplacementRuleId++,\n\t\t\t} as ReplacementRule\n\t\t},\n\t)\n}\n\nexport function parseRendNonApplicable(\n\trules: Rule['rend non applicable'],\n\tcontext: Context,\n): Array<ReplacementRule> {\n\tconst rendNonApplicableReplacements = parseReplacements(rules, context)\n\trendNonApplicableReplacements.forEach(\n\t\t(r) => (r.replaceByNonApplicable = true),\n\t)\n\treturn rendNonApplicableReplacements\n}\n\nexport function getReplacements(\n\tparsedRules: Record<string, RuleNode>,\n): RulesReplacements<string> {\n\tconst ret = {}\n\tfor (const dottedName in parsedRules) {\n\t\tconst rule = parsedRules[dottedName]\n\t\tfor (const replacement of rule.replacements) {\n\t\t\tif (!replacement.replacedReference.dottedName) {\n\t\t\t\tthrow new PublicodesInternalError(replacement)\n\t\t\t}\n\t\t\tconst key = replacement.replacedReference.dottedName\n\t\t\tret[key] = [...(ret[key] ?? []), replacement]\n\t\t}\n\t}\n\n\treturn ret\n}\n\nexport function inlineReplacements<\n\tNewNames extends string,\n\tPreviousNames extends string,\n>({\n\tnewRules,\n\tpreviousReplacements,\n\tparsedRules,\n\treferencesMaps,\n}: {\n\tnewRules: ParsedRules<NewNames>\n\tpreviousReplacements: RulesReplacements<PreviousNames>\n\tparsedRules: ParsedRules<PreviousNames | NewNames>\n\treferencesMaps: ReferencesMaps<NewNames | PreviousNames>\n}): [\n\tParsedRules<NewNames | PreviousNames>,\n\tRulesReplacements<NewNames | PreviousNames>,\n] {\n\ttype Names = NewNames | PreviousNames\n\tconst newReplacements = getReplacements(newRules) as RulesReplacements<Names>\n\n\tconst ruleNamesWithNewReplacements = new Set([]) as Set<Names>\n\tfor (const replacedReference in newReplacements) {\n\t\tconst rulesThatUse =\n\t\t\treferencesMaps.rulesThatUse.get(replacedReference as NewNames | Names) ??\n\t\t\t[]\n\n\t\tfor (const value of rulesThatUse) {\n\t\t\truleNamesWithNewReplacements.add(value)\n\t\t}\n\t}\n\n\tconst newRuleNamesWithPreviousReplacements: Set<NewNames> = new Set(\n\t\t(Object.keys(newRules) as Array<NewNames>).filter((ruleName) =>\n\t\t\t[...(referencesMaps.referencesIn.get(ruleName) ?? new Set())].some(\n\t\t\t\t(reference) =>\n\t\t\t\t\t(previousReplacements[reference as PreviousNames] ?? []).length,\n\t\t\t),\n\t\t),\n\t)\n\n\tconst replacements = mergeWithArray(previousReplacements, newReplacements)\n\tif (\n\t\t!newRuleNamesWithPreviousReplacements.size &&\n\t\t!ruleNamesWithNewReplacements.size\n\t) {\n\t\treturn [parsedRules, replacements]\n\t}\n\n\tconst inlinePreviousReplacement = makeReplacementInliner(\n\t\tpreviousReplacements,\n\t\treferencesMaps,\n\t)\n\tconst inlineNewReplacement = makeReplacementInliner(\n\t\tnewReplacements,\n\t\treferencesMaps,\n\t)\n\n\tnewRuleNamesWithPreviousReplacements.forEach((name) => {\n\t\tparsedRules[name] = inlinePreviousReplacement(\n\t\t\tparsedRules[name],\n\t\t) as RuleNode<Names>\n\t})\n\truleNamesWithNewReplacements.forEach((name) => {\n\t\tparsedRules[name] = inlineNewReplacement(\n\t\t\tparsedRules[name],\n\t\t) as RuleNode<Names>\n\t})\n\n\treturn [parsedRules, replacements]\n}\n\nexport function makeReplacementInliner(\n\treplacements: RulesReplacements<string>,\n\treferencesMaps: ReferencesMaps<string>,\n): (n: ASTNode) => ASTNode {\n\treturn makeASTTransformer((node, transform) => {\n\t\tif (\n\t\t\tnode.nodeKind === 'replacementRule' ||\n\t\t\tnode.nodeKind === 'inversion' ||\n\t\t\tnode.nodeKind === 'une possibilité'\n\t\t) {\n\t\t\treturn false\n\t\t}\n\t\tif (node.nodeKind === 'contexte') {\n\t\t\t// We don't replace references in contexte keys\n\t\t\treturn {\n\t\t\t\t...node,\n\t\t\t\texplanation: {\n\t\t\t\t\t...node.explanation,\n\t\t\t\t\tvaleur: transform(node.explanation.valeur),\n\t\t\t\t\tcontexte: node.explanation.contexte.map(([name, value]) => [\n\t\t\t\t\t\tname,\n\t\t\t\t\t\ttransform(value),\n\t\t\t\t\t]),\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tif (node.nodeKind === 'reference') {\n\t\t\tif (!node.dottedName) {\n\t\t\t\tthrow new PublicodesInternalError(node)\n\t\t\t}\n\t\t\tconst replacedReferenceNode = replace(\n\t\t\t\tnode,\n\t\t\t\treplacements[node.dottedName] ?? [],\n\t\t\t)\n\t\t\t// Collect inlined replacement\n\t\t\tmakeASTVisitor((n) => {\n\t\t\t\tupdateReferencesMapsFromReferenceNode(\n\t\t\t\t\tn,\n\t\t\t\t\treferencesMaps,\n\t\t\t\t\tnode.contextDottedName,\n\t\t\t\t)\n\t\t\t\treturn 'continue'\n\t\t\t})(replacedReferenceNode)\n\t\t\treturn replacedReferenceNode\n\t\t}\n\t})\n}\n\nfunction replace(\n\tnode: ASTNode<'reference'>,\n\treplacements: Array<ReplacementRule>,\n): ASTNode {\n\t// TODO : handle transitivité\n\n\tconst applicableReplacements = replacements\n\t\t.filter(\n\t\t\t({ definitionRule }) =>\n\t\t\t\tdefinitionRule.dottedName !== node.contextDottedName,\n\t\t)\n\t\t.filter(\n\t\t\t({ whiteListedNames }) =>\n\t\t\t\t!whiteListedNames.length ||\n\t\t\t\twhiteListedNames.some((name) =>\n\t\t\t\t\tnode.contextDottedName.startsWith(name.dottedName as string),\n\t\t\t\t),\n\t\t)\n\t\t.filter(\n\t\t\t({ blackListedNames }) =>\n\t\t\t\t!blackListedNames.length ||\n\t\t\t\tblackListedNames.every(\n\t\t\t\t\t(name) =>\n\t\t\t\t\t\t!node.contextDottedName.startsWith(name.dottedName as string),\n\t\t\t\t),\n\t\t)\n\t\t.reverse()\n\t\t.sort((a, b) => {\n\t\t\tconst result = (b.priority ?? 0) - (a.priority ?? 0)\n\t\t\tif (result !== 0) {\n\t\t\t\treturn result\n\t\t\t}\n\t\t\treturn b.definitionRule.dottedName.localeCompare(\n\t\t\t\ta.definitionRule.dottedName,\n\t\t\t)\n\t\t})\n\n\tif (!applicableReplacements.length) {\n\t\treturn node\n\t}\n\n\tconst applicableReplacementsCacheKey = applicableReplacements\n\t\t.map((n) => n.remplacementRuleId)\n\t\t.join('-')\n\tif (cache[applicableReplacementsCacheKey]) {\n\t\treturn cache[applicableReplacementsCacheKey]\n\t}\n\tconst replacementNode = {\n\t\tnodeKind: 'variations',\n\t\texplanation: [\n\t\t\t...applicableReplacements.map(\n\t\t\t\t({ definitionRule, replaceByNonApplicable }) =>\n\t\t\t\t\treplaceByNonApplicable ?\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcondition: definitionRule,\n\t\t\t\t\t\t\tconsequence: notApplicableNode,\n\t\t\t\t\t\t}\n\t\t\t\t\t:\t{\n\t\t\t\t\t\t\tcondition: estApplicable(definitionRule),\n\t\t\t\t\t\t\tconsequence: definitionRule,\n\t\t\t\t\t\t},\n\t\t\t),\n\t\t\t{ condition: oui, consequence: node },\n\t\t],\n\t} as ASTNode<'variations'>\n\n\treplacementNode.sourceMap = {\n\t\tmecanismName: 'replacement',\n\t\targs: {\n\t\t\tapplicableReplacements,\n\t\t\toriginalNode: node,\n\t\t},\n\t}\n\tcache[applicableReplacementsCacheKey] = replacementNode\n\treturn cache[applicableReplacementsCacheKey]\n}\n\nfunction estApplicable(node: ASTNode) {\n\treturn {\n\t\tnodeKind: 'condition',\n\t\texplanation: {\n\t\t\tsi: { nodeKind: 'est non applicable', explanation: node },\n\t\t\talors: non,\n\t\t\tsinon: oui,\n\t\t},\n\t} as ASTNode<'condition'>\n}\n\nconst oui = defaultNode(true)\nconst non = defaultNode(false)\n","import { Logger, ParsedRules } from '.'\nimport { makeASTTransformer, traverseParsedRules } from './AST'\nimport { PublicodesError } from './error'\nimport inferNodeType, { NodesTypes } from './inferNodeType'\nimport { ReplacementRule, inlineReplacements } from './replacement'\nimport { Rule, parseRules } from './rule'\nimport {\n\tdisambiguateReferenceNode,\n\tupdateReferencesMapsFromReferenceNode,\n} from './ruleUtils'\nimport { getUnitKey } from './units'\nimport { weakCopyObj } from './utils'\n\nexport type Context<RuleNames extends string = string> = {\n\tdottedName: RuleNames | ''\n\tparsedRules: ParsedRules<RuleNames>\n\tnodesTypes: NodesTypes\n\treferencesMaps: ReferencesMaps<RuleNames>\n\trulesReplacements: RulesReplacements<RuleNames>\n\tgetUnitKey?: getUnitKey\n\tlogger: Logger\n\tinversionMaxIterations?: number\n\t/**\n\t * Don't throw an error if the parent of a rule is not found.\n\t * This is useful to parse partial rule sets (e.g. optimized ones).\n\t */\n\tallowOrphanRules: boolean\n\t/**\n\t * This is used to generate unique IDs for sub-engines, we need to generate them at\n\t *  */\n\tsubEngineIncrementingNumber?: number\n}\n\nexport type RulesReplacements<RuleNames extends string> = Partial<\n\tRecord<RuleNames, ReplacementRule[]>\n>\n\nexport type ReferencesMaps<Names extends string> = {\n\treferencesIn: Map<Names, Set<Names>>\n\trulesThatUse: Map<Names, Set<Names>>\n}\n\nexport type RawRule = Omit<Rule, 'nom'> | string | number | null\nexport type RawPublicodes<RuleNames extends string> = Partial<\n\tRecord<RuleNames, RawRule>\n>\n\nexport function createContext<RuleNames extends string>(\n\tpartialContext: Partial<Context<RuleNames>>,\n): Context<RuleNames> {\n\treturn {\n\t\tdottedName: '',\n\t\tlogger: console,\n\t\tgetUnitKey: (x) => x,\n\t\tparsedRules: {} as ParsedRules<RuleNames>,\n\t\treferencesMaps: { referencesIn: new Map(), rulesThatUse: new Map() },\n\t\tnodesTypes: new WeakMap(),\n\t\trulesReplacements: {},\n\t\tallowOrphanRules: false,\n\n\t\tsubEngineIncrementingNumber: 1,\n\n\t\t...partialContext,\n\t}\n}\n\nexport function copyContext<C extends Context>(context: C): C {\n\treturn {\n\t\t...context,\n\t\tparsedRules: { ...context.parsedRules },\n\t\treferencesMaps: {\n\t\t\treferencesIn: new Map(context.referencesMaps.referencesIn),\n\t\t\trulesThatUse: new Map(context.referencesMaps.rulesThatUse),\n\t\t},\n\t}\n}\nexport default function parsePublicodes<\n\tContextNames extends string,\n\tNewRulesNames extends string,\n>(\n\trawRules: RawPublicodes<NewRulesNames>,\n\tpartialContext: Partial<Context<ContextNames>> = createContext({}),\n): Pick<\n\tContext<ContextNames | NewRulesNames>,\n\t'parsedRules' | 'nodesTypes' | 'referencesMaps' | 'rulesReplacements'\n> {\n\t// STEP 1 : get the rules as an object\n\n\tif (typeof rawRules === 'string')\n\t\tthrow new PublicodesError(\n\t\t\t'EngineError',\n\t\t\t'Publicodes does not parse yaml rule sets itself anymore. Please provide a parsed js object. E.g. the `eemeli/yaml` package.',\n\t\t\t{},\n\t\t)\n\n\t// let rules = { ...rawRules } // take 7-8ms\n\tconst rules = weakCopyObj(rawRules) // take 1-2ms\n\n\t// STEP 2: Rules parsing\n\tconst context = createContext(partialContext)\n\tconst previousParsedRules = context.parsedRules\n\tcontext.parsedRules = {} as ParsedRules<ContextNames>\n\tparseRules(rules, context)\n\n\tlet parsedRules = {} as ParsedRules<NewRulesNames | ContextNames>\n\tfor (const dottedName in previousParsedRules) {\n\t\tparsedRules[dottedName] = previousParsedRules[dottedName]\n\t}\n\tfor (const dottedName in context.parsedRules) {\n\t\tparsedRules[dottedName] = context.parsedRules[dottedName]\n\t}\n\n\t// STEP 3: Disambiguate reference\n\tconst [newRules, referencesMaps] =\n\t\tdisambiguateReferencesAndCollectDependencies(\n\t\t\tparsedRules,\n\t\t\tcontext.parsedRules,\n\t\t\tcontext.referencesMaps,\n\t\t\tcontext.allowOrphanRules,\n\t\t)\n\n\t// STEP 4: Inline replacements\n\tlet rulesReplacements\n\t\t// eslint-disable-next-line prefer-const\n\t;[parsedRules, rulesReplacements] = inlineReplacements<\n\t\tNewRulesNames,\n\t\tContextNames\n\t>({\n\t\tparsedRules,\n\t\tnewRules: newRules as any,\n\t\treferencesMaps,\n\t\tpreviousReplacements: context.rulesReplacements,\n\t})\n\n\t// STEP 5: type inference\n\tconst nodesTypes = inferNodeType(\n\t\tObject.keys(newRules),\n\t\tparsedRules,\n\t\tcontext.nodesTypes,\n\t)\n\n\treturn {\n\t\tparsedRules,\n\t\tnodesTypes,\n\t\treferencesMaps,\n\t\trulesReplacements,\n\t}\n}\n\nfunction disambiguateReferencesAndCollectDependencies<\n\tNewNames extends string,\n\tPreviousNames extends string,\n>(\n\tparsedRules: ParsedRules<PreviousNames>,\n\tnewRules: ParsedRules<NewNames>,\n\treferencesMaps: ReferencesMaps<PreviousNames>,\n\tallowOrphanRules: boolean,\n): [\n\tparsedRules: ParsedRules<NewNames>,\n\treferencesMap: ReferencesMaps<PreviousNames | NewNames>,\n] {\n\tconst disambiguateReference = makeASTTransformer((node) =>\n\t\tdisambiguateReferenceNode(node, parsedRules),\n\t)\n\tconst disambiguateReferencesAndCollectDependencies = makeASTTransformer(\n\t\t(node) => {\n\t\t\tconst n = disambiguateReferenceNode(node, parsedRules)\n\t\t\tif (n) {\n\t\t\t\tupdateReferencesMapsFromReferenceNode(n, referencesMaps)\n\t\t\t}\n\t\t\treturn n\n\t\t},\n\t)\n\tconst disambiguatedRules = traverseParsedRules((node) => {\n\t\tif (node.nodeKind === 'replacementRule') {\n\t\t\t// The dependencies of replacements will be collected later, during the inlining\n\t\t\treturn disambiguateReference(node)\n\t\t}\n\t\tif (node.nodeKind === 'rule') {\n\t\t\tconst parentUndefined = (node.explanation.parents as any).find(\n\t\t\t\t(n: any) => !(n.dottedName in parsedRules),\n\t\t\t)\n\t\t\tif (!allowOrphanRules && parentUndefined) {\n\t\t\t\tthrow new PublicodesError(\n\t\t\t\t\t'SyntaxError',\n\t\t\t\t\t`La règle parente \"${parentUndefined.dottedName}\" n'existe pas`,\n\t\t\t\t\t{\n\t\t\t\t\t\tdottedName: node.dottedName,\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t\treturn disambiguateReferencesAndCollectDependencies(node)\n\t}, newRules)\n\treturn [\n\t\tdisambiguatedRules,\n\t\treferencesMaps as ReferencesMaps<NewNames | PreviousNames>,\n\t]\n}\n","import { ASTNode, EvaluatedNode } from '.'\n\nexport function computeTraversedVariableBeforeEval(\n\ttraversedVariablesStack: Array<Set<string>> | undefined,\n\tparsedNode: ASTNode,\n\tcachedNode: EvaluatedNode | undefined,\n\tpublicParsedRules: Record<string, ASTNode>,\n\tisTraversedVariablesBoundary: boolean,\n) {\n\tif (traversedVariablesStack === undefined) {\n\t\treturn\n\t}\n\tif (cachedNode !== undefined) {\n\t\tcachedNode.traversedVariables?.forEach(\n\t\t\t(name) => traversedVariablesStack[0]?.add(name),\n\t\t)\n\t\treturn\n\t}\n\n\tif (isTraversedVariablesBoundary) {\n\t\t// Note: we use `unshift` instead of the more usual `push` to reverse the\n\t\t// order of the elements in the stack. This simplify access to the “top\n\t\t// element” with [0], instead of [length - 1]. We could also use the new\n\t\t// method `.at(-1)` but it isn't supported below Node v16.\n\t\ttraversedVariablesStack.unshift(new Set())\n\t}\n\n\tif (\n\t\tparsedNode.nodeKind === 'reference' &&\n\t\tparsedNode.dottedName &&\n\t\tparsedNode.dottedName in publicParsedRules\n\t) {\n\t\ttraversedVariablesStack[0].add(parsedNode.dottedName)\n\t}\n}\n\nexport function isTraversedVariablesBoundary(\n\ttraversedVariablesStack: Array<Set<string>> | undefined,\n\tparsedNode: ASTNode,\n) {\n\treturn (\n\t\t!!traversedVariablesStack &&\n\t\t(traversedVariablesStack.length === 0 || parsedNode.nodeKind === 'rule')\n\t)\n}\n\nexport function computeTraversedVariableAfterEval(\n\ttraversedVariablesStack: Array<Set<string>> | undefined,\n\tevaluatedNode: EvaluatedNode,\n\tisTraversedVariablesBoundary: boolean,\n) {\n\tif (traversedVariablesStack === undefined) {\n\t\treturn\n\t}\n\tif (isTraversedVariablesBoundary) {\n\t\tevaluatedNode.traversedVariables = Array.from(\n\t\t\ttraversedVariablesStack.shift() ?? [],\n\t\t)\n\n\t\tif (traversedVariablesStack.length > 0) {\n\t\t\tevaluatedNode.traversedVariables.forEach((name) => {\n\t\t\t\ttraversedVariablesStack[0].add(name)\n\t\t\t})\n\t\t}\n\t}\n}\n","import { EvaluatedNode } from './index'\nimport { serializeUnit } from './units'\nexport default function serializeEvaluation(\n\tnode: EvaluatedNode,\n): string | undefined {\n\tif (typeof node.nodeValue === 'number') {\n\t\tconst serializedUnit = serializeUnit(node.unit)\n\t\treturn (\n\t\t\t'' +\n\t\t\tnode.nodeValue +\n\t\t\t(serializedUnit ? serializedUnit.replace(/\\s/g, '') : '')\n\t\t)\n\t} else if (typeof node.nodeValue === 'boolean') {\n\t\treturn node.nodeValue ? 'oui' : 'non'\n\t} else if (typeof node.nodeValue === 'string') {\n\t\treturn `'${node.nodeValue}'`\n\t}\n}\n"],"mappings":"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","names":["module","Rule","dot","Parser","Grammar","lexer","pad","module","pad","string","word","Lexer","lexer","node","name","string","formatUnit","factor","convertTable","unitClasses","formatUnit","context","name","evaluate","evaluate","nodeValue","evaluate","date","date","evaluate","evaluate","evaluate","evaluate","evaluate","evaluate","nodeValue","evaluate","evaluate","evaluate","evaluate","unit","moo","arrpush","nearley","disambiguateReference","disambiguateReferencesAndCollectDependencies","isTraversedVariablesBoundary"]}