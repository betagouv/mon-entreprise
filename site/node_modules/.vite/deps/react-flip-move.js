import {
  require_react_dom
} from "./chunk-JTBF2GAF.js";
import {
  require_react
} from "./chunk-4BTUQGSU.js";
import {
  __toESM
} from "./chunk-2LSFTFF7.js";

// ../node_modules/react-flip-move/dist/react-flip-move.es.js
var import_react = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
function warnOnce(msg) {
  var hasWarned = false;
  return function() {
    if (!hasWarned) {
      console.warn(msg);
      hasWarned = true;
    }
  };
}
var statelessFunctionalComponentSupplied = warnOnce("\n>> Error, via react-flip-move <<\n\nYou provided a stateless functional component as a child to <FlipMove>. Unfortunately, SFCs aren't supported, because Flip Move needs access to the backing instances via refs, and SFCs don't have a public instance that holds that info.\n\nPlease wrap your components in a native element (eg. <div>), or a non-functional component.\n");
var primitiveNodeSupplied = warnOnce("\n>> Error, via react-flip-move <<\n\nYou provided a primitive (text or number) node as a child to <FlipMove>. Flip Move needs containers with unique keys to move children around.\n\nPlease wrap your value in a native element (eg. <span>), or a component.\n");
var invalidTypeForTimingProp = function invalidTypeForTimingProp2(args) {
  return console.error("\n>> Error, via react-flip-move <<\n\nThe prop you provided for '" + args.prop + "' is invalid. It needs to be a positive integer, or a string that can be resolved to a number. The value you provided is '" + args.value + "'.\n\nAs a result,  the default value for this parameter will be used, which is '" + args.defaultValue + "'.\n");
};
var invalidEnterLeavePreset = function invalidEnterLeavePreset2(args) {
  return console.error("\n>> Error, via react-flip-move <<\n\nThe enter/leave preset you provided is invalid. We don't currently have a '" + args.value + " preset.'\n\nAcceptable values are " + args.acceptableValues + ". The default value of '" + args.defaultValue + "' will be used.\n");
};
var parentNodePositionStatic = warnOnce(`
>> Warning, via react-flip-move <<

When using "wrapperless" mode (by supplying 'typeName' of 'null'), strange things happen when the direct parent has the default "static" position.

FlipMove has added 'position: relative' to this node, to ensure Flip Move animates correctly.

To avoid seeing this warning, simply apply a non-static position to that parent node.
`);
var childIsDisabled = warnOnce("\n>> Warning, via react-flip-move <<\n\nOne or more of Flip Move's child elements have the html attribute 'disabled' set to true.\n\nPlease note that this will cause animations to break in Internet Explorer 11 and below. Either remove the disabled attribute or set 'animation' to false.\n");
var enterPresets = {
  elevator: {
    from: { transform: "scale(0)", opacity: "0" },
    to: { transform: "", opacity: "" }
  },
  fade: {
    from: { opacity: "0" },
    to: { opacity: "" }
  },
  accordionVertical: {
    from: { transform: "scaleY(0)", transformOrigin: "center top" },
    to: { transform: "", transformOrigin: "center top" }
  },
  accordionHorizontal: {
    from: { transform: "scaleX(0)", transformOrigin: "left center" },
    to: { transform: "", transformOrigin: "left center" }
  },
  none: null
};
var leavePresets = {
  elevator: {
    from: { transform: "scale(1)", opacity: "1" },
    to: { transform: "scale(0)", opacity: "0" }
  },
  fade: {
    from: { opacity: "1" },
    to: { opacity: "0" }
  },
  accordionVertical: {
    from: { transform: "scaleY(1)", transformOrigin: "center top" },
    to: { transform: "scaleY(0)", transformOrigin: "center top" }
  },
  accordionHorizontal: {
    from: { transform: "scaleX(1)", transformOrigin: "left center" },
    to: { transform: "scaleX(0)", transformOrigin: "left center" }
  },
  none: null
};
var appearPresets = enterPresets;
var defaultPreset = "elevator";
var disablePreset = "none";
var find = function find2(predicate, arr) {
  for (var i = 0; i < arr.length; i++) {
    if (predicate(arr[i], i, arr)) {
      return arr[i];
    }
  }
  return void 0;
};
var every = function every2(predicate, arr) {
  for (var i = 0; i < arr.length; i++) {
    if (!predicate(arr[i], i, arr)) {
      return false;
    }
  }
  return true;
};
var _isArray = function isArray(arr) {
  _isArray = Array.isArray || function(arg) {
    return Object.prototype.toString.call(arg) === "[object Array]";
  };
  return _isArray(arr);
};
var isElementAnSFC = function isElementAnSFC2(element) {
  var isNativeDOMElement = typeof element.type === "string";
  if (isNativeDOMElement) {
    return false;
  }
  return typeof element.type === "function" && !element.type.prototype.isReactComponent;
};
function omit(obj) {
  var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var result = {};
  Object.keys(obj).forEach(function(key) {
    if (attrs.indexOf(key) === -1) {
      result[key] = obj[key];
    }
  });
  return result;
}
function arraysEqual(a, b) {
  var sameObject = a === b;
  if (sameObject) {
    return true;
  }
  var notBothArrays = !_isArray(a) || !_isArray(b);
  var differentLengths = a.length !== b.length;
  if (notBothArrays || differentLengths) {
    return false;
  }
  return every(function(element, index) {
    return element === b[index];
  }, a);
}
function memoizeString(fn) {
  var cache = {};
  return function(str) {
    if (!cache[str]) {
      cache[str] = fn(str);
    }
    return cache[str];
  };
}
var hyphenate = memoizeString(function(str) {
  return str.replace(/([A-Z])/g, "-$1").toLowerCase();
});
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var classCallCheck = function(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var _extends = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var inherits = function(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};
var possibleConstructorReturn = function(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};
function propConverter(ComposedComponent) {
  var _class, _temp;
  return _temp = _class = function(_Component) {
    inherits(FlipMovePropConverter, _Component);
    function FlipMovePropConverter() {
      classCallCheck(this, FlipMovePropConverter);
      return possibleConstructorReturn(this, _Component.apply(this, arguments));
    }
    FlipMovePropConverter.prototype.checkChildren = function checkChildren(children) {
      if (false) {
        return;
      }
      import_react.Children.forEach(children, function(child) {
        if (child == null || typeof child === "boolean") {
          return;
        }
        if ((typeof child === "undefined" ? "undefined" : _typeof(child)) !== "object") {
          primitiveNodeSupplied();
          return;
        }
        if (isElementAnSFC(child) && child.key != null) {
          statelessFunctionalComponentSupplied();
        }
      });
    };
    FlipMovePropConverter.prototype.convertProps = function convertProps(props) {
      var workingProps = {
        // explicitly bypass the props that don't need conversion
        children: props.children,
        easing: props.easing,
        onStart: props.onStart,
        onFinish: props.onFinish,
        onStartAll: props.onStartAll,
        onFinishAll: props.onFinishAll,
        typeName: props.typeName,
        disableAllAnimations: props.disableAllAnimations,
        getPosition: props.getPosition,
        maintainContainerHeight: props.maintainContainerHeight,
        verticalAlignment: props.verticalAlignment,
        // Do string-to-int conversion for all timing-related props
        duration: this.convertTimingProp("duration"),
        delay: this.convertTimingProp("delay"),
        staggerDurationBy: this.convertTimingProp("staggerDurationBy"),
        staggerDelayBy: this.convertTimingProp("staggerDelayBy"),
        // Our enter/leave animations can be specified as boolean (default or
        // disabled), string (preset name), or object (actual animation values).
        // Let's standardize this so that they're always objects
        appearAnimation: this.convertAnimationProp(props.appearAnimation, appearPresets),
        enterAnimation: this.convertAnimationProp(props.enterAnimation, enterPresets),
        leaveAnimation: this.convertAnimationProp(props.leaveAnimation, leavePresets),
        delegated: {}
      };
      this.checkChildren(workingProps.children);
      var primaryPropKeys = Object.keys(workingProps);
      var delegatedProps = omit(this.props, primaryPropKeys);
      delegatedProps.style = _extends({
        position: "relative"
      }, delegatedProps.style);
      workingProps.delegated = delegatedProps;
      return workingProps;
    };
    FlipMovePropConverter.prototype.convertTimingProp = function convertTimingProp(prop) {
      var rawValue = this.props[prop];
      var value = typeof rawValue === "number" ? rawValue : parseInt(rawValue, 10);
      if (isNaN(value)) {
        var defaultValue = FlipMovePropConverter.defaultProps[prop];
        if (true) {
          invalidTypeForTimingProp({
            prop,
            value: rawValue,
            defaultValue
          });
        }
        return defaultValue;
      }
      return value;
    };
    FlipMovePropConverter.prototype.convertAnimationProp = function convertAnimationProp(animation, presets) {
      switch (typeof animation === "undefined" ? "undefined" : _typeof(animation)) {
        case "boolean": {
          return presets[animation ? defaultPreset : disablePreset];
        }
        case "string": {
          var presetKeys = Object.keys(presets);
          if (presetKeys.indexOf(animation) === -1) {
            if (true) {
              invalidEnterLeavePreset({
                value: animation,
                acceptableValues: presetKeys.join(", "),
                defaultValue: defaultPreset
              });
            }
            return presets[defaultPreset];
          }
          return presets[animation];
        }
        default: {
          return animation;
        }
      }
    };
    FlipMovePropConverter.prototype.render = function render() {
      return import_react.default.createElement(ComposedComponent, this.convertProps(this.props));
    };
    return FlipMovePropConverter;
  }(import_react.Component), _class.defaultProps = {
    easing: "ease-in-out",
    duration: 350,
    delay: 0,
    staggerDurationBy: 0,
    staggerDelayBy: 0,
    typeName: "div",
    enterAnimation: defaultPreset,
    leaveAnimation: defaultPreset,
    disableAllAnimations: false,
    getPosition: function getPosition(node) {
      return node.getBoundingClientRect();
    },
    maintainContainerHeight: false,
    verticalAlignment: "top"
  }, _temp;
}
function applyStylesToDOMNode(_ref) {
  var domNode = _ref.domNode, styles = _ref.styles;
  Object.keys(styles).forEach(function(key) {
    domNode.style.setProperty(hyphenate(key), styles[key]);
  });
}
function whichTransitionEvent() {
  var transitions = {
    transition: "transitionend",
    "-o-transition": "oTransitionEnd",
    "-moz-transition": "transitionend",
    "-webkit-transition": "webkitTransitionEnd"
  };
  if (typeof document === "undefined")
    return "";
  var el = document.createElement("fakeelement");
  var match = find(function(t) {
    return el.style.getPropertyValue(t) !== void 0;
  }, Object.keys(transitions));
  return match ? transitions[match] : "";
}
var getRelativeBoundingBox = function getRelativeBoundingBox2(_ref2) {
  var childDomNode = _ref2.childDomNode, parentDomNode = _ref2.parentDomNode, getPosition = _ref2.getPosition;
  var parentBox = getPosition(parentDomNode);
  var _getPosition = getPosition(childDomNode), top = _getPosition.top, left = _getPosition.left, right = _getPosition.right, bottom = _getPosition.bottom, width = _getPosition.width, height = _getPosition.height;
  return {
    top: top - parentBox.top,
    left: left - parentBox.left,
    right: parentBox.right - right,
    bottom: parentBox.bottom - bottom,
    width,
    height
  };
};
var getPositionDelta = function getPositionDelta2(_ref3) {
  var childDomNode = _ref3.childDomNode, childBoundingBox = _ref3.childBoundingBox, parentBoundingBox = _ref3.parentBoundingBox, getPosition = _ref3.getPosition;
  var defaultBox = {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    height: 0,
    width: 0
  };
  var oldRelativeBox = childBoundingBox || defaultBox;
  var parentBox = parentBoundingBox || defaultBox;
  var newAbsoluteBox = getPosition(childDomNode);
  var newRelativeBox = {
    top: newAbsoluteBox.top - parentBox.top,
    left: newAbsoluteBox.left - parentBox.left
  };
  return [oldRelativeBox.left - newRelativeBox.left, oldRelativeBox.top - newRelativeBox.top];
};
var removeNodeFromDOMFlow = function removeNodeFromDOMFlow2(childData, verticalAlignment) {
  var domNode = childData.domNode, boundingBox = childData.boundingBox;
  if (!domNode || !boundingBox) {
    return;
  }
  var computed = window.getComputedStyle(domNode);
  var marginAttrs = ["margin-top", "margin-left", "margin-right"];
  var margins = marginAttrs.reduce(function(acc, margin) {
    var _babelHelpers$extends;
    var propertyVal = computed.getPropertyValue(margin);
    return _extends({}, acc, (_babelHelpers$extends = {}, _babelHelpers$extends[margin] = Number(propertyVal.replace("px", "")), _babelHelpers$extends));
  }, {});
  var topOffset = verticalAlignment === "bottom" ? boundingBox.top - boundingBox.height : boundingBox.top;
  var styles = {
    position: "absolute",
    top: topOffset - margins["margin-top"] + "px",
    left: boundingBox.left - margins["margin-left"] + "px",
    right: boundingBox.right - margins["margin-right"] + "px"
  };
  applyStylesToDOMNode({ domNode, styles });
};
var updateHeightPlaceholder = function updateHeightPlaceholder2(_ref4) {
  var domNode = _ref4.domNode, parentData = _ref4.parentData, getPosition = _ref4.getPosition;
  var parentDomNode = parentData.domNode;
  var parentBoundingBox = parentData.boundingBox;
  if (!parentDomNode || !parentBoundingBox) {
    return;
  }
  applyStylesToDOMNode({ domNode, styles: { height: "0" } });
  var originalParentHeight = parentBoundingBox.height;
  var collapsedParentHeight = getPosition(parentDomNode).height;
  var reductionInHeight = originalParentHeight - collapsedParentHeight;
  var styles = {
    height: reductionInHeight > 0 ? reductionInHeight + "px" : "0"
  };
  applyStylesToDOMNode({ domNode, styles });
};
var getNativeNode = function getNativeNode2(element) {
  if (typeof HTMLElement === "undefined") {
    return null;
  }
  if (element instanceof HTMLElement) {
    return element;
  }
  var foundNode = (0, import_react_dom.findDOMNode)(element);
  if (foundNode && foundNode.nodeType === Node.TEXT_NODE) {
    return null;
  }
  return foundNode;
};
var createTransitionString = function createTransitionString2(index, props) {
  var delay = props.delay, duration = props.duration;
  var staggerDurationBy = props.staggerDurationBy, staggerDelayBy = props.staggerDelayBy, easing = props.easing;
  delay += index * staggerDelayBy;
  duration += index * staggerDurationBy;
  var cssProperties = ["transform", "opacity"];
  return cssProperties.map(function(prop) {
    return prop + " " + duration + "ms " + easing + " " + delay + "ms";
  }).join(", ");
};
var transitionEnd = whichTransitionEvent();
var noBrowserSupport = !transitionEnd;
function getKey(childData) {
  return childData.key || "";
}
function getElementChildren(children) {
  return import_react.Children.toArray(children);
}
var FlipMove$1 = function(_Component) {
  inherits(FlipMove, _Component);
  function FlipMove() {
    var _temp, _this, _ret;
    classCallCheck(this, FlipMove);
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return _ret = (_temp = (_this = possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.state = {
      children: getElementChildren(
        // `this.props` ought to always be defined at this point, but a report
        // was made about it not being defined in IE10.
        // TODO: Test in IE10, to see if there's an underlying cause that can
        // be addressed.
        _this.props ? _this.props.children : []
      ).map(function(element) {
        return _extends({}, element, {
          element,
          appearing: true
        });
      })
    }, _this.childrenData = {}, _this.parentData = {
      domNode: null,
      boundingBox: null
    }, _this.heightPlaceholderData = {
      domNode: null
    }, _this.remainingAnimations = 0, _this.childrenToAnimate = [], _this.findDOMContainer = function() {
      var domNode = import_react_dom.default.findDOMNode(_this);
      var parentNode = domNode && domNode.parentNode;
      if (!parentNode || !(parentNode instanceof HTMLElement)) {
        return;
      }
      if (window.getComputedStyle(parentNode).position === "static") {
        parentNode.style.position = "relative";
        parentNodePositionStatic();
      }
      _this.parentData.domNode = parentNode;
    }, _this.runAnimation = function() {
      var dynamicChildren = _this.state.children.filter(_this.doesChildNeedToBeAnimated);
      var childrenInitialStyles = dynamicChildren.map(function(child) {
        return _this.computeInitialStyles(child);
      });
      dynamicChildren.forEach(function(child, index) {
        _this.remainingAnimations += 1;
        _this.childrenToAnimate.push(getKey(child));
        _this.animateChild(child, index, childrenInitialStyles[index]);
      });
      if (typeof _this.props.onStartAll === "function") {
        _this.callChildrenHook(_this.props.onStartAll);
      }
    }, _this.doesChildNeedToBeAnimated = function(child) {
      if (!getKey(child)) {
        return false;
      }
      var childData = _this.getChildData(getKey(child));
      var childDomNode = childData.domNode;
      var childBoundingBox = childData.boundingBox;
      var parentBoundingBox = _this.parentData.boundingBox;
      if (!childDomNode) {
        return false;
      }
      var _this$props = _this.props, appearAnimation = _this$props.appearAnimation, enterAnimation = _this$props.enterAnimation, leaveAnimation = _this$props.leaveAnimation, getPosition = _this$props.getPosition;
      var isAppearingWithAnimation = child.appearing && appearAnimation;
      var isEnteringWithAnimation = child.entering && enterAnimation;
      var isLeavingWithAnimation = child.leaving && leaveAnimation;
      if (isAppearingWithAnimation || isEnteringWithAnimation || isLeavingWithAnimation) {
        return true;
      }
      var _getPositionDelta = getPositionDelta({
        childDomNode,
        childBoundingBox,
        parentBoundingBox,
        getPosition
      }), dX = _getPositionDelta[0], dY = _getPositionDelta[1];
      return dX !== 0 || dY !== 0;
    }, _temp), possibleConstructorReturn(_this, _ret);
  }
  FlipMove.prototype.componentDidMount = function componentDidMount() {
    if (this.props.typeName === null) {
      this.findDOMContainer();
    }
    var shouldTriggerFLIP = this.props.appearAnimation && !this.isAnimationDisabled(this.props);
    if (shouldTriggerFLIP) {
      this.prepForAnimation();
      this.runAnimation();
    }
  };
  FlipMove.prototype.componentDidUpdate = function componentDidUpdate(previousProps) {
    if (this.props.typeName === null) {
      this.findDOMContainer();
    }
    var oldChildrenKeys = getElementChildren(this.props.children).map(function(d) {
      return d.key;
    });
    var nextChildrenKeys = getElementChildren(previousProps.children).map(function(d) {
      return d.key;
    });
    var shouldTriggerFLIP = !arraysEqual(oldChildrenKeys, nextChildrenKeys) && !this.isAnimationDisabled(this.props);
    if (shouldTriggerFLIP) {
      this.prepForAnimation();
      this.runAnimation();
    }
  };
  FlipMove.prototype.calculateNextSetOfChildren = function calculateNextSetOfChildren(nextChildren) {
    var _this2 = this;
    var updatedChildren = nextChildren.map(function(nextChild) {
      var child = _this2.findChildByKey(nextChild.key);
      var isEntering = !child || child.leaving;
      return _extends({}, nextChild, { element: nextChild, entering: isEntering });
    });
    var numOfChildrenLeaving = 0;
    this.state.children.forEach(function(child, index) {
      var isLeaving = !find(function(_ref) {
        var key = _ref.key;
        return key === getKey(child);
      }, nextChildren);
      if (!isLeaving || !_this2.props.leaveAnimation)
        return;
      var nextChild = _extends({}, child, { leaving: true });
      var nextChildIndex = index + numOfChildrenLeaving;
      updatedChildren.splice(nextChildIndex, 0, nextChild);
      numOfChildrenLeaving += 1;
    });
    return updatedChildren;
  };
  FlipMove.prototype.prepForAnimation = function prepForAnimation() {
    var _this3 = this;
    var _props = this.props, leaveAnimation = _props.leaveAnimation, maintainContainerHeight = _props.maintainContainerHeight, getPosition = _props.getPosition;
    if (leaveAnimation) {
      var leavingChildren = this.state.children.filter(function(child) {
        return child.leaving;
      });
      leavingChildren.forEach(function(leavingChild) {
        var childData = _this3.getChildData(getKey(leavingChild));
        if (!_this3.isAnimationDisabled(_this3.props) && childData.domNode && childData.domNode.disabled) {
          childIsDisabled();
        }
        if (childData.boundingBox) {
          removeNodeFromDOMFlow(childData, _this3.props.verticalAlignment);
        }
      });
      if (maintainContainerHeight && this.heightPlaceholderData.domNode) {
        updateHeightPlaceholder({
          domNode: this.heightPlaceholderData.domNode,
          parentData: this.parentData,
          getPosition
        });
      }
    }
    this.state.children.forEach(function(child) {
      var _getChildData = _this3.getChildData(getKey(child)), domNode = _getChildData.domNode;
      if (!domNode) {
        return;
      }
      if (!child.entering && !child.leaving) {
        applyStylesToDOMNode({
          domNode,
          styles: {
            transition: ""
          }
        });
      }
    });
  };
  FlipMove.prototype.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {
    this.updateBoundingBoxCaches();
    var nextChildren = getElementChildren(nextProps.children);
    this.setState({
      children: this.isAnimationDisabled(nextProps) ? nextChildren.map(function(element) {
        return _extends({}, element, { element });
      }) : this.calculateNextSetOfChildren(nextChildren)
    });
  };
  FlipMove.prototype.animateChild = function animateChild(child, index, childInitialStyles) {
    var _this4 = this;
    var _getChildData2 = this.getChildData(getKey(child)), domNode = _getChildData2.domNode;
    if (!domNode) {
      return;
    }
    applyStylesToDOMNode({
      domNode,
      styles: childInitialStyles
    });
    if (this.props.onStart)
      this.props.onStart(child, domNode);
    requestAnimationFrame(function() {
      requestAnimationFrame(function() {
        var styles = {
          transition: createTransitionString(index, _this4.props),
          transform: "",
          opacity: ""
        };
        if (child.appearing && _this4.props.appearAnimation) {
          styles = _extends({}, styles, _this4.props.appearAnimation.to);
        } else if (child.entering && _this4.props.enterAnimation) {
          styles = _extends({}, styles, _this4.props.enterAnimation.to);
        } else if (child.leaving && _this4.props.leaveAnimation) {
          styles = _extends({}, styles, _this4.props.leaveAnimation.to);
        }
        applyStylesToDOMNode({ domNode, styles });
      });
    });
    this.bindTransitionEndHandler(child);
  };
  FlipMove.prototype.bindTransitionEndHandler = function bindTransitionEndHandler(child) {
    var _this5 = this;
    var _getChildData3 = this.getChildData(getKey(child)), domNode = _getChildData3.domNode;
    if (!domNode) {
      return;
    }
    var transitionEndHandler = function transitionEndHandler2(ev) {
      if (ev.target !== domNode)
        return;
      domNode.style.transition = "";
      _this5.triggerFinishHooks(child, domNode);
      domNode.removeEventListener(transitionEnd, transitionEndHandler2);
      if (child.leaving) {
        _this5.removeChildData(getKey(child));
      }
    };
    domNode.addEventListener(transitionEnd, transitionEndHandler);
  };
  FlipMove.prototype.triggerFinishHooks = function triggerFinishHooks(child, domNode) {
    var _this6 = this;
    if (this.props.onFinish)
      this.props.onFinish(child, domNode);
    this.remainingAnimations -= 1;
    if (this.remainingAnimations === 0) {
      var nextChildren = this.state.children.filter(function(_ref2) {
        var leaving = _ref2.leaving;
        return !leaving;
      }).map(function(item) {
        return _extends({}, item, {
          // fix for Flow
          element: item.element,
          appearing: false,
          entering: false
        });
      });
      this.setState({ children: nextChildren }, function() {
        if (typeof _this6.props.onFinishAll === "function") {
          _this6.callChildrenHook(_this6.props.onFinishAll);
        }
        _this6.childrenToAnimate = [];
      });
      if (this.heightPlaceholderData.domNode) {
        this.heightPlaceholderData.domNode.style.height = "0";
      }
    }
  };
  FlipMove.prototype.callChildrenHook = function callChildrenHook(hook) {
    var _this7 = this;
    var elements = [];
    var domNodes = [];
    this.childrenToAnimate.forEach(function(childKey) {
      var child = _this7.findChildByKey(childKey);
      if (!child) {
        return;
      }
      elements.push(child);
      if (_this7.hasChildData(childKey)) {
        domNodes.push(_this7.getChildData(childKey).domNode);
      }
    });
    hook(elements, domNodes);
  };
  FlipMove.prototype.updateBoundingBoxCaches = function updateBoundingBoxCaches() {
    var _this8 = this;
    var parentDomNode = this.parentData.domNode;
    if (!parentDomNode) {
      return;
    }
    this.parentData.boundingBox = this.props.getPosition(parentDomNode);
    var childrenBoundingBoxes = [];
    this.state.children.forEach(function(child) {
      var childKey = getKey(child);
      if (!childKey) {
        childrenBoundingBoxes.push(null);
        return;
      }
      if (!_this8.hasChildData(childKey)) {
        childrenBoundingBoxes.push(null);
        return;
      }
      var childData = _this8.getChildData(childKey);
      if (!childData.domNode || !child) {
        childrenBoundingBoxes.push(null);
        return;
      }
      childrenBoundingBoxes.push(getRelativeBoundingBox({
        childDomNode: childData.domNode,
        parentDomNode,
        getPosition: _this8.props.getPosition
      }));
    });
    this.state.children.forEach(function(child, index) {
      var childKey = getKey(child);
      var childBoundingBox = childrenBoundingBoxes[index];
      if (!childKey) {
        return;
      }
      _this8.setChildData(childKey, {
        boundingBox: childBoundingBox
      });
    });
  };
  FlipMove.prototype.computeInitialStyles = function computeInitialStyles(child) {
    if (child.appearing) {
      return this.props.appearAnimation ? this.props.appearAnimation.from : {};
    } else if (child.entering) {
      if (!this.props.enterAnimation) {
        return {};
      }
      return _extends({
        position: "",
        top: "",
        left: "",
        right: "",
        bottom: ""
      }, this.props.enterAnimation.from);
    } else if (child.leaving) {
      return this.props.leaveAnimation ? this.props.leaveAnimation.from : {};
    }
    var childData = this.getChildData(getKey(child));
    var childDomNode = childData.domNode;
    var childBoundingBox = childData.boundingBox;
    var parentBoundingBox = this.parentData.boundingBox;
    if (!childDomNode) {
      return {};
    }
    var _getPositionDelta2 = getPositionDelta({
      childDomNode,
      childBoundingBox,
      parentBoundingBox,
      getPosition: this.props.getPosition
    }), dX = _getPositionDelta2[0], dY = _getPositionDelta2[1];
    return {
      transform: "translate(" + dX + "px, " + dY + "px)"
    };
  };
  FlipMove.prototype.isAnimationDisabled = function isAnimationDisabled(props) {
    return noBrowserSupport || props.disableAllAnimations || props.duration === 0 && props.delay === 0 && props.staggerDurationBy === 0 && props.staggerDelayBy === 0;
  };
  FlipMove.prototype.findChildByKey = function findChildByKey(key) {
    return find(function(child) {
      return getKey(child) === key;
    }, this.state.children);
  };
  FlipMove.prototype.hasChildData = function hasChildData(key) {
    return Object.prototype.hasOwnProperty.call(this.childrenData, key);
  };
  FlipMove.prototype.getChildData = function getChildData(key) {
    return this.hasChildData(key) ? this.childrenData[key] : {};
  };
  FlipMove.prototype.setChildData = function setChildData(key, data) {
    this.childrenData[key] = _extends({}, this.getChildData(key), data);
  };
  FlipMove.prototype.removeChildData = function removeChildData(key) {
    delete this.childrenData[key];
    this.setState(function(prevState) {
      return _extends({}, prevState, {
        children: prevState.children.filter(function(child) {
          return child.element.key !== key;
        })
      });
    });
  };
  FlipMove.prototype.createHeightPlaceholder = function createHeightPlaceholder() {
    var _this9 = this;
    var typeName = this.props.typeName;
    var isContainerAList = typeName === "ul" || typeName === "ol";
    var placeholderType = isContainerAList ? "li" : "div";
    return (0, import_react.createElement)(placeholderType, {
      key: "height-placeholder",
      ref: function ref(domNode) {
        _this9.heightPlaceholderData.domNode = domNode;
      },
      style: { visibility: "hidden", height: 0 }
    });
  };
  FlipMove.prototype.childrenWithRefs = function childrenWithRefs() {
    var _this10 = this;
    return this.state.children.map(function(child) {
      return (0, import_react.cloneElement)(child.element, {
        ref: function ref(element) {
          if (!element) {
            return;
          }
          var domNode = getNativeNode(element);
          _this10.setChildData(getKey(child), { domNode });
        }
      });
    });
  };
  FlipMove.prototype.render = function render() {
    var _this11 = this;
    var _props2 = this.props, typeName = _props2.typeName, delegated = _props2.delegated, leaveAnimation = _props2.leaveAnimation, maintainContainerHeight = _props2.maintainContainerHeight;
    var children = this.childrenWithRefs();
    if (leaveAnimation && maintainContainerHeight) {
      children.push(this.createHeightPlaceholder());
    }
    if (!typeName)
      return children;
    var props = _extends({}, delegated, {
      children,
      ref: function ref(node) {
        _this11.parentData.domNode = node;
      }
    });
    return (0, import_react.createElement)(typeName, props);
  };
  return FlipMove;
}(import_react.Component);
var enhancedFlipMove = propConverter(FlipMove$1);
var react_flip_move_es_default = enhancedFlipMove;
export {
  react_flip_move_es_default as default
};
//# sourceMappingURL=react-flip-move.js.map
