import {
  require_object_assign
} from "./chunk-RPRH3NKW.js";
import {
  __decorate
} from "./chunk-DPF5S65K.js";
import {
  require_jsx_runtime
} from "./chunk-NRX3E354.js";
import {
  require_react
} from "./chunk-4BTUQGSU.js";
import {
  __commonJS,
  __export,
  __require,
  __toESM
} from "./chunk-2LSFTFF7.js";

// ../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../node_modules/events/events.js
var require_events = __commonJS({
  "../node_modules/events/events.js"(exports, module) {
    "use strict";
    var R3 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply5 = R3 && typeof R3.apply === "function" ? R3.apply : function ReflectApply6(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys3;
    if (R3 && typeof R3.ownKeys === "function") {
      ReflectOwnKeys3 = R3.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys3 = function ReflectOwnKeys4(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys3 = function ReflectOwnKeys4(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning3(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN5 = Number.isNaN || function NumberIsNaN6(value2) {
      return value2 !== value2;
    };
    function EventEmitter3() {
      EventEmitter3.init.call(this);
    }
    module.exports = EventEmitter3;
    module.exports.once = once5;
    EventEmitter3.EventEmitter = EventEmitter3;
    EventEmitter3.prototype._events = void 0;
    EventEmitter3.prototype._eventsCount = 0;
    EventEmitter3.prototype._maxListeners = void 0;
    var defaultMaxListeners3 = 10;
    function checkListener3(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter3, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners3;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN5(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners3 = arg;
      }
    });
    EventEmitter3.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter3.prototype.setMaxListeners = function setMaxListeners3(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN5(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners3(that) {
      if (that._maxListeners === void 0)
        return EventEmitter3.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter3.prototype.getMaxListeners = function getMaxListeners3() {
      return _getMaxListeners3(this);
    };
    EventEmitter3.prototype.emit = function emit5(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events4 = this._events;
      if (events4 !== void 0)
        doError = doError && events4.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er2;
        if (args.length > 0)
          er2 = args[0];
        if (er2 instanceof Error) {
          throw er2;
        }
        var err2 = new Error("Unhandled error." + (er2 ? " (" + er2.message + ")" : ""));
        err2.context = er2;
        throw err2;
      }
      var handler = events4[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply5(handler, this, args);
      } else {
        var len = handler.length;
        var listeners3 = arrayClone3(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply5(listeners3[i], this, args);
      }
      return true;
    };
    function _addListener3(target, type, listener, prepend) {
      var m2;
      var events4;
      var existing;
      checkListener3(listener);
      events4 = target._events;
      if (events4 === void 0) {
        events4 = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events4.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events4 = target._events;
        }
        existing = events4[type];
      }
      if (existing === void 0) {
        existing = events4[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events4[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m2 = _getMaxListeners3(target);
        if (m2 > 0 && existing.length > m2 && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning3(w);
        }
      }
      return target;
    }
    EventEmitter3.prototype.addListener = function addListener5(type, listener) {
      return _addListener3(this, type, listener, false);
    };
    EventEmitter3.prototype.on = EventEmitter3.prototype.addListener;
    EventEmitter3.prototype.prependListener = function prependListener5(type, listener) {
      return _addListener3(this, type, listener, true);
    };
    function onceWrapper3() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap3(target, type, listener) {
      var state2 = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper3.bind(state2);
      wrapped.listener = listener;
      state2.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter3.prototype.once = function once6(type, listener) {
      checkListener3(listener);
      this.on(type, _onceWrap3(this, type, listener));
      return this;
    };
    EventEmitter3.prototype.prependOnceListener = function prependOnceListener3(type, listener) {
      checkListener3(listener);
      this.prependListener(type, _onceWrap3(this, type, listener));
      return this;
    };
    EventEmitter3.prototype.removeListener = function removeListener5(type, listener) {
      var list, events4, position, i, originalListener;
      checkListener3(listener);
      events4 = this._events;
      if (events4 === void 0)
        return this;
      list = events4[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events4[type];
          if (events4.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne3(list, position);
        }
        if (list.length === 1)
          events4[type] = list[0];
        if (events4.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners5(type) {
      var listeners3, events4, i;
      events4 = this._events;
      if (events4 === void 0)
        return this;
      if (events4.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events4[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events4[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys5 = Object.keys(events4);
        var key;
        for (i = 0; i < keys5.length; ++i) {
          key = keys5[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners3 = events4[type];
      if (typeof listeners3 === "function") {
        this.removeListener(type, listeners3);
      } else if (listeners3 !== void 0) {
        for (i = listeners3.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners3[i]);
        }
      }
      return this;
    };
    function _listeners3(target, type, unwrap) {
      var events4 = target._events;
      if (events4 === void 0)
        return [];
      var evlistener = events4[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners3(evlistener) : arrayClone3(evlistener, evlistener.length);
    }
    EventEmitter3.prototype.listeners = function listeners3(type) {
      return _listeners3(this, type, true);
    };
    EventEmitter3.prototype.rawListeners = function rawListeners3(type) {
      return _listeners3(this, type, false);
    };
    EventEmitter3.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount3.call(emitter, type);
      }
    };
    EventEmitter3.prototype.listenerCount = listenerCount3;
    function listenerCount3(type) {
      var events4 = this._events;
      if (events4 !== void 0) {
        var evlistener = events4[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames3() {
      return this._eventsCount > 0 ? ReflectOwnKeys3(this._events) : [];
    };
    function arrayClone3(arr, n) {
      var copy6 = new Array(n);
      for (var i = 0; i < n; ++i)
        copy6[i] = arr[i];
      return copy6;
    }
    function spliceOne3(list, index3) {
      for (; index3 + 1 < list.length; index3++)
        list[index3] = list[index3 + 1];
      list.pop();
    }
    function unwrapListeners3(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once5(emitter, name) {
      return new Promise(function(resolve3, reject) {
        function errorListener(err2) {
          emitter.removeListener(name, resolver);
          reject(err2);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve3([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener3(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter3(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter3(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener3(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener3(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// ../node_modules/queue/index.js
var require_queue = __commonJS({
  "../node_modules/queue/index.js"(exports, module) {
    var inherits = require_inherits_browser();
    var EventEmitter3 = require_events().EventEmitter;
    module.exports = Queue;
    module.exports.default = Queue;
    function Queue(options) {
      if (!(this instanceof Queue)) {
        return new Queue(options);
      }
      EventEmitter3.call(this);
      options = options || {};
      this.concurrency = options.concurrency || Infinity;
      this.timeout = options.timeout || 0;
      this.autostart = options.autostart || false;
      this.results = options.results || null;
      this.pending = 0;
      this.session = 0;
      this.running = false;
      this.jobs = [];
      this.timers = {};
    }
    inherits(Queue, EventEmitter3);
    var arrayMethods = [
      "pop",
      "shift",
      "indexOf",
      "lastIndexOf"
    ];
    arrayMethods.forEach(function(method) {
      Queue.prototype[method] = function() {
        return Array.prototype[method].apply(this.jobs, arguments);
      };
    });
    Queue.prototype.slice = function(begin, end3) {
      this.jobs = this.jobs.slice(begin, end3);
      return this;
    };
    Queue.prototype.reverse = function() {
      this.jobs.reverse();
      return this;
    };
    var arrayAddMethods = [
      "push",
      "unshift",
      "splice"
    ];
    arrayAddMethods.forEach(function(method) {
      Queue.prototype[method] = function() {
        var methodResult = Array.prototype[method].apply(this.jobs, arguments);
        if (this.autostart) {
          this.start();
        }
        return methodResult;
      };
    });
    Object.defineProperty(Queue.prototype, "length", {
      get: function() {
        return this.pending + this.jobs.length;
      }
    });
    Queue.prototype.start = function(cb) {
      if (cb) {
        callOnErrorOrEnd.call(this, cb);
      }
      this.running = true;
      if (this.pending >= this.concurrency) {
        return;
      }
      if (this.jobs.length === 0) {
        if (this.pending === 0) {
          done3.call(this);
        }
        return;
      }
      var self2 = this;
      var job = this.jobs.shift();
      var once5 = true;
      var session = this.session;
      var timeoutId = null;
      var didTimeout = false;
      var resultIndex = null;
      var timeout = job.hasOwnProperty("timeout") ? job.timeout : this.timeout;
      function next2(err2, result) {
        if (once5 && self2.session === session) {
          once5 = false;
          self2.pending--;
          if (timeoutId !== null) {
            delete self2.timers[timeoutId];
            clearTimeout(timeoutId);
          }
          if (err2) {
            self2.emit("error", err2, job);
          } else if (didTimeout === false) {
            if (resultIndex !== null) {
              self2.results[resultIndex] = Array.prototype.slice.call(arguments, 1);
            }
            self2.emit("success", result, job);
          }
          if (self2.session === session) {
            if (self2.pending === 0 && self2.jobs.length === 0) {
              done3.call(self2);
            } else if (self2.running) {
              self2.start();
            }
          }
        }
      }
      if (timeout) {
        timeoutId = setTimeout(function() {
          didTimeout = true;
          if (self2.listeners("timeout").length > 0) {
            self2.emit("timeout", next2, job);
          } else {
            next2();
          }
        }, timeout);
        this.timers[timeoutId] = timeoutId;
      }
      if (this.results) {
        resultIndex = this.results.length;
        this.results[resultIndex] = null;
      }
      this.pending++;
      self2.emit("start", job);
      var promise = job(next2);
      if (promise && promise.then && typeof promise.then === "function") {
        promise.then(function(result) {
          return next2(null, result);
        }).catch(function(err2) {
          return next2(err2 || true);
        });
      }
      if (this.running && this.jobs.length > 0) {
        this.start();
      }
    };
    Queue.prototype.stop = function() {
      this.running = false;
    };
    Queue.prototype.end = function(err2) {
      clearTimers.call(this);
      this.jobs.length = 0;
      this.pending = 0;
      done3.call(this, err2);
    };
    function clearTimers() {
      for (var key in this.timers) {
        var timeoutId = this.timers[key];
        delete this.timers[key];
        clearTimeout(timeoutId);
      }
    }
    function callOnErrorOrEnd(cb) {
      var self2 = this;
      this.on("error", onerror);
      this.on("end", onend3);
      function onerror(err2) {
        self2.end(err2);
      }
      function onend3(err2) {
        self2.removeListener("error", onerror);
        self2.removeListener("end", onend3);
        cb(err2, this.results);
      }
    }
    function done3(err2) {
      this.session++;
      this.running = false;
      this.emit("end", err2);
    }
  }
});

// ../node_modules/is-url/index.js
var require_is_url = __commonJS({
  "../node_modules/is-url/index.js"(exports, module) {
    module.exports = isUrl;
    var protocolAndDomainRE = /^(?:\w+:)?\/\/(\S+)$/;
    var localhostDomainRE = /^localhost[\:?\d]*(?:[^\:?\d]\S*)?$/;
    var nonLocalhostDomainRE = /^[^\s\.]+\.\S{2,}$/;
    function isUrl(string) {
      if (typeof string !== "string") {
        return false;
      }
      var match = string.match(protocolAndDomainRE);
      if (!match) {
        return false;
      }
      var everythingAfterProtocol = match[1];
      if (!everythingAfterProtocol) {
        return false;
      }
      if (localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol)) {
        return true;
      }
      return false;
    }
  }
});

// ../node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "../node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var global2 = typeof self !== "undefined" ? self : exports;
    var __self__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      F.prototype = global2;
      return new F();
    }();
    (function(self2) {
      var irrelevant = function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView3 = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        function normalizeValue(value2) {
          if (typeof value2 !== "string") {
            value2 = String(value2);
          }
          return value2;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value2 = items.shift();
              return { done: value2 === void 0, value: value2 };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value2, name) {
              this.append(name, value2);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value2) {
          name = normalizeName(name);
          value2 = normalizeValue(value2);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value2 : value2;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value2) {
          this.map[normalizeName(name)] = normalizeValue(value2);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value2, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value2) {
            items.push(value2);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value2, name) {
            items.push([name, value2]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve3, reject) {
            reader.onload = function() {
              resolve3(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView3(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split3 = bytes.split("=");
              var name = split3.shift().replace(/\+/g, " ");
              var value2 = split3.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value2));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line2) {
            var parts = line2.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value2 = parts.join(":").trim();
              headers.append(key, value2);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err2) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch3(input, init4) {
          return new Promise(function(resolve3, reject) {
            var request = new Request(input, init4);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve3(new Response(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value2, name) {
              xhr.setRequestHeader(name, value2);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch3.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch3;
          self2.Headers = Headers;
          self2.Request = Request;
          self2.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch3;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// ../node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "../node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal3(a2, b) {
      if (a2 === b)
        return true;
      if (a2 && b && typeof a2 == "object" && typeof b == "object") {
        if (a2.constructor !== b.constructor)
          return false;
        var length4, i, keys5;
        if (Array.isArray(a2)) {
          length4 = a2.length;
          if (length4 != b.length)
            return false;
          for (i = length4; i-- !== 0; )
            if (!equal3(a2[i], b[i]))
              return false;
          return true;
        }
        if (a2.constructor === RegExp)
          return a2.source === b.source && a2.flags === b.flags;
        if (a2.valueOf !== Object.prototype.valueOf)
          return a2.valueOf() === b.valueOf();
        if (a2.toString !== Object.prototype.toString)
          return a2.toString() === b.toString();
        keys5 = Object.keys(a2);
        length4 = keys5.length;
        if (length4 !== Object.keys(b).length)
          return false;
        for (i = length4; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys5[i]))
            return false;
        for (i = length4; i-- !== 0; ) {
          var key = keys5[i];
          if (!equal3(a2[key], b[key]))
            return false;
        }
        return true;
      }
      return a2 !== a2 && b !== b;
    };
  }
});

// ../node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength5;
    exports.toByteArray = toByteArray4;
    exports.fromByteArray = fromByteArray4;
    var lookup4 = [];
    var revLookup4 = [];
    var Arr4 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code3.length; i < len; ++i) {
      lookup4[i] = code3[i];
      revLookup4[code3.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup4["-".charCodeAt(0)] = 62;
    revLookup4["_".charCodeAt(0)] = 63;
    function getLens3(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength5(b64) {
      var lens = getLens3(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength3(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray4(b64) {
      var tmp;
      var lens = getLens3(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr4(_byteLength3(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup4[b64.charCodeAt(i2)] << 18 | revLookup4[b64.charCodeAt(i2 + 1)] << 12 | revLookup4[b64.charCodeAt(i2 + 2)] << 6 | revLookup4[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup4[b64.charCodeAt(i2)] << 2 | revLookup4[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup4[b64.charCodeAt(i2)] << 10 | revLookup4[b64.charCodeAt(i2 + 1)] << 4 | revLookup4[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase644(num) {
      return lookup4[num >> 18 & 63] + lookup4[num >> 12 & 63] + lookup4[num >> 6 & 63] + lookup4[num & 63];
    }
    function encodeChunk4(uint82, start3, end3) {
      var tmp;
      var output = [];
      for (var i2 = start3; i2 < end3; i2 += 3) {
        tmp = (uint82[i2] << 16 & 16711680) + (uint82[i2 + 1] << 8 & 65280) + (uint82[i2 + 2] & 255);
        output.push(tripletToBase644(tmp));
      }
      return output.join("");
    }
    function fromByteArray4(uint82) {
      var tmp;
      var len2 = uint82.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk4(uint82, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint82[len2 - 1];
        parts.push(
          lookup4[tmp >> 2] + lookup4[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint82[len2 - 2] << 8) + uint82[len2 - 1];
        parts.push(
          lookup4[tmp >> 10] + lookup4[tmp >> 4 & 63] + lookup4[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// ../node_modules/tiny-inflate/index.js
var require_tiny_inflate = __commonJS({
  "../node_modules/tiny-inflate/index.js"(exports, module) {
    var TINF_OK = 0;
    var TINF_DATA_ERROR = -3;
    function Tree() {
      this.table = new Uint16Array(16);
      this.trans = new Uint16Array(288);
    }
    function Data(source, dest) {
      this.source = source;
      this.sourceIndex = 0;
      this.tag = 0;
      this.bitcount = 0;
      this.dest = dest;
      this.destLen = 0;
      this.ltree = new Tree();
      this.dtree = new Tree();
    }
    var sltree = new Tree();
    var sdtree = new Tree();
    var length_bits = new Uint8Array(30);
    var length_base = new Uint16Array(30);
    var dist_bits = new Uint8Array(30);
    var dist_base = new Uint16Array(30);
    var clcidx = new Uint8Array([
      16,
      17,
      18,
      0,
      8,
      7,
      9,
      6,
      10,
      5,
      11,
      4,
      12,
      3,
      13,
      2,
      14,
      1,
      15
    ]);
    var code_tree = new Tree();
    var lengths = new Uint8Array(288 + 32);
    function tinf_build_bits_base(bits, base, delta, first) {
      var i, sum;
      for (i = 0; i < delta; ++i)
        bits[i] = 0;
      for (i = 0; i < 30 - delta; ++i)
        bits[i + delta] = i / delta | 0;
      for (sum = first, i = 0; i < 30; ++i) {
        base[i] = sum;
        sum += 1 << bits[i];
      }
    }
    function tinf_build_fixed_trees(lt, dt) {
      var i;
      for (i = 0; i < 7; ++i)
        lt.table[i] = 0;
      lt.table[7] = 24;
      lt.table[8] = 152;
      lt.table[9] = 112;
      for (i = 0; i < 24; ++i)
        lt.trans[i] = 256 + i;
      for (i = 0; i < 144; ++i)
        lt.trans[24 + i] = i;
      for (i = 0; i < 8; ++i)
        lt.trans[24 + 144 + i] = 280 + i;
      for (i = 0; i < 112; ++i)
        lt.trans[24 + 144 + 8 + i] = 144 + i;
      for (i = 0; i < 5; ++i)
        dt.table[i] = 0;
      dt.table[5] = 32;
      for (i = 0; i < 32; ++i)
        dt.trans[i] = i;
    }
    var offs = new Uint16Array(16);
    function tinf_build_tree(t2, lengths2, off3, num) {
      var i, sum;
      for (i = 0; i < 16; ++i)
        t2.table[i] = 0;
      for (i = 0; i < num; ++i)
        t2.table[lengths2[off3 + i]]++;
      t2.table[0] = 0;
      for (sum = 0, i = 0; i < 16; ++i) {
        offs[i] = sum;
        sum += t2.table[i];
      }
      for (i = 0; i < num; ++i) {
        if (lengths2[off3 + i])
          t2.trans[offs[lengths2[off3 + i]]++] = i;
      }
    }
    function tinf_getbit(d) {
      if (!d.bitcount--) {
        d.tag = d.source[d.sourceIndex++];
        d.bitcount = 7;
      }
      var bit = d.tag & 1;
      d.tag >>>= 1;
      return bit;
    }
    function tinf_read_bits(d, num, base) {
      if (!num)
        return base;
      while (d.bitcount < 24) {
        d.tag |= d.source[d.sourceIndex++] << d.bitcount;
        d.bitcount += 8;
      }
      var val = d.tag & 65535 >>> 16 - num;
      d.tag >>>= num;
      d.bitcount -= num;
      return val + base;
    }
    function tinf_decode_symbol(d, t2) {
      while (d.bitcount < 24) {
        d.tag |= d.source[d.sourceIndex++] << d.bitcount;
        d.bitcount += 8;
      }
      var sum = 0, cur = 0, len = 0;
      var tag = d.tag;
      do {
        cur = 2 * cur + (tag & 1);
        tag >>>= 1;
        ++len;
        sum += t2.table[len];
        cur -= t2.table[len];
      } while (cur >= 0);
      d.tag = tag;
      d.bitcount -= len;
      return t2.trans[sum + cur];
    }
    function tinf_decode_trees(d, lt, dt) {
      var hlit, hdist, hclen;
      var i, num, length4;
      hlit = tinf_read_bits(d, 5, 257);
      hdist = tinf_read_bits(d, 5, 1);
      hclen = tinf_read_bits(d, 4, 4);
      for (i = 0; i < 19; ++i)
        lengths[i] = 0;
      for (i = 0; i < hclen; ++i) {
        var clen = tinf_read_bits(d, 3, 0);
        lengths[clcidx[i]] = clen;
      }
      tinf_build_tree(code_tree, lengths, 0, 19);
      for (num = 0; num < hlit + hdist; ) {
        var sym = tinf_decode_symbol(d, code_tree);
        switch (sym) {
          case 16:
            var prev = lengths[num - 1];
            for (length4 = tinf_read_bits(d, 2, 3); length4; --length4) {
              lengths[num++] = prev;
            }
            break;
          case 17:
            for (length4 = tinf_read_bits(d, 3, 3); length4; --length4) {
              lengths[num++] = 0;
            }
            break;
          case 18:
            for (length4 = tinf_read_bits(d, 7, 11); length4; --length4) {
              lengths[num++] = 0;
            }
            break;
          default:
            lengths[num++] = sym;
            break;
        }
      }
      tinf_build_tree(lt, lengths, 0, hlit);
      tinf_build_tree(dt, lengths, hlit, hdist);
    }
    function tinf_inflate_block_data(d, lt, dt) {
      while (1) {
        var sym = tinf_decode_symbol(d, lt);
        if (sym === 256) {
          return TINF_OK;
        }
        if (sym < 256) {
          d.dest[d.destLen++] = sym;
        } else {
          var length4, dist, offs2;
          var i;
          sym -= 257;
          length4 = tinf_read_bits(d, length_bits[sym], length_base[sym]);
          dist = tinf_decode_symbol(d, dt);
          offs2 = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
          for (i = offs2; i < offs2 + length4; ++i) {
            d.dest[d.destLen++] = d.dest[i];
          }
        }
      }
    }
    function tinf_inflate_uncompressed_block(d) {
      var length4, invlength;
      var i;
      while (d.bitcount > 8) {
        d.sourceIndex--;
        d.bitcount -= 8;
      }
      length4 = d.source[d.sourceIndex + 1];
      length4 = 256 * length4 + d.source[d.sourceIndex];
      invlength = d.source[d.sourceIndex + 3];
      invlength = 256 * invlength + d.source[d.sourceIndex + 2];
      if (length4 !== (~invlength & 65535))
        return TINF_DATA_ERROR;
      d.sourceIndex += 4;
      for (i = length4; i; --i)
        d.dest[d.destLen++] = d.source[d.sourceIndex++];
      d.bitcount = 0;
      return TINF_OK;
    }
    function tinf_uncompress(source, dest) {
      var d = new Data(source, dest);
      var bfinal, btype, res;
      do {
        bfinal = tinf_getbit(d);
        btype = tinf_read_bits(d, 2, 0);
        switch (btype) {
          case 0:
            res = tinf_inflate_uncompressed_block(d);
            break;
          case 1:
            res = tinf_inflate_block_data(d, sltree, sdtree);
            break;
          case 2:
            tinf_decode_trees(d, d.ltree, d.dtree);
            res = tinf_inflate_block_data(d, d.ltree, d.dtree);
            break;
          default:
            res = TINF_DATA_ERROR;
        }
        if (res !== TINF_OK)
          throw new Error("Data error");
      } while (!bfinal);
      if (d.destLen < d.dest.length) {
        if (typeof d.dest.slice === "function")
          return d.dest.slice(0, d.destLen);
        else
          return d.dest.subarray(0, d.destLen);
      }
      return d.dest;
    }
    tinf_build_fixed_trees(sltree, sdtree);
    tinf_build_bits_base(length_bits, length_base, 4, 3);
    tinf_build_bits_base(dist_bits, dist_base, 2, 1);
    length_bits[28] = 0;
    length_base[28] = 258;
    module.exports = tinf_uncompress;
  }
});

// ../node_modules/unicode-trie/swap.js
var require_swap = __commonJS({
  "../node_modules/unicode-trie/swap.js"(exports, module) {
    var isBigEndian2 = new Uint8Array(new Uint32Array([305419896]).buffer)[0] === 18;
    var swap4 = (b, n, m2) => {
      let i = b[n];
      b[n] = b[m2];
      b[m2] = i;
    };
    var swap324 = (array) => {
      const len = array.length;
      for (let i = 0; i < len; i += 4) {
        swap4(array, i, i + 3);
        swap4(array, i + 1, i + 2);
      }
    };
    var swap32LE = (array) => {
      if (isBigEndian2) {
        swap324(array);
      }
    };
    module.exports = {
      swap32LE
    };
  }
});

// ../node_modules/unicode-trie/index.js
var require_unicode_trie = __commonJS({
  "../node_modules/unicode-trie/index.js"(exports, module) {
    var inflate2 = require_tiny_inflate();
    var { swap32LE } = require_swap();
    var SHIFT_1 = 6 + 5;
    var SHIFT_2 = 5;
    var SHIFT_1_2 = SHIFT_1 - SHIFT_2;
    var OMITTED_BMP_INDEX_1_LENGTH = 65536 >> SHIFT_1;
    var INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;
    var INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;
    var INDEX_SHIFT = 2;
    var DATA_BLOCK_LENGTH = 1 << SHIFT_2;
    var DATA_MASK = DATA_BLOCK_LENGTH - 1;
    var LSCP_INDEX_2_OFFSET = 65536 >> SHIFT_2;
    var LSCP_INDEX_2_LENGTH = 1024 >> SHIFT_2;
    var INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;
    var UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;
    var UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
    var INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;
    var DATA_GRANULARITY = 1 << INDEX_SHIFT;
    var UnicodeTrie = class {
      constructor(data2) {
        const isBuffer6 = typeof data2.readUInt32BE === "function" && typeof data2.slice === "function";
        if (isBuffer6 || data2 instanceof Uint8Array) {
          let uncompressedLength;
          if (isBuffer6) {
            this.highStart = data2.readUInt32LE(0);
            this.errorValue = data2.readUInt32LE(4);
            uncompressedLength = data2.readUInt32LE(8);
            data2 = data2.slice(12);
          } else {
            const view = new DataView(data2.buffer);
            this.highStart = view.getUint32(0, true);
            this.errorValue = view.getUint32(4, true);
            uncompressedLength = view.getUint32(8, true);
            data2 = data2.subarray(12);
          }
          data2 = inflate2(data2, new Uint8Array(uncompressedLength));
          data2 = inflate2(data2, new Uint8Array(uncompressedLength));
          swap32LE(data2);
          this.data = new Uint32Array(data2.buffer);
        } else {
          ({ data: this.data, highStart: this.highStart, errorValue: this.errorValue } = data2);
        }
      }
      get(codePoint) {
        let index3;
        if (codePoint < 0 || codePoint > 1114111) {
          return this.errorValue;
        }
        if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
          index3 = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index3];
        }
        if (codePoint <= 65535) {
          index3 = (this.data[LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index3];
        }
        if (codePoint < this.highStart) {
          index3 = this.data[INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> SHIFT_1)];
          index3 = this.data[index3 + (codePoint >> SHIFT_2 & INDEX_2_MASK)];
          index3 = (index3 << INDEX_SHIFT) + (codePoint & DATA_MASK);
          return this.data[index3];
        }
        return this.data[this.data.length - DATA_GRANULARITY];
      }
    };
    module.exports = UnicodeTrie;
  }
});

// ../node_modules/dfa/index.js
var require_dfa = __commonJS({
  "../node_modules/dfa/index.js"(exports, module) {
    "use strict";
    var INITIAL_STATE = 1;
    var FAIL_STATE = 0;
    var StateMachine = class {
      constructor(dfa) {
        this.stateTable = dfa.stateTable;
        this.accepting = dfa.accepting;
        this.tags = dfa.tags;
      }
      /**
       * Returns an iterable object that yields pattern matches over the input sequence.
       * Matches are of the form [startIndex, endIndex, tags].
       */
      match(str) {
        var self2 = this;
        return {
          *[Symbol.iterator]() {
            var state2 = INITIAL_STATE;
            var startRun = null;
            var lastAccepting = null;
            var lastState = null;
            for (var p = 0; p < str.length; p++) {
              var c2 = str[p];
              lastState = state2;
              state2 = self2.stateTable[state2][c2];
              if (state2 === FAIL_STATE) {
                if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {
                  yield [startRun, lastAccepting, self2.tags[lastState]];
                }
                state2 = self2.stateTable[INITIAL_STATE][c2];
                startRun = null;
              }
              if (state2 !== FAIL_STATE && startRun == null) {
                startRun = p;
              }
              if (self2.accepting[state2]) {
                lastAccepting = p;
              }
              if (state2 === FAIL_STATE) {
                state2 = INITIAL_STATE;
              }
            }
            if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {
              yield [startRun, lastAccepting, self2.tags[state2]];
            }
          }
        };
      }
      /**
       * For each match over the input sequence, action functions matching
       * the tag definitions in the input pattern are called with the startIndex,
       * endIndex, and sub-match sequence.
       */
      apply(str, actions) {
        for (var [start3, end3, tags] of this.match(str)) {
          for (var tag of tags) {
            if (typeof actions[tag] === "function") {
              actions[tag](start3, end3, str.slice(start3, end3 + 1));
            }
          }
        }
      }
    };
    module.exports = StateMachine;
  }
});

// ../node_modules/clone/clone.js
var require_clone = __commonJS({
  "../node_modules/clone/clone.js"(exports, module) {
    var clone = function() {
      "use strict";
      function _instanceof(obj, type) {
        return type != null && obj instanceof type;
      }
      var nativeMap;
      try {
        nativeMap = Map;
      } catch (_) {
        nativeMap = function() {
        };
      }
      var nativeSet;
      try {
        nativeSet = Set;
      } catch (_) {
        nativeSet = function() {
        };
      }
      var nativePromise;
      try {
        nativePromise = Promise;
      } catch (_) {
        nativePromise = function() {
        };
      }
      function clone2(parent, circular, depth, prototype, includeNonEnumerable) {
        if (typeof circular === "object") {
          depth = circular.depth;
          prototype = circular.prototype;
          includeNonEnumerable = circular.includeNonEnumerable;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth == "undefined")
          depth = Infinity;
        function _clone(parent2, depth2) {
          if (parent2 === null)
            return null;
          if (depth2 === 0)
            return parent2;
          var child;
          var proto;
          if (typeof parent2 != "object") {
            return parent2;
          }
          if (_instanceof(parent2, nativeMap)) {
            child = new nativeMap();
          } else if (_instanceof(parent2, nativeSet)) {
            child = new nativeSet();
          } else if (_instanceof(parent2, nativePromise)) {
            child = new nativePromise(function(resolve3, reject) {
              parent2.then(function(value2) {
                resolve3(_clone(value2, depth2 - 1));
              }, function(err2) {
                reject(_clone(err2, depth2 - 1));
              });
            });
          } else if (clone2.__isArray(parent2)) {
            child = [];
          } else if (clone2.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex)
              child.lastIndex = parent2.lastIndex;
          } else if (clone2.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else if (_instanceof(parent2, Error)) {
            child = Object.create(parent2);
          } else {
            if (typeof prototype == "undefined") {
              proto = Object.getPrototypeOf(parent2);
              child = Object.create(proto);
            } else {
              child = Object.create(prototype);
              proto = prototype;
            }
          }
          if (circular) {
            var index3 = allParents.indexOf(parent2);
            if (index3 != -1) {
              return allChildren[index3];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          if (_instanceof(parent2, nativeMap)) {
            parent2.forEach(function(value2, key) {
              var keyChild = _clone(key, depth2 - 1);
              var valueChild = _clone(value2, depth2 - 1);
              child.set(keyChild, valueChild);
            });
          }
          if (_instanceof(parent2, nativeSet)) {
            parent2.forEach(function(value2) {
              var entryChild = _clone(value2, depth2 - 1);
              child.add(entryChild);
            });
          }
          for (var i in parent2) {
            var attrs;
            if (proto) {
              attrs = Object.getOwnPropertyDescriptor(proto, i);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i] = _clone(parent2[i], depth2 - 1);
          }
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(parent2);
            for (var i = 0; i < symbols.length; i++) {
              var symbol = symbols[i];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
              if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                continue;
              }
              child[symbol] = _clone(parent2[symbol], depth2 - 1);
              if (!descriptor.enumerable) {
                Object.defineProperty(child, symbol, {
                  enumerable: false
                });
              }
            }
          }
          if (includeNonEnumerable) {
            var allPropertyNames = Object.getOwnPropertyNames(parent2);
            for (var i = 0; i < allPropertyNames.length; i++) {
              var propertyName = allPropertyNames[i];
              var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
              if (descriptor && descriptor.enumerable) {
                continue;
              }
              child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
              Object.defineProperty(child, propertyName, {
                enumerable: false
              });
            }
          }
          return child;
        }
        return _clone(parent, depth);
      }
      clone2.clonePrototype = function clonePrototype(parent) {
        if (parent === null)
          return null;
        var c2 = function() {
        };
        c2.prototype = parent;
        return new c2();
      };
      function __objToStr(o) {
        return Object.prototype.toString.call(o);
      }
      clone2.__objToStr = __objToStr;
      function __isDate(o) {
        return typeof o === "object" && __objToStr(o) === "[object Date]";
      }
      clone2.__isDate = __isDate;
      function __isArray(o) {
        return typeof o === "object" && __objToStr(o) === "[object Array]";
      }
      clone2.__isArray = __isArray;
      function __isRegExp(o) {
        return typeof o === "object" && __objToStr(o) === "[object RegExp]";
      }
      clone2.__isRegExp = __isRegExp;
      function __getRegExpFlags(re) {
        var flags = "";
        if (re.global)
          flags += "g";
        if (re.ignoreCase)
          flags += "i";
        if (re.multiline)
          flags += "m";
        return flags;
      }
      clone2.__getRegExpFlags = __getRegExpFlags;
      return clone2;
    }();
    if (typeof module === "object" && module.exports) {
      module.exports = clone;
    }
  }
});

// ../node_modules/brotli/dec/streams.js
var require_streams = __commonJS({
  "../node_modules/brotli/dec/streams.js"(exports) {
    function BrotliInput(buffer3) {
      this.buffer = buffer3;
      this.pos = 0;
    }
    BrotliInput.prototype.read = function(buf, i, count) {
      if (this.pos + count > this.buffer.length) {
        count = this.buffer.length - this.pos;
      }
      for (var p = 0; p < count; p++)
        buf[i + p] = this.buffer[this.pos + p];
      this.pos += count;
      return count;
    };
    exports.BrotliInput = BrotliInput;
    function BrotliOutput(buf) {
      this.buffer = buf;
      this.pos = 0;
    }
    BrotliOutput.prototype.write = function(buf, count) {
      if (this.pos + count > this.buffer.length)
        throw new Error("Output buffer is not large enough");
      this.buffer.set(buf.subarray(0, count), this.pos);
      this.pos += count;
      return count;
    };
    exports.BrotliOutput = BrotliOutput;
  }
});

// ../node_modules/brotli/dec/bit_reader.js
var require_bit_reader = __commonJS({
  "../node_modules/brotli/dec/bit_reader.js"(exports, module) {
    var BROTLI_READ_SIZE = 4096;
    var BROTLI_IBUF_SIZE = 2 * BROTLI_READ_SIZE + 32;
    var BROTLI_IBUF_MASK = 2 * BROTLI_READ_SIZE - 1;
    var kBitMask = new Uint32Array([
      0,
      1,
      3,
      7,
      15,
      31,
      63,
      127,
      255,
      511,
      1023,
      2047,
      4095,
      8191,
      16383,
      32767,
      65535,
      131071,
      262143,
      524287,
      1048575,
      2097151,
      4194303,
      8388607,
      16777215
    ]);
    function BrotliBitReader(input) {
      this.buf_ = new Uint8Array(BROTLI_IBUF_SIZE);
      this.input_ = input;
      this.reset();
    }
    BrotliBitReader.READ_SIZE = BROTLI_READ_SIZE;
    BrotliBitReader.IBUF_MASK = BROTLI_IBUF_MASK;
    BrotliBitReader.prototype.reset = function() {
      this.buf_ptr_ = 0;
      this.val_ = 0;
      this.pos_ = 0;
      this.bit_pos_ = 0;
      this.bit_end_pos_ = 0;
      this.eos_ = 0;
      this.readMoreInput();
      for (var i = 0; i < 4; i++) {
        this.val_ |= this.buf_[this.pos_] << 8 * i;
        ++this.pos_;
      }
      return this.bit_end_pos_ > 0;
    };
    BrotliBitReader.prototype.readMoreInput = function() {
      if (this.bit_end_pos_ > 256) {
        return;
      } else if (this.eos_) {
        if (this.bit_pos_ > this.bit_end_pos_)
          throw new Error("Unexpected end of input " + this.bit_pos_ + " " + this.bit_end_pos_);
      } else {
        var dst = this.buf_ptr_;
        var bytes_read = this.input_.read(this.buf_, dst, BROTLI_READ_SIZE);
        if (bytes_read < 0) {
          throw new Error("Unexpected end of input");
        }
        if (bytes_read < BROTLI_READ_SIZE) {
          this.eos_ = 1;
          for (var p = 0; p < 32; p++)
            this.buf_[dst + bytes_read + p] = 0;
        }
        if (dst === 0) {
          for (var p = 0; p < 32; p++)
            this.buf_[(BROTLI_READ_SIZE << 1) + p] = this.buf_[p];
          this.buf_ptr_ = BROTLI_READ_SIZE;
        } else {
          this.buf_ptr_ = 0;
        }
        this.bit_end_pos_ += bytes_read << 3;
      }
    };
    BrotliBitReader.prototype.fillBitWindow = function() {
      while (this.bit_pos_ >= 8) {
        this.val_ >>>= 8;
        this.val_ |= this.buf_[this.pos_ & BROTLI_IBUF_MASK] << 24;
        ++this.pos_;
        this.bit_pos_ = this.bit_pos_ - 8 >>> 0;
        this.bit_end_pos_ = this.bit_end_pos_ - 8 >>> 0;
      }
    };
    BrotliBitReader.prototype.readBits = function(n_bits) {
      if (32 - this.bit_pos_ < n_bits) {
        this.fillBitWindow();
      }
      var val = this.val_ >>> this.bit_pos_ & kBitMask[n_bits];
      this.bit_pos_ += n_bits;
      return val;
    };
    module.exports = BrotliBitReader;
  }
});

// ../node_modules/brotli/dec/dictionary.bin.js
var require_dictionary_bin = __commonJS({
  "../node_modules/brotli/dec/dictionary.bin.js"(exports, module) {
    module.exports = "W5/fcQLn5gKf2XUbAiQ1XULX+TZz6ADToDsgqk6qVfeC0e4m6OO2wcQ1J76ZBVRV1fRkEsdu//62zQsFEZWSTCnMhcsQKlS2qOhuVYYMGCkV0fXWEoMFbESXrKEZ9wdUEsyw9g4bJlEt1Y6oVMxMRTEVbCIwZzJzboK5j8m4YH02qgXYhv1V+PM435sLVxyHJihaJREEhZGqL03txGFQLm76caGO/ovxKvzCby/3vMTtX/459f0igi7WutnKiMQ6wODSoRh/8Lx1V3Q99MvKtwB6bHdERYRY0hStJoMjNeTsNX7bn+Y7e4EQ3bf8xBc7L0BsyfFPK43dGSXpL6clYC/I328h54/VYrQ5i0648FgbGtl837svJ35L3Mot/+nPlNpWgKx1gGXQYqX6n+bbZ7wuyCHKcUok12Xjqub7NXZGzqBx0SD+uziNf87t7ve42jxSKQoW3nyxVrWIGlFShhCKxjpZZ5MeGna0+lBkk+kaN8F9qFBAFgEogyMBdcX/T1W/WnMOi/7ycWUQloEBKGeC48MkiwqJkJO+12eQiOFHMmck6q/IjWW3RZlany23TBm+cNr/84/oi5GGmGBZWrZ6j+zykVozz5fT/QH/Da6WTbZYYPynVNO7kxzuNN2kxKKWche5WveitPKAecB8YcAHz/+zXLjcLzkdDSktNIDwZE9J9X+tto43oJy65wApM3mDzYtCwX9lM+N5VR3kXYo0Z3t0TtXfgBFg7gU8oN0Dgl7fZlUbhNll+0uuohRVKjrEd8egrSndy5/Tgd2gqjA4CAVuC7ESUmL3DZoGnfhQV8uwnpi8EGvAVVsowNRxPudck7+oqAUDkwZopWqFnW1riss0t1z6iCISVKreYGNvQcXv+1L9+jbP8cd/dPUiqBso2q+7ZyFBvENCkkVr44iyPbtOoOoCecWsiuqMSML5lv+vN5MzUr+Dnh73G7Q1YnRYJVYXHRJaNAOByiaK6CusgFdBPE40r0rvqXV7tksKO2DrHYXBTv8P5ysqxEx8VDXUDDqkPH6NNOV/a2WH8zlkXRELSa8P+heNyJBBP7PgsG1EtWtNef6/i+lcayzQwQCsduidpbKfhWUDgAEmyhGu/zVTacI6RS0zTABrOYueemnVa19u9fT23N/Ta6RvTpof5DWygqreCqrDAgM4LID1+1T/taU6yTFVLqXOv+/MuQOFnaF8vLMKD7tKWDoBdALgxF33zQccCcdHx8fKIVdW69O7qHtXpeGr9jbbpFA+qRMWr5hp0s67FPc7HAiLV0g0/peZlW7hJPYEhZyhpSwahnf93/tZgfqZWXFdmdXBzqxGHLrQKxoAY6fRoBhgCRPmmGueYZ5JexTVDKUIXzkG/fqp/0U3hAgQdJ9zumutK6nqWbaqvm1pgu03IYR+G+8s0jDBBz8cApZFSBeuWasyqo2OMDKAZCozS+GWSvL/HsE9rHxooe17U3s/lTE+VZAk4j3dp6uIGaC0JMiqR5CUsabPyM0dOYDR7Ea7ip4USZlya38YfPtvrX/tBlhHilj55nZ1nfN24AOAi9BVtz/Mbn8AEDJCqJgsVUa6nQnSxv2Fs7l/NlCzpfYEjmPrNyib/+t0ei2eEMjvNhLkHCZlci4WhBe7ePZTmzYqlY9+1pxtS4GB+5lM1BHT9tS270EWUDYFq1I0yY/fNiAk4bk9yBgmef/f2k6AlYQZHsNFnW8wBQxCd68iWv7/35bXfz3JZmfGligWAKRjIs3IpzxQ27vAglHSiOzCYzJ9L9A1CdiyFvyR66ucA4jKifu5ehwER26yV7HjKqn5Mfozo7Coxxt8LWWPT47BeMxX8p0Pjb7hZn+6bw7z3Lw+7653j5sI8CLu5kThpMlj1m4c2ch3jGcP1FsT13vuK3qjecKTZk2kHcOZY40UX+qdaxstZqsqQqgXz+QGF99ZJLqr3VYu4aecl1Ab5GmqS8k/GV5b95zxQ5d4EfXUJ6kTS/CXF/aiqKDOT1T7Jz5z0PwDUcwr9clLN1OJGCiKfqvah+h3XzrBOiLOW8wvn8gW6qE8vPxi+Efv+UH55T7PQFVMh6cZ1pZQlzJpKZ7P7uWvwPGJ6DTlR6wbyj3Iv2HyefnRo/dv7dNx+qaa0N38iBsR++Uil7Wd4afwDNsrzDAK4fXZwvEY/jdKuIKXlfrQd2C39dW7ntnRbIp9OtGy9pPBn/V2ASoi/2UJZfS+xuGLH8bnLuPlzdTNS6zdyk8Dt/h6sfOW5myxh1f+zf3zZ3MX/mO9cQPp5pOx967ZA6/pqHvclNfnUFF+rq+Vd7alKr6KWPcIDhpn6v2K6NlUu6LrKo8b/pYpU/Gazfvtwhn7tEOUuXht5rUJdSf6sLjYf0VTYDgwJ81yaqKTUYej/tbHckSRb/HZicwGJqh1mAHB/IuNs9dc9yuvF3D5Xocm3elWFdq5oEy70dYFit79yaLiNjPj5UUcVmZUVhQEhW5V2Z6Cm4HVH/R8qlamRYwBileuh07CbEce3TXa2JmXWBf+ozt319psboobeZhVnwhMZzOeQJzhpTDbP71Tv8HuZxxUI/+ma3XW6DFDDs4+qmpERwHGBd2edxwUKlODRdUWZ/g0GOezrbzOZauFMai4QU6GVHV6aPNBiBndHSsV4IzpvUiiYyg6OyyrL4Dj5q/Lw3N5kAwftEVl9rNd7Jk5PDij2hTH6wIXnsyXkKePxbmHYgC8A6an5Fob/KH5GtC0l4eFso+VpxedtJHdHpNm+Bvy4C79yVOkrZsLrQ3OHCeB0Ra+kBIRldUGlDCEmq2RwXnfyh6Dz+alk6eftI2n6sastRrGwbwszBeDRS/Fa/KwRJkCzTsLr/JCs5hOPE/MPLYdZ1F1fv7D+VmysX6NpOC8aU9F4Qs6HvDyUy9PvFGDKZ/P5101TYHFl8pjj6wm/qyS75etZhhfg0UEL4OYmHk6m6dO192AzoIyPSV9QedDA4Ml23rRbqxMPMxf7FJnDc5FTElVS/PyqgePzmwVZ26NWhRDQ+oaT7ly7ell4s3DypS1s0g+tOr7XHrrkZj9+x/mJBttrLx98lFIaRZzHz4aC7r52/JQ4VjHahY2/YVXZn/QC2ztQb/sY3uRlyc5vQS8nLPGT/n27495i8HPA152z7Fh5aFpyn1GPJKHuPL8Iw94DuW3KjkURAWZXn4EQy89xiKEHN1mk/tkM4gYDBxwNoYvRfE6LFqsxWJtPrDGbsnLMap3Ka3MUoytW0cvieozOmdERmhcqzG+3HmZv2yZeiIeQTKGdRT4HHNxekm1tY+/n06rGmFleqLscSERzctTKM6G9P0Pc1RmVvrascIxaO1CQCiYPE15bD7c3xSeW7gXxYjgxcrUlcbIvO0r+Yplhx0kTt3qafDOmFyMjgGxXu73rddMHpV1wMubyAGcf/v5dLr5P72Ta9lBF+fzMJrMycwv+9vnU3ANIl1cH9tfW7af8u0/HG0vV47jNFXzFTtaha1xvze/s8KMtCYucXc1nzfd/MQydUXn/b72RBt5wO/3jRcMH9BdhC/yctKBIveRYPrNpDWqBsO8VMmP+WvRaOcA4zRMR1PvSoO92rS7pYEv+fZfEfTMzEdM+6X5tLlyxExhqLRkms5EuLovLfx66de5fL2/yX02H52FPVwahrPqmN/E0oVXnsCKhbi/yRxX83nRbUKWhzYceXOntfuXn51NszJ6MO73pQf5Pl4in3ec4JU8hF7ppV34+mm9r1LY0ee/i1O1wpd8+zfLztE0cqBxggiBi5Bu95v9l3r9r/U5hweLn+TbfxowrWDqdJauKd8+q/dH8sbPkc9ttuyO94f7/XK/nHX46MPFLEb5qQlNPvhJ50/59t9ft3LXu7uVaWaO2bDrDCnRSzZyWvFKxO1+vT8MwwunR3bX0CkfPjqb4K9O19tn5X50PvmYpEwHtiW9WtzuV/s76B1zvLLNkViNd8ySxIl/3orfqP90TyTGaf7/rx8jQzeHJXdmh/N6YDvbvmTBwCdxfEQ1NcL6wNMdSIXNq7b1EUzRy1/Axsyk5p22GMG1b+GxFgbHErZh92wuvco0AuOLXct9hvw2nw/LqIcDRRmJmmZzcgUa7JpM/WV/S9IUfbF56TL2orzqwebdRD8nIYNJ41D/hz37Fo11p2Y21wzPcn713qVGhqtevStYfGH4n69OEJtPvbbLYWvscDqc3Hgnu166+tAyLnxrX0Y5zoYjV++1sI7t5kMr02KT/+uwtkc+rZLOf/qn/s3nYCf13Dg8/sB2diJgjGqjQ+TLhxbzyue2Ob7X6/9lUwW7a+lbznHzOYy8LKW1C/uRPbQY3KW/0gO9LXunHLvPL97afba9bFtc9hmz7GAttjVYlCvQAiOwAk/gC5+hkLEs6tr3AZKxLJtOEwk2dLxTYWsIB/j/ToWtIWzo906FrSG8iaqqqqqqiIiIiAgzMzMzNz+AyK+01/zi8n8S+Y1MjoRaQ80WU/G8MBlO+53VPXANrWm4wzGUVZUjjBJZVdhpcfkjsmcWaO+UEldXi1e+zq+HOsCpknYshuh8pOLISJun7TN0EIGW2xTnlOImeecnoGW4raxe2G1T3HEvfYUYMhG+gAFOAwh5nK8mZhwJMmN7r224QVsNFvZ87Z0qatvknklyPDK3Hy45PgVKXji52Wen4d4PlFVVYGnNap+fSpFbK90rYnhUc6n91Q3AY9E0tJOFrcfZtm/491XbcG/jsViUPPX76qmeuiz+qY1Hk7/1VPM405zWVuoheLUimpWYdVzCmUdKHebMdzgrYrb8mL2eeLSnRWHdonfZa8RsOU9F37w+591l5FLYHiOqWeHtE/lWrBHcRKp3uhtr8yXm8LU/5ms+NM6ZKsqu90cFZ4o58+k4rdrtB97NADFbwmEG7lXqvirhOTOqU14xuUF2myIjURcPHrPOQ4lmM3PeMg7bUuk0nnZi67bXsU6H8lhqIo8TaOrEafCO1ARK9PjC0QOoq2BxmMdgYB9G/lIb9++fqNJ2s7BHGFyBNmZAR8J3KCo012ikaSP8BCrf6VI0X5xdnbhHIO+B5rbOyB54zXkzfObyJ4ecwxfqBJMLFc7m59rNcw7hoHnFZ0b00zee+gTqvjm61Pb4xn0kcDX4jvHM0rBXZypG3DCKnD/Waa/ZtHmtFPgO5eETx+k7RrVg3aSwm2YoNXnCs3XPQDhNn+Fia6IlOOuIG6VJH7TP6ava26ehKHQa2T4N0tcZ9dPCGo3ZdnNltsHQbeYt5vPnJezV/cAeNypdml1vCHI8M81nSRP5Qi2+mI8v/sxiZru9187nRtp3f/42NemcONa+4eVC3PCZzc88aZh851CqSsshe70uPxeN/dmYwlwb3trwMrN1Gq8jbnApcVDx/yDPeYs5/7r62tsQ6lLg+DiFXTEhzR9dHqv0iT4tgj825W+H3XiRUNUZT2kR9Ri0+lp+UM3iQtS8uOE23Ly4KYtvqH13jghUntJRAewuzNLDXp8RxdcaA3cMY6TO2IeSFRXezeWIjCqyhsUdMYuCgYTZSKpBype1zRfq8FshvfBPc6BAQWl7/QxIDp3VGo1J3vn42OEs3qznws+YLRXbymyB19a9XBx6n/owcyxlEYyFWCi+kG9F+EyD/4yn80+agaZ9P7ay2Dny99aK2o91FkfEOY8hBwyfi5uwx2y5SaHmG+oq/zl1FX/8irOf8Y3vAcX/6uLP6A6nvMO24edSGPjQc827Rw2atX+z2bKq0CmW9mOtYnr5/AfDa1ZfPaXnKtlWborup7QYx+Or2uWb+N3N//2+yDcXMqIJdf55xl7/vsj4WoPPlxLxtVrkJ4w/tTe3mLdATOOYwxcq52w5Wxz5MbPdVs5O8/lhfE7dPj0bIiPQ3QV0iqm4m3YX8hRfc6jQ3fWepevMqUDJd86Z4vwM40CWHnn+WphsGHfieF02D3tmZvpWD+kBpNCFcLnZhcmmrhpGzzbdA+sQ1ar18OJD87IOKOFoRNznaHPNHUfUNhvY1iU+uhvEvpKHaUn3qK3exVVyX4joipp3um7FmYJWmA+WbIDshRpbVRx5/nqstCgy87FGbfVB8yDGCqS+2qCsnRwnSAN6zgzxfdB2nBT/vZ4/6uxb6oH8b4VBRxiIB93wLa47hG3w2SL/2Z27yOXJFwZpSJaBYyvajA7vRRYNKqljXKpt/CFD/tSMr18DKKbwB0xggBePatl1nki0yvqW5zchlyZmJ0OTxJ3D+fsYJs/mxYN5+Le5oagtcl+YsVvy8kSjI2YGvGjvmpkRS9W2dtXqWnVuxUhURm1lKtou/hdEq19VBp9OjGvHEQSmrpuf2R24mXGheil8KeiANY8fW1VERUfBImb64j12caBZmRViZHbeVMjCrPDg9A90IXrtnsYCuZtRQ0PyrKDjBNOsPfKsg1pA02gHlVr0OXiFhtp6nJqXVzcbfM0KnzC3ggOENPE9VBdmHKN6LYaijb4wXxJn5A0FSDF5j+h1ooZx885Jt3ZKzO5n7Z5WfNEOtyyPqQEnn7WLv5Fis3PdgMshjF1FRydbNyeBbyKI1oN1TRVrVK7kgsb/zjX4NDPIRMctVeaxVB38Vh1x5KbeJbU138AM5KzmZu3uny0ErygxiJF7GVXUrPzFxrlx1uFdAaZFDN9cvIb74qD9tzBMo7L7WIEYK+sla1DVMHpF0F7b3+Y6S+zjvLeDMCpapmJo1weBWuxKF3rOocih1gun4BoJh1kWnV/Jmiq6uOhK3VfKxEHEkafjLgK3oujaPzY6SXg8phhL4TNR1xvJd1Wa0aYFfPUMLrNBDCh4AuGRTbtKMc6Z1Udj8evY/ZpCuMAUefdo69DZUngoqE1P9A3PJfOf7WixCEj+Y6t7fYeHbbxUAoFV3M89cCKfma3fc1+jKRe7MFWEbQqEfyzO2x/wrO2VYH7iYdQ9BkPyI8/3kXBpLaCpU7eC0Yv/am/tEDu7HZpqg0EvHo0nf/R/gRzUWy33/HXMJQeu1GylKmOkXzlCfGFruAcPPhaGqZOtu19zsJ1SO2Jz4Ztth5cBX6mRQwWmDwryG9FUMlZzNckMdK+IoMJv1rOWnBamS2w2KHiaPMPLC15hCZm4KTpoZyj4E2TqC/P6r7/EhnDMhKicZZ1ZwxuC7DPzDGs53q8gXaI9kFTK+2LTq7bhwsTbrMV8Rsfua5lMS0FwbTitUVnVa1yTb5IX51mmYnUcP9wPr8Ji1tiYJeJV9GZTrQhF7vvdU2OTU42ogJ9FDwhmycI2LIg++03C6scYhUyUuMV5tkw6kGUoL+mjNC38+wMdWNljn6tGPpRES7veqrSn5TRuv+dh6JVL/iDHU1db4c9WK3++OrH3PqziF916UMUKn8G67nN60GfWiHrXYhUG3yVWmyYak59NHj8t1smG4UDiWz2rPHNrKnN4Zo1LBbr2/eF9YZ0n0blx2nG4X+EKFxvS3W28JESD+FWk61VCD3z/URGHiJl++7TdBwkCj6tGOH3qDb0QqcOF9Kzpj0HUb/KyFW3Yhj2VMKJqGZleFBH7vqvf7WqLC3XMuHV8q8a4sTFuxUtkD/6JIBvKaVjv96ndgruKZ1k/BHzqf2K9fLk7HGXANyLDd1vxkK/i055pnzl+zw6zLnwXlVYVtfmacJgEpRP1hbGgrYPVN6v2lG+idQNGmwcKXu/8xEj/P6qe/sB2WmwNp6pp8jaISMkwdleFXYK55NHWLTTbutSUqjBfDGWo/Yg918qQ+8BRZSAHZbfuNZz2O0sov1Ue4CWlVg3rFhM3Kljj9ksGd/NUhk4nH+a5UN2+1i8+NM3vRNp7uQ6sqexSCukEVlVZriHNqFi5rLm9TMWa4qm3idJqppQACol2l4VSuvWLfta4JcXy3bROPNbXOgdOhG47LC0CwW/dMlSx4Jf17aEU3yA1x9p+Yc0jupXgcMuYNku64iYOkGToVDuJvlbEKlJqsmiHbvNrIVZEH+yFdF8DbleZ6iNiWwMqvtMp/mSpwx5KxRrT9p3MAPTHGtMbfvdFhyj9vhaKcn3At8Lc16Ai+vBcSp1ztXi7rCJZx/ql7TXcclq6Q76UeKWDy9boS0WHIjUuWhPG8LBmW5y2rhuTpM5vsLt+HOLh1Yf0DqXa9tsfC+kaKt2htA0ai/L2i7RKoNjEwztkmRU0GfgW1TxUvPFhg0V7DdfWJk5gfrccpYv+MA9M0dkGTLECeYwUixRzjRFdmjG7zdZIl3XKB9YliNKI31lfa7i2JG5C8Ss+rHe0D7Z696/V3DEAOWHnQ9yNahMUl5kENWS6pHKKp2D1BaSrrHdE1w2qNxIztpXgUIrF0bm15YML4b6V1k+GpNysTahKMVrrS85lTVo9OGJ96I47eAy5rYWpRf/mIzeoYU1DKaQCTUVwrhHeyNoDqHel+lLxr9WKzhSYw7vrR6+V5q0pfi2k3L1zqkubY6rrd9ZLvSuWNf0uqnkY+FpTvFzSW9Fp0b9l8JA7THV9eCi/PY/SCZIUYx3BU2alj7Cm3VV6eYpios4b6WuNOJdYXUK3zTqj5CVG2FqYM4Z7CuIU0qO05XR0d71FHM0YhZmJmTRfLlXEumN82BGtzdX0S19t1e+bUieK8zRmqpa4Qc5TSjifmaQsY2ETLjhI36gMR1+7qpjdXXHiceUekfBaucHShAOiFXmv3sNmGQyU5iVgnoocuonQXEPTFwslHtS8R+A47StI9wj0iSrtbi5rMysczFiImsQ+bdFClnFjjpXXwMy6O7qfjOr8Fb0a7ODItisjnn3EQO16+ypd1cwyaAW5Yzxz5QknfMO7643fXW/I9y3U2xH27Oapqr56Z/tEzglj6IbT6HEHjopiXqeRbe5mQQvxtcbDOVverN0ZgMdzqRYRjaXtMRd56Q4cZSmdPvZJdSrhJ1D9zNXPqAEqPIavPdfubt5oke2kmv0dztIszSv2VYuoyf1UuopbsYb+uX9h6WpwjpgtZ6fNNawNJ4q8O3CFoSbioAaOSZMx2GYaPYB+rEb6qjQiNRFQ76TvwNFVKD+BhH9VhcKGsXzmMI7BptU/CNWolM7YzROvpFAntsiWJp6eR2d3GarcYShVYSUqhmYOWj5E96NK2WvmYNTeY7Zs4RUEdv9h9QT4EseKt6LzLrqEOs3hxAY1MaNWpSa6zZx8F3YOVeCYMS88W+CYHDuWe4yoc6YK+djDuEOrBR5lvh0r+Q9uM88lrjx9x9AtgpQVNE8r+3O6Gvw59D+kBF/UMXyhliYUtPjmvXGY6Dk3x+kEOW+GtdMVC4EZTqoS/jmR0P0LS75DOc/w2vnri97M4SdbZ8qeU7gg8DVbERkU5geaMQO3mYrSYyAngeUQqrN0C0/vsFmcgWNXNeidsTAj7/4MncJR0caaBUpbLK1yBCBNRjEv6KvuVSdpPnEMJdsRRtqJ+U8tN1gXA4ePHc6ZT0eviI73UOJF0fEZ8YaneAQqQdGphNvwM4nIqPnXxV0xA0fnCT+oAhJuyw/q8jO0y8CjSteZExwBpIN6SvNp6A5G/abi6egeND/1GTguhuNjaUbbnSbGd4L8937Ezm34Eyi6n1maeOBxh3PI0jzJDf5mh/BsLD7F2GOKvlA/5gtvxI3/eV4sLfKW5Wy+oio+es/u6T8UU+nsofy57Icb/JlZHPFtCgd/x+bwt3ZT+xXTtTtTrGAb4QehC6X9G+8YT+ozcLxDsdCjsuOqwPFnrdLYaFc92Ui0m4fr39lYmlCaqTit7G6O/3kWDkgtXjNH4BiEm/+jegQnihOtfffn33WxsFjhfMd48HT+f6o6X65j7XR8WLSHMFkxbvOYsrRsF1bowDuSQ18Mkxk4qz2zoGPL5fu9h2Hqmt1asl3Q3Yu3szOc+spiCmX4AETBM3pLoTYSp3sVxahyhL8eC4mPN9k2x3o0xkiixIzM3CZFzf5oR4mecQ5+ax2wCah3/crmnHoqR0+KMaOPxRif1oEFRFOO/kTPPmtww+NfMXxEK6gn6iU32U6fFruIz8Q4WgljtnaCVTBgWx7diUdshC9ZEa5yKpRBBeW12r/iNc/+EgNqmhswNB8SBoihHXeDF7rrWDLcmt3V8GYYN7pXRy4DZjj4DJuUBL5iC3DQAaoo4vkftqVTYRGLS3mHZ7gdmdTTqbgNN/PTdTCOTgXolc88MhXAEUMdX0iy1JMuk5wLsgeu0QUYlz2S4skTWwJz6pOm/8ihrmgGfFgri+ZWUK2gAPHgbWa8jaocdSuM4FJYoKicYX/ZSENkg9Q1ZzJfwScfVnR2DegOGwCvmogaWJCLQepv9WNlU6QgsmOwICquU28Mlk3d9W5E81lU/5Ez0LcX6lwKMWDNluNKfBDUy/phJgBcMnfkh9iRxrdOzgs08JdPB85Lwo+GUSb4t3nC+0byqMZtO2fQJ4U2zGIr49t/28qmmGv2RanDD7a3FEcdtutkW8twwwlUSpb8QalodddbBfNHKDQ828BdE7OBgFdiKYohLawFYqpybQoxATZrheLhdI7+0Zlu9Q1myRcd15r9UIm8K2LGJxqTegntqNVMKnf1a8zQiyUR1rxoqjiFxeHxqFcYUTHfDu7rhbWng6qOxOsI+5A1p9mRyEPdVkTlE24vY54W7bWc6jMgZvNXdfC9/9q7408KDsbdL7Utz7QFSDetz2picArzrdpL8OaCHC9V26RroemtDZ5yNM/KGkWMyTmfnInEvwtSD23UcFcjhaE3VKzkoaEMKGBft4XbIO6forTY1lmGQwVmKicBCiArDzE+1oIxE08fWeviIOD5TznqH+OoHadvoOP20drMPe5Irg3XBQziW2XDuHYzjqQQ4wySssjXUs5H+t3FWYMHppUnBHMx/nYIT5d7OmjDbgD9F6na3m4l7KdkeSO3kTEPXafiWinogag7b52taiZhL1TSvBFmEZafFq2H8khQaZXuitCewT5FBgVtPK0j4xUHPfUz3Q28eac1Z139DAP23dgki94EC8vbDPTQC97HPPSWjUNG5tWKMsaxAEMKC0665Xvo1Ntd07wCLNf8Q56mrEPVpCxlIMVlQlWRxM3oAfpgIc+8KC3rEXUog5g06vt7zgXY8grH7hhwVSaeuvC06YYRAwpbyk/Unzj9hLEZNs2oxPQB9yc+GnL6zTgq7rI++KDJwX2SP8Sd6YzTuw5lV/kU6eQxRD12omfQAW6caTR4LikYkBB1CMOrvgRr/VY75+NSB40Cni6bADAtaK+vyxVWpf9NeKJxN2KYQ8Q2xPB3K1s7fuhvWbr2XpgW044VD6DRs0qXoqKf1NFsaGvKJc47leUV3pppP/5VTKFhaGuol4Esfjf5zyCyUHmHthChcYh4hYLQF+AFWsuq4t0wJyWgdwQVOZiV0efRHPoK5+E1vjz9wTJmVkITC9oEstAsyZSgE/dbicwKr89YUxKZI+owD205Tm5lnnmDRuP/JnzxX3gMtlrcX0UesZdxyQqYQuEW4R51vmQ5xOZteUd8SJruMlTUzhtVw/Nq7eUBcqN2/HVotgfngif60yKEtoUx3WYOZlVJuJOh8u59fzSDPFYtQgqDUAGyGhQOAvKroXMcOYY0qjnStJR/G3aP+Jt1sLVlGV8POwr/6OGsqetnyF3TmTqZjENfnXh51oxe9qVUw2M78EzAJ+IM8lZ1MBPQ9ZWSVc4J3mWSrLKrMHReA5qdGoz0ODRsaA+vwxXA2cAM4qlfzBJA6581m4hzxItQw5dxrrBL3Y6kCbUcFxo1S8jyV44q//+7ASNNudZ6xeaNOSIUffqMn4A9lIjFctYn2gpEPAb3f7p3iIBN8H14FUGQ9ct2hPsL+cEsTgUrR47uJVN4n4wt/wgfwwHuOnLd4yobkofy8JvxSQTA7rMpDIc608SlZFJfZYcmbT0tAHpPE8MrtQ42siTUNWxqvWZOmvu9f0JPoQmg+6l7sZWwyfi6PXkxJnwBraUG0MYG4zYHQz3igy/XsFkx5tNQxw43qvI9dU3f0DdhOUlHKjmi1VAr2Kiy0HZwD8VeEbhh0OiDdMYspolQsYdSwjCcjeowIXNZVUPmL2wwIkYhmXKhGozdCJ4lRKbsf4NBh/XnQoS92NJEWOVOFs2YhN8c5QZFeK0pRdAG40hqvLbmoSA8xQmzOOEc7wLcme9JOsjPCEgpCwUs9E2DohMHRhUeyGIN6TFvrbny8nDuilsDpzrH5mS76APoIEJmItS67sQJ+nfwddzmjPxcBEBBCw0kWDwd0EZCkNeOD7NNQhtBm7KHL9mRxj6U1yWU2puzlIDtpYxdH4ZPeXBJkTGAJfUr/oTCz/iypY6uXaR2V1doPxJYlrw2ghH0D5gbrhFcIxzYwi4a/4hqVdf2DdxBp6vGYDjavxMAAoy+1+3aiO6S3W/QAKNVXagDtvsNtx7Ks+HKgo6U21B+QSZgIogV5Bt+BnXisdVfy9VyXV+2P5fMuvdpAjM1o/K9Z+XnE4EOCrue+kcdYHqAQ0/Y/OmNlQ6OI33jH/uD1RalPaHpJAm2av0/xtpqdXVKNDrc9F2izo23Wu7firgbURFDNX9eGGeYBhiypyXZft2j3hTvzE6PMWKsod//rEILDkzBXfi7xh0eFkfb3/1zzPK/PI5Nk3FbZyTl4mq5BfBoVoqiPHO4Q4QKZAlrQ3MdNfi3oxIjvsM3kAFv3fdufurqYR3PSwX/mpGy/GFI/B2MNPiNdOppWVbs/gjF3YH+QA9jMhlAbhvasAHstB0IJew09iAkmXHl1/TEj+jvHOpOGrPRQXbPADM+Ig2/OEcUcpgPTItMtW4DdqgfYVI/+4hAFWYjUGpOP/UwNuB7+BbKOcALbjobdgzeBQfjgNSp2GOpxzGLj70Vvq5cw2AoYENwKLUtJUX8sGRox4dVa/TN4xKwaKcl9XawQR/uNus700Hf17pyNnezrUgaY9e4MADhEDBpsJT6y1gDJs1q6wlwGhuUzGR7C8kgpjPyHWwsvrf3yn1zJEIRa5eSxoLAZOCR9xbuztxFRJW9ZmMYfCFJ0evm9F2fVnuje92Rc4Pl6A8bluN8MZyyJGZ0+sNSb//DvAFxC2BqlEsFwccWeAl6CyBcQV1bx4mQMBP1Jxqk1EUADNLeieS2dUFbQ/c/kvwItbZ7tx0st16viqd53WsRmPTKv2AD8CUnhtPWg5aUegNpsYgasaw2+EVooeNKmrW3MFtj76bYHJm5K9gpAXZXsE5U8DM8XmVOSJ1F1WnLy6nQup+jx52bAb+rCq6y9WXl2B2oZDhfDkW7H3oYfT/4xx5VncBuxMXP2lNfhUVQjSSzSRbuZFE4vFawlzveXxaYKVs8LpvAb8IRYF3ZHiRnm0ADeNPWocwxSzNseG7NrSEVZoHdKWqaGEBz1N8Pt7kFbqh3LYmAbm9i1IChIpLpM5AS6mr6OAPHMwwznVy61YpBYX8xZDN/a+lt7n+x5j4bNOVteZ8lj3hpAHSx1VR8vZHec4AHO9XFCdjZ9eRkSV65ljMmZVzaej2qFn/qt1lvWzNZEfHxK3qOJrHL6crr0CRzMox5f2e8ALBB4UGFZKA3tN6F6IXd32GTJXGQ7DTi9j/dNcLF9jCbDcWGKxoKTYblIwbLDReL00LRcDPMcQuXLMh5YzgtfjkFK1DP1iDzzYYVZz5M/kWYRlRpig1htVRjVCknm+h1M5LiEDXOyHREhvzCGpFZjHS0RsK27o2avgdilrJkalWqPW3D9gmwV37HKmfM3F8YZj2ar+vHFvf3B8CRoH4kDHIK9mrAg+owiEwNjjd9V+FsQKYR8czJrUkf7Qoi2YaW6EVDZp5zYlqiYtuXOTHk4fAcZ7qBbdLDiJq0WNV1l2+Hntk1mMWvxrYmc8kIx8G3rW36J6Ra4lLrTOCgiOihmow+YnzUT19jbV2B3RWqSHyxkhmgsBqMYWvOcUom1jDQ436+fcbu3xf2bbeqU/ca+C4DOKE+e3qvmeMqW3AxejfzBRFVcwVYPq4L0APSWWoJu+5UYX4qg5U6YTioqQGPG9XrnuZ/BkxuYpe6Li87+18EskyQW/uA+uk2rpHpr6hut2TlVbKgWkFpx+AZffweiw2+VittkEyf/ifinS/0ItRL2Jq3tQOcxPaWO2xrG68GdFoUpZgFXaP2wYVtRc6xYCfI1CaBqyWpg4bx8OHBQwsV4XWMibZZ0LYjWEy2IxQ1mZrf1/UNbYCJplWu3nZ4WpodIGVA05d+RWSS+ET9tH3RfGGmNI1cIY7evZZq7o+a0bjjygpmR3mVfalkT/SZGT27Q8QGalwGlDOS9VHCyFAIL0a1Q7JiW3saz9gqY8lqKynFrPCzxkU4SIfLc9VfCI5edgRhDXs0edO992nhTKHriREP1NJC6SROMgQ0xO5kNNZOhMOIT99AUElbxqeZF8A3xrfDJsWtDnUenAHdYWSwAbYjFqQZ+D5gi3hNK8CSxU9i6f6ClL9IGlj1OPMQAsr84YG6ijsJpCaGWj75c3yOZKBB9mNpQNPUKkK0D6wgLH8MGoyRxTX6Y05Q4AnYNXMZwXM4eij/9WpsM/9CoRnFQXGR6MEaY+FXvXEO3RO0JaStk6OXuHVATHJE+1W+TU3bSZ2ksMtqjO0zfSJCdBv7y2d8DMx6TfVme3q0ZpTKMMu4YL/t7ciTNtdDkwPogh3Cnjx7qk08SHwf+dksZ7M2vCOlfsF0hQ6J4ehPCaHTNrM/zBSOqD83dBEBCW/F/LEmeh0nOHd7oVl3/Qo/9GUDkkbj7yz+9cvvu+dDAtx8NzCDTP4iKdZvk9MWiizvtILLepysflSvTLFBZ37RLwiriqyRxYv/zrgFd/9XVHh/OmzBvDX4mitMR/lUavs2Vx6cR94lzAkplm3IRNy4TFfu47tuYs9EQPIPVta4P64tV+sZ7n3ued3cgEx2YK+QL5+xms6osk8qQbTyuKVGdaX9FQqk6qfDnT5ykxk0VK7KZ62b6DNDUfQlqGHxSMKv1P0XN5BqMeKG1P4Wp5QfZDUCEldppoX0U6ss2jIko2XpURKCIhfaOqLPfShdtS37ZrT+jFRSH2xYVV1rmT/MBtRQhxiO4MQ3iAGlaZi+9PWBEIXOVnu9jN1f921lWLZky9bqbM3J2MAAI9jmuAx3gyoEUa6P2ivs0EeNv/OR+AX6q5SW6l5HaoFuS6jr6yg9limu+P0KYKzfMXWcQSfTXzpOzKEKpwI3YGXZpSSy2LTlMgfmFA3CF6R5c9xWEtRuCg2ZPUQ2Nb6dRFTNd4TfGHrnEWSKHPuRyiJSDAZ+KX0VxmSHjGPbQTLVpqixia2uyhQ394gBMt7C3ZAmxn/DJS+l1fBsAo2Eir/C0jG9csd4+/tp12pPc/BVJGaK9mfvr7M/CeztrmCO5qY06Edi4xAGtiEhnWAbzLy2VEyazE1J5nPmgU4RpW4Sa0TnOT6w5lgt3/tMpROigHHmexBGAMY0mdcDbDxWIz41NgdD6oxgHsJRgr5RnT6wZAkTOcStU4NMOQNemSO7gxGahdEsC+NRVGxMUhQmmM0llWRbbmFGHzEqLM4Iw0H7577Kyo+Zf+2cUFIOw93gEY171vQaM0HLwpjpdRR6Jz7V0ckE7XzYJ0TmY9znLdzkva0vNrAGGT5SUZ5uaHDkcGvI0ySpwkasEgZPMseYcu85w8HPdSNi+4T6A83iAwDbxgeFcB1ZM2iGXzFcEOUlYVrEckaOyodfvaYSQ7GuB4ISE0nYJc15X/1ciDTPbPCgYJK55VkEor4LvzL9S2WDy4xj+6FOqVyTAC2ZNowheeeSI5hA/02l8UYkv4nk9iaVn+kCVEUstgk5Hyq+gJm6R9vG3rhuM904he/hFmNQaUIATB1y3vw+OmxP4X5Yi6A5I5jJufHCjF9+AGNwnEllZjUco6XhsO5T5+R3yxz5yLVOnAn0zuS+6zdj0nTJbEZCbXJdtpfYZfCeCOqJHoE2vPPFS6eRLjIJlG69X93nfR0mxSFXzp1Zc0lt/VafDaImhUMtbnqWVb9M4nGNQLN68BHP7AR8Il9dkcxzmBv8PCZlw9guY0lurbBsmNYlwJZsA/B15/HfkbjbwPddaVecls/elmDHNW2r4crAx43feNkfRwsaNq/yyJ0d/p5hZ6AZajz7DBfUok0ZU62gCzz7x8eVfJTKA8IWn45vINLSM1q+HF9CV9qF3zP6Ml21kPPL3CXzkuYUlnSqT+Ij4tI/od5KwIs+tDajDs64owN7tOAd6eucGz+KfO26iNcBFpbWA5732bBNWO4kHNpr9D955L61bvHCF/mwSrz6eQaDjfDEANqGMkFc+NGxpKZzCD2sj/JrHd+zlPQ8Iz7Q+2JVIiVCuCKoK/hlAEHzvk/Piq3mRL1rT/fEh9hoT5GJmeYswg1otiKydizJ/fS2SeKHVu6Z3JEHjiW8NaTQgP5xdBli8nC57XiN9hrquBu99hn9zqwo92+PM2JXtpeVZS0PdqR5mDyDreMMtEws+CpwaRyyzoYtfcvt9PJIW0fJVNNi/FFyRsea7peLvJrL+5b4GOXJ8tAr+ATk9f8KmiIsRhqRy0vFzwRV3Z5dZ3QqIU8JQ/uQpkJbjMUMFj2F9sCFeaBjI4+fL/oN3+LQgjI4zuAfQ+3IPIPFQBccf0clJpsfpnBxD84atwtupkGqKvrH7cGNl/QcWcSi6wcVDML6ljOgYbo+2BOAWNNjlUBPiyitUAwbnhFvLbnqw42kR3Yp2kv2dMeDdcGOX5kT4S6M44KHEB/SpCfl7xgsUvs+JNY9G3O2X/6FEt9FyAn57lrbiu+tl83sCymSvq9eZbe9mchL7MTf/Ta78e80zSf0hYY5eUU7+ff14jv7Xy8qjzfzzzvaJnrIdvFb5BLWKcWGy5/w7+vV2cvIfwHqdTB+RuJK5oj9mbt0Hy94AmjMjjwYNZlNS6uiyxNnwNyt3gdreLb64p/3+08nXkb92LTkkRgFOwk1oGEVllcOj5lv1hfAZywDows0944U8vUFw+A/nuVq/UCygsrmWIBnHyU01d0XJPwriEOvx/ISK6Pk4y2w0gmojZs7lU8TtakBAdne4v/aNxmMpK4VcGMp7si0yqsiolXRuOi1Z1P7SqD3Zmp0CWcyK4Ubmp2SXiXuI5nGLCieFHKHNRIlcY3Pys2dwMTYCaqlyWSITwr2oGXvyU3h1Pf8eQ3w1bnD7ilocVjYDkcXR3Oo1BXgMLTUjNw2xMVwjtp99NhSVc5aIWrDQT5DHPKtCtheBP4zHcw4dz2eRdTMamhlHhtfgqJJHI7NGDUw1XL8vsSeSHyKqDtqoAmrQqsYwvwi7HW3ojWyhIa5oz5xJTaq14NAzFLjVLR12rRNUQ6xohDnrWFb5bG9yf8aCD8d5phoackcNJp+Dw3Due3RM+5Rid7EuIgsnwgpX0rUWh/nqPtByMhMZZ69NpgvRTKZ62ViZ+Q7Dp5r4K0d7EfJuiy06KuIYauRh5Ecrhdt2QpTS1k1AscEHvapNbU3HL1F2TFyR33Wxb5MvH5iZsrn3SDcsxlnnshO8PLwmdGN+paWnQuORtZGX37uhFT64SeuPsx8UOokY6ON85WdQ1dki5zErsJGazcBOddWJEKqNPiJpsMD1GrVLrVY+AOdPWQneTyyP1hRX/lMM4ZogGGOhYuAdr7F/DOiAoc++cn5vlf0zkMUJ40Z1rlgv9BelPqVOpxKeOpzKdF8maK+1Vv23MO9k/8+qpLoxrIGH2EDQlnGmH8CD31G8QqlyQIcpmR5bwmSVw9/Ns6IHgulCRehvZ/+VrM60Cu/r3AontFfrljew74skYe2uyn7JKQtFQBQRJ9ryGic/zQOsbS4scUBctA8cPToQ3x6ZBQu6DPu5m1bnCtP8TllLYA0UTQNVqza5nfew3Mopy1GPUwG5jsl0OVXniPmAcmLqO5HG8Hv3nSLecE9oOjPDXcsTxoCBxYyzBdj4wmnyEV4kvFDunipS8SSkvdaMnTBN9brHUR8xdmmEAp/Pdqk9uextp1t+JrtXwpN/MG2w/qhRMpSNxQ1uhg/kKO30eQ/FyHUDkWHT8V6gGRU4DhDMxZu7xXij9Ui6jlpWmQCqJg3FkOTq3WKneCRYZxBXMNAVLQgHXSCGSqNdjebY94oyIpVjMYehAiFx/tqzBXFHZaL5PeeD74rW5OysFoUXY8sebUZleFTUa/+zBKVTFDopTReXNuZq47QjkWnxjirCommO4L/GrFtVV21EpMyw8wyThL5Y59d88xtlx1g1ttSICDwnof6lt/6zliPzgVUL8jWBjC0o2D6Kg+jNuThkAlaDJsq/AG2aKA//A76avw2KNqtv223P+Wq3StRDDNKFFgtsFukYt1GFDWooFVXitaNhb3RCyJi4cMeNjROiPEDb4k+G3+hD8tsg+5hhmSc/8t2JTSwYoCzAI75doq8QTHe+E/Tw0RQSUDlU+6uBeNN3h6jJGX/mH8oj0i3caCNsjvTnoh73BtyZpsflHLq6AfwJNCDX4S98h4+pCOhGKDhV3rtkKHMa3EG4J9y8zFWI4UsfNzC/Rl5midNn7gwoN9j23HGCQQ+OAZpTTPMdiVow740gIyuEtd0qVxMyNXhHcnuXRKdw5wDUSL358ktjMXmAkvIB73BLa1vfF9BAUZInPYJiwxqFWQQBVk7gQH4ojfUQ/KEjn+A/WR6EEe4CtbpoLe1mzHkajgTIoE0SLDHVauKhrq12zrAXBGbPPWKCt4DGedq3JyGRbmPFW32bE7T20+73BatV/qQhhBWfWBFHfhYWXjALts38FemnoT+9bn1jDBMcUMmYgSc0e7GQjv2MUBwLU8ionCpgV+Qrhg7iUIfUY6JFxR0Y+ZTCPM+rVuq0GNLyJXX6nrUTt8HzFBRY1E/FIm2EeVA9NcXrj7S6YYIChVQCWr/m2fYUjC4j0XLkzZ8GCSLfmkW3PB/xq+nlXsKVBOj7vTvqKCOMq7Ztqr3cQ+N8gBnPaAps+oGwWOkbuxnRYj/x/WjiDclVrs22xMK4qArE1Ztk1456kiJriw6abkNeRHogaPRBgbgF9Z8i/tbzWELN4CvbqtrqV9TtGSnmPS2F9kqOIBaazHYaJ9bi3AoDBvlZasMluxt0BDXfhp02Jn411aVt6S4TUB8ZgFDkI6TP6gwPY85w+oUQSsjIeXVminrwIdK2ZAawb8Se6XOJbOaliQxHSrnAeONDLuCnFejIbp4YDtBcQCwMsYiRZfHefuEJqJcwKTTJ8sx5hjHmJI1sPFHOr6W9AhZ2NAod38mnLQk1gOz2LCAohoQbgMbUK9RMEA3LkiF7Sr9tLZp6lkciIGhE2V546w3Mam53VtVkGbB9w0Yk2XiRnCmbpxmHr2k4eSC0RuNbjNsUfDIfc8DZvRvgUDe1IlKdZTzcT4ZGEb53dp8VtsoZlyXzLHOdAbsp1LPTVaHvLA0GYDFMbAW/WUBfUAdHwqLFAV+3uHvYWrCfhUOR2i89qvCBoOb48usAGdcF2M4aKn79k/43WzBZ+xR1L0uZfia70XP9soQReeuhZiUnXFDG1T8/OXNmssTSnYO+3kVLAgeiY719uDwL9FQycgLPessNihMZbAKG7qwPZyG11G1+ZA3jAX2yddpYfmaKBlmfcK/V0mwIRUDC0nJSOPUl2KB8h13F4dlVZiRhdGY5farwN+f9hEb1cRi41ZcGDn6Xe9MMSTOY81ULJyXIHSWFIQHstVYLiJEiUjktlHiGjntN5/btB8Fu+vp28zl2fZXN+dJDyN6EXhS+0yzqpl/LSJNEUVxmu7BsNdjAY0jVsAhkNuuY0E1G48ej25mSt+00yPbQ4SRCVkIwb6ISvYtmJRPz9Zt5dk76blf+lJwAPH5KDF+vHAmACLoCdG2Adii6dOHnNJnTmZtoOGO8Q1jy1veMw6gbLFToQmfJa7nT7Al89mRbRkZZQxJTKgK5Kc9INzmTJFp0tpAPzNmyL/F08bX3nhCumM/cR/2RPn9emZ3VljokttZD1zVWXlUIqEU7SLk5I0lFRU0AcENXBYazNaVzsVHA/sD3o9hm42wbHIRb/BBQTKzAi8s3+bMtpOOZgLdQzCYPfX3UUxKd1WYVkGH7lh/RBBgMZZwXzU9+GYxdBqlGs0LP+DZ5g2BWNh6FAcR944B+K/JTWI3t9YyVyRhlP4CCoUk/mmF7+r2pilVBjxXBHFaBfBtr9hbVn2zDuI0kEOG3kBx8CGdPOjX1ph1POOZJUO1JEGG0jzUy2tK4X0CgVNYhmkqqQysRNtKuPdCJqK3WW57kaV17vXgiyPrl4KEEWgiGF1euI4QkSFHFf0TDroQiLNKJiLbdhH0YBhriRNCHPxSqJmNNoketaioohqMglh6wLtEGWSM1EZbQg72h0UJAIPVFCAJOThpQGGdKfFovcwEeiBuZHN2Ob4uVM7+gwZLz1D9E7ta4RmMZ24OBBAg7Eh6dLXGofZ4U2TFOCQMKjwhVckjrydRS+YaqCw1kYt6UexuzbNEDyYLTZnrY1PzsHZJT4U+awO2xlqTSYu6n/U29O2wPXgGOEKDMSq+zTUtyc8+6iLp0ivav4FKx+xxVy4FxhIF/pucVDqpsVe2jFOfdZhTzLz2QjtzvsTCvDPU7bzDH2eXVKUV9TZ+qFtaSSxnYgYdXKwVreIgvWhT9eGDB2OvnWyPLfIIIfNnfIxU8nW7MbcH05nhlsYtaW9EZRsxWcKdEqInq1DiZPKCz7iGmAU9/ccnnQud2pNgIGFYOTAWjhIrd63aPDgfj8/sdlD4l+UTlcxTI9jbaMqqN0gQxSHs60IAcW3cH4p3V1aSciTKB29L1tz2eUQhRiTgTvmqc+sGtBNh4ky0mQJGsdycBREP+fAaSs1EREDVo5gvgi5+aCN7NECw30owbCc1mSpjiahyNVwJd1jiGgzSwfTpzf2c5XJvG/g1n0fH88KHNnf+u7ZiRMlXueSIsloJBUtW9ezvsx9grfsX/FNxnbxU1Lvg0hLxixypHKGFAaPu0xCD8oDTeFSyfRT6s8109GMUZL8m2xXp8X2dpPCWWdX84iga4BrTlOfqox4shqEgh/Ht4qRst52cA1xOIUuOxgfUivp6v5f8IVyaryEdpVk72ERAwdT4aoY1usBgmP+0m06Q216H/nubtNYxHaOIYjcach3A8Ez/zc0KcShhel0HCYjFsA0FjYqyJ5ZUH1aZw3+zWC0hLpM6GDfcAdn9fq2orPmZbW6XXrf+Krc9RtvII5jeD3dFoT1KwZJwxfUMvc5KLfn8rROW23Jw89sJ2a5dpB3qWDUBWF2iX8OCuKprHosJ2mflBR+Wqs86VvgI/XMnsqb97+VlKdPVysczPj8Jhzf+WCvGBHijAqYlavbF60soMWlHbvKT+ScvhprgeTln51xX0sF+Eadc/l2s2a5BgkVbHYyz0E85p0LstqH+gEGiR84nBRRFIn8hLSZrGwqjZ3E29cuGi+5Z5bp7EM8MWFa9ssS/vy4VrDfECSv7DSU84DaP0sXI3Ap4lWznQ65nQoTKRWU30gd7Nn8ZowUvGIx4aqyXGwmA/PB4qN8msJUODezUHEl0VP9uo+cZ8vPFodSIB4C7lQYjEFj8yu49C2KIV3qxMFYTevG8KqAr0TPlkbzHHnTpDpvpzziAiNFh8xiT7C/TiyH0EguUw4vxAgpnE27WIypV+uFN2zW7xniF/n75trs9IJ5amB1zXXZ1LFkJ6GbS/dFokzl4cc2mamVwhL4XU0Av5gDWAl+aEWhAP7t2VIwU+EpvfOPDcLASX7H7lZpXA2XQfbSlD4qU18NffNPoAKMNSccBfO9YVVgmlW4RydBqfHAV7+hrZ84WJGho6bNT0YMhxxLdOx/dwGj0oyak9aAkNJ8lRJzUuA8sR+fPyiyTgUHio5+Pp+YaKlHrhR41jY5NESPS3x+zTMe0S2HnLOKCOQPpdxKyviBvdHrCDRqO+l96HhhNBLXWv4yEMuEUYo8kXnYJM8oIgVM4XJ+xXOev4YbWeqsvgq0lmw4/PiYr9sYLt+W5EAuYSFnJEan8CwJwbtASBfLBBpJZiRPor/aCJBZsM+MhvS7ZepyHvU8m5WSmaZnxuLts8ojl6KkS8oSAHkq5GWlCB/NgJ5W3rO2Cj1MK7ahxsCrbTT3a0V/QQH+sErxV4XUWDHx0kkFy25bPmBMBQ6BU3HoHhhYcJB9JhP6NXUWKxnE0raXHB6U9KHpWdQCQI72qevp5fMzcm+AvC85rsynVQhruDA9fp9COe7N56cg1UKGSas89vrN+WlGLYTwi5W+0xYdKEGtGCeNJwXKDU0XqU5uQYnWsMwTENLGtbQMvoGjIFIEMzCRal4rnBAg7D/CSn8MsCvS+FDJJAzoiioJEhZJgAp9n2+1Yznr7H+6eT4YkJ9Mpj60ImcW4i4iHDLn9RydB8dx3QYm3rsX6n4VRrZDsYK6DCGwkwd5n3/INFEpk16fYpP6JtMQpqEMzcOfQGAHXBTEGzuLJ03GYQL9bmV2/7ExDlRf+Uvf1sM2frRtCWmal12pMgtonvSCtR4n1CLUZRdTHDHP1Otwqd+rcdlavnKjUB/OYXQHUJzpNyFoKpQK+2OgrEKpGyIgIBgn2y9QHnTJihZOpEvOKIoHAMGAXHmj21Lym39Mbiow4IF+77xNuewziNVBxr6KD5e+9HzZSBIlUa/AmsDFJFXeyrQakR3FwowTGcADJHcEfhGkXYNGSYo4dh4bxwLM+28xjiqkdn0/3R4UEkvcBrBfn/SzBc1XhKM2VPlJgKSorjDac96V2UnQYXl1/yZPT4DVelgO+soMjexXwYO58VLl5xInQUZI8jc3H2CPnCNb9X05nOxIy4MlecasTqGK6s2az4RjpF2cQP2G28R+7wDPsZDZC/kWtjdoHC7SpdPmqQrUAhMwKVuxCmYTiD9q/O7GHtZvPSN0CAUQN/rymXZNniYLlJDE70bsk6Xxsh4kDOdxe7A2wo7P9F5YvqqRDI6brf79yPCSp4I0jVoO4YnLYtX5nzspR5WB4AKOYtR1ujXbOQpPyYDvfRE3FN5zw0i7reehdi7yV0YDRKRllGCGRk5Yz+Uv1fYl2ZwrnGsqsjgAVo0xEUba8ohjaNMJNwTwZA/wBDWFSCpg1eUH8MYL2zdioxRTqgGQrDZxQyNzyBJPXZF0+oxITJAbj7oNC5JwgDMUJaM5GqlGCWc//KCIrI+aclEe4IA0uzv7cuj6GCdaJONpi13O544vbtIHBF+A+JeDFUQNy61Gki3rtyQ4aUywn6ru314/dkGiP8Iwjo0J/2Txs49ZkwEl4mx+iYUUO55I6pJzU4P+7RRs+DXZkyKUYZqVWrPF4I94m4Wx1tXeE74o9GuX977yvJ/jkdak8+AmoHVjI15V+WwBdARFV2IPirJgVMdsg1Pez2VNHqa7EHWdTkl3XTcyjG9BiueWFvQfXI8aWSkuuRmqi/HUuzqyvLJfNfs0txMqldYYflWB1BS31WkuPJGGwXUCpjiQSktkuBMWwHjSkQxeehqw1Kgz0Trzm7QbtgxiEPDVmWCNCAeCfROTphd1ZNOhzLy6XfJyG6Xgd5MCAZw4xie0Sj5AnY1/akDgNS9YFl3Y06vd6FAsg2gVQJtzG7LVq1OH2frbXNHWH/NY89NNZ4QUSJqL2yEcGADbT38X0bGdukqYlSoliKOcsSTuqhcaemUeYLLoI8+MZor2RxXTRThF1LrHfqf/5LcLAjdl4EERgUysYS2geE+yFdasU91UgUDsc2cSQ1ZoT9+uLOwdgAmifwQqF028INc2IQEDfTmUw3eZxvz7Ud1z3xc1PQfeCvfKsB9jOhRj7rFyb9XcDWLcYj0bByosychMezMLVkFiYcdBBQtvI6K0KRuOZQH2kBsYHJaXTkup8F0eIhO1/GcIwWKpr2mouB7g5TUDJNvORXPXa/mU8bh27TAZYBe2sKx4NSv5OjnHIWD2RuysCzBlUfeNXhDd2jxnHoUlheJ3jBApzURy0fwm2FwwsSU0caQGl0Kv8hopRQE211NnvtLRsmCNrhhpEDoNiZEzD2QdJWKbRRWnaFedXHAELSN0t0bfsCsMf0ktfBoXBoNA+nZN9+pSlmuzspFevmsqqcMllzzvkyXrzoA+Ryo1ePXpdGOoJvhyru+EBRsmOp7MXZ0vNUMUqHLUoKglg1p73sWeZmPc+KAw0pE2zIsFFE5H4192KwDvDxdxEYoDBDNZjbg2bmADTeUKK57IPD4fTYF4c6EnXx/teYMORBDtIhPJneiZny7Nv/zG+YmekIKCoxr6kauE2bZtBLufetNG0BtBY7f+/ImUypMBvdWu/Q7vTMRzw5aQGZWuc1V0HEsItFYMIBnoKGZ0xcarba/TYZq50kCaflFysYjA4EDKHqGdpYWdKYmm+a7TADmW35yfnOYpZYrkpVEtiqF0EujI00aeplNs2k+qyFZNeE3CDPL9P6b4PQ/kataHkVpLSEVGK7EX6rAa7IVNrvZtFvOA6okKvBgMtFDAGZOx88MeBcJ8AR3AgUUeIznAN6tjCUipGDZONm1FjWJp4A3QIzSaIOmZ7DvF/ysYYbM/fFDOV0jntAjRdapxJxL0eThpEhKOjCDDq2ks+3GrwxqIFKLe1WdOzII8XIOPGnwy6LKXVfpSDOTEfaRsGujhpS4hBIsMOqHbl16PJxc4EkaVu9wpEYlF/84NSv5Zum4drMfp9yXbzzAOJqqS4YkI4cBrFrC7bMPiCfgI3nNZAqkk3QOZqR+yyqx+nDQKBBBZ7QKrfGMCL+XpqFaBJU0wpkBdAhbR4hJsmT5aynlvkouoxm/NjD5oe6BzVIO9uktM+/5dEC5P7vZvarmuO/lKXz4sBabVPIATuKTrwbJP8XUkdM6uEctHKXICUJGjaZIWRbZp8czquQYfY6ynBUCfIU+gG6wqSIBmYIm9pZpXdaL121V7q0VjDjmQnXvMe7ysoEZnZL15B0SpxS1jjd83uNIOKZwu5MPzg2NhOx3xMOPYwEn2CUzbSrwAs5OAtrz3GAaUkJOU74XwjaYUmGJdZBS1NJVkGYrToINLKDjxcuIlyfVsKQSG/G4DyiO2SlQvJ0d0Ot1uOG5IFSAkq+PRVMgVMDvOIJMdqjeCFKUGRWBW9wigYvcbU7CQL/7meF2KZAaWl+4y9uhowAX7elogAvItAAxo2+SFxGRsHGEW9BnhlTuWigYxRcnVUBRQHV41LV+Fr5CJYV7sHfeywswx4XMtUx6EkBhR+q8AXXUA8uPJ73Pb49i9KG9fOljvXeyFj9ixgbo6CcbAJ7WHWqKHy/h+YjBwp6VcN7M89FGzQ04qbrQtgrOFybg3gQRTYG5xn73ArkfQWjCJROwy3J38Dx/D7jOa6BBNsitEw1wGq780EEioOeD+ZGp2J66ADiVGMayiHYucMk8nTK2zzT9CnEraAk95kQjy4k0GRElLL5YAKLQErJ5rp1eay9O4Fb6yJGm9U4FaMwPGxtKD6odIIHKoWnhKo1U8KIpFC+MVn59ZXmc7ZTBZfsg6FQ8W10YfTr4u0nYrpHZbZ1jXiLmooF0cOm0+mPnJBXQtepc7n0BqOipNCqI6yyloTeRShNKH04FIo0gcMk0H/xThyN4pPAWjDDkEp3lNNPRNVfpMI44CWRlRgViP64eK0JSRp0WUvCWYumlW/c58Vcz/yMwVcW5oYb9+26TEhwvbxiNg48hl1VI1UXTU//Eta+BMKnGUivctfL5wINDD0giQL1ipt6U7C9cd4+lgqY2lMUZ02Uv6Prs+ZEZer7ZfWBXVghlfOOrClwsoOFKzWEfz6RZu1eCs+K8fLvkts5+BX0gyrFYve0C3qHrn5U/Oh6D/CihmWIrY7HUZRhJaxde+tldu6adYJ+LeXupQw0XExC36RETdNFxcq9glMu4cNQSX9cqR/GQYp+IxUkIcNGWVU7ZtGa6P3XAyodRt0XeS3Tp01AnCh0ZbUh4VrSZeV9RWfSoWyxnY3hzcZ30G/InDq4wxRrEejreBxnhIQbkxenxkaxl+k7eLUQkUR6vKJ2iDFNGX3WmVA1yaOH+mvhBd+sE6vacQzFobwY5BqEAFmejwW5ne7HtVNolOUgJc8CsUxmc/LBi8N5mu9VsIA5HyErnS6zeCz7VLI9+n/hbT6hTokMXTVyXJRKSG2hd2labXTbtmK4fNH3IZBPreSA4FMeVouVN3zG5x9CiGpLw/3pceo4qGqp+rVp+z+7yQ98oEf+nyH4F3+J9IheDBa94Wi63zJbLBCIZm7P0asHGpIJt3PzE3m0S4YIWyXBCVXGikj8MudDPB/6Nm2v4IxJ5gU0ii0guy5SUHqGUYzTP0jIJU5E82RHUXtX4lDdrihBLdP1YaG1AGUC12rQKuIaGvCpMjZC9bWSCYnjDlvpWbkdXMTNeBHLKiuoozMGIvkczmP0aRJSJ8PYnLCVNhKHXBNckH79e8Z8Kc2wUej4sQZoH8qDRGkg86maW/ZQWGNnLcXmq3FlXM6ssR/3P6E/bHMvm6HLrv1yRixit25JsH3/IOr2UV4BWJhxXW5BJ6Xdr07n9kF3ZNAk6/Xpc5MSFmYJ2R7bdL8Kk7q1OU9Elg/tCxJ8giT27wSTySF0GOxg4PbYJdi/Nyia9Nn89CGDulfJemm1aiEr/eleGSN+5MRrVJ4K6lgyTTIW3i9cQ0dAi6FHt0YMbH3wDSAtGLSAccezzxHitt1QdhW36CQgPcA8vIIBh3/JNjf/Obmc2yzpk8edSlS4lVdwgW5vzbYEyFoF4GCBBby1keVNueHAH+evi+H7oOVfS3XuPQSNTXOONAbzJeSb5stwdQHl1ZjrGoE49I8+A9j3t+ahhQj74FCSWpZrj7wRSFJJnnwi1T9HL5qrCFW/JZq6P62XkMWTb+u4lGpKfmmwiJWx178GOG7KbrZGqyWwmuyKWPkNswkZ1q8uptUlviIi+AXh2bOOTOLsrtNkfqbQJeh24reebkINLkjut5r4d9GR/r8CBa9SU0UQhsnZp5cP+RqWCixRm7i4YRFbtZ4EAkhtNa6jHb6gPYQv7MKqkPLRmX3dFsK8XsRLVZ6IEVrCbmNDc8o5mqsogjAQfoC9Bc7R6gfw03m+lQpv6kTfhxscDIX6s0w+fBxtkhjXAXr10UouWCx3C/p/FYwJRS/AXRKkjOb5CLmK4XRe0+xeDDwVkJPZau52bzLEDHCqV0f44pPgKOkYKgTZJ33fmk3Tu8SdxJ02SHM8Fem5SMsWqRyi2F1ynfRJszcFKykdWlNqgDA/L9lKYBmc7Zu/q9ii1FPF47VJkqhirUob53zoiJtVVRVwMR34gV9iqcBaHbRu9kkvqk3yMpfRFG49pKKjIiq7h/VpRwPGTHoY4cg05X5028iHsLvUW/uz+kjPyIEhhcKUwCkJAwbR9pIEGOn8z6svAO8i89sJ3dL5qDWFYbS+HGPRMxYwJItFQN86YESeJQhn2urGiLRffQeLptDl8dAgb+Tp47UQPxWOw17OeChLN1WnzlkPL1T5O+O3Menpn4C3IY5LEepHpnPeZHbvuWfeVtPlkH4LZjPbBrkJT3NoRJzBt86CO0Xq59oQ+8dsm0ymRcmQyn8w71mhmcuEI5byuF+C88VPYly2sEzjlzAQ3vdn/1+Hzguw6qFNNbqenhZGbdiG6RwZaTG7jTA2X9RdXjDN9yj1uQpyO4Lx8KRAcZcbZMafp4wPOd5MdXoFY52V1A8M9hi3sso93+uprE0qYNMjkE22CvK4HuUxqN7oIz5pWuETq1lQAjqlSlqdD2Rnr/ggp/TVkQYjn9lMfYelk2sH5HPdopYo7MHwlV1or9Bxf+QCyLzm92vzG2wjiIjC/ZHEJzeroJl6bdFPTpZho5MV2U86fLQqxNlGIMqCGy+9WYhJ8ob1r0+Whxde9L2PdysETv97O+xVw+VNN1TZSQN5I6l9m5Ip6pLIqLm4a1B1ffH6gHyqT9p82NOjntRWGIofO3bJz5GhkvSWbsXueTAMaJDou99kGLqDlhwBZNEQ4mKPuDvVwSK4WmLluHyhA97pZiVe8g+JxmnJF8IkV/tCs4Jq/HgOoAEGR9tCDsDbDmi3OviUQpG5D8XmKcSAUaFLRXb2lmJTNYdhtYyfjBYZQmN5qT5CNuaD3BVnlkCk7bsMW3AtXkNMMTuW4HjUERSJnVQ0vsBGa1wo3Qh7115XGeTF3NTz8w0440AgU7c3bSXO/KMINaIWXd0oLpoq/0/QJxCQSJ9XnYy1W7TYLBJpHsVWD1ahsA7FjNvRd6mxCiHsm8g6Z0pnzqIpF1dHUtP2ITU5Z1hZHbu+L3BEEStBbL9XYvGfEakv1bmf+bOZGnoiuHEdlBnaChxYKNzB23b8sw8YyT7Ajxfk49eJIAvdbVkdFCe2J0gMefhQ0bIZxhx3fzMIysQNiN8PgOUKxOMur10LduigREDRMZyP4oGWrP1GFY4t6groASsZ421os48wAdnrbovNhLt7ScNULkwZ5AIZJTrbaKYTLjA1oJ3sIuN/aYocm/9uoQHEIlacF1s/TM1fLcPTL38O9fOsjMEIwoPKfvt7opuI9G2Hf/PR4aCLDQ7wNmIdEuXJ/QNL72k5q4NejAldPfe3UVVqzkys8YZ/jYOGOp6c+YzRCrCuq0M11y7TiN6qk7YXRMn/gukxrEimbMQjr3jwRM6dKVZ4RUfWQr8noPXLJq6yh5R3EH1IVOHESst/LItbG2D2vRsZRkAObzvQAAD3mb3/G4NzopI0FAiHfbpq0X72adg6SRj+8OHMShtFxxLZlf/nLgRLbClwl5WmaYSs+yEjkq48tY7Z2bE0N91mJwt+ua0NlRJIDh0HikF4UvSVorFj2YVu9YeS5tfvlVjPSoNu/Zu6dEUfBOT555hahBdN3Sa5Xuj2Rvau1lQNIaC944y0RWj9UiNDskAK1WoL+EfXcC6IbBXFRyVfX/WKXxPAwUyIAGW8ggZ08hcijKTt1YKnUO6QPvcrmDVAb0FCLIXn5id4fD/Jx4tw/gbXs7WF9b2RgXtPhLBG9vF5FEkdHAKrQHZAJC/HWvk7nvzzDzIXZlfFTJoC3JpGgLPBY7SQTjGlUvG577yNutZ1hTfs9/1nkSXK9zzKLRZ3VODeKUovJe0WCq1zVMYxCJMenmNzPIU2S8TA4E7wWmbNkxq9rI2dd6v0VpcAPVMxnDsvWTWFayyqvKZO7Z08a62i/oH2/jxf8rpmfO64in3FLiL1GX8IGtVE9M23yGsIqJbxDTy+LtaMWDaPqkymb5VrQdzOvqldeU0SUi6IirG8UZ3jcpRbwHa1C0Dww9G/SFX3gPvTJQE+kyz+g1BeMILKKO+olcHzctOWgzxYHnOD7dpCRtuZEXACjgqesZMasoPgnuDC4nUviAAxDc5pngjoAITIkvhKwg5d608pdrZcA+qn5TMT6Uo/QzBaOxBCLTJX3Mgk85rMfsnWx86oLxf7p2PX5ONqieTa/qM3tPw4ZXvlAp83NSD8F7+ZgctK1TpoYwtiU2h02HCGioH5tkVCqNVTMH5p00sRy2JU1qyDBP2CII/Dg4WDsIl+zgeX7589srx6YORRQMBfKbodbB743Tl4WLKOEnwWUVBsm94SOlCracU72MSyj068wdpYjyz1FwC2bjQnxnB6Mp/pZ+yyZXtguEaYB+kqhjQ6UUmwSFazOb+rhYjLaoiM+aN9/8KKn0zaCTFpN9eKwWy7/u4EHzO46TdFSNjMfn2iPSJwDPCFHc0I1+vjdAZw5ZjqR/uzi9Zn20oAa5JnLEk/EA3VRWE7J/XrupfFJPtCUuqHPpnlL7ISJtRpSVcB8qsZCm2QEkWoROtCKKxUh3yEcMbWYJwk6DlEBG0bZP6eg06FL3v6RPb7odGuwm7FN8fG4woqtB8e7M5klPpo97GoObNwt+ludTAmxyC5hmcFx+dIvEZKI6igFKHqLH01iY1o7903VzG9QGetyVx5RNmBYUU+zIuSva/yIcECUi4pRmE3VkF2avqulQEUY4yZ/wmNboBzPmAPey3+dSYtBZUjeWWT0pPwCz4Vozxp9xeClIU60qvEFMQCaPvPaA70WlOP9f/ey39macvpGCVa+zfa8gO44wbxpJUlC8GN/pRMTQtzY8Z8/hiNrU+Zq64ZfFGIkdj7m7abcK1EBtws1X4J/hnqvasPvvDSDYWN+QcQVGMqXalkDtTad5rYY0TIR1Eqox3czwPMjKPvF5sFv17Thujr1IZ1Ytl4VX1J0vjXKmLY4lmXipRAro0qVGEcXxEVMMEl54jQMd4J7RjgomU0j1ptjyxY+cLiSyXPfiEcIS2lWDK3ISAy6UZ3Hb5vnPncA94411jcy75ay6B6DSTzK6UTCZR9uDANtPBrvIDgjsfarMiwoax2OlLxaSoYn4iRgkpEGqEkwox5tyI8aKkLlfZ12lO11TxsqRMY89j5JaO55XfPJPDL1LGSnC88Re9Ai+Nu5bZjtwRrvFITUFHPR4ZmxGslQMecgbZO7nHk32qHxYkdvWpup07ojcMCaVrpFAyFZJJbNvBpZfdf39Hdo2kPtT7v0/f8R/B5Nz4f1t9/3zNM/7n6SUHfcWk5dfQFJvcJMgPolGCpOFb/WC0FGWU2asuQyT+rm88ZKZ78Cei/CAh939CH0JYbpZIPtxc2ufXqjS3pHH9lnWK4iJ7OjR/EESpCo2R3MYKyE7rHfhTvWho4cL1QdN4jFTyR6syMwFm124TVDDRXMNveI1Dp/ntwdz8k8kxw7iFSx6+Yx6O+1LzMVrN0BBzziZi9kneZSzgollBnVwBh6oSOPHXrglrOj+QmR/AESrhDpKrWT+8/AiMDxS/5wwRNuGQPLlJ9ovomhJWn8sMLVItQ8N/7IXvtD8kdOoHaw+vBSbFImQsv/OCAIui99E+YSIOMlMvBXkAt+NAZK8wB9Jf8CPtB+TOUOR+z71d/AFXpPBT6+A5FLjxMjLIEoJzrQfquvxEIi+WoUzGR1IzQFNvbYOnxb2PyQ0kGdyXKzW2axQL8lNAXPk6NEjqrRD1oZtKLlFoofrXw0dCNWASHzy+7PSzOUJ3XtaPZsxLDjr+o41fKuKWNmjiZtfkOzItvlV2MDGSheGF0ma04qE3TUEfqJMrXFm7DpK+27DSvCUVf7rbNoljPhha5W7KBqVq0ShUSTbRmuqPtQreVWH4JET5yMhuqMoSd4r/N8sDmeQiQQvi1tcZv7Moc7dT5X5AtCD6kNEGZOzVcNYlpX4AbTsLgSYYliiPyVoniuYYySxsBy5cgb3pD+EK0Gpb0wJg031dPgaL8JZt6sIvzNPEHfVPOjXmaXj4bd4voXzpZ5GApMhILgMbCEWZ2zwgdeQgjNHLbPIt+KqxRwWPLTN6HwZ0Ouijj4UF+Sg0Au8XuIKW0WxlexdrFrDcZJ8Shauat3X0XmHygqgL1nAu2hrJFb4wZXkcS+i36KMyU1yFvYv23bQUJi/3yQpqr/naUOoiEWOxckyq/gq43dFou1DVDaYMZK9tho7+IXXokBCs5GRfOcBK7g3A+jXQ39K4YA8PBRW4m5+yR0ZAxWJncjRVbITvIAPHYRt1EJ3YLiUbqIvoKHtzHKtUy1ddRUQ0AUO41vonZDUOW+mrszw+SW/6Q/IUgNpcXFjkM7F4CSSQ2ExZg85otsMs7kqsQD4OxYeBNDcSpifjMoLb7GEbGWTwasVObmB/bfPcUlq0wYhXCYEDWRW02TP5bBrYsKTGWjnWDDJ1F7zWai0zW/2XsCuvBQjPFcTYaQX3tSXRSm8hsAoDdjArK/OFp6vcWYOE7lizP0Yc+8p16i7/NiXIiiQTp7c7Xus925VEtlKAjUdFhyaiLT7VxDagprMFwix4wZ05u0qj7cDWFd0W9OYHIu3JbJKMXRJ1aYNovugg+QqRN7fNHSi26VSgBpn+JfMuPo3aeqPWik/wI5Rz3BWarPQX4i5+dM0npwVOsX+KsOhC7vDg+OJsz4Q5zlnIeflUWL6QYMbf9WDfLmosLF4Qev3mJiOuHjoor/dMeBpA9iKDkMjYBNbRo414HCxjsHrB4EXNbHzNMDHCLuNBG6Sf+J4MZ/ElVsDSLxjIiGsTPhw8BPjxbfQtskj+dyNMKOOcUYIRBEIqbazz3lmjlRQhplxq673VklMMY6597vu+d89ec/zq7Mi4gQvh87ehYbpOuZEXj5g/Q7S7BFDAAB9DzG35SC853xtWVcnZQoH54jeOqYLR9NDuwxsVthTV7V99n/B7HSbAytbEyVTz/5NhJ8gGIjG0E5j3griULUd5Rg7tQR+90hJgNQKQH2btbSfPcaTOfIexc1db1BxUOhM1vWCpLaYuKr3FdNTt/T3PWCpEUWDKEtzYrjpzlL/wri3MITKsFvtF8QVV/NhVo97aKIBgdliNc10dWdXVDpVtsNn+2UIolrgqdWA4EY8so0YvB4a+aLzMXiMAuOHQrXY0tr+CL10JbvZzgjJJuB1cRkdT7DUqTvnswVUp5kkUSFVtIIFYK05+tQxT6992HHNWVhWxUsD1PkceIrlXuUVRogwmfdhyrf6zzaL8+c0L7GXMZOteAhAVQVwdJh+7nrX7x4LaIIfz2F2v7Dg/uDfz2Fa+4gFm2zHAor8UqimJG3VTJtZEoFXhnDYXvxMJFc6ku2bhbCxzij2z5UNuK0jmp1mnvkVNUfR+SEmj1Lr94Lym75PO7Fs0MIr3GdsWXRXSfgLTVY0FLqba97u1In8NAcY7IC6TjWLigwKEIm43NxTdaVTv9mcKkzuzBkKd8x/xt1p/9BbP7Wyb4bpo1K1gnOpbLvKz58pWl3B55RJ/Z5mRDLPtNQg14jdOEs9+h/V5UVpwrAI8kGbX8KPVPDIMfIqKDjJD9UyDOPhjZ3vFAyecwyq4akUE9mDOtJEK1hpDyi6Ae87sWAClXGTiwPwN7PXWwjxaR79ArHRIPeYKTunVW24sPr/3HPz2IwH8oKH4OlWEmt4BLM6W5g4kMcYbLwj2usodD1088stZA7VOsUSpEVl4w7NMb1EUHMRxAxLF0CIV+0L3iZb+ekB1vSDSFjAZ3hfLJf7gFaXrOKn+mhR+rWw/eTXIcAgl4HvFuBg1LOmOAwJH3eoVEjjwheKA4icbrQCmvAtpQ0mXG0agYp5mj4Rb6mdQ+RV4QBPbxMqh9C7o8nP0Wko2ocnCHeRGhN1XVyT2b9ACsL+6ylUy+yC3QEnaKRIJK91YtaoSrcWZMMwxuM0E9J68Z+YyjA0g8p1PfHAAIROy6Sa04VXOuT6A351FOWhKfTGsFJ3RTJGWYPoLk5FVK4OaYR9hkJvezwF9vQN1126r6isMGXWTqFW+3HL3I/jurlIdDWIVvYY+s6yq7lrFSPAGRdnU7PVwY/SvWbZGpXzy3BQ2LmAJlrONUsZs4oGkly0V267xbD5KMY8woNNsmWG1VVgLCra8aQBBcI4DP2BlNwxhiCtHlaz6OWFoCW0vMR3ErrG7JyMjTSCnvRcsEHgmPnwA6iNpJ2DrFb4gLlhKJyZGaWkA97H6FFdwEcLT6DRQQL++fOkVC4cYGW1TG/3iK5dShRSuiBulmihqgjR45Vi03o2RbQbP3sxt90VxQ6vzdlGfkXmmKmjOi080JSHkLntjvsBJnv7gKscOaTOkEaRQqAnCA4HWtB4XnMtOhpRmH2FH8tTXrIjAGNWEmudQLCkcVlGTQ965Kh0H6ixXbgImQP6b42B49sO5C8pc7iRlgyvSYvcnH9FgQ3azLbQG2cUW96SDojTQStxkOJyOuDGTHAnnWkz29aEwN9FT8EJ4yhXOg+jLTrCPKeEoJ9a7lDXOjEr8AgX4BmnMQ668oW0zYPyQiVMPxKRHtpfnEEyaKhdzNVThlxxDQNdrHeZiUFb6NoY2KwvSb7BnRcpJy+/g/zAYx3fYSN5QEaVD2Y1VsNWxB0BSO12MRsRY8JLfAezRMz5lURuLUnG1ToKk6Q30FughqWN6gBNcFxP/nY/iv+iaUQOa+2Nuym46wtI/DvSfzSp1jEi4SdYBE7YhTiVV5cX9gwboVDMVgZp5YBQlHOQvaDNfcCoCJuYhf5kz5kwiIKPjzgpcRJHPbOhJajeoeRL53cuMahhV8Z7IRr6M4hW0JzT7mzaMUzQpm866zwM7Cs07fJYXuWvjAMkbe5O6V4bu71sOG6JQ4oL8zIeXHheFVavzxmlIyBkgc9IZlEDplMPr8xlcyss4pVUdwK1e7CK2kTsSdq7g5SHRAl3pYUB9Ko4fsh4qleOyJv1z3KFSTSvwEcRO/Ew8ozEDYZSqpfoVW9uhJfYrNAXR0Z3VmeoAD+rVWtwP/13sE/3ICX3HhDG3CMc476dEEC0K3umSAD4j+ZQLVdFOsWL2C1TH5+4KiSWH+lMibo+B55hR3Gq40G1n25sGcN0mEcoU2wN9FCVyQLBhYOu9aHVLWjEKx2JIUZi5ySoHUAI9b8hGzaLMxCZDMLhv8MkcpTqEwz9KFDpCpqQhVmsGQN8m24wyB82FAKNmjgfKRsXRmsSESovAwXjBIoMKSG51p6Um8b3i7GISs7kjTq/PZoioCfJzfKdJTN0Q45kQEQuh9H88M3yEs3DbtRTKALraM0YC8laiMiOOe6ADmTcCiREeAWZelBaEXRaSuj2lx0xHaRYqF65O0Lo5OCFU18A8cMDE4MLYm9w2QSr9NgQAIcRxZsNpA7UJR0e71JL+VU+ISWFk5I97lra8uGg7GlQYhGd4Gc6rxsLFRiIeGO4abP4S4ekQ1fiqDCy87GZHd52fn5aaDGuvOmIofrzpVwMvtbreZ/855OaXTRcNiNE0wzGZSxbjg26v8ko8L537v/XCCWP2MFaArJpvnkep0pA+O86MWjRAZPQRfznZiSIaTppy6m3p6HrNSsY7fDtz7Cl4V/DJAjQDoyiL2uwf1UHVd2AIrzBUSlJaTj4k6NL97a/GqhWKU9RUmjnYKpm2r+JYUcrkCuZKvcYvrg8pDoUKQywY9GDWg03DUFSirlUXBS5SWn/KAntnf0IdHGL/7mwXqDG+LZYjbEdQmqUqq4y54TNmWUP7IgcAw5816YBzwiNIJiE9M4lPCzeI/FGBeYy3p6IAmH4AjXXmvQ4Iy0Y82NTobcAggT2Cdqz6Mx4TdGoq9fn2etrWKUNFyatAHydQTVUQ2S5OWVUlugcNvoUrlA8cJJz9MqOa/W3iVno4zDHfE7zhoY5f5lRTVZDhrQbR8LS4eRLz8iPMyBL6o4PiLlp89FjdokQLaSBmKHUwWp0na5fE3v9zny2YcDXG/jfI9sctulHRbdkI5a4GOPJx4oAJQzVZ/yYAado8KNZUdEFs9ZPiBsausotXMNebEgr0dyopuqfScFJ3ODNPHgclACPdccwv0YJGQdsN2lhoV4HVGBxcEUeUX/alr4nqpcc1CCR3vR7g40zteQg/JvWmFlUE4mAiTpHlYGrB7w+U2KdSwQz2QJKBe/5eiixWipmfP15AFWrK8Sh1GBBYLgzki1wTMhGQmagXqJ2+FuqJ8f0XzXCVJFHQdMAw8xco11HhM347alrAu+wmX3pDFABOvkC+WPX0Uhg1Z5MVHKNROxaR84YV3s12UcM+70cJ460SzEaKLyh472vOMD3XnaK7zxZcXlWqenEvcjmgGNR2OKbI1s8U+iwiW+HotHalp3e1MGDy6BMVIvajnAzkFHbeVsgjmJUkrP9OAwnEHYXVBqYx3q7LvXjoVR0mY8h+ZaOnh053pdsGkmbqhyryN01eVHySr+CkDYkSMeZ1xjPNVM+gVLTDKu2VGsMUJqWO4TwPDP0VOg2/8ITbAUaMGb4LjL7L+Pi11lEVMXTYIlAZ/QHmTENjyx3kDkBdfcvvQt6tKk6jYFM4EG5UXDTaF5+1ZjRz6W7MdJPC+wTkbDUim4p5QQH3b9kGk2Bkilyeur8Bc20wm5uJSBO95GfYDI1EZipoRaH7uVveneqz43tlTZGRQ4a7CNmMHgXyOQQOL6WQkgMUTQDT8vh21aSdz7ERiZT1jK9F+v6wgFvuEmGngSvIUR2CJkc5tx1QygfZnAruONobB1idCLB1FCfO7N1ZdRocT8/Wye+EnDiO9pzqIpnLDl4bkaRKW+ekBVwHn46Shw1X0tclt/0ROijuUB4kIInrVJU4buWf4YITJtjOJ6iKdr1u+flgQeFH70GxKjhdgt/MrwfB4K/sXczQ+9zYcrD4dhY6qZhZ010rrxggWA8JaZyg2pYij8ieYEg1aZJkZK9O1Re7sB0iouf60rK0Gd+AYlp7soqCBCDGwfKeUQhCBn0E0o0GS6PdmjLi0TtCYZeqazqwN+yNINIA8Lk3iPDnWUiIPLGNcHmZDxfeK0iAdxm/T7LnN+gemRL61hHIc0NCAZaiYJR+OHnLWSe8sLrK905B5eEJHNlWq4RmEXIaFTmo49f8w61+NwfEUyuJAwVqZCLFcyHBKAcIVj3sNzfEOXzVKIndxHw+AR93owhbCxUZf6Gs8cz6/1VdrFEPrv330+9s6BtMVPJ3zl/Uf9rUi0Z/opexfdL3ykF76e999GPfVv8fJv/Y/+/5hEMon1tqNFyVRevV9y9/uIvsG3dbB8GRRrgaEXfhx+2xeOFt+cEn3RZanNxdEe2+B6MHpNbrRE53PlDifPvFcp4kO78ILR0T4xyW/WGPyBsqGdoA7zJJCu1TKbGfhnqgnRbxbB2B3UZoeQ2bz2sTVnUwokTcTU21RxN1PYPS3Sar7T0eRIsyCNowr9amwoMU/od9s2APtiKNL6ENOlyKADstAEWKA+sdKDhrJ6BOhRJmZ+QJbAaZ3/5Fq0/lumCgEzGEbu3yi0Y4I4EgVAjqxh4HbuQn0GrRhOWyAfsglQJAVL1y/6yezS2k8RE2MstJLh92NOB3GCYgFXznF4d25qiP4ZCyI4RYGesut6FXK6GwPpKK8WHEkhYui0AyEmr5Ml3uBFtPFdnioI8RiCooa7Z1G1WuyIi3nSNglutc+xY8BkeW3JJXPK6jd2VIMpaSxpVtFq+R+ySK9J6WG5Qvt+C+QH1hyYUOVK7857nFmyDBYgZ/o+AnibzNVqyYCJQvyDXDTK+iXdkA71bY7TL3bvuLxLBQ8kbTvTEY9aqkQ3+MiLWbEgjLzOH+lXgco1ERgzd80rDCymlpaRQbOYnKG/ODoFl46lzT0cjM5FYVvv0qLUbD5lyJtMUaC1pFlTkNONx6lliaX9o0i/1vws5bNKn5OuENQEKmLlcP4o2ZmJjD4zzd3Fk32uQ4uRWkPSUqb4LBe3EXHdORNB2BWsws5daRnMfNVX7isPSb1hMQdAJi1/qmDMfRUlCU74pmnzjbXfL8PVG8NsW6IQM2Ne23iCPIpryJjYbVnm5hCvKpMa7HLViNiNc+xTfDIaKm3jctViD8A1M9YPJNk003VVr4Zo2MuGW8vil8SLaGpPXqG7I4DLdtl8a4Rbx1Lt4w5Huqaa1XzZBtj208EJVGcmKYEuaeN27zT9EE6a09JerXdEbpaNgNqYJdhP1NdqiPKsbDRUi86XvvNC7rME5mrSQtrzAZVndtSjCMqd8BmaeGR4l4YFULGRBeXIV9Y4yxLFdyoUNpiy2IhePSWzBofYPP0eIa2q5JP4j9G8at/AqoSsLAUuRXtvgsqX/zYwsE+of6oSDbUOo4RMJw+DOUTJq+hnqwKim9Yy/napyZNTc2rCq6V9jHtJbxGPDwlzWj/Sk3zF/BHOlT/fSjSq7FqlPI1q6J+ru8Aku008SFINXZfOfnZNOvGPMtEmn2gLPt+H4QLA+/SYe4j398auzhKIp2Pok3mPC5q1IN1HgR+mnEfc4NeeHYwd2/kpszR3cBn7ni9NbIqhtSWFW8xbUJuUPVOeeXu3j0IGZmFNiwaNZ6rH4/zQ2ODz6tFxRLsUYZu1bfd1uIvfQDt4YD/efKYv8VF8bHGDgK22w2Wqwpi43vNCOXFJZCGMqWiPbL8mil6tsmOTXAWCyMCw73e2rADZj2IK6rqksM3EXF2cbLb4vjB14wa/yXK5vwU+05MzERJ5nXsXsW21o7M+gO0js2OyKciP5uF2iXyb2DiptwQeHeqygkrNsqVCSlldxBMpwHi1vfc8RKpP/4L3Lmpq6DZcvhDDfxTCE3splacTcOtXdK2g303dIWBVe2wD/Gvja1cClFQ67gw0t1ZUttsUgQ1Veky8oOpS6ksYEc4bqseCbZy766SvL3FodmnahlWJRgVCNjPxhL/fk2wyvlKhITH/VQCipOI0dNcRa5B1M5HmOBjTLeZQJy237e2mobwmDyJNHePhdDmiknvLKaDbShL+Is1XTCJuLQd2wmdJL7+mKvs294whXQD+vtd88KKk0DXP8B1Xu9J+xo69VOuFgexgTrcvI6SyltuLix9OPuE6/iRJYoBMEXxU4shQMf4Fjqwf1PtnJ/wWSZd29rhZjRmTGgiGTAUQqRz+nCdjeMfYhsBD5Lv60KILWEvNEHfmsDs2L0A252351eUoYxAysVaCJVLdH9QFWAmqJDCODUcdoo12+gd6bW2boY0pBVHWL6LQDK5bYWh1V8vFvi0cRpfwv7cJiMX3AZNJuTddHehTIdU0YQ/sQ1dLoF2xQPcCuHKiuCWOY30DHe1OwcClLAhqAKyqlnIbH/8u9ScJpcS4kgp6HKDUdiOgRaRGSiUCRBjzI5gSksMZKqy7Sd51aeg0tgJ+x0TH9YH2Mgsap9N7ENZdEB0bey2DMTrBA1hn56SErNHf3tKtqyL9b6yXEP97/rc+jgD2N1LNUH6RM9AzP3kSipr06RkKOolR7HO768jjWiH1X92jA7dkg7gcNcjqsZCgfqWw0tPXdLg20cF6vnQypg7gLtkazrHAodyYfENPQZsdfnjMZiNu4nJO97D1/sQE+3vNFzrSDOKw+keLECYf7RJwVHeP/j79833oZ0egonYB2FlFE5qj02B/LVOMJQlsB8uNg3Leg4qtZwntsOSNidR0abbZmAK4sCzvt8Yiuz2yrNCJoH5O8XvX/vLeR/BBYTWj0sOPYM/jyxRd5+/JziKAABaPcw/34UA3aj/gLZxZgRCWN6m4m3demanNgsx0P237/Q+Ew5VYnJPkyCY0cIVHoFn2Ay/e7U4P19APbPFXEHX94N6KhEMPG7iwB3+I+O1jd5n6VSgHegxgaSawO6iQCYFgDsPSMsNOcUj4q3sF6KzGaH/0u5PQoAj/8zq6Uc9MoNrGqhYeb2jQo0WlGlXjxtanZLS24/OIN5Gx/2g684BPDQpwlqnkFcxpmP/osnOXrFuu4PqifouQH0eF5qCkvITQbJw/Zvy5mAHWC9oU+cTiYhJmSfKsCyt1cGVxisKu+NymEQIAyaCgud/V09qT3nk/9s/SWsYtha7yNpzBIMM40rCSGaJ9u6lEkl00vXBiEt7p9P5IBCiavynEOv7FgLqPdeqxRiCwuFVMolSIUBcoyfUC2e2FJSAUgYdVGFf0b0Kn2EZlK97yyxrT2MVgvtRikfdaAW8RwEEfN+B7/eK8bBdp7URpbqn1xcrC6d2UjdsKbzCjBFqkKkoZt7Mrhg6YagE7spkqj0jOrWM+UGQ0MUlG2evP1uE1p2xSv4dMK0dna6ENcNUF+xkaJ7B764NdxLCpuvhblltVRAf7vK5qPttJ/9RYFUUSGcLdibnz6mf7WkPO3MkUUhR2mAOuGv8IWw5XG1ZvoVMnjSAZe6T7WYA99GENxoHkMiKxHlCuK5Gd0INrISImHQrQmv6F4mqU/TTQ8nHMDzCRivKySQ8dqkpQgnUMnwIkaAuc6/FGq1hw3b2Sba398BhUwUZSAIO8XZvnuLdY2n6hOXws+gq9BHUKcKFA6kz6FDnpxLPICa3qGhnc97bo1FT/XJk48LrkHJ2CAtBv0RtN97N21plfpXHvZ8gMJb7Zc4cfI6MbPwsW7AilCSXMFIEUEmir8XLEklA0ztYbGpTTGqttp5hpFTTIqUyaAIqvMT9A/x+Ji5ejA4Bhxb/cl1pUdOD6epd3yilIdO6j297xInoiBPuEDW2/UfslDyhGkQs7Wy253bVnlT+SWg89zYIK/9KXFl5fe+jow2rd5FXv8zDPrmfMXiUPt9QBO/iK4QGbX5j/7Rx1c1vzsY8ONbP3lVIaPrhL4+1QrECTN3nyKavGG0gBBtHvTKhGoBHgMXHStFowN+HKrPriYu+OZ05Frn8okQrPaaxoKP1ULCS/cmKFN3gcH7HQlVjraCeQmtjg1pSQxeuqXiSKgLpxc/1OiZsU4+n4lz4hpahGyWBURLi4642n1gn9qz9bIsaCeEPJ0uJmenMWp2tJmIwLQ6VSgDYErOeBCfSj9P4G/vI7oIF+l/n5fp956QgxGvur77ynawAu3G9MdFbJbu49NZnWnnFcQHjxRuhUYvg1U/e84N4JTecciDAKb/KYIFXzloyuE1eYXf54MmhjTq7B/yBToDzzpx3tJCTo3HCmVPYfmtBRe3mPYEE/6RlTIxbf4fSOcaKFGk4gbaUWe44hVk9SZzhW80yfW5QWBHxmtUzvMhfVQli4gZTktIOZd9mjJ5hsbmzttaHQB29Am3dZkmx3g/qvYocyhZ2PXAWsNQiIaf+Q8W/MWPIK7/TjvCx5q2XRp4lVWydMc2wIQkhadDB0xsnw/kSEyGjLKjI4coVIwtubTF3E7MJ6LS6UOsJKj82XVAVPJJcepfewbzE91ivXZvOvYfsmMevwtPpfMzGmC7WJlyW2j0jh7AF1JLmwEJSKYwIvu6DHc3YnyLH9ZdIBnQ+nOVDRiP+REpqv++typYHIvoJyICGA40d8bR7HR2k7do6UQTHF4oriYeIQbxKe4Th6+/l1BjUtS9hqORh3MbgvYrStXTfSwaBOmAVQZzpYNqsAmQyjY56MUqty3c/xH6GuhNvNaG9vGbG6cPtBM8UA3e8r51D0AR9kozKuGGSMgLz3nAHxDNnc7GTwpLj7/6HeWp1iksDeTjwCLpxejuMtpMnGJgsiku1sOACwQ9ukzESiDRN77YNESxR5LphOlcASXA5uIts1LnBIcn1J7BLWs49DMALSnuz95gdOrTZr0u1SeYHinno/pE58xYoXbVO/S+FEMMs5qyWkMnp8Q3ClyTlZP52Y9nq7b8fITPuVXUk9ohG5EFHw4gAEcjFxfKb3xuAsEjx2z1wxNbSZMcgS9GKyW3R6KwJONgtA64LTyxWm8Bvudp0M1FdJPEGopM4Fvg7G/hsptkhCfHFegv4ENwxPeXmYhxwZy7js+BeM27t9ODBMynVCLJ7RWcBMteZJtvjOYHb5lOnCLYWNEMKC59BA7covu1cANa2PXL05iGdufOzkgFqqHBOrgQVUmLEc+Mkz4Rq8O6WkNr7atNkH4M8d+SD1t/tSzt3oFql+neVs+AwEI5JaBJaxARtY2Z4mKoUqxds4UpZ0sv3zIbNoo0J4fihldQTX3XNcuNcZmcrB5LTWMdzeRuAtBk3cZHYQF6gTi3PNuDJ0nmR+4LPLoHvxQIxRgJ9iNNXqf2SYJhcvCtJiVWo85TsyFOuq7EyBPJrAdhEgE0cTq16FQXhYPJFqSfiVn0IQnPOy0LbU4BeG94QjdYNB0CiQ3QaxQqD2ebSMiNjaVaw8WaM4Z5WnzcVDsr4eGweSLa2DE3BWViaxhZFIcSTjgxNCAfelg+hznVOYoe5VqTYs1g7WtfTm3e4/WduC6p+qqAM8H4ZyrJCGpewThTDPe6H7CzX/zQ8Tm+r65HeZn+MsmxUciEWPlAVaK/VBaQBWfoG/aRL/jSZIQfep/89GjasWmbaWzeEZ2R1FOjvyJT37O9B8046SRSKVEnXWlBqbkb5XCS3qFeuE9xb9+frEknxWB5h1D/hruz2iVDEAS7+qkEz5Ot5agHJc7WCdY94Ws61sURcX5nG8UELGBAHZ3i+3VulAyT0nKNNz4K2LBHBWJcTBX1wzf+//u/j/9+//v87+9/l9Lbh/L/uyNYiTsWV2LwsjaA6MxTuzFMqmxW8Jw/+IppdX8t/Clgi1rI1SN0UC/r6tX/4lUc2VV1OQReSeCsjUpKZchw4XUcjHfw6ryCV3R8s6VXm67vp4n+lcPV9gJwmbKQEsmrJi9c2vkwrm8HFbVYNTaRGq8D91t9n5+U+aD/hNtN3HjC/nC/vUoGFSCkXP+NlRcmLUqLbiUBl4LYf1U/CCvwtd3ryCH8gUmGITAxiH1O5rnGTz7y1LuFjmnFGQ1UWuM7HwfXtWl2fPFKklYwNUpF2IL/TmaRETjQiM5SJacI+3Gv5MBU8lP5Io6gWkawpyzNEVGqOdx4YlO1dCvjbWFZWbCmeiFKPSlMKtKcMFLs/KQxtgAHi7NZNCQ32bBAW2mbHflVZ8wXKi1JKVHkW20bnYnl3dKWJeWJOiX3oKPBD6Zbi0ZvSIuWktUHB8qDR8DMMh1ZfkBL9FS9x5r0hBGLJ8pUCJv3NYH+Ae8p40mZWd5m5fhobFjQeQvqTT4VKWIYfRL0tfaXKiVl75hHReuTJEcqVlug+eOIIc4bdIydtn2K0iNZPsYWQvQio2qbO3OqAlPHDDOB7DfjGEfVF51FqqNacd6QmgFKJpMfLp5DHTv4wXlONKVXF9zTJpDV4m1sYZqJPhotcsliZM8yksKkCkzpiXt+EcRQvSQqmBS9WdWkxMTJXPSw94jqI3varCjQxTazjlMH8jTS8ilaW8014/vwA/LNa+YiFoyyx3s/KswP3O8QW1jtq45yTM/DX9a8M4voTVaO2ebvw1EooDw/yg6Y1faY+WwrdVs5Yt0hQ5EwRfYXSFxray1YvSM+kYmlpLG2/9mm1MfmbKHXr44Ih8nVKb1M537ZANUkCtdsPZ80JVKVKabVHCadaLXg+IV8i5GSwpZti0h6diTaKs9sdpUKEpd7jDUpYmHtiX33SKiO3tuydkaxA7pEc9XIQEOfWJlszj5YpL5bKeQyT7aZSBOamvSHl8xsWvgo26IP/bqk+0EJUz+gkkcvlUlyPp2kdKFtt7y5aCdks9ZJJcFp5ZWeaWKgtnXMN3ORwGLBE0PtkEIek5FY2aVssUZHtsWIvnljMVJtuVIjpZup/5VL1yPOHWWHkOMc6YySWMckczD5jUj2mlLVquFaMU8leGVaqeXis+aRRL8zm4WuBk6cyWfGMxgtr8useQEx7k/PvRoZyd9nde1GUCV84gMX8Ogu/BWezYPSR27llzQnA97oo0pYyxobYUJfsj+ysTm9zJ+S4pk0TGo9VTG0KjqYhTmALfoDZVKla2b5yhv241PxFaLJs3i05K0AAIdcGxCJZmT3ZdT7CliR7q+kur7WdQjygYtOWRL9B8E4s4LI8KpAj7bE0dg7DLOaX+MGeAi0hMMSSWZEz+RudXbZCsGYS0QqiXjH9XQbd8sCB+nIVTq7/T/FDS+zWY9q7Z2fdq1tdLb6v3hKKVDAw5gjj6o9r1wHFROdHc18MJp4SJ2Ucvu+iQ9EgkekW8VCM+psM6y+/2SBy8tNN4a3L1MzP+OLsyvESo5gS7IQOnIqMmviJBVc6zbVG1n8eXiA3j46kmvvtJlewwNDrxk4SbJOtP/TV/lIVK9ueShNbbMHfwnLTLLhbZuO79ec5XvfgRwLFK+w1r5ZWW15rVFZrE+wKqNRv5KqsLNfpGgnoUU6Y71NxEmN7MyqwqAQqoIULOw/LbuUB2+uE75gJt+kq1qY4LoxV+qR/zalupea3D5+WMeaRIn0sAI6DDWDh158fqUb4YhAxhREbUN0qyyJYkBU4V2KARXDT65gW3gRsiv7xSPYEKLwzgriWcWgPr0sbZnv7m1XHNFW6xPdGNZUdxFiUYlmXNjDVWuu7LCkX/nVkrXaJhiYktBISC2xgBXQnNEP+cptWl1eG62a7CPXrnrkTQ5BQASbEqUZWMDiZUisKyHDeLFOaJILUo5f6iDt4ZO8MlqaKLto0AmTHVVbkGuyPa1R/ywZsWRoRDoRdNMMHwYTsklMVnlAd2S0282bgMI8fiJpDh69OSL6K3qbo20KfpNMurnYGQSr/stFqZ7hYsxKlLnKAKhsmB8AIpEQ4bd/NrTLTXefsE6ChRmKWjXKVgpGoPs8GAicgKVw4K0qgDgy1A6hFq1WRat3fHF+FkU+b6H4NWpOU3KXTxrIb2qSHAb+qhm8hiSROi/9ofapjxhyKxxntPpge6KL5Z4+WBMYkAcE6+0Hd3Yh2zBsK2MV3iW0Y6cvOCroXlRb2MMJtdWx+3dkFzGh2Pe3DZ9QpSqpaR/rE1ImOrHqYYyccpiLC22amJIjRWVAherTfpQLmo6/K2pna85GrDuQPlH1Tsar8isAJbXLafSwOof4gg9RkAGm/oYpBQQiPUoyDk2BCQ1k+KILq48ErFo4WSRhHLq/y7mgw3+L85PpP6xWr6cgp9sOjYjKagOrxF148uhuaWtjet953fh1IQiEzgC+d2IgBCcUZqgTAICm2bR8oCjDLBsmg+ThyhfD+zBalsKBY1Ce54Y/t9cwfbLu9SFwEgphfopNA3yNxgyDafUM3mYTovZNgPGdd4ZFFOj1vtfFW3u7N+iHEN1HkeesDMXKPyoCDCGVMo4GCCD6PBhQ3dRZIHy0Y/3MaE5zU9mTCrwwnZojtE+qNpMSkJSpmGe0EzLyFelMJqhfFQ7a50uXxZ8pCc2wxtAKWgHoeamR2O7R+bq7IbPYItO0esdRgoTaY38hZLJ5y02oIVwoPokGIzxAMDuanQ1vn2WDQ00Rh6o5QOaCRu99fwDbQcN0XAuqkFpxT/cfz3slGRVokrNU0iqiMAJFEbKScZdmSkTUznC0U+MfwFOGdLgsewRyPKwBZYSmy6U325iUhBQNxbAC3FLKDV9VSOuQpOOukJ/GAmu/tyEbX9DgEp6dv1zoU0IqzpG6gssSjIYRVPGgU1QAQYRgIT8gEV0EXr1sqeh2I6rXjtmoCYyEDCe/PkFEi/Q48FuT29p557iN+LCwk5CK/CZ2WdAdfQZh2Z9QGrzPLSNRj5igUWzl9Vi0rCqH8G1Kp4QMLkuwMCAypdviDXyOIk0AHTM8HBYKh3b0/F+DxoNj4ZdoZfCpQVdnZarqoMaHWnMLNVcyevytGsrXQEoIbubqWYNo7NRHzdc0zvT21fWVirj7g36iy6pxogfvgHp1xH1Turbz8QyyHnXeBJicpYUctbzApwzZ1HT+FPEXMAgUZetgeGMwt4G+DHiDT2Lu+PT21fjJCAfV16a/Wu1PqOkUHSTKYhWW6PhhHUlNtWzFnA7MbY+r64vkwdpfNB2JfWgWXAvkzd42K4lN9x7Wrg4kIKgXCb4mcW595MCPJ/cTfPAMQMFWwnqwde4w8HZYJFpQwcSMhjVz4B8p6ncSCN1X4klxoIH4BN2J6taBMj6lHkAOs8JJAmXq5xsQtrPIPIIp/HG6i21xMGcFgqDXSRF0xQg14d2uy6HgKE13LSvQe52oShF5Jx1R6avyL4thhXQZHfC94oZzuPUBKFYf1VvDaxIrtV6dNGSx7DO0i1p6CzBkuAmEqyWceQY7F9+U0ObYDzoa1iKao/cOD/v6Q9gHrrr1uCeOk8fST9MG23Ul0KmM3r+Wn6Hi6WAcL7gEeaykicvgjzkjSwFsAXIR81Zx4QJ6oosVyJkCcT+4xAldCcihqvTf94HHUPXYp3REIaR4dhpQF6+FK1H0i9i7Pvh8owu3lO4PT1iuqu+DkL2Bj9+kdfGAg2TXw03iNHyobxofLE2ibjsYDPgeEQlRMR7afXbSGQcnPjI2D+sdtmuQ771dbASUsDndU7t58jrrNGRzISvwioAlHs5FA+cBE5Ccznkd8NMV6BR6ksnKLPZnMUawRDU1MZ/ib3xCdkTblHKu4blNiylH5n213yM0zubEie0o4JhzcfAy3H5qh2l17uLooBNLaO+gzonTH2uF8PQu9EyH+pjGsACTMy4cHzsPdymUSXYJOMP3yTkXqvO/lpvt0cX5ekDEu9PUfBeZODkFuAjXCaGdi6ew4qxJ8PmFfwmPpkgQjQlWqomFY6UkjmcnAtJG75EVR+NpzGpP1Ef5qUUbfowrC3zcSLX3BxgWEgEx/v9cP8H8u1Mvt9/rMDYf6sjwU1xSOPBgzFEeJLMRVFtKo5QHsUYT8ZRLCah27599EuqoC9PYjYO6aoAMHB8X1OHwEAYouHfHB3nyb2B+SnZxM/vw/bCtORjLMSy5aZoEpvgdGvlJfNPFUu/p7Z4VVK1hiI0/UTuB3ZPq4ohEbm7Mntgc1evEtknaosgZSwnDC2BdMmibpeg48X8Ixl+/8+xXdbshQXUPPvx8jT3fkELivHSmqbhblfNFShWAyQnJ3WBU6SMYSIpTDmHjdLVAdlADdz9gCplZw6mTiHqDwIsxbm9ErGusiVpg2w8Q3khKV/R9Oj8PFeF43hmW/nSd99nZzhyjCX3QOZkkB6BsH4H866WGyv9E0hVAzPYah2tkRfQZMmP2rinfOeQalge0ovhduBjJs9a1GBwReerceify49ctOh5/65ATYuMsAkVltmvTLBk4oHpdl6i+p8DoNj4Fb2vhdFYer2JSEilEwPd5n5zNoGBXEjreg/wh2NFnNRaIUHSOXa4eJRwygZoX6vnWnqVdCRT1ARxeFrNBJ+tsdooMwqnYhE7zIxnD8pZH+P0Nu1wWxCPTADfNWmqx626IBJJq6NeapcGeOmbtXvl0TeWG0Y7OGGV4+EHTtNBIT5Wd0Bujl7inXgZgfXTM5efD3qDTJ54O9v3Bkv+tdIRlq1kXcVD0BEMirmFxglNPt5pedb1AnxuCYMChUykwsTIWqT23XDpvTiKEru1cTcEMeniB+HQDehxPXNmkotFdwUPnilB/u4Nx5Xc6l8J9jH1EgKZUUt8t8cyoZleDBEt8oibDmJRAoMKJ5Oe9CSWS5ZMEJvacsGVdXDWjp/Ype5x0p9PXB2PAwt2LRD3d+ftNgpuyvxlP8pB84oB1i73vAVpwyrmXW72hfW6Dzn9Jkj4++0VQ4d0KSx1AsDA4OtXXDo63/w+GD+zC7w5SJaxsmnlYRQ4dgdjA7tTl2KNLnpJ+mvkoDxtt1a4oPaX3EVqj96o9sRKBQqU7ZOiupeAIyLMD+Y3YwHx30XWHB5CQiw7q3mj1EDlP2eBsZbz79ayUMbyHQ7s8gu4Lgip1LiGJj7NQj905/+rgUYKAA5qdrlHKIknWmqfuR+PB8RdBkDg/NgnlT89G72h2NvySnj7UyBwD+mi/IWs1xWbxuVwUIVXun5cMqBtFbrccI+DILjsVQg6eeq0itiRfedn89CvyFtpkxaauEvSANuZmB1p8FGPbU94J9medwsZ9HkUYjmI7OH5HuxendLbxTaYrPuIfE2ffXFKhoNBUp33HsFAXmCV/Vxpq5AYgFoRr5Ay93ZLRlgaIPjhZjXZZChT+aE5iWAXMX0oSFQEtwjiuhQQItTQX5IYrKfKB+queTNplR1Hoflo5/I6aPPmACwQCE2jTOYo5Dz1cs7Sod0KTG/3kEDGk3kUaUCON19xSJCab3kNpWZhSWkO8l+SpW70Wn3g0ciOIJO5JXma6dbos6jyisuxXwUUhj2+1uGhcvuliKtWwsUTw4gi1c/diEEpZHoKoxTBeMDmhPhKTx7TXWRakV8imJR355DcIHkR9IREHxohP4TbyR5LtFU24umRPRmEYHbpe1LghyxPx7YgUHjNbbQFRQhh4KeU1EabXx8FS3JAxp2rwRDoeWkJgWRUSKw6gGP5U2PuO9V4ZuiKXGGzFQuRuf+tkSSsbBtRJKhCi3ENuLlXhPbjTKD4djXVnfXFds6Zb+1XiUrRfyayGxJq1+SYBEfbKlgjiSmk0orgTqzSS+DZ5rTqsJbttiNtp+KMqGE2AHGFw6jQqM5vD6vMptmXV9OAjq49Uf/Lx9Opam+Hn5O9p8qoBBAQixzQZ4eNVkO9sPzJAMyR1y4/RCQQ1s0pV5KAU5sKLw3tkcFbI/JqrjCsK4Mw+W8aod4lioYuawUiCyVWBE/qPaFi5bnkgpfu/ae47174rI1fqQoTbW0HrU6FAejq7ByM0V4zkZTg02/YJK2N7hUQRCeZ4BIgSEqgD8XsjzG6LIsSbuHoIdz/LhFzbNn1clci1NHWJ0/6/O8HJMdIpEZbqi1RrrFfoo/rI/7ufm2MPG5lUI0IYJ4MAiHRTSOFJ2oTverFHYXThkYFIoyFx6rMYFgaOKM4xNWdlOnIcKb/suptptgTOTdVIf4YgdaAjJnIAm4qNNHNQqqAzvi53GkyRCEoseUBrHohZsjUbkR8gfKtc/+Oa72lwxJ8Mq6HDfDATbfbJhzeIuFQJSiw1uZprHlzUf90WgqG76zO0eCB1WdPv1IT6sNxxh91GEL2YpgC97ikFHyoaH92ndwduqZ6IYjkg20DX33MWdoZk7QkcKUCgisIYslOaaLyvIIqRKWQj16jE1DlQWJJaPopWTJjXfixEjRJJo8g4++wuQjbq+WVYjsqCuNIQW3YjnxKe2M5ZKEqq+cX7ZVgnkbsU3RWIyXA1rxv4kGersYJjD//auldXGmcEbcfTeF16Y1708FB1HIfmWv6dSFi6oD4E+RIjCsEZ+kY7dKnwReJJw3xCjKvi3kGN42rvyhUlIz0Bp+fNSV5xwFiuBzG296e5s/oHoFtUyUplmPulIPl+e1CQIQVtjlzLzzzbV+D/OVQtYzo5ixtMi5BmHuG4N/uKfJk5UIREp7+12oZlKtPBomXSzAY0KgtbPzzZoHQxujnREUgBU+O/jKKhgxVhRPtbqyHiUaRwRpHv7pgRPyUrnE7fYkVblGmfTY28tFCvlILC04Tz3ivkNWVazA+OsYrxvRM/hiNn8Fc4bQBeUZABGx5S/xFf9Lbbmk298X7iFg2yeimvsQqqJ+hYbt6uq+Zf9jC+Jcwiccd61NKQtFvGWrgJiHB5lwi6fR8KzYS7EaEHf/ka9EC7H8D+WEa3TEACHBkNSj/cXxFeq4RllC+fUFm2xtstYLL2nos1DfzsC9vqDDdRVcPA3Ho95aEQHvExVThXPqym65llkKlfRXbPTRiDepdylHjmV9YTWAEjlD9DdQnCem7Aj/ml58On366392214B5zrmQz/9ySG2mFqEwjq5sFl5tYJPw5hNz8lyZPUTsr5E0F2C9VMPnZckWP7+mbwp/BiN7f4kf7vtGnZF2JGvjK/sDX1RtcFY5oPQnE4lIAYV49U3C9SP0LCY/9i/WIFK9ORjzM9kG/KGrAuwFmgdEpdLaiqQNpCTGZVuAO65afkY1h33hrqyLjZy92JK3/twdj9pafFcwfXONmPQWldPlMe7jlP24Js0v9m8bIJ9TgS2IuRvE9ZVRaCwSJYOtAfL5H/YS4FfzKWKbek+GFulheyKtDNlBtrdmr+KU+ibHTdalzFUmMfxw3f36x+3cQbJLItSilW9cuvZEMjKw987jykZRlsH/UI+HlKfo2tLwemBEeBFtmxF2xmItA/dAIfQ+rXnm88dqvXa+GapOYVt/2waFimXFx3TC2MUiOi5/Ml+3rj/YU6Ihx2hXgiDXFsUeQkRAD6wF3SCPi2flk7XwKAA4zboqynuELD312EJ88lmDEVOMa1W/K/a8tGylZRMrMoILyoMQzzbDJHNZrhH77L9qSC42HVmKiZ5S0016UTp83gOhCwz9XItK9fgXfK3F5d7nZCBUekoLxrutQaPHa16Rjsa0gTrzyjqTnmcIcrxg6X6dkKiucudc0DD5W4pJPf0vuDW8r5/uw24YfMuxFRpD2ovT2mFX79xH6Jf+MVdv2TYqR6/955QgVPe3JCD/WjAYcLA9tpXgFiEjge2J5ljeI/iUzg91KQuHkII4mmHZxC3XQORLAC6G7uFn5LOmlnXkjFdoO976moNTxElS8HdxWoPAkjjocDR136m2l+f5t6xaaNgdodOvTu0rievnhNAB79WNrVs6EsPgkgfahF9gSFzzAd+rJSraw5Mllit7vUP5YxA843lUpu6/5jAR0RvH4rRXkSg3nE+O5GFyfe+L0s5r3k05FyghSFnKo4TTgs07qj4nTLqOYj6qaW9knJTDkF5OFMYbmCP+8H16Ty482OjvERV6OFyw043L9w3hoJi408sR+SGo1WviXUu8d7qS+ehKjpKwxeCthsm2LBFSFeetx0x4AaKPxtp3CxdWqCsLrB1s/j5TAhc1jNZsXWl6tjo/WDoewxzg8T8NnhZ1niUwL/nhfygLanCnRwaFGDyLw+sfZhyZ1UtYTp8TYB6dE7R3VsKKH95CUxJ8u8N+9u2/9HUNKHW3x3w5GQrfOPafk2w5qZq8MaHT0ebeY3wIsp3rN9lrpIsW9c1ws3VNV+JwNz0Lo9+V7zZr6GD56We6gWVIvtmam5GPPkVAbr74r6SwhuL+TRXtW/0pgyX16VNl4/EAD50TnUPuwrW6OcUO2VlWXS0inq872kk7GUlW6o/ozFKq+Sip6LcTtSDfDrPTcCHhx75H8BeRon+KG2wRwzfDgWhALmiWOMO6h3pm1UCZEPEjScyk7tdLx6WrdA2N1QTPENvNnhCQjW6kl057/qv7IwRryHrZBCwVSbLLnFRiHdTwk8mlYixFt1slEcPD7FVht13HyqVeyD55HOXrh2ElAxJyinGeoFzwKA91zfrdLvDxJSjzmImfvTisreI25EDcVfGsmxLVbfU8PGe/7NmWWKjXcdTJ11jAlVIY/Bv/mcxg/Q10vCHwKG1GW/XbJq5nxDhyLqiorn7Wd7VEVL8UgVzpHMjQ+Z8DUgSukiVwWAKkeTlVVeZ7t1DGnCgJVIdBPZAEK5f8CDyDNo7tK4/5DBjdD5MPV86TaEhGsLVFPQSI68KlBYy84FievdU9gWh6XZrugvtCZmi9vfd6db6V7FmoEcRHnG36VZH8N4aZaldq9zZawt1uBFgxYYx+Gs/qW1jwANeFy+LCoymyM6zgG7j8bGzUyLhvrbJkTYAEdICEb4kMKusKT9V3eIwMLsjdUdgijMc+7iKrr+TxrVWG0U+W95SGrxnxGrE4eaJFfgvAjUM4SAy8UaRwE9j6ZQH5qYAWGtXByvDiLSDfOD0yFA3UCMKSyQ30fyy1mIRg4ZcgZHLNHWl+c9SeijOvbOJxoQy7lTN2r3Y8p6ovxvUY74aOYbuVezryqXA6U+fcp6wSV9X5/OZKP18tB56Ua0gMyxJI7XyNT7IrqN8GsB9rL/kP5KMrjXxgqKLDa+V5OCH6a5hmOWemMUsea9vQl9t5Oce76PrTyTv50ExOqngE3PHPfSL//AItPdB7kGnyTRhVUUFNdJJ2z7RtktZwgmQzhBG/G7QsjZmJfCE7k75EmdIKH7xlnmDrNM/XbTT6FzldcH/rcRGxlPrv4qDScqE7JSmQABJWqRT/TUcJSwoQM+1jvDigvrjjH8oeK2in1S+/yO1j8xAws/T5u0VnIvAPqaE1atNuN0cuRliLcH2j0nTL4JpcR7w9Qya0JoaHgsOiALLCCzRkl1UUESz+ze/gIXHGtDwgYrK6pCFKJ1webSDog4zTlPkgXZqxlQDiYMjhDpwTtBW2WxthWbov9dt2X9XFLFmcF+eEc1UaQ74gqZiZsdj63pH1qcv3Vy8JYciogIVKsJ8Yy3J9w/GhjWVSQAmrS0BPOWK+RKV+0lWqXgYMnIFwpcZVD7zPSp547i9HlflB8gVnSTGmmq1ClO081OW/UH11pEQMfkEdDFzjLC1Cdo/BdL3s7cXb8J++Hzz1rhOUVZFIPehRiZ8VYu6+7Er7j5PSZu9g/GBdmNzJmyCD9wiswj9BZw+T3iBrg81re36ihMLjoVLoWc+62a1U/7qVX5CpvTVF7rocSAKwv4cBVqZm7lLDS/qoXs4fMs/VQi6BtVbNA3uSzKpQfjH1o3x4LrvkOn40zhm6hjduDglzJUwA0POabgdXIndp9fzhOo23Pe+Rk9GSLX0d71Poqry8NQDTzNlsa+JTNG9+UrEf+ngxCjGEsDCc0bz+udVRyHQI1jmEO3S+IOQycEq7XwB6z3wfMfa73m8PVRp+iOgtZfeSBl01xn03vMaQJkyj7vnhGCklsCWVRUl4y+5oNUzQ63B2dbjDF3vikd/3RUMifPYnX5Glfuk2FsV/7RqjI9yKTbE8wJY+74p7qXO8+dIYgjtLD/N8TJtRh04N9tXJA4H59IkMmLElgvr0Q5OCeVfdAt+5hkh4pQgfRMHpL74XatLQpPiOyHRs/OdmHtBf8nOZcxVKzdGclIN16lE7kJ+pVMjspOI+5+TqLRO6m0ZpNXJoZRv9MPDRcAfJUtNZHyig/s2wwReakFgPPJwCQmu1I30/tcBbji+Na53i1W1N+BqoY7Zxo+U/M9XyJ4Ok2SSkBtoOrwuhAY3a03Eu6l8wFdIG1cN+e8hopTkiKF093KuH/BcB39rMiGDLn6XVhGKEaaT/vqb/lufuAdpGExevF1+J9itkFhCfymWr9vGb3BTK4j598zRH7+e+MU9maruZqb0pkGxRDRE1CD4Z8LV4vhgPidk5w2Bq816g3nHw1//j3JStz7NR9HIWELO8TMn3QrP/zZp//+Dv9p429/ogv+GATR+n/UdF+ns9xNkXZQJXY4t9jMkJNUFygAtzndXwjss+yWH9HAnLQQfhAskdZS2l01HLWv7L7us5uTH409pqitvfSOQg/c+Zt7k879P3K9+WV68n7+3cZfuRd/dDPP/03rn+d+/nBvWfgDlt8+LzjqJ/vx3CnNOwiXhho778C96iD+1TBvRZYeP+EH81LE0vVwOOrmCLB3iKzI1x+vJEsrPH4uF0UB4TJ4X3uDfOCo3PYpYe0MF4bouh0DQ/l43fxUF7Y+dpWuvTSffB0yO2UQUETI/LwCZE3BvnevJ7c9zUlY3H58xzke6DNFDQG8n0WtDN4LAYN4nogKav1ezOfK/z+t6tsCTp+dhx4ymjWuCJk1dEUifDP+HyS4iP/Vg9B2jTo9L4NbiBuDS4nuuHW6H+JDQn2JtqRKGkEQPEYE7uzazXIkcxIAqUq1esasZBETlEZY7y7Jo+RoV/IsjY9eIMkUvr42Hc0xqtsavZvhz1OLwSxMOTuqzlhb0WbdOwBH9EYiyBjatz40bUxTHbiWxqJ0uma19qhPruvcWJlbiSSH48OLDDpaHPszvyct41ZfTu10+vjox6kOqK6v0K/gEPphEvMl/vwSv+A4Hhm36JSP9IXTyCZDm4kKsqD5ay8b1Sad/vaiyO5N/sDfEV6Z4q95E+yfjxpqBoBETW2C7xl4pIO2bDODDFurUPwE7EWC2Uplq+AHmBHvir2PSgkR12/Ry65O0aZtQPeXi9mTlF/Wj5GQ+vFkYyhXsLTjrBSP9hwk4GPqDP5rBn5/l8b0mLRAvRSzXHc293bs3s8EsdE3m2exxidWVB4joHR+S+dz5/W+v00K3TqN14CDBth8eWcsTbiwXPsygHdGid0PEdy6HHm2v/IUuV5RVapYmzGsX90mpnIdNGcOOq64Dbc5GUbYpD9M7S+6cLY//QmjxFLP5cuTFRm3vA5rkFZroFnO3bjHF35uU3s8mvL7Tp9nyTc4mymTJ5sLIp7umSnGkO23faehtz3mmTS7fbVx5rP7x3HXIjRNeq/A3xCs9JNB08c9S9BF2O3bOur0ItslFxXgRPdaapBIi4dRpKGxVz7ir69t/bc9qTxjvtOyGOfiLGDhR4fYywHv1WdOplxIV87TpLBy3Wc0QP0P9s4G7FBNOdITS/tep3o3h1TEa5XDDii7fWtqRzUEReP2fbxz7bHWWJdbIOxOUJZtItNZpTFRfj6vm9sYjRxQVO+WTdiOhdPeTJ+8YirPvoeL88l5iLYOHd3b/Imkq+1ZN1El3UikhftuteEYxf1Wujof8Pr4ICTu5ezZyZ4tHQMxlzUHLYO2VMOoNMGL/20S5i2o2obfk+8qqdR7xzbRDbgU0lnuIgz4LelQ5XS7xbLuSQtNS95v3ZUOdaUx/Qd8qxCt6xf2E62yb/HukLO6RyorV8KgYl5YNc75y+KvefrxY+lc/64y9kvWP0a0bDz/rojq+RWjO06WeruWqNFU7r3HPIcLWRql8ICZsz2Ls/qOm/CLn6++X+Qf7mGspYCrZod/lpl6Rw4xN/yuq8gqV4B6aHk1hVE1SfILxWu5gvXqbfARYQpspcxKp1F/c8XOPzkZvmoSw+vEqBLdrq1fr3wAPv5NnM9i8F+jdAuxkP5Z71c6uhK3enlnGymr7UsWZKC12qgUiG8XXGQ9mxnqz4GSIlybF9eXmbqj2sHX+a1jf0gRoONHRdRSrIq03Ty89eQ1GbV/Bk+du4+V15zls+vvERvZ4E7ZbnxWTVjDjb4o/k8jlw44pTIrUGxxuJvBeO+heuhOjpFsO6lVJ/aXnJDa/bM0Ql1cLbXE/Pbv3EZ3vj3iVrB5irjupZTzlnv677NrI9UNYNqbPgp/HZXS+lJmk87wec+7YOxTDo2aw2l3NfDr34VNlvqWJBknuK7oSlZ6/T10zuOoPZOeoIk81N+sL843WJ2Q4Z0fZ3scsqC/JV2fuhWi1jGURSKZV637lf53Xnnx16/vKEXY89aVJ0fv91jGdfG+G4+sniwHes4hS+udOr4RfhFhG/F5gUG35QaU+McuLmclb5ZWmR+sG5V6nf+PxYzlrnFGxpZaK8eqqVo0NfmAWoGfXDiT/FnUbWvzGDOTr8aktOZWg4BYvz5YH12ZbfCcGtNk+dDAZNGWvHov+PIOnY9Prjg8h/wLRrT69suaMVZ5bNuK00lSVpnqSX1NON/81FoP92rYndionwgOiA8WMf4vc8l15KqEEG4yAm2+WAN5Brfu1sq9suWYqgoajgOYt/JCk1gC8wPkK+XKCtRX6TAtgvrnuBgNRmn6I8lVDipOVB9kX6Oxkp4ZKyd1M6Gj8/v2U7k+YQBL95Kb9PQENucJb0JlW3b5tObN7m/Z1j1ev388d7o15zgXsI9CikAGAViR6lkJv7nb4Ak40M2G8TJ447kN+pvfHiOFjSUSP6PM+QfbAywKJCBaxSVxpizHseZUyUBhq59vFwrkyGoRiHbo0apweEZeSLuNiQ+HAekOnarFg00dZNXaPeoHPTRR0FmEyqYExOVaaaO8c0uFUh7U4e/UxdBmthlBDgg257Q33j1hA7HTxSeTTSuVnPZbgW1nodwmG16aKBDKxEetv7D9OjO0JhrbJTnoe+kcGoDJazFSO8/fUN9Jy/g4XK5PUkw2dgPDGpJqBfhe7GA+cjzfE/EGsMM+FV9nj9IAhrSfT/J3QE5TEIYyk5UjsI6ZZcCPr6A8FZUF4g9nnpVmjX90MLSQysIPD0nFzqwCcSJmIb5mYv2Cmk+C1MDFkZQyCBq4c/Yai9LJ6xYkGS/x2s5/frIW2vmG2Wrv0APpCdgCA9snFvfpe8uc0OwdRs4G9973PGEBnQB5qKrCQ6m6X/H7NInZ7y/1674/ZXOVp7OeuCRk8JFS516VHrnH1HkIUIlTIljjHaQtEtkJtosYul77cVwjk3gW1Ajaa6zWeyHGLlpk3VHE2VFzT2yI/EvlGUSz2H9zYE1s4nsKMtMqNyKNtL/59CpFJki5Fou6VXGm8vWATEPwrUVOLvoA8jLuwOzVBCgHB2Cr5V6OwEWtJEKokJkfc87h+sNHTvMb0KVTp5284QTPupoWvQVUwUeogZR3kBMESYo0mfukewRVPKh5+rzLQb7HKjFFIgWhj1w3yN/qCNoPI8XFiUgBNT1hCHBsAz8L7Oyt8wQWUFj92ONn/APyJFg8hzueqoJdNj57ROrFbffuS/XxrSXLTRgj5uxZjpgQYceeMc2wJrahReSKpm3QjHfqExTLAB2ipVumE8pqcZv8LYXQiPHHsgb5BMW8zM5pvQit+mQx8XGaVDcfVbLyMTlY8xcfmm/RSAT/H09UQol5gIz7rESDmnrQ4bURIB4iRXMDQwxgex1GgtDxKp2HayIkR+E/aDmCttNm2C6lytWdfOVzD6X2SpDWjQDlMRvAp1symWv4my1bPCD+E1EmGnMGWhNwmycJnDV2WrQNxO45ukEb08AAffizYKVULp15I4vbNK5DzWwCSUADfmKhfGSUqii1L2UsE8rB7mLuHuUJZOx4+WiizHBJ/hwboaBzhpNOVvgFTf5cJsHef7L1HCI9dOUUbb+YxUJWn6dYOLz+THi91kzY5dtO5c+grX7v0jEbsuoOGnoIreDIg/sFMyG+TyCLIcAWd1IZ1UNFxE8Uie13ucm40U2fcxC0u3WLvLOxwu+F7MWUsHsdtFQZ7W+nlfCASiAKyh8rnP3EyDByvtJb6Kax6/HkLzT9SyEyTMVM1zPtM0MJY14DmsWh4MgD15Ea9Hd00AdkTZ0EiG5NAGuIBzQJJ0JR0na+OB7lQA6UKxMfihIQ7GCCnVz694QvykWXTxpS2soDu+smru1UdIxSvAszBFD1c8c6ZOobA8bJiJIvuycgIXBQIXWwhyTgZDQxJTRXgEwRNAawGSXO0a1DKjdihLVNp/taE/xYhsgwe+VpKEEB4LlraQyE84gEihxCnbfoyOuJIEXy2FIYw+JjRusybKlU2g/vhTSGTydvCvXhYBdtAXtS2v7LkHtmXh/8fly1do8FI/D0f8UbzVb5h+KRhMGSAmR2mhi0YG/uj7wgxcfzCrMvdjitUIpXDX8ae2JcF/36qUWIMwN6JsjaRGNj+jEteGDcFyTUb8X/NHSucKMJp7pduxtD6KuxVlyxxwaeiC1FbGBESO84lbyrAugYxdl+2N8/6AgWpo/IeoAOcsG35IA/b3AuSyoa55L7llBLlaWlEWvuCFd8f8NfcTUgzJv6CbB+6ohWwodlk9nGWFpBAOaz5uEW5xBvmjnHFeDsb0mXwayj3mdYq5gxxNf3H3/tnCgHwjSrpSgVxLmiTtuszdRUFIsn6LiMPjL808vL1uQhDbM7aA43mISXReqjSskynIRcHCJ9qeFopJfx9tqyUoGbSwJex/0aDE3plBPGtNBYgWbdLom3+Q/bjdizR2/AS/c/dH/d3G7pyl1qDXgtOFtEqidwLqxPYtrNEveasWq3vPUUtqTeu8gpov4bdOQRI2kneFvRNMrShyVeEupK1PoLDPMSfWMIJcs267mGB8X9CehQCF0gIyhpP10mbyM7lwW1e6TGvHBV1sg/UyTghHPGRqMyaebC6pbB1WKNCQtlai1GGvmq9zUKaUzLaXsXEBYtHxmFbEZ2kJhR164LhWW2Tlp1dhsGE7ZgIWRBOx3Zcu2DxgH+G83WTPceKG0TgQKKiiNNOlWgvqNEbnrk6fVD+AqRam2OguZb0YWSTX88N+i/ELSxbaUUpPx4vJUzYg/WonSeA8xUK6u7DPHgpqWpEe6D4cXg5uK9FIYVba47V/nb+wyOtk+zG8RrS4EA0ouwa04iByRLSvoJA2FzaobbZtXnq8GdbfqEp5I2dpfpj59TCVif6+E75p665faiX8gS213RqBxTZqfHP46nF6NSenOneuT+vgbLUbdTH2/t0REFXZJOEB6DHvx6N6g9956CYrY/AYcm9gELJXYkrSi+0F0geKDZgOCIYkLU/+GOW5aGj8mvLFgtFH5+XC8hvAE3CvHRfl4ofM/Qwk4x2A+R+nyc9gNu/9Tem7XW4XRnyRymf52z09cTOdr+PG6+P/Vb4QiXlwauc5WB1z3o+IJjlbxI8MyWtSzT+k4sKVbhF3xa+vDts3NxXa87iiu+xRH9cAprnOL2h6vV54iQRXuOAj1s8nLFK8gZ70ThIQcWdF19/2xaJmT0efrkNDkWbpAQPdo92Z8+Hn/aLjbOzB9AI/k12fPs9HhUNDJ1u6ax2VxD3R6PywN7BrLJ26z6s3QoMp76qzzwetrDABKSGkfW5PwS1GvYNUbK6uRqxfyVGNyFB0E+OugMM8kKwmJmupuRWO8XkXXXQECyRVw9UyIrtCtcc4oNqXqr7AURBmKn6Khz3eBN96LwIJrAGP9mr/59uTOSx631suyT+QujDd4beUFpZ0kJEEnjlP+X/Kr2kCKhnENTg4BsMTOmMqlj2WMFLRUlVG0fzdCBgUta9odrJfpVdFomTi6ak0tFjXTcdqqvWBAzjY6hVrH9sbt3Z9gn+AVDpTcQImefbB4edirjzrsNievve4ZT4EUZWV3TxEsIW+9MT/RJoKfZZYSRGfC1CwPG/9rdMOM8qR/LUYvw5f/emUSoD7YSFuOoqchdUg2UePd1eCtFSKgxLSZ764oy4lvRCIH6bowPxZWwxNFctksLeil47pfevcBipkkBIc4ngZG+kxGZ71a72KQ7VaZ6MZOZkQJZXM6kb/Ac0/XkJx8dvyfJcWbI3zONEaEPIW8GbkYjsZcwy+eMoKrYjDmvEEixHzkCSCRPRzhOfJZuLdcbx19EL23MA8rnjTZZ787FGMnkqnpuzB5/90w1gtUSRaWcb0eta8198VEeZMUSfIhyuc4/nywFQ9uqn7jdqXh+5wwv+RK9XouNPbYdoEelNGo34KyySwigsrfCe0v/PlWPvQvQg8R0KgHO18mTVThhQrlbEQ0Kp/JxPdjHyR7E1QPw/ut0r+HDDG7BwZFm9IqEUZRpv2WpzlMkOemeLcAt5CsrzskLGaVOAxyySzZV/D2EY7ydNZMf8e8VhHcKGHAWNszf1EOq8fNstijMY4JXyATwTdncFFqcNDfDo+mWFvxJJpc4sEZtjXyBdoFcxbUmniCoKq5jydUHNjYJxMqN1KzYV62MugcELVhS3Bnd+TLLOh7dws/zSXWzxEb4Nj4aFun5x4kDWLK5TUF/yCXB/cZYvI9kPgVsG2jShtXkxfgT+xzjJofXqPEnIXIQ1lnIdmVzBOM90EXvJUW6a0nZ/7XjJGl8ToO3H/fdxnxmTNKBZxnkpXLVgLXCZywGT3YyS75w/PAH5I/jMuRspej8xZObU9kREbRA+kqjmKRFaKGWAmFQspC+QLbKPf0RaK3OXvBSWqo46p70ws/eZpu6jCtZUgQy6r4tHMPUdAgWGGUYNbuv/1a6K+MVFsd3T183+T8capSo6m0+Sh57fEeG/95dykGJBQMj09DSW2bY0mUonDy9a8trLnnL5B5LW3Nl8rJZNysO8Zb+80zXxqUGFpud3Qzwb7bf+8mq6x0TAnJU9pDQR9YQmZhlna2xuxJt0aCO/f1SU8gblOrbIyMsxTlVUW69VJPzYU2HlRXcqE2lLLxnObZuz2tT9CivfTAUYfmzJlt/lOPgsR6VN64/xQd4Jlk/RV7UKVv2Gx/AWsmTAuCWKhdwC+4HmKEKYZh2Xis4KsUR1BeObs1c13wqFRnocdmuheaTV30gvVXZcouzHKK5zwrN52jXJEuX6dGx3BCpV/++4f3hyaW/cQJLFKqasjsMuO3B3WlMq2gyYfdK1e7L2pO/tRye2mwzwZPfdUMrl5wdLqdd2Kv/wVtnpyWYhd49L6rsOV+8HXPrWH2Kup89l2tz6bf80iYSd+V4LROSOHeamvexR524q4r43rTmtFzQvArpvWfLYFZrbFspBsXNUqqenjxNNsFXatZvlIhk7teUPfK+YL32F8McTnjv0BZNppb+vshoCrtLXjIWq3EJXpVXIlG6ZNL0dh6qEm2WMwDjD3LfOfkGh1/czYc/0qhiD2ozNnH4882MVVt3JbVFkbwowNCO3KL5IoYW5wlVeGCViOuv1svZx7FbzxKzA4zGqBlRRaRWCobXaVq4yYCWbZf8eiJwt3OY+MFiSJengcFP2t0JMfzOiJ7cECvpx7neg1Rc5x+7myPJOXt2FohVRyXtD+/rDoTOyGYInJelZMjolecVHUhUNqvdZWg2J2t0jPmiLFeRD/8fOT4o+NGILb+TufCo9ceBBm3JLVn+MO2675n7qiEX/6W+188cYg3Zn5NSTjgOKfWFSAANa6raCxSoVU851oJLY11WIoYK0du0ec5E4tCnAPoKh71riTsjVIp3gKvBbEYQiNYrmH22oLQWA2AdwMnID6PX9b58dR2QKo4qag1D1Z+L/FwEKTR7osOZPWECPJIHQqPUsM5i/CH5YupVPfFA5pHUBcsesh8eO5YhyWnaVRPZn/BmdXVumZWPxMP5e28zm2uqHgFoT9CymHYNNrzrrjlXZM06HnzDxYNlI5b/QosxLmmrqDFqmogQdqk0WLkUceoAvQxHgkIyvWU69BPFr24VB6+lx75Rna6dGtrmOxDnvBojvi1/4dHjVeg8owofPe1cOnxU1ioh016s/Vudv9mhV9f35At+Sh28h1bpp8xhr09+vf47Elx3Ms6hyp6QvB3t0vnLbOhwo660cp7K0vvepabK7YJfxEWWfrC2YzJfYOjygPwfwd/1amTqa0hZ5ueebhWYVMubRTwIjj+0Oq0ohU3zfRfuL8gt59XsHdwKtxTQQ4Y2qz6gisxnm2UdlmpEkgOsZz7iEk6QOt8BuPwr+NR01LTqXmJo1C76o1N274twJvl+I069TiLpenK/miRxhyY8jvYV6W1WuSwhH9q7kuwnJMtm7IWcqs7HsnyHSqWXLSpYtZGaR1V3t0gauninFPZGtWskF65rtti48UV9uV9KM8kfDYs0pgB00S+TlzTXV6P8mxq15b9En8sz3jWSszcifZa/NuufPNnNTb031pptt0+sRSH/7UG8pzbsgtt3OG3ut7B9JzDMt2mTZuyRNIV8D54TuTrpNcHtgmMlYJeiY9XS83NYJicjRjtJSf9BZLsQv629QdDsKQhTK5CnXhpk7vMNkHzPhm0ExW/VCGApHfPyBagtZQTQmPHx7g5IXXsrQDPzIVhv2LB6Ih138iSDww1JNHrDvzUxvp73MsQBVhW8EbrReaVUcLB1R3PUXyaYG4HpJUcLVxMgDxcPkVRQpL7VTAGabDzbKcvg12t5P8TSGQkrj/gOrpnbiDHwluA73xbXts/L7u468cRWSWRtgTwlQnA47EKg0OiZDgFxAKQQUcsbGomITgeXUAAyKe03eA7Mp4gnyKQmm0LXJtEk6ddksMJCuxDmmHzmVhO+XaN2A54MIh3niw5CF7PwiXFZrnA8wOdeHLvvhdoqIDG9PDI7UnWWHq526T8y6ixJPhkuVKZnoUruOpUgOOp3iIKBjk+yi1vHo5cItHXb1PIKzGaZlRS0g5d3MV2pD8FQdGYLZ73aae/eEIUePMc4NFz8pIUfLCrrF4jVWH5gQneN3S8vANBmUXrEcKGn6hIUN95y1vpsvLwbGpzV9L0ZKTan6TDXM05236uLJcIEMKVAxKNT0K8WljuwNny3BNQRfzovA85beI9zr1AGNYnYCVkR1aGngWURUrgqR+gRrQhxW81l3CHevjvGEPzPMTxdsIfB9dfGRbZU0cg/1mcubtECX4tvaedmNAvTxCJtc2QaoUalGfENCGK7IS/O8CRpdOVca8EWCRwv2sSWE8CJPW5PCugjCXPd3h6U60cPD+bdhtXZuYB6stcoveE7Sm5MM2yvfUHXFSW7KzLmi7/EeEWL0wqcOH9MOSKjhCHHmw+JGLcYE/7SBZQCRggox0ZZTAxrlzNNXYXL5fNIjkdT4YMqVUz6p8YDt049v4OXGdg3qTrtLBUXOZf7ahPlZAY/O+7Sp0bvGSHdyQ8B1LOsplqMb9Se8VAE7gIdSZvxbRSrfl+Lk5Qaqi5QJceqjitdErcHXg/3MryljPSIAMaaloFm1cVwBJ8DNmkDqoGROSHFetrgjQ5CahuKkdH5pRPigMrgTtlFI8ufJPJSUlGgTjbBSvpRc0zypiUn6U5KZqcRoyrtzhmJ7/caeZkmVRwJQeLOG8LY6vP5ChpKhc8Js0El+n6FXqbx9ItdtLtYP92kKfaTLtCi8StLZdENJa9Ex1nOoz1kQ7qxoiZFKRyLf4O4CHRT0T/0W9F8epNKVoeyxUXhy3sQMMsJjQJEyMOjmOhMFgOmmlscV4eFi1CldU92yjwleirEKPW3bPAuEhRZV7JsKV3Lr5cETAiFuX5Nw5UlF7d2HZ96Bh0sgFIL5KGaKSoVYVlvdKpZJVP5+NZ7xDEkQhmDgsDKciazJCXJ6ZN2B3FY2f6VZyGl/t4aunGIAk/BHaS+i+SpdRfnB/OktOvyjinWNfM9Ksr6WwtCa1hCmeRI6icpFM4o8quCLsikU0tMoZI/9EqXRMpKGaWzofl4nQuVQm17d5fU5qXCQeCDqVaL9XJ9qJ08n3G3EFZS28SHEb3cdRBdtO0YcTzil3QknNKEe/smQ1fTb0XbpyNB5xAeuIlf+5KWlEY0DqJbsnzJlQxJPOVyHiKMx5Xu9FcEv1Fbg6Fhm4t+Jyy5JC1W3YO8dYLsO0PXPbxodBgttTbH3rt9Cp1lJIk2r3O1Zqu94eRbnIz2f50lWolYzuKsj4PMok4abHLO8NAC884hiXx5Fy5pWKO0bWL7uEGXaJCtznhP67SlQ4xjWIfgq6EpZ28QMtuZK7JC0RGbl9nA4XtFLug/NLMoH1pGt9IonAJqcEDLyH6TDROcbsmGPaGIxMo41IUAnQVPMPGByp4mOmh9ZQMkBAcksUK55LsZj7E5z5XuZoyWCKu6nHmDq22xI/9Z8YdxJy4kWpD16jLVrpwGLWfyOD0Wd+cBzFBxVaGv7S5k9qwh/5t/LQEXsRqI3Q9Rm3QIoaZW9GlsDaKOUyykyWuhNOprSEi0s1G4rgoiX1V743EELti+pJu5og6X0g6oTynUqlhH9k6ezyRi05NGZHz0nvp3HOJr7ebrAUFrDjbkFBObEvdQWkkUbL0pEvMU46X58vF9j9F3j6kpyetNUBItrEubW9ZvMPM4qNqLlsSBJqOH3XbNwv/cXDXNxN8iFLzUhteisYY+RlHYOuP29/Cb+L+xv+35Rv7xudnZ6ohK4cMPfCG8KI7dNmjNk/H4e84pOxn/sZHK9psfvj8ncA8qJz7O8xqbxESDivGJOZzF7o5PJLQ7g34qAWoyuA+x3btU98LT6ZyGyceIXjrqob2CAVql4VOTQPUQYvHV/g4zAuCZGvYQBtf0wmd5lilrvuEn1BXLny01B4h4SMDlYsnNpm9d7m9h578ufpef9Z4WplqWQvqo52fyUA7J24eZD5av6SyGIV9kpmHNqyvdfzcpEMw97BvknV2fq+MFHun9BT3Lsf8pbzvisWiIQvYkng+8Vxk1V+dli1u56kY50LRjaPdotvT5BwqtwyF+emo/z9J3yVUVGfKrxQtJMOAQWoQii/4dp9wgybSa5mkucmRLtEQZ/pz0tL/NVcgWAd95nEQ3Tg6tNbuyn3Iepz65L3huMUUBntllWuu4DbtOFSMSbpILV4fy6wlM0SOvi6CpLh81c1LreIvKd61uEWBcDw1lUBUW1I0Z+m/PaRlX+PQ/oxg0Ye6KUiIiTF4ADNk59Ydpt5/rkxmq9tV5Kcp/eQLUVVmBzQNVuytQCP6Ezd0G8eLxWyHpmZWJ3bAzkWTtg4lZlw42SQezEmiUPaJUuR/qklVA/87S4ArFCpALdY3QRdUw3G3XbWUp6aq9z0zUizcPa7351p9JXOZyfdZBFnqt90VzQndXB/mwf8LC9STj5kenVpNuqOQQP3mIRJj7eV21FxG8VAxKrEn3c+XfmZ800EPb9/5lIlijscUbB6da0RQaMook0zug1G0tKi/JBC4rw7/D3m4ARzAkzMcVrDcT2SyFtUdWAsFlsPDFqV3N+EjyXaoEePwroaZCiLqEzb8MW+PNE9TmTC01EzWli51PzZvUqkmyuROU+V6ik+Le/9qT6nwzUzf9tP68tYei0YaDGx6kAd7jn1cKqOCuYbiELH9zYqcc4MnRJjkeGiqaGwLImhyeKs+xKJMBlOJ05ow9gGCKZ1VpnMKoSCTbMS+X+23y042zOb5MtcY/6oBeAo1Vy89OTyhpavFP78jXCcFH0t7Gx24hMEOm2gsEfGabVpQgvFqbQKMsknFRRmuPHcZu0Su/WMFphZvB2r/EGbG72rpGGho3h+Msz0uGzJ7hNK2uqQiE1qmn0zgacKYYZBCqsxV+sjbpoVdSilW/b94n2xNb648VmNIoizqEWhBnsen+d0kbCPmRItfWqSBeOd9Wne3c6bcd6uvXOJ6WdiSsuXq0ndhqrQ4QoWUjCjYtZ0EAhnSOP1m44xkf0O7jXghrzSJWxP4a/t72jU29Vu2rvu4n7HfHkkmQOMGSS+NPeLGO5I73mC2B7+lMiBQQZRM9/9liLIfowupUFAbPBbR+lxDM6M8Ptgh1paJq5Rvs7yEuLQv/7d1oU2woFSb3FMPWQOKMuCuJ7pDDjpIclus5TeEoMBy2YdVB4fxmesaCeMNsEgTHKS5WDSGyNUOoEpcC2OFWtIRf0w27ck34/DjxRTVIcc9+kqZE6iMSiVDsiKdP/Xz5XfEhm/sBhO50p1rvJDlkyyxuJ9SPgs7YeUJBjXdeAkE+P9OQJm6SZnn1svcduI78dYmbkE2mtziPrcjVisXG78spLvbZaSFx/Rks9zP4LKn0Cdz/3JsetkT06A8f/yCgMO6Mb1Hme0JJ7b2wZz1qleqTuKBGokhPVUZ0dVu+tnQYNEY1fmkZSz6+EGZ5EzL7657mreZGR3jUfaEk458PDniBzsSmBKhDRzfXameryJv9/D5m6HIqZ0R+ouCE54Dzp4IJuuD1e4Dc5i+PpSORJfG23uVgqixAMDvchMR0nZdH5brclYwRoJRWv/rlxGRI5ffD5NPGmIDt7vDE1434pYdVZIFh89Bs94HGGJbTwrN8T6lh1HZFTOB4lWzWj6EVqxSMvC0/ljWBQ3F2kc/mO2b6tWonT2JEqEwFts8rz2h+oWNds9ceR2cb7zZvJTDppHaEhK5avWqsseWa2Dt5BBhabdWSktS80oMQrL4TvAM9b5HMmyDnO+OkkbMXfUJG7eXqTIG6lqSOEbqVR+qYdP7uWb57WEJqzyh411GAVsDinPs7KvUeXItlcMdOUWzXBH6zscymV1LLVCtc8IePojzXHF9m5b5zGwBRdzcyUJkiu938ApmAayRdJrX1PmVguWUvt2ThQ62czItTyWJMW2An/hdDfMK7SiFQlGIdAbltHz3ycoh7j9V7GxNWBpbtcSdqm4XxRwTawc3cbZ+xfSv9qQfEkDKfZTwCkqWGI/ur250ItXlMlh6vUNWEYIg9A3GzbgmbqvTN8js2YMo87CU5y6nZ4dbJLDQJj9fc7yM7tZzJDZFtqOcU8+mZjYlq4VmifI23iHb1ZoT9E+kT2dolnP1AfiOkt7PQCSykBiXy5mv637IegWSKj9IKrYZf4Lu9+I7ub+mkRdlvYzehh/jaJ9n7HUH5b2IbgeNdkY7wx1yVzxS7pbvky6+nmVUtRllEFfweUQ0/nG017WoUYSxs+j2B4FV/F62EtHlMWZXYrjGHpthnNb1x66LKZ0Qe92INWHdfR/vqp02wMS8r1G4dJqHok8KmQ7947G13a4YXbsGgHcBvRuVu1eAi4/A5+ZixmdSXM73LupB/LH7O9yxLTVXJTyBbI1S49TIROrfVCOb/czZ9pM4JsZx8kUz8dQGv7gUWKxXvTH7QM/3J2OuXXgciUhqY+cgtaOliQQVOYthBLV3xpESZT3rmfEYNZxmpBbb24CRao86prn+i9TNOh8VxRJGXJfXHATJHs1T5txgc/opYrY8XjlGQQbRcoxIBcnVsMjmU1ymmIUL4dviJXndMAJ0Yet+c7O52/p98ytlmAsGBaTAmMhimAnvp1TWNGM9BpuitGj+t810CU2UhorrjPKGtThVC8WaXw04WFnT5fTjqmPyrQ0tN3CkLsctVy2xr0ZWgiWVZ1OrlFjjxJYsOiZv2cAoOvE+7sY0I/TwWcZqMoyIKNOftwP7w++Rfg67ljfovKYa50if3fzE/8aPYVey/Nq35+nH2sLPh/fP5TsylSKGOZ4k69d2PnH43+kq++sRXHQqGArWdwhx+hpwQC6JgT2uxehYU4Zbw7oNb6/HLikPyJROGK2ouyr+vzseESp9G50T4AyFrSqOQ0rroCYP4sMDFBrHn342EyZTMlSyk47rHSq89Y9/nI3zG5lX16Z5lxphguLOcZUndL8wNcrkyjH82jqg8Bo8OYkynrxZvbFno5lUS3OPr8Ko3mX9NoRPdYOKKjD07bvgFgpZ/RF+YzkWvJ/Hs/tUbfeGzGWLxNAjfDzHHMVSDwB5SabQLsIZHiBp43FjGkaienYoDd18hu2BGwOK7U3o70K/WY/kuuKdmdrykIBUdG2mvE91L1JtTbh20mOLbk1vCAamu7utlXeGU2ooVikbU/actcgmsC1FKk2qmj3GWeIWbj4tGIxE7BLcBWUvvcnd/lYxsMV4F917fWeFB/XbINN3qGvIyTpCalz1lVewdIGqeAS/gB8Mi+sA+BqDiX3VGD2eUunTRbSY+AuDy4E3Qx3hAhwnSXX+B0zuj3eQ1miS8Vux2z/l6/BkWtjKGU72aJkOCWhGcSf3+kFkkB15vGOsQrSdFr6qTj0gBYiOlnBO41170gOWHSUoBVRU2JjwppYdhIFDfu7tIRHccSNM5KZOFDPz0TGMAjzzEpeLwTWp+kn201kU6NjbiMQJx83+LX1e1tZ10kuChJZ/XBUQ1dwaBHjTDJDqOympEk8X2M3VtVw21JksChA8w1tTefO3RJ1FMbqZ01bHHkudDB/OhLfe7P5GOHaI28ZXKTMuqo0hLWQ4HabBsGG7NbP1RiXtETz074er6w/OerJWEqjmkq2y51q1BVI+JUudnVa3ogBpzdhFE7fC7kybrAt2Z6RqDjATAUEYeYK45WMupBKQRtQlU+uNsjnzj6ZmGrezA+ASrWxQ6LMkHRXqXwNq7ftv28dUx/ZSJciDXP2SWJsWaN0FjPX9Yko6LobZ7aYW/IdUktI9apTLyHS8DyWPyuoZyxN1TK/vtfxk3HwWh6JczZC8Ftn0bIJay2g+n5wd7lm9rEsKO+svqVmi+c1j88hSCxbzrg4+HEP0Nt1/B6YW1XVm09T1CpAKjc9n18hjqsaFGdfyva1ZG0Xu3ip6N6JGpyTSqY5h4BOlpLPaOnyw45PdXTN+DtAKg7DLrLFTnWusoSBHk3s0d7YouJHq85/R09Tfc37ENXZF48eAYLnq9GLioNcwDZrC6FW6godB8JnqYUPvn0pWLfQz0lM0Yy8Mybgn84Ds3Q9bDP10bLyOV+qzxa4Rd9Dhu7cju8mMaONXK3UqmBQ9qIg7etIwEqM/kECk/Dzja4Bs1xR+Q/tCbc8IKrSGsTdJJ0vge7IG20W687uVmK6icWQ6cD3lwFzgNMGtFvO5qyJeKflGLAAcQZOrkxVwy3cWvqlGpvjmf9Qe6Ap20MPbV92DPV0OhFM4kz8Yr0ffC2zLWSQ1kqY6QdQrttR3kh1YLtQd1kCEv5hVoPIRWl5ERcUTttBIrWp6Xs5Ehh5OUUwI5aEBvuiDmUoENmnVw1FohCrbRp1A1E+XSlWVOTi7ADW+5Ohb9z1vK4qx5R5lPdGCPBJZ00mC+Ssp8VUbgpGAvXWMuWQQRbCqI6Rr2jtxZxtfP7W/8onz+yz0Gs76LaT5HX9ecyiZCB/ZR/gFtMxPsDwohoeCRtiuLxE1GM1vUEUgBv86+eehL58/P56QFGQ/MqOe/vC76L63jzmeax4exd/OKTUvkXg+fOJUHych9xt/9goJMrapSgvXrj8+8vk/N80f22Sewj6cyGqt1B6mztoeklVHHraouhvHJaG/OuBz6DHKMpFmQULU1bRWlyYE0RPXYYkUycIemN7TLtgNCJX6BqdyxDKkegO7nJK5xQ7OVYDZTMf9bVHidtk6DQX9Et+V9M7esgbsYBdEeUpsB0Xvw2kd9+rI7V+m47u+O/tq7mw7262HU1WlS9uFzsV6JxIHNmUCy0QS9e077JGRFbG65z3/dOKB/Zk+yDdKpUmdXjn/aS3N5nv4fK7bMHHmPlHd4E2+iTbV5rpzScRnxk6KARuDTJ8Q1LpK2mP8gj1EbuJ9RIyY+EWK4hCiIDBAS1Tm2IEXAFfgKPgdL9O6mAa06wjCcUAL6EsxPQWO9VNegBPm/0GgkZbDxCynxujX/92vmGcjZRMAY45puak2sFLCLSwXpEsyy5fnF0jGJBhm+fNSHKKUUfy+276A7/feLOFxxUuHRNJI2Osenxyvf8DAGObT60pfTTlhEg9u/KKkhJqm5U1/+BEcSkpFDA5XeCqxwXmPac1jcuZ3JWQ+p0NdWzb/5v1ZvF8GtMTFFEdQjpLO0bwPb0BHNWnip3liDXI2fXf05jjvfJ0NpjLCUgfTh9CMFYVFKEd4Z/OG/2C+N435mnK+9t1gvCiVcaaH7rK4+PjCvpVNiz+t2QyqH1O8x3JKZVl6Q+Lp/XK8wMjVMslOq9FdSw5FtUs/CptXH9PW+wbWHgrV17R5jTVOtGtKFu3nb80T+E0tv9QkzW3J2dbaw/8ddAKZ0pxIaEqLjlPrji3VgJ3GvdFvlqD8075woxh4fVt0JZE0KVFsAvqhe0dqN9b35jtSpnYMXkU+vZq+IAHad3IHc2s/LYrnD1anfG46IFiMIr9oNbZDWvwthqYNqOigaKd/XlLU4XHfk/PXIjPsLy/9/kAtQ+/wKH+hI/IROWj5FPvTZAT9f7j4ZXQyG4M0TujMAFXYkKvEHv1xhySekgXGGqNxWeWKlf8dDAlLuB1cb/qOD+rk7cmwt+1yKpk9cudqBanTi6zTbXRtV8qylNtjyOVKy1HTz0GW9rjt6sSjAZcT5R+KdtyYb0zyqG9pSLuCw5WBwAn7fjBjKLLoxLXMI+52L9cLwIR2B6OllJZLHJ8vDxmWdtF+QJnmt1rsHPIWY20lftk8fYePkAIg6Hgn532QoIpegMxiWgAOfe5/U44APR8Ac0NeZrVh3gEhs12W+tVSiWiUQekf/YBECUy5fdYbA08dd7VzPAP9aiVcIB9k6tY7WdJ1wNV+bHeydNtmC6G5ICtFC1ZwmJU/j8hf0I8TRVKSiz5oYIa93EpUI78X8GYIAZabx47/n8LDAAJ0nNtP1rpROprqKMBRecShca6qXuTSI3jZBLOB3Vp381B5rCGhjSvh/NSVkYp2qIdP/Bg=";
  }
});

// ../node_modules/brotli/dec/dictionary-browser.js
var require_dictionary_browser = __commonJS({
  "../node_modules/brotli/dec/dictionary-browser.js"(exports) {
    var base64 = require_base64_js();
    exports.init = function() {
      var BrotliDecompressBuffer = require_decode().BrotliDecompressBuffer;
      var compressed = base64.toByteArray(require_dictionary_bin());
      return BrotliDecompressBuffer(compressed);
    };
  }
});

// ../node_modules/brotli/dec/dictionary.js
var require_dictionary = __commonJS({
  "../node_modules/brotli/dec/dictionary.js"(exports) {
    var data2 = require_dictionary_browser();
    exports.init = function() {
      exports.dictionary = data2.init();
    };
    exports.offsetsByLength = new Uint32Array([
      0,
      0,
      0,
      0,
      0,
      4096,
      9216,
      21504,
      35840,
      44032,
      53248,
      63488,
      74752,
      87040,
      93696,
      100864,
      104704,
      106752,
      108928,
      113536,
      115968,
      118528,
      119872,
      121280,
      122016
    ]);
    exports.sizeBitsByLength = new Uint8Array([
      0,
      0,
      0,
      0,
      10,
      10,
      11,
      11,
      10,
      10,
      10,
      10,
      10,
      9,
      9,
      8,
      7,
      7,
      8,
      7,
      7,
      6,
      6,
      5,
      5
    ]);
    exports.minDictionaryWordLength = 4;
    exports.maxDictionaryWordLength = 24;
  }
});

// ../node_modules/brotli/dec/huffman.js
var require_huffman = __commonJS({
  "../node_modules/brotli/dec/huffman.js"(exports) {
    function HuffmanCode(bits, value2) {
      this.bits = bits;
      this.value = value2;
    }
    exports.HuffmanCode = HuffmanCode;
    var MAX_LENGTH = 15;
    function GetNextKey(key, len) {
      var step = 1 << len - 1;
      while (key & step) {
        step >>= 1;
      }
      return (key & step - 1) + step;
    }
    function ReplicateValue(table, i, step, end3, code3) {
      do {
        end3 -= step;
        table[i + end3] = new HuffmanCode(code3.bits, code3.value);
      } while (end3 > 0);
    }
    function NextTableBitSize(count, len, root_bits) {
      var left = 1 << len - root_bits;
      while (len < MAX_LENGTH) {
        left -= count[len];
        if (left <= 0)
          break;
        ++len;
        left <<= 1;
      }
      return len - root_bits;
    }
    exports.BrotliBuildHuffmanTable = function(root_table, table, root_bits, code_lengths, code_lengths_size) {
      var start_table = table;
      var code3;
      var len;
      var symbol;
      var key;
      var step;
      var low;
      var mask;
      var table_bits;
      var table_size;
      var total_size;
      var sorted;
      var count = new Int32Array(MAX_LENGTH + 1);
      var offset3 = new Int32Array(MAX_LENGTH + 1);
      sorted = new Int32Array(code_lengths_size);
      for (symbol = 0; symbol < code_lengths_size; symbol++) {
        count[code_lengths[symbol]]++;
      }
      offset3[1] = 0;
      for (len = 1; len < MAX_LENGTH; len++) {
        offset3[len + 1] = offset3[len] + count[len];
      }
      for (symbol = 0; symbol < code_lengths_size; symbol++) {
        if (code_lengths[symbol] !== 0) {
          sorted[offset3[code_lengths[symbol]]++] = symbol;
        }
      }
      table_bits = root_bits;
      table_size = 1 << table_bits;
      total_size = table_size;
      if (offset3[MAX_LENGTH] === 1) {
        for (key = 0; key < total_size; ++key) {
          root_table[table + key] = new HuffmanCode(0, sorted[0] & 65535);
        }
        return total_size;
      }
      key = 0;
      symbol = 0;
      for (len = 1, step = 2; len <= root_bits; ++len, step <<= 1) {
        for (; count[len] > 0; --count[len]) {
          code3 = new HuffmanCode(len & 255, sorted[symbol++] & 65535);
          ReplicateValue(root_table, table + key, step, table_size, code3);
          key = GetNextKey(key, len);
        }
      }
      mask = total_size - 1;
      low = -1;
      for (len = root_bits + 1, step = 2; len <= MAX_LENGTH; ++len, step <<= 1) {
        for (; count[len] > 0; --count[len]) {
          if ((key & mask) !== low) {
            table += table_size;
            table_bits = NextTableBitSize(count, len, root_bits);
            table_size = 1 << table_bits;
            total_size += table_size;
            low = key & mask;
            root_table[start_table + low] = new HuffmanCode(table_bits + root_bits & 255, table - start_table - low & 65535);
          }
          code3 = new HuffmanCode(len - root_bits & 255, sorted[symbol++] & 65535);
          ReplicateValue(root_table, table + (key >> root_bits), step, table_size, code3);
          key = GetNextKey(key, len);
        }
      }
      return total_size;
    };
  }
});

// ../node_modules/brotli/dec/context.js
var require_context = __commonJS({
  "../node_modules/brotli/dec/context.js"(exports) {
    exports.lookup = new Uint8Array([
      /* CONTEXT_UTF8, last byte. */
      /* ASCII range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      4,
      4,
      0,
      0,
      4,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      8,
      12,
      16,
      12,
      12,
      20,
      12,
      16,
      24,
      28,
      12,
      12,
      32,
      12,
      36,
      12,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      44,
      32,
      32,
      24,
      40,
      28,
      12,
      12,
      48,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      52,
      52,
      48,
      52,
      52,
      52,
      52,
      52,
      24,
      12,
      28,
      12,
      12,
      12,
      56,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      60,
      60,
      56,
      60,
      60,
      60,
      60,
      60,
      24,
      12,
      28,
      12,
      0,
      /* UTF8 continuation byte range. */
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      0,
      1,
      /* UTF8 lead byte range. */
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      2,
      3,
      /* CONTEXT_UTF8 second last byte. */
      /* ASCII range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      1,
      1,
      1,
      1,
      1,
      1,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      1,
      1,
      1,
      1,
      0,
      /* UTF8 continuation byte range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      /* UTF8 lead byte range. */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      /* CONTEXT_SIGNED, second last byte. */
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      7,
      /* CONTEXT_SIGNED, last byte, same as the above values shifted by 3 bits. */
      0,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      24,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      32,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      40,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      48,
      56,
      /* CONTEXT_LSB6, last byte. */
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      /* CONTEXT_MSB6, last byte. */
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      6,
      6,
      6,
      6,
      7,
      7,
      7,
      7,
      8,
      8,
      8,
      8,
      9,
      9,
      9,
      9,
      10,
      10,
      10,
      10,
      11,
      11,
      11,
      11,
      12,
      12,
      12,
      12,
      13,
      13,
      13,
      13,
      14,
      14,
      14,
      14,
      15,
      15,
      15,
      15,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      22,
      22,
      22,
      22,
      23,
      23,
      23,
      23,
      24,
      24,
      24,
      24,
      25,
      25,
      25,
      25,
      26,
      26,
      26,
      26,
      27,
      27,
      27,
      27,
      28,
      28,
      28,
      28,
      29,
      29,
      29,
      29,
      30,
      30,
      30,
      30,
      31,
      31,
      31,
      31,
      32,
      32,
      32,
      32,
      33,
      33,
      33,
      33,
      34,
      34,
      34,
      34,
      35,
      35,
      35,
      35,
      36,
      36,
      36,
      36,
      37,
      37,
      37,
      37,
      38,
      38,
      38,
      38,
      39,
      39,
      39,
      39,
      40,
      40,
      40,
      40,
      41,
      41,
      41,
      41,
      42,
      42,
      42,
      42,
      43,
      43,
      43,
      43,
      44,
      44,
      44,
      44,
      45,
      45,
      45,
      45,
      46,
      46,
      46,
      46,
      47,
      47,
      47,
      47,
      48,
      48,
      48,
      48,
      49,
      49,
      49,
      49,
      50,
      50,
      50,
      50,
      51,
      51,
      51,
      51,
      52,
      52,
      52,
      52,
      53,
      53,
      53,
      53,
      54,
      54,
      54,
      54,
      55,
      55,
      55,
      55,
      56,
      56,
      56,
      56,
      57,
      57,
      57,
      57,
      58,
      58,
      58,
      58,
      59,
      59,
      59,
      59,
      60,
      60,
      60,
      60,
      61,
      61,
      61,
      61,
      62,
      62,
      62,
      62,
      63,
      63,
      63,
      63,
      /* CONTEXT_{M,L}SB6, second last byte, */
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    exports.lookupOffsets = new Uint16Array([
      /* CONTEXT_LSB6 */
      1024,
      1536,
      /* CONTEXT_MSB6 */
      1280,
      1536,
      /* CONTEXT_UTF8 */
      0,
      256,
      /* CONTEXT_SIGNED */
      768,
      512
    ]);
  }
});

// ../node_modules/brotli/dec/prefix.js
var require_prefix = __commonJS({
  "../node_modules/brotli/dec/prefix.js"(exports) {
    function PrefixCodeRange(offset3, nbits) {
      this.offset = offset3;
      this.nbits = nbits;
    }
    exports.kBlockLengthPrefixCode = [
      new PrefixCodeRange(1, 2),
      new PrefixCodeRange(5, 2),
      new PrefixCodeRange(9, 2),
      new PrefixCodeRange(13, 2),
      new PrefixCodeRange(17, 3),
      new PrefixCodeRange(25, 3),
      new PrefixCodeRange(33, 3),
      new PrefixCodeRange(41, 3),
      new PrefixCodeRange(49, 4),
      new PrefixCodeRange(65, 4),
      new PrefixCodeRange(81, 4),
      new PrefixCodeRange(97, 4),
      new PrefixCodeRange(113, 5),
      new PrefixCodeRange(145, 5),
      new PrefixCodeRange(177, 5),
      new PrefixCodeRange(209, 5),
      new PrefixCodeRange(241, 6),
      new PrefixCodeRange(305, 6),
      new PrefixCodeRange(369, 7),
      new PrefixCodeRange(497, 8),
      new PrefixCodeRange(753, 9),
      new PrefixCodeRange(1265, 10),
      new PrefixCodeRange(2289, 11),
      new PrefixCodeRange(4337, 12),
      new PrefixCodeRange(8433, 13),
      new PrefixCodeRange(16625, 24)
    ];
    exports.kInsertLengthPrefixCode = [
      new PrefixCodeRange(0, 0),
      new PrefixCodeRange(1, 0),
      new PrefixCodeRange(2, 0),
      new PrefixCodeRange(3, 0),
      new PrefixCodeRange(4, 0),
      new PrefixCodeRange(5, 0),
      new PrefixCodeRange(6, 1),
      new PrefixCodeRange(8, 1),
      new PrefixCodeRange(10, 2),
      new PrefixCodeRange(14, 2),
      new PrefixCodeRange(18, 3),
      new PrefixCodeRange(26, 3),
      new PrefixCodeRange(34, 4),
      new PrefixCodeRange(50, 4),
      new PrefixCodeRange(66, 5),
      new PrefixCodeRange(98, 5),
      new PrefixCodeRange(130, 6),
      new PrefixCodeRange(194, 7),
      new PrefixCodeRange(322, 8),
      new PrefixCodeRange(578, 9),
      new PrefixCodeRange(1090, 10),
      new PrefixCodeRange(2114, 12),
      new PrefixCodeRange(6210, 14),
      new PrefixCodeRange(22594, 24)
    ];
    exports.kCopyLengthPrefixCode = [
      new PrefixCodeRange(2, 0),
      new PrefixCodeRange(3, 0),
      new PrefixCodeRange(4, 0),
      new PrefixCodeRange(5, 0),
      new PrefixCodeRange(6, 0),
      new PrefixCodeRange(7, 0),
      new PrefixCodeRange(8, 0),
      new PrefixCodeRange(9, 0),
      new PrefixCodeRange(10, 1),
      new PrefixCodeRange(12, 1),
      new PrefixCodeRange(14, 2),
      new PrefixCodeRange(18, 2),
      new PrefixCodeRange(22, 3),
      new PrefixCodeRange(30, 3),
      new PrefixCodeRange(38, 4),
      new PrefixCodeRange(54, 4),
      new PrefixCodeRange(70, 5),
      new PrefixCodeRange(102, 5),
      new PrefixCodeRange(134, 6),
      new PrefixCodeRange(198, 7),
      new PrefixCodeRange(326, 8),
      new PrefixCodeRange(582, 9),
      new PrefixCodeRange(1094, 10),
      new PrefixCodeRange(2118, 24)
    ];
    exports.kInsertRangeLut = [
      0,
      0,
      8,
      8,
      0,
      16,
      8,
      16,
      16
    ];
    exports.kCopyRangeLut = [
      0,
      8,
      0,
      8,
      16,
      0,
      16,
      8,
      16
    ];
  }
});

// ../node_modules/brotli/dec/transform.js
var require_transform = __commonJS({
  "../node_modules/brotli/dec/transform.js"(exports) {
    var BrotliDictionary = require_dictionary();
    var kIdentity = 0;
    var kOmitLast1 = 1;
    var kOmitLast2 = 2;
    var kOmitLast3 = 3;
    var kOmitLast4 = 4;
    var kOmitLast5 = 5;
    var kOmitLast6 = 6;
    var kOmitLast7 = 7;
    var kOmitLast8 = 8;
    var kOmitLast9 = 9;
    var kUppercaseFirst = 10;
    var kUppercaseAll = 11;
    var kOmitFirst1 = 12;
    var kOmitFirst2 = 13;
    var kOmitFirst3 = 14;
    var kOmitFirst4 = 15;
    var kOmitFirst5 = 16;
    var kOmitFirst6 = 17;
    var kOmitFirst7 = 18;
    var kOmitFirst9 = 20;
    function Transform3(prefix, transform4, suffix) {
      this.prefix = new Uint8Array(prefix.length);
      this.transform = transform4;
      this.suffix = new Uint8Array(suffix.length);
      for (var i = 0; i < prefix.length; i++)
        this.prefix[i] = prefix.charCodeAt(i);
      for (var i = 0; i < suffix.length; i++)
        this.suffix[i] = suffix.charCodeAt(i);
    }
    var kTransforms = [
      new Transform3("", kIdentity, ""),
      new Transform3("", kIdentity, " "),
      new Transform3(" ", kIdentity, " "),
      new Transform3("", kOmitFirst1, ""),
      new Transform3("", kUppercaseFirst, " "),
      new Transform3("", kIdentity, " the "),
      new Transform3(" ", kIdentity, ""),
      new Transform3("s ", kIdentity, " "),
      new Transform3("", kIdentity, " of "),
      new Transform3("", kUppercaseFirst, ""),
      new Transform3("", kIdentity, " and "),
      new Transform3("", kOmitFirst2, ""),
      new Transform3("", kOmitLast1, ""),
      new Transform3(", ", kIdentity, " "),
      new Transform3("", kIdentity, ", "),
      new Transform3(" ", kUppercaseFirst, " "),
      new Transform3("", kIdentity, " in "),
      new Transform3("", kIdentity, " to "),
      new Transform3("e ", kIdentity, " "),
      new Transform3("", kIdentity, '"'),
      new Transform3("", kIdentity, "."),
      new Transform3("", kIdentity, '">'),
      new Transform3("", kIdentity, "\n"),
      new Transform3("", kOmitLast3, ""),
      new Transform3("", kIdentity, "]"),
      new Transform3("", kIdentity, " for "),
      new Transform3("", kOmitFirst3, ""),
      new Transform3("", kOmitLast2, ""),
      new Transform3("", kIdentity, " a "),
      new Transform3("", kIdentity, " that "),
      new Transform3(" ", kUppercaseFirst, ""),
      new Transform3("", kIdentity, ". "),
      new Transform3(".", kIdentity, ""),
      new Transform3(" ", kIdentity, ", "),
      new Transform3("", kOmitFirst4, ""),
      new Transform3("", kIdentity, " with "),
      new Transform3("", kIdentity, "'"),
      new Transform3("", kIdentity, " from "),
      new Transform3("", kIdentity, " by "),
      new Transform3("", kOmitFirst5, ""),
      new Transform3("", kOmitFirst6, ""),
      new Transform3(" the ", kIdentity, ""),
      new Transform3("", kOmitLast4, ""),
      new Transform3("", kIdentity, ". The "),
      new Transform3("", kUppercaseAll, ""),
      new Transform3("", kIdentity, " on "),
      new Transform3("", kIdentity, " as "),
      new Transform3("", kIdentity, " is "),
      new Transform3("", kOmitLast7, ""),
      new Transform3("", kOmitLast1, "ing "),
      new Transform3("", kIdentity, "\n	"),
      new Transform3("", kIdentity, ":"),
      new Transform3(" ", kIdentity, ". "),
      new Transform3("", kIdentity, "ed "),
      new Transform3("", kOmitFirst9, ""),
      new Transform3("", kOmitFirst7, ""),
      new Transform3("", kOmitLast6, ""),
      new Transform3("", kIdentity, "("),
      new Transform3("", kUppercaseFirst, ", "),
      new Transform3("", kOmitLast8, ""),
      new Transform3("", kIdentity, " at "),
      new Transform3("", kIdentity, "ly "),
      new Transform3(" the ", kIdentity, " of "),
      new Transform3("", kOmitLast5, ""),
      new Transform3("", kOmitLast9, ""),
      new Transform3(" ", kUppercaseFirst, ", "),
      new Transform3("", kUppercaseFirst, '"'),
      new Transform3(".", kIdentity, "("),
      new Transform3("", kUppercaseAll, " "),
      new Transform3("", kUppercaseFirst, '">'),
      new Transform3("", kIdentity, '="'),
      new Transform3(" ", kIdentity, "."),
      new Transform3(".com/", kIdentity, ""),
      new Transform3(" the ", kIdentity, " of the "),
      new Transform3("", kUppercaseFirst, "'"),
      new Transform3("", kIdentity, ". This "),
      new Transform3("", kIdentity, ","),
      new Transform3(".", kIdentity, " "),
      new Transform3("", kUppercaseFirst, "("),
      new Transform3("", kUppercaseFirst, "."),
      new Transform3("", kIdentity, " not "),
      new Transform3(" ", kIdentity, '="'),
      new Transform3("", kIdentity, "er "),
      new Transform3(" ", kUppercaseAll, " "),
      new Transform3("", kIdentity, "al "),
      new Transform3(" ", kUppercaseAll, ""),
      new Transform3("", kIdentity, "='"),
      new Transform3("", kUppercaseAll, '"'),
      new Transform3("", kUppercaseFirst, ". "),
      new Transform3(" ", kIdentity, "("),
      new Transform3("", kIdentity, "ful "),
      new Transform3(" ", kUppercaseFirst, ". "),
      new Transform3("", kIdentity, "ive "),
      new Transform3("", kIdentity, "less "),
      new Transform3("", kUppercaseAll, "'"),
      new Transform3("", kIdentity, "est "),
      new Transform3(" ", kUppercaseFirst, "."),
      new Transform3("", kUppercaseAll, '">'),
      new Transform3(" ", kIdentity, "='"),
      new Transform3("", kUppercaseFirst, ","),
      new Transform3("", kIdentity, "ize "),
      new Transform3("", kUppercaseAll, "."),
      new Transform3("Â ", kIdentity, ""),
      new Transform3(" ", kIdentity, ","),
      new Transform3("", kUppercaseFirst, '="'),
      new Transform3("", kUppercaseAll, '="'),
      new Transform3("", kIdentity, "ous "),
      new Transform3("", kUppercaseAll, ", "),
      new Transform3("", kUppercaseFirst, "='"),
      new Transform3(" ", kUppercaseFirst, ","),
      new Transform3(" ", kUppercaseAll, '="'),
      new Transform3(" ", kUppercaseAll, ", "),
      new Transform3("", kUppercaseAll, ","),
      new Transform3("", kUppercaseAll, "("),
      new Transform3("", kUppercaseAll, ". "),
      new Transform3(" ", kUppercaseAll, "."),
      new Transform3("", kUppercaseAll, "='"),
      new Transform3(" ", kUppercaseAll, ". "),
      new Transform3(" ", kUppercaseFirst, '="'),
      new Transform3(" ", kUppercaseAll, "='"),
      new Transform3(" ", kUppercaseFirst, "='")
    ];
    exports.kTransforms = kTransforms;
    exports.kNumTransforms = kTransforms.length;
    function ToUpperCase(p, i) {
      if (p[i] < 192) {
        if (p[i] >= 97 && p[i] <= 122) {
          p[i] ^= 32;
        }
        return 1;
      }
      if (p[i] < 224) {
        p[i + 1] ^= 32;
        return 2;
      }
      p[i + 2] ^= 5;
      return 3;
    }
    exports.transformDictionaryWord = function(dst, idx, word, len, transform4) {
      var prefix = kTransforms[transform4].prefix;
      var suffix = kTransforms[transform4].suffix;
      var t2 = kTransforms[transform4].transform;
      var skip = t2 < kOmitFirst1 ? 0 : t2 - (kOmitFirst1 - 1);
      var i = 0;
      var start_idx = idx;
      var uppercase;
      if (skip > len) {
        skip = len;
      }
      var prefix_pos = 0;
      while (prefix_pos < prefix.length) {
        dst[idx++] = prefix[prefix_pos++];
      }
      word += skip;
      len -= skip;
      if (t2 <= kOmitLast9) {
        len -= t2;
      }
      for (i = 0; i < len; i++) {
        dst[idx++] = BrotliDictionary.dictionary[word + i];
      }
      uppercase = idx - len;
      if (t2 === kUppercaseFirst) {
        ToUpperCase(dst, uppercase);
      } else if (t2 === kUppercaseAll) {
        while (len > 0) {
          var step = ToUpperCase(dst, uppercase);
          uppercase += step;
          len -= step;
        }
      }
      var suffix_pos = 0;
      while (suffix_pos < suffix.length) {
        dst[idx++] = suffix[suffix_pos++];
      }
      return idx - start_idx;
    };
  }
});

// ../node_modules/brotli/dec/decode.js
var require_decode = __commonJS({
  "../node_modules/brotli/dec/decode.js"(exports) {
    var BrotliInput = require_streams().BrotliInput;
    var BrotliOutput = require_streams().BrotliOutput;
    var BrotliBitReader = require_bit_reader();
    var BrotliDictionary = require_dictionary();
    var HuffmanCode = require_huffman().HuffmanCode;
    var BrotliBuildHuffmanTable = require_huffman().BrotliBuildHuffmanTable;
    var Context = require_context();
    var Prefix = require_prefix();
    var Transform3 = require_transform();
    var kDefaultCodeLength = 8;
    var kCodeLengthRepeatCode = 16;
    var kNumLiteralCodes = 256;
    var kNumInsertAndCopyCodes = 704;
    var kNumBlockLengthCodes = 26;
    var kLiteralContextBits = 6;
    var kDistanceContextBits = 2;
    var HUFFMAN_TABLE_BITS = 8;
    var HUFFMAN_TABLE_MASK = 255;
    var HUFFMAN_MAX_TABLE_SIZE = 1080;
    var CODE_LENGTH_CODES = 18;
    var kCodeLengthCodeOrder = new Uint8Array([
      1,
      2,
      3,
      4,
      0,
      5,
      17,
      6,
      16,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15
    ]);
    var NUM_DISTANCE_SHORT_CODES = 16;
    var kDistanceShortCodeIndexOffset = new Uint8Array([
      3,
      2,
      1,
      0,
      3,
      3,
      3,
      3,
      3,
      3,
      2,
      2,
      2,
      2,
      2,
      2
    ]);
    var kDistanceShortCodeValueOffset = new Int8Array([
      0,
      0,
      0,
      0,
      -1,
      1,
      -2,
      2,
      -3,
      3,
      -1,
      1,
      -2,
      2,
      -3,
      3
    ]);
    var kMaxHuffmanTableSize = new Uint16Array([
      256,
      402,
      436,
      468,
      500,
      534,
      566,
      598,
      630,
      662,
      694,
      726,
      758,
      790,
      822,
      854,
      886,
      920,
      952,
      984,
      1016,
      1048,
      1080
    ]);
    function DecodeWindowBits(br) {
      var n;
      if (br.readBits(1) === 0) {
        return 16;
      }
      n = br.readBits(3);
      if (n > 0) {
        return 17 + n;
      }
      n = br.readBits(3);
      if (n > 0) {
        return 8 + n;
      }
      return 17;
    }
    function DecodeVarLenUint8(br) {
      if (br.readBits(1)) {
        var nbits = br.readBits(3);
        if (nbits === 0) {
          return 1;
        } else {
          return br.readBits(nbits) + (1 << nbits);
        }
      }
      return 0;
    }
    function MetaBlockLength() {
      this.meta_block_length = 0;
      this.input_end = 0;
      this.is_uncompressed = 0;
      this.is_metadata = false;
    }
    function DecodeMetaBlockLength(br) {
      var out = new MetaBlockLength();
      var size_nibbles;
      var size_bytes;
      var i;
      out.input_end = br.readBits(1);
      if (out.input_end && br.readBits(1)) {
        return out;
      }
      size_nibbles = br.readBits(2) + 4;
      if (size_nibbles === 7) {
        out.is_metadata = true;
        if (br.readBits(1) !== 0)
          throw new Error("Invalid reserved bit");
        size_bytes = br.readBits(2);
        if (size_bytes === 0)
          return out;
        for (i = 0; i < size_bytes; i++) {
          var next_byte = br.readBits(8);
          if (i + 1 === size_bytes && size_bytes > 1 && next_byte === 0)
            throw new Error("Invalid size byte");
          out.meta_block_length |= next_byte << i * 8;
        }
      } else {
        for (i = 0; i < size_nibbles; ++i) {
          var next_nibble = br.readBits(4);
          if (i + 1 === size_nibbles && size_nibbles > 4 && next_nibble === 0)
            throw new Error("Invalid size nibble");
          out.meta_block_length |= next_nibble << i * 4;
        }
      }
      ++out.meta_block_length;
      if (!out.input_end && !out.is_metadata) {
        out.is_uncompressed = br.readBits(1);
      }
      return out;
    }
    function ReadSymbol(table, index3, br) {
      var start_index = index3;
      var nbits;
      br.fillBitWindow();
      index3 += br.val_ >>> br.bit_pos_ & HUFFMAN_TABLE_MASK;
      nbits = table[index3].bits - HUFFMAN_TABLE_BITS;
      if (nbits > 0) {
        br.bit_pos_ += HUFFMAN_TABLE_BITS;
        index3 += table[index3].value;
        index3 += br.val_ >>> br.bit_pos_ & (1 << nbits) - 1;
      }
      br.bit_pos_ += table[index3].bits;
      return table[index3].value;
    }
    function ReadHuffmanCodeLengths(code_length_code_lengths, num_symbols, code_lengths, br) {
      var symbol = 0;
      var prev_code_len = kDefaultCodeLength;
      var repeat3 = 0;
      var repeat_code_len = 0;
      var space = 32768;
      var table = [];
      for (var i = 0; i < 32; i++)
        table.push(new HuffmanCode(0, 0));
      BrotliBuildHuffmanTable(table, 0, 5, code_length_code_lengths, CODE_LENGTH_CODES);
      while (symbol < num_symbols && space > 0) {
        var p = 0;
        var code_len;
        br.readMoreInput();
        br.fillBitWindow();
        p += br.val_ >>> br.bit_pos_ & 31;
        br.bit_pos_ += table[p].bits;
        code_len = table[p].value & 255;
        if (code_len < kCodeLengthRepeatCode) {
          repeat3 = 0;
          code_lengths[symbol++] = code_len;
          if (code_len !== 0) {
            prev_code_len = code_len;
            space -= 32768 >> code_len;
          }
        } else {
          var extra_bits = code_len - 14;
          var old_repeat;
          var repeat_delta;
          var new_len = 0;
          if (code_len === kCodeLengthRepeatCode) {
            new_len = prev_code_len;
          }
          if (repeat_code_len !== new_len) {
            repeat3 = 0;
            repeat_code_len = new_len;
          }
          old_repeat = repeat3;
          if (repeat3 > 0) {
            repeat3 -= 2;
            repeat3 <<= extra_bits;
          }
          repeat3 += br.readBits(extra_bits) + 3;
          repeat_delta = repeat3 - old_repeat;
          if (symbol + repeat_delta > num_symbols) {
            throw new Error("[ReadHuffmanCodeLengths] symbol + repeat_delta > num_symbols");
          }
          for (var x = 0; x < repeat_delta; x++)
            code_lengths[symbol + x] = repeat_code_len;
          symbol += repeat_delta;
          if (repeat_code_len !== 0) {
            space -= repeat_delta << 15 - repeat_code_len;
          }
        }
      }
      if (space !== 0) {
        throw new Error("[ReadHuffmanCodeLengths] space = " + space);
      }
      for (; symbol < num_symbols; symbol++)
        code_lengths[symbol] = 0;
    }
    function ReadHuffmanCode(alphabet_size, tables, table, br) {
      var table_size = 0;
      var simple_code_or_skip;
      var code_lengths = new Uint8Array(alphabet_size);
      br.readMoreInput();
      simple_code_or_skip = br.readBits(2);
      if (simple_code_or_skip === 1) {
        var i;
        var max_bits_counter = alphabet_size - 1;
        var max_bits = 0;
        var symbols = new Int32Array(4);
        var num_symbols = br.readBits(2) + 1;
        while (max_bits_counter) {
          max_bits_counter >>= 1;
          ++max_bits;
        }
        for (i = 0; i < num_symbols; ++i) {
          symbols[i] = br.readBits(max_bits) % alphabet_size;
          code_lengths[symbols[i]] = 2;
        }
        code_lengths[symbols[0]] = 1;
        switch (num_symbols) {
          case 1:
            break;
          case 3:
            if (symbols[0] === symbols[1] || symbols[0] === symbols[2] || symbols[1] === symbols[2]) {
              throw new Error("[ReadHuffmanCode] invalid symbols");
            }
            break;
          case 2:
            if (symbols[0] === symbols[1]) {
              throw new Error("[ReadHuffmanCode] invalid symbols");
            }
            code_lengths[symbols[1]] = 1;
            break;
          case 4:
            if (symbols[0] === symbols[1] || symbols[0] === symbols[2] || symbols[0] === symbols[3] || symbols[1] === symbols[2] || symbols[1] === symbols[3] || symbols[2] === symbols[3]) {
              throw new Error("[ReadHuffmanCode] invalid symbols");
            }
            if (br.readBits(1)) {
              code_lengths[symbols[2]] = 3;
              code_lengths[symbols[3]] = 3;
            } else {
              code_lengths[symbols[0]] = 2;
            }
            break;
        }
      } else {
        var i;
        var code_length_code_lengths = new Uint8Array(CODE_LENGTH_CODES);
        var space = 32;
        var num_codes = 0;
        var huff = [
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(3, 2),
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(4, 1),
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(3, 2),
          new HuffmanCode(2, 0),
          new HuffmanCode(2, 4),
          new HuffmanCode(2, 3),
          new HuffmanCode(4, 5)
        ];
        for (i = simple_code_or_skip; i < CODE_LENGTH_CODES && space > 0; ++i) {
          var code_len_idx = kCodeLengthCodeOrder[i];
          var p = 0;
          var v2;
          br.fillBitWindow();
          p += br.val_ >>> br.bit_pos_ & 15;
          br.bit_pos_ += huff[p].bits;
          v2 = huff[p].value;
          code_length_code_lengths[code_len_idx] = v2;
          if (v2 !== 0) {
            space -= 32 >> v2;
            ++num_codes;
          }
        }
        if (!(num_codes === 1 || space === 0))
          throw new Error("[ReadHuffmanCode] invalid num_codes or space");
        ReadHuffmanCodeLengths(code_length_code_lengths, alphabet_size, code_lengths, br);
      }
      table_size = BrotliBuildHuffmanTable(tables, table, HUFFMAN_TABLE_BITS, code_lengths, alphabet_size);
      if (table_size === 0) {
        throw new Error("[ReadHuffmanCode] BuildHuffmanTable failed: ");
      }
      return table_size;
    }
    function ReadBlockLength(table, index3, br) {
      var code3;
      var nbits;
      code3 = ReadSymbol(table, index3, br);
      nbits = Prefix.kBlockLengthPrefixCode[code3].nbits;
      return Prefix.kBlockLengthPrefixCode[code3].offset + br.readBits(nbits);
    }
    function TranslateShortCodes(code3, ringbuffer, index3) {
      var val;
      if (code3 < NUM_DISTANCE_SHORT_CODES) {
        index3 += kDistanceShortCodeIndexOffset[code3];
        index3 &= 3;
        val = ringbuffer[index3] + kDistanceShortCodeValueOffset[code3];
      } else {
        val = code3 - NUM_DISTANCE_SHORT_CODES + 1;
      }
      return val;
    }
    function MoveToFront(v2, index3) {
      var value2 = v2[index3];
      var i = index3;
      for (; i; --i)
        v2[i] = v2[i - 1];
      v2[0] = value2;
    }
    function InverseMoveToFrontTransform(v2, v_len) {
      var mtf = new Uint8Array(256);
      var i;
      for (i = 0; i < 256; ++i) {
        mtf[i] = i;
      }
      for (i = 0; i < v_len; ++i) {
        var index3 = v2[i];
        v2[i] = mtf[index3];
        if (index3)
          MoveToFront(mtf, index3);
      }
    }
    function HuffmanTreeGroup(alphabet_size, num_htrees) {
      this.alphabet_size = alphabet_size;
      this.num_htrees = num_htrees;
      this.codes = new Array(num_htrees + num_htrees * kMaxHuffmanTableSize[alphabet_size + 31 >>> 5]);
      this.htrees = new Uint32Array(num_htrees);
    }
    HuffmanTreeGroup.prototype.decode = function(br) {
      var i;
      var table_size;
      var next2 = 0;
      for (i = 0; i < this.num_htrees; ++i) {
        this.htrees[i] = next2;
        table_size = ReadHuffmanCode(this.alphabet_size, this.codes, next2, br);
        next2 += table_size;
      }
    };
    function DecodeContextMap(context_map_size, br) {
      var out = { num_htrees: null, context_map: null };
      var use_rle_for_zeros;
      var max_run_length_prefix = 0;
      var table;
      var i;
      br.readMoreInput();
      var num_htrees = out.num_htrees = DecodeVarLenUint8(br) + 1;
      var context_map = out.context_map = new Uint8Array(context_map_size);
      if (num_htrees <= 1) {
        return out;
      }
      use_rle_for_zeros = br.readBits(1);
      if (use_rle_for_zeros) {
        max_run_length_prefix = br.readBits(4) + 1;
      }
      table = [];
      for (i = 0; i < HUFFMAN_MAX_TABLE_SIZE; i++) {
        table[i] = new HuffmanCode(0, 0);
      }
      ReadHuffmanCode(num_htrees + max_run_length_prefix, table, 0, br);
      for (i = 0; i < context_map_size; ) {
        var code3;
        br.readMoreInput();
        code3 = ReadSymbol(table, 0, br);
        if (code3 === 0) {
          context_map[i] = 0;
          ++i;
        } else if (code3 <= max_run_length_prefix) {
          var reps = 1 + (1 << code3) + br.readBits(code3);
          while (--reps) {
            if (i >= context_map_size) {
              throw new Error("[DecodeContextMap] i >= context_map_size");
            }
            context_map[i] = 0;
            ++i;
          }
        } else {
          context_map[i] = code3 - max_run_length_prefix;
          ++i;
        }
      }
      if (br.readBits(1)) {
        InverseMoveToFrontTransform(context_map, context_map_size);
      }
      return out;
    }
    function DecodeBlockType(max_block_type, trees2, tree_type, block_types, ringbuffers, indexes, br) {
      var ringbuffer = tree_type * 2;
      var index3 = tree_type;
      var type_code = ReadSymbol(trees2, tree_type * HUFFMAN_MAX_TABLE_SIZE, br);
      var block_type;
      if (type_code === 0) {
        block_type = ringbuffers[ringbuffer + (indexes[index3] & 1)];
      } else if (type_code === 1) {
        block_type = ringbuffers[ringbuffer + (indexes[index3] - 1 & 1)] + 1;
      } else {
        block_type = type_code - 2;
      }
      if (block_type >= max_block_type) {
        block_type -= max_block_type;
      }
      block_types[tree_type] = block_type;
      ringbuffers[ringbuffer + (indexes[index3] & 1)] = block_type;
      ++indexes[index3];
    }
    function CopyUncompressedBlockToOutput(output, len, pos, ringbuffer, ringbuffer_mask, br) {
      var rb_size = ringbuffer_mask + 1;
      var rb_pos = pos & ringbuffer_mask;
      var br_pos = br.pos_ & BrotliBitReader.IBUF_MASK;
      var nbytes;
      if (len < 8 || br.bit_pos_ + (len << 3) < br.bit_end_pos_) {
        while (len-- > 0) {
          br.readMoreInput();
          ringbuffer[rb_pos++] = br.readBits(8);
          if (rb_pos === rb_size) {
            output.write(ringbuffer, rb_size);
            rb_pos = 0;
          }
        }
        return;
      }
      if (br.bit_end_pos_ < 32) {
        throw new Error("[CopyUncompressedBlockToOutput] br.bit_end_pos_ < 32");
      }
      while (br.bit_pos_ < 32) {
        ringbuffer[rb_pos] = br.val_ >>> br.bit_pos_;
        br.bit_pos_ += 8;
        ++rb_pos;
        --len;
      }
      nbytes = br.bit_end_pos_ - br.bit_pos_ >> 3;
      if (br_pos + nbytes > BrotliBitReader.IBUF_MASK) {
        var tail = BrotliBitReader.IBUF_MASK + 1 - br_pos;
        for (var x = 0; x < tail; x++)
          ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
        nbytes -= tail;
        rb_pos += tail;
        len -= tail;
        br_pos = 0;
      }
      for (var x = 0; x < nbytes; x++)
        ringbuffer[rb_pos + x] = br.buf_[br_pos + x];
      rb_pos += nbytes;
      len -= nbytes;
      if (rb_pos >= rb_size) {
        output.write(ringbuffer, rb_size);
        rb_pos -= rb_size;
        for (var x = 0; x < rb_pos; x++)
          ringbuffer[x] = ringbuffer[rb_size + x];
      }
      while (rb_pos + len >= rb_size) {
        nbytes = rb_size - rb_pos;
        if (br.input_.read(ringbuffer, rb_pos, nbytes) < nbytes) {
          throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
        }
        output.write(ringbuffer, rb_size);
        len -= nbytes;
        rb_pos = 0;
      }
      if (br.input_.read(ringbuffer, rb_pos, len) < len) {
        throw new Error("[CopyUncompressedBlockToOutput] not enough bytes");
      }
      br.reset();
    }
    function JumpToByteBoundary(br) {
      var new_bit_pos = br.bit_pos_ + 7 & ~7;
      var pad_bits = br.readBits(new_bit_pos - br.bit_pos_);
      return pad_bits == 0;
    }
    function BrotliDecompressedSize(buffer3) {
      var input = new BrotliInput(buffer3);
      var br = new BrotliBitReader(input);
      DecodeWindowBits(br);
      var out = DecodeMetaBlockLength(br);
      return out.meta_block_length;
    }
    exports.BrotliDecompressedSize = BrotliDecompressedSize;
    function BrotliDecompressBuffer(buffer3, output_size) {
      var input = new BrotliInput(buffer3);
      if (output_size == null) {
        output_size = BrotliDecompressedSize(buffer3);
      }
      var output_buffer = new Uint8Array(output_size);
      var output = new BrotliOutput(output_buffer);
      BrotliDecompress(input, output);
      if (output.pos < output.buffer.length) {
        output.buffer = output.buffer.subarray(0, output.pos);
      }
      return output.buffer;
    }
    exports.BrotliDecompressBuffer = BrotliDecompressBuffer;
    function BrotliDecompress(input, output) {
      var i;
      var pos = 0;
      var input_end = 0;
      var window_bits = 0;
      var max_backward_distance;
      var max_distance = 0;
      var ringbuffer_size;
      var ringbuffer_mask;
      var ringbuffer;
      var ringbuffer_end;
      var dist_rb = [16, 15, 11, 4];
      var dist_rb_idx = 0;
      var prev_byte1 = 0;
      var prev_byte2 = 0;
      var hgroup = [new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0)];
      var block_type_trees;
      var block_len_trees;
      var br;
      var kRingBufferWriteAheadSlack = 128 + BrotliBitReader.READ_SIZE;
      br = new BrotliBitReader(input);
      window_bits = DecodeWindowBits(br);
      max_backward_distance = (1 << window_bits) - 16;
      ringbuffer_size = 1 << window_bits;
      ringbuffer_mask = ringbuffer_size - 1;
      ringbuffer = new Uint8Array(ringbuffer_size + kRingBufferWriteAheadSlack + BrotliDictionary.maxDictionaryWordLength);
      ringbuffer_end = ringbuffer_size;
      block_type_trees = [];
      block_len_trees = [];
      for (var x = 0; x < 3 * HUFFMAN_MAX_TABLE_SIZE; x++) {
        block_type_trees[x] = new HuffmanCode(0, 0);
        block_len_trees[x] = new HuffmanCode(0, 0);
      }
      while (!input_end) {
        var meta_block_remaining_len = 0;
        var is_uncompressed;
        var block_length = [1 << 28, 1 << 28, 1 << 28];
        var block_type = [0];
        var num_block_types = [1, 1, 1];
        var block_type_rb = [0, 1, 0, 1, 0, 1];
        var block_type_rb_index = [0];
        var distance_postfix_bits;
        var num_direct_distance_codes;
        var distance_postfix_mask;
        var num_distance_codes;
        var context_map = null;
        var context_modes = null;
        var num_literal_htrees;
        var dist_context_map = null;
        var num_dist_htrees;
        var context_offset = 0;
        var context_map_slice = null;
        var literal_htree_index = 0;
        var dist_context_offset = 0;
        var dist_context_map_slice = null;
        var dist_htree_index = 0;
        var context_lookup_offset1 = 0;
        var context_lookup_offset2 = 0;
        var context_mode;
        var htree_command;
        for (i = 0; i < 3; ++i) {
          hgroup[i].codes = null;
          hgroup[i].htrees = null;
        }
        br.readMoreInput();
        var _out = DecodeMetaBlockLength(br);
        meta_block_remaining_len = _out.meta_block_length;
        if (pos + meta_block_remaining_len > output.buffer.length) {
          var tmp = new Uint8Array(pos + meta_block_remaining_len);
          tmp.set(output.buffer);
          output.buffer = tmp;
        }
        input_end = _out.input_end;
        is_uncompressed = _out.is_uncompressed;
        if (_out.is_metadata) {
          JumpToByteBoundary(br);
          for (; meta_block_remaining_len > 0; --meta_block_remaining_len) {
            br.readMoreInput();
            br.readBits(8);
          }
          continue;
        }
        if (meta_block_remaining_len === 0) {
          continue;
        }
        if (is_uncompressed) {
          br.bit_pos_ = br.bit_pos_ + 7 & ~7;
          CopyUncompressedBlockToOutput(
            output,
            meta_block_remaining_len,
            pos,
            ringbuffer,
            ringbuffer_mask,
            br
          );
          pos += meta_block_remaining_len;
          continue;
        }
        for (i = 0; i < 3; ++i) {
          num_block_types[i] = DecodeVarLenUint8(br) + 1;
          if (num_block_types[i] >= 2) {
            ReadHuffmanCode(num_block_types[i] + 2, block_type_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
            ReadHuffmanCode(kNumBlockLengthCodes, block_len_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
            block_length[i] = ReadBlockLength(block_len_trees, i * HUFFMAN_MAX_TABLE_SIZE, br);
            block_type_rb_index[i] = 1;
          }
        }
        br.readMoreInput();
        distance_postfix_bits = br.readBits(2);
        num_direct_distance_codes = NUM_DISTANCE_SHORT_CODES + (br.readBits(4) << distance_postfix_bits);
        distance_postfix_mask = (1 << distance_postfix_bits) - 1;
        num_distance_codes = num_direct_distance_codes + (48 << distance_postfix_bits);
        context_modes = new Uint8Array(num_block_types[0]);
        for (i = 0; i < num_block_types[0]; ++i) {
          br.readMoreInput();
          context_modes[i] = br.readBits(2) << 1;
        }
        var _o1 = DecodeContextMap(num_block_types[0] << kLiteralContextBits, br);
        num_literal_htrees = _o1.num_htrees;
        context_map = _o1.context_map;
        var _o2 = DecodeContextMap(num_block_types[2] << kDistanceContextBits, br);
        num_dist_htrees = _o2.num_htrees;
        dist_context_map = _o2.context_map;
        hgroup[0] = new HuffmanTreeGroup(kNumLiteralCodes, num_literal_htrees);
        hgroup[1] = new HuffmanTreeGroup(kNumInsertAndCopyCodes, num_block_types[1]);
        hgroup[2] = new HuffmanTreeGroup(num_distance_codes, num_dist_htrees);
        for (i = 0; i < 3; ++i) {
          hgroup[i].decode(br);
        }
        context_map_slice = 0;
        dist_context_map_slice = 0;
        context_mode = context_modes[block_type[0]];
        context_lookup_offset1 = Context.lookupOffsets[context_mode];
        context_lookup_offset2 = Context.lookupOffsets[context_mode + 1];
        htree_command = hgroup[1].htrees[0];
        while (meta_block_remaining_len > 0) {
          var cmd_code;
          var range_idx;
          var insert_code;
          var copy_code;
          var insert_length;
          var copy_length;
          var distance_code;
          var distance;
          var context;
          var j;
          var copy_dst;
          br.readMoreInput();
          if (block_length[1] === 0) {
            DecodeBlockType(
              num_block_types[1],
              block_type_trees,
              1,
              block_type,
              block_type_rb,
              block_type_rb_index,
              br
            );
            block_length[1] = ReadBlockLength(block_len_trees, HUFFMAN_MAX_TABLE_SIZE, br);
            htree_command = hgroup[1].htrees[block_type[1]];
          }
          --block_length[1];
          cmd_code = ReadSymbol(hgroup[1].codes, htree_command, br);
          range_idx = cmd_code >> 6;
          if (range_idx >= 2) {
            range_idx -= 2;
            distance_code = -1;
          } else {
            distance_code = 0;
          }
          insert_code = Prefix.kInsertRangeLut[range_idx] + (cmd_code >> 3 & 7);
          copy_code = Prefix.kCopyRangeLut[range_idx] + (cmd_code & 7);
          insert_length = Prefix.kInsertLengthPrefixCode[insert_code].offset + br.readBits(Prefix.kInsertLengthPrefixCode[insert_code].nbits);
          copy_length = Prefix.kCopyLengthPrefixCode[copy_code].offset + br.readBits(Prefix.kCopyLengthPrefixCode[copy_code].nbits);
          prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask];
          prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask];
          for (j = 0; j < insert_length; ++j) {
            br.readMoreInput();
            if (block_length[0] === 0) {
              DecodeBlockType(
                num_block_types[0],
                block_type_trees,
                0,
                block_type,
                block_type_rb,
                block_type_rb_index,
                br
              );
              block_length[0] = ReadBlockLength(block_len_trees, 0, br);
              context_offset = block_type[0] << kLiteralContextBits;
              context_map_slice = context_offset;
              context_mode = context_modes[block_type[0]];
              context_lookup_offset1 = Context.lookupOffsets[context_mode];
              context_lookup_offset2 = Context.lookupOffsets[context_mode + 1];
            }
            context = Context.lookup[context_lookup_offset1 + prev_byte1] | Context.lookup[context_lookup_offset2 + prev_byte2];
            literal_htree_index = context_map[context_map_slice + context];
            --block_length[0];
            prev_byte2 = prev_byte1;
            prev_byte1 = ReadSymbol(hgroup[0].codes, hgroup[0].htrees[literal_htree_index], br);
            ringbuffer[pos & ringbuffer_mask] = prev_byte1;
            if ((pos & ringbuffer_mask) === ringbuffer_mask) {
              output.write(ringbuffer, ringbuffer_size);
            }
            ++pos;
          }
          meta_block_remaining_len -= insert_length;
          if (meta_block_remaining_len <= 0)
            break;
          if (distance_code < 0) {
            var context;
            br.readMoreInput();
            if (block_length[2] === 0) {
              DecodeBlockType(
                num_block_types[2],
                block_type_trees,
                2,
                block_type,
                block_type_rb,
                block_type_rb_index,
                br
              );
              block_length[2] = ReadBlockLength(block_len_trees, 2 * HUFFMAN_MAX_TABLE_SIZE, br);
              dist_context_offset = block_type[2] << kDistanceContextBits;
              dist_context_map_slice = dist_context_offset;
            }
            --block_length[2];
            context = (copy_length > 4 ? 3 : copy_length - 2) & 255;
            dist_htree_index = dist_context_map[dist_context_map_slice + context];
            distance_code = ReadSymbol(hgroup[2].codes, hgroup[2].htrees[dist_htree_index], br);
            if (distance_code >= num_direct_distance_codes) {
              var nbits;
              var postfix;
              var offset3;
              distance_code -= num_direct_distance_codes;
              postfix = distance_code & distance_postfix_mask;
              distance_code >>= distance_postfix_bits;
              nbits = (distance_code >> 1) + 1;
              offset3 = (2 + (distance_code & 1) << nbits) - 4;
              distance_code = num_direct_distance_codes + (offset3 + br.readBits(nbits) << distance_postfix_bits) + postfix;
            }
          }
          distance = TranslateShortCodes(distance_code, dist_rb, dist_rb_idx);
          if (distance < 0) {
            throw new Error("[BrotliDecompress] invalid distance");
          }
          if (pos < max_backward_distance && max_distance !== max_backward_distance) {
            max_distance = pos;
          } else {
            max_distance = max_backward_distance;
          }
          copy_dst = pos & ringbuffer_mask;
          if (distance > max_distance) {
            if (copy_length >= BrotliDictionary.minDictionaryWordLength && copy_length <= BrotliDictionary.maxDictionaryWordLength) {
              var offset3 = BrotliDictionary.offsetsByLength[copy_length];
              var word_id = distance - max_distance - 1;
              var shift = BrotliDictionary.sizeBitsByLength[copy_length];
              var mask = (1 << shift) - 1;
              var word_idx = word_id & mask;
              var transform_idx = word_id >> shift;
              offset3 += word_idx * copy_length;
              if (transform_idx < Transform3.kNumTransforms) {
                var len = Transform3.transformDictionaryWord(ringbuffer, copy_dst, offset3, copy_length, transform_idx);
                copy_dst += len;
                pos += len;
                meta_block_remaining_len -= len;
                if (copy_dst >= ringbuffer_end) {
                  output.write(ringbuffer, ringbuffer_size);
                  for (var _x = 0; _x < copy_dst - ringbuffer_end; _x++)
                    ringbuffer[_x] = ringbuffer[ringbuffer_end + _x];
                }
              } else {
                throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
              }
            } else {
              throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
            }
          } else {
            if (distance_code > 0) {
              dist_rb[dist_rb_idx & 3] = distance;
              ++dist_rb_idx;
            }
            if (copy_length > meta_block_remaining_len) {
              throw new Error("Invalid backward reference. pos: " + pos + " distance: " + distance + " len: " + copy_length + " bytes left: " + meta_block_remaining_len);
            }
            for (j = 0; j < copy_length; ++j) {
              ringbuffer[pos & ringbuffer_mask] = ringbuffer[pos - distance & ringbuffer_mask];
              if ((pos & ringbuffer_mask) === ringbuffer_mask) {
                output.write(ringbuffer, ringbuffer_size);
              }
              ++pos;
              --meta_block_remaining_len;
            }
          }
          prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask];
          prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask];
        }
        pos &= 1073741823;
      }
      output.write(ringbuffer, pos & ringbuffer_mask);
    }
    exports.BrotliDecompress = BrotliDecompress;
    BrotliDictionary.init();
  }
});

// ../node_modules/brotli/decompress.js
var require_decompress = __commonJS({
  "../node_modules/brotli/decompress.js"(exports, module) {
    module.exports = require_decode().BrotliDecompressBuffer;
  }
});

// ../node_modules/abs-svg-path/index.js
var require_abs_svg_path = __commonJS({
  "../node_modules/abs-svg-path/index.js"(exports, module) {
    module.exports = absolutize;
    function absolutize(path2) {
      var startX = 0;
      var startY = 0;
      var x = 0;
      var y = 0;
      return path2.map(function(seg) {
        seg = seg.slice();
        var type = seg[0];
        var command = type.toUpperCase();
        if (type != command) {
          seg[0] = command;
          switch (type) {
            case "a":
              seg[6] += x;
              seg[7] += y;
              break;
            case "v":
              seg[1] += y;
              break;
            case "h":
              seg[1] += x;
              break;
            default:
              for (var i = 1; i < seg.length; ) {
                seg[i++] += x;
                seg[i++] += y;
              }
          }
        }
        switch (command) {
          case "Z":
            x = startX;
            y = startY;
            break;
          case "H":
            x = seg[1];
            break;
          case "V":
            y = seg[1];
            break;
          case "M":
            x = startX = seg[1];
            y = startY = seg[2];
            break;
          default:
            x = seg[seg.length - 2];
            y = seg[seg.length - 1];
        }
        return seg;
      });
    }
  }
});

// ../node_modules/parse-svg-path/index.js
var require_parse_svg_path = __commonJS({
  "../node_modules/parse-svg-path/index.js"(exports, module) {
    module.exports = parse3;
    var length4 = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
    var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
    function parse3(path2) {
      var data2 = [];
      path2.replace(segment, function(_, command, args) {
        var type = command.toLowerCase();
        args = parseValues(args);
        if (type == "m" && args.length > 2) {
          data2.push([command].concat(args.splice(0, 2)));
          type = "l";
          command = command == "m" ? "l" : "L";
        }
        while (true) {
          if (args.length == length4[type]) {
            args.unshift(command);
            return data2.push(args);
          }
          if (args.length < length4[type])
            throw new Error("malformed path data");
          data2.push([command].concat(args.splice(0, length4[type])));
        }
      });
      return data2;
    }
    var number2 = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
    function parseValues(args) {
      var numbers = args.match(number2);
      return numbers ? numbers.map(Number) : [];
    }
  }
});

// ../node_modules/color-name/index.js
var require_color_name = __commonJS({
  "../node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// ../node_modules/simple-swizzle/node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "../node_modules/simple-swizzle/node_modules/is-arrayish/index.js"(exports, module) {
    module.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// ../node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "../node_modules/simple-swizzle/index.js"(exports, module) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat8 = Array.prototype.concat;
    var slice10 = Array.prototype.slice;
    var swizzle = module.exports = function swizzle2(args) {
      var results = [];
      for (var i = 0, len = args.length; i < len; i++) {
        var arg = args[i];
        if (isArrayish(arg)) {
          results = concat8.call(results, slice10.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});

// ../node_modules/color-string/index.js
var require_color_string = __commonJS({
  "../node_modules/color-string/index.js"(exports, module) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty3 = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name in colorNames) {
      if (hasOwnProperty3.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb = [0, 0, 0, 1];
      var match;
      var i;
      var hexAlpha;
      if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];
        for (i = 0; i < 3; i++) {
          var i2 = i * 2;
          rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i + 1], 0);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(per)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty3.call(colorNames, match[1])) {
          return null;
        }
        rgb = colorNames[match[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i = 0; i < 3; i++) {
        rgb[i] = clamp(rgb[i], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hsl);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h2 = (parseFloat(match[1]) % 360 + 360) % 360;
        var s2 = clamp(parseFloat(match[2]), 0, 100);
        var l2 = clamp(parseFloat(match[3]), 0, 100);
        var a2 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h2, s2, l2, a2];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h2 = (parseFloat(match[1]) % 360 + 360) % 360;
        var w = clamp(parseFloat(match[2]), 0, 100);
        var b = clamp(parseFloat(match[3]), 0, 100);
        var a2 = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h2, w, b, a2];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r = Math.round(rgba[0] / 255 * 100);
      var g3 = Math.round(rgba[1] / 255 * 100);
      var b = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g3 + "%, " + b + "%)" : "rgba(" + r + "%, " + g3 + "%, " + b + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a2 = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a2 = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a2 + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp(num, min3, max3) {
      return Math.min(Math.max(min3, num), max3);
    }
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
  }
});

// ../node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "../node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    function ZStream2() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream2;
  }
});

// ../node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "../node_modules/pako/lib/utils/common.js"(exports) {
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (source.hasOwnProperty(p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src3, src_offs, len, dest_offs) {
        if (src3.subarray && dest.subarray) {
          dest.set(src3.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src3[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i, l2, len, pos, chunk, result;
        len = 0;
        for (i = 0, l2 = chunks.length; i < l2; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l2 = chunks.length; i < l2; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src3, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src3[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on3) {
      if (on3) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// ../node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "../node_modules/pako/lib/zlib/trees.js"(exports) {
    "use strict";
    var utils2 = require_common();
    var Z_FIXED2 = 4;
    var Z_BINARY2 = 0;
    var Z_TEXT2 = 1;
    var Z_UNKNOWN2 = 2;
    function zero2(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK2 = 0;
    var STATIC_TREES2 = 1;
    var DYN_TREES2 = 2;
    var MIN_MATCH2 = 3;
    var MAX_MATCH2 = 258;
    var LENGTH_CODES2 = 29;
    var LITERALS2 = 256;
    var L_CODES2 = LITERALS2 + 1 + LENGTH_CODES2;
    var D_CODES2 = 30;
    var BL_CODES2 = 19;
    var HEAP_SIZE2 = 2 * L_CODES2 + 1;
    var MAX_BITS2 = 15;
    var Buf_size2 = 16;
    var MAX_BL_BITS2 = 7;
    var END_BLOCK2 = 256;
    var REP_3_62 = 16;
    var REPZ_3_102 = 17;
    var REPZ_11_1382 = 18;
    var extra_lbits2 = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits2 = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits2 = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN2 = 512;
    var static_ltree2 = new Array((L_CODES2 + 2) * 2);
    zero2(static_ltree2);
    var static_dtree2 = new Array(D_CODES2 * 2);
    zero2(static_dtree2);
    var _dist_code2 = new Array(DIST_CODE_LEN2);
    zero2(_dist_code2);
    var _length_code2 = new Array(MAX_MATCH2 - MIN_MATCH2 + 1);
    zero2(_length_code2);
    var base_length2 = new Array(LENGTH_CODES2);
    zero2(base_length2);
    var base_dist2 = new Array(D_CODES2);
    zero2(base_dist2);
    function StaticTreeDesc2(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc2;
    var static_d_desc2;
    var static_bl_desc2;
    function TreeDesc2(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code2(dist) {
      return dist < 256 ? _dist_code2[dist] : _dist_code2[256 + (dist >>> 7)];
    }
    function put_short2(s2, w) {
      s2.pending_buf[s2.pending++] = w & 255;
      s2.pending_buf[s2.pending++] = w >>> 8 & 255;
    }
    function send_bits2(s2, value2, length4) {
      if (s2.bi_valid > Buf_size2 - length4) {
        s2.bi_buf |= value2 << s2.bi_valid & 65535;
        put_short2(s2, s2.bi_buf);
        s2.bi_buf = value2 >> Buf_size2 - s2.bi_valid;
        s2.bi_valid += length4 - Buf_size2;
      } else {
        s2.bi_buf |= value2 << s2.bi_valid & 65535;
        s2.bi_valid += length4;
      }
    }
    function send_code2(s2, c2, tree) {
      send_bits2(
        s2,
        tree[c2 * 2],
        tree[c2 * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse2(code3, len) {
      var res = 0;
      do {
        res |= code3 & 1;
        code3 >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush2(s2) {
      if (s2.bi_valid === 16) {
        put_short2(s2, s2.bi_buf);
        s2.bi_buf = 0;
        s2.bi_valid = 0;
      } else if (s2.bi_valid >= 8) {
        s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
        s2.bi_buf >>= 8;
        s2.bi_valid -= 8;
      }
    }
    function gen_bitlen2(s2, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h2;
      var n, m2;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS2; bits++) {
        s2.bl_count[bits] = 0;
      }
      tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
      for (h2 = s2.heap_max + 1; h2 < HEAP_SIZE2; h2++) {
        n = s2.heap[h2];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s2.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s2.opt_len += f * (bits + xbits);
        if (has_stree) {
          s2.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s2.bl_count[bits] === 0) {
          bits--;
        }
        s2.bl_count[bits]--;
        s2.bl_count[bits + 1] += 2;
        s2.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s2.bl_count[bits];
        while (n !== 0) {
          m2 = s2.heap[--h2];
          if (m2 > max_code) {
            continue;
          }
          if (tree[m2 * 2 + 1] !== bits) {
            s2.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
            tree[m2 * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes2(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS2 + 1);
      var code3 = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS2; bits++) {
        next_code[bits] = code3 = code3 + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse2(next_code[len]++, len);
      }
    }
    function tr_static_init2() {
      var n;
      var bits;
      var length4;
      var code3;
      var dist;
      var bl_count = new Array(MAX_BITS2 + 1);
      length4 = 0;
      for (code3 = 0; code3 < LENGTH_CODES2 - 1; code3++) {
        base_length2[code3] = length4;
        for (n = 0; n < 1 << extra_lbits2[code3]; n++) {
          _length_code2[length4++] = code3;
        }
      }
      _length_code2[length4 - 1] = code3;
      dist = 0;
      for (code3 = 0; code3 < 16; code3++) {
        base_dist2[code3] = dist;
        for (n = 0; n < 1 << extra_dbits2[code3]; n++) {
          _dist_code2[dist++] = code3;
        }
      }
      dist >>= 7;
      for (; code3 < D_CODES2; code3++) {
        base_dist2[code3] = dist << 7;
        for (n = 0; n < 1 << extra_dbits2[code3] - 7; n++) {
          _dist_code2[256 + dist++] = code3;
        }
      }
      for (bits = 0; bits <= MAX_BITS2; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree2[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree2[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree2[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree2[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes2(static_ltree2, L_CODES2 + 1, bl_count);
      for (n = 0; n < D_CODES2; n++) {
        static_dtree2[n * 2 + 1] = 5;
        static_dtree2[n * 2] = bi_reverse2(n, 5);
      }
      static_l_desc2 = new StaticTreeDesc2(static_ltree2, extra_lbits2, LITERALS2 + 1, L_CODES2, MAX_BITS2);
      static_d_desc2 = new StaticTreeDesc2(static_dtree2, extra_dbits2, 0, D_CODES2, MAX_BITS2);
      static_bl_desc2 = new StaticTreeDesc2(new Array(0), extra_blbits2, 0, BL_CODES2, MAX_BL_BITS2);
    }
    function init_block2(s2) {
      var n;
      for (n = 0; n < L_CODES2; n++) {
        s2.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES2; n++) {
        s2.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES2; n++) {
        s2.bl_tree[n * 2] = 0;
      }
      s2.dyn_ltree[END_BLOCK2 * 2] = 1;
      s2.opt_len = s2.static_len = 0;
      s2.last_lit = s2.matches = 0;
    }
    function bi_windup2(s2) {
      if (s2.bi_valid > 8) {
        put_short2(s2, s2.bi_buf);
      } else if (s2.bi_valid > 0) {
        s2.pending_buf[s2.pending++] = s2.bi_buf;
      }
      s2.bi_buf = 0;
      s2.bi_valid = 0;
    }
    function copy_block2(s2, buf, len, header) {
      bi_windup2(s2);
      if (header) {
        put_short2(s2, len);
        put_short2(s2, ~len);
      }
      utils2.arraySet(s2.pending_buf, s2.window, buf, len, s2.pending);
      s2.pending += len;
    }
    function smaller2(tree, n, m2, depth) {
      var _n2 = n * 2;
      var _m2 = m2 * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m2];
    }
    function pqdownheap2(s2, tree, k) {
      var v2 = s2.heap[k];
      var j = k << 1;
      while (j <= s2.heap_len) {
        if (j < s2.heap_len && smaller2(tree, s2.heap[j + 1], s2.heap[j], s2.depth)) {
          j++;
        }
        if (smaller2(tree, v2, s2.heap[j], s2.depth)) {
          break;
        }
        s2.heap[k] = s2.heap[j];
        k = j;
        j <<= 1;
      }
      s2.heap[k] = v2;
    }
    function compress_block2(s2, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code3;
      var extra;
      if (s2.last_lit !== 0) {
        do {
          dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
          lc = s2.pending_buf[s2.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code2(s2, lc, ltree);
          } else {
            code3 = _length_code2[lc];
            send_code2(s2, code3 + LITERALS2 + 1, ltree);
            extra = extra_lbits2[code3];
            if (extra !== 0) {
              lc -= base_length2[code3];
              send_bits2(s2, lc, extra);
            }
            dist--;
            code3 = d_code2(dist);
            send_code2(s2, code3, dtree);
            extra = extra_dbits2[code3];
            if (extra !== 0) {
              dist -= base_dist2[code3];
              send_bits2(s2, dist, extra);
            }
          }
        } while (lx < s2.last_lit);
      }
      send_code2(s2, END_BLOCK2, ltree);
    }
    function build_tree2(s2, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m2;
      var max_code = -1;
      var node;
      s2.heap_len = 0;
      s2.heap_max = HEAP_SIZE2;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s2.heap[++s2.heap_len] = max_code = n;
          s2.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s2.heap_len < 2) {
        node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s2.depth[node] = 0;
        s2.opt_len--;
        if (has_stree) {
          s2.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s2.heap_len >> 1; n >= 1; n--) {
        pqdownheap2(s2, tree, n);
      }
      node = elems;
      do {
        n = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[
          1
          /*SMALLEST*/
        ] = s2.heap[s2.heap_len--];
        pqdownheap2(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
        m2 = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[--s2.heap_max] = n;
        s2.heap[--s2.heap_max] = m2;
        tree[node * 2] = tree[n * 2] + tree[m2 * 2];
        s2.depth[node] = (s2.depth[n] >= s2.depth[m2] ? s2.depth[n] : s2.depth[m2]) + 1;
        tree[n * 2 + 1] = tree[m2 * 2 + 1] = node;
        s2.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap2(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s2.heap_len >= 2);
      s2.heap[--s2.heap_max] = s2.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen2(s2, desc);
      gen_codes2(tree, max_code, s2.bl_count);
    }
    function scan_tree2(s2, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s2.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s2.bl_tree[curlen * 2]++;
          }
          s2.bl_tree[REP_3_62 * 2]++;
        } else if (count <= 10) {
          s2.bl_tree[REPZ_3_102 * 2]++;
        } else {
          s2.bl_tree[REPZ_11_1382 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree2(s2, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code2(s2, curlen, s2.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code2(s2, curlen, s2.bl_tree);
            count--;
          }
          send_code2(s2, REP_3_62, s2.bl_tree);
          send_bits2(s2, count - 3, 2);
        } else if (count <= 10) {
          send_code2(s2, REPZ_3_102, s2.bl_tree);
          send_bits2(s2, count - 3, 3);
        } else {
          send_code2(s2, REPZ_11_1382, s2.bl_tree);
          send_bits2(s2, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree2(s2) {
      var max_blindex;
      scan_tree2(s2, s2.dyn_ltree, s2.l_desc.max_code);
      scan_tree2(s2, s2.dyn_dtree, s2.d_desc.max_code);
      build_tree2(s2, s2.bl_desc);
      for (max_blindex = BL_CODES2 - 1; max_blindex >= 3; max_blindex--) {
        if (s2.bl_tree[bl_order2[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees2(s2, lcodes, dcodes, blcodes) {
      var rank2;
      send_bits2(s2, lcodes - 257, 5);
      send_bits2(s2, dcodes - 1, 5);
      send_bits2(s2, blcodes - 4, 4);
      for (rank2 = 0; rank2 < blcodes; rank2++) {
        send_bits2(s2, s2.bl_tree[bl_order2[rank2] * 2 + 1], 3);
      }
      send_tree2(s2, s2.dyn_ltree, lcodes - 1);
      send_tree2(s2, s2.dyn_dtree, dcodes - 1);
    }
    function detect_data_type2(s2) {
      var black_mask = 4093624447;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s2.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY2;
        }
      }
      if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT2;
      }
      for (n = 32; n < LITERALS2; n++) {
        if (s2.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT2;
        }
      }
      return Z_BINARY2;
    }
    var static_init_done2 = false;
    function _tr_init2(s2) {
      if (!static_init_done2) {
        tr_static_init2();
        static_init_done2 = true;
      }
      s2.l_desc = new TreeDesc2(s2.dyn_ltree, static_l_desc2);
      s2.d_desc = new TreeDesc2(s2.dyn_dtree, static_d_desc2);
      s2.bl_desc = new TreeDesc2(s2.bl_tree, static_bl_desc2);
      s2.bi_buf = 0;
      s2.bi_valid = 0;
      init_block2(s2);
    }
    function _tr_stored_block2(s2, buf, stored_len, last3) {
      send_bits2(s2, (STORED_BLOCK2 << 1) + (last3 ? 1 : 0), 3);
      copy_block2(s2, buf, stored_len, true);
    }
    function _tr_align2(s2) {
      send_bits2(s2, STATIC_TREES2 << 1, 3);
      send_code2(s2, END_BLOCK2, static_ltree2);
      bi_flush2(s2);
    }
    function _tr_flush_block2(s2, buf, stored_len, last3) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s2.level > 0) {
        if (s2.strm.data_type === Z_UNKNOWN2) {
          s2.strm.data_type = detect_data_type2(s2);
        }
        build_tree2(s2, s2.l_desc);
        build_tree2(s2, s2.d_desc);
        max_blindex = build_bl_tree2(s2);
        opt_lenb = s2.opt_len + 3 + 7 >>> 3;
        static_lenb = s2.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block2(s2, buf, stored_len, last3);
      } else if (s2.strategy === Z_FIXED2 || static_lenb === opt_lenb) {
        send_bits2(s2, (STATIC_TREES2 << 1) + (last3 ? 1 : 0), 3);
        compress_block2(s2, static_ltree2, static_dtree2);
      } else {
        send_bits2(s2, (DYN_TREES2 << 1) + (last3 ? 1 : 0), 3);
        send_all_trees2(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
        compress_block2(s2, s2.dyn_ltree, s2.dyn_dtree);
      }
      init_block2(s2);
      if (last3) {
        bi_windup2(s2);
      }
    }
    function _tr_tally2(s2, dist, lc) {
      s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
      s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
      s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
      s2.last_lit++;
      if (dist === 0) {
        s2.dyn_ltree[lc * 2]++;
      } else {
        s2.matches++;
        dist--;
        s2.dyn_ltree[(_length_code2[lc] + LITERALS2 + 1) * 2]++;
        s2.dyn_dtree[d_code2(dist) * 2]++;
      }
      return s2.last_lit === s2.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init2;
    exports._tr_stored_block = _tr_stored_block2;
    exports._tr_flush_block = _tr_flush_block2;
    exports._tr_tally = _tr_tally2;
    exports._tr_align = _tr_align2;
  }
});

// ../node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "../node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    "use strict";
    function adler322(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module.exports = adler322;
  }
});

// ../node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "../node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    "use strict";
    function makeTable2() {
      var c2, table = [];
      for (var n = 0; n < 256; n++) {
        c2 = n;
        for (var k = 0; k < 8; k++) {
          c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
        }
        table[n] = c2;
      }
      return table;
    }
    var crcTable2 = makeTable2();
    function crc322(crc, buf, len, pos) {
      var t2 = crcTable2, end3 = pos + len;
      crc ^= -1;
      for (var i = pos; i < end3; i++) {
        crc = crc >>> 8 ^ t2[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    module.exports = crc322;
  }
});

// ../node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "../node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    module.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// ../node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "../node_modules/pako/lib/zlib/deflate.js"(exports) {
    "use strict";
    var utils2 = require_common();
    var trees2 = require_trees();
    var adler322 = require_adler32();
    var crc322 = require_crc32();
    var msg2 = require_messages();
    var Z_NO_FLUSH2 = 0;
    var Z_PARTIAL_FLUSH2 = 1;
    var Z_FULL_FLUSH2 = 3;
    var Z_FINISH2 = 4;
    var Z_BLOCK2 = 5;
    var Z_OK2 = 0;
    var Z_STREAM_END2 = 1;
    var Z_STREAM_ERROR2 = -2;
    var Z_DATA_ERROR2 = -3;
    var Z_BUF_ERROR2 = -5;
    var Z_DEFAULT_COMPRESSION2 = -1;
    var Z_FILTERED2 = 1;
    var Z_HUFFMAN_ONLY2 = 2;
    var Z_RLE2 = 3;
    var Z_FIXED2 = 4;
    var Z_DEFAULT_STRATEGY2 = 0;
    var Z_UNKNOWN2 = 2;
    var Z_DEFLATED2 = 8;
    var MAX_MEM_LEVEL2 = 9;
    var MAX_WBITS2 = 15;
    var DEF_MEM_LEVEL2 = 8;
    var LENGTH_CODES2 = 29;
    var LITERALS2 = 256;
    var L_CODES2 = LITERALS2 + 1 + LENGTH_CODES2;
    var D_CODES2 = 30;
    var BL_CODES2 = 19;
    var HEAP_SIZE2 = 2 * L_CODES2 + 1;
    var MAX_BITS2 = 15;
    var MIN_MATCH2 = 3;
    var MAX_MATCH2 = 258;
    var MIN_LOOKAHEAD2 = MAX_MATCH2 + MIN_MATCH2 + 1;
    var PRESET_DICT2 = 32;
    var INIT_STATE2 = 42;
    var EXTRA_STATE2 = 69;
    var NAME_STATE2 = 73;
    var COMMENT_STATE2 = 91;
    var HCRC_STATE2 = 103;
    var BUSY_STATE2 = 113;
    var FINISH_STATE2 = 666;
    var BS_NEED_MORE2 = 1;
    var BS_BLOCK_DONE2 = 2;
    var BS_FINISH_STARTED2 = 3;
    var BS_FINISH_DONE2 = 4;
    var OS_CODE2 = 3;
    function err2(strm, errorCode) {
      strm.msg = msg2[errorCode];
      return errorCode;
    }
    function rank2(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero2(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending2(strm) {
      var s2 = strm.state;
      var len = s2.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils2.arraySet(strm.output, s2.pending_buf, s2.pending_out, len, strm.next_out);
      strm.next_out += len;
      s2.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s2.pending -= len;
      if (s2.pending === 0) {
        s2.pending_out = 0;
      }
    }
    function flush_block_only2(s2, last3) {
      trees2._tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last3);
      s2.block_start = s2.strstart;
      flush_pending2(s2.strm);
    }
    function put_byte2(s2, b) {
      s2.pending_buf[s2.pending++] = b;
    }
    function putShortMSB2(s2, b) {
      s2.pending_buf[s2.pending++] = b >>> 8 & 255;
      s2.pending_buf[s2.pending++] = b & 255;
    }
    function read_buf2(strm, buf, start3, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils2.arraySet(buf, strm.input, strm.next_in, len, start3);
      if (strm.state.wrap === 1) {
        strm.adler = adler322(strm.adler, buf, len, start3);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc322(strm.adler, buf, len, start3);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match2(s2, cur_match) {
      var chain_length = s2.max_chain_length;
      var scan = s2.strstart;
      var match;
      var len;
      var best_len = s2.prev_length;
      var nice_match = s2.nice_match;
      var limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD2 ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD2) : 0;
      var _win = s2.window;
      var wmask = s2.w_mask;
      var prev = s2.prev;
      var strend = s2.strstart + MAX_MATCH2;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s2.prev_length >= s2.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s2.lookahead) {
        nice_match = s2.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH2 - (strend - scan);
        scan = strend - MAX_MATCH2;
        if (len > best_len) {
          s2.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s2.lookahead) {
        return best_len;
      }
      return s2.lookahead;
    }
    function fill_window2(s2) {
      var _w_size = s2.w_size;
      var p, n, m2, more, str;
      do {
        more = s2.window_size - s2.lookahead - s2.strstart;
        if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD2)) {
          utils2.arraySet(s2.window, s2.window, _w_size, _w_size, 0);
          s2.match_start -= _w_size;
          s2.strstart -= _w_size;
          s2.block_start -= _w_size;
          n = s2.hash_size;
          p = n;
          do {
            m2 = s2.head[--p];
            s2.head[p] = m2 >= _w_size ? m2 - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m2 = s2.prev[--p];
            s2.prev[p] = m2 >= _w_size ? m2 - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s2.strm.avail_in === 0) {
          break;
        }
        n = read_buf2(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
        s2.lookahead += n;
        if (s2.lookahead + s2.insert >= MIN_MATCH2) {
          str = s2.strstart - s2.insert;
          s2.ins_h = s2.window[str];
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + 1]) & s2.hash_mask;
          while (s2.insert) {
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH2 - 1]) & s2.hash_mask;
            s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = str;
            str++;
            s2.insert--;
            if (s2.lookahead + s2.insert < MIN_MATCH2) {
              break;
            }
          }
        }
      } while (s2.lookahead < MIN_LOOKAHEAD2 && s2.strm.avail_in !== 0);
    }
    function deflate_stored2(s2, flush) {
      var max_block_size = 65535;
      if (max_block_size > s2.pending_buf_size - 5) {
        max_block_size = s2.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s2.lookahead <= 1) {
          fill_window2(s2);
          if (s2.lookahead === 0 && flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE2;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.strstart += s2.lookahead;
        s2.lookahead = 0;
        var max_start = s2.block_start + max_block_size;
        if (s2.strstart === 0 || s2.strstart >= max_start) {
          s2.lookahead = s2.strstart - max_start;
          s2.strstart = max_start;
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
        if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD2) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH2) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.strstart > s2.block_start) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_NEED_MORE2;
    }
    function deflate_fast2(s2, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD2) {
          fill_window2(s2);
          if (s2.lookahead < MIN_LOOKAHEAD2 && flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE2;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH2) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH2 - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD2) {
          s2.match_length = longest_match2(s2, hash_head);
        }
        if (s2.match_length >= MIN_MATCH2) {
          bflush = trees2._tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH2);
          s2.lookahead -= s2.match_length;
          if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH2) {
            s2.match_length--;
            do {
              s2.strstart++;
              s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH2 - 1]) & s2.hash_mask;
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            } while (--s2.match_length !== 0);
            s2.strstart++;
          } else {
            s2.strstart += s2.match_length;
            s2.match_length = 0;
            s2.ins_h = s2.window[s2.strstart];
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + 1]) & s2.hash_mask;
          }
        } else {
          bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s2.insert = s2.strstart < MIN_MATCH2 - 1 ? s2.strstart : MIN_MATCH2 - 1;
      if (flush === Z_FINISH2) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.last_lit) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    }
    function deflate_slow2(s2, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD2) {
          fill_window2(s2);
          if (s2.lookahead < MIN_LOOKAHEAD2 && flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE2;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH2) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH2 - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        s2.prev_length = s2.match_length;
        s2.prev_match = s2.match_start;
        s2.match_length = MIN_MATCH2 - 1;
        if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD2) {
          s2.match_length = longest_match2(s2, hash_head);
          if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED2 || s2.match_length === MIN_MATCH2 && s2.strstart - s2.match_start > 4096)) {
            s2.match_length = MIN_MATCH2 - 1;
          }
        }
        if (s2.prev_length >= MIN_MATCH2 && s2.match_length <= s2.prev_length) {
          max_insert = s2.strstart + s2.lookahead - MIN_MATCH2;
          bflush = trees2._tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH2);
          s2.lookahead -= s2.prev_length - 1;
          s2.prev_length -= 2;
          do {
            if (++s2.strstart <= max_insert) {
              s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH2 - 1]) & s2.hash_mask;
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            }
          } while (--s2.prev_length !== 0);
          s2.match_available = 0;
          s2.match_length = MIN_MATCH2 - 1;
          s2.strstart++;
          if (bflush) {
            flush_block_only2(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE2;
            }
          }
        } else if (s2.match_available) {
          bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
          if (bflush) {
            flush_block_only2(s2, false);
          }
          s2.strstart++;
          s2.lookahead--;
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        } else {
          s2.match_available = 1;
          s2.strstart++;
          s2.lookahead--;
        }
      }
      if (s2.match_available) {
        bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
        s2.match_available = 0;
      }
      s2.insert = s2.strstart < MIN_MATCH2 - 1 ? s2.strstart : MIN_MATCH2 - 1;
      if (flush === Z_FINISH2) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.last_lit) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    }
    function deflate_rle2(s2, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s2.window;
      for (; ; ) {
        if (s2.lookahead <= MAX_MATCH2) {
          fill_window2(s2);
          if (s2.lookahead <= MAX_MATCH2 && flush === Z_NO_FLUSH2) {
            return BS_NEED_MORE2;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.match_length = 0;
        if (s2.lookahead >= MIN_MATCH2 && s2.strstart > 0) {
          scan = s2.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s2.strstart + MAX_MATCH2;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s2.match_length = MAX_MATCH2 - (strend - scan);
            if (s2.match_length > s2.lookahead) {
              s2.match_length = s2.lookahead;
            }
          }
        }
        if (s2.match_length >= MIN_MATCH2) {
          bflush = trees2._tr_tally(s2, 1, s2.match_length - MIN_MATCH2);
          s2.lookahead -= s2.match_length;
          s2.strstart += s2.match_length;
          s2.match_length = 0;
        } else {
          bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH2) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.last_lit) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    }
    function deflate_huff2(s2, flush) {
      var bflush;
      for (; ; ) {
        if (s2.lookahead === 0) {
          fill_window2(s2);
          if (s2.lookahead === 0) {
            if (flush === Z_NO_FLUSH2) {
              return BS_NEED_MORE2;
            }
            break;
          }
        }
        s2.match_length = 0;
        bflush = trees2._tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
        if (bflush) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH2) {
        flush_block_only2(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED2;
        }
        return BS_FINISH_DONE2;
      }
      if (s2.last_lit) {
        flush_block_only2(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE2;
        }
      }
      return BS_BLOCK_DONE2;
    }
    function Config2(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table2;
    configuration_table2 = [
      /*      good lazy nice chain */
      new Config2(0, 0, 0, 0, deflate_stored2),
      /* 0 store only */
      new Config2(4, 4, 8, 4, deflate_fast2),
      /* 1 max speed, no lazy matches */
      new Config2(4, 5, 16, 8, deflate_fast2),
      /* 2 */
      new Config2(4, 6, 32, 32, deflate_fast2),
      /* 3 */
      new Config2(4, 4, 16, 16, deflate_slow2),
      /* 4 lazy matches */
      new Config2(8, 16, 32, 32, deflate_slow2),
      /* 5 */
      new Config2(8, 16, 128, 128, deflate_slow2),
      /* 6 */
      new Config2(8, 32, 128, 256, deflate_slow2),
      /* 7 */
      new Config2(32, 128, 258, 1024, deflate_slow2),
      /* 8 */
      new Config2(32, 258, 258, 4096, deflate_slow2)
      /* 9 max compression */
    ];
    function lm_init2(s2) {
      s2.window_size = 2 * s2.w_size;
      zero2(s2.head);
      s2.max_lazy_match = configuration_table2[s2.level].max_lazy;
      s2.good_match = configuration_table2[s2.level].good_length;
      s2.nice_match = configuration_table2[s2.level].nice_length;
      s2.max_chain_length = configuration_table2[s2.level].max_chain;
      s2.strstart = 0;
      s2.block_start = 0;
      s2.lookahead = 0;
      s2.insert = 0;
      s2.match_length = s2.prev_length = MIN_MATCH2 - 1;
      s2.match_available = 0;
      s2.ins_h = 0;
    }
    function DeflateState2() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED2;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils2.Buf16(HEAP_SIZE2 * 2);
      this.dyn_dtree = new utils2.Buf16((2 * D_CODES2 + 1) * 2);
      this.bl_tree = new utils2.Buf16((2 * BL_CODES2 + 1) * 2);
      zero2(this.dyn_ltree);
      zero2(this.dyn_dtree);
      zero2(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils2.Buf16(MAX_BITS2 + 1);
      this.heap = new utils2.Buf16(2 * L_CODES2 + 1);
      zero2(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils2.Buf16(2 * L_CODES2 + 1);
      zero2(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep2(strm) {
      var s2;
      if (!strm || !strm.state) {
        return err2(strm, Z_STREAM_ERROR2);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN2;
      s2 = strm.state;
      s2.pending = 0;
      s2.pending_out = 0;
      if (s2.wrap < 0) {
        s2.wrap = -s2.wrap;
      }
      s2.status = s2.wrap ? INIT_STATE2 : BUSY_STATE2;
      strm.adler = s2.wrap === 2 ? 0 : 1;
      s2.last_flush = Z_NO_FLUSH2;
      trees2._tr_init(s2);
      return Z_OK2;
    }
    function deflateReset2(strm) {
      var ret = deflateResetKeep2(strm);
      if (ret === Z_OK2) {
        lm_init2(strm.state);
      }
      return ret;
    }
    function deflateSetHeader2(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR2;
      }
      strm.state.gzhead = head;
      return Z_OK2;
    }
    function deflateInit22(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR2;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION2) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL2 || method !== Z_DEFLATED2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED2) {
        return err2(strm, Z_STREAM_ERROR2);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s2 = new DeflateState2();
      strm.state = s2;
      s2.strm = strm;
      s2.wrap = wrap;
      s2.gzhead = null;
      s2.w_bits = windowBits;
      s2.w_size = 1 << s2.w_bits;
      s2.w_mask = s2.w_size - 1;
      s2.hash_bits = memLevel + 7;
      s2.hash_size = 1 << s2.hash_bits;
      s2.hash_mask = s2.hash_size - 1;
      s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH2 - 1) / MIN_MATCH2);
      s2.window = new utils2.Buf8(s2.w_size * 2);
      s2.head = new utils2.Buf16(s2.hash_size);
      s2.prev = new utils2.Buf16(s2.w_size);
      s2.lit_bufsize = 1 << memLevel + 6;
      s2.pending_buf_size = s2.lit_bufsize * 4;
      s2.pending_buf = new utils2.Buf8(s2.pending_buf_size);
      s2.d_buf = 1 * s2.lit_bufsize;
      s2.l_buf = (1 + 2) * s2.lit_bufsize;
      s2.level = level;
      s2.strategy = strategy;
      s2.method = method;
      return deflateReset2(strm);
    }
    function deflateInit3(strm, level) {
      return deflateInit22(strm, level, Z_DEFLATED2, MAX_WBITS2, DEF_MEM_LEVEL2, Z_DEFAULT_STRATEGY2);
    }
    function deflate2(strm, flush) {
      var old_flush, s2;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK2 || flush < 0) {
        return strm ? err2(strm, Z_STREAM_ERROR2) : Z_STREAM_ERROR2;
      }
      s2 = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE2 && flush !== Z_FINISH2) {
        return err2(strm, strm.avail_out === 0 ? Z_BUF_ERROR2 : Z_STREAM_ERROR2);
      }
      s2.strm = strm;
      old_flush = s2.last_flush;
      s2.last_flush = flush;
      if (s2.status === INIT_STATE2) {
        if (s2.wrap === 2) {
          strm.adler = 0;
          put_byte2(s2, 31);
          put_byte2(s2, 139);
          put_byte2(s2, 8);
          if (!s2.gzhead) {
            put_byte2(s2, 0);
            put_byte2(s2, 0);
            put_byte2(s2, 0);
            put_byte2(s2, 0);
            put_byte2(s2, 0);
            put_byte2(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY2 || s2.level < 2 ? 4 : 0);
            put_byte2(s2, OS_CODE2);
            s2.status = BUSY_STATE2;
          } else {
            put_byte2(
              s2,
              (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16)
            );
            put_byte2(s2, s2.gzhead.time & 255);
            put_byte2(s2, s2.gzhead.time >> 8 & 255);
            put_byte2(s2, s2.gzhead.time >> 16 & 255);
            put_byte2(s2, s2.gzhead.time >> 24 & 255);
            put_byte2(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY2 || s2.level < 2 ? 4 : 0);
            put_byte2(s2, s2.gzhead.os & 255);
            if (s2.gzhead.extra && s2.gzhead.extra.length) {
              put_byte2(s2, s2.gzhead.extra.length & 255);
              put_byte2(s2, s2.gzhead.extra.length >> 8 & 255);
            }
            if (s2.gzhead.hcrc) {
              strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending, 0);
            }
            s2.gzindex = 0;
            s2.status = EXTRA_STATE2;
          }
        } else {
          var header = Z_DEFLATED2 + (s2.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s2.strategy >= Z_HUFFMAN_ONLY2 || s2.level < 2) {
            level_flags = 0;
          } else if (s2.level < 6) {
            level_flags = 1;
          } else if (s2.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s2.strstart !== 0) {
            header |= PRESET_DICT2;
          }
          header += 31 - header % 31;
          s2.status = BUSY_STATE2;
          putShortMSB2(s2, header);
          if (s2.strstart !== 0) {
            putShortMSB2(s2, strm.adler >>> 16);
            putShortMSB2(s2, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s2.status === EXTRA_STATE2) {
        if (s2.gzhead.extra) {
          beg = s2.pending;
          while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending2(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                break;
              }
            }
            put_byte2(s2, s2.gzhead.extra[s2.gzindex] & 255);
            s2.gzindex++;
          }
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (s2.gzindex === s2.gzhead.extra.length) {
            s2.gzindex = 0;
            s2.status = NAME_STATE2;
          }
        } else {
          s2.status = NAME_STATE2;
        }
      }
      if (s2.status === NAME_STATE2) {
        if (s2.gzhead.name) {
          beg = s2.pending;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending2(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s2.gzindex < s2.gzhead.name.length) {
              val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte2(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (val === 0) {
            s2.gzindex = 0;
            s2.status = COMMENT_STATE2;
          }
        } else {
          s2.status = COMMENT_STATE2;
        }
      }
      if (s2.status === COMMENT_STATE2) {
        if (s2.gzhead.comment) {
          beg = s2.pending;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending2(strm);
              beg = s2.pending;
              if (s2.pending === s2.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s2.gzindex < s2.gzhead.comment.length) {
              val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte2(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc322(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          if (val === 0) {
            s2.status = HCRC_STATE2;
          }
        } else {
          s2.status = HCRC_STATE2;
        }
      }
      if (s2.status === HCRC_STATE2) {
        if (s2.gzhead.hcrc) {
          if (s2.pending + 2 > s2.pending_buf_size) {
            flush_pending2(strm);
          }
          if (s2.pending + 2 <= s2.pending_buf_size) {
            put_byte2(s2, strm.adler & 255);
            put_byte2(s2, strm.adler >> 8 & 255);
            strm.adler = 0;
            s2.status = BUSY_STATE2;
          }
        } else {
          s2.status = BUSY_STATE2;
        }
      }
      if (s2.pending !== 0) {
        flush_pending2(strm);
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
          return Z_OK2;
        }
      } else if (strm.avail_in === 0 && rank2(flush) <= rank2(old_flush) && flush !== Z_FINISH2) {
        return err2(strm, Z_BUF_ERROR2);
      }
      if (s2.status === FINISH_STATE2 && strm.avail_in !== 0) {
        return err2(strm, Z_BUF_ERROR2);
      }
      if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH2 && s2.status !== FINISH_STATE2) {
        var bstate = s2.strategy === Z_HUFFMAN_ONLY2 ? deflate_huff2(s2, flush) : s2.strategy === Z_RLE2 ? deflate_rle2(s2, flush) : configuration_table2[s2.level].func(s2, flush);
        if (bstate === BS_FINISH_STARTED2 || bstate === BS_FINISH_DONE2) {
          s2.status = FINISH_STATE2;
        }
        if (bstate === BS_NEED_MORE2 || bstate === BS_FINISH_STARTED2) {
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
          }
          return Z_OK2;
        }
        if (bstate === BS_BLOCK_DONE2) {
          if (flush === Z_PARTIAL_FLUSH2) {
            trees2._tr_align(s2);
          } else if (flush !== Z_BLOCK2) {
            trees2._tr_stored_block(s2, 0, 0, false);
            if (flush === Z_FULL_FLUSH2) {
              zero2(s2.head);
              if (s2.lookahead === 0) {
                s2.strstart = 0;
                s2.block_start = 0;
                s2.insert = 0;
              }
            }
          }
          flush_pending2(strm);
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
            return Z_OK2;
          }
        }
      }
      if (flush !== Z_FINISH2) {
        return Z_OK2;
      }
      if (s2.wrap <= 0) {
        return Z_STREAM_END2;
      }
      if (s2.wrap === 2) {
        put_byte2(s2, strm.adler & 255);
        put_byte2(s2, strm.adler >> 8 & 255);
        put_byte2(s2, strm.adler >> 16 & 255);
        put_byte2(s2, strm.adler >> 24 & 255);
        put_byte2(s2, strm.total_in & 255);
        put_byte2(s2, strm.total_in >> 8 & 255);
        put_byte2(s2, strm.total_in >> 16 & 255);
        put_byte2(s2, strm.total_in >> 24 & 255);
      } else {
        putShortMSB2(s2, strm.adler >>> 16);
        putShortMSB2(s2, strm.adler & 65535);
      }
      flush_pending2(strm);
      if (s2.wrap > 0) {
        s2.wrap = -s2.wrap;
      }
      return s2.pending !== 0 ? Z_OK2 : Z_STREAM_END2;
    }
    function deflateEnd2(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      status = strm.state.status;
      if (status !== INIT_STATE2 && status !== EXTRA_STATE2 && status !== NAME_STATE2 && status !== COMMENT_STATE2 && status !== HCRC_STATE2 && status !== BUSY_STATE2 && status !== FINISH_STATE2) {
        return err2(strm, Z_STREAM_ERROR2);
      }
      strm.state = null;
      return status === BUSY_STATE2 ? err2(strm, Z_DATA_ERROR2) : Z_OK2;
    }
    function deflateSetDictionary2(strm, dictionary) {
      var dictLength = dictionary.length;
      var s2;
      var str, n;
      var wrap;
      var avail;
      var next2;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      s2 = strm.state;
      wrap = s2.wrap;
      if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE2 || s2.lookahead) {
        return Z_STREAM_ERROR2;
      }
      if (wrap === 1) {
        strm.adler = adler322(strm.adler, dictionary, dictLength, 0);
      }
      s2.wrap = 0;
      if (dictLength >= s2.w_size) {
        if (wrap === 0) {
          zero2(s2.head);
          s2.strstart = 0;
          s2.block_start = 0;
          s2.insert = 0;
        }
        tmpDict = new utils2.Buf8(s2.w_size);
        utils2.arraySet(tmpDict, dictionary, dictLength - s2.w_size, s2.w_size, 0);
        dictionary = tmpDict;
        dictLength = s2.w_size;
      }
      avail = strm.avail_in;
      next2 = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window2(s2);
      while (s2.lookahead >= MIN_MATCH2) {
        str = s2.strstart;
        n = s2.lookahead - (MIN_MATCH2 - 1);
        do {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH2 - 1]) & s2.hash_mask;
          s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = str;
          str++;
        } while (--n);
        s2.strstart = str;
        s2.lookahead = MIN_MATCH2 - 1;
        fill_window2(s2);
      }
      s2.strstart += s2.lookahead;
      s2.block_start = s2.strstart;
      s2.insert = s2.lookahead;
      s2.lookahead = 0;
      s2.match_length = s2.prev_length = MIN_MATCH2 - 1;
      s2.match_available = 0;
      strm.next_in = next2;
      strm.input = input;
      strm.avail_in = avail;
      s2.wrap = wrap;
      return Z_OK2;
    }
    exports.deflateInit = deflateInit3;
    exports.deflateInit2 = deflateInit22;
    exports.deflateReset = deflateReset2;
    exports.deflateResetKeep = deflateResetKeep2;
    exports.deflateSetHeader = deflateSetHeader2;
    exports.deflate = deflate2;
    exports.deflateEnd = deflateEnd2;
    exports.deflateSetDictionary = deflateSetDictionary2;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// ../node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "../node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    var BAD2 = 30;
    var TYPE2 = 12;
    module.exports = function inflate_fast3(strm, start3) {
      var state2;
      var _in;
      var last3;
      var _out;
      var beg;
      var end3;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from4;
      var from_source;
      var input, output;
      state2 = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last3 = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start3 - strm.avail_out);
      end3 = _out + (strm.avail_out - 257);
      dmax = state2.dmax;
      wsize = state2.wsize;
      whave = state2.whave;
      wnext = state2.wnext;
      s_window = state2.window;
      hold = state2.hold;
      bits = state2.bits;
      lcode = state2.lencode;
      dcode = state2.distcode;
      lmask = (1 << state2.lenbits) - 1;
      dmask = (1 << state2.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state2.mode = BAD2;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state2.sane) {
                            strm.msg = "invalid distance too far back";
                            state2.mode = BAD2;
                            break top;
                          }
                        }
                        from4 = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from4 += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from4++];
                            } while (--op);
                            from4 = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from4 += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from4++];
                            } while (--op);
                            from4 = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from4++];
                              } while (--op);
                              from4 = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from4 += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from4++];
                            } while (--op);
                            from4 = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from4++];
                          output[_out++] = from_source[from4++];
                          output[_out++] = from_source[from4++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from4++];
                          if (len > 1) {
                            output[_out++] = from_source[from4++];
                          }
                        }
                      } else {
                        from4 = _out - dist;
                        do {
                          output[_out++] = output[from4++];
                          output[_out++] = output[from4++];
                          output[_out++] = output[from4++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from4++];
                          if (len > 1) {
                            output[_out++] = output[from4++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state2.mode = BAD2;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state2.mode = TYPE2;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state2.mode = BAD2;
                break top;
              }
              break;
            }
        } while (_in < last3 && _out < end3);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last3 ? 5 + (last3 - _in) : 5 - (_in - last3);
      strm.avail_out = _out < end3 ? 257 + (end3 - _out) : 257 - (_out - end3);
      state2.hold = hold;
      state2.bits = bits;
      return;
    };
  }
});

// ../node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "../node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    var utils2 = require_common();
    var MAXBITS2 = 15;
    var ENOUGH_LENS2 = 852;
    var ENOUGH_DISTS2 = 592;
    var CODES2 = 0;
    var LENS2 = 1;
    var DISTS2 = 2;
    var lbase2 = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext2 = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase2 = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext2 = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module.exports = function inflate_table3(type, lens, lens_index, codes3, table, table_index, work, opts2) {
      var bits = opts2.bits;
      var len = 0;
      var sym = 0;
      var min3 = 0, max3 = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill5;
      var low;
      var mask;
      var next2;
      var base = null;
      var base_index = 0;
      var end3;
      var count = new utils2.Buf16(MAXBITS2 + 1);
      var offs = new utils2.Buf16(MAXBITS2 + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS2; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes3; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max3 = MAXBITS2; max3 >= 1; max3--) {
        if (count[max3] !== 0) {
          break;
        }
      }
      if (root > max3) {
        root = max3;
      }
      if (max3 === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts2.bits = 1;
        return 0;
      }
      for (min3 = 1; min3 < max3; min3++) {
        if (count[min3] !== 0) {
          break;
        }
      }
      if (root < min3) {
        root = min3;
      }
      left = 1;
      for (len = 1; len <= MAXBITS2; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES2 || max3 !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS2; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes3; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES2) {
        base = extra = work;
        end3 = 19;
      } else if (type === LENS2) {
        base = lbase2;
        base_index -= 257;
        extra = lext2;
        extra_index -= 257;
        end3 = 256;
      } else {
        base = dbase2;
        extra = dext2;
        end3 = -1;
      }
      huff = 0;
      sym = 0;
      len = min3;
      next2 = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS2 && used > ENOUGH_LENS2 || type === DISTS2 && used > ENOUGH_DISTS2) {
        return 1;
      }
      var i = 0;
      for (; ; ) {
        i++;
        here_bits = len - drop;
        if (work[sym] < end3) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end3) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill5 = 1 << curr;
        min3 = fill5;
        do {
          fill5 -= incr;
          table[next2 + (huff >> drop) + fill5] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill5 !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max3) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next2 += min3;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max3) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS2 && used > ENOUGH_LENS2 || type === DISTS2 && used > ENOUGH_DISTS2) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next2 - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next2 + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts2.bits = root;
      return 0;
    };
  }
});

// ../node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "../node_modules/pako/lib/zlib/inflate.js"(exports) {
    "use strict";
    var utils2 = require_common();
    var adler322 = require_adler32();
    var crc322 = require_crc32();
    var inflate_fast3 = require_inffast();
    var inflate_table3 = require_inftrees();
    var CODES2 = 0;
    var LENS2 = 1;
    var DISTS2 = 2;
    var Z_FINISH2 = 4;
    var Z_BLOCK2 = 5;
    var Z_TREES2 = 6;
    var Z_OK2 = 0;
    var Z_STREAM_END2 = 1;
    var Z_NEED_DICT2 = 2;
    var Z_STREAM_ERROR2 = -2;
    var Z_DATA_ERROR2 = -3;
    var Z_MEM_ERROR2 = -4;
    var Z_BUF_ERROR2 = -5;
    var Z_DEFLATED2 = 8;
    var HEAD2 = 1;
    var FLAGS2 = 2;
    var TIME2 = 3;
    var OS2 = 4;
    var EXLEN2 = 5;
    var EXTRA2 = 6;
    var NAME2 = 7;
    var COMMENT2 = 8;
    var HCRC2 = 9;
    var DICTID2 = 10;
    var DICT2 = 11;
    var TYPE2 = 12;
    var TYPEDO2 = 13;
    var STORED2 = 14;
    var COPY_2 = 15;
    var COPY2 = 16;
    var TABLE2 = 17;
    var LENLENS2 = 18;
    var CODELENS2 = 19;
    var LEN_2 = 20;
    var LEN2 = 21;
    var LENEXT2 = 22;
    var DIST2 = 23;
    var DISTEXT2 = 24;
    var MATCH2 = 25;
    var LIT2 = 26;
    var CHECK2 = 27;
    var LENGTH2 = 28;
    var DONE2 = 29;
    var BAD2 = 30;
    var MEM2 = 31;
    var SYNC2 = 32;
    var ENOUGH_LENS2 = 852;
    var ENOUGH_DISTS2 = 592;
    var MAX_WBITS2 = 15;
    var DEF_WBITS2 = MAX_WBITS2;
    function zswap322(q2) {
      return (q2 >>> 24 & 255) + (q2 >>> 8 & 65280) + ((q2 & 65280) << 8) + ((q2 & 255) << 24);
    }
    function InflateState2() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils2.Buf16(320);
      this.work = new utils2.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep2(strm) {
      var state2;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      strm.total_in = strm.total_out = state2.total = 0;
      strm.msg = "";
      if (state2.wrap) {
        strm.adler = state2.wrap & 1;
      }
      state2.mode = HEAD2;
      state2.last = 0;
      state2.havedict = 0;
      state2.dmax = 32768;
      state2.head = null;
      state2.hold = 0;
      state2.bits = 0;
      state2.lencode = state2.lendyn = new utils2.Buf32(ENOUGH_LENS2);
      state2.distcode = state2.distdyn = new utils2.Buf32(ENOUGH_DISTS2);
      state2.sane = 1;
      state2.back = -1;
      return Z_OK2;
    }
    function inflateReset3(strm) {
      var state2;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      state2.wsize = 0;
      state2.whave = 0;
      state2.wnext = 0;
      return inflateResetKeep2(strm);
    }
    function inflateReset22(strm, windowBits) {
      var wrap;
      var state2;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR2;
      }
      if (state2.window !== null && state2.wbits !== windowBits) {
        state2.window = null;
      }
      state2.wrap = wrap;
      state2.wbits = windowBits;
      return inflateReset3(strm);
    }
    function inflateInit22(strm, windowBits) {
      var ret;
      var state2;
      if (!strm) {
        return Z_STREAM_ERROR2;
      }
      state2 = new InflateState2();
      strm.state = state2;
      state2.window = null;
      ret = inflateReset22(strm, windowBits);
      if (ret !== Z_OK2) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit3(strm) {
      return inflateInit22(strm, DEF_WBITS2);
    }
    var virgin2 = true;
    var lenfix2;
    var distfix2;
    function fixedtables2(state2) {
      if (virgin2) {
        var sym;
        lenfix2 = new utils2.Buf32(512);
        distfix2 = new utils2.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state2.lens[sym++] = 8;
        }
        while (sym < 256) {
          state2.lens[sym++] = 9;
        }
        while (sym < 280) {
          state2.lens[sym++] = 7;
        }
        while (sym < 288) {
          state2.lens[sym++] = 8;
        }
        inflate_table3(LENS2, state2.lens, 0, 288, lenfix2, 0, state2.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state2.lens[sym++] = 5;
        }
        inflate_table3(DISTS2, state2.lens, 0, 32, distfix2, 0, state2.work, { bits: 5 });
        virgin2 = false;
      }
      state2.lencode = lenfix2;
      state2.lenbits = 9;
      state2.distcode = distfix2;
      state2.distbits = 5;
    }
    function updatewindow2(strm, src3, end3, copy6) {
      var dist;
      var state2 = strm.state;
      if (state2.window === null) {
        state2.wsize = 1 << state2.wbits;
        state2.wnext = 0;
        state2.whave = 0;
        state2.window = new utils2.Buf8(state2.wsize);
      }
      if (copy6 >= state2.wsize) {
        utils2.arraySet(state2.window, src3, end3 - state2.wsize, state2.wsize, 0);
        state2.wnext = 0;
        state2.whave = state2.wsize;
      } else {
        dist = state2.wsize - state2.wnext;
        if (dist > copy6) {
          dist = copy6;
        }
        utils2.arraySet(state2.window, src3, end3 - copy6, dist, state2.wnext);
        copy6 -= dist;
        if (copy6) {
          utils2.arraySet(state2.window, src3, end3 - copy6, copy6, 0);
          state2.wnext = copy6;
          state2.whave = state2.wsize;
        } else {
          state2.wnext += dist;
          if (state2.wnext === state2.wsize) {
            state2.wnext = 0;
          }
          if (state2.whave < state2.wsize) {
            state2.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate2(strm, flush) {
      var state2;
      var input, output;
      var next2;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy6;
      var from4;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils2.Buf8(4);
      var opts2;
      var n;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      if (state2.mode === TYPE2) {
        state2.mode = TYPEDO2;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next2 = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state2.hold;
      bits = state2.bits;
      _in = have;
      _out = left;
      ret = Z_OK2;
      inf_leave:
        for (; ; ) {
          switch (state2.mode) {
            case HEAD2:
              if (state2.wrap === 0) {
                state2.mode = TYPEDO2;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              if (state2.wrap & 2 && hold === 35615) {
                state2.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state2.check = crc322(state2.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state2.mode = FLAGS2;
                break;
              }
              state2.flags = 0;
              if (state2.head) {
                state2.head.done = false;
              }
              if (!(state2.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state2.mode = BAD2;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED2) {
                strm.msg = "unknown compression method";
                state2.mode = BAD2;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state2.wbits === 0) {
                state2.wbits = len;
              } else if (len > state2.wbits) {
                strm.msg = "invalid window size";
                state2.mode = BAD2;
                break;
              }
              state2.dmax = 1 << len;
              strm.adler = state2.check = 1;
              state2.mode = hold & 512 ? DICTID2 : TYPE2;
              hold = 0;
              bits = 0;
              break;
            case FLAGS2:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              state2.flags = hold;
              if ((state2.flags & 255) !== Z_DEFLATED2) {
                strm.msg = "unknown compression method";
                state2.mode = BAD2;
                break;
              }
              if (state2.flags & 57344) {
                strm.msg = "unknown header flags set";
                state2.mode = BAD2;
                break;
              }
              if (state2.head) {
                state2.head.text = hold >> 8 & 1;
              }
              if (state2.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state2.check = crc322(state2.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state2.mode = TIME2;
            case TIME2:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              if (state2.head) {
                state2.head.time = hold;
              }
              if (state2.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state2.check = crc322(state2.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state2.mode = OS2;
            case OS2:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              if (state2.head) {
                state2.head.xflags = hold & 255;
                state2.head.os = hold >> 8;
              }
              if (state2.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state2.check = crc322(state2.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state2.mode = EXLEN2;
            case EXLEN2:
              if (state2.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                state2.length = hold;
                if (state2.head) {
                  state2.head.extra_len = hold;
                }
                if (state2.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state2.check = crc322(state2.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state2.head) {
                state2.head.extra = null;
              }
              state2.mode = EXTRA2;
            case EXTRA2:
              if (state2.flags & 1024) {
                copy6 = state2.length;
                if (copy6 > have) {
                  copy6 = have;
                }
                if (copy6) {
                  if (state2.head) {
                    len = state2.head.extra_len - state2.length;
                    if (!state2.head.extra) {
                      state2.head.extra = new Array(state2.head.extra_len);
                    }
                    utils2.arraySet(
                      state2.head.extra,
                      input,
                      next2,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy6,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state2.flags & 512) {
                    state2.check = crc322(state2.check, input, copy6, next2);
                  }
                  have -= copy6;
                  next2 += copy6;
                  state2.length -= copy6;
                }
                if (state2.length) {
                  break inf_leave;
                }
              }
              state2.length = 0;
              state2.mode = NAME2;
            case NAME2:
              if (state2.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy6 = 0;
                do {
                  len = input[next2 + copy6++];
                  if (state2.head && len && state2.length < 65536) {
                    state2.head.name += String.fromCharCode(len);
                  }
                } while (len && copy6 < have);
                if (state2.flags & 512) {
                  state2.check = crc322(state2.check, input, copy6, next2);
                }
                have -= copy6;
                next2 += copy6;
                if (len) {
                  break inf_leave;
                }
              } else if (state2.head) {
                state2.head.name = null;
              }
              state2.length = 0;
              state2.mode = COMMENT2;
            case COMMENT2:
              if (state2.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy6 = 0;
                do {
                  len = input[next2 + copy6++];
                  if (state2.head && len && state2.length < 65536) {
                    state2.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy6 < have);
                if (state2.flags & 512) {
                  state2.check = crc322(state2.check, input, copy6, next2);
                }
                have -= copy6;
                next2 += copy6;
                if (len) {
                  break inf_leave;
                }
              } else if (state2.head) {
                state2.head.comment = null;
              }
              state2.mode = HCRC2;
            case HCRC2:
              if (state2.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                if (hold !== (state2.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state2.mode = BAD2;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state2.head) {
                state2.head.hcrc = state2.flags >> 9 & 1;
                state2.head.done = true;
              }
              strm.adler = state2.check = 0;
              state2.mode = TYPE2;
              break;
            case DICTID2:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              strm.adler = state2.check = zswap322(hold);
              hold = 0;
              bits = 0;
              state2.mode = DICT2;
            case DICT2:
              if (state2.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next2;
                strm.avail_in = have;
                state2.hold = hold;
                state2.bits = bits;
                return Z_NEED_DICT2;
              }
              strm.adler = state2.check = 1;
              state2.mode = TYPE2;
            case TYPE2:
              if (flush === Z_BLOCK2 || flush === Z_TREES2) {
                break inf_leave;
              }
            case TYPEDO2:
              if (state2.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state2.mode = CHECK2;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              state2.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state2.mode = STORED2;
                  break;
                case 1:
                  fixedtables2(state2);
                  state2.mode = LEN_2;
                  if (flush === Z_TREES2) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state2.mode = TABLE2;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state2.mode = BAD2;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED2:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state2.mode = BAD2;
                break;
              }
              state2.length = hold & 65535;
              hold = 0;
              bits = 0;
              state2.mode = COPY_2;
              if (flush === Z_TREES2) {
                break inf_leave;
              }
            case COPY_2:
              state2.mode = COPY2;
            case COPY2:
              copy6 = state2.length;
              if (copy6) {
                if (copy6 > have) {
                  copy6 = have;
                }
                if (copy6 > left) {
                  copy6 = left;
                }
                if (copy6 === 0) {
                  break inf_leave;
                }
                utils2.arraySet(output, input, next2, copy6, put);
                have -= copy6;
                next2 += copy6;
                left -= copy6;
                put += copy6;
                state2.length -= copy6;
                break;
              }
              state2.mode = TYPE2;
              break;
            case TABLE2:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              state2.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state2.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state2.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state2.nlen > 286 || state2.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state2.mode = BAD2;
                break;
              }
              state2.have = 0;
              state2.mode = LENLENS2;
            case LENLENS2:
              while (state2.have < state2.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                state2.lens[order[state2.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state2.have < 19) {
                state2.lens[order[state2.have++]] = 0;
              }
              state2.lencode = state2.lendyn;
              state2.lenbits = 7;
              opts2 = { bits: state2.lenbits };
              ret = inflate_table3(CODES2, state2.lens, 0, 19, state2.lencode, 0, state2.work, opts2);
              state2.lenbits = opts2.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state2.mode = BAD2;
                break;
              }
              state2.have = 0;
              state2.mode = CODELENS2;
            case CODELENS2:
              while (state2.have < state2.nlen + state2.ndist) {
                for (; ; ) {
                  here = state2.lencode[hold & (1 << state2.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state2.lens[state2.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state2.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state2.mode = BAD2;
                      break;
                    }
                    len = state2.lens[state2.have - 1];
                    copy6 = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy6 = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy6 = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state2.have + copy6 > state2.nlen + state2.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state2.mode = BAD2;
                    break;
                  }
                  while (copy6--) {
                    state2.lens[state2.have++] = len;
                  }
                }
              }
              if (state2.mode === BAD2) {
                break;
              }
              if (state2.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state2.mode = BAD2;
                break;
              }
              state2.lenbits = 9;
              opts2 = { bits: state2.lenbits };
              ret = inflate_table3(LENS2, state2.lens, 0, state2.nlen, state2.lencode, 0, state2.work, opts2);
              state2.lenbits = opts2.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state2.mode = BAD2;
                break;
              }
              state2.distbits = 6;
              state2.distcode = state2.distdyn;
              opts2 = { bits: state2.distbits };
              ret = inflate_table3(DISTS2, state2.lens, state2.nlen, state2.ndist, state2.distcode, 0, state2.work, opts2);
              state2.distbits = opts2.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state2.mode = BAD2;
                break;
              }
              state2.mode = LEN_2;
              if (flush === Z_TREES2) {
                break inf_leave;
              }
            case LEN_2:
              state2.mode = LEN2;
            case LEN2:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next2;
                strm.avail_in = have;
                state2.hold = hold;
                state2.bits = bits;
                inflate_fast3(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next2 = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state2.hold;
                bits = state2.bits;
                if (state2.mode === TYPE2) {
                  state2.back = -1;
                }
                break;
              }
              state2.back = 0;
              for (; ; ) {
                here = state2.lencode[hold & (1 << state2.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state2.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state2.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state2.back += here_bits;
              state2.length = here_val;
              if (here_op === 0) {
                state2.mode = LIT2;
                break;
              }
              if (here_op & 32) {
                state2.back = -1;
                state2.mode = TYPE2;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state2.mode = BAD2;
                break;
              }
              state2.extra = here_op & 15;
              state2.mode = LENEXT2;
            case LENEXT2:
              if (state2.extra) {
                n = state2.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                state2.length += hold & (1 << state2.extra) - 1;
                hold >>>= state2.extra;
                bits -= state2.extra;
                state2.back += state2.extra;
              }
              state2.was = state2.length;
              state2.mode = DIST2;
            case DIST2:
              for (; ; ) {
                here = state2.distcode[hold & (1 << state2.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state2.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state2.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state2.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state2.mode = BAD2;
                break;
              }
              state2.offset = here_val;
              state2.extra = here_op & 15;
              state2.mode = DISTEXT2;
            case DISTEXT2:
              if (state2.extra) {
                n = state2.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                state2.offset += hold & (1 << state2.extra) - 1;
                hold >>>= state2.extra;
                bits -= state2.extra;
                state2.back += state2.extra;
              }
              if (state2.offset > state2.dmax) {
                strm.msg = "invalid distance too far back";
                state2.mode = BAD2;
                break;
              }
              state2.mode = MATCH2;
            case MATCH2:
              if (left === 0) {
                break inf_leave;
              }
              copy6 = _out - left;
              if (state2.offset > copy6) {
                copy6 = state2.offset - copy6;
                if (copy6 > state2.whave) {
                  if (state2.sane) {
                    strm.msg = "invalid distance too far back";
                    state2.mode = BAD2;
                    break;
                  }
                }
                if (copy6 > state2.wnext) {
                  copy6 -= state2.wnext;
                  from4 = state2.wsize - copy6;
                } else {
                  from4 = state2.wnext - copy6;
                }
                if (copy6 > state2.length) {
                  copy6 = state2.length;
                }
                from_source = state2.window;
              } else {
                from_source = output;
                from4 = put - state2.offset;
                copy6 = state2.length;
              }
              if (copy6 > left) {
                copy6 = left;
              }
              left -= copy6;
              state2.length -= copy6;
              do {
                output[put++] = from_source[from4++];
              } while (--copy6);
              if (state2.length === 0) {
                state2.mode = LEN2;
              }
              break;
            case LIT2:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state2.length;
              left--;
              state2.mode = LEN2;
              break;
            case CHECK2:
              if (state2.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next2++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state2.total += _out;
                if (_out) {
                  strm.adler = state2.check = /*UPDATE(state.check, put - _out, _out);*/
                  state2.flags ? crc322(state2.check, output, _out, put - _out) : adler322(state2.check, output, _out, put - _out);
                }
                _out = left;
                if ((state2.flags ? hold : zswap322(hold)) !== state2.check) {
                  strm.msg = "incorrect data check";
                  state2.mode = BAD2;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state2.mode = LENGTH2;
            case LENGTH2:
              if (state2.wrap && state2.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                if (hold !== (state2.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state2.mode = BAD2;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state2.mode = DONE2;
            case DONE2:
              ret = Z_STREAM_END2;
              break inf_leave;
            case BAD2:
              ret = Z_DATA_ERROR2;
              break inf_leave;
            case MEM2:
              return Z_MEM_ERROR2;
            case SYNC2:
            default:
              return Z_STREAM_ERROR2;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next2;
      strm.avail_in = have;
      state2.hold = hold;
      state2.bits = bits;
      if (state2.wsize || _out !== strm.avail_out && state2.mode < BAD2 && (state2.mode < CHECK2 || flush !== Z_FINISH2)) {
        if (updatewindow2(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state2.mode = MEM2;
          return Z_MEM_ERROR2;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state2.total += _out;
      if (state2.wrap && _out) {
        strm.adler = state2.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state2.flags ? crc322(state2.check, output, _out, strm.next_out - _out) : adler322(state2.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state2.bits + (state2.last ? 64 : 0) + (state2.mode === TYPE2 ? 128 : 0) + (state2.mode === LEN_2 || state2.mode === COPY_2 ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH2) && ret === Z_OK2) {
        ret = Z_BUF_ERROR2;
      }
      return ret;
    }
    function inflateEnd2(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      var state2 = strm.state;
      if (state2.window) {
        state2.window = null;
      }
      strm.state = null;
      return Z_OK2;
    }
    function inflateGetHeader2(strm, head) {
      var state2;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      if ((state2.wrap & 2) === 0) {
        return Z_STREAM_ERROR2;
      }
      state2.head = head;
      head.done = false;
      return Z_OK2;
    }
    function inflateSetDictionary2(strm, dictionary) {
      var dictLength = dictionary.length;
      var state2;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR2;
      }
      state2 = strm.state;
      if (state2.wrap !== 0 && state2.mode !== DICT2) {
        return Z_STREAM_ERROR2;
      }
      if (state2.mode === DICT2) {
        dictid = 1;
        dictid = adler322(dictid, dictionary, dictLength, 0);
        if (dictid !== state2.check) {
          return Z_DATA_ERROR2;
        }
      }
      ret = updatewindow2(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state2.mode = MEM2;
        return Z_MEM_ERROR2;
      }
      state2.havedict = 1;
      return Z_OK2;
    }
    exports.inflateReset = inflateReset3;
    exports.inflateReset2 = inflateReset22;
    exports.inflateResetKeep = inflateResetKeep2;
    exports.inflateInit = inflateInit3;
    exports.inflateInit2 = inflateInit22;
    exports.inflate = inflate2;
    exports.inflateEnd = inflateEnd2;
    exports.inflateGetHeader = inflateGetHeader2;
    exports.inflateSetDictionary = inflateSetDictionary2;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// ../node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "../node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../node_modules/crypto-js/core.js
var require_core = __commonJS({
  "../node_modules/crypto-js/core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS2 = CryptoJS2 || function(Math2, undefined2) {
        var crypto;
        if (typeof window !== "undefined" && window.crypto) {
          crypto = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto = globalThis.crypto;
        }
        if (!crypto && typeof window !== "undefined" && window.msCrypto) {
          crypto = window.msCrypto;
        }
        if (!crypto && typeof global !== "undefined" && global.crypto) {
          crypto = global.crypto;
        }
        if (!crypto && typeof __require === "function") {
          try {
            crypto = require_crypto();
          } catch (err2) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto) {
            if (typeof crypto.getRandomValues === "function") {
              try {
                return crypto.getRandomValues(new Uint32Array(1))[0];
              } catch (err2) {
              }
            }
            if (typeof crypto.randomBytes === "function") {
              try {
                return crypto.randomBytes(4).readInt32LE();
              } catch (err2) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create2 = Object.create || function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C2 = {};
        var C_lib = C2.lib = {};
        var Base2 = C_lib.Base = function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create2(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base2.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base2.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C2.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base2.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data2) {
            if (typeof data2 == "string") {
              data2 = Utf8.parse(data2);
            }
            this._data.concat(data2);
            this._nDataBytes += data2.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data2 = this._data;
            var dataWords = data2.words;
            var dataSigBytes = data2.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset3 = 0; offset3 < nWordsReady; offset3 += blockSize) {
                this._doProcessBlock(dataWords, offset3);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data2.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base2.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base2.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C2.algo = {};
        return C2;
      }(Math);
      return CryptoJS2;
    });
  }
});

// ../node_modules/crypto-js/md5.js
var require_md5 = __commonJS({
  "../node_modules/crypto-js/md5.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(Math2) {
        var C2 = CryptoJS2;
        var C_lib = C2.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C2.algo;
        var T2 = [];
        (function() {
          for (var i = 0; i < 64; i++) {
            T2[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
          }
        })();
        var MD52 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M2, offset3) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset3 + i;
              var M_offset_i = M2[offset_i];
              M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H2 = this._hash.words;
            var M_offset_0 = M2[offset3 + 0];
            var M_offset_1 = M2[offset3 + 1];
            var M_offset_2 = M2[offset3 + 2];
            var M_offset_3 = M2[offset3 + 3];
            var M_offset_4 = M2[offset3 + 4];
            var M_offset_5 = M2[offset3 + 5];
            var M_offset_6 = M2[offset3 + 6];
            var M_offset_7 = M2[offset3 + 7];
            var M_offset_8 = M2[offset3 + 8];
            var M_offset_9 = M2[offset3 + 9];
            var M_offset_10 = M2[offset3 + 10];
            var M_offset_11 = M2[offset3 + 11];
            var M_offset_12 = M2[offset3 + 12];
            var M_offset_13 = M2[offset3 + 13];
            var M_offset_14 = M2[offset3 + 14];
            var M_offset_15 = M2[offset3 + 15];
            var a2 = H2[0];
            var b = H2[1];
            var c2 = H2[2];
            var d = H2[3];
            a2 = FF(a2, b, c2, d, M_offset_0, 7, T2[0]);
            d = FF(d, a2, b, c2, M_offset_1, 12, T2[1]);
            c2 = FF(c2, d, a2, b, M_offset_2, 17, T2[2]);
            b = FF(b, c2, d, a2, M_offset_3, 22, T2[3]);
            a2 = FF(a2, b, c2, d, M_offset_4, 7, T2[4]);
            d = FF(d, a2, b, c2, M_offset_5, 12, T2[5]);
            c2 = FF(c2, d, a2, b, M_offset_6, 17, T2[6]);
            b = FF(b, c2, d, a2, M_offset_7, 22, T2[7]);
            a2 = FF(a2, b, c2, d, M_offset_8, 7, T2[8]);
            d = FF(d, a2, b, c2, M_offset_9, 12, T2[9]);
            c2 = FF(c2, d, a2, b, M_offset_10, 17, T2[10]);
            b = FF(b, c2, d, a2, M_offset_11, 22, T2[11]);
            a2 = FF(a2, b, c2, d, M_offset_12, 7, T2[12]);
            d = FF(d, a2, b, c2, M_offset_13, 12, T2[13]);
            c2 = FF(c2, d, a2, b, M_offset_14, 17, T2[14]);
            b = FF(b, c2, d, a2, M_offset_15, 22, T2[15]);
            a2 = GG(a2, b, c2, d, M_offset_1, 5, T2[16]);
            d = GG(d, a2, b, c2, M_offset_6, 9, T2[17]);
            c2 = GG(c2, d, a2, b, M_offset_11, 14, T2[18]);
            b = GG(b, c2, d, a2, M_offset_0, 20, T2[19]);
            a2 = GG(a2, b, c2, d, M_offset_5, 5, T2[20]);
            d = GG(d, a2, b, c2, M_offset_10, 9, T2[21]);
            c2 = GG(c2, d, a2, b, M_offset_15, 14, T2[22]);
            b = GG(b, c2, d, a2, M_offset_4, 20, T2[23]);
            a2 = GG(a2, b, c2, d, M_offset_9, 5, T2[24]);
            d = GG(d, a2, b, c2, M_offset_14, 9, T2[25]);
            c2 = GG(c2, d, a2, b, M_offset_3, 14, T2[26]);
            b = GG(b, c2, d, a2, M_offset_8, 20, T2[27]);
            a2 = GG(a2, b, c2, d, M_offset_13, 5, T2[28]);
            d = GG(d, a2, b, c2, M_offset_2, 9, T2[29]);
            c2 = GG(c2, d, a2, b, M_offset_7, 14, T2[30]);
            b = GG(b, c2, d, a2, M_offset_12, 20, T2[31]);
            a2 = HH(a2, b, c2, d, M_offset_5, 4, T2[32]);
            d = HH(d, a2, b, c2, M_offset_8, 11, T2[33]);
            c2 = HH(c2, d, a2, b, M_offset_11, 16, T2[34]);
            b = HH(b, c2, d, a2, M_offset_14, 23, T2[35]);
            a2 = HH(a2, b, c2, d, M_offset_1, 4, T2[36]);
            d = HH(d, a2, b, c2, M_offset_4, 11, T2[37]);
            c2 = HH(c2, d, a2, b, M_offset_7, 16, T2[38]);
            b = HH(b, c2, d, a2, M_offset_10, 23, T2[39]);
            a2 = HH(a2, b, c2, d, M_offset_13, 4, T2[40]);
            d = HH(d, a2, b, c2, M_offset_0, 11, T2[41]);
            c2 = HH(c2, d, a2, b, M_offset_3, 16, T2[42]);
            b = HH(b, c2, d, a2, M_offset_6, 23, T2[43]);
            a2 = HH(a2, b, c2, d, M_offset_9, 4, T2[44]);
            d = HH(d, a2, b, c2, M_offset_12, 11, T2[45]);
            c2 = HH(c2, d, a2, b, M_offset_15, 16, T2[46]);
            b = HH(b, c2, d, a2, M_offset_2, 23, T2[47]);
            a2 = II(a2, b, c2, d, M_offset_0, 6, T2[48]);
            d = II(d, a2, b, c2, M_offset_7, 10, T2[49]);
            c2 = II(c2, d, a2, b, M_offset_14, 15, T2[50]);
            b = II(b, c2, d, a2, M_offset_5, 21, T2[51]);
            a2 = II(a2, b, c2, d, M_offset_12, 6, T2[52]);
            d = II(d, a2, b, c2, M_offset_3, 10, T2[53]);
            c2 = II(c2, d, a2, b, M_offset_10, 15, T2[54]);
            b = II(b, c2, d, a2, M_offset_1, 21, T2[55]);
            a2 = II(a2, b, c2, d, M_offset_8, 6, T2[56]);
            d = II(d, a2, b, c2, M_offset_15, 10, T2[57]);
            c2 = II(c2, d, a2, b, M_offset_6, 15, T2[58]);
            b = II(b, c2, d, a2, M_offset_13, 21, T2[59]);
            a2 = II(a2, b, c2, d, M_offset_4, 6, T2[60]);
            d = II(d, a2, b, c2, M_offset_11, 10, T2[61]);
            c2 = II(c2, d, a2, b, M_offset_2, 15, T2[62]);
            b = II(b, c2, d, a2, M_offset_9, 21, T2[63]);
            H2[0] = H2[0] + a2 | 0;
            H2[1] = H2[1] + b | 0;
            H2[2] = H2[2] + c2 | 0;
            H2[3] = H2[3] + d | 0;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data2.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H2 = hash.words;
            for (var i = 0; i < 4; i++) {
              var H_i = H2[i];
              H2[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a2, b, c2, d, x, s2, t2) {
          var n = a2 + (b & c2 | ~b & d) + x + t2;
          return (n << s2 | n >>> 32 - s2) + b;
        }
        function GG(a2, b, c2, d, x, s2, t2) {
          var n = a2 + (b & d | c2 & ~d) + x + t2;
          return (n << s2 | n >>> 32 - s2) + b;
        }
        function HH(a2, b, c2, d, x, s2, t2) {
          var n = a2 + (b ^ c2 ^ d) + x + t2;
          return (n << s2 | n >>> 32 - s2) + b;
        }
        function II(a2, b, c2, d, x, s2, t2) {
          var n = a2 + (c2 ^ (b | ~d)) + x + t2;
          return (n << s2 | n >>> 32 - s2) + b;
        }
        C2.MD5 = Hasher._createHelper(MD52);
        C2.HmacMD5 = Hasher._createHmacHelper(MD52);
      })(Math);
      return CryptoJS2.MD5;
    });
  }
});

// ../node_modules/postcss-value-parser/lib/parse.js
var require_parse = __commonJS({
  "../node_modules/postcss-value-parser/lib/parse.js"(exports, module) {
    var openParentheses = "(".charCodeAt(0);
    var closeParentheses = ")".charCodeAt(0);
    var singleQuote = "'".charCodeAt(0);
    var doubleQuote = '"'.charCodeAt(0);
    var backslash = "\\".charCodeAt(0);
    var slash = "/".charCodeAt(0);
    var comma = ",".charCodeAt(0);
    var colon = ":".charCodeAt(0);
    var star = "*".charCodeAt(0);
    var uLower = "u".charCodeAt(0);
    var uUpper = "U".charCodeAt(0);
    var plus = "+".charCodeAt(0);
    var isUnicodeRange = /^[a-f0-9?-]+$/i;
    module.exports = function(input) {
      var tokens = [];
      var value2 = input;
      var next2, quote, prev, token, escape2, escapePos, whitespacePos, parenthesesOpenPos;
      var pos = 0;
      var code3 = value2.charCodeAt(pos);
      var max3 = value2.length;
      var stack = [{ nodes: tokens }];
      var balanced = 0;
      var parent;
      var name = "";
      var before = "";
      var after = "";
      while (pos < max3) {
        if (code3 <= 32) {
          next2 = pos;
          do {
            next2 += 1;
            code3 = value2.charCodeAt(next2);
          } while (code3 <= 32);
          token = value2.slice(pos, next2);
          prev = tokens[tokens.length - 1];
          if (code3 === closeParentheses && balanced) {
            after = token;
          } else if (prev && prev.type === "div") {
            prev.after = token;
            prev.sourceEndIndex += token.length;
          } else if (code3 === comma || code3 === colon || code3 === slash && value2.charCodeAt(next2 + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
            before = token;
          } else {
            tokens.push({
              type: "space",
              sourceIndex: pos,
              sourceEndIndex: next2,
              value: token
            });
          }
          pos = next2;
        } else if (code3 === singleQuote || code3 === doubleQuote) {
          next2 = pos;
          quote = code3 === singleQuote ? "'" : '"';
          token = {
            type: "string",
            sourceIndex: pos,
            quote
          };
          do {
            escape2 = false;
            next2 = value2.indexOf(quote, next2 + 1);
            if (~next2) {
              escapePos = next2;
              while (value2.charCodeAt(escapePos - 1) === backslash) {
                escapePos -= 1;
                escape2 = !escape2;
              }
            } else {
              value2 += quote;
              next2 = value2.length - 1;
              token.unclosed = true;
            }
          } while (escape2);
          token.value = value2.slice(pos + 1, next2);
          token.sourceEndIndex = token.unclosed ? next2 : next2 + 1;
          tokens.push(token);
          pos = next2 + 1;
          code3 = value2.charCodeAt(pos);
        } else if (code3 === slash && value2.charCodeAt(pos + 1) === star) {
          next2 = value2.indexOf("*/", pos);
          token = {
            type: "comment",
            sourceIndex: pos,
            sourceEndIndex: next2 + 2
          };
          if (next2 === -1) {
            token.unclosed = true;
            next2 = value2.length;
            token.sourceEndIndex = next2;
          }
          token.value = value2.slice(pos + 2, next2);
          tokens.push(token);
          pos = next2 + 2;
          code3 = value2.charCodeAt(pos);
        } else if ((code3 === slash || code3 === star) && parent && parent.type === "function" && parent.value === "calc") {
          token = value2[pos];
          tokens.push({
            type: "word",
            sourceIndex: pos - before.length,
            sourceEndIndex: pos + token.length,
            value: token
          });
          pos += 1;
          code3 = value2.charCodeAt(pos);
        } else if (code3 === slash || code3 === comma || code3 === colon) {
          token = value2[pos];
          tokens.push({
            type: "div",
            sourceIndex: pos - before.length,
            sourceEndIndex: pos + token.length,
            value: token,
            before,
            after: ""
          });
          before = "";
          pos += 1;
          code3 = value2.charCodeAt(pos);
        } else if (openParentheses === code3) {
          next2 = pos;
          do {
            next2 += 1;
            code3 = value2.charCodeAt(next2);
          } while (code3 <= 32);
          parenthesesOpenPos = pos;
          token = {
            type: "function",
            sourceIndex: pos - name.length,
            value: name,
            before: value2.slice(parenthesesOpenPos + 1, next2)
          };
          pos = next2;
          if (name === "url" && code3 !== singleQuote && code3 !== doubleQuote) {
            next2 -= 1;
            do {
              escape2 = false;
              next2 = value2.indexOf(")", next2 + 1);
              if (~next2) {
                escapePos = next2;
                while (value2.charCodeAt(escapePos - 1) === backslash) {
                  escapePos -= 1;
                  escape2 = !escape2;
                }
              } else {
                value2 += ")";
                next2 = value2.length - 1;
                token.unclosed = true;
              }
            } while (escape2);
            whitespacePos = next2;
            do {
              whitespacePos -= 1;
              code3 = value2.charCodeAt(whitespacePos);
            } while (code3 <= 32);
            if (parenthesesOpenPos < whitespacePos) {
              if (pos !== whitespacePos + 1) {
                token.nodes = [
                  {
                    type: "word",
                    sourceIndex: pos,
                    sourceEndIndex: whitespacePos + 1,
                    value: value2.slice(pos, whitespacePos + 1)
                  }
                ];
              } else {
                token.nodes = [];
              }
              if (token.unclosed && whitespacePos + 1 !== next2) {
                token.after = "";
                token.nodes.push({
                  type: "space",
                  sourceIndex: whitespacePos + 1,
                  sourceEndIndex: next2,
                  value: value2.slice(whitespacePos + 1, next2)
                });
              } else {
                token.after = value2.slice(whitespacePos + 1, next2);
                token.sourceEndIndex = next2;
              }
            } else {
              token.after = "";
              token.nodes = [];
            }
            pos = next2 + 1;
            token.sourceEndIndex = token.unclosed ? next2 : pos;
            code3 = value2.charCodeAt(pos);
            tokens.push(token);
          } else {
            balanced += 1;
            token.after = "";
            token.sourceEndIndex = pos + 1;
            tokens.push(token);
            stack.push(token);
            tokens = token.nodes = [];
            parent = token;
          }
          name = "";
        } else if (closeParentheses === code3 && balanced) {
          pos += 1;
          code3 = value2.charCodeAt(pos);
          parent.after = after;
          parent.sourceEndIndex += after.length;
          after = "";
          balanced -= 1;
          stack[stack.length - 1].sourceEndIndex = pos;
          stack.pop();
          parent = stack[balanced];
          tokens = parent.nodes;
        } else {
          next2 = pos;
          do {
            if (code3 === backslash) {
              next2 += 1;
            }
            next2 += 1;
            code3 = value2.charCodeAt(next2);
          } while (next2 < max3 && !(code3 <= 32 || code3 === singleQuote || code3 === doubleQuote || code3 === comma || code3 === colon || code3 === slash || code3 === openParentheses || code3 === star && parent && parent.type === "function" && parent.value === "calc" || code3 === slash && parent.type === "function" && parent.value === "calc" || code3 === closeParentheses && balanced));
          token = value2.slice(pos, next2);
          if (openParentheses === code3) {
            name = token;
          } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
            tokens.push({
              type: "unicode-range",
              sourceIndex: pos,
              sourceEndIndex: next2,
              value: token
            });
          } else {
            tokens.push({
              type: "word",
              sourceIndex: pos,
              sourceEndIndex: next2,
              value: token
            });
          }
          pos = next2;
        }
      }
      for (pos = stack.length - 1; pos; pos -= 1) {
        stack[pos].unclosed = true;
        stack[pos].sourceEndIndex = value2.length;
      }
      return stack[0].nodes;
    };
  }
});

// ../node_modules/postcss-value-parser/lib/unit.js
var require_unit = __commonJS({
  "../node_modules/postcss-value-parser/lib/unit.js"(exports, module) {
    var minus = "-".charCodeAt(0);
    var plus = "+".charCodeAt(0);
    var dot = ".".charCodeAt(0);
    var exp = "e".charCodeAt(0);
    var EXP = "E".charCodeAt(0);
    function likeNumber(value2) {
      var code3 = value2.charCodeAt(0);
      var nextCode;
      if (code3 === plus || code3 === minus) {
        nextCode = value2.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        var nextNextCode = value2.charCodeAt(2);
        if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code3 === dot) {
        nextCode = value2.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code3 >= 48 && code3 <= 57) {
        return true;
      }
      return false;
    }
    module.exports = function(value2) {
      var pos = 0;
      var length4 = value2.length;
      var code3;
      var nextCode;
      var nextNextCode;
      if (length4 === 0 || !likeNumber(value2)) {
        return false;
      }
      code3 = value2.charCodeAt(pos);
      if (code3 === plus || code3 === minus) {
        pos++;
      }
      while (pos < length4) {
        code3 = value2.charCodeAt(pos);
        if (code3 < 48 || code3 > 57) {
          break;
        }
        pos += 1;
      }
      code3 = value2.charCodeAt(pos);
      nextCode = value2.charCodeAt(pos + 1);
      if (code3 === dot && nextCode >= 48 && nextCode <= 57) {
        pos += 2;
        while (pos < length4) {
          code3 = value2.charCodeAt(pos);
          if (code3 < 48 || code3 > 57) {
            break;
          }
          pos += 1;
        }
      }
      code3 = value2.charCodeAt(pos);
      nextCode = value2.charCodeAt(pos + 1);
      nextNextCode = value2.charCodeAt(pos + 2);
      if ((code3 === exp || code3 === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
        pos += nextCode === plus || nextCode === minus ? 3 : 2;
        while (pos < length4) {
          code3 = value2.charCodeAt(pos);
          if (code3 < 48 || code3 > 57) {
            break;
          }
          pos += 1;
        }
      }
      return {
        number: value2.slice(0, pos),
        unit: value2.slice(pos)
      };
    };
  }
});

// ../node_modules/hsl-to-rgb-for-reals/converter.js
var require_converter = __commonJS({
  "../node_modules/hsl-to-rgb-for-reals/converter.js"(exports, module) {
    var hslToRgb = function(hue, saturation, lightness) {
      if (hue == void 0) {
        return [0, 0, 0];
      }
      var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;
      var huePrime = hue / 60;
      var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
      huePrime = Math.floor(huePrime);
      var red3;
      var green3;
      var blue3;
      if (huePrime === 0) {
        red3 = chroma;
        green3 = secondComponent;
        blue3 = 0;
      } else if (huePrime === 1) {
        red3 = secondComponent;
        green3 = chroma;
        blue3 = 0;
      } else if (huePrime === 2) {
        red3 = 0;
        green3 = chroma;
        blue3 = secondComponent;
      } else if (huePrime === 3) {
        red3 = 0;
        green3 = secondComponent;
        blue3 = chroma;
      } else if (huePrime === 4) {
        red3 = secondComponent;
        green3 = 0;
        blue3 = chroma;
      } else if (huePrime === 5) {
        red3 = chroma;
        green3 = 0;
        blue3 = secondComponent;
      }
      var lightnessAdjustment = lightness - chroma / 2;
      red3 += lightnessAdjustment;
      green3 += lightnessAdjustment;
      blue3 += lightnessAdjustment;
      return [
        Math.abs(Math.round(red3 * 255)),
        Math.abs(Math.round(green3 * 255)),
        Math.abs(Math.round(blue3 * 255))
      ];
    };
    module.exports = hslToRgb;
  }
});

// ../node_modules/hsl-to-hex/index.js
var require_hsl_to_hex = __commonJS({
  "../node_modules/hsl-to-hex/index.js"(exports, module) {
    var toRgb = require_converter();
    function max3(val, n) {
      return val > n ? n : val;
    }
    function min3(val, n) {
      return val < n ? n : val;
    }
    function cycle(val) {
      val = max3(val, 1e7);
      val = min3(val, -1e7);
      while (val < 0) {
        val += 360;
      }
      while (val > 359) {
        val -= 360;
      }
      return val;
    }
    function hsl(hue, saturation, luminosity) {
      hue = cycle(hue);
      saturation = min3(max3(saturation, 100), 0);
      luminosity = min3(max3(luminosity, 100), 0);
      saturation /= 100;
      luminosity /= 100;
      var rgb = toRgb(hue, saturation, luminosity);
      return "#" + rgb.map(function(n) {
        return (256 + n).toString(16).substr(-2);
      }).join("");
    }
    module.exports = hsl;
  }
});

// ../node_modules/media-engine/src/queries.js
var require_queries = __commonJS({
  "../node_modules/media-engine/src/queries.js"(exports, module) {
    function MaxHeight(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value >= options.height;
      };
    }
    function MinHeight(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value < options.height;
      };
    }
    function MaxWidth(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value >= options.width;
      };
    }
    function MinWidth(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value < options.width;
      };
    }
    function Orientation(value2) {
      this.value = value2;
      this.match = function(options) {
        return this.value === options.orientation;
      };
    }
    module.exports = function Query(type, value2) {
      switch (type) {
        case "max-height":
          return new MaxHeight(value2);
        case "min-height":
          return new MinHeight(value2);
        case "max-width":
          return new MaxWidth(value2);
        case "min-width":
          return new MinWidth(value2);
        case "orientation":
          return new Orientation(value2);
        default:
          throw new Error(value2);
      }
    };
  }
});

// ../node_modules/media-engine/src/operators.js
var require_operators = __commonJS({
  "../node_modules/media-engine/src/operators.js"(exports, module) {
    function And(left, right) {
      this.left = left;
      this.right = right;
      this.match = function(options) {
        return left.match(options) && right.match(options);
      };
    }
    function Or(left, right) {
      this.left = left;
      this.right = right;
      this.match = function(options) {
        return left.match(options) || right.match(options);
      };
    }
    module.exports = function Operator(type, left, right) {
      switch (type) {
        case "and":
          return new And(left, right);
        case ",":
          return new Or(left, right);
        default:
          throw new Error(value);
      }
    };
  }
});

// ../node_modules/media-engine/src/parser.js
var require_parser = __commonJS({
  "../node_modules/media-engine/src/parser.js"(exports, module) {
    var Query = require_queries();
    var Operator = require_operators();
    var NUMBERS = /[0-9]/;
    var LETTERS = /[a-z|\-]/i;
    var WHITESPACE = /\s/;
    var COLON = /:/;
    var COMMA = /,/;
    var AND = /and$/;
    var AT = /@/;
    function tokenizer(input) {
      var current = 0;
      var tokens = [];
      while (current < input.length) {
        var char = input[current];
        if (AT.test(char)) {
          char = input[++current];
          while (LETTERS.test(char) && char !== void 0) {
            char = input[++current];
          }
        }
        if (WHITESPACE.test(char) || char === ")" || char === "(") {
          current++;
          continue;
        }
        if (COLON.test(char) || COMMA.test(char)) {
          current++;
          tokens.push({ type: "operator", value: char });
          continue;
        }
        if (NUMBERS.test(char)) {
          var value2 = "";
          while (NUMBERS.test(char)) {
            value2 += char;
            char = input[++current];
          }
          tokens.push({ type: "number", value: value2 });
          continue;
        }
        if (LETTERS.test(char)) {
          var value2 = "";
          while (LETTERS.test(char) && char !== void 0) {
            value2 += char;
            char = input[++current];
          }
          if (AND.test(value2)) {
            tokens.push({ type: "operator", value: value2 });
          } else {
            tokens.push({ type: "literal", value: value2 });
          }
          continue;
        }
        throw new TypeError(
          "Tokenizer: I dont know what this character is: " + char
        );
      }
      return tokens;
    }
    function parser(tokens) {
      var output = [];
      var stack = [];
      while (tokens.length > 0) {
        var token = tokens.shift();
        if (token.type === "number" || token.type === "literal") {
          output.push(token);
          continue;
        }
        if (token.type === "operator") {
          if (COLON.test(token.value)) {
            token = { type: "query", key: output.pop(), value: tokens.shift() };
            output.push(token);
            continue;
          }
          while (stack.length > 0) {
            output.unshift(stack.pop());
          }
          stack.push(token);
        }
      }
      while (stack.length > 0) {
        output.unshift(stack.pop());
      }
      function walk() {
        var head = output.shift();
        if (head.type === "number") {
          return parseInt(head.value);
        }
        if (head.type === "literal") {
          return head.value;
        }
        if (head.type === "operator") {
          var l2 = walk();
          var r = walk();
          return Operator(head.value, l2, r);
        }
        if (head.type === "query") {
          var l2 = head.key.value;
          var r = head.value.value;
          return Query(l2, r);
        }
      }
      return walk();
    }
    module.exports = {
      parse: function(query) {
        var tokens = tokenizer(query);
        var ast = parser(tokens);
        return ast;
      }
    };
  }
});

// ../node_modules/media-engine/src/index.js
var require_src = __commonJS({
  "../node_modules/media-engine/src/index.js"(exports, module) {
    var Parser = require_parser();
    module.exports = function(queries, options) {
      var result = {};
      Object.keys(queries).forEach(function(query) {
        if (Parser.parse(query).match(options)) {
          Object.assign(result, queries[query]);
        }
      });
      return result;
    };
  }
});

// ../node_modules/hyphen/hyphen.js
var require_hyphen = __commonJS({
  "../node_modules/hyphen/hyphen.js"(exports, module) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root.createHyphenator = factory();
      }
    })(exports, function() {
      var SETTING_DEFAULT_ASYNC = false, SETTING_DEFAULT_DEBUG = false, SETTING_DEFAULT_HTML = false, SETTING_DEFAULT_HYPH_CHAR = "­", SETTING_DEFAULT_MIN_WORD_LENGTH = 5, SETTING_NAME_ASYNC = "async", SETTING_NAME_DEBUG = "debug", SETTING_NAME_HTML = "html", SETTING_NAME_HYPH_CHAR = "hyphenChar", SETTING_NAME_MIN_WORD_LENGTH = "minWordLength";
      var _global = typeof global === "object" ? global : typeof window === "object" ? window : typeof this === "object" ? this : {};
      function cloneObj(source) {
        var target = {};
        for (var key in source) {
          target[key] = source[key];
        }
        return target;
      }
      function keyOrDefault(object, key, defaultValue) {
        if (key in object) {
          return object[key];
        }
        return defaultValue;
      }
      function exceptionsFromDefinition(patternsDefinition, hyphenChar) {
        return patternsDefinition.exceptions.reduce(
          function(exceptions, exception) {
            exceptions[exception.replace(/\-/g, "")] = exception.replace(
              /\-/g,
              hyphenChar
            );
            return exceptions;
          },
          {}
        );
      }
      function createHyphenator(patternsDefinition, options) {
        options = options || {};
        var asyncMode = keyOrDefault(
          options,
          SETTING_NAME_ASYNC,
          SETTING_DEFAULT_ASYNC
        ), caches = {}, debug3 = keyOrDefault(options, SETTING_NAME_DEBUG, SETTING_DEFAULT_DEBUG), exceptions = {}, hyphenChar = keyOrDefault(
          options,
          SETTING_NAME_HYPH_CHAR,
          SETTING_DEFAULT_HYPH_CHAR
        ), patterns = patternsDefinition.patterns.map(preprocessPattern), minWordLength = keyOrDefault(
          options,
          SETTING_NAME_MIN_WORD_LENGTH,
          SETTING_DEFAULT_MIN_WORD_LENGTH
        ) >> 0, skipHTML = keyOrDefault(options, SETTING_NAME_HTML, SETTING_DEFAULT_HTML);
        var cacheKey = hyphenChar + minWordLength;
        exceptions[cacheKey] = exceptionsFromDefinition(
          patternsDefinition,
          hyphenChar
        );
        caches[cacheKey] = cloneObj(exceptions[cacheKey]);
        if (asyncMode && !("Promise" in _global)) {
          throw new Error(
            "Failed to create hyphenator: Could not find global Promise object, needed for hyphenator to work in async mode"
          );
        }
        return function(text2, options2) {
          options2 = options2 || {};
          var localDebug = keyOrDefault(options2, SETTING_NAME_DEBUG, debug3), localHyphenChar = keyOrDefault(
            options2,
            SETTING_NAME_HYPH_CHAR,
            hyphenChar
          ), localMinWordLength = keyOrDefault(options2, SETTING_NAME_MIN_WORD_LENGTH, minWordLength) >> 0, cacheKey2 = localHyphenChar + localMinWordLength;
          if (!exceptions[cacheKey2]) {
            exceptions[cacheKey2] = exceptionsFromDefinition(
              patternsDefinition,
              localHyphenChar
            );
          }
          if (!caches[cacheKey2]) {
            caches[cacheKey2] = cloneObj(exceptions[cacheKey2]);
          }
          return start3(
            text2,
            patterns,
            caches[cacheKey2],
            localDebug,
            localHyphenChar,
            skipHTML,
            localMinWordLength,
            asyncMode
          );
        };
      }
      function createTextChunkReader(text2, hyphenChar, skipHTML, minWordLength) {
        function readNextTextChunk() {
          var nextTextChunk = "";
          shouldHyphenate = void 0;
          chunkReader:
            while (nextCharIndex <= text2.length) {
              var nextChar = text2.charAt(nextCharIndex++), charIsLetter = !!nextChar && !/\s|[\!-\@\[-\`\{-\~\u2013-\u203C]/.test(nextChar), charIsAngleOpen = nextChar === "<", charIsAngleClose = nextChar === ">", charIsHyphen = nextChar === hyphenChar;
              do {
                if (state2 === STATE_READ_TAG) {
                  if (charIsAngleClose) {
                    state2 = STATE_RETURN_UNTOUCHED;
                  }
                  break;
                }
                if (charIsHyphen) {
                  shouldHyphenate = SHOULD_SKIP;
                  state2 = STATE_READ_WORD;
                  break;
                }
                if (charIsLetter) {
                  state2 = STATE_READ_WORD;
                  break;
                }
                if (state2 === STATE_READ_WORD) {
                  state2 = STATE_RETURN_WORD;
                  shouldHyphenate = shouldHyphenate || nextTextChunk.length >= minWordLength && SHOULD_HYPHENATE;
                  break;
                }
                shouldHyphenate = SHOULD_SKIP;
                state2 = STATE_RETURN_UNTOUCHED;
              } while (0);
              if (charIsAngleOpen && state2 !== STATE_RETURN_WORD && skipHTML && !isSpacelike(text2.charAt(nextCharIndex))) {
                shouldHyphenate = SHOULD_SKIP;
                state2 = STATE_READ_TAG;
              }
              switch (state2) {
                case STATE_READ_TAG:
                  nextTextChunk += nextChar;
                  break;
                case STATE_READ_WORD:
                  nextTextChunk += nextChar;
                  break;
                case STATE_RETURN_UNTOUCHED:
                  nextTextChunk += nextChar;
                  break chunkReader;
                case STATE_RETURN_WORD:
                  nextCharIndex--;
                  break chunkReader;
              }
            }
          return nextTextChunk || void 0;
        }
        function shouldNextHyphenate() {
          return shouldHyphenate === SHOULD_HYPHENATE;
        }
        var isSpacelike = RegExp.prototype.test.bind(/\s/);
        var nextCharIndex = 0, SHOULD_HYPHENATE = 1, SHOULD_SKIP = 2, shouldHyphenate, STATE_READ_TAG = 1, STATE_READ_WORD = 2, STATE_RETURN_UNTOUCHED = 3, STATE_RETURN_WORD = 4, state2;
        return [readNextTextChunk, shouldNextHyphenate];
      }
      function hyphenateWord(text2, patterns, debug3, hyphenChar) {
        var levels = new Array(text2.length + 1), loweredText = text2.toLocaleLowerCase(), p = [], patternData, patternIndex = 0;
        for (var i = levels.length; i--; )
          levels[i] = 0;
        while (patternData = patterns[patternIndex++]) {
          var fromChar = 0, endPattern = false;
          while (!endPattern) {
            var patternEntityIndex = loweredText.indexOf(patternData.text, fromChar), patternFits = patternEntityIndex > -1 && (patternData.stickToLeft ? patternEntityIndex === 0 : true) && (patternData.stickToRight ? patternEntityIndex + patternData.text.length === text2.length : true);
            if (patternFits) {
              p.push(patternData.pattern + ">" + patternData.levels.join(""));
              for (var i = 0; i < patternData.levels.length; i++)
                levels[patternEntityIndex + i] = Math.max(
                  patternData.levels[i],
                  levels[patternEntityIndex + i]
                );
            }
            if (patternEntityIndex > -1 && patternData.text.length > 0) {
              fromChar = patternEntityIndex + patternData.text.length + 1;
            } else {
              endPattern = true;
            }
          }
        }
        levels[0] = levels[1] = levels[levels.length - 1] = levels[levels.length - 2] = 0;
        var hyphenatedText = "", leveledText = "", debugHyphenatedText = "";
        for (var i = 0; i < levels.length; i++) {
          hyphenatedText += (levels[i] % 2 === 1 ? hyphenChar : "") + text2.charAt(i);
          debugHyphenatedText += (levels[i] % 2 === 1 ? "-" : "") + text2.charAt(i);
          leveledText += (levels[i] > 0 ? levels[i] : "") + text2.charAt(i);
        }
        if (debug3)
          console.log.apply(
            console,
            [text2, "->"].concat(p).concat(["->"]).concat(levels).concat(["->", leveledText]).concat(["->", debugHyphenatedText])
          );
        return hyphenatedText;
      }
      function preprocessPattern(pattern2) {
        var patternCharIndex = 0, patternChar, patternData = {
          pattern: pattern2,
          text: "",
          levels: [],
          stickToLeft: 0,
          stickToRight: 0
        }, states = { alphabet: 1, level: 2, stickToLeft: 3, stickToRight: 4 };
        while (patternChar = pattern2.charAt(patternCharIndex++)) {
          var charIsDot = patternChar === ".", charIsNumber = !charIsDot && /\d/.test(patternChar), state2 = charIsDot ? patternCharIndex - 1 === 0 ? states.stickToLeft : states.stickToRight : charIsNumber ? states.level : states.alphabet;
          switch (state2) {
            case states.alphabet:
              !prevCharIsNumber && patternData.levels.push(0);
              patternData.text += patternChar;
              break;
            case states.level:
              patternData.levels.push(parseInt(patternChar));
              break;
            case states.stickToLeft:
              patternData.stickToLeft = true;
              break;
            case states.stickToRight:
              patternData.stickToRight = true;
              break;
          }
          var prevCharIsNumber = charIsNumber;
        }
        return patternData;
      }
      function start3(text2, patterns, cache2, debug3, hyphenChar, skipHTML, minWordLength, isAsync) {
        function done3() {
          allTime = /* @__PURE__ */ new Date() - allTime;
          resolveNewText(newText);
          if (debug3) {
            console.log(
              "----------------\nHyphenation stats: " + processedN + " text chunks processed, " + hyphenatedN + " words hyphenated"
            );
            console.log("Work time: " + workTime / 1e3);
            console.log("Wait time: " + (allTime - workTime) / 1e3);
            console.log("All time: " + allTime / 1e3);
          }
        }
        var cacheKey, newText = "", textChunk, reader = createTextChunkReader(text2, hyphenChar, skipHTML, minWordLength), readNextTextChunk = reader[0], shouldNextHyphenate = reader[1], processedN = 0, hyphenatedN = 0;
        var allTime = /* @__PURE__ */ new Date(), workTime = 0;
        var resolveNewText = function() {
        };
        function nextTick3() {
          var loopStart = /* @__PURE__ */ new Date();
          while ((!isAsync || /* @__PURE__ */ new Date() - loopStart < 10) && (textChunk = readNextTextChunk())) {
            cacheKey = textChunk.length ? "$" + textChunk : "";
            if (shouldNextHyphenate()) {
              if (cache2[cacheKey] === void 0) {
                cache2[cacheKey] = hyphenateWord(
                  textChunk,
                  patterns,
                  debug3,
                  hyphenChar
                );
              }
              if (textChunk !== cache2[cacheKey]) {
                hyphenatedN++;
              }
              textChunk = cache2[cacheKey];
            }
            newText += textChunk;
            processedN++;
          }
          workTime += /* @__PURE__ */ new Date() - loopStart;
          if (!textChunk) {
            done3();
          } else {
            setTimeout(nextTick3);
          }
        }
        if (isAsync) {
          setTimeout(nextTick3);
          return new Promise(function(resolve3) {
            resolveNewText = resolve3;
          });
        } else {
          nextTick3();
          return newText;
        }
      }
      return createHyphenator;
    });
  }
});

// ../node_modules/hyphen/index.js
var require_hyphen2 = __commonJS({
  "../node_modules/hyphen/index.js"(exports, module) {
    module.exports = require_hyphen();
  }
});

// ../node_modules/hyphen/patterns/en-us.js
var require_en_us = __commonJS({
  "../node_modules/hyphen/patterns/en-us.js"(exports, module) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root.hyphenationPatternsEnUs = factory();
      }
    })(exports, function() {
      var patterns = [], hyphenation = [];
      var patterns = [
        " ",
        // just type <return> if you're not using INITEX
        ".ach4",
        ".ad4der",
        ".af1t",
        ".al3t",
        ".am5at",
        ".an5c",
        ".ang4",
        ".ani5m",
        ".ant4",
        ".an3te",
        ".anti5s",
        ".ar5s",
        ".ar4tie",
        ".ar4ty",
        ".as3c",
        ".as1p",
        ".as1s",
        ".aster5",
        ".atom5",
        ".au1d",
        ".av4i",
        ".awn4",
        ".ba4g",
        ".ba5na",
        ".bas4e",
        ".ber4",
        ".be5ra",
        ".be3sm",
        ".be5sto",
        ".bri2",
        ".but4ti",
        ".cam4pe",
        ".can5c",
        ".capa5b",
        ".car5ol",
        ".ca4t",
        ".ce4la",
        ".ch4",
        ".chill5i",
        ".ci2",
        ".cit5r",
        ".co3e",
        ".co4r",
        ".cor5ner",
        ".de4moi",
        ".de3o",
        ".de3ra",
        ".de3ri",
        ".des4c",
        ".dictio5",
        ".do4t",
        ".du4c",
        ".dumb5",
        ".earth5",
        ".eas3i",
        ".eb4",
        ".eer4",
        ".eg2",
        ".el5d",
        ".el3em",
        ".enam3",
        ".en3g",
        ".en3s",
        ".eq5ui5t",
        ".er4ri",
        ".es3",
        ".eu3",
        ".eye5",
        ".fes3",
        ".for5mer",
        ".ga2",
        ".ge2",
        ".gen3t4",
        ".ge5og",
        ".gi5a",
        ".gi4b",
        ".go4r",
        ".hand5i",
        ".han5k",
        ".he2",
        ".hero5i",
        ".hes3",
        ".het3",
        ".hi3b",
        ".hi3er",
        ".hon5ey",
        ".hon3o",
        ".hov5",
        ".id4l",
        ".idol3",
        ".im3m",
        ".im5pin",
        ".in1",
        ".in3ci",
        ".ine2",
        ".in2k",
        ".in3s",
        ".ir5r",
        ".is4i",
        ".ju3r",
        ".la4cy",
        ".la4m",
        ".lat5er",
        ".lath5",
        ".le2",
        ".leg5e",
        ".len4",
        ".lep5",
        ".lev1",
        ".li4g",
        ".lig5a",
        ".li2n",
        ".li3o",
        ".li4t",
        ".mag5a5",
        ".mal5o",
        ".man5a",
        ".mar5ti",
        ".me2",
        ".mer3c",
        ".me5ter",
        ".mis1",
        ".mist5i",
        ".mon3e",
        ".mo3ro",
        ".mu5ta",
        ".muta5b",
        ".ni4c",
        ".od2",
        ".odd5",
        ".of5te",
        ".or5ato",
        ".or3c",
        ".or1d",
        ".or3t",
        ".os3",
        ".os4tl",
        ".oth3",
        ".out3",
        ".ped5al",
        ".pe5te",
        ".pe5tit",
        ".pi4e",
        ".pio5n",
        ".pi2t",
        ".pre3m",
        ".ra4c",
        ".ran4t",
        ".ratio5na",
        ".ree2",
        ".re5mit",
        ".res2",
        ".re5stat",
        ".ri4g",
        ".rit5u",
        ".ro4q",
        ".ros5t",
        ".row5d",
        ".ru4d",
        ".sci3e",
        ".self5",
        ".sell5",
        ".se2n",
        ".se5rie",
        ".sh2",
        ".si2",
        ".sing4",
        ".st4",
        ".sta5bl",
        ".sy2",
        ".ta4",
        ".te4",
        ".ten5an",
        ".th2",
        ".ti2",
        ".til4",
        ".tim5o5",
        ".ting4",
        ".tin5k",
        ".ton4a",
        ".to4p",
        ".top5i",
        ".tou5s",
        ".trib5ut",
        ".un1a",
        ".un3ce",
        ".under5",
        ".un1e",
        ".un5k",
        ".un5o",
        ".un3u",
        ".up3",
        ".ure3",
        ".us5a",
        ".ven4de",
        ".ve5ra",
        ".wil5i",
        ".ye4",
        "4ab.",
        "a5bal",
        "a5ban",
        "abe2",
        "ab5erd",
        "abi5a",
        "ab5it5ab",
        "ab5lat",
        "ab5o5liz",
        "4abr",
        "ab5rog",
        "ab3ul",
        "a4car",
        "ac5ard",
        "ac5aro",
        "a5ceou",
        "ac1er",
        "a5chet",
        "4a2ci",
        "a3cie",
        "ac1in",
        "a3cio",
        "ac5rob",
        "act5if",
        "ac3ul",
        "ac4um",
        "a2d",
        "ad4din",
        "ad5er.",
        "2adi",
        "a3dia",
        "ad3ica",
        "adi4er",
        "a3dio",
        "a3dit",
        "a5diu",
        "ad4le",
        "ad3ow",
        "ad5ran",
        "ad4su",
        "4adu",
        "a3duc",
        "ad5um",
        "ae4r",
        "aeri4e",
        "a2f",
        "aff4",
        "a4gab",
        "aga4n",
        "ag5ell",
        "age4o",
        "4ageu",
        "ag1i",
        "4ag4l",
        "ag1n",
        "a2go",
        "3agog",
        "ag3oni",
        "a5guer",
        "ag5ul",
        "a4gy",
        "a3ha",
        "a3he",
        "ah4l",
        "a3ho",
        "ai2",
        "a5ia",
        "a3ic.",
        "ai5ly",
        "a4i4n",
        "ain5in",
        "ain5o",
        "ait5en",
        "a1j",
        "ak1en",
        "al5ab",
        "al3ad",
        "a4lar",
        "4aldi",
        "2ale",
        "al3end",
        "a4lenti",
        "a5le5o",
        "al1i",
        "al4ia.",
        "ali4e",
        "al5lev",
        "4allic",
        "4alm",
        "a5log.",
        "a4ly.",
        "4alys",
        "5a5lyst",
        "5alyt",
        "3alyz",
        "4ama",
        "am5ab",
        "am3ag",
        "ama5ra",
        "am5asc",
        "a4matis",
        "a4m5ato",
        "am5era",
        "am3ic",
        "am5if",
        "am5ily",
        "am1in",
        "ami4no",
        "a2mo",
        "a5mon",
        "amor5i",
        "amp5en",
        "a2n",
        "an3age",
        "3analy",
        "a3nar",
        "an3arc",
        "anar4i",
        "a3nati",
        "4and",
        "ande4s",
        "an3dis",
        "an1dl",
        "an4dow",
        "a5nee",
        "a3nen",
        "an5est.",
        "a3neu",
        "2ang",
        "ang5ie",
        "an1gl",
        "a4n1ic",
        "a3nies",
        "an3i3f",
        "an4ime",
        "a5nimi",
        "a5nine",
        "an3io",
        "a3nip",
        "an3ish",
        "an3it",
        "a3niu",
        "an4kli",
        "5anniz",
        "ano4",
        "an5ot",
        "anoth5",
        "an2sa",
        "an4sco",
        "an4sn",
        "an2sp",
        "ans3po",
        "an4st",
        "an4sur",
        "antal4",
        "an4tie",
        "4anto",
        "an2tr",
        "an4tw",
        "an3ua",
        "an3ul",
        "a5nur",
        "4ao",
        "apar4",
        "ap5at",
        "ap5ero",
        "a3pher",
        "4aphi",
        "a4pilla",
        "ap5illar",
        "ap3in",
        "ap3ita",
        "a3pitu",
        "a2pl",
        "apoc5",
        "ap5ola",
        "apor5i",
        "apos3t",
        "aps5es",
        "a3pu",
        "aque5",
        "2a2r",
        "ar3act",
        "a5rade",
        "ar5adis",
        "ar3al",
        "a5ramete",
        "aran4g",
        "ara3p",
        "ar4at",
        "a5ratio",
        "ar5ativ",
        "a5rau",
        "ar5av4",
        "araw4",
        "arbal4",
        "ar4chan",
        "ar5dine",
        "ar4dr",
        "ar5eas",
        "a3ree",
        "ar3ent",
        "a5ress",
        "ar4fi",
        "ar4fl",
        "ar1i",
        "ar5ial",
        "ar3ian",
        "a3riet",
        "ar4im",
        "ar5inat",
        "ar3io",
        "ar2iz",
        "ar2mi",
        "ar5o5d",
        "a5roni",
        "a3roo",
        "ar2p",
        "ar3q",
        "arre4",
        "ar4sa",
        "ar2sh",
        "4as.",
        "as4ab",
        "as3ant",
        "ashi4",
        "a5sia.",
        "a3sib",
        "a3sic",
        "5a5si4t",
        "ask3i",
        "as4l",
        "a4soc",
        "as5ph",
        "as4sh",
        "as3ten",
        "as1tr",
        "asur5a",
        "a2ta",
        "at3abl",
        "at5ac",
        "at3alo",
        "at5ap",
        "ate5c",
        "at5ech",
        "at3ego",
        "at3en.",
        "at3era",
        "ater5n",
        "a5terna",
        "at3est",
        "at5ev",
        "4ath",
        "ath5em",
        "a5then",
        "at4ho",
        "ath5om",
        "4ati.",
        "a5tia",
        "at5i5b",
        "at1ic",
        "at3if",
        "ation5ar",
        "at3itu",
        "a4tog",
        "a2tom",
        "at5omiz",
        "a4top",
        "a4tos",
        "a1tr",
        "at5rop",
        "at4sk",
        "at4tag",
        "at5te",
        "at4th",
        "a2tu",
        "at5ua",
        "at5ue",
        "at3ul",
        "at3ura",
        "a2ty",
        "au4b",
        "augh3",
        "au3gu",
        "au4l2",
        "aun5d",
        "au3r",
        "au5sib",
        "aut5en",
        "au1th",
        "a2va",
        "av3ag",
        "a5van",
        "ave4no",
        "av3era",
        "av5ern",
        "av5ery",
        "av1i",
        "avi4er",
        "av3ig",
        "av5oc",
        "a1vor",
        "3away",
        "aw3i",
        "aw4ly",
        "aws4",
        "ax4ic",
        "ax4id",
        "ay5al",
        "aye4",
        "ays4",
        "azi4er",
        "azz5i",
        "5ba.",
        "bad5ger",
        "ba4ge",
        "bal1a",
        "ban5dag",
        "ban4e",
        "ban3i",
        "barbi5",
        "bari4a",
        "bas4si",
        "1bat",
        "ba4z",
        "2b1b",
        "b2be",
        "b3ber",
        "bbi4na",
        "4b1d",
        "4be.",
        "beak4",
        "beat3",
        "4be2d",
        "be3da",
        "be3de",
        "be3di",
        "be3gi",
        "be5gu",
        "1bel",
        "be1li",
        "be3lo",
        "4be5m",
        "be5nig",
        "be5nu",
        "4bes4",
        "be3sp",
        "be5str",
        "3bet",
        "bet5iz",
        "be5tr",
        "be3tw",
        "be3w",
        "be5yo",
        "2bf",
        "4b3h",
        "bi2b",
        "bi4d",
        "3bie",
        "bi5en",
        "bi4er",
        "2b3if",
        "1bil",
        "bi3liz",
        "bina5r4",
        "bin4d",
        "bi5net",
        "bi3ogr",
        "bi5ou",
        "bi2t",
        "3bi3tio",
        "bi3tr",
        "3bit5ua",
        "b5itz",
        "b1j",
        "bk4",
        "b2l2",
        "blath5",
        "b4le.",
        "blen4",
        "5blesp",
        "b3lis",
        "b4lo",
        "blun4t",
        "4b1m",
        "4b3n",
        "bne5g",
        "3bod",
        "bod3i",
        "bo4e",
        "bol3ic",
        "bom4bi",
        "bon4a",
        "bon5at",
        "3boo",
        "5bor.",
        "4b1ora",
        "bor5d",
        "5bore",
        "5bori",
        "5bos4",
        "b5ota",
        "both5",
        "bo4to",
        "bound3",
        "4bp",
        "4brit",
        "broth3",
        "2b5s2",
        "bsor4",
        "2bt",
        "bt4l",
        "b4to",
        "b3tr",
        "buf4fer",
        "bu4ga",
        "bu3li",
        "bumi4",
        "bu4n",
        "bunt4i",
        "bu3re",
        "bus5ie",
        "buss4e",
        "5bust",
        "4buta",
        "3butio",
        "b5uto",
        "b1v",
        "4b5w",
        "5by.",
        "bys4",
        "1ca",
        "cab3in",
        "ca1bl",
        "cach4",
        "ca5den",
        "4cag4",
        "2c5ah",
        "ca3lat",
        "cal4la",
        "call5in",
        "4calo",
        "can5d",
        "can4e",
        "can4ic",
        "can5is",
        "can3iz",
        "can4ty",
        "cany4",
        "ca5per",
        "car5om",
        "cast5er",
        "cas5tig",
        "4casy",
        "ca4th",
        "4cativ",
        "cav5al",
        "c3c",
        "ccha5",
        "cci4a",
        "ccompa5",
        "ccon4",
        "ccou3t",
        "2ce.",
        "4ced.",
        "4ceden",
        "3cei",
        "5cel.",
        "3cell",
        "1cen",
        "3cenc",
        "2cen4e",
        "4ceni",
        "3cent",
        "3cep",
        "ce5ram",
        "4cesa",
        "3cessi",
        "ces5si5b",
        "ces5t",
        "cet4",
        "c5e4ta",
        "cew4",
        "2ch",
        "4ch.",
        "4ch3ab",
        "5chanic",
        "ch5a5nis",
        "che2",
        "cheap3",
        "4ched",
        "che5lo",
        "3chemi",
        "ch5ene",
        "ch3er.",
        "ch3ers",
        "4ch1in",
        "5chine.",
        "ch5iness",
        "5chini",
        "5chio",
        "3chit",
        "chi2z",
        "3cho2",
        "ch4ti",
        "1ci",
        "3cia",
        "ci2a5b",
        "cia5r",
        "ci5c",
        "4cier",
        "5cific.",
        "4cii",
        "ci4la",
        "3cili",
        "2cim",
        "2cin",
        "c4ina",
        "3cinat",
        "cin3em",
        "c1ing",
        "c5ing.",
        "5cino",
        "cion4",
        "4cipe",
        "ci3ph",
        "4cipic",
        "4cista",
        "4cisti",
        "2c1it",
        "cit3iz",
        "5ciz",
        "ck1",
        "ck3i",
        "1c4l4",
        "4clar",
        "c5laratio",
        "5clare",
        "cle4m",
        "4clic",
        "clim4",
        "cly4",
        "c5n",
        "1co",
        "co5ag",
        "coe2",
        "2cog",
        "co4gr",
        "coi4",
        "co3inc",
        "col5i",
        "5colo",
        "col3or",
        "com5er",
        "con4a",
        "c4one",
        "con3g",
        "con5t",
        "co3pa",
        "cop3ic",
        "co4pl",
        "4corb",
        "coro3n",
        "cos4e",
        "cov1",
        "cove4",
        "cow5a",
        "coz5e",
        "co5zi",
        "c1q",
        "cras5t",
        "5crat.",
        "5cratic",
        "cre3at",
        "5cred",
        "4c3reta",
        "cre4v",
        "cri2",
        "cri5f",
        "c4rin",
        "cris4",
        "5criti",
        "cro4pl",
        "crop5o",
        "cros4e",
        "cru4d",
        "4c3s2",
        "2c1t",
        "cta4b",
        "ct5ang",
        "c5tant",
        "c2te",
        "c3ter",
        "c4ticu",
        "ctim3i",
        "ctu4r",
        "c4tw",
        "cud5",
        "c4uf",
        "c4ui",
        "cu5ity",
        "5culi",
        "cul4tis",
        "3cultu",
        "cu2ma",
        "c3ume",
        "cu4mi",
        "3cun",
        "cu3pi",
        "cu5py",
        "cur5a4b",
        "cu5ria",
        "1cus",
        "cuss4i",
        "3c4ut",
        "cu4tie",
        "4c5utiv",
        "4cutr",
        "1cy",
        "cze4",
        "1d2a",
        "5da.",
        "2d3a4b",
        "dach4",
        "4daf",
        "2dag",
        "da2m2",
        "dan3g",
        "dard5",
        "dark5",
        "4dary",
        "3dat",
        "4dativ",
        "4dato",
        "5dav4",
        "dav5e",
        "5day",
        "d1b",
        "d5c",
        "d1d4",
        "2de.",
        "deaf5",
        "deb5it",
        "de4bon",
        "decan4",
        "de4cil",
        "de5com",
        "2d1ed",
        "4dee.",
        "de5if",
        "deli4e",
        "del5i5q",
        "de5lo",
        "d4em",
        "5dem.",
        "3demic",
        "dem5ic.",
        "de5mil",
        "de4mons",
        "demor5",
        "1den",
        "de4nar",
        "de3no",
        "denti5f",
        "de3nu",
        "de1p",
        "de3pa",
        "depi4",
        "de2pu",
        "d3eq",
        "d4erh",
        "5derm",
        "dern5iz",
        "der5s",
        "des2",
        "d2es.",
        "de1sc",
        "de2s5o",
        "des3ti",
        "de3str",
        "de4su",
        "de1t",
        "de2to",
        "de1v",
        "dev3il",
        "4dey",
        "4d1f",
        "d4ga",
        "d3ge4t",
        "dg1i",
        "d2gy",
        "d1h2",
        "5di.",
        "1d4i3a",
        "dia5b",
        "di4cam",
        "d4ice",
        "3dict",
        "3did",
        "5di3en",
        "d1if",
        "di3ge",
        "di4lato",
        "d1in",
        "1dina",
        "3dine.",
        "5dini",
        "di5niz",
        "1dio",
        "dio5g",
        "di4pl",
        "dir2",
        "di1re",
        "dirt5i",
        "dis1",
        "5disi",
        "d4is3t",
        "d2iti",
        "1di1v",
        "d1j",
        "d5k2",
        "4d5la",
        "3dle.",
        "3dled",
        "3dles.",
        "4dless",
        "2d3lo",
        "4d5lu",
        "2dly",
        "d1m",
        "4d1n4",
        "1do",
        "3do.",
        "do5de",
        "5doe",
        "2d5of",
        "d4og",
        "do4la",
        "doli4",
        "do5lor",
        "dom5iz",
        "do3nat",
        "doni4",
        "doo3d",
        "dop4p",
        "d4or",
        "3dos",
        "4d5out",
        "do4v",
        "3dox",
        "d1p",
        "1dr",
        "drag5on",
        "4drai",
        "dre4",
        "drea5r",
        "5dren",
        "dri4b",
        "dril4",
        "dro4p",
        "4drow",
        "5drupli",
        "4dry",
        "2d1s2",
        "ds4p",
        "d4sw",
        "d4sy",
        "d2th",
        "1du",
        "d1u1a",
        "du2c",
        "d1uca",
        "duc5er",
        "4duct.",
        "4ducts",
        "du5el",
        "du4g",
        "d3ule",
        "dum4be",
        "du4n",
        "4dup",
        "du4pe",
        "d1v",
        "d1w",
        "d2y",
        "5dyn",
        "dy4se",
        "dys5p",
        "e1a4b",
        "e3act",
        "ead1",
        "ead5ie",
        "ea4ge",
        "ea5ger",
        "ea4l",
        "eal5er",
        "eal3ou",
        "eam3er",
        "e5and",
        "ear3a",
        "ear4c",
        "ear5es",
        "ear4ic",
        "ear4il",
        "ear5k",
        "ear2t",
        "eart3e",
        "ea5sp",
        "e3ass",
        "east3",
        "ea2t",
        "eat5en",
        "eath3i",
        "e5atif",
        "e4a3tu",
        "ea2v",
        "eav3en",
        "eav5i",
        "eav5o",
        "2e1b",
        "e4bel.",
        "e4bels",
        "e4ben",
        "e4bit",
        "e3br",
        "e4cad",
        "ecan5c",
        "ecca5",
        "e1ce",
        "ec5essa",
        "ec2i",
        "e4cib",
        "ec5ificat",
        "ec5ifie",
        "ec5ify",
        "ec3im",
        "eci4t",
        "e5cite",
        "e4clam",
        "e4clus",
        "e2col",
        "e4comm",
        "e4compe",
        "e4conc",
        "e2cor",
        "ec3ora",
        "eco5ro",
        "e1cr",
        "e4crem",
        "ec4tan",
        "ec4te",
        "e1cu",
        "e4cul",
        "ec3ula",
        "2e2da",
        "4ed3d",
        "e4d1er",
        "ede4s",
        "4edi",
        "e3dia",
        "ed3ib",
        "ed3ica",
        "ed3im",
        "ed1it",
        "edi5z",
        "4edo",
        "e4dol",
        "edon2",
        "e4dri",
        "e4dul",
        "ed5ulo",
        "ee2c",
        "eed3i",
        "ee2f",
        "eel3i",
        "ee4ly",
        "ee2m",
        "ee4na",
        "ee4p1",
        "ee2s4",
        "eest4",
        "ee4ty",
        "e5ex",
        "e1f",
        "e4f3ere",
        "1eff",
        "e4fic",
        "5efici",
        "efil4",
        "e3fine",
        "ef5i5nite",
        "3efit",
        "efor5es",
        "e4fuse.",
        "4egal",
        "eger4",
        "eg5ib",
        "eg4ic",
        "eg5ing",
        "e5git5",
        "eg5n",
        "e4go.",
        "e4gos",
        "eg1ul",
        "e5gur",
        "5egy",
        "e1h4",
        "eher4",
        "ei2",
        "e5ic",
        "ei5d",
        "eig2",
        "ei5gl",
        "e3imb",
        "e3inf",
        "e1ing",
        "e5inst",
        "eir4d",
        "eit3e",
        "ei3th",
        "e5ity",
        "e1j",
        "e4jud",
        "ej5udi",
        "eki4n",
        "ek4la",
        "e1la",
        "e4la.",
        "e4lac",
        "elan4d",
        "el5ativ",
        "e4law",
        "elaxa4",
        "e3lea",
        "el5ebra",
        "5elec",
        "e4led",
        "el3ega",
        "e5len",
        "e4l1er",
        "e1les",
        "el2f",
        "el2i",
        "e3libe",
        "e4l5ic.",
        "el3ica",
        "e3lier",
        "el5igib",
        "e5lim",
        "e4l3ing",
        "e3lio",
        "e2lis",
        "el5ish",
        "e3liv3",
        "4ella",
        "el4lab",
        "ello4",
        "e5loc",
        "el5og",
        "el3op.",
        "el2sh",
        "el4ta",
        "e5lud",
        "el5ug",
        "e4mac",
        "e4mag",
        "e5man",
        "em5ana",
        "em5b",
        "e1me",
        "e2mel",
        "e4met",
        "em3ica",
        "emi4e",
        "em5igra",
        "em1in2",
        "em5ine",
        "em3i3ni",
        "e4mis",
        "em5ish",
        "e5miss",
        "em3iz",
        "5emniz",
        "emo4g",
        "emoni5o",
        "em3pi",
        "e4mul",
        "em5ula",
        "emu3n",
        "e3my",
        "en5amo",
        "e4nant",
        "ench4er",
        "en3dic",
        "e5nea",
        "e5nee",
        "en3em",
        "en5ero",
        "en5esi",
        "en5est",
        "en3etr",
        "e3new",
        "en5ics",
        "e5nie",
        "e5nil",
        "e3nio",
        "en3ish",
        "en3it",
        "e5niu",
        "5eniz",
        "4enn",
        "4eno",
        "eno4g",
        "e4nos",
        "en3ov",
        "en4sw",
        "ent5age",
        "4enthes",
        "en3ua",
        "en5uf",
        "e3ny.",
        "4en3z",
        "e5of",
        "eo2g",
        "e4oi4",
        "e3ol",
        "eop3ar",
        "e1or",
        "eo3re",
        "eo5rol",
        "eos4",
        "e4ot",
        "eo4to",
        "e5out",
        "e5ow",
        "e2pa",
        "e3pai",
        "ep5anc",
        "e5pel",
        "e3pent",
        "ep5etitio",
        "ephe4",
        "e4pli",
        "e1po",
        "e4prec",
        "ep5reca",
        "e4pred",
        "ep3reh",
        "e3pro",
        "e4prob",
        "ep4sh",
        "ep5ti5b",
        "e4put",
        "ep5uta",
        "e1q",
        "equi3l",
        "e4q3ui3s",
        "er1a",
        "era4b",
        "4erand",
        "er3ar",
        "4erati.",
        "2erb",
        "er4bl",
        "er3ch",
        "er4che",
        "2ere.",
        "e3real",
        "ere5co",
        "ere3in",
        "er5el.",
        "er3emo",
        "er5ena",
        "er5ence",
        "4erene",
        "er3ent",
        "ere4q",
        "er5ess",
        "er3est",
        "eret4",
        "er1h",
        "er1i",
        "e1ria4",
        "5erick",
        "e3rien",
        "eri4er",
        "er3ine",
        "e1rio",
        "4erit",
        "er4iu",
        "eri4v",
        "e4riva",
        "er3m4",
        "er4nis",
        "4ernit",
        "5erniz",
        "er3no",
        "2ero",
        "er5ob",
        "e5roc",
        "ero4r",
        "er1ou",
        "er1s",
        "er3set",
        "ert3er",
        "4ertl",
        "er3tw",
        "4eru",
        "eru4t",
        "5erwau",
        "e1s4a",
        "e4sage.",
        "e4sages",
        "es2c",
        "e2sca",
        "es5can",
        "e3scr",
        "es5cu",
        "e1s2e",
        "e2sec",
        "es5ecr",
        "es5enc",
        "e4sert.",
        "e4serts",
        "e4serva",
        "4esh",
        "e3sha",
        "esh5en",
        "e1si",
        "e2sic",
        "e2sid",
        "es5iden",
        "es5igna",
        "e2s5im",
        "es4i4n",
        "esis4te",
        "esi4u",
        "e5skin",
        "es4mi",
        "e2sol",
        "es3olu",
        "e2son",
        "es5ona",
        "e1sp",
        "es3per",
        "es5pira",
        "es4pre",
        "2ess",
        "es4si4b",
        "estan4",
        "es3tig",
        "es5tim",
        "4es2to",
        "e3ston",
        "2estr",
        "e5stro",
        "estruc5",
        "e2sur",
        "es5urr",
        "es4w",
        "eta4b",
        "eten4d",
        "e3teo",
        "ethod3",
        "et1ic",
        "e5tide",
        "etin4",
        "eti4no",
        "e5tir",
        "e5titio",
        "et5itiv",
        "4etn",
        "et5ona",
        "e3tra",
        "e3tre",
        "et3ric",
        "et5rif",
        "et3rog",
        "et5ros",
        "et3ua",
        "et5ym",
        "et5z",
        "4eu",
        "e5un",
        "e3up",
        "eu3ro",
        "eus4",
        "eute4",
        "euti5l",
        "eu5tr",
        "eva2p5",
        "e2vas",
        "ev5ast",
        "e5vea",
        "ev3ell",
        "evel3o",
        "e5veng",
        "even4i",
        "ev1er",
        "e5verb",
        "e1vi",
        "ev3id",
        "evi4l",
        "e4vin",
        "evi4v",
        "e5voc",
        "e5vu",
        "e1wa",
        "e4wag",
        "e5wee",
        "e3wh",
        "ewil5",
        "ew3ing",
        "e3wit",
        "1exp",
        "5eyc",
        "5eye.",
        "eys4",
        "1fa",
        "fa3bl",
        "fab3r",
        "fa4ce",
        "4fag",
        "fain4",
        "fall5e",
        "4fa4ma",
        "fam5is",
        "5far",
        "far5th",
        "fa3ta",
        "fa3the",
        "4fato",
        "fault5",
        "4f5b",
        "4fd",
        "4fe.",
        "feas4",
        "feath3",
        "fe4b",
        "4feca",
        "5fect",
        "2fed",
        "fe3li",
        "fe4mo",
        "fen2d",
        "fend5e",
        "fer1",
        "5ferr",
        "fev4",
        "4f1f",
        "f4fes",
        "f4fie",
        "f5fin.",
        "f2f5is",
        "f4fly",
        "f2fy",
        "4fh",
        "1fi",
        "fi3a",
        "2f3ic.",
        "4f3ical",
        "f3ican",
        "4ficate",
        "f3icen",
        "fi3cer",
        "fic4i",
        "5ficia",
        "5ficie",
        "4fics",
        "fi3cu",
        "fi5del",
        "fight5",
        "fil5i",
        "fill5in",
        "4fily",
        "2fin",
        "5fina",
        "fin2d5",
        "fi2ne",
        "f1in3g",
        "fin4n",
        "fis4ti",
        "f4l2",
        "f5less",
        "flin4",
        "flo3re",
        "f2ly5",
        "4fm",
        "4fn",
        "1fo",
        "5fon",
        "fon4de",
        "fon4t",
        "fo2r",
        "fo5rat",
        "for5ay",
        "fore5t",
        "for4i",
        "fort5a",
        "fos5",
        "4f5p",
        "fra4t",
        "f5rea",
        "fres5c",
        "fri2",
        "fril4",
        "frol5",
        "2f3s",
        "2ft",
        "f4to",
        "f2ty",
        "3fu",
        "fu5el",
        "4fug",
        "fu4min",
        "fu5ne",
        "fu3ri",
        "fusi4",
        "fus4s",
        "4futa",
        "1fy",
        "1ga",
        "gaf4",
        "5gal.",
        "3gali",
        "ga3lo",
        "2gam",
        "ga5met",
        "g5amo",
        "gan5is",
        "ga3niz",
        "gani5za",
        "4gano",
        "gar5n4",
        "gass4",
        "gath3",
        "4gativ",
        "4gaz",
        "g3b",
        "gd4",
        "2ge.",
        "2ged",
        "geez4",
        "gel4in",
        "ge5lis",
        "ge5liz",
        "4gely",
        "1gen",
        "ge4nat",
        "ge5niz",
        "4geno",
        "4geny",
        "1geo",
        "ge3om",
        "g4ery",
        "5gesi",
        "geth5",
        "4geto",
        "ge4ty",
        "ge4v",
        "4g1g2",
        "g2ge",
        "g3ger",
        "gglu5",
        "ggo4",
        "gh3in",
        "gh5out",
        "gh4to",
        "5gi.",
        "1gi4a",
        "gia5r",
        "g1ic",
        "5gicia",
        "g4ico",
        "gien5",
        "5gies.",
        "gil4",
        "g3imen",
        "3g4in.",
        "gin5ge",
        "5g4ins",
        "5gio",
        "3gir",
        "gir4l",
        "g3isl",
        "gi4u",
        "5giv",
        "3giz",
        "gl2",
        "gla4",
        "glad5i",
        "5glas",
        "1gle",
        "gli4b",
        "g3lig",
        "3glo",
        "glo3r",
        "g1m",
        "g4my",
        "gn4a",
        "g4na.",
        "gnet4t",
        "g1ni",
        "g2nin",
        "g4nio",
        "g1no",
        "g4non",
        "1go",
        "3go.",
        "gob5",
        "5goe",
        "3g4o4g",
        "go3is",
        "gon2",
        "4g3o3na",
        "gondo5",
        "go3ni",
        "5goo",
        "go5riz",
        "gor5ou",
        "5gos.",
        "gov1",
        "g3p",
        "1gr",
        "4grada",
        "g4rai",
        "gran2",
        "5graph.",
        "g5rapher",
        "5graphic",
        "4graphy",
        "4gray",
        "gre4n",
        "4gress.",
        "4grit",
        "g4ro",
        "gruf4",
        "gs2",
        "g5ste",
        "gth3",
        "gu4a",
        "3guard",
        "2gue",
        "5gui5t",
        "3gun",
        "3gus",
        "4gu4t",
        "g3w",
        "1gy",
        "2g5y3n",
        "gy5ra",
        "h3ab4l",
        "hach4",
        "hae4m",
        "hae4t",
        "h5agu",
        "ha3la",
        "hala3m",
        "ha4m",
        "han4ci",
        "han4cy",
        "5hand.",
        "han4g",
        "hang5er",
        "hang5o",
        "h5a5niz",
        "han4k",
        "han4te",
        "hap3l",
        "hap5t",
        "ha3ran",
        "ha5ras",
        "har2d",
        "hard3e",
        "har4le",
        "harp5en",
        "har5ter",
        "has5s",
        "haun4",
        "5haz",
        "haz3a",
        "h1b",
        "1head",
        "3hear",
        "he4can",
        "h5ecat",
        "h4ed",
        "he5do5",
        "he3l4i",
        "hel4lis",
        "hel4ly",
        "h5elo",
        "hem4p",
        "he2n",
        "hena4",
        "hen5at",
        "heo5r",
        "hep5",
        "h4era",
        "hera3p",
        "her4ba",
        "here5a",
        "h3ern",
        "h5erou",
        "h3ery",
        "h1es",
        "he2s5p",
        "he4t",
        "het4ed",
        "heu4",
        "h1f",
        "h1h",
        "hi5an",
        "hi4co",
        "high5",
        "h4il2",
        "himer4",
        "h4ina",
        "hion4e",
        "hi4p",
        "hir4l",
        "hi3ro",
        "hir4p",
        "hir4r",
        "his3el",
        "his4s",
        "hith5er",
        "hi2v",
        "4hk",
        "4h1l4",
        "hlan4",
        "h2lo",
        "hlo3ri",
        "4h1m",
        "hmet4",
        "2h1n",
        "h5odiz",
        "h5ods",
        "ho4g",
        "hoge4",
        "hol5ar",
        "3hol4e",
        "ho4ma",
        "home3",
        "hon4a",
        "ho5ny",
        "3hood",
        "hoon4",
        "hor5at",
        "ho5ris",
        "hort3e",
        "ho5ru",
        "hos4e",
        "ho5sen",
        "hos1p",
        "1hous",
        "house3",
        "hov5el",
        "4h5p",
        "4hr4",
        "hree5",
        "hro5niz",
        "hro3po",
        "4h1s2",
        "h4sh",
        "h4tar",
        "ht1en",
        "ht5es",
        "h4ty",
        "hu4g",
        "hu4min",
        "hun5ke",
        "hun4t",
        "hus3t4",
        "hu4t",
        "h1w",
        "h4wart",
        "hy3pe",
        "hy3ph",
        "hy2s",
        "2i1a",
        "i2al",
        "iam4",
        "iam5ete",
        "i2an",
        "4ianc",
        "ian3i",
        "4ian4t",
        "ia5pe",
        "iass4",
        "i4ativ",
        "ia4tric",
        "i4atu",
        "ibe4",
        "ib3era",
        "ib5ert",
        "ib5ia",
        "ib3in",
        "ib5it.",
        "ib5ite",
        "i1bl",
        "ib3li",
        "i5bo",
        "i1br",
        "i2b5ri",
        "i5bun",
        "4icam",
        "5icap",
        "4icar",
        "i4car.",
        "i4cara",
        "icas5",
        "i4cay",
        "iccu4",
        "4iceo",
        "4ich",
        "2ici",
        "i5cid",
        "ic5ina",
        "i2cip",
        "ic3ipa",
        "i4cly",
        "i2c5oc",
        "4i1cr",
        "5icra",
        "i4cry",
        "ic4te",
        "ictu2",
        "ic4t3ua",
        "ic3ula",
        "ic4um",
        "ic5uo",
        "i3cur",
        "2id",
        "i4dai",
        "id5anc",
        "id5d",
        "ide3al",
        "ide4s",
        "i2di",
        "id5ian",
        "idi4ar",
        "i5die",
        "id3io",
        "idi5ou",
        "id1it",
        "id5iu",
        "i3dle",
        "i4dom",
        "id3ow",
        "i4dr",
        "i2du",
        "id5uo",
        "2ie4",
        "ied4e",
        "5ie5ga",
        "ield3",
        "ien5a4",
        "ien4e",
        "i5enn",
        "i3enti",
        "i1er.",
        "i3esc",
        "i1est",
        "i3et",
        "4if.",
        "if5ero",
        "iff5en",
        "if4fr",
        "4ific.",
        "i3fie",
        "i3fl",
        "4ift",
        "2ig",
        "iga5b",
        "ig3era",
        "ight3i",
        "4igi",
        "i3gib",
        "ig3il",
        "ig3in",
        "ig3it",
        "i4g4l",
        "i2go",
        "ig3or",
        "ig5ot",
        "i5gre",
        "igu5i",
        "ig1ur",
        "i3h",
        "4i5i4",
        "i3j",
        "4ik",
        "i1la",
        "il3a4b",
        "i4lade",
        "i2l5am",
        "ila5ra",
        "i3leg",
        "il1er",
        "ilev4",
        "il5f",
        "il1i",
        "il3ia",
        "il2ib",
        "il3io",
        "il4ist",
        "2ilit",
        "il2iz",
        "ill5ab",
        "4iln",
        "il3oq",
        "il4ty",
        "il5ur",
        "il3v",
        "i4mag",
        "im3age",
        "ima5ry",
        "imenta5r",
        "4imet",
        "im1i",
        "im5ida",
        "imi5le",
        "i5mini",
        "4imit",
        "im4ni",
        "i3mon",
        "i2mu",
        "im3ula",
        "2in.",
        "i4n3au",
        "4inav",
        "incel4",
        "in3cer",
        "4ind",
        "in5dling",
        "2ine",
        "i3nee",
        "iner4ar",
        "i5ness",
        "4inga",
        "4inge",
        "in5gen",
        "4ingi",
        "in5gling",
        "4ingo",
        "4ingu",
        "2ini",
        "i5ni.",
        "i4nia",
        "in3io",
        "in1is",
        "i5nite.",
        "5initio",
        "in3ity",
        "4ink",
        "4inl",
        "2inn",
        "2i1no",
        "i4no4c",
        "ino4s",
        "i4not",
        "2ins",
        "in3se",
        "insur5a",
        "2int.",
        "2in4th",
        "in1u",
        "i5nus",
        "4iny",
        "2io",
        "4io.",
        "ioge4",
        "io2gr",
        "i1ol",
        "io4m",
        "ion3at",
        "ion4ery",
        "ion3i",
        "io5ph",
        "ior3i",
        "i4os",
        "io5th",
        "i5oti",
        "io4to",
        "i4our",
        "2ip",
        "ipe4",
        "iphras4",
        "ip3i",
        "ip4ic",
        "ip4re4",
        "ip3ul",
        "i3qua",
        "iq5uef",
        "iq3uid",
        "iq3ui3t",
        "4ir",
        "i1ra",
        "ira4b",
        "i4rac",
        "ird5e",
        "ire4de",
        "i4ref",
        "i4rel4",
        "i4res",
        "ir5gi",
        "ir1i",
        "iri5de",
        "ir4is",
        "iri3tu",
        "5i5r2iz",
        "ir4min",
        "iro4g",
        "5iron.",
        "ir5ul",
        "2is.",
        "is5ag",
        "is3ar",
        "isas5",
        "2is1c",
        "is3ch",
        "4ise",
        "is3er",
        "3isf",
        "is5han",
        "is3hon",
        "ish5op",
        "is3ib",
        "isi4d",
        "i5sis",
        "is5itiv",
        "4is4k",
        "islan4",
        "4isms",
        "i2so",
        "iso5mer",
        "is1p",
        "is2pi",
        "is4py",
        "4is1s",
        "is4sal",
        "issen4",
        "is4ses",
        "is4ta.",
        "is1te",
        "is1ti",
        "ist4ly",
        "4istral",
        "i2su",
        "is5us",
        "4ita.",
        "ita4bi",
        "i4tag",
        "4ita5m",
        "i3tan",
        "i3tat",
        "2ite",
        "it3era",
        "i5teri",
        "it4es",
        "2ith",
        "i1ti",
        "4itia",
        "4i2tic",
        "it3ica",
        "5i5tick",
        "it3ig",
        "it5ill",
        "i2tim",
        "2itio",
        "4itis",
        "i4tism",
        "i2t5o5m",
        "4iton",
        "i4tram",
        "it5ry",
        "4itt",
        "it3uat",
        "i5tud",
        "it3ul",
        "4itz.",
        "i1u",
        "2iv",
        "iv3ell",
        "iv3en.",
        "i4v3er.",
        "i4vers.",
        "iv5il.",
        "iv5io",
        "iv1it",
        "i5vore",
        "iv3o3ro",
        "i4v3ot",
        "4i5w",
        "ix4o",
        "4iy",
        "4izar",
        "izi4",
        "5izont",
        "5ja",
        "jac4q",
        "ja4p",
        "1je",
        "jer5s",
        "4jestie",
        "4jesty",
        "jew3",
        "jo4p",
        "5judg",
        "3ka.",
        "k3ab",
        "k5ag",
        "kais4",
        "kal4",
        "k1b",
        "k2ed",
        "1kee",
        "ke4g",
        "ke5li",
        "k3en4d",
        "k1er",
        "kes4",
        "k3est.",
        "ke4ty",
        "k3f",
        "kh4",
        "k1i",
        "5ki.",
        "5k2ic",
        "k4ill",
        "kilo5",
        "k4im",
        "k4in.",
        "kin4de",
        "k5iness",
        "kin4g",
        "ki4p",
        "kis4",
        "k5ish",
        "kk4",
        "k1l",
        "4kley",
        "4kly",
        "k1m",
        "k5nes",
        "1k2no",
        "ko5r",
        "kosh4",
        "k3ou",
        "kro5n",
        "4k1s2",
        "k4sc",
        "ks4l",
        "k4sy",
        "k5t",
        "k1w",
        "lab3ic",
        "l4abo",
        "laci4",
        "l4ade",
        "la3dy",
        "lag4n",
        "lam3o",
        "3land",
        "lan4dl",
        "lan5et",
        "lan4te",
        "lar4g",
        "lar3i",
        "las4e",
        "la5tan",
        "4lateli",
        "4lativ",
        "4lav",
        "la4v4a",
        "2l1b",
        "lbin4",
        "4l1c2",
        "lce4",
        "l3ci",
        "2ld",
        "l2de",
        "ld4ere",
        "ld4eri",
        "ldi4",
        "ld5is",
        "l3dr",
        "l4dri",
        "le2a",
        "le4bi",
        "left5",
        "5leg.",
        "5legg",
        "le4mat",
        "lem5atic",
        "4len.",
        "3lenc",
        "5lene.",
        "1lent",
        "le3ph",
        "le4pr",
        "lera5b",
        "ler4e",
        "3lerg",
        "3l4eri",
        "l4ero",
        "les2",
        "le5sco",
        "5lesq",
        "3less",
        "5less.",
        "l3eva",
        "lev4er.",
        "lev4era",
        "lev4ers",
        "3ley",
        "4leye",
        "2lf",
        "l5fr",
        "4l1g4",
        "l5ga",
        "lgar3",
        "l4ges",
        "lgo3",
        "2l3h",
        "li4ag",
        "li2am",
        "liar5iz",
        "li4as",
        "li4ato",
        "li5bi",
        "5licio",
        "li4cor",
        "4lics",
        "4lict.",
        "l4icu",
        "l3icy",
        "l3ida",
        "lid5er",
        "3lidi",
        "lif3er",
        "l4iff",
        "li4fl",
        "5ligate",
        "3ligh",
        "li4gra",
        "3lik",
        "4l4i4l",
        "lim4bl",
        "lim3i",
        "li4mo",
        "l4im4p",
        "l4ina",
        "1l4ine",
        "lin3ea",
        "lin3i",
        "link5er",
        "li5og",
        "4l4iq",
        "lis4p",
        "l1it",
        "l2it.",
        "5litica",
        "l5i5tics",
        "liv3er",
        "l1iz",
        "4lj",
        "lka3",
        "l3kal",
        "lka4t",
        "l1l",
        "l4law",
        "l2le",
        "l5lea",
        "l3lec",
        "l3leg",
        "l3lel",
        "l3le4n",
        "l3le4t",
        "ll2i",
        "l2lin4",
        "l5lina",
        "ll4o",
        "lloqui5",
        "ll5out",
        "l5low",
        "2lm",
        "l5met",
        "lm3ing",
        "l4mod",
        "lmon4",
        "2l1n2",
        "3lo.",
        "lob5al",
        "lo4ci",
        "4lof",
        "3logic",
        "l5ogo",
        "3logu",
        "lom3er",
        "5long",
        "lon4i",
        "l3o3niz",
        "lood5",
        "5lope.",
        "lop3i",
        "l3opm",
        "lora4",
        "lo4rato",
        "lo5rie",
        "lor5ou",
        "5los.",
        "los5et",
        "5losophiz",
        "5losophy",
        "los4t",
        "lo4ta",
        "loun5d",
        "2lout",
        "4lov",
        "2lp",
        "lpa5b",
        "l3pha",
        "l5phi",
        "lp5ing",
        "l3pit",
        "l4pl",
        "l5pr",
        "4l1r",
        "2l1s2",
        "l4sc",
        "l2se",
        "l4sie",
        "4lt",
        "lt5ag",
        "ltane5",
        "l1te",
        "lten4",
        "ltera4",
        "lth3i",
        "l5ties.",
        "ltis4",
        "l1tr",
        "ltu2",
        "ltur3a",
        "lu5a",
        "lu3br",
        "luch4",
        "lu3ci",
        "lu3en",
        "luf4",
        "lu5id",
        "lu4ma",
        "5lumi",
        "l5umn.",
        "5lumnia",
        "lu3o",
        "luo3r",
        "4lup",
        "luss4",
        "lus3te",
        "1lut",
        "l5ven",
        "l5vet4",
        "2l1w",
        "1ly",
        "4lya",
        "4lyb",
        "ly5me",
        "ly3no",
        "2lys4",
        "l5yse",
        "1ma",
        "2mab",
        "ma2ca",
        "ma5chine",
        "ma4cl",
        "mag5in",
        "5magn",
        "2mah",
        "maid5",
        "4mald",
        "ma3lig",
        "ma5lin",
        "mal4li",
        "mal4ty",
        "5mania",
        "man5is",
        "man3iz",
        "4map",
        "ma5rine.",
        "ma5riz",
        "mar4ly",
        "mar3v",
        "ma5sce",
        "mas4e",
        "mas1t",
        "5mate",
        "math3",
        "ma3tis",
        "4matiza",
        "4m1b",
        "mba4t5",
        "m5bil",
        "m4b3ing",
        "mbi4v",
        "4m5c",
        "4me.",
        "2med",
        "4med.",
        "5media",
        "me3die",
        "m5e5dy",
        "me2g",
        "mel5on",
        "mel4t",
        "me2m",
        "mem1o3",
        "1men",
        "men4a",
        "men5ac",
        "men4de",
        "4mene",
        "men4i",
        "mens4",
        "mensu5",
        "3ment",
        "men4te",
        "me5on",
        "m5ersa",
        "2mes",
        "3mesti",
        "me4ta",
        "met3al",
        "me1te",
        "me5thi",
        "m4etr",
        "5metric",
        "me5trie",
        "me3try",
        "me4v",
        "4m1f",
        "2mh",
        "5mi.",
        "mi3a",
        "mid4a",
        "mid4g",
        "mig4",
        "3milia",
        "m5i5lie",
        "m4ill",
        "min4a",
        "3mind",
        "m5inee",
        "m4ingl",
        "min5gli",
        "m5ingly",
        "min4t",
        "m4inu",
        "miot4",
        "m2is",
        "mis4er.",
        "mis5l",
        "mis4ti",
        "m5istry",
        "4mith",
        "m2iz",
        "4mk",
        "4m1l",
        "m1m",
        "mma5ry",
        "4m1n",
        "mn4a",
        "m4nin",
        "mn4o",
        "1mo",
        "4mocr",
        "5mocratiz",
        "mo2d1",
        "mo4go",
        "mois2",
        "moi5se",
        "4mok",
        "mo5lest",
        "mo3me",
        "mon5et",
        "mon5ge",
        "moni3a",
        "mon4ism",
        "mon4ist",
        "mo3niz",
        "monol4",
        "mo3ny.",
        "mo2r",
        "4mora.",
        "mos2",
        "mo5sey",
        "mo3sp",
        "moth3",
        "m5ouf",
        "3mous",
        "mo2v",
        "4m1p",
        "mpara5",
        "mpa5rab",
        "mpar5i",
        "m3pet",
        "mphas4",
        "m2pi",
        "mpi4a",
        "mp5ies",
        "m4p1in",
        "m5pir",
        "mp5is",
        "mpo3ri",
        "mpos5ite",
        "m4pous",
        "mpov5",
        "mp4tr",
        "m2py",
        "4m3r",
        "4m1s2",
        "m4sh",
        "m5si",
        "4mt",
        "1mu",
        "mula5r4",
        "5mult",
        "multi3",
        "3mum",
        "mun2",
        "4mup",
        "mu4u",
        "4mw",
        "1na",
        "2n1a2b",
        "n4abu",
        "4nac.",
        "na4ca",
        "n5act",
        "nag5er.",
        "nak4",
        "na4li",
        "na5lia",
        "4nalt",
        "na5mit",
        "n2an",
        "nanci4",
        "nan4it",
        "nank4",
        "nar3c",
        "4nare",
        "nar3i",
        "nar4l",
        "n5arm",
        "n4as",
        "nas4c",
        "nas5ti",
        "n2at",
        "na3tal",
        "nato5miz",
        "n2au",
        "nau3se",
        "3naut",
        "nav4e",
        "4n1b4",
        "ncar5",
        "n4ces.",
        "n3cha",
        "n5cheo",
        "n5chil",
        "n3chis",
        "nc1in",
        "nc4it",
        "ncour5a",
        "n1cr",
        "n1cu",
        "n4dai",
        "n5dan",
        "n1de",
        "nd5est.",
        "ndi4b",
        "n5d2if",
        "n1dit",
        "n3diz",
        "n5duc",
        "ndu4r",
        "nd2we",
        "2ne.",
        "n3ear",
        "ne2b",
        "neb3u",
        "ne2c",
        "5neck",
        "2ned",
        "ne4gat",
        "neg5ativ",
        "5nege",
        "ne4la",
        "nel5iz",
        "ne5mi",
        "ne4mo",
        "1nen",
        "4nene",
        "3neo",
        "ne4po",
        "ne2q",
        "n1er",
        "nera5b",
        "n4erar",
        "n2ere",
        "n4er5i",
        "ner4r",
        "1nes",
        "2nes.",
        "4nesp",
        "2nest",
        "4nesw",
        "3netic",
        "ne4v",
        "n5eve",
        "ne4w",
        "n3f",
        "n4gab",
        "n3gel",
        "nge4n4e",
        "n5gere",
        "n3geri",
        "ng5ha",
        "n3gib",
        "ng1in",
        "n5git",
        "n4gla",
        "ngov4",
        "ng5sh",
        "n1gu",
        "n4gum",
        "n2gy",
        "4n1h4",
        "nha4",
        "nhab3",
        "nhe4",
        "3n4ia",
        "ni3an",
        "ni4ap",
        "ni3ba",
        "ni4bl",
        "ni4d",
        "ni5di",
        "ni4er",
        "ni2fi",
        "ni5ficat",
        "n5igr",
        "nik4",
        "n1im",
        "ni3miz",
        "n1in",
        "5nine.",
        "nin4g",
        "ni4o",
        "5nis.",
        "nis4ta",
        "n2it",
        "n4ith",
        "3nitio",
        "n3itor",
        "ni3tr",
        "n1j",
        "4nk2",
        "n5kero",
        "n3ket",
        "nk3in",
        "n1kl",
        "4n1l",
        "n5m",
        "nme4",
        "nmet4",
        "4n1n2",
        "nne4",
        "nni3al",
        "nni4v",
        "nob4l",
        "no3ble",
        "n5ocl",
        "4n3o2d",
        "3noe",
        "4nog",
        "noge4",
        "nois5i",
        "no5l4i",
        "5nologis",
        "3nomic",
        "n5o5miz",
        "no4mo",
        "no3my",
        "no4n",
        "non4ag",
        "non5i",
        "n5oniz",
        "4nop",
        "5nop5o5li",
        "nor5ab",
        "no4rary",
        "4nosc",
        "nos4e",
        "nos5t",
        "no5ta",
        "1nou",
        "3noun",
        "nov3el3",
        "nowl3",
        "n1p4",
        "npi4",
        "npre4c",
        "n1q",
        "n1r",
        "nru4",
        "2n1s2",
        "ns5ab",
        "nsati4",
        "ns4c",
        "n2se",
        "n4s3es",
        "nsid1",
        "nsig4",
        "n2sl",
        "ns3m",
        "n4soc",
        "ns4pe",
        "n5spi",
        "nsta5bl",
        "n1t",
        "nta4b",
        "nter3s",
        "nt2i",
        "n5tib",
        "nti4er",
        "nti2f",
        "n3tine",
        "n4t3ing",
        "nti4p",
        "ntrol5li",
        "nt4s",
        "ntu3me",
        "nu1a",
        "nu4d",
        "nu5en",
        "nuf4fe",
        "n3uin",
        "3nu3it",
        "n4um",
        "nu1me",
        "n5umi",
        "3nu4n",
        "n3uo",
        "nu3tr",
        "n1v2",
        "n1w4",
        "nym4",
        "nyp4",
        "4nz",
        "n3za",
        "4oa",
        "oad3",
        "o5a5les",
        "oard3",
        "oas4e",
        "oast5e",
        "oat5i",
        "ob3a3b",
        "o5bar",
        "obe4l",
        "o1bi",
        "o2bin",
        "ob5ing",
        "o3br",
        "ob3ul",
        "o1ce",
        "och4",
        "o3chet",
        "ocif3",
        "o4cil",
        "o4clam",
        "o4cod",
        "oc3rac",
        "oc5ratiz",
        "ocre3",
        "5ocrit",
        "octor5a",
        "oc3ula",
        "o5cure",
        "od5ded",
        "od3ic",
        "odi3o",
        "o2do4",
        "odor3",
        "od5uct.",
        "od5ucts",
        "o4el",
        "o5eng",
        "o3er",
        "oe4ta",
        "o3ev",
        "o2fi",
        "of5ite",
        "ofit4t",
        "o2g5a5r",
        "og5ativ",
        "o4gato",
        "o1ge",
        "o5gene",
        "o5geo",
        "o4ger",
        "o3gie",
        "1o1gis",
        "og3it",
        "o4gl",
        "o5g2ly",
        "3ogniz",
        "o4gro",
        "ogu5i",
        "1ogy",
        "2ogyn",
        "o1h2",
        "ohab5",
        "oi2",
        "oic3es",
        "oi3der",
        "oiff4",
        "oig4",
        "oi5let",
        "o3ing",
        "oint5er",
        "o5ism",
        "oi5son",
        "oist5en",
        "oi3ter",
        "o5j",
        "2ok",
        "o3ken",
        "ok5ie",
        "o1la",
        "o4lan",
        "olass4",
        "ol2d",
        "old1e",
        "ol3er",
        "o3lesc",
        "o3let",
        "ol4fi",
        "ol2i",
        "o3lia",
        "o3lice",
        "ol5id.",
        "o3li4f",
        "o5lil",
        "ol3ing",
        "o5lio",
        "o5lis.",
        "ol3ish",
        "o5lite",
        "o5litio",
        "o5liv",
        "olli4e",
        "ol5ogiz",
        "olo4r",
        "ol5pl",
        "ol2t",
        "ol3ub",
        "ol3ume",
        "ol3un",
        "o5lus",
        "ol2v",
        "o2ly",
        "om5ah",
        "oma5l",
        "om5atiz",
        "om2be",
        "om4bl",
        "o2me",
        "om3ena",
        "om5erse",
        "o4met",
        "om5etry",
        "o3mia",
        "om3ic.",
        "om3ica",
        "o5mid",
        "om1in",
        "o5mini",
        "5ommend",
        "omo4ge",
        "o4mon",
        "om3pi",
        "ompro5",
        "o2n",
        "on1a",
        "on4ac",
        "o3nan",
        "on1c",
        "3oncil",
        "2ond",
        "on5do",
        "o3nen",
        "on5est",
        "on4gu",
        "on1ic",
        "o3nio",
        "on1is",
        "o5niu",
        "on3key",
        "on4odi",
        "on3omy",
        "on3s",
        "onspi4",
        "onspir5a",
        "onsu4",
        "onten4",
        "on3t4i",
        "ontif5",
        "on5um",
        "onva5",
        "oo2",
        "ood5e",
        "ood5i",
        "oo4k",
        "oop3i",
        "o3ord",
        "oost5",
        "o2pa",
        "ope5d",
        "op1er",
        "3opera",
        "4operag",
        "2oph",
        "o5phan",
        "o5pher",
        "op3ing",
        "o3pit",
        "o5pon",
        "o4posi",
        "o1pr",
        "op1u",
        "opy5",
        "o1q",
        "o1ra",
        "o5ra.",
        "o4r3ag",
        "or5aliz",
        "or5ange",
        "ore5a",
        "o5real",
        "or3ei",
        "ore5sh",
        "or5est.",
        "orew4",
        "or4gu",
        "4o5ria",
        "or3ica",
        "o5ril",
        "or1in",
        "o1rio",
        "or3ity",
        "o3riu",
        "or2mi",
        "orn2e",
        "o5rof",
        "or3oug",
        "or5pe",
        "3orrh",
        "or4se",
        "ors5en",
        "orst4",
        "or3thi",
        "or3thy",
        "or4ty",
        "o5rum",
        "o1ry",
        "os3al",
        "os2c",
        "os4ce",
        "o3scop",
        "4oscopi",
        "o5scr",
        "os4i4e",
        "os5itiv",
        "os3ito",
        "os3ity",
        "osi4u",
        "os4l",
        "o2so",
        "os4pa",
        "os4po",
        "os2ta",
        "o5stati",
        "os5til",
        "os5tit",
        "o4tan",
        "otele4g",
        "ot3er.",
        "ot5ers",
        "o4tes",
        "4oth",
        "oth5esi",
        "oth3i4",
        "ot3ic.",
        "ot5ica",
        "o3tice",
        "o3tif",
        "o3tis",
        "oto5s",
        "ou2",
        "ou3bl",
        "ouch5i",
        "ou5et",
        "ou4l",
        "ounc5er",
        "oun2d",
        "ou5v",
        "ov4en",
        "over4ne",
        "over3s",
        "ov4ert",
        "o3vis",
        "oviti4",
        "o5v4ol",
        "ow3der",
        "ow3el",
        "ow5est",
        "ow1i",
        "own5i",
        "o4wo",
        "oy1a",
        "1pa",
        "pa4ca",
        "pa4ce",
        "pac4t",
        "p4ad",
        "5pagan",
        "p3agat",
        "p4ai",
        "pain4",
        "p4al",
        "pan4a",
        "pan3el",
        "pan4ty",
        "pa3ny",
        "pa1p",
        "pa4pu",
        "para5bl",
        "par5age",
        "par5di",
        "3pare",
        "par5el",
        "p4a4ri",
        "par4is",
        "pa2te",
        "pa5ter",
        "5pathic",
        "pa5thy",
        "pa4tric",
        "pav4",
        "3pay",
        "4p1b",
        "pd4",
        "4pe.",
        "3pe4a",
        "pear4l",
        "pe2c",
        "2p2ed",
        "3pede",
        "3pedi",
        "pedia4",
        "ped4ic",
        "p4ee",
        "pee4d",
        "pek4",
        "pe4la",
        "peli4e",
        "pe4nan",
        "p4enc",
        "pen4th",
        "pe5on",
        "p4era.",
        "pera5bl",
        "p4erag",
        "p4eri",
        "peri5st",
        "per4mal",
        "perme5",
        "p4ern",
        "per3o",
        "per3ti",
        "pe5ru",
        "per1v",
        "pe2t",
        "pe5ten",
        "pe5tiz",
        "4pf",
        "4pg",
        "4ph.",
        "phar5i",
        "phe3no",
        "ph4er",
        "ph4es.",
        "ph1ic",
        "5phie",
        "ph5ing",
        "5phisti",
        "3phiz",
        "ph2l",
        "3phob",
        "3phone",
        "5phoni",
        "pho4r",
        "4phs",
        "ph3t",
        "5phu",
        "1phy",
        "pi3a",
        "pian4",
        "pi4cie",
        "pi4cy",
        "p4id",
        "p5ida",
        "pi3de",
        "5pidi",
        "3piec",
        "pi3en",
        "pi4grap",
        "pi3lo",
        "pi2n",
        "p4in.",
        "pind4",
        "p4ino",
        "3pi1o",
        "pion4",
        "p3ith",
        "pi5tha",
        "pi2tu",
        "2p3k2",
        "1p2l2",
        "3plan",
        "plas5t",
        "pli3a",
        "pli5er",
        "4plig",
        "pli4n",
        "ploi4",
        "plu4m",
        "plum4b",
        "4p1m",
        "2p3n",
        "po4c",
        "5pod.",
        "po5em",
        "po3et5",
        "5po4g",
        "poin2",
        "5point",
        "poly5t",
        "po4ni",
        "po4p",
        "1p4or",
        "po4ry",
        "1pos",
        "pos1s",
        "p4ot",
        "po4ta",
        "5poun",
        "4p1p",
        "ppa5ra",
        "p2pe",
        "p4ped",
        "p5pel",
        "p3pen",
        "p3per",
        "p3pet",
        "ppo5site",
        "pr2",
        "pray4e",
        "5preci",
        "pre5co",
        "pre3em",
        "pref5ac",
        "pre4la",
        "pre3r",
        "p3rese",
        "3press",
        "pre5ten",
        "pre3v",
        "5pri4e",
        "prin4t3",
        "pri4s",
        "pris3o",
        "p3roca",
        "prof5it",
        "pro3l",
        "pros3e",
        "pro1t",
        "2p1s2",
        "p2se",
        "ps4h",
        "p4sib",
        "2p1t",
        "pt5a4b",
        "p2te",
        "p2th",
        "pti3m",
        "ptu4r",
        "p4tw",
        "pub3",
        "pue4",
        "puf4",
        "pul3c",
        "pu4m",
        "pu2n",
        "pur4r",
        "5pus",
        "pu2t",
        "5pute",
        "put3er",
        "pu3tr",
        "put4ted",
        "put4tin",
        "p3w",
        "qu2",
        "qua5v",
        "2que.",
        "3quer",
        "3quet",
        "2rab",
        "ra3bi",
        "rach4e",
        "r5acl",
        "raf5fi",
        "raf4t",
        "r2ai",
        "ra4lo",
        "ram3et",
        "r2ami",
        "rane5o",
        "ran4ge",
        "r4ani",
        "ra5no",
        "rap3er",
        "3raphy",
        "rar5c",
        "rare4",
        "rar5ef",
        "4raril",
        "r2as",
        "ration4",
        "rau4t",
        "ra5vai",
        "rav3el",
        "ra5zie",
        "r1b",
        "r4bab",
        "r4bag",
        "rbi2",
        "rbi4f",
        "r2bin",
        "r5bine",
        "rb5ing.",
        "rb4o",
        "r1c",
        "r2ce",
        "rcen4",
        "r3cha",
        "rch4er",
        "r4ci4b",
        "rc4it",
        "rcum3",
        "r4dal",
        "rd2i",
        "rdi4a",
        "rdi4er",
        "rdin4",
        "rd3ing",
        "2re.",
        "re1al",
        "re3an",
        "re5arr",
        "5reav",
        "re4aw",
        "r5ebrat",
        "rec5oll",
        "rec5ompe",
        "re4cre",
        "2r2ed",
        "re1de",
        "re3dis",
        "red5it",
        "re4fac",
        "re2fe",
        "re5fer.",
        "re3fi",
        "re4fy",
        "reg3is",
        "re5it",
        "re1li",
        "re5lu",
        "r4en4ta",
        "ren4te",
        "re1o",
        "re5pin",
        "re4posi",
        "re1pu",
        "r1er4",
        "r4eri",
        "rero4",
        "re5ru",
        "r4es.",
        "re4spi",
        "ress5ib",
        "res2t",
        "re5stal",
        "re3str",
        "re4ter",
        "re4ti4z",
        "re3tri",
        "reu2",
        "re5uti",
        "rev2",
        "re4val",
        "rev3el",
        "r5ev5er.",
        "re5vers",
        "re5vert",
        "re5vil",
        "rev5olu",
        "re4wh",
        "r1f",
        "rfu4",
        "r4fy",
        "rg2",
        "rg3er",
        "r3get",
        "r3gic",
        "rgi4n",
        "rg3ing",
        "r5gis",
        "r5git",
        "r1gl",
        "rgo4n",
        "r3gu",
        "rh4",
        "4rh.",
        "4rhal",
        "ri3a",
        "ria4b",
        "ri4ag",
        "r4ib",
        "rib3a",
        "ric5as",
        "r4ice",
        "4rici",
        "5ricid",
        "ri4cie",
        "r4ico",
        "rid5er",
        "ri3enc",
        "ri3ent",
        "ri1er",
        "ri5et",
        "rig5an",
        "5rigi",
        "ril3iz",
        "5riman",
        "rim5i",
        "3rimo",
        "rim4pe",
        "r2ina",
        "5rina.",
        "rin4d",
        "rin4e",
        "rin4g",
        "ri1o",
        "5riph",
        "riph5e",
        "ri2pl",
        "rip5lic",
        "r4iq",
        "r2is",
        "r4is.",
        "ris4c",
        "r3ish",
        "ris4p",
        "ri3ta3b",
        "r5ited.",
        "rit5er.",
        "rit5ers",
        "rit3ic",
        "ri2tu",
        "rit5ur",
        "riv5el",
        "riv3et",
        "riv3i",
        "r3j",
        "r3ket",
        "rk4le",
        "rk4lin",
        "r1l",
        "rle4",
        "r2led",
        "r4lig",
        "r4lis",
        "rl5ish",
        "r3lo4",
        "r1m",
        "rma5c",
        "r2me",
        "r3men",
        "rm5ers",
        "rm3ing",
        "r4ming.",
        "r4mio",
        "r3mit",
        "r4my",
        "r4nar",
        "r3nel",
        "r4ner",
        "r5net",
        "r3ney",
        "r5nic",
        "r1nis4",
        "r3nit",
        "r3niv",
        "rno4",
        "r4nou",
        "r3nu",
        "rob3l",
        "r2oc",
        "ro3cr",
        "ro4e",
        "ro1fe",
        "ro5fil",
        "rok2",
        "ro5ker",
        "5role.",
        "rom5ete",
        "rom4i",
        "rom4p",
        "ron4al",
        "ron4e",
        "ro5n4is",
        "ron4ta",
        "1room",
        "5root",
        "ro3pel",
        "rop3ic",
        "ror3i",
        "ro5ro",
        "ros5per",
        "ros4s",
        "ro4the",
        "ro4ty",
        "ro4va",
        "rov5el",
        "rox5",
        "r1p",
        "r4pea",
        "r5pent",
        "rp5er.",
        "r3pet",
        "rp4h4",
        "rp3ing",
        "r3po",
        "r1r4",
        "rre4c",
        "rre4f",
        "r4reo",
        "rre4st",
        "rri4o",
        "rri4v",
        "rron4",
        "rros4",
        "rrys4",
        "4rs2",
        "r1sa",
        "rsa5ti",
        "rs4c",
        "r2se",
        "r3sec",
        "rse4cr",
        "rs5er.",
        "rs3es",
        "rse5v2",
        "r1sh",
        "r5sha",
        "r1si",
        "r4si4b",
        "rson3",
        "r1sp",
        "r5sw",
        "rtach4",
        "r4tag",
        "r3teb",
        "rten4d",
        "rte5o",
        "r1ti",
        "rt5ib",
        "rti4d",
        "r4tier",
        "r3tig",
        "rtil3i",
        "rtil4l",
        "r4tily",
        "r4tist",
        "r4tiv",
        "r3tri",
        "rtroph4",
        "rt4sh",
        "ru3a",
        "ru3e4l",
        "ru3en",
        "ru4gl",
        "ru3in",
        "rum3pl",
        "ru2n",
        "runk5",
        "run4ty",
        "r5usc",
        "ruti5n",
        "rv4e",
        "rvel4i",
        "r3ven",
        "rv5er.",
        "r5vest",
        "r3vey",
        "r3vic",
        "rvi4v",
        "r3vo",
        "r1w",
        "ry4c",
        "5rynge",
        "ry3t",
        "sa2",
        "2s1ab",
        "5sack",
        "sac3ri",
        "s3act",
        "5sai",
        "salar4",
        "sal4m",
        "sa5lo",
        "sal4t",
        "3sanc",
        "san4de",
        "s1ap",
        "sa5ta",
        "5sa3tio",
        "sat3u",
        "sau4",
        "sa5vor",
        "5saw",
        "4s5b",
        "scan4t5",
        "sca4p",
        "scav5",
        "s4ced",
        "4scei",
        "s4ces",
        "sch2",
        "s4cho",
        "3s4cie",
        "5scin4d",
        "scle5",
        "s4cli",
        "scof4",
        "4scopy",
        "scour5a",
        "s1cu",
        "4s5d",
        "4se.",
        "se4a",
        "seas4",
        "sea5w",
        "se2c3o",
        "3sect",
        "4s4ed",
        "se4d4e",
        "s5edl",
        "se2g",
        "seg3r",
        "5sei",
        "se1le",
        "5self",
        "5selv",
        "4seme",
        "se4mol",
        "sen5at",
        "4senc",
        "sen4d",
        "s5ened",
        "sen5g",
        "s5enin",
        "4sentd",
        "4sentl",
        "sep3a3",
        "4s1er.",
        "s4erl",
        "ser4o",
        "4servo",
        "s1e4s",
        "se5sh",
        "ses5t",
        "5se5um",
        "5sev",
        "sev3en",
        "sew4i",
        "5sex",
        "4s3f",
        "2s3g",
        "s2h",
        "2sh.",
        "sh1er",
        "5shev",
        "sh1in",
        "sh3io",
        "3ship",
        "shiv5",
        "sho4",
        "sh5old",
        "shon3",
        "shor4",
        "short5",
        "4shw",
        "si1b",
        "s5icc",
        "3side.",
        "5sides",
        "5sidi",
        "si5diz",
        "4signa",
        "sil4e",
        "4sily",
        "2s1in",
        "s2ina",
        "5sine.",
        "s3ing",
        "1sio",
        "5sion",
        "sion5a",
        "si2r",
        "sir5a",
        "1sis",
        "3sitio",
        "5siu",
        "1siv",
        "5siz",
        "sk2",
        "4ske",
        "s3ket",
        "sk5ine",
        "sk5ing",
        "s1l2",
        "s3lat",
        "s2le",
        "slith5",
        "2s1m",
        "s3ma",
        "small3",
        "sman3",
        "smel4",
        "s5men",
        "5smith",
        "smol5d4",
        "s1n4",
        "1so",
        "so4ce",
        "soft3",
        "so4lab",
        "sol3d2",
        "so3lic",
        "5solv",
        "3som",
        "3s4on.",
        "sona4",
        "son4g",
        "s4op",
        "5sophic",
        "s5ophiz",
        "s5ophy",
        "sor5c",
        "sor5d",
        "4sov",
        "so5vi",
        "2spa",
        "5spai",
        "spa4n",
        "spen4d",
        "2s5peo",
        "2sper",
        "s2phe",
        "3spher",
        "spho5",
        "spil4",
        "sp5ing",
        "4spio",
        "s4ply",
        "s4pon",
        "spor4",
        "4spot",
        "squal4l",
        "s1r",
        "2ss",
        "s1sa",
        "ssas3",
        "s2s5c",
        "s3sel",
        "s5seng",
        "s4ses.",
        "s5set",
        "s1si",
        "s4sie",
        "ssi4er",
        "ss5ily",
        "s4sl",
        "ss4li",
        "s4sn",
        "sspend4",
        "ss2t",
        "ssur5a",
        "ss5w",
        "2st.",
        "s2tag",
        "s2tal",
        "stam4i",
        "5stand",
        "s4ta4p",
        "5stat.",
        "s4ted",
        "stern5i",
        "s5tero",
        "ste2w",
        "stew5a",
        "s3the",
        "st2i",
        "s4ti.",
        "s5tia",
        "s1tic",
        "5stick",
        "s4tie",
        "s3tif",
        "st3ing",
        "5stir",
        "s1tle",
        "5stock",
        "stom3a",
        "5stone",
        "s4top",
        "3store",
        "st4r",
        "s4trad",
        "5stratu",
        "s4tray",
        "s4trid",
        "4stry",
        "4st3w",
        "s2ty",
        "1su",
        "su1al",
        "su4b3",
        "su2g3",
        "su5is",
        "suit3",
        "s4ul",
        "su2m",
        "sum3i",
        "su2n",
        "su2r",
        "4sv",
        "sw2",
        "4swo",
        "s4y",
        "4syc",
        "3syl",
        "syn5o",
        "sy5rin",
        "1ta",
        "3ta.",
        "2tab",
        "ta5bles",
        "5taboliz",
        "4taci",
        "ta5do",
        "4taf4",
        "tai5lo",
        "ta2l",
        "ta5la",
        "tal5en",
        "tal3i",
        "4talk",
        "tal4lis",
        "ta5log",
        "ta5mo",
        "tan4de",
        "tanta3",
        "ta5per",
        "ta5pl",
        "tar4a",
        "4tarc",
        "4tare",
        "ta3riz",
        "tas4e",
        "ta5sy",
        "4tatic",
        "ta4tur",
        "taun4",
        "tav4",
        "2taw",
        "tax4is",
        "2t1b",
        "4tc",
        "t4ch",
        "tch5et",
        "4t1d",
        "4te.",
        "tead4i",
        "4teat",
        "tece4",
        "5tect",
        "2t1ed",
        "te5di",
        "1tee",
        "teg4",
        "te5ger",
        "te5gi",
        "3tel.",
        "teli4",
        "5tels",
        "te2ma2",
        "tem3at",
        "3tenan",
        "3tenc",
        "3tend",
        "4tenes",
        "1tent",
        "ten4tag",
        "1teo",
        "te4p",
        "te5pe",
        "ter3c",
        "5ter3d",
        "1teri",
        "ter5ies",
        "ter3is",
        "teri5za",
        "5ternit",
        "ter5v",
        "4tes.",
        "4tess",
        "t3ess.",
        "teth5e",
        "3teu",
        "3tex",
        "4tey",
        "2t1f",
        "4t1g",
        "2th.",
        "than4",
        "th2e",
        "4thea",
        "th3eas",
        "the5at",
        "the3is",
        "3thet",
        "th5ic.",
        "th5ica",
        "4thil",
        "5think",
        "4thl",
        "th5ode",
        "5thodic",
        "4thoo",
        "thor5it",
        "tho5riz",
        "2ths",
        "1tia",
        "ti4ab",
        "ti4ato",
        "2ti2b",
        "4tick",
        "t4ico",
        "t4ic1u",
        "5tidi",
        "3tien",
        "tif2",
        "ti5fy",
        "2tig",
        "5tigu",
        "till5in",
        "1tim",
        "4timp",
        "tim5ul",
        "2t1in",
        "t2ina",
        "3tine.",
        "3tini",
        "1tio",
        "ti5oc",
        "tion5ee",
        "5tiq",
        "ti3sa",
        "3tise",
        "tis4m",
        "ti5so",
        "tis4p",
        "5tistica",
        "ti3tl",
        "ti4u",
        "1tiv",
        "tiv4a",
        "1tiz",
        "ti3za",
        "ti3zen",
        "2tl",
        "t5la",
        "tlan4",
        "3tle.",
        "3tled",
        "3tles.",
        "t5let.",
        "t5lo",
        "4t1m",
        "tme4",
        "2t1n2",
        "1to",
        "to3b",
        "to5crat",
        "4todo",
        "2tof",
        "to2gr",
        "to5ic",
        "to2ma",
        "tom4b",
        "to3my",
        "ton4ali",
        "to3nat",
        "4tono",
        "4tony",
        "to2ra",
        "to3rie",
        "tor5iz",
        "tos2",
        "5tour",
        "4tout",
        "to3war",
        "4t1p",
        "1tra",
        "tra3b",
        "tra5ch",
        "traci4",
        "trac4it",
        "trac4te",
        "tras4",
        "tra5ven",
        "trav5es5",
        "tre5f",
        "tre4m",
        "trem5i",
        "5tria",
        "tri5ces",
        "5tricia",
        "4trics",
        "2trim",
        "tri4v",
        "tro5mi",
        "tron5i",
        "4trony",
        "tro5phe",
        "tro3sp",
        "tro3v",
        "tru5i",
        "trus4",
        "4t1s2",
        "t4sc",
        "tsh4",
        "t4sw",
        "4t3t2",
        "t4tes",
        "t5to",
        "ttu4",
        "1tu",
        "tu1a",
        "tu3ar",
        "tu4bi",
        "tud2",
        "4tue",
        "4tuf4",
        "5tu3i",
        "3tum",
        "tu4nis",
        "2t3up.",
        "3ture",
        "5turi",
        "tur3is",
        "tur5o",
        "tu5ry",
        "3tus",
        "4tv",
        "tw4",
        "4t1wa",
        "twis4",
        "4two",
        "1ty",
        "4tya",
        "2tyl",
        "type3",
        "ty5ph",
        "4tz",
        "tz4e",
        "4uab",
        "uac4",
        "ua5na",
        "uan4i",
        "uar5ant",
        "uar2d",
        "uar3i",
        "uar3t",
        "u1at",
        "uav4",
        "ub4e",
        "u4bel",
        "u3ber",
        "u4bero",
        "u1b4i",
        "u4b5ing",
        "u3ble.",
        "u3ca",
        "uci4b",
        "uc4it",
        "ucle3",
        "u3cr",
        "u3cu",
        "u4cy",
        "ud5d",
        "ud3er",
        "ud5est",
        "udev4",
        "u1dic",
        "ud3ied",
        "ud3ies",
        "ud5is",
        "u5dit",
        "u4don",
        "ud4si",
        "u4du",
        "u4ene",
        "uens4",
        "uen4te",
        "uer4il",
        "3ufa",
        "u3fl",
        "ugh3en",
        "ug5in",
        "2ui2",
        "uil5iz",
        "ui4n",
        "u1ing",
        "uir4m",
        "uita4",
        "uiv3",
        "uiv4er.",
        "u5j",
        "4uk",
        "u1la",
        "ula5b",
        "u5lati",
        "ulch4",
        "5ulche",
        "ul3der",
        "ul4e",
        "u1len",
        "ul4gi",
        "ul2i",
        "u5lia",
        "ul3ing",
        "ul5ish",
        "ul4lar",
        "ul4li4b",
        "ul4lis",
        "4ul3m",
        "u1l4o",
        "4uls",
        "uls5es",
        "ul1ti",
        "ultra3",
        "4ultu",
        "u3lu",
        "ul5ul",
        "ul5v",
        "um5ab",
        "um4bi",
        "um4bly",
        "u1mi",
        "u4m3ing",
        "umor5o",
        "um2p",
        "unat4",
        "u2ne",
        "un4er",
        "u1ni",
        "un4im",
        "u2nin",
        "un5ish",
        "uni3v",
        "un3s4",
        "un4sw",
        "unt3ab",
        "un4ter.",
        "un4tes",
        "unu4",
        "un5y",
        "un5z",
        "u4ors",
        "u5os",
        "u1ou",
        "u1pe",
        "uper5s",
        "u5pia",
        "up3ing",
        "u3pl",
        "up3p",
        "upport5",
        "upt5ib",
        "uptu4",
        "u1ra",
        "4ura.",
        "u4rag",
        "u4ras",
        "ur4be",
        "urc4",
        "ur1d",
        "ure5at",
        "ur4fer",
        "ur4fr",
        "u3rif",
        "uri4fic",
        "ur1in",
        "u3rio",
        "u1rit",
        "ur3iz",
        "ur2l",
        "url5ing.",
        "ur4no",
        "uros4",
        "ur4pe",
        "ur4pi",
        "urs5er",
        "ur5tes",
        "ur3the",
        "urti4",
        "ur4tie",
        "u3ru",
        "2us",
        "u5sad",
        "u5san",
        "us4ap",
        "usc2",
        "us3ci",
        "use5a",
        "u5sia",
        "u3sic",
        "us4lin",
        "us1p",
        "us5sl",
        "us5tere",
        "us1tr",
        "u2su",
        "usur4",
        "uta4b",
        "u3tat",
        "4ute.",
        "4utel",
        "4uten",
        "uten4i",
        "4u1t2i",
        "uti5liz",
        "u3tine",
        "ut3ing",
        "ution5a",
        "u4tis",
        "5u5tiz",
        "u4t1l",
        "ut5of",
        "uto5g",
        "uto5matic",
        "u5ton",
        "u4tou",
        "uts4",
        "u3u",
        "uu4m",
        "u1v2",
        "uxu3",
        "uz4e",
        "1va",
        "5va.",
        "2v1a4b",
        "vac5il",
        "vac3u",
        "vag4",
        "va4ge",
        "va5lie",
        "val5o",
        "val1u",
        "va5mo",
        "va5niz",
        "va5pi",
        "var5ied",
        "3vat",
        "4ve.",
        "4ved",
        "veg3",
        "v3el.",
        "vel3li",
        "ve4lo",
        "v4ely",
        "ven3om",
        "v5enue",
        "v4erd",
        "5vere.",
        "v4erel",
        "v3eren",
        "ver5enc",
        "v4eres",
        "ver3ie",
        "vermi4n",
        "3verse",
        "ver3th",
        "v4e2s",
        "4ves.",
        "ves4te",
        "ve4te",
        "vet3er",
        "ve4ty",
        "vi5ali",
        "5vian",
        "5vide.",
        "5vided",
        "4v3iden",
        "5vides",
        "5vidi",
        "v3if",
        "vi5gn",
        "vik4",
        "2vil",
        "5vilit",
        "v3i3liz",
        "v1in",
        "4vi4na",
        "v2inc",
        "vin5d",
        "4ving",
        "vio3l",
        "v3io4r",
        "vi1ou",
        "vi4p",
        "vi5ro",
        "vis3it",
        "vi3so",
        "vi3su",
        "4viti",
        "vit3r",
        "4vity",
        "3viv",
        "5vo.",
        "voi4",
        "3vok",
        "vo4la",
        "v5ole",
        "5volt",
        "3volv",
        "vom5i",
        "vor5ab",
        "vori4",
        "vo4ry",
        "vo4ta",
        "4votee",
        "4vv4",
        "v4y",
        "w5abl",
        "2wac",
        "wa5ger",
        "wag5o",
        "wait5",
        "w5al.",
        "wam4",
        "war4t",
        "was4t",
        "wa1te",
        "wa5ver",
        "w1b",
        "wea5rie",
        "weath3",
        "wed4n",
        "weet3",
        "wee5v",
        "wel4l",
        "w1er",
        "west3",
        "w3ev",
        "whi4",
        "wi2",
        "wil2",
        "will5in",
        "win4de",
        "win4g",
        "wir4",
        "3wise",
        "with3",
        "wiz5",
        "w4k",
        "wl4es",
        "wl3in",
        "w4no",
        "1wo2",
        "wom1",
        "wo5ven",
        "w5p",
        "wra4",
        "wri4",
        "writa4",
        "w3sh",
        "ws4l",
        "ws4pe",
        "w5s4t",
        "4wt",
        "wy4",
        "x1a",
        "xac5e",
        "x4ago",
        "xam3",
        "x4ap",
        "xas5",
        "x3c2",
        "x1e",
        "xe4cuto",
        "x2ed",
        "xer4i",
        "xe5ro",
        "x1h",
        "xhi2",
        "xhil5",
        "xhu4",
        "x3i",
        "xi5a",
        "xi5c",
        "xi5di",
        "x4ime",
        "xi5miz",
        "x3o",
        "x4ob",
        "x3p",
        "xpan4d",
        "xpecto5",
        "xpe3d",
        "x1t2",
        "x3ti",
        "x1u",
        "xu3a",
        "xx4",
        "y5ac",
        "3yar4",
        "y5at",
        "y1b",
        "y1c",
        "y2ce",
        "yc5er",
        "y3ch",
        "ych4e",
        "ycom4",
        "ycot4",
        "y1d",
        "y5ee",
        "y1er",
        "y4erf",
        "yes4",
        "ye4t",
        "y5gi",
        "4y3h",
        "y1i",
        "y3la",
        "ylla5bl",
        "y3lo",
        "y5lu",
        "ymbol5",
        "yme4",
        "ympa3",
        "yn3chr",
        "yn5d",
        "yn5g",
        "yn5ic",
        "5ynx",
        "y1o4",
        "yo5d",
        "y4o5g",
        "yom4",
        "yo5net",
        "y4ons",
        "y4os",
        "y4ped",
        "yper5",
        "yp3i",
        "y3po",
        "y4poc",
        "yp2ta",
        "y5pu",
        "yra5m",
        "yr5ia",
        "y3ro",
        "yr4r",
        "ys4c",
        "y3s2e",
        "ys3ica",
        "ys3io",
        "3ysis",
        "y4so",
        "yss4",
        "ys1t",
        "ys3ta",
        "ysur4",
        "y3thin",
        "yt3ic",
        "y1w",
        "za1",
        "z5a2b",
        "zar2",
        "4zb",
        "2ze",
        "ze4n",
        "ze4p",
        "z1er",
        "ze3ro",
        "zet4",
        "2z1i",
        "z4il",
        "z4is",
        "5zl",
        "4zm",
        "1zo",
        "zo4m",
        "zo5ol",
        "zte4",
        "4z1z2",
        "z4zy",
        // hyphen.tex patterns end here, and additional patterns begin:
        ".con5gr",
        ".de5riva",
        ".dri5v4",
        ".eth1y6l1",
        ".eu4ler",
        ".ev2",
        ".ever5si5b",
        ".ga4s1om1",
        ".ge4ome",
        ".ge5ot1",
        ".he3mo1",
        ".he3p6a",
        ".he3roe",
        ".in5u2t",
        ".kil2n3i",
        ".ko6r1te1",
        ".le6ices",
        ".me4ga1l",
        ".met4ala",
        ".mim5i2c1",
        ".mi1s4ers",
        ".ne6o3f",
        ".noe1th",
        ".non1e2m",
        ".poly1s",
        ".post1am",
        ".pre1am",
        ".rav5en1o",
        ".semi5",
        ".sem4ic",
        ".semid6",
        ".semip4",
        ".semir4",
        ".sem6is4",
        ".semiv4",
        ".sph6in1",
        ".spin1o",
        ".ta5pes1tr",
        ".te3legr",
        ".to6pog",
        ".to2q",
        ".un3at5t",
        ".un5err5",
        ".vi2c3ar",
        ".we2b1l",
        ".re1e4c",
        "a5bolic",
        "a2cabl",
        "af6fish",
        "am1en3ta5b",
        "anal6ys",
        "ano5a2c",
        "ans5gr",
        "ans3v",
        "anti1d",
        "an3ti1n2",
        "anti1re",
        "a4pe5able",
        "ar3che5t",
        "ar2range",
        "as5ymptot",
        "ath3er1o1s",
        "at6tes.",
        "augh4tl",
        "au5li5f",
        "av3iou",
        "back2er.",
        "ba6r1onie",
        "ba1thy",
        "bbi4t",
        "be2vie",
        "bi5d2if",
        "bil2lab",
        "bio5m",
        "bi1orb",
        "bio1rh",
        "b1i3tive",
        "blan2d1",
        "blin2d1",
        "blon2d2",
        "bor1no5",
        "bo2t1u1l",
        "brus4q",
        "bus6i2er",
        "bus6i2es",
        "buss4ing",
        "but2ed.",
        "but4ted",
        "cad5e1m",
        "cat1a1s2",
        "4chs.",
        "chs3hu",
        "chie5vo",
        "cig3a3r",
        "cin2q",
        "cle4ar",
        "co6ph1o3n",
        "cous2ti",
        "cri3tie",
        "croc1o1d",
        "cro5e2co",
        "c2tro3me6c",
        "1cu2r1ance",
        "2d3alone",
        "data1b",
        "dd5a5b",
        "d2d5ib",
        "de4als.",
        "de5clar1",
        "de2c5lina",
        "de3fin3iti",
        "de2mos",
        "des3ic",
        "de2tic",
        "dic1aid",
        "dif5fra",
        "3di1methy",
        "di2ren",
        "di2rer",
        "2d1lead",
        "2d1li2e",
        "3do5word",
        "dren1a5l",
        "drif2t1a",
        "d1ri3pleg5",
        "drom3e5d",
        "d3tab",
        "du2al.",
        "du1op1o1l",
        "ea4n3ies",
        "e3chas",
        "edg1l",
        "ed1uling",
        "eli2t1is",
        "e1loa",
        "en1dix",
        "eo3grap",
        "1e6p3i3neph1",
        "e2r3i4an.",
        "e3spac6i",
        "eth1y6l1ene",
        "5eu2clid1",
        "feb1rua",
        "fermi1o",
        "3fich",
        "fit5ted.",
        "fla1g6el",
        "flow2er.",
        "3fluor",
        "gen2cy.",
        "ge3o1d",
        "ght1we",
        "g1lead",
        "get2ic.",
        "4g1lish",
        "5glo5bin",
        "1g2nac",
        "gnet1ism",
        "gno5mo",
        "g2n1or.",
        "g2noresp",
        "2g1o4n3i1za",
        "graph5er.",
        "griev1",
        "g1utan",
        "hair1s",
        "ha2p3ar5r",
        "hatch1",
        "hex2a3",
        "hite3sid",
        "h3i5pel1a4",
        "hnau3z",
        "ho6r1ic.",
        "h2t1eou",
        "hypo1tha",
        "id4ios",
        "ifac1et",
        "ign4it",
        "ignit1er",
        "i4jk",
        "im3ped3a",
        "infra1s2",
        "i5nitely.",
        "irre6v3oc",
        "i1tesima",
        "ith5i2l",
        "itin5er5ar",
        "janu3a",
        "japan1e2s",
        "je1re1m",
        "1ke6ling",
        "1ki5netic",
        "1kovian",
        "k3sha",
        "la4c3i5e",
        "lai6n3ess",
        "lar5ce1n",
        "l3chai",
        "l3chil6d1",
        "lead6er.",
        "lea4s1a",
        "1lec3ta6b",
        "le3g6en2dre",
        "1le1noid",
        "lith1o5g",
        "ll1fl",
        "l2l3ish",
        "l5mo3nell",
        "lo1bot1o1",
        "lo2ges.",
        "load4ed.",
        "load6er.",
        "l3tea",
        "lth5i2ly",
        "lue1p",
        "1lunk3er",
        "1lum5bia.",
        "3lyg1a1mi",
        "ly5styr",
        "ma1la1p",
        "m2an.",
        "man3u1sc",
        "mar1gin1",
        "medi2c",
        "med3i3cin",
        "medio6c1",
        "me3gran3",
        "m2en.",
        "3mi3da5b",
        "3milita",
        "mil2l1ag",
        "mil5li5li",
        "mi6n3is.",
        "mi1n2ut1er",
        "mi1n2ut1est",
        "m3ma1b",
        "5maph1ro1",
        "5moc1ra1t",
        "mo5e2las",
        "mol1e5c",
        "mon4ey1l",
        "mono3ch",
        "mo4no1en",
        "moro6n5is",
        "mono1s6",
        "moth4et2",
        "m1ou3sin",
        "m5shack2",
        "mu2dro",
        "mul2ti5u",
        "n3ar4chs.",
        "n3ch2es1t",
        "ne3back",
        "2ne1ski",
        "n1dieck",
        "nd3thr",
        "nfi6n3ites",
        "4n5i4an.",
        "nge5nes",
        "ng1ho",
        "ng1spr",
        "nk3rup",
        "n5less",
        "5noc3er1os",
        "nom1a6l",
        "nom5e1no",
        "n1o1mist",
        "non1eq",
        "non1i4so",
        "5nop1oly.",
        "no1vemb",
        "ns5ceiv",
        "ns4moo",
        "ntre1p",
        "obli2g1",
        "o3chas",
        "odel3li",
        "odit1ic",
        "oerst2",
        "oke1st",
        "o3les3ter",
        "oli3gop1o1",
        "o1lo3n4om",
        "o3mecha6",
        "onom1ic",
        "o3norma",
        "o3no2t1o3n",
        "o3nou",
        "op1ism.",
        "or4tho3ni4t",
        "orth1ri",
        "or5tively",
        "o4s3pher",
        "o5test1er",
        "o5tes3tor",
        "oth3e1o1s",
        "ou3ba3do",
        "o6v3i4an.",
        "oxi6d1ic",
        "pal6mat",
        "parag6ra4",
        "par4a1le",
        "param4",
        "para3me",
        "pee2v1",
        "phi2l3ant",
        "phi5lat1e3l",
        "pi2c1a3d",
        "pli2c1ab",
        "pli5nar",
        "poin3ca",
        "1pole.",
        "poly1e",
        "po3lyph1ono",
        "1prema3c",
        "pre1neu",
        "pres2pli",
        "pro2cess",
        "proc3i3ty.",
        "pro2g1e",
        "3pseu2d",
        "pseu3d6o3d2",
        "pseu3d6o3f2",
        "pto3mat4",
        "p5trol3",
        "pu5bes5c",
        "quain2t1e",
        "qu6a3si3",
        "quasir6",
        "quasis6",
        "quin5tes5s",
        "qui3v4ar",
        "r1abolic",
        "3rab1o1loi",
        "ra3chu",
        "r3a3dig",
        "radi1o6g",
        "r2amen",
        "3ra4m5e1triz",
        "ra3mou",
        "ra5n2has",
        "ra1or",
        "r3bin1ge",
        "re2c3i1pr",
        "rec5t6ang",
        "re4t1ribu",
        "r3ial.",
        "riv1o1l",
        "6rk.",
        "rk1ho",
        "r1krau",
        "6rks.",
        "r5le5qu",
        "ro1bot1",
        "ro5e2las",
        "ro5epide1",
        "ro3mesh",
        "ro1tron",
        "r3pau5li",
        "rse1rad1i",
        "r1thou",
        "r1treu",
        "r1veil",
        "rz1sc",
        "sales3c",
        "sales5w",
        "5sa3par5il",
        "sca6p1er",
        "sca2t1ol",
        "s4chitz",
        "schro1ding1",
        "1sci2utt",
        "scrap4er.",
        "scy4th1",
        "sem1a1ph",
        "se3mes1t",
        "se1mi6t5ic",
        "sep3temb",
        "shoe1st",
        "sid2ed.",
        "side5st",
        "side5sw",
        "si5resid",
        "sky1sc",
        "3slova1kia",
        "3s2og1a1my",
        "so2lute",
        "3s2pace",
        "1s2pacin",
        "spe3cio",
        "spher1o",
        "spi2c1il",
        "spokes5w",
        "sports3c",
        "sports3w",
        "s3qui3to",
        "s2s1a3chu1",
        "ss3hat",
        "s2s3i4an.",
        "s5sign5a3b",
        "1s2tamp",
        "s2t1ant5shi",
        "star3tli",
        "sta1ti",
        "st5b",
        "1stor1ab",
        "strat1a1g",
        "strib5ut",
        "st5scr",
        "stu1pi4d1",
        "styl1is",
        "su2per1e6",
        "1sync",
        "1syth3i2",
        "swimm6",
        "5tab1o1lism",
        "ta3gon.",
        "talk1a5",
        "t1a1min",
        "t6ap6ath",
        "5tar2rh",
        "tch1c",
        "tch3i1er",
        "t1cr",
        "teach4er.",
        "tele2g",
        "tele1r6o",
        "3ter1gei",
        "ter2ic.",
        "t3ess2es",
        "tha4l1am",
        "tho3don",
        "th1o5gen1i",
        "tho1k2er",
        "thy4l1an",
        "thy3sc",
        "2t3i4an.",
        "ti2n3o1m",
        "t1li2er",
        "tolo2gy",
        "tot3ic",
        "trai3tor1",
        "tra1vers",
        "travers3a3b",
        "treach1e",
        "tr4ial.",
        "3tro1le1um",
        "trof4ic.",
        "tro3fit",
        "tro1p2is",
        "3trop1o5les",
        "3trop1o5lis",
        "t1ro1pol3it",
        "tsch3ie",
        "ttrib1ut1",
        "turn3ar",
        "t1wh",
        "ty2p5al",
        "ua3drati",
        "uad1ratu",
        "u5do3ny",
        "uea1m",
        "u2r1al.",
        "uri4al.",
        "us2er.",
        "v1ativ",
        "v1oir5du1",
        "va6guer",
        "vaude3v",
        "1verely.",
        "v1er1eig",
        "ves1tite",
        "vi1vip3a3r",
        "voice1p",
        "waste3w6a2",
        "wave1g4",
        "w3c",
        "week1n",
        "wide5sp",
        "wo4k1en",
        "wrap3aro",
        "writ6er.",
        "x1q",
        "xquis3",
        "y5che3d",
        "ym5e5try",
        "y1stro",
        "yes5ter1y",
        "z3ian.",
        "z3o1phr",
        "z2z3w",
        // end of additional patterns.
        ""
      ];
      var hyphenation = [
        "as-so-ciate",
        "as-so-ciates",
        "dec-li-na-tion",
        "oblig-a-tory",
        "phil-an-thropic",
        "present",
        "presents",
        "project",
        "projects",
        "reci-procity",
        "re-cog-ni-zance",
        "ref-or-ma-tion",
        "ret-ri-bu-tion",
        "ta-ble",
        ""
      ];
      return {
        patterns,
        exceptions: hyphenation
      };
    });
  }
});

// ../node_modules/@react-pdf/renderer/node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS({
  "../node_modules/@react-pdf/renderer/node_modules/scheduler/cjs/scheduler.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        Object.defineProperty(exports, "__esModule", { value: true });
        var enableSchedulerDebugging = false;
        var enableIsInputPending = false;
        var enableMessageLoopImplementation = true;
        var enableProfiling = true;
        var requestHostCallback;
        var requestHostTimeout;
        var cancelHostTimeout;
        var shouldYieldToHost;
        var requestPaint;
        if (
          // If Scheduler runs in a non-DOM environment, it falls back to a naive
          // implementation using setTimeout.
          typeof window === "undefined" || // Check if MessageChannel is supported, too.
          typeof MessageChannel !== "function"
        ) {
          var _callback = null;
          var _timeoutID = null;
          var _flushCallback = function() {
            if (_callback !== null) {
              try {
                var currentTime = exports.unstable_now();
                var hasRemainingTime = true;
                _callback(hasRemainingTime, currentTime);
                _callback = null;
              } catch (e) {
                setTimeout(_flushCallback, 0);
                throw e;
              }
            }
          };
          var initialTime = Date.now();
          exports.unstable_now = function() {
            return Date.now() - initialTime;
          };
          requestHostCallback = function(cb) {
            if (_callback !== null) {
              setTimeout(requestHostCallback, 0, cb);
            } else {
              _callback = cb;
              setTimeout(_flushCallback, 0);
            }
          };
          requestHostTimeout = function(cb, ms) {
            _timeoutID = setTimeout(cb, ms);
          };
          cancelHostTimeout = function() {
            clearTimeout(_timeoutID);
          };
          shouldYieldToHost = function() {
            return false;
          };
          requestPaint = exports.unstable_forceFrameRate = function() {
          };
        } else {
          var performance3 = window.performance;
          var _Date = window.Date;
          var _setTimeout = window.setTimeout;
          var _clearTimeout = window.clearTimeout;
          var requestAnimationFrame = window.requestAnimationFrame;
          var cancelAnimationFrame = window.cancelAnimationFrame;
          if (typeof console !== "undefined") {
            if (typeof requestAnimationFrame !== "function") {
              console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");
            }
            if (typeof cancelAnimationFrame !== "function") {
              console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");
            }
          }
          if (typeof performance3 === "object" && typeof performance3.now === "function") {
            exports.unstable_now = function() {
              return performance3.now();
            };
          } else {
            var _initialTime = _Date.now();
            exports.unstable_now = function() {
              return _Date.now() - _initialTime;
            };
          }
          var isRAFLoopRunning = false;
          var isMessageLoopRunning = false;
          var scheduledHostCallback = null;
          var rAFTimeoutID = -1;
          var taskTimeoutID = -1;
          var frameLength = enableMessageLoopImplementation ? (
            // We won't attempt to align with the vsync. Instead we'll yield multiple
            // times per frame, often enough to keep it responsive even at really
            // high frame rates > 120.
            5
          ) : (
            // Use a heuristic to measure the frame rate and yield at the end of the
            // frame. We start out assuming that we run at 30fps but then the
            // heuristic tracking will adjust this value to a faster fps if we get
            // more frequent animation frames.
            33.33
          );
          var prevRAFTime = -1;
          var prevRAFInterval = -1;
          var frameDeadline = 0;
          var fpsLocked = false;
          var maxFrameLength = 300;
          var needsPaint = false;
          if (enableIsInputPending && navigator !== void 0 && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0) {
            var scheduling = navigator.scheduling;
            shouldYieldToHost = function() {
              var currentTime = exports.unstable_now();
              if (currentTime >= frameDeadline) {
                if (needsPaint || scheduling.isInputPending()) {
                  return true;
                }
                return currentTime >= frameDeadline + maxFrameLength;
              } else {
                return false;
              }
            };
            requestPaint = function() {
              needsPaint = true;
            };
          } else {
            shouldYieldToHost = function() {
              return exports.unstable_now() >= frameDeadline;
            };
            requestPaint = function() {
            };
          }
          exports.unstable_forceFrameRate = function(fps) {
            if (fps < 0 || fps > 125) {
              console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported");
              return;
            }
            if (fps > 0) {
              frameLength = Math.floor(1e3 / fps);
              fpsLocked = true;
            } else {
              frameLength = 33.33;
              fpsLocked = false;
            }
          };
          var performWorkUntilDeadline = function() {
            if (enableMessageLoopImplementation) {
              if (scheduledHostCallback !== null) {
                var currentTime = exports.unstable_now();
                frameDeadline = currentTime + frameLength;
                var hasTimeRemaining = true;
                try {
                  var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
                  if (!hasMoreWork) {
                    isMessageLoopRunning = false;
                    scheduledHostCallback = null;
                  } else {
                    port.postMessage(null);
                  }
                } catch (error) {
                  port.postMessage(null);
                  throw error;
                }
              } else {
                isMessageLoopRunning = false;
              }
              needsPaint = false;
            } else {
              if (scheduledHostCallback !== null) {
                var _currentTime = exports.unstable_now();
                var _hasTimeRemaining = frameDeadline - _currentTime > 0;
                try {
                  var _hasMoreWork = scheduledHostCallback(_hasTimeRemaining, _currentTime);
                  if (!_hasMoreWork) {
                    scheduledHostCallback = null;
                  }
                } catch (error) {
                  port.postMessage(null);
                  throw error;
                }
              }
              needsPaint = false;
            }
          };
          var channel = new MessageChannel();
          var port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          var onAnimationFrame = function(rAFTime) {
            if (scheduledHostCallback === null) {
              prevRAFTime = -1;
              prevRAFInterval = -1;
              isRAFLoopRunning = false;
              return;
            }
            isRAFLoopRunning = true;
            requestAnimationFrame(function(nextRAFTime) {
              _clearTimeout(rAFTimeoutID);
              onAnimationFrame(nextRAFTime);
            });
            var onTimeout = function() {
              frameDeadline = exports.unstable_now() + frameLength / 2;
              performWorkUntilDeadline();
              rAFTimeoutID = _setTimeout(onTimeout, frameLength * 3);
            };
            rAFTimeoutID = _setTimeout(onTimeout, frameLength * 3);
            if (prevRAFTime !== -1 && // Make sure this rAF time is different from the previous one. This check
            // could fail if two rAFs fire in the same frame.
            rAFTime - prevRAFTime > 0.1) {
              var rAFInterval = rAFTime - prevRAFTime;
              if (!fpsLocked && prevRAFInterval !== -1) {
                if (rAFInterval < frameLength && prevRAFInterval < frameLength) {
                  frameLength = rAFInterval < prevRAFInterval ? prevRAFInterval : rAFInterval;
                  if (frameLength < 8.33) {
                    frameLength = 8.33;
                  }
                }
              }
              prevRAFInterval = rAFInterval;
            }
            prevRAFTime = rAFTime;
            frameDeadline = rAFTime + frameLength;
            port.postMessage(null);
          };
          requestHostCallback = function(callback) {
            scheduledHostCallback = callback;
            if (enableMessageLoopImplementation) {
              if (!isMessageLoopRunning) {
                isMessageLoopRunning = true;
                port.postMessage(null);
              }
            } else {
              if (!isRAFLoopRunning) {
                isRAFLoopRunning = true;
                requestAnimationFrame(function(rAFTime) {
                  onAnimationFrame(rAFTime);
                });
              }
            }
          };
          requestHostTimeout = function(callback, ms) {
            taskTimeoutID = _setTimeout(function() {
              callback(exports.unstable_now());
            }, ms);
          };
          cancelHostTimeout = function() {
            _clearTimeout(taskTimeoutID);
            taskTimeoutID = -1;
          };
        }
        function push(heap, node) {
          var index3 = heap.length;
          heap.push(node);
          siftUp(heap, node, index3);
        }
        function peek(heap) {
          var first = heap[0];
          return first === void 0 ? null : first;
        }
        function pop(heap) {
          var first = heap[0];
          if (first !== void 0) {
            var last3 = heap.pop();
            if (last3 !== first) {
              heap[0] = last3;
              siftDown(heap, last3, 0);
            }
            return first;
          } else {
            return null;
          }
        }
        function siftUp(heap, node, i) {
          var index3 = i;
          while (true) {
            var parentIndex = Math.floor((index3 - 1) / 2);
            var parent = heap[parentIndex];
            if (parent !== void 0 && compare9(parent, node) > 0) {
              heap[parentIndex] = node;
              heap[index3] = parent;
              index3 = parentIndex;
            } else {
              return;
            }
          }
        }
        function siftDown(heap, node, i) {
          var index3 = i;
          var length4 = heap.length;
          while (index3 < length4) {
            var leftIndex = (index3 + 1) * 2 - 1;
            var left = heap[leftIndex];
            var rightIndex = leftIndex + 1;
            var right = heap[rightIndex];
            if (left !== void 0 && compare9(left, node) < 0) {
              if (right !== void 0 && compare9(right, left) < 0) {
                heap[index3] = right;
                heap[rightIndex] = node;
                index3 = rightIndex;
              } else {
                heap[index3] = left;
                heap[leftIndex] = node;
                index3 = leftIndex;
              }
            } else if (right !== void 0 && compare9(right, node) < 0) {
              heap[index3] = right;
              heap[rightIndex] = node;
              index3 = rightIndex;
            } else {
              return;
            }
          }
        }
        function compare9(a2, b) {
          var diff = a2.sortIndex - b.sortIndex;
          return diff !== 0 ? diff : a2.id - b.id;
        }
        var NoPriority = 0;
        var ImmediatePriority = 1;
        var UserBlockingPriority = 2;
        var NormalPriority = 3;
        var LowPriority = 4;
        var IdlePriority = 5;
        var runIdCounter = 0;
        var mainThreadIdCounter = 0;
        var profilingStateSize = 4;
        var sharedProfilingBuffer = enableProfiling ? (
          // $FlowFixMe Flow doesn't know about SharedArrayBuffer
          typeof SharedArrayBuffer === "function" ? new SharedArrayBuffer(profilingStateSize * Int32Array.BYTES_PER_ELEMENT) : (
            // $FlowFixMe Flow doesn't know about ArrayBuffer
            typeof ArrayBuffer === "function" ? new ArrayBuffer(profilingStateSize * Int32Array.BYTES_PER_ELEMENT) : null
          )
        ) : null;
        var profilingState = enableProfiling && sharedProfilingBuffer !== null ? new Int32Array(sharedProfilingBuffer) : [];
        var PRIORITY = 0;
        var CURRENT_TASK_ID = 1;
        var CURRENT_RUN_ID = 2;
        var QUEUE_SIZE = 3;
        if (enableProfiling) {
          profilingState[PRIORITY] = NoPriority;
          profilingState[QUEUE_SIZE] = 0;
          profilingState[CURRENT_TASK_ID] = 0;
        }
        var INITIAL_EVENT_LOG_SIZE = 131072;
        var MAX_EVENT_LOG_SIZE = 524288;
        var eventLogSize = 0;
        var eventLogBuffer = null;
        var eventLog = null;
        var eventLogIndex = 0;
        var TaskStartEvent = 1;
        var TaskCompleteEvent = 2;
        var TaskErrorEvent = 3;
        var TaskCancelEvent = 4;
        var TaskRunEvent = 5;
        var TaskYieldEvent = 6;
        var SchedulerSuspendEvent = 7;
        var SchedulerResumeEvent = 8;
        function logEvent(entries) {
          if (eventLog !== null) {
            var offset3 = eventLogIndex;
            eventLogIndex += entries.length;
            if (eventLogIndex + 1 > eventLogSize) {
              eventLogSize *= 2;
              if (eventLogSize > MAX_EVENT_LOG_SIZE) {
                console.error("Scheduler Profiling: Event log exceeded maximum size. Don't forget to call `stopLoggingProfilingEvents()`.");
                stopLoggingProfilingEvents();
                return;
              }
              var newEventLog = new Int32Array(eventLogSize * 4);
              newEventLog.set(eventLog);
              eventLogBuffer = newEventLog.buffer;
              eventLog = newEventLog;
            }
            eventLog.set(entries, offset3);
          }
        }
        function startLoggingProfilingEvents() {
          eventLogSize = INITIAL_EVENT_LOG_SIZE;
          eventLogBuffer = new ArrayBuffer(eventLogSize * 4);
          eventLog = new Int32Array(eventLogBuffer);
          eventLogIndex = 0;
        }
        function stopLoggingProfilingEvents() {
          var buffer3 = eventLogBuffer;
          eventLogSize = 0;
          eventLogBuffer = null;
          eventLog = null;
          eventLogIndex = 0;
          return buffer3;
        }
        function markTaskStart(task, ms) {
          if (enableProfiling) {
            profilingState[QUEUE_SIZE]++;
            if (eventLog !== null) {
              logEvent([TaskStartEvent, ms * 1e3, task.id, task.priorityLevel]);
            }
          }
        }
        function markTaskCompleted(task, ms) {
          if (enableProfiling) {
            profilingState[PRIORITY] = NoPriority;
            profilingState[CURRENT_TASK_ID] = 0;
            profilingState[QUEUE_SIZE]--;
            if (eventLog !== null) {
              logEvent([TaskCompleteEvent, ms * 1e3, task.id]);
            }
          }
        }
        function markTaskCanceled(task, ms) {
          if (enableProfiling) {
            profilingState[QUEUE_SIZE]--;
            if (eventLog !== null) {
              logEvent([TaskCancelEvent, ms * 1e3, task.id]);
            }
          }
        }
        function markTaskErrored(task, ms) {
          if (enableProfiling) {
            profilingState[PRIORITY] = NoPriority;
            profilingState[CURRENT_TASK_ID] = 0;
            profilingState[QUEUE_SIZE]--;
            if (eventLog !== null) {
              logEvent([TaskErrorEvent, ms * 1e3, task.id]);
            }
          }
        }
        function markTaskRun(task, ms) {
          if (enableProfiling) {
            runIdCounter++;
            profilingState[PRIORITY] = task.priorityLevel;
            profilingState[CURRENT_TASK_ID] = task.id;
            profilingState[CURRENT_RUN_ID] = runIdCounter;
            if (eventLog !== null) {
              logEvent([TaskRunEvent, ms * 1e3, task.id, runIdCounter]);
            }
          }
        }
        function markTaskYield(task, ms) {
          if (enableProfiling) {
            profilingState[PRIORITY] = NoPriority;
            profilingState[CURRENT_TASK_ID] = 0;
            profilingState[CURRENT_RUN_ID] = 0;
            if (eventLog !== null) {
              logEvent([TaskYieldEvent, ms * 1e3, task.id, runIdCounter]);
            }
          }
        }
        function markSchedulerSuspended(ms) {
          if (enableProfiling) {
            mainThreadIdCounter++;
            if (eventLog !== null) {
              logEvent([SchedulerSuspendEvent, ms * 1e3, mainThreadIdCounter]);
            }
          }
        }
        function markSchedulerUnsuspended(ms) {
          if (enableProfiling) {
            if (eventLog !== null) {
              logEvent([SchedulerResumeEvent, ms * 1e3, mainThreadIdCounter]);
            }
          }
        }
        var maxSigned31BitInt = 1073741823;
        var IMMEDIATE_PRIORITY_TIMEOUT = -1;
        var USER_BLOCKING_PRIORITY = 250;
        var NORMAL_PRIORITY_TIMEOUT = 5e3;
        var LOW_PRIORITY_TIMEOUT = 1e4;
        var IDLE_PRIORITY = maxSigned31BitInt;
        var taskQueue = [];
        var timerQueue = [];
        var taskIdCounter = 1;
        var isSchedulerPaused = false;
        var currentTask = null;
        var currentPriorityLevel = NormalPriority;
        var isPerformingWork = false;
        var isHostCallbackScheduled = false;
        var isHostTimeoutScheduled = false;
        function advanceTimers(currentTime) {
          var timer = peek(timerQueue);
          while (timer !== null) {
            if (timer.callback === null) {
              pop(timerQueue);
            } else if (timer.startTime <= currentTime) {
              pop(timerQueue);
              timer.sortIndex = timer.expirationTime;
              push(taskQueue, timer);
              if (enableProfiling) {
                markTaskStart(timer, currentTime);
                timer.isQueued = true;
              }
            } else {
              return;
            }
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled) {
            if (peek(taskQueue) !== null) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
            }
          }
        }
        function flushWork(hasTimeRemaining, initialTime2) {
          if (enableProfiling) {
            markSchedulerUnsuspended(initialTime2);
          }
          isHostCallbackScheduled = false;
          if (isHostTimeoutScheduled) {
            isHostTimeoutScheduled = false;
            cancelHostTimeout();
          }
          isPerformingWork = true;
          var previousPriorityLevel = currentPriorityLevel;
          try {
            if (enableProfiling) {
              try {
                return workLoop(hasTimeRemaining, initialTime2);
              } catch (error) {
                if (currentTask !== null) {
                  var currentTime = exports.unstable_now();
                  markTaskErrored(currentTask, currentTime);
                  currentTask.isQueued = false;
                }
                throw error;
              }
            } else {
              return workLoop(hasTimeRemaining, initialTime2);
            }
          } finally {
            currentTask = null;
            currentPriorityLevel = previousPriorityLevel;
            isPerformingWork = false;
            if (enableProfiling) {
              var _currentTime = exports.unstable_now();
              markSchedulerSuspended(_currentTime);
            }
          }
        }
        function workLoop(hasTimeRemaining, initialTime2) {
          var currentTime = initialTime2;
          advanceTimers(currentTime);
          currentTask = peek(taskQueue);
          while (currentTask !== null && !(enableSchedulerDebugging && isSchedulerPaused)) {
            if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
              break;
            }
            var callback = currentTask.callback;
            if (callback !== null) {
              currentTask.callback = null;
              currentPriorityLevel = currentTask.priorityLevel;
              var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
              markTaskRun(currentTask, currentTime);
              var continuationCallback = callback(didUserCallbackTimeout);
              currentTime = exports.unstable_now();
              if (typeof continuationCallback === "function") {
                currentTask.callback = continuationCallback;
                markTaskYield(currentTask, currentTime);
              } else {
                if (enableProfiling) {
                  markTaskCompleted(currentTask, currentTime);
                  currentTask.isQueued = false;
                }
                if (currentTask === peek(taskQueue)) {
                  pop(taskQueue);
                }
              }
              advanceTimers(currentTime);
            } else {
              pop(taskQueue);
            }
            currentTask = peek(taskQueue);
          }
          if (currentTask !== null) {
            return true;
          } else {
            var firstTimer = peek(timerQueue);
            if (firstTimer !== null) {
              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
            return false;
          }
        }
        function unstable_runWithPriority(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
            case LowPriority:
            case IdlePriority:
              break;
            default:
              priorityLevel = NormalPriority;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_next(eventHandler) {
          var priorityLevel;
          switch (currentPriorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
              priorityLevel = NormalPriority;
              break;
            default:
              priorityLevel = currentPriorityLevel;
              break;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_wrapCallback(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        }
        function timeoutForPriorityLevel(priorityLevel) {
          switch (priorityLevel) {
            case ImmediatePriority:
              return IMMEDIATE_PRIORITY_TIMEOUT;
            case UserBlockingPriority:
              return USER_BLOCKING_PRIORITY;
            case IdlePriority:
              return IDLE_PRIORITY;
            case LowPriority:
              return LOW_PRIORITY_TIMEOUT;
            case NormalPriority:
            default:
              return NORMAL_PRIORITY_TIMEOUT;
          }
        }
        function unstable_scheduleCallback2(priorityLevel, callback, options) {
          var currentTime = exports.unstable_now();
          var startTime3;
          var timeout;
          if (typeof options === "object" && options !== null) {
            var delay = options.delay;
            if (typeof delay === "number" && delay > 0) {
              startTime3 = currentTime + delay;
            } else {
              startTime3 = currentTime;
            }
            timeout = typeof options.timeout === "number" ? options.timeout : timeoutForPriorityLevel(priorityLevel);
          } else {
            timeout = timeoutForPriorityLevel(priorityLevel);
            startTime3 = currentTime;
          }
          var expirationTime = startTime3 + timeout;
          var newTask = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: startTime3,
            expirationTime,
            sortIndex: -1
          };
          if (enableProfiling) {
            newTask.isQueued = false;
          }
          if (startTime3 > currentTime) {
            newTask.sortIndex = startTime3;
            push(timerQueue, newTask);
            if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
              if (isHostTimeoutScheduled) {
                cancelHostTimeout();
              } else {
                isHostTimeoutScheduled = true;
              }
              requestHostTimeout(handleTimeout, startTime3 - currentTime);
            }
          } else {
            newTask.sortIndex = expirationTime;
            push(taskQueue, newTask);
            if (enableProfiling) {
              markTaskStart(newTask, currentTime);
              newTask.isQueued = true;
            }
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          return newTask;
        }
        function unstable_pauseExecution() {
          isSchedulerPaused = true;
        }
        function unstable_continueExecution() {
          isSchedulerPaused = false;
          if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
          }
        }
        function unstable_getFirstCallbackNode() {
          return peek(taskQueue);
        }
        function unstable_cancelCallback2(task) {
          if (enableProfiling) {
            if (task.isQueued) {
              var currentTime = exports.unstable_now();
              markTaskCanceled(task, currentTime);
              task.isQueued = false;
            }
          }
          task.callback = null;
        }
        function unstable_getCurrentPriorityLevel() {
          return currentPriorityLevel;
        }
        function unstable_shouldYield() {
          var currentTime = exports.unstable_now();
          advanceTimers(currentTime);
          var firstTask = peek(taskQueue);
          return firstTask !== currentTask && currentTask !== null && firstTask !== null && firstTask.callback !== null && firstTask.startTime <= currentTime && firstTask.expirationTime < currentTask.expirationTime || shouldYieldToHost();
        }
        var unstable_requestPaint = requestPaint;
        var unstable_Profiling = enableProfiling ? {
          startLoggingProfilingEvents,
          stopLoggingProfilingEvents,
          sharedProfilingBuffer
        } : null;
        exports.unstable_ImmediatePriority = ImmediatePriority;
        exports.unstable_UserBlockingPriority = UserBlockingPriority;
        exports.unstable_NormalPriority = NormalPriority;
        exports.unstable_IdlePriority = IdlePriority;
        exports.unstable_LowPriority = LowPriority;
        exports.unstable_runWithPriority = unstable_runWithPriority;
        exports.unstable_next = unstable_next;
        exports.unstable_scheduleCallback = unstable_scheduleCallback2;
        exports.unstable_cancelCallback = unstable_cancelCallback2;
        exports.unstable_wrapCallback = unstable_wrapCallback;
        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
        exports.unstable_shouldYield = unstable_shouldYield;
        exports.unstable_requestPaint = unstable_requestPaint;
        exports.unstable_continueExecution = unstable_continueExecution;
        exports.unstable_pauseExecution = unstable_pauseExecution;
        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
        exports.unstable_Profiling = unstable_Profiling;
      })();
    }
  }
});

// ../node_modules/@react-pdf/renderer/node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "../node_modules/@react-pdf/renderer/node_modules/scheduler/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_scheduler_development();
    }
  }
});

// ../node_modules/@react-pdf/renderer/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

// ../node_modules/@react-pdf/primitives/src/index.js
var src_exports = {};
__export(src_exports, {
  Canvas: () => Canvas,
  Circle: () => Circle,
  ClipPath: () => ClipPath,
  Defs: () => Defs,
  Document: () => Document,
  Ellipse: () => Ellipse,
  G: () => G,
  Image: () => Image,
  Line: () => Line,
  LinearGradient: () => LinearGradient,
  Link: () => Link,
  Note: () => Note,
  Page: () => Page,
  Path: () => Path,
  Polygon: () => Polygon,
  Polyline: () => Polyline,
  RadialGradient: () => RadialGradient,
  Rect: () => Rect,
  Stop: () => Stop,
  Svg: () => Svg,
  Text: () => Text,
  TextInstance: () => TextInstance,
  Tspan: () => Tspan,
  View: () => View
});
var G = "G";
var Svg = "SVG";
var View = "VIEW";
var Text = "TEXT";
var Link = "LINK";
var Page = "PAGE";
var Note = "NOTE";
var Path = "PATH";
var Rect = "RECT";
var Line = "LINE";
var Stop = "STOP";
var Defs = "DEFS";
var Image = "IMAGE";
var Tspan = "TSPAN";
var Canvas = "CANVAS";
var Circle = "CIRCLE";
var Ellipse = "ELLIPSE";
var Polygon = "POLYGON";
var Document = "DOCUMENT";
var Polyline = "POLYLINE";
var ClipPath = "CLIP_PATH";
var TextInstance = "TEXT_INSTANCE";
var LinearGradient = "LINEAR_GRADIENT";
var RadialGradient = "RADIAL_GRADIENT";

// ../node_modules/@react-pdf/renderer/lib/react-pdf.browser.es.js
var import_queue = __toESM(require_queue());
var import_react = __toESM(require_react());

// ../node_modules/@react-pdf/renderer/node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}

// ../node_modules/@react-pdf/renderer/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js
function _regeneratorRuntime() {
  "use strict";
  _regeneratorRuntime = function _regeneratorRuntime6() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn3 = Op.hasOwnProperty, defineProperty5 = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define4(obj, key, value2) {
    return Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define4({}, "");
  } catch (err2) {
    define4 = function define5(obj, key, value2) {
      return obj[key] = value2;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty5(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err2) {
      return {
        type: "throw",
        arg: err2
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction3() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define4(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto3 = Object.getPrototypeOf, NativeIteratorPrototype = getProto3 && getProto3(getProto3(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn3.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define4(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve3, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value2 = result.value;
        return value2 && "object" == _typeof(value2) && hasOwn3.call(value2, "__await") ? PromiseImpl.resolve(value2.__await).then(function(value3) {
          invoke("next", value3, resolve3, reject);
        }, function(err2) {
          invoke("throw", err2, resolve3, reject);
        }) : PromiseImpl.resolve(value2).then(function(unwrapped) {
          result.value = unwrapped, resolve3(result);
        }, function(error) {
          return invoke("throw", error, resolve3, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty5(this, "_invoke", {
      value: function value2(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve3, reject) {
            invoke(method, arg, resolve3, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state2 = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state2)
        throw new Error("Generator is already running");
      if ("completed" === state2) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state2)
            throw state2 = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state2 = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state2 = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state2 = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next2 = function next3() {
          for (; ++i < iterable.length; )
            if (hasOwn3.call(iterable, i))
              return next3.value = iterable[i], next3.done = false, next3;
          return next3.value = void 0, next3.done = true, next3;
        };
        return next2.next = next2;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction3.prototype = GeneratorFunctionPrototype, defineProperty5(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty5(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction3,
    configurable: true
  }), GeneratorFunction3.displayName = define4(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction3 || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define4(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define4(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define4(Gp, toStringTagSymbol, "Generator"), define4(Gp, iteratorSymbol, function() {
    return this;
  }), define4(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys5 = [];
    for (var key in object)
      keys5.push(key);
    return keys5.reverse(), function next2() {
      for (; keys5.length; ) {
        var key2 = keys5.pop();
        if (key2 in object)
          return next2.value = key2, next2.done = false, next2;
      }
      return next2.done = true, next2;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn3.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function stop() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn3.call(entry, "catchLoc"), hasFinally = hasOwn3.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn3.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}

// ../node_modules/@react-pdf/renderer/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(gen, resolve3, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value2 = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve3(value2);
  } else {
    Promise.resolve(value2).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve3, reject) {
      var gen = fn.apply(self2, args);
      function _next(value2) {
        asyncGeneratorStep(gen, resolve3, reject, _next, _throw, "next", value2);
      }
      function _throw(err2) {
        asyncGeneratorStep(gen, resolve3, reject, _next, _throw, "throw", err2);
      }
      _next(void 0);
    });
  };
}

// ../node_modules/@react-pdf/font/node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof2(obj) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof2(obj);
}

// ../node_modules/@react-pdf/font/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js
function _regeneratorRuntime2() {
  "use strict";
  _regeneratorRuntime2 = function _regeneratorRuntime6() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn3 = Op.hasOwnProperty, defineProperty5 = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define4(obj, key, value2) {
    return Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define4({}, "");
  } catch (err2) {
    define4 = function define5(obj, key, value2) {
      return obj[key] = value2;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty5(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err2) {
      return {
        type: "throw",
        arg: err2
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction3() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define4(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto3 = Object.getPrototypeOf, NativeIteratorPrototype = getProto3 && getProto3(getProto3(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn3.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define4(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve3, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value2 = result.value;
        return value2 && "object" == _typeof2(value2) && hasOwn3.call(value2, "__await") ? PromiseImpl.resolve(value2.__await).then(function(value3) {
          invoke("next", value3, resolve3, reject);
        }, function(err2) {
          invoke("throw", err2, resolve3, reject);
        }) : PromiseImpl.resolve(value2).then(function(unwrapped) {
          result.value = unwrapped, resolve3(result);
        }, function(error) {
          return invoke("throw", error, resolve3, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty5(this, "_invoke", {
      value: function value2(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve3, reject) {
            invoke(method, arg, resolve3, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state2 = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state2)
        throw new Error("Generator is already running");
      if ("completed" === state2) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state2)
            throw state2 = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state2 = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state2 = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state2 = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next2 = function next3() {
          for (; ++i < iterable.length; )
            if (hasOwn3.call(iterable, i))
              return next3.value = iterable[i], next3.done = false, next3;
          return next3.value = void 0, next3.done = true, next3;
        };
        return next2.next = next2;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction3.prototype = GeneratorFunctionPrototype, defineProperty5(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty5(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction3,
    configurable: true
  }), GeneratorFunction3.displayName = define4(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction3 || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define4(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define4(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define4(Gp, toStringTagSymbol, "Generator"), define4(Gp, iteratorSymbol, function() {
    return this;
  }), define4(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys5 = [];
    for (var key in object)
      keys5.push(key);
    return keys5.reverse(), function next2() {
      for (; keys5.length; ) {
        var key2 = keys5.pop();
        if (key2 in object)
          return next2.value = key2, next2.done = false, next2;
      }
      return next2.done = true, next2;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn3.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function stop() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn3.call(entry, "catchLoc"), hasFinally = hasOwn3.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn3.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}

// ../node_modules/@react-pdf/font/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep2(gen, resolve3, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value2 = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve3(value2);
  } else {
    Promise.resolve(value2).then(_next, _throw);
  }
}
function _asyncToGenerator2(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve3, reject) {
      var gen = fn.apply(self2, args);
      function _next(value2) {
        asyncGeneratorStep2(gen, resolve3, reject, _next, _throw, "next", value2);
      }
      function _throw(err2) {
        asyncGeneratorStep2(gen, resolve3, reject, _next, _throw, "throw", err2);
      }
      _next(void 0);
    });
  };
}

// ../node_modules/@react-pdf/font/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}

// ../node_modules/@react-pdf/font/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}

// ../node_modules/@react-pdf/font/lib/index.browser.es.js
var import_is_url = __toESM(require_is_url());
var import_cross_fetch = __toESM(require_browser_ponyfill());

// ../node_modules/restructure/src/DecodeStream.js
var ENCODING_MAPPING = {
  utf16le: "utf-16le",
  ucs2: "utf-16le",
  utf16be: "utf-16be"
};
var DecodeStream = class {
  constructor(buffer3) {
    this.buffer = buffer3;
    this.view = new DataView(buffer3.buffer, buffer3.byteOffset, buffer3.byteLength);
    this.pos = 0;
    this.length = this.buffer.length;
  }
  readString(length4, encoding = "ascii") {
    encoding = ENCODING_MAPPING[encoding] || encoding;
    let buf = this.readBuffer(length4);
    try {
      let decoder = new TextDecoder(encoding);
      return decoder.decode(buf);
    } catch (err2) {
      return buf;
    }
  }
  readBuffer(length4) {
    return this.buffer.slice(this.pos, this.pos += length4);
  }
  readUInt24BE() {
    return (this.readUInt16BE() << 8) + this.readUInt8();
  }
  readUInt24LE() {
    return this.readUInt16LE() + (this.readUInt8() << 16);
  }
  readInt24BE() {
    return (this.readInt16BE() << 8) + this.readUInt8();
  }
  readInt24LE() {
    return this.readUInt16LE() + (this.readInt8() << 16);
  }
};
DecodeStream.TYPES = {
  UInt8: 1,
  UInt16: 2,
  UInt24: 3,
  UInt32: 4,
  Int8: 1,
  Int16: 2,
  Int24: 3,
  Int32: 4,
  Float: 4,
  Double: 8
};
for (let key of Object.getOwnPropertyNames(DataView.prototype)) {
  if (key.slice(0, 3) === "get") {
    let type = key.slice(3).replace("Ui", "UI");
    if (type === "Float32") {
      type = "Float";
    } else if (type === "Float64") {
      type = "Double";
    }
    let bytes = DecodeStream.TYPES[type];
    DecodeStream.prototype["read" + type + (bytes === 1 ? "" : "BE")] = function() {
      const ret = this.view[key](this.pos, false);
      this.pos += bytes;
      return ret;
    };
    if (bytes !== 1) {
      DecodeStream.prototype["read" + type + "LE"] = function() {
        const ret = this.view[key](this.pos, true);
        this.pos += bytes;
        return ret;
      };
    }
  }
}

// ../node_modules/restructure/src/EncodeStream.js
var textEncoder = new TextEncoder();
var isBigEndian = new Uint8Array(new Uint16Array([4660]).buffer)[0] == 18;
var EncodeStream = class {
  constructor(buffer3) {
    this.buffer = buffer3;
    this.view = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
    this.pos = 0;
  }
  writeBuffer(buffer3) {
    this.buffer.set(buffer3, this.pos);
    this.pos += buffer3.length;
  }
  writeString(string, encoding = "ascii") {
    let buf;
    switch (encoding) {
      case "utf16le":
      case "utf16-le":
      case "ucs2":
        buf = stringToUtf16(string, isBigEndian);
        break;
      case "utf16be":
      case "utf16-be":
        buf = stringToUtf16(string, !isBigEndian);
        break;
      case "utf8":
        buf = textEncoder.encode(string);
        break;
      case "ascii":
        buf = stringToAscii(string);
        break;
      default:
        throw new Error(`Unsupported encoding: ${encoding}`);
    }
    this.writeBuffer(buf);
  }
  writeUInt24BE(val) {
    this.buffer[this.pos++] = val >>> 16 & 255;
    this.buffer[this.pos++] = val >>> 8 & 255;
    this.buffer[this.pos++] = val & 255;
  }
  writeUInt24LE(val) {
    this.buffer[this.pos++] = val & 255;
    this.buffer[this.pos++] = val >>> 8 & 255;
    this.buffer[this.pos++] = val >>> 16 & 255;
  }
  writeInt24BE(val) {
    if (val >= 0) {
      this.writeUInt24BE(val);
    } else {
      this.writeUInt24BE(val + 16777215 + 1);
    }
  }
  writeInt24LE(val) {
    if (val >= 0) {
      this.writeUInt24LE(val);
    } else {
      this.writeUInt24LE(val + 16777215 + 1);
    }
  }
  fill(val, length4) {
    if (length4 < this.buffer.length) {
      this.buffer.fill(val, this.pos, this.pos + length4);
      this.pos += length4;
    } else {
      const buf = new Uint8Array(length4);
      buf.fill(val);
      this.writeBuffer(buf);
    }
  }
};
function stringToUtf16(string, swap4) {
  let buf = new Uint16Array(string.length);
  for (let i = 0; i < string.length; i++) {
    let code3 = string.charCodeAt(i);
    if (swap4) {
      code3 = code3 >> 8 | (code3 & 255) << 8;
    }
    buf[i] = code3;
  }
  return new Uint8Array(buf.buffer);
}
function stringToAscii(string) {
  let buf = new Uint8Array(string.length);
  for (let i = 0; i < string.length; i++) {
    buf[i] = string.charCodeAt(i);
  }
  return buf;
}
for (let key of Object.getOwnPropertyNames(DataView.prototype)) {
  if (key.slice(0, 3) === "set") {
    let type = key.slice(3).replace("Ui", "UI");
    if (type === "Float32") {
      type = "Float";
    } else if (type === "Float64") {
      type = "Double";
    }
    let bytes = DecodeStream.TYPES[type];
    EncodeStream.prototype["write" + type + (bytes === 1 ? "" : "BE")] = function(value2) {
      this.view[key](this.pos, value2, false);
      this.pos += bytes;
    };
    if (bytes !== 1) {
      EncodeStream.prototype["write" + type + "LE"] = function(value2) {
        this.view[key](this.pos, value2, true);
        this.pos += bytes;
      };
    }
  }
}

// ../node_modules/restructure/src/Base.js
var Base = class {
  fromBuffer(buffer3) {
    let stream2 = new DecodeStream(buffer3);
    return this.decode(stream2);
  }
  toBuffer(value2) {
    let size = this.size(value2);
    let buffer3 = new Uint8Array(size);
    let stream2 = new EncodeStream(buffer3);
    this.encode(stream2, value2);
    return buffer3;
  }
};

// ../node_modules/restructure/src/Number.js
var NumberT = class extends Base {
  constructor(type, endian = "BE") {
    super();
    this.type = type;
    this.endian = endian;
    this.fn = this.type;
    if (this.type[this.type.length - 1] !== "8") {
      this.fn += this.endian;
    }
  }
  size() {
    return DecodeStream.TYPES[this.type];
  }
  decode(stream2) {
    return stream2[`read${this.fn}`]();
  }
  encode(stream2, val) {
    return stream2[`write${this.fn}`](val);
  }
};
var uint8 = new NumberT("UInt8");
var uint16be = new NumberT("UInt16", "BE");
var uint16 = uint16be;
var uint16le = new NumberT("UInt16", "LE");
var uint24be = new NumberT("UInt24", "BE");
var uint24 = uint24be;
var uint24le = new NumberT("UInt24", "LE");
var uint32be = new NumberT("UInt32", "BE");
var uint32 = uint32be;
var uint32le = new NumberT("UInt32", "LE");
var int8 = new NumberT("Int8");
var int16be = new NumberT("Int16", "BE");
var int16 = int16be;
var int16le = new NumberT("Int16", "LE");
var int24be = new NumberT("Int24", "BE");
var int24le = new NumberT("Int24", "LE");
var int32be = new NumberT("Int32", "BE");
var int32 = int32be;
var int32le = new NumberT("Int32", "LE");
var floatbe = new NumberT("Float", "BE");
var floatle = new NumberT("Float", "LE");
var doublebe = new NumberT("Double", "BE");
var doublele = new NumberT("Double", "LE");
var Fixed = class extends NumberT {
  constructor(size, endian, fracBits = size >> 1) {
    super(`Int${size}`, endian);
    this._point = 1 << fracBits;
  }
  decode(stream2) {
    return super.decode(stream2) / this._point;
  }
  encode(stream2, val) {
    return super.encode(stream2, val * this._point | 0);
  }
};
var fixed16be = new Fixed(16, "BE");
var fixed16 = fixed16be;
var fixed16le = new Fixed(16, "LE");
var fixed32be = new Fixed(32, "BE");
var fixed32 = fixed32be;
var fixed32le = new Fixed(32, "LE");

// ../node_modules/restructure/src/utils.js
function resolveLength(length4, stream2, parent) {
  let res;
  if (typeof length4 === "number") {
    res = length4;
  } else if (typeof length4 === "function") {
    res = length4.call(parent, parent);
  } else if (parent && typeof length4 === "string") {
    res = parent[length4];
  } else if (stream2 && length4 instanceof NumberT) {
    res = length4.decode(stream2);
  }
  if (isNaN(res)) {
    throw new Error("Not a fixed size");
  }
  return res;
}
var PropertyDescriptor = class {
  constructor(opts2 = {}) {
    this.enumerable = true;
    this.configurable = true;
    for (let key in opts2) {
      const val = opts2[key];
      this[key] = val;
    }
  }
};

// ../node_modules/restructure/src/Array.js
var ArrayT = class extends Base {
  constructor(type, length4, lengthType = "count") {
    super();
    this.type = type;
    this.length = length4;
    this.lengthType = lengthType;
  }
  decode(stream2, parent) {
    let length4;
    const { pos } = stream2;
    const res = [];
    let ctx = parent;
    if (this.length != null) {
      length4 = resolveLength(this.length, stream2, parent);
    }
    if (this.length instanceof NumberT) {
      Object.defineProperties(res, {
        parent: { value: parent },
        _startOffset: { value: pos },
        _currentOffset: { value: 0, writable: true },
        _length: { value: length4 }
      });
      ctx = res;
    }
    if (length4 == null || this.lengthType === "bytes") {
      const target = length4 != null ? stream2.pos + length4 : (parent != null ? parent._length : void 0) ? parent._startOffset + parent._length : stream2.length;
      while (stream2.pos < target) {
        res.push(this.type.decode(stream2, ctx));
      }
    } else {
      for (let i = 0, end3 = length4; i < end3; i++) {
        res.push(this.type.decode(stream2, ctx));
      }
    }
    return res;
  }
  size(array, ctx, includePointers = true) {
    if (!array) {
      return this.type.size(null, ctx) * resolveLength(this.length, null, ctx);
    }
    let size = 0;
    if (this.length instanceof NumberT) {
      size += this.length.size();
      ctx = { parent: ctx, pointerSize: 0 };
    }
    for (let item of array) {
      size += this.type.size(item, ctx);
    }
    if (ctx && includePointers && this.length instanceof NumberT) {
      size += ctx.pointerSize;
    }
    return size;
  }
  encode(stream2, array, parent) {
    let ctx = parent;
    if (this.length instanceof NumberT) {
      ctx = {
        pointers: [],
        startOffset: stream2.pos,
        parent
      };
      ctx.pointerOffset = stream2.pos + this.size(array, ctx, false);
      this.length.encode(stream2, array.length);
    }
    for (let item of array) {
      this.type.encode(stream2, item, ctx);
    }
    if (this.length instanceof NumberT) {
      let i = 0;
      while (i < ctx.pointers.length) {
        const ptr = ctx.pointers[i++];
        ptr.type.encode(stream2, ptr.val, ptr.parent);
      }
    }
  }
};

// ../node_modules/restructure/src/LazyArray.js
var LazyArray = class extends ArrayT {
  decode(stream2, parent) {
    const { pos } = stream2;
    const length4 = resolveLength(this.length, stream2, parent);
    if (this.length instanceof NumberT) {
      parent = {
        parent,
        _startOffset: pos,
        _currentOffset: 0,
        _length: length4
      };
    }
    const res = new LazyArrayValue(this.type, length4, stream2, parent);
    stream2.pos += length4 * this.type.size(null, parent);
    return res;
  }
  size(val, ctx) {
    if (val instanceof LazyArrayValue) {
      val = val.toArray();
    }
    return super.size(val, ctx);
  }
  encode(stream2, val, ctx) {
    if (val instanceof LazyArrayValue) {
      val = val.toArray();
    }
    return super.encode(stream2, val, ctx);
  }
};
var LazyArrayValue = class {
  constructor(type, length4, stream2, ctx) {
    this.type = type;
    this.length = length4;
    this.stream = stream2;
    this.ctx = ctx;
    this.base = this.stream.pos;
    this.items = [];
  }
  get(index3) {
    if (index3 < 0 || index3 >= this.length) {
      return void 0;
    }
    if (this.items[index3] == null) {
      const { pos } = this.stream;
      this.stream.pos = this.base + this.type.size(null, this.ctx) * index3;
      this.items[index3] = this.type.decode(this.stream, this.ctx);
      this.stream.pos = pos;
    }
    return this.items[index3];
  }
  toArray() {
    const result = [];
    for (let i = 0, end3 = this.length; i < end3; i++) {
      result.push(this.get(i));
    }
    return result;
  }
};

// ../node_modules/restructure/src/Bitfield.js
var Bitfield = class extends Base {
  constructor(type, flags = []) {
    super();
    this.type = type;
    this.flags = flags;
  }
  decode(stream2) {
    const val = this.type.decode(stream2);
    const res = {};
    for (let i = 0; i < this.flags.length; i++) {
      const flag = this.flags[i];
      if (flag != null) {
        res[flag] = !!(val & 1 << i);
      }
    }
    return res;
  }
  size() {
    return this.type.size();
  }
  encode(stream2, keys5) {
    let val = 0;
    for (let i = 0; i < this.flags.length; i++) {
      const flag = this.flags[i];
      if (flag != null) {
        if (keys5[flag]) {
          val |= 1 << i;
        }
      }
    }
    return this.type.encode(stream2, val);
  }
};

// ../node_modules/restructure/src/Buffer.js
var BufferT = class extends Base {
  constructor(length4) {
    super();
    this.length = length4;
  }
  decode(stream2, parent) {
    const length4 = resolveLength(this.length, stream2, parent);
    return stream2.readBuffer(length4);
  }
  size(val, parent) {
    if (!val) {
      return resolveLength(this.length, null, parent);
    }
    let len = val.length;
    if (this.length instanceof NumberT) {
      len += this.length.size();
    }
    return len;
  }
  encode(stream2, buf, parent) {
    if (this.length instanceof NumberT) {
      this.length.encode(stream2, buf.length);
    }
    return stream2.writeBuffer(buf);
  }
};

// ../node_modules/restructure/src/Optional.js
var Optional = class extends Base {
  constructor(type, condition = true) {
    super();
    this.type = type;
    this.condition = condition;
  }
  decode(stream2, parent) {
    let { condition } = this;
    if (typeof condition === "function") {
      condition = condition.call(parent, parent);
    }
    if (condition) {
      return this.type.decode(stream2, parent);
    }
  }
  size(val, parent) {
    let { condition } = this;
    if (typeof condition === "function") {
      condition = condition.call(parent, parent);
    }
    if (condition) {
      return this.type.size(val, parent);
    } else {
      return 0;
    }
  }
  encode(stream2, val, parent) {
    let { condition } = this;
    if (typeof condition === "function") {
      condition = condition.call(parent, parent);
    }
    if (condition) {
      return this.type.encode(stream2, val, parent);
    }
  }
};

// ../node_modules/restructure/src/Reserved.js
var Reserved = class extends Base {
  constructor(type, count = 1) {
    super();
    this.type = type;
    this.count = count;
  }
  decode(stream2, parent) {
    stream2.pos += this.size(null, parent);
    return void 0;
  }
  size(data2, parent) {
    const count = resolveLength(this.count, null, parent);
    return this.type.size() * count;
  }
  encode(stream2, val, parent) {
    return stream2.fill(0, this.size(val, parent));
  }
};

// ../node_modules/restructure/src/String.js
var StringT = class extends Base {
  constructor(length4, encoding = "ascii") {
    super();
    this.length = length4;
    this.encoding = encoding;
  }
  decode(stream2, parent) {
    let length4, pos;
    if (this.length != null) {
      length4 = resolveLength(this.length, stream2, parent);
    } else {
      let buffer3;
      ({ buffer: buffer3, length: length4, pos } = stream2);
      while (pos < length4 && buffer3[pos] !== 0) {
        ++pos;
      }
      length4 = pos - stream2.pos;
    }
    let { encoding } = this;
    if (typeof encoding === "function") {
      encoding = encoding.call(parent, parent) || "ascii";
    }
    const string = stream2.readString(length4, encoding);
    if (this.length == null && stream2.pos < stream2.length) {
      stream2.pos++;
    }
    return string;
  }
  size(val, parent) {
    if (!val) {
      return resolveLength(this.length, null, parent);
    }
    let { encoding } = this;
    if (typeof encoding === "function") {
      encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || "ascii";
    }
    if (encoding === "utf16be") {
      encoding = "utf16le";
    }
    let size = byteLength(val, encoding);
    if (this.length instanceof NumberT) {
      size += this.length.size();
    }
    if (this.length == null) {
      size++;
    }
    return size;
  }
  encode(stream2, val, parent) {
    let { encoding } = this;
    if (typeof encoding === "function") {
      encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || "ascii";
    }
    if (this.length instanceof NumberT) {
      this.length.encode(stream2, byteLength(val, encoding));
    }
    stream2.writeString(val, encoding);
    if (this.length == null) {
      return stream2.writeUInt8(0);
    }
  }
};
function byteLength(string, encoding) {
  switch (encoding) {
    case "ascii":
      return string.length;
    case "utf8":
      let len = 0;
      for (let i = 0; i < string.length; i++) {
        let c2 = string.charCodeAt(i);
        if (c2 >= 55296 && c2 <= 56319 && i < string.length - 1) {
          let c22 = string.charCodeAt(++i);
          if ((c22 & 64512) === 56320) {
            c2 = ((c2 & 1023) << 10) + (c22 & 1023) + 65536;
          } else {
            i--;
          }
        }
        if ((c2 & 4294967168) === 0) {
          len++;
        } else if ((c2 & 4294965248) === 0) {
          len += 2;
        } else if ((c2 & 4294901760) === 0) {
          len += 3;
        } else if ((c2 & 4292870144) === 0) {
          len += 4;
        }
      }
      return len;
    case "utf16le":
    case "utf16-le":
    case "utf16be":
    case "utf16-be":
    case "ucs2":
      return string.length * 2;
    default:
      throw new Error("Unknown encoding " + encoding);
  }
}

// ../node_modules/restructure/src/Struct.js
var Struct = class extends Base {
  constructor(fields = {}) {
    super();
    this.fields = fields;
  }
  decode(stream2, parent, length4 = 0) {
    const res = this._setup(stream2, parent, length4);
    this._parseFields(stream2, res, this.fields);
    if (this.process != null) {
      this.process.call(res, stream2);
    }
    return res;
  }
  _setup(stream2, parent, length4) {
    const res = {};
    Object.defineProperties(res, {
      parent: { value: parent },
      _startOffset: { value: stream2.pos },
      _currentOffset: { value: 0, writable: true },
      _length: { value: length4 }
    });
    return res;
  }
  _parseFields(stream2, res, fields) {
    for (let key in fields) {
      var val;
      const type = fields[key];
      if (typeof type === "function") {
        val = type.call(res, res);
      } else {
        val = type.decode(stream2, res);
      }
      if (val !== void 0) {
        if (val instanceof PropertyDescriptor) {
          Object.defineProperty(res, key, val);
        } else {
          res[key] = val;
        }
      }
      res._currentOffset = stream2.pos - res._startOffset;
    }
  }
  size(val, parent, includePointers = true) {
    if (val == null) {
      val = {};
    }
    const ctx = {
      parent,
      val,
      pointerSize: 0
    };
    if (this.preEncode != null) {
      this.preEncode.call(val);
    }
    let size = 0;
    for (let key in this.fields) {
      const type = this.fields[key];
      if (type.size != null) {
        size += type.size(val[key], ctx);
      }
    }
    if (includePointers) {
      size += ctx.pointerSize;
    }
    return size;
  }
  encode(stream2, val, parent) {
    let type;
    if (this.preEncode != null) {
      this.preEncode.call(val, stream2);
    }
    const ctx = {
      pointers: [],
      startOffset: stream2.pos,
      parent,
      val,
      pointerSize: 0
    };
    ctx.pointerOffset = stream2.pos + this.size(val, ctx, false);
    for (let key in this.fields) {
      type = this.fields[key];
      if (type.encode != null) {
        type.encode(stream2, val[key], ctx);
      }
    }
    let i = 0;
    while (i < ctx.pointers.length) {
      const ptr = ctx.pointers[i++];
      ptr.type.encode(stream2, ptr.val, ptr.parent);
    }
  }
};

// ../node_modules/restructure/src/VersionedStruct.js
var getPath = (object, pathArray) => {
  return pathArray.reduce((prevObj, key) => prevObj && prevObj[key], object);
};
var VersionedStruct = class _VersionedStruct extends Struct {
  constructor(type, versions3 = {}) {
    super();
    this.type = type;
    this.versions = versions3;
    if (typeof type === "string") {
      this.versionPath = type.split(".");
    }
  }
  decode(stream2, parent, length4 = 0) {
    const res = this._setup(stream2, parent, length4);
    if (typeof this.type === "string") {
      res.version = getPath(parent, this.versionPath);
    } else {
      res.version = this.type.decode(stream2);
    }
    if (this.versions.header) {
      this._parseFields(stream2, res, this.versions.header);
    }
    const fields = this.versions[res.version];
    if (fields == null) {
      throw new Error(`Unknown version ${res.version}`);
    }
    if (fields instanceof _VersionedStruct) {
      return fields.decode(stream2, parent);
    }
    this._parseFields(stream2, res, fields);
    if (this.process != null) {
      this.process.call(res, stream2);
    }
    return res;
  }
  size(val, parent, includePointers = true) {
    let key, type;
    if (!val) {
      throw new Error("Not a fixed size");
    }
    if (this.preEncode != null) {
      this.preEncode.call(val);
    }
    const ctx = {
      parent,
      val,
      pointerSize: 0
    };
    let size = 0;
    if (typeof this.type !== "string") {
      size += this.type.size(val.version, ctx);
    }
    if (this.versions.header) {
      for (key in this.versions.header) {
        type = this.versions.header[key];
        if (type.size != null) {
          size += type.size(val[key], ctx);
        }
      }
    }
    const fields = this.versions[val.version];
    if (fields == null) {
      throw new Error(`Unknown version ${val.version}`);
    }
    for (key in fields) {
      type = fields[key];
      if (type.size != null) {
        size += type.size(val[key], ctx);
      }
    }
    if (includePointers) {
      size += ctx.pointerSize;
    }
    return size;
  }
  encode(stream2, val, parent) {
    let key, type;
    if (this.preEncode != null) {
      this.preEncode.call(val, stream2);
    }
    const ctx = {
      pointers: [],
      startOffset: stream2.pos,
      parent,
      val,
      pointerSize: 0
    };
    ctx.pointerOffset = stream2.pos + this.size(val, ctx, false);
    if (typeof this.type !== "string") {
      this.type.encode(stream2, val.version);
    }
    if (this.versions.header) {
      for (key in this.versions.header) {
        type = this.versions.header[key];
        if (type.encode != null) {
          type.encode(stream2, val[key], ctx);
        }
      }
    }
    const fields = this.versions[val.version];
    for (key in fields) {
      type = fields[key];
      if (type.encode != null) {
        type.encode(stream2, val[key], ctx);
      }
    }
    let i = 0;
    while (i < ctx.pointers.length) {
      const ptr = ctx.pointers[i++];
      ptr.type.encode(stream2, ptr.val, ptr.parent);
    }
  }
};

// ../node_modules/restructure/src/Pointer.js
var Pointer = class extends Base {
  constructor(offsetType, type, options = {}) {
    super();
    this.offsetType = offsetType;
    this.type = type;
    this.options = options;
    if (this.type === "void") {
      this.type = null;
    }
    if (this.options.type == null) {
      this.options.type = "local";
    }
    if (this.options.allowNull == null) {
      this.options.allowNull = true;
    }
    if (this.options.nullValue == null) {
      this.options.nullValue = 0;
    }
    if (this.options.lazy == null) {
      this.options.lazy = false;
    }
    if (this.options.relativeTo) {
      if (typeof this.options.relativeTo !== "function") {
        throw new Error("relativeTo option must be a function");
      }
      this.relativeToGetter = options.relativeTo;
    }
  }
  decode(stream2, ctx) {
    const offset3 = this.offsetType.decode(stream2, ctx);
    if (offset3 === this.options.nullValue && this.options.allowNull) {
      return null;
    }
    let relative;
    switch (this.options.type) {
      case "local":
        relative = ctx._startOffset;
        break;
      case "immediate":
        relative = stream2.pos - this.offsetType.size();
        break;
      case "parent":
        relative = ctx.parent._startOffset;
        break;
      default:
        var c2 = ctx;
        while (c2.parent) {
          c2 = c2.parent;
        }
        relative = c2._startOffset || 0;
    }
    if (this.options.relativeTo) {
      relative += this.relativeToGetter(ctx);
    }
    const ptr = offset3 + relative;
    if (this.type != null) {
      let val = null;
      const decodeValue = () => {
        if (val != null) {
          return val;
        }
        const { pos } = stream2;
        stream2.pos = ptr;
        val = this.type.decode(stream2, ctx);
        stream2.pos = pos;
        return val;
      };
      if (this.options.lazy) {
        return new PropertyDescriptor({
          get: decodeValue
        });
      }
      return decodeValue();
    } else {
      return ptr;
    }
  }
  size(val, ctx) {
    const parent = ctx;
    switch (this.options.type) {
      case "local":
      case "immediate":
        break;
      case "parent":
        ctx = ctx.parent;
        break;
      default:
        while (ctx.parent) {
          ctx = ctx.parent;
        }
    }
    let { type } = this;
    if (type == null) {
      if (!(val instanceof VoidPointer)) {
        throw new Error("Must be a VoidPointer");
      }
      ({ type } = val);
      val = val.value;
    }
    if (val && ctx) {
      let size = type.size(val, parent);
      ctx.pointerSize += size;
    }
    return this.offsetType.size();
  }
  encode(stream2, val, ctx) {
    let relative;
    const parent = ctx;
    if (val == null) {
      this.offsetType.encode(stream2, this.options.nullValue);
      return;
    }
    switch (this.options.type) {
      case "local":
        relative = ctx.startOffset;
        break;
      case "immediate":
        relative = stream2.pos + this.offsetType.size(val, parent);
        break;
      case "parent":
        ctx = ctx.parent;
        relative = ctx.startOffset;
        break;
      default:
        relative = 0;
        while (ctx.parent) {
          ctx = ctx.parent;
        }
    }
    if (this.options.relativeTo) {
      relative += this.relativeToGetter(parent.val);
    }
    this.offsetType.encode(stream2, ctx.pointerOffset - relative);
    let { type } = this;
    if (type == null) {
      if (!(val instanceof VoidPointer)) {
        throw new Error("Must be a VoidPointer");
      }
      ({ type } = val);
      val = val.value;
    }
    ctx.pointers.push({
      type,
      val,
      parent
    });
    return ctx.pointerOffset += type.size(val, parent);
  }
};
var VoidPointer = class {
  constructor(type, value2) {
    this.type = type;
    this.value = value2;
  }
};

// ../node_modules/fontkit/node_modules/@swc/helpers/src/_define_property.mjs
function _defineProperty(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}

// ../node_modules/fontkit/dist/browser-module.mjs
var import_fast_deep_equal = __toESM(require_fast_deep_equal(), 1);

// ../node_modules/unicode-properties/dist/module.mjs
var import_base64_js = __toESM(require_base64_js(), 1);
var import_unicode_trie = __toESM(require_unicode_trie(), 1);
function $parcel$interopDefault(a2) {
  return a2 && a2.__esModule ? a2.default : a2;
}
var $f4087201da764553$exports = {};
$f4087201da764553$exports = JSON.parse('{"categories":["Cc","Zs","Po","Sc","Ps","Pe","Sm","Pd","Nd","Lu","Sk","Pc","Ll","So","Lo","Pi","Cf","No","Pf","Lt","Lm","Mn","Me","Mc","Nl","Zl","Zp","Cs","Co"],"combiningClasses":["Not_Reordered","Above","Above_Right","Below","Attached_Above_Right","Attached_Below","Overlay","Iota_Subscript","Double_Below","Double_Above","Below_Right","Above_Left","CCC10","CCC11","CCC12","CCC13","CCC14","CCC15","CCC16","CCC17","CCC18","CCC19","CCC20","CCC21","CCC22","CCC23","CCC24","CCC25","CCC30","CCC31","CCC32","CCC27","CCC28","CCC29","CCC33","CCC34","CCC35","CCC36","Nukta","Virama","CCC84","CCC91","CCC103","CCC107","CCC118","CCC122","CCC129","CCC130","CCC132","Attached_Above","Below_Left","Left","Kana_Voicing","CCC26","Right"],"scripts":["Common","Latin","Bopomofo","Inherited","Greek","Coptic","Cyrillic","Armenian","Hebrew","Arabic","Syriac","Thaana","Nko","Samaritan","Mandaic","Devanagari","Bengali","Gurmukhi","Gujarati","Oriya","Tamil","Telugu","Kannada","Malayalam","Sinhala","Thai","Lao","Tibetan","Myanmar","Georgian","Hangul","Ethiopic","Cherokee","Canadian_Aboriginal","Ogham","Runic","Tagalog","Hanunoo","Buhid","Tagbanwa","Khmer","Mongolian","Limbu","Tai_Le","New_Tai_Lue","Buginese","Tai_Tham","Balinese","Sundanese","Batak","Lepcha","Ol_Chiki","Braille","Glagolitic","Tifinagh","Han","Hiragana","Katakana","Yi","Lisu","Vai","Bamum","Syloti_Nagri","Phags_Pa","Saurashtra","Kayah_Li","Rejang","Javanese","Cham","Tai_Viet","Meetei_Mayek","null","Linear_B","Lycian","Carian","Old_Italic","Gothic","Old_Permic","Ugaritic","Old_Persian","Deseret","Shavian","Osmanya","Osage","Elbasan","Caucasian_Albanian","Linear_A","Cypriot","Imperial_Aramaic","Palmyrene","Nabataean","Hatran","Phoenician","Lydian","Meroitic_Hieroglyphs","Meroitic_Cursive","Kharoshthi","Old_South_Arabian","Old_North_Arabian","Manichaean","Avestan","Inscriptional_Parthian","Inscriptional_Pahlavi","Psalter_Pahlavi","Old_Turkic","Old_Hungarian","Hanifi_Rohingya","Old_Sogdian","Sogdian","Elymaic","Brahmi","Kaithi","Sora_Sompeng","Chakma","Mahajani","Sharada","Khojki","Multani","Khudawadi","Grantha","Newa","Tirhuta","Siddham","Modi","Takri","Ahom","Dogra","Warang_Citi","Nandinagari","Zanabazar_Square","Soyombo","Pau_Cin_Hau","Bhaiksuki","Marchen","Masaram_Gondi","Gunjala_Gondi","Makasar","Cuneiform","Egyptian_Hieroglyphs","Anatolian_Hieroglyphs","Mro","Bassa_Vah","Pahawh_Hmong","Medefaidrin","Miao","Tangut","Nushu","Duployan","SignWriting","Nyiakeng_Puachue_Hmong","Wancho","Mende_Kikakui","Adlam"],"eaw":["N","Na","A","W","H","F"]}');
var $747425b437e121da$var$trie = new (0, import_unicode_trie.default)((0, import_base64_js.default).toByteArray("AAARAAAAAADwfAEAZXl5ONRt+/5bPVFZimRfKoTQJNm37CGE7Iw0j3UsTWKsoyI7kwyyTiEUzSD7NiEzhWYijH0wMVkHE4Mx49fzfo+3nuP4/fdZjvv+XNd5n/d9nef1WZvmKhTxiZndzDQBSEYQqxqKwnsKvGQucFh+6t6cJ792ePQBZv5S9yXSwkyjf/P4T7mTNnIAv1dOVhMlR9lflbUL9JeJguqsjvG9NTj/wLb566VAURnLo2vvRi89S3gW/33ihh2eXpDn40BIW7REl/7coRKIhAFlAiOtbLDTt6mMb4GzMF1gNnvX/sBxtbsAIjfztCNcQjcNDtLThRvuXu5M5g/CBjaLBE4lJm4qy/oZD97+IJryApcXfgWYlkvWbhfXgujOJKVu8B+ozqTLbxyJ5kNiR75CxDqfBM9eOlDMmGeoZ0iQbbS5VUplIwI+ZNXEKQVJxlwqjhOY7w3XwPesbLK5JZE+Tt4X8q8km0dzInsPPzbscrjBMVjF5mOHSeRdJVgKUjLTHiHqXSPkep8N/zFk8167KLp75f6RndkvzdfB6Uz3MmqvRArzdCbs1/iRZjYPLLF3U8Qs+H+Rb8iK51a6NIV2V9+07uJsTGFWpPz8J++7iRu2B6eAKlK/kujrLthwaD/7a6J5w90TusnH1JMAc+gNrql4aspOUG/RrsxUKmPzhHgP4Bleru+6Vfc/MBjgXVx7who94nPn7MPFrnwQP7g0k0Dq0h2GSKO6fTZ8nLodN1SiOUj/5EL/Xo1DBvRm0wmrh3x6phcJ20/9CuMr5h8WPqXMSasLoLHoufTmE7mzYrs6B0dY7KjuCogKqsvxnxAwXWvd9Puc9PnE8DOHT2INHxRlIyVHrqZahtfV2E/A2PDdtA3ewlRHMtFIBKO/T4IozWTQZ+mb+gdKuk/ZHrqloucKdsOSJmlWTSntWjcxVMjUmroXLM10I6TwDLnBq4LP69TxgVeyGsd8yHvhF8ydPlrNRSNs9EP7WmeuSE7Lu10JbOuQcJw/63sDp68wB9iwP5AO+mBpV0R5VDDeyQUFCel1G+4KHBgEVFS0YK+m2sXLWLuGTlkVAd97WwKKdacjWElRCuDRauf33l/yVcDF6sVPKeTes99FC1NpNWcpieGSV/IbO8PCTy5pbUR1U8lxzf4T+y6fZMxOz3LshkQLeeDSd0WmUrQgajmbktrxsb2AZ0ACw2Vgni+gV/m+KvCRWLg08Clx7uhql+v9XySGcjjOHlsp8vBw/e8HS7dtiqF6T/XcSXuaMW66GF1g4q9YyBadHqy3Y5jin1c7yZos6BBr6dsomSHxiUHanYtcYQwnMMZhRhOnaYJeyJzaRuukyCUh48+e/BUvk/aEfDp8ag+jD64BHxNnQ5v/E7WRk7eLjGV13I3oqy45YNONi/1op1oDr7rPjkhPsTXgUpQtGDPlIs55KhQaic9kSGs/UrZ2QKQOflB8MTEQxRF9pullToWO7Eplan6mcMRFnUu2441yxi23x+KqKlr7RWWsi9ZXMWlr8vfP3llk1m2PRj0yudccxBuoa7VfIgRmnFPGX6Pm1WIfMm/Rm4n/xTn8IGqA0GWuqgu48pEUO0U9nN+ZdIvFpPb7VDPphIfRZxznlHeVFebkd9l+raXy9BpTMcIUIvBfgHEb6ndGo8VUkxpief14KjzFOcaANfgvFpvyY8lE8lE4raHizLpluPzMks1hx/e1Hok5yV0p7qQH7GaYeMzzZTFvRpv6k6iaJ4yNqzBvN8J7B430h2wFm1IBPcqbou33G7/NWPgopl4Mllla6e24L3TOTVNkza2zv3QKuDWTeDpClCEYgTQ+5vEBSQZs/rMF50+sm4jofTgWLqgX1x3TkrDEVaRqfY/xZizFZ3Y8/DFEFD31VSfBQ5raEB6nHnZh6ddehtclQJ8fBrldyIh99LNnV32HzKEej04hk6SYjdauCa4aYW0ru/QxvQRGzLKOAQszf3ixJypTW3WWL6BLSF2EMCMIw7OUvWBC6A/gDc2D1jvBapMCc7ztx6jYczwTKsRLL6dMNXb83HS8kdD0pTMMj161zbVHkU0mhSHo9SlBDDXdN6hDvRGizmohtIyR3ot8tF5iUG4GLNcXeGvBudSFrHu+bVZb9jirNVG+rQPI51A7Hu8/b0UeaIaZ4UgDO68PkYx3PE2HWpKapJ764Kxt5TFYpywMy4DLQqVRy11I7SOLhxUFmqiEK52NaijWArIfCg6qG8q5eSiwRCJb1R7GDJG74TrYgx/lVq7w9++Kh929xSJEaoSse5fUOQg9nMAnIZv+7fwVRcNv3gOHI46Vb5jYUC66PYHO6lS+TOmvEQjuYmx4RkffYGxqZIp/DPWNHAixbRBc+XKE3JEOgs4jIwu/dSAwhydruOGF39co91aTs85JJ3Z/LpXoF43hUwJsb/M1Chzdn8HX8vLXnqWUKvRhNLpfAF4PTFqva1sBQG0J+59HyYfmQ3oa4/sxZdapVLlo/fooxSXi/dOEQWIWq8E0FkttEyTFXR2aNMPINMIzZwCNEheYTVltsdaLkMyKoEUluPNAYCM2IG3br0DLy0fVNWKHtbSKbBjfiw7Lu06gQFalC7RC9BwRMSpLYDUo9pDtDfzwUiPJKLJ2LGcSphWBadOI/iJjNqUHV7ucG8yC6+iNM9QYElqBR7ECFXrcTgWQ3eG/tCWacT9bxIkfmxPmi3vOd36KxihAJA73vWNJ+Y9oapXNscVSVqS5g15xOWND/WuUCcA9YAAg6WFbjHamrblZ5c0L6Zx1X58ZittGcfDKU697QRSqW/g+RofNRyvrWMrBn44cPvkRe2HdTu/Cq01C5/riWPHZyXPKHuSDDdW8c1XPgd6ogvLh20qEIu8c19sqr4ufyHrwh37ZN5MkvY1dsGmEz9pUBTxWrvvhNyODyX2Q1k/fbX/T/vbHNcBrmjgDtvBdtZrVtiIg5iXQuzO/DEMvRX8Mi1zymSlt92BGILeKItjoShJXE/H7xwnf0Iewb8BFieJ9MflEBCQYEDm8eZniiEPfGoaYiiEdhQxHQNr2AuRdmbL9mcl18Kumh+HEZLp6z+j35ML9zTbUwahUZCyQQOgQrGfdfQtaR/OYJ/9dYXb2TWZFMijfCA8Nov4sa5FFDUe1T68h4q08WDE7JbbDiej4utRMR9ontevxlXv6LuJTXt1YEv8bDzEt683PuSsIN0afvu0rcBu9AbXZbkOG3K3AhtqQ28N23lXm7S3Yn6KXmAhBhz+GeorJJ4XxO/b3vZk2LXp42+QvsVxGSNVpfSctIFMTR1bD9t70i6sfNF3WKz/uKDEDCpzzztwhL45lsw89H2IpWN10sXHRlhDse9KCdpP5qNNpU84cTY+aiqswqR8XZ9ea0KbVRwRuOGQU3csAtV2fSbnq47U6es6rKlWLWhg3s/B9C9g+oTyp6RtIldR51OOkP5/6nSy6itUVPcMNOp4M/hDdKOz3uK6srbdxOrc2cJgr1Sg02oBxxSky6V7JaG+ziNwlfqnjnvh2/uq1lKfbp+qpwq/D/5OI5gkFl5CejKGxfc2YVJfGqc4E0x5e9PHK2ukbHNI7/RZV6LNe65apbTGjoCaQls0txPPbmQbCQn+/upCoXRZy9yzorWJvZ0KWcbXlBxU/d5I4ERUTxMuVWhSMmF677LNN7NnLwsmKawXkCgbrpcluOl0WChR1qhtSrxGXHu251dEItYhYX3snvn1gS2uXuzdTxCJjZtjsip0iT2sDC0qMS7Bk9su2NyXjFK5/f5ZoWwofg3DtTyjaFqspnOOTSh8xK/CKUFS57guVEkw9xoQuRCwwEO9Lu9z2vYxSa9NFV8DvSxv2C4WYLYF8Nrc4DzWkzNsk81JJOlZ/LYJrGCoj4MmZpnf3AXmzxT4rtl9jsqljEyedz468SGKdBiQzyz/qWKEhFg45ZczlZZ3KGL3l6sn+3TTa3zMVMhPa1obGp/z+fvY0QXTrJTf1XAT3EtQdUfYYlmWZyvPZ/6rWwU7UOQei7pVE0osgN94Iy+T1+omE6z4Rh2O20FjgBeK2y1mcoFiMDOJvuZPn5Moy9fmFH3wyfKvn4+TwfLvt/lHTTVnvrtoUWRBiQXhiNM8nE6ZoWeux/Z0b2unRcdUzdDpmL7CAgd1ToRXwgmHTZOgiGtVT+xr1QH9ObebRTT4NzL+XSpLuuWp62GqQvJVTPoZOeJCb6gIwd9XHMftQ+Kc08IKKdKQANSJ1a2gve3JdRhO0+tNiYzWAZfd7isoeBu67W7xuK8WX7nhJURld98Inb0t/dWOSau/kDvV4DJo/cImw9AO2Gvq0F2n0M7yIZKL8amMbjYld+qFls7hq8Acvq97K2PrCaomuUiesu7qNanGupEl6J/iem8lyr/NMnsTr6o41PO0yhQh3hPFN0wJP7S830je9iTBLzUNgYH+gUZpROo3rN2qgCI+6GewpX8w8CH+ro6QrWiStqmcMzVa3vEel+3/dDxMp0rDv1Q6wTMS3K64zTT6RWzK1y643im25Ja7X2ePCV2mTswd/4jshZPo4bLnerqIosq/hy2bKUAmVn9n4oun1+a0DIZ56UhVwmZHdUNpLa8gmPvxS1eNvCF1T0wo1wKPdCJi0qOrWz7oYRTzgTtkzEzZn308XSLwUog4OWGKJzCn/3FfF9iA32dZHSv30pRCM3KBY9WZoRhtdK/ChHk6DEQBsfV6tN2o1Cn0mLtPBfnkS+qy1L2xfFe9TQPtDE1Be44RTl82E9hPT2rS2+93LFbzhQQO3C/hD2jRFH3BWWbasAfuMhRJFcTri73eE835y016s22DjoFJ862WvLj69fu2TgSF3RHia9D5DSitlQAXYCnbdqjPkR287Lh6dCHDapos+eFDvcZPP2edPmTFxznJE/EBLoQQ0Qmn9EkZOyJmHxMbvKYb8o21ZHmv5YLqgsEPk9gWZwYQY9wLqGXuax/8QlV5qDaPbq9pLPT1yp+zOWKmraEy1OUJI7zdEcEmvBpbdwLrDCgEb2xX8S/nxZgjK4bRi+pbOmbh8bEeoPvU/L9ndx9kntlDALbdAvp0O8ZC3zSUnFg4cePsw7jxewWvL7HRSBLUn6J7vTH9uld5N76JFPgBCdXGF221oEJk++XfRwXplLSyrVO7HFWBEs99nTazKveW3HpbD4dH/YmdAl+lwbSt8BQWyTG7jAsACI7bPPUU9hI9XUHWqQOuezHzUjnx5Qqs6T1qNHfTTHleDtmqK7flA9a0gz2nycIpz1FHBuWxKNtUeTdqP29Fb3tv+tl5JyBqXoR+vCsdzZwZUhf6Lu8bvkB9yQP4x7GGegB0ym0Lpl03Q7e+C0cDsm9GSDepCDji7nUslLyYyluPfvLyKaDSX4xpR+nVYQjQQn5F8KbY1gbIVLiK1J3mW90zTyR1bqApX2BlWh7KG8LAY9/S9nWC0XXh9pZZo6xuir12T43rkaGfQssbQyIslA7uJnSHOV22NhlNtUo0czxPAsXhh8tIQYaTM4l/yAlZlydTcXhlG22Gs/n3BxKBd/3ZjYwg3NaUurVXhNB+afVnFfNr9TbC9ksNdvwpNfeHanyJ8M6GrIVfLlYAPv0ILe4dn0Z+BJSbJkN7eZY/c6+6ttDYcIDeUKIDXqUSE42Xdh5nRbuaObozjht0HJ5H1e+em+NJi/+8kQlyjCbJpPckwThZeIF9/u7lrVIKNeJLCN/TpPAeXxvd31/CUDWHK9MuP1V1TJgngzi4V0qzS3SW3Qy5UiGHqg02wQa5tsEl9s/X9nNMosgLlUgZSfCBj1DiypLfhr9/r0nR0XY2tmhDOcUS4E7cqa4EJBhzqvpbZa35Q5Iz5EqmhYiOGDAYk606Tv74+KGfPjKVuP15rIzgW0I7/niOu9el/sn2bRye0gV+GrePDRDMHjwO1lEdeXH8N+UTO3IoN18kpI3tPxz+fY+n2MGMSGFHAx/83tKeJOl+2i+f1O9v6FfEDBbqrw+lpM8Anav7zHNr7hE78nXUtPNodMbCnITWA7Ma/IHlZ50F9hWge/wzOvSbtqFVFtkS8Of2nssjZwbSFdU+VO8z6tCEc9UA9ACxT5zIUeSrkBB/v1krOpm7bVMrGxEKfI6LcnpB4D8bvn2hDKGqKrJaVAJuDaBEY3F7eXyqnFWlOoFV/8ZLspZiZd7orXLhd4mhHQgbuKbHjJWUzrnm0Dxw/LJLzXCkh7slMxKo8uxZIWZfdKHlfI7uj3LP6ARAuWdF7ZmZ7daOKqKGbz5LxOggTgS39oEioYmrqkCeUDvbxkBYKeHhcLmMN8dMF01ZMb32IpL/cH8R7VHQSI5I0YfL14g9d7P/6cjB1JXXxbozEDbsrPdmL8ph7QW10jio+v7YsqHKQ6xrBbOVtxU0/nFfzUGZwIBLwyUvg49ii+54nv9FyECBpURnQK4Ox6N7lw5fsjdd5l/2SwBcAHMJoyjO1Pifye2dagaOwCVMqdJWAo77pvBe0zdJcTWu5fdzPNfV2p1pc7/JKQ8zhKkwsOELUDhXygPJ5oR8Vpk2lsCen3D3QOQp2zdrSZHjVBstDF/wWO98rrkQ6/7zt/Drip7OHIug1lomNdmRaHRrjmqeodn22sesQQPgzimPOMqC60a5+i/UYh51uZm+ijWkkaI2xjrBO2558DZNZMiuDQlaVAvBy2wLn/bR3FrNzfnO/9oDztYqxZrr7JMIhqmrochbqmQnKowxW29bpqTaJu7kW1VotC72QkYX8OoDDdMDwV1kJRk3mufgJBzf+iwFRJ7XWQwO5ujVglgFgHtycWiMLx5N+6XU+TulLabWjOzoao03fniUW0xvIJNPbk7CQlFZd/RCOPvgQbLjh5ITE8NVJeKt3HGr6JTnFdIzcVOlEtwqbIIX0IM7saC+4N5047MTJ9+Wn11EhyEPIlwsHE5utCeXRjQzlrR+R1Cf/qDzcNbqLXdk3J7gQ39VUrrEkS/VMWjjg+t2oYrqB0tUZClcUF6+LBC3EQ7KnGIwm/qjZX4GKPtjTX1zQKV6nPAb2t/Rza5IqKRf8i2DFEhV/YSifX0YwsiF6TQnp48Gr65TFq0zUe6LGjiY7fq0LSGKL1VnC6ESI2yxvt3XqBx53B3gSlGFeJcPbUbonW1E9E9m4NfuwPh+t5QjRxX34lvBPVxwQd7aeTd+r9dw5CiP1pt8wMZoMdni7GapYdo6KPgeQKcmlFfq4UYhvV0IBgeiR3RnTMBaqDqpZrTRyLdsp4l0IXZTdErfH0sN3dqBG5vRIx3VgCYcHmmkqJ8Hyu3s9K9uBD1d8cZUEx3qYcF5vsqeRpF1GOg8emeWM2OmBlWPdZ6qAXwm3nENFyh+kvXk132PfWAlN0kb7yh4fz2T7VWUY/hEXX5DvxGABC03XRpyOG8t/u3Gh5tZdpsSV9AWaxJN7zwhVglgII1gV28tUViyqn4UMdIh5t+Ea2zo7PO48oba0TwQbiSZOH4YhD578kPF3reuaP7LujPMsjHmaDuId9XEaZBCJhbXJbRg5VCk3KJpryH/+8S3wdhR47pdFcmpZG2p0Bpjp/VbvalgIZMllYX5L31aMPdt1J7r/7wbixt0Mnz2ZvNGTARHPVD+2O1D8SGpWXlVnP2ekgon55YiinADDynyaXtZDXueVqbuTi8z8cHHK325pgqM+mWZwzHeEreMvhZopAScXM14SJHpGwZyRljMlDvcMm9FZ/1e9+r/puOnpXOtc9Iu2fmgBfEP9cGW1Fzb1rGlfJ08pACtq1ZW18bf2cevebzVeHbaA50G9qoUp39JWdPHbYkPCRXjt4gzlq3Cxge28Mky8MoS/+On72kc+ZI2xBtgJytpAQHQ1zrEddMIVyR5urX6yBNu8v5lKC8eLdGKTJtbgIZ3ZyTzSfWmx9f+cvcJe8yM39K/djkp2aUTE/9m2Lj5jg7b8vdRAer7DO3SyLNHs1CAm5x5iAdh2yGJYivArZbCBNY88Tw+w+C1Tbt7wK3zl2rzTHo/D8/gb3c3mYrnEIEipYqPUcdWjnTsSw471O3EUN7Gtg4NOAs9PJrxm03VuZKa5xwXAYCjt7Gs01Km6T2DhOYUMoFcCSu7Hk1p3yP1eG+M3v3Q5luAze6WwBnZIYO0TCucPWK+UJ36KoJ8Y+vpavhLO8g5ed704IjlQdfemrMu//EvPYXTQSGIPPfiagJS9nMqP5IvkxN9pvuJz7h8carPXTKMq8jnTeL0STan6dnLTAqwIswcIwWDR2KwbGddAVN8SYWRB7kfBfBRkSXzvHlIF8D6jo64kUzYk5o/n8oLjKqat0rdXvQ86MkwQGMnnlcasqPPT2+mVtUGb32KuH6cyZQenrRG11TArcAl27+nvOMBDe++EKHf4YdyGf7mznzOz33cFFGEcv329p4qG2hoaQ8ULiMyVz6ENcxhoqGnFIdupcn7GICQWuw3yO3W8S33mzCcMYJ8ywc7U7rmaQf/W5K63Gr4bVTpXOyOp4tbaPyIaatBNpXqlmQUTSZXjxPr19+73PSaT+QnI35YsWn6WpfJjRtK8vlJZoTSgjaRU39AGCkWOZtifJrnefCrqwTKDFmuWUCukEsYcRrMzCoit28wYpP7kSVjMD8WJYQiNc2blMjuqYegmf6SsfC1jqz8XzghMlOX+gn/MKZmgljszrmehEa4V98VreJDxYvHr3j7IeJB9/sBZV41BWT/AZAjuC5XorlIPnZgBAniBEhanp0/0+qZmEWDpu8ige1hUPIyTo6T6gDEcFhWSoduNh8YSu65KgMOGBw7VlNYzNIgwHtq9KP2yyTVysqX5v12sf7D+vQUdR2dRDvCV40rIInXSLWT/yrC6ExOQxBJwIDbeZcl3z1yR5Rj3l8IGpxspapnvBL+fwupA3b6fkFceID9wgiM1ILB0cHVdvo/R4xg8yqKXT8efl0GnGX1/27FUYeUW2L/GNRGGWVGp3i91oaJkb4rybENHre9a2P5viz/yqk8ngWUUS+Kv+fu+9BLFnfLiLXOFcIeBJLhnayCiuDRSqcx0Qu68gVsGYc6EHD500Fkt+gpDj6gvr884n8wZ5o6q7xtL5wA0beXQnffWYkZrs2NGIRgQbsc5NB302SVx+R4ROvmgZaR8wBcji128BMfJ9kcvJ4DC+bQ57kRmv5yxgU4ngZfn0/JNZ8JBwxjTqS+s9kjJFG1unGUGLwMiIuXUD9EFhNIJuyCEAmVZSIGKH4G6v1gRR1LyzQKH2ZqiI1DnHMoDEZspbDjTeaFIAbSvjSq3A+n46y9hhVM8wIpnARSXyzmOD96d9UXvFroSPgGw1dq2vdEqDq9fJN1EbL2WulNmHkFDvxSO9ZT/RX/Bw2gA/BrF90XrJACereVfbV/YXaKfp77Nmx5NjEIUlxojsy7iN7nBHSZigfsbFyVOX1ZTeCCxvqnRSExP4lk5ZeYlRu9caaa743TWNdchRIhEWwadsBIe245C8clpaZ4zrPsk+OwXzxWCvRRumyNSLW5KWaSJyJU95cwheK76gr7228spZ3hmTtLyrfM2QRFqZFMR8/Q6yWfVgwTdfX2Ry4w3+eAO/5VT5nFb5NlzXPvBEAWrNZ6Q3jbH0RF4vcbp+fDngf/ywpoyNQtjrfvcq93AVb1RDWRghvyqgI2BkMr1rwYi8gizZ0G9GmPpMeqPerAQ0dJbzx+KAFM4IBq6iSLpZHUroeyfd9o5o+4fR2EtsZBoJORQEA4SW0CmeXSnblx2e9QkCHIodyqV6+g5ETEpZsLqnd/Na60EKPX/tQpPEcO+COIBPcQdszDzSiHGyQFPly/7KciUh1u+mFfxTCHGv9nn2WqndGgeGjQ/kr02qmTBX7Hc1qiEvgiSz1Tz/sy7Es29wvn6FrDGPP7asXlhOaiHxOctPvTptFA1kHFUk8bME7SsTSnGbFbUrssxrq70LhoSh5OwvQna+w84XdXhZb2sloJ4ZsCg3j+PrjJL08/JBi5zGd6ud/ZxhmcGKLOXPcNunQq5ESW92iJvfsuRrNYtawWwSmNhPYoFj2QqWNF0ffLpGt/ad24RJ8vkb5sXkpyKXmvFG5Vcdzf/44k3PBL/ojJ52+kWGzOArnyp5f969oV3J2c4Li27Nkova9VwRNVKqN0V+gV+mTHitgkXV30aWd3A1RSildEleiNPA+5cp+3+T7X+xfHiRZXQ1s4FA9TxIcnveQs9JSZ5r5qNmgqlW4zMtZ6rYNvgmyVcywKtu8ZxnSbS5vXlBV+NXdIfi3+xzrnJ0TkFL+Un8v1PWOC2PPFCjVPq7qTH7mOpzOYj/b4h0ceT+eHgr97Jqhb1ziVfeANzfN8bFUhPKBi7hJBCukQnB0aGjFTYLJPXL26lQ2b80xrOD5cFWgA8hz3St0e69kwNnD3+nX3gy12FjrjO+ddRvvvfyV3SWbXcxqNHfmsb9u1TV+wHTb9B07/L2sB8WUHJ9eeNomDyysEWZ0deqEhH/oWI2oiEh526gvAK1Nx2kIhNvkYR+tPYHEa9j+nd1VBpQP1uzSjIDO+fDDB7uy029rRjDC5Sk6aKczyz1D5uA9Lu+Rrrapl8JXNL3VRllNQH2K1ZFxOpX8LprttfqQ56MbPM0IttUheXWD/mROOeFqGUbL+kUOVlXLTFX/525g4faLEFO4qWWdmOXMNvVjpIVTWt650HfQjX9oT3Dg5Au6+v1/Ci78La6ZOngYCFPT1AUwxQuZ0yt5xKdNXLaDTISMTeCj16XTryhM36K2mfGRIgot71voWs8tTpL/f1rvcwv3LSDf+/G8THCT7NpfHWcW+lsF/ol8q9Bi6MezNTqp0rpp/kJRiVfNrX/w27cRRTu8RIIqtUblBMkxy4jwAVqCjUJkiPBj2cAoVloG8B2/N5deLdMhDb7xs5nhd3dubJhuj8WbaFRyu1L678DHhhA+rMimNo4C1kGpp0tD/qnCfCFHejpf0LJX43OTr578PY0tnIIrlWyNYyuR/ie6j2xNb1OV6u0dOX/1Dtcd7+ya9W+rY2LmnyQMtk8SMLTon8RAdwOaN2tNg5zVnDKlmVeOxPV2vhHIo9QEPV7jc3f+zVDquiNg1OaHX3cZXJDRY5MJpo+VanAcmqp4oasYLG+wrXUL5vJU0kqk2hGEskhP+Jjigrz1l6QnEwp6n8PMVeJp70Ii6ppeaK9GhF6fJE00ceLyxv08tKiPat4QdxZFgSbQknnEiCLD8Qc1rjazVKM3r3gXnnMeONgdz/yFV1q+haaN+wnF3Fn4uYCI9XsKOuVwDD0LsCO/f0gj5cmxCFcr7sclIcefWjvore+3aSU474cyqDVxH7w1RX3CHsaqsMRX17ZLgjsDXws3kLm2XJdM3Ku383UXqaHqsywzPhx7NFir0Fqjym/w6cxD2U9ypa3dx7Z12w/fi3Jps8sqJ8f8Ah8aZAvkHXvIRyrsxK7rrFaNNdNvjI8+3Emri195DCNa858anj2Qdny6Czshkn4N2+1m+k5S8sunX3Ja7I+JutRzg1mc2e9Yc0Zv9PZn1SwhxIdU9sXwZRTd/J5FoUm0e+PYREeHg3oc2YYzGf2xfJxXExt4pT3RfDRHvMXLUmoXOy63xv5pLuhOEax0dRgSywZ/GH+YBXFgCeTU0hZ8SPEFsn8punp1Kurd1KgXxUZ+la3R5+4ePGR4ZF5UQtOa83+Vj8zh80dfzbhxWCeoJnQ4dkZJM4drzknZOOKx2n3WrvJnzFIS8p0xeic+M3ZRVXIp10tV2DyYKwRxLzulPwzHcLlYTxl4PF7v8l106Azr+6wBFejbq/3P72C/0j78cepY9990/d4eAurn2lqdGKLU8FffnMw7cY7pVeXJRMU73Oxwi2g2vh/+4gX8dvbjfojn/eLVhhYl8GthwCQ50KcZq4z2JeW5eeOnJWFQEnVxDoG459TaC4zXybECEoJ0V5q1tXrQbDMtUxeTV6Pdt1/zJuc7TJoV/9YZFWxUtCf6Ou3Vd/vR/vG0138hJQrHkNeoep5dLe+6umcSquKvMaFpm3EZHDBOvCi0XYyIFHMgX7Cqp3JVXlxJFwQfHSaIUEbI2u1lBVUdlNw4Qa9UsLPEK94Qiln3pyKxQVCeNlx8yd7EegVNQBkFLabKvnietYVB4IPZ1fSor82arbgYec8aSdFMaIluYTYuNx32SxfrjKUdPGq+UNp5YpydoEG3xVLixtmHO9zXxKAnHnPuH2fPGrjx0GcuCDEU+yXUtXh6nfUL+cykws1gJ5vkfYFaFBr9PdCXvVf35OJQxzUMmWjv0W6uGJK11uAGDqSpOwCf6rouSIjPVgw57cJCOQ4b9tkI/Y5WNon9Swe72aZryKo8d+HyHBEdWJKrkary0LIGczA4Irq353Wc0Zga3om7UQiAGCvIl8GGyaqz5zH+1gMP5phWUCpKtttWIyicz09vXg76GxkmiGSMQ06Z9X8BUwqOtauDbPIf4rpK/yYoeAHxJ9soXS9VDe1Aw+awOOxaN8foLrif0TXBvQ55dtRtulRq9emFDBxlQcqKCaD8NeTSE7FOHvcjf/+oKbbtRqz9gbofoc2EzQ3pL6W5JdfJzAWmOk8oeoECe90lVMruwl/ltM015P/zIPazqvdvFmLNVHMIZrwiQ2tIKtGh6PDVH+85ew3caqVt2BsDv5rOcu3G9srQWd7NmgtzCRUXLYknYRSwtH9oUtkqyN3CfP20xQ1faXQl4MEmjQehWR6GmGnkdpYNQYeIG408yAX7uCZmYUic9juOfb+Re28+OVOB+scYK4DaPcBe+5wmji9gymtkMpKo4UKqCz7yxzuN8VIlx9yNozpRJpNaWHtaZVEqP45n2JemTlYBSmNIK1FuSYAUQ1yBLnKxevrjayd+h2i8PjdB3YY6b0nr3JuOXGpPMyh4V2dslpR3DFEvgpsBLqhqLDOWP4yEvIL6f21PpA7/8B"));
var $747425b437e121da$var$log2 = Math.log2 || ((n) => Math.log(n) / Math.LN2);
var $747425b437e121da$var$bits = (n) => $747425b437e121da$var$log2(n) + 1 | 0;
var $747425b437e121da$var$CATEGORY_BITS = $747425b437e121da$var$bits((0, $parcel$interopDefault($f4087201da764553$exports)).categories.length - 1);
var $747425b437e121da$var$COMBINING_BITS = $747425b437e121da$var$bits((0, $parcel$interopDefault($f4087201da764553$exports)).combiningClasses.length - 1);
var $747425b437e121da$var$SCRIPT_BITS = $747425b437e121da$var$bits((0, $parcel$interopDefault($f4087201da764553$exports)).scripts.length - 1);
var $747425b437e121da$var$EAW_BITS = $747425b437e121da$var$bits((0, $parcel$interopDefault($f4087201da764553$exports)).eaw.length - 1);
var $747425b437e121da$var$NUMBER_BITS = 10;
var $747425b437e121da$var$CATEGORY_SHIFT = $747425b437e121da$var$COMBINING_BITS + $747425b437e121da$var$SCRIPT_BITS + $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$COMBINING_SHIFT = $747425b437e121da$var$SCRIPT_BITS + $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$SCRIPT_SHIFT = $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$EAW_SHIFT = $747425b437e121da$var$NUMBER_BITS;
var $747425b437e121da$var$CATEGORY_MASK = (1 << $747425b437e121da$var$CATEGORY_BITS) - 1;
var $747425b437e121da$var$COMBINING_MASK = (1 << $747425b437e121da$var$COMBINING_BITS) - 1;
var $747425b437e121da$var$SCRIPT_MASK = (1 << $747425b437e121da$var$SCRIPT_BITS) - 1;
var $747425b437e121da$var$EAW_MASK = (1 << $747425b437e121da$var$EAW_BITS) - 1;
var $747425b437e121da$var$NUMBER_MASK = (1 << $747425b437e121da$var$NUMBER_BITS) - 1;
function $747425b437e121da$export$410364bbb673ddbc(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, $parcel$interopDefault($f4087201da764553$exports)).categories[val >> $747425b437e121da$var$CATEGORY_SHIFT & $747425b437e121da$var$CATEGORY_MASK];
}
function $747425b437e121da$export$c03b919c6651ed55(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, $parcel$interopDefault($f4087201da764553$exports)).combiningClasses[val >> $747425b437e121da$var$COMBINING_SHIFT & $747425b437e121da$var$COMBINING_MASK];
}
function $747425b437e121da$export$941569448d136665(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, $parcel$interopDefault($f4087201da764553$exports)).scripts[val >> $747425b437e121da$var$SCRIPT_SHIFT & $747425b437e121da$var$SCRIPT_MASK];
}
function $747425b437e121da$export$92f6187db8ca6d26(codePoint) {
  const val = $747425b437e121da$var$trie.get(codePoint);
  return (0, $parcel$interopDefault($f4087201da764553$exports)).eaw[val >> $747425b437e121da$var$EAW_SHIFT & $747425b437e121da$var$EAW_MASK];
}
function $747425b437e121da$export$7d1258ebb7625a0d(codePoint) {
  let val = $747425b437e121da$var$trie.get(codePoint);
  let num = val & $747425b437e121da$var$NUMBER_MASK;
  if (num === 0)
    return null;
  else if (num <= 50)
    return num - 1;
  else if (num < 480) {
    const numerator = (num >> 4) - 12;
    const denominator = (num & 15) + 1;
    return numerator / denominator;
  } else if (num < 768) {
    val = (num >> 5) - 14;
    let exp = (num & 31) + 2;
    while (exp > 0) {
      val *= 10;
      exp--;
    }
    return val;
  } else {
    val = (num >> 2) - 191;
    let exp = (num & 3) + 1;
    while (exp > 0) {
      val *= 60;
      exp--;
    }
    return val;
  }
}
function $747425b437e121da$export$52c8ea63abd07594(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Nl";
}
function $747425b437e121da$export$727d9dbc4fbb948f(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Nd";
}
function $747425b437e121da$export$a5b49f4dc6a07d2c(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Pc" || category === "Pd" || category === "Pe" || category === "Pf" || category === "Pi" || category === "Po" || category === "Ps";
}
function $747425b437e121da$export$7b6804e8df61fcf5(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Ll";
}
function $747425b437e121da$export$aebd617640818cda(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Lu";
}
function $747425b437e121da$export$de8b4ee23b2cf823(codePoint) {
  return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Lt";
}
function $747425b437e121da$export$3c52dd84024ae72c(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Zs" || category === "Zl" || category === "Zp";
}
function $747425b437e121da$export$a11bdcffe109e74b(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Nd" || category === "No" || category === "Nl" || category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Me" || category === "Mc";
}
function $747425b437e121da$export$e33ad6871e762338(codePoint) {
  const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
  return category === "Mn" || category === "Me" || category === "Mc";
}
var $747425b437e121da$export$2e2bcd8739ae039 = {
  getCategory: $747425b437e121da$export$410364bbb673ddbc,
  getCombiningClass: $747425b437e121da$export$c03b919c6651ed55,
  getScript: $747425b437e121da$export$941569448d136665,
  getEastAsianWidth: $747425b437e121da$export$92f6187db8ca6d26,
  getNumericValue: $747425b437e121da$export$7d1258ebb7625a0d,
  isAlphabetic: $747425b437e121da$export$52c8ea63abd07594,
  isDigit: $747425b437e121da$export$727d9dbc4fbb948f,
  isPunctuation: $747425b437e121da$export$a5b49f4dc6a07d2c,
  isLowerCase: $747425b437e121da$export$7b6804e8df61fcf5,
  isUpperCase: $747425b437e121da$export$aebd617640818cda,
  isTitleCase: $747425b437e121da$export$de8b4ee23b2cf823,
  isWhiteSpace: $747425b437e121da$export$3c52dd84024ae72c,
  isBaseForm: $747425b437e121da$export$a11bdcffe109e74b,
  isMark: $747425b437e121da$export$e33ad6871e762338
};

// ../node_modules/fontkit/dist/browser-module.mjs
var import_unicode_trie2 = __toESM(require_unicode_trie(), 1);
var import_dfa = __toESM(require_dfa(), 1);
var import_clone = __toESM(require_clone(), 1);
var import_tiny_inflate = __toESM(require_tiny_inflate(), 1);
var import_decompress = __toESM(require_decompress(), 1);
function $parcel$export(e, n, v2, s2) {
  Object.defineProperty(e, n, { get: v2, set: s2, enumerable: true, configurable: true });
}
function $parcel$interopDefault2(a2) {
  return a2 && a2.__esModule ? a2.default : a2;
}
var $d636bc798e7178db$exports = {};
$parcel$export($d636bc798e7178db$exports, "logErrors", () => $d636bc798e7178db$export$bd5c5d8b8dcafd78);
$parcel$export($d636bc798e7178db$exports, "registerFormat", () => $d636bc798e7178db$export$36b2f24e97d43be);
$parcel$export($d636bc798e7178db$exports, "create", () => $d636bc798e7178db$export$185802fd694ee1f5);
$parcel$export($d636bc798e7178db$exports, "defaultLanguage", () => $d636bc798e7178db$export$42940898df819940);
$parcel$export($d636bc798e7178db$exports, "setDefaultLanguage", () => $d636bc798e7178db$export$5157e7780d44cc36);
var $d636bc798e7178db$export$bd5c5d8b8dcafd78 = false;
var $d636bc798e7178db$var$formats = [];
function $d636bc798e7178db$export$36b2f24e97d43be(format) {
  $d636bc798e7178db$var$formats.push(format);
}
function $d636bc798e7178db$export$185802fd694ee1f5(buffer3, postscriptName) {
  for (let i = 0; i < $d636bc798e7178db$var$formats.length; i++) {
    let format = $d636bc798e7178db$var$formats[i];
    if (format.probe(buffer3)) {
      let font2 = new format(new (0, DecodeStream)(buffer3));
      if (postscriptName)
        return font2.getFont(postscriptName);
      return font2;
    }
  }
  throw new Error("Unknown font format");
}
var $d636bc798e7178db$export$42940898df819940 = "en";
function $d636bc798e7178db$export$5157e7780d44cc36(lang = "en") {
  $d636bc798e7178db$export$42940898df819940 = lang;
}
function $e71565f2ce09cb6b$export$69a3209f1a06c04d(target, key1, descriptor) {
  if (descriptor.get) {
    let get18 = descriptor.get;
    descriptor.get = function() {
      let value2 = get18.call(this);
      Object.defineProperty(this, key1, {
        value: value2
      });
      return value2;
    };
  } else if (typeof descriptor.value === "function") {
    let fn = descriptor.value;
    return {
      get() {
        let cache1 = /* @__PURE__ */ new Map();
        function memoized(...args) {
          let key = args.length > 0 ? args[0] : "value";
          if (cache1.has(key))
            return cache1.get(key);
          let result = fn.apply(this, args);
          cache1.set(key, result);
          return result;
        }
        Object.defineProperty(this, key1, {
          value: memoized
        });
        return memoized;
      }
    };
  }
}
var $26a62205ad06574e$var$SubHeader = new Struct({
  firstCode: uint16,
  entryCount: uint16,
  idDelta: int16,
  idRangeOffset: uint16
});
var $26a62205ad06574e$var$CmapGroup = new Struct({
  startCharCode: uint32,
  endCharCode: uint32,
  glyphID: uint32
});
var $26a62205ad06574e$var$UnicodeValueRange = new Struct({
  startUnicodeValue: uint24,
  additionalCount: uint8
});
var $26a62205ad06574e$var$UVSMapping = new Struct({
  unicodeValue: uint24,
  glyphID: uint16
});
var $26a62205ad06574e$var$DefaultUVS = new ArrayT($26a62205ad06574e$var$UnicodeValueRange, uint32);
var $26a62205ad06574e$var$NonDefaultUVS = new ArrayT($26a62205ad06574e$var$UVSMapping, uint32);
var $26a62205ad06574e$var$VarSelectorRecord = new Struct({
  varSelector: uint24,
  defaultUVS: new Pointer(uint32, $26a62205ad06574e$var$DefaultUVS, {
    type: "parent"
  }),
  nonDefaultUVS: new Pointer(uint32, $26a62205ad06574e$var$NonDefaultUVS, {
    type: "parent"
  })
});
var $26a62205ad06574e$var$CmapSubtable = new VersionedStruct(uint16, {
  0: {
    length: uint16,
    language: uint16,
    codeMap: new LazyArray(uint8, 256)
  },
  2: {
    length: uint16,
    language: uint16,
    subHeaderKeys: new ArrayT(uint16, 256),
    subHeaderCount: (t2) => Math.max.apply(Math, t2.subHeaderKeys),
    subHeaders: new LazyArray($26a62205ad06574e$var$SubHeader, "subHeaderCount"),
    glyphIndexArray: new LazyArray(uint16, "subHeaderCount")
  },
  4: {
    length: uint16,
    language: uint16,
    segCountX2: uint16,
    segCount: (t2) => t2.segCountX2 >> 1,
    searchRange: uint16,
    entrySelector: uint16,
    rangeShift: uint16,
    endCode: new LazyArray(uint16, "segCount"),
    reservedPad: new Reserved(uint16),
    startCode: new LazyArray(uint16, "segCount"),
    idDelta: new LazyArray(int16, "segCount"),
    idRangeOffset: new LazyArray(uint16, "segCount"),
    glyphIndexArray: new LazyArray(uint16, (t2) => (t2.length - t2._currentOffset) / 2)
  },
  6: {
    length: uint16,
    language: uint16,
    firstCode: uint16,
    entryCount: uint16,
    glyphIndices: new LazyArray(uint16, "entryCount")
  },
  8: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint16,
    is32: new LazyArray(uint8, 8192),
    nGroups: uint32,
    groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
  },
  10: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint32,
    firstCode: uint32,
    entryCount: uint32,
    glyphIndices: new LazyArray(uint16, "numChars")
  },
  12: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint32,
    nGroups: uint32,
    groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
  },
  13: {
    reserved: new Reserved(uint16),
    length: uint32,
    language: uint32,
    nGroups: uint32,
    groups: new LazyArray($26a62205ad06574e$var$CmapGroup, "nGroups")
  },
  14: {
    length: uint32,
    numRecords: uint32,
    varSelectors: new LazyArray($26a62205ad06574e$var$VarSelectorRecord, "numRecords")
  }
});
var $26a62205ad06574e$var$CmapEntry = new Struct({
  platformID: uint16,
  encodingID: uint16,
  table: new Pointer(uint32, $26a62205ad06574e$var$CmapSubtable, {
    type: "parent",
    lazy: true
  })
});
var $26a62205ad06574e$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numSubtables: uint16,
  tables: new ArrayT($26a62205ad06574e$var$CmapEntry, "numSubtables")
});
var $f2612a29f92ac062$export$2e2bcd8739ae039 = new Struct({
  version: int32,
  revision: int32,
  checkSumAdjustment: uint32,
  magicNumber: uint32,
  flags: uint16,
  unitsPerEm: uint16,
  created: new ArrayT(int32, 2),
  modified: new ArrayT(int32, 2),
  xMin: int16,
  yMin: int16,
  xMax: int16,
  yMax: int16,
  macStyle: new Bitfield(uint16, [
    "bold",
    "italic",
    "underline",
    "outline",
    "shadow",
    "condensed",
    "extended"
  ]),
  lowestRecPPEM: uint16,
  fontDirectionHint: int16,
  indexToLocFormat: int16,
  glyphDataFormat: int16
  // 0 for current format
});
var $2c179dd593583073$export$2e2bcd8739ae039 = new Struct({
  version: int32,
  ascent: int16,
  descent: int16,
  lineGap: int16,
  advanceWidthMax: uint16,
  minLeftSideBearing: int16,
  minRightSideBearing: int16,
  xMaxExtent: int16,
  caretSlopeRise: int16,
  caretSlopeRun: int16,
  caretOffset: int16,
  reserved: new Reserved(int16, 4),
  metricDataFormat: int16,
  numberOfMetrics: uint16
  // Number of advance widths in 'hmtx' table
});
var $bdc9060542264b85$var$HmtxEntry = new Struct({
  advance: uint16,
  bearing: int16
});
var $bdc9060542264b85$export$2e2bcd8739ae039 = new Struct({
  metrics: new LazyArray($bdc9060542264b85$var$HmtxEntry, (t2) => t2.parent.hhea.numberOfMetrics),
  bearings: new LazyArray(int16, (t2) => t2.parent.maxp.numGlyphs - t2.parent.hhea.numberOfMetrics)
});
var $dbf51cb3d3fe409d$export$2e2bcd8739ae039 = new Struct({
  version: int32,
  numGlyphs: uint16,
  maxPoints: uint16,
  maxContours: uint16,
  maxComponentPoints: uint16,
  maxComponentContours: uint16,
  maxZones: uint16,
  maxTwilightPoints: uint16,
  maxStorage: uint16,
  maxFunctionDefs: uint16,
  maxInstructionDefs: uint16,
  maxStackElements: uint16,
  maxSizeOfInstructions: uint16,
  maxComponentElements: uint16,
  maxComponentDepth: uint16
  // Maximum levels of recursion; 1 for simple components
});
function $e449ad78d50845fe$export$badc544e0651b6b1(platformID, encodingID, languageID = 0) {
  if (platformID === 1 && $e449ad78d50845fe$export$479e671907f486d1[languageID])
    return $e449ad78d50845fe$export$479e671907f486d1[languageID];
  return $e449ad78d50845fe$export$6fef87b7618bdf0b[platformID][encodingID];
}
var $e449ad78d50845fe$var$SINGLE_BYTE_ENCODINGS = /* @__PURE__ */ new Set([
  "x-mac-roman",
  "x-mac-cyrillic",
  "iso-8859-6",
  "iso-8859-8"
]);
var $e449ad78d50845fe$var$MAC_ENCODINGS = {
  "x-mac-croatian": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ",
  "x-mac-gaelic": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæøṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ",
  "x-mac-greek": "Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩάΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ­",
  "x-mac-icelandic": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ",
  "x-mac-inuit": "ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł",
  "x-mac-ce": "ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ",
  "x-mac-romanian": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ",
  "x-mac-turkish": "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ"
};
var $e449ad78d50845fe$var$encodingCache = /* @__PURE__ */ new Map();
function $e449ad78d50845fe$export$1dceb3c14ed68bee(encoding) {
  let cached = $e449ad78d50845fe$var$encodingCache.get(encoding);
  if (cached)
    return cached;
  let mapping = $e449ad78d50845fe$var$MAC_ENCODINGS[encoding];
  if (mapping) {
    let res = /* @__PURE__ */ new Map();
    for (let i = 0; i < mapping.length; i++)
      res.set(mapping.charCodeAt(i), 128 + i);
    $e449ad78d50845fe$var$encodingCache.set(encoding, res);
    return res;
  }
  if ($e449ad78d50845fe$var$SINGLE_BYTE_ENCODINGS.has(encoding)) {
    let decoder = new TextDecoder(encoding);
    let mapping2 = new Uint8Array(128);
    for (let i = 0; i < 128; i++)
      mapping2[i] = 128 + i;
    let res = /* @__PURE__ */ new Map();
    let s2 = decoder.decode(mapping2);
    for (let i1 = 0; i1 < 128; i1++)
      res.set(s2.charCodeAt(i1), 128 + i1);
    $e449ad78d50845fe$var$encodingCache.set(encoding, res);
    return res;
  }
}
var $e449ad78d50845fe$export$6fef87b7618bdf0b = [
  // unicode
  [
    "utf16be",
    "utf16be",
    "utf16be",
    "utf16be",
    "utf16be",
    "utf16be"
  ],
  // macintosh
  // Mappings available at http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/
  // 0	Roman                 17	Malayalam
  // 1	Japanese	            18	Sinhalese
  // 2	Traditional Chinese	  19	Burmese
  // 3	Korean	              20	Khmer
  // 4	Arabic	              21	Thai
  // 5	Hebrew	              22	Laotian
  // 6	Greek	                23	Georgian
  // 7	Russian	              24	Armenian
  // 8	RSymbol	              25	Simplified Chinese
  // 9	Devanagari	          26	Tibetan
  // 10	Gurmukhi	            27	Mongolian
  // 11	Gujarati	            28	Geez
  // 12	Oriya	                29	Slavic
  // 13	Bengali	              30	Vietnamese
  // 14	Tamil	                31	Sindhi
  // 15	Telugu	              32	(Uninterpreted)
  // 16	Kannada
  [
    "x-mac-roman",
    "shift-jis",
    "big5",
    "euc-kr",
    "iso-8859-6",
    "iso-8859-8",
    "x-mac-greek",
    "x-mac-cyrillic",
    "x-mac-symbol",
    "x-mac-devanagari",
    "x-mac-gurmukhi",
    "x-mac-gujarati",
    "Oriya",
    "Bengali",
    "Tamil",
    "Telugu",
    "Kannada",
    "Malayalam",
    "Sinhalese",
    "Burmese",
    "Khmer",
    "iso-8859-11",
    "Laotian",
    "Georgian",
    "Armenian",
    "hz-gb-2312",
    "Tibetan",
    "Mongolian",
    "Geez",
    "x-mac-ce",
    "Vietnamese",
    "Sindhi"
  ],
  // ISO (deprecated)
  [
    "ascii"
  ],
  // windows
  // Docs here: http://msdn.microsoft.com/en-us/library/system.text.encoding(v=vs.110).aspx
  [
    "symbol",
    "utf16be",
    "shift-jis",
    "gb18030",
    "big5",
    "x-cp20949",
    "johab",
    null,
    null,
    null,
    "utf16be"
  ]
];
var $e449ad78d50845fe$export$479e671907f486d1 = {
  15: "x-mac-icelandic",
  17: "x-mac-turkish",
  18: "x-mac-croatian",
  24: "x-mac-ce",
  25: "x-mac-ce",
  26: "x-mac-ce",
  27: "x-mac-ce",
  28: "x-mac-ce",
  30: "x-mac-icelandic",
  37: "x-mac-romanian",
  38: "x-mac-ce",
  39: "x-mac-ce",
  40: "x-mac-ce",
  143: "x-mac-inuit",
  146: "x-mac-gaelic"
};
var $e449ad78d50845fe$export$2092376fd002e13 = [
  // unicode
  [],
  {
    0: "en",
    30: "fo",
    60: "ks",
    90: "rw",
    1: "fr",
    31: "fa",
    61: "ku",
    91: "rn",
    2: "de",
    32: "ru",
    62: "sd",
    92: "ny",
    3: "it",
    33: "zh",
    63: "bo",
    93: "mg",
    4: "nl",
    34: "nl-BE",
    64: "ne",
    94: "eo",
    5: "sv",
    35: "ga",
    65: "sa",
    128: "cy",
    6: "es",
    36: "sq",
    66: "mr",
    129: "eu",
    7: "da",
    37: "ro",
    67: "bn",
    130: "ca",
    8: "pt",
    38: "cz",
    68: "as",
    131: "la",
    9: "no",
    39: "sk",
    69: "gu",
    132: "qu",
    10: "he",
    40: "si",
    70: "pa",
    133: "gn",
    11: "ja",
    41: "yi",
    71: "or",
    134: "ay",
    12: "ar",
    42: "sr",
    72: "ml",
    135: "tt",
    13: "fi",
    43: "mk",
    73: "kn",
    136: "ug",
    14: "el",
    44: "bg",
    74: "ta",
    137: "dz",
    15: "is",
    45: "uk",
    75: "te",
    138: "jv",
    16: "mt",
    46: "be",
    76: "si",
    139: "su",
    17: "tr",
    47: "uz",
    77: "my",
    140: "gl",
    18: "hr",
    48: "kk",
    78: "km",
    141: "af",
    19: "zh-Hant",
    49: "az-Cyrl",
    79: "lo",
    142: "br",
    20: "ur",
    50: "az-Arab",
    80: "vi",
    143: "iu",
    21: "hi",
    51: "hy",
    81: "id",
    144: "gd",
    22: "th",
    52: "ka",
    82: "tl",
    145: "gv",
    23: "ko",
    53: "mo",
    83: "ms",
    146: "ga",
    24: "lt",
    54: "ky",
    84: "ms-Arab",
    147: "to",
    25: "pl",
    55: "tg",
    85: "am",
    148: "el-polyton",
    26: "hu",
    56: "tk",
    86: "ti",
    149: "kl",
    27: "es",
    57: "mn-CN",
    87: "om",
    150: "az",
    28: "lv",
    58: "mn",
    88: "so",
    151: "nn",
    29: "se",
    59: "ps",
    89: "sw"
  },
  // ISO (deprecated)
  [],
  {
    1078: "af",
    16393: "en-IN",
    1159: "rw",
    1074: "tn",
    1052: "sq",
    6153: "en-IE",
    1089: "sw",
    1115: "si",
    1156: "gsw",
    8201: "en-JM",
    1111: "kok",
    1051: "sk",
    1118: "am",
    17417: "en-MY",
    1042: "ko",
    1060: "sl",
    5121: "ar-DZ",
    5129: "en-NZ",
    1088: "ky",
    11274: "es-AR",
    15361: "ar-BH",
    13321: "en-PH",
    1108: "lo",
    16394: "es-BO",
    3073: "ar",
    18441: "en-SG",
    1062: "lv",
    13322: "es-CL",
    2049: "ar-IQ",
    7177: "en-ZA",
    1063: "lt",
    9226: "es-CO",
    11265: "ar-JO",
    11273: "en-TT",
    2094: "dsb",
    5130: "es-CR",
    13313: "ar-KW",
    2057: "en-GB",
    1134: "lb",
    7178: "es-DO",
    12289: "ar-LB",
    1033: "en",
    1071: "mk",
    12298: "es-EC",
    4097: "ar-LY",
    12297: "en-ZW",
    2110: "ms-BN",
    17418: "es-SV",
    6145: "ary",
    1061: "et",
    1086: "ms",
    4106: "es-GT",
    8193: "ar-OM",
    1080: "fo",
    1100: "ml",
    18442: "es-HN",
    16385: "ar-QA",
    1124: "fil",
    1082: "mt",
    2058: "es-MX",
    1025: "ar-SA",
    1035: "fi",
    1153: "mi",
    19466: "es-NI",
    10241: "ar-SY",
    2060: "fr-BE",
    1146: "arn",
    6154: "es-PA",
    7169: "aeb",
    3084: "fr-CA",
    1102: "mr",
    15370: "es-PY",
    14337: "ar-AE",
    1036: "fr",
    1148: "moh",
    10250: "es-PE",
    9217: "ar-YE",
    5132: "fr-LU",
    1104: "mn",
    20490: "es-PR",
    1067: "hy",
    6156: "fr-MC",
    2128: "mn-CN",
    3082: "es",
    1101: "as",
    4108: "fr-CH",
    1121: "ne",
    1034: "es",
    2092: "az-Cyrl",
    1122: "fy",
    1044: "nb",
    21514: "es-US",
    1068: "az",
    1110: "gl",
    2068: "nn",
    14346: "es-UY",
    1133: "ba",
    1079: "ka",
    1154: "oc",
    8202: "es-VE",
    1069: "eu",
    3079: "de-AT",
    1096: "or",
    2077: "sv-FI",
    1059: "be",
    1031: "de",
    1123: "ps",
    1053: "sv",
    2117: "bn",
    5127: "de-LI",
    1045: "pl",
    1114: "syr",
    1093: "bn-IN",
    4103: "de-LU",
    1046: "pt",
    1064: "tg",
    8218: "bs-Cyrl",
    2055: "de-CH",
    2070: "pt-PT",
    2143: "tzm",
    5146: "bs",
    1032: "el",
    1094: "pa",
    1097: "ta",
    1150: "br",
    1135: "kl",
    1131: "qu-BO",
    1092: "tt",
    1026: "bg",
    1095: "gu",
    2155: "qu-EC",
    1098: "te",
    1027: "ca",
    1128: "ha",
    3179: "qu",
    1054: "th",
    3076: "zh-HK",
    1037: "he",
    1048: "ro",
    1105: "bo",
    5124: "zh-MO",
    1081: "hi",
    1047: "rm",
    1055: "tr",
    2052: "zh",
    1038: "hu",
    1049: "ru",
    1090: "tk",
    4100: "zh-SG",
    1039: "is",
    9275: "smn",
    1152: "ug",
    1028: "zh-TW",
    1136: "ig",
    4155: "smj-NO",
    1058: "uk",
    1155: "co",
    1057: "id",
    5179: "smj",
    1070: "hsb",
    1050: "hr",
    1117: "iu",
    3131: "se-FI",
    1056: "ur",
    4122: "hr-BA",
    2141: "iu-Latn",
    1083: "se",
    2115: "uz-Cyrl",
    1029: "cs",
    2108: "ga",
    2107: "se-SE",
    1091: "uz",
    1030: "da",
    1076: "xh",
    8251: "sms",
    1066: "vi",
    1164: "prs",
    1077: "zu",
    6203: "sma-NO",
    1106: "cy",
    1125: "dv",
    1040: "it",
    7227: "sms",
    1160: "wo",
    2067: "nl-BE",
    2064: "it-CH",
    1103: "sa",
    1157: "sah",
    1043: "nl",
    1041: "ja",
    7194: "sr-Cyrl-BA",
    1144: "ii",
    3081: "en-AU",
    1099: "kn",
    3098: "sr",
    1130: "yo",
    10249: "en-BZ",
    1087: "kk",
    6170: "sr-Latn-BA",
    4105: "en-CA",
    1107: "km",
    2074: "sr-Latn",
    9225: "en-029",
    1158: "quc",
    1132: "nso"
  }
];
var $2bcf221753ec8e32$var$NameRecord = new Struct({
  platformID: uint16,
  encodingID: uint16,
  languageID: uint16,
  nameID: uint16,
  length: uint16,
  string: new Pointer(uint16, new StringT("length", (t2) => (0, $e449ad78d50845fe$export$badc544e0651b6b1)(t2.platformID, t2.encodingID, t2.languageID)), {
    type: "parent",
    relativeTo: (ctx) => ctx.parent.stringOffset,
    allowNull: false
  })
});
var $2bcf221753ec8e32$var$LangTagRecord = new Struct({
  length: uint16,
  tag: new Pointer(uint16, new StringT("length", "utf16be"), {
    type: "parent",
    relativeTo: (ctx) => ctx.stringOffset
  })
});
var $2bcf221753ec8e32$var$NameTable = new VersionedStruct(uint16, {
  0: {
    count: uint16,
    stringOffset: uint16,
    records: new ArrayT($2bcf221753ec8e32$var$NameRecord, "count")
  },
  1: {
    count: uint16,
    stringOffset: uint16,
    records: new ArrayT($2bcf221753ec8e32$var$NameRecord, "count"),
    langTagCount: uint16,
    langTags: new ArrayT($2bcf221753ec8e32$var$LangTagRecord, "langTagCount")
  }
});
var $2bcf221753ec8e32$export$2e2bcd8739ae039 = $2bcf221753ec8e32$var$NameTable;
var $2bcf221753ec8e32$var$NAMES = [
  "copyright",
  "fontFamily",
  "fontSubfamily",
  "uniqueSubfamily",
  "fullName",
  "version",
  "postscriptName",
  "trademark",
  "manufacturer",
  "designer",
  "description",
  "vendorURL",
  "designerURL",
  "license",
  "licenseURL",
  null,
  "preferredFamily",
  "preferredSubfamily",
  "compatibleFull",
  "sampleText",
  "postscriptCIDFontName",
  "wwsFamilyName",
  "wwsSubfamilyName"
];
$2bcf221753ec8e32$var$NameTable.process = function(stream2) {
  var records = {};
  for (let record of this.records) {
    let language = (0, $e449ad78d50845fe$export$2092376fd002e13)[record.platformID][record.languageID];
    if (language == null && this.langTags != null && record.languageID >= 32768)
      language = this.langTags[record.languageID - 32768].tag;
    if (language == null)
      language = record.platformID + "-" + record.languageID;
    let key = record.nameID >= 256 ? "fontFeatures" : $2bcf221753ec8e32$var$NAMES[record.nameID] || record.nameID;
    if (records[key] == null)
      records[key] = {};
    let obj = records[key];
    if (record.nameID >= 256)
      obj = obj[record.nameID] || (obj[record.nameID] = {});
    if (typeof record.string === "string" || typeof obj[language] !== "string")
      obj[language] = record.string;
  }
  this.records = records;
};
$2bcf221753ec8e32$var$NameTable.preEncode = function() {
  if (Array.isArray(this.records))
    return;
  this.version = 0;
  let records = [];
  for (let key in this.records) {
    let val = this.records[key];
    if (key === "fontFeatures")
      continue;
    records.push({
      platformID: 3,
      encodingID: 1,
      languageID: 1033,
      nameID: $2bcf221753ec8e32$var$NAMES.indexOf(key),
      length: val.en.length * 2,
      string: val.en
    });
    if (key === "postscriptName")
      records.push({
        platformID: 1,
        encodingID: 0,
        languageID: 0,
        nameID: $2bcf221753ec8e32$var$NAMES.indexOf(key),
        length: val.en.length,
        string: val.en
      });
  }
  this.records = records;
  this.count = records.length;
  this.stringOffset = $2bcf221753ec8e32$var$NameTable.size(this, null, false);
};
var $84b272aa31b70606$var$OS2 = new VersionedStruct(uint16, {
  header: {
    xAvgCharWidth: int16,
    usWeightClass: uint16,
    usWidthClass: uint16,
    fsType: new Bitfield(uint16, [
      null,
      "noEmbedding",
      "viewOnly",
      "editable",
      null,
      null,
      null,
      null,
      "noSubsetting",
      "bitmapOnly"
    ]),
    ySubscriptXSize: int16,
    ySubscriptYSize: int16,
    ySubscriptXOffset: int16,
    ySubscriptYOffset: int16,
    ySuperscriptXSize: int16,
    ySuperscriptYSize: int16,
    ySuperscriptXOffset: int16,
    ySuperscriptYOffset: int16,
    yStrikeoutSize: int16,
    yStrikeoutPosition: int16,
    sFamilyClass: int16,
    panose: new ArrayT(uint8, 10),
    ulCharRange: new ArrayT(uint32, 4),
    vendorID: new StringT(4),
    fsSelection: new Bitfield(uint16, [
      "italic",
      "underscore",
      "negative",
      "outlined",
      "strikeout",
      "bold",
      "regular",
      "useTypoMetrics",
      "wws",
      "oblique"
    ]),
    usFirstCharIndex: uint16,
    usLastCharIndex: uint16
    // The maximum Unicode index in this font
  },
  // The Apple version of this table ends here, but the Microsoft one continues on...
  0: {},
  1: {
    typoAscender: int16,
    typoDescender: int16,
    typoLineGap: int16,
    winAscent: uint16,
    winDescent: uint16,
    codePageRange: new ArrayT(uint32, 2)
  },
  2: {
    // these should be common with version 1 somehow
    typoAscender: int16,
    typoDescender: int16,
    typoLineGap: int16,
    winAscent: uint16,
    winDescent: uint16,
    codePageRange: new ArrayT(uint32, 2),
    xHeight: int16,
    capHeight: int16,
    defaultChar: uint16,
    breakChar: uint16,
    maxContent: uint16
  },
  5: {
    typoAscender: int16,
    typoDescender: int16,
    typoLineGap: int16,
    winAscent: uint16,
    winDescent: uint16,
    codePageRange: new ArrayT(uint32, 2),
    xHeight: int16,
    capHeight: int16,
    defaultChar: uint16,
    breakChar: uint16,
    maxContent: uint16,
    usLowerOpticalPointSize: uint16,
    usUpperOpticalPointSize: uint16
  }
});
var $84b272aa31b70606$var$versions = $84b272aa31b70606$var$OS2.versions;
$84b272aa31b70606$var$versions[3] = $84b272aa31b70606$var$versions[4] = $84b272aa31b70606$var$versions[2];
var $84b272aa31b70606$export$2e2bcd8739ae039 = $84b272aa31b70606$var$OS2;
var $32d9e2eb9565d93c$export$2e2bcd8739ae039 = new VersionedStruct(fixed32, {
  header: {
    italicAngle: fixed32,
    underlinePosition: int16,
    underlineThickness: int16,
    isFixedPitch: uint32,
    minMemType42: uint32,
    maxMemType42: uint32,
    minMemType1: uint32,
    maxMemType1: uint32
    // Maximum memory usage when a TrueType font is downloaded as a Type 1 font
  },
  1: {},
  2: {
    numberOfGlyphs: uint16,
    glyphNameIndex: new ArrayT(uint16, "numberOfGlyphs"),
    names: new ArrayT(new StringT(uint8))
  },
  2.5: {
    numberOfGlyphs: uint16,
    offsets: new ArrayT(uint8, "numberOfGlyphs")
  },
  3: {},
  4: {
    map: new ArrayT(uint32, (t2) => t2.parent.maxp.numGlyphs)
  }
});
var $5202bd9d9ad8eaac$export$2e2bcd8739ae039 = new Struct({
  controlValues: new ArrayT(int16)
});
var $5c0f37ca5ffb1850$export$2e2bcd8739ae039 = new Struct({
  instructions: new ArrayT(uint8)
});
var $2b2b260902b1c57e$var$loca = new VersionedStruct("head.indexToLocFormat", {
  0: {
    offsets: new ArrayT(uint16)
  },
  1: {
    offsets: new ArrayT(uint32)
  }
});
$2b2b260902b1c57e$var$loca.process = function() {
  if (this.version === 0 && !this._processed) {
    for (let i = 0; i < this.offsets.length; i++)
      this.offsets[i] <<= 1;
    this._processed = true;
  }
};
$2b2b260902b1c57e$var$loca.preEncode = function() {
  if (this.version === 0 && this._processed !== false) {
    for (let i = 0; i < this.offsets.length; i++)
      this.offsets[i] >>>= 1;
    this._processed = false;
  }
};
var $2b2b260902b1c57e$export$2e2bcd8739ae039 = $2b2b260902b1c57e$var$loca;
var $7afb878c7bea4f66$export$2e2bcd8739ae039 = new Struct({
  controlValueProgram: new ArrayT(uint8)
});
var $6c92b6371bce8bd9$export$2e2bcd8739ae039 = new ArrayT(new BufferT());
var $43e9821ef3717eec$export$2e2bcd8739ae039 = class {
  getCFFVersion(ctx) {
    while (ctx && !ctx.hdrSize)
      ctx = ctx.parent;
    return ctx ? ctx.version : -1;
  }
  decode(stream2, parent) {
    let version4 = this.getCFFVersion(parent);
    let count = version4 >= 2 ? stream2.readUInt32BE() : stream2.readUInt16BE();
    if (count === 0)
      return [];
    let offSize = stream2.readUInt8();
    let offsetType;
    if (offSize === 1)
      offsetType = uint8;
    else if (offSize === 2)
      offsetType = uint16;
    else if (offSize === 3)
      offsetType = uint24;
    else if (offSize === 4)
      offsetType = uint32;
    else
      throw new Error(`Bad offset size in CFFIndex: ${offSize} ${stream2.pos}`);
    let ret = [];
    let startPos = stream2.pos + (count + 1) * offSize - 1;
    let start3 = offsetType.decode(stream2);
    for (let i = 0; i < count; i++) {
      let end3 = offsetType.decode(stream2);
      if (this.type != null) {
        let pos = stream2.pos;
        stream2.pos = startPos + start3;
        parent.length = end3 - start3;
        ret.push(this.type.decode(stream2, parent));
        stream2.pos = pos;
      } else
        ret.push({
          offset: startPos + start3,
          length: end3 - start3
        });
      start3 = end3;
    }
    stream2.pos = startPos + start3;
    return ret;
  }
  size(arr, parent) {
    let size = 2;
    if (arr.length === 0)
      return size;
    let type = this.type || new BufferT();
    let offset3 = 1;
    for (let i = 0; i < arr.length; i++) {
      let item = arr[i];
      offset3 += type.size(item, parent);
    }
    let offsetType;
    if (offset3 <= 255)
      offsetType = uint8;
    else if (offset3 <= 65535)
      offsetType = uint16;
    else if (offset3 <= 16777215)
      offsetType = uint24;
    else if (offset3 <= 4294967295)
      offsetType = uint32;
    else
      throw new Error("Bad offset in CFFIndex");
    size += 1 + offsetType.size() * (arr.length + 1);
    size += offset3 - 1;
    return size;
  }
  encode(stream2, arr, parent) {
    stream2.writeUInt16BE(arr.length);
    if (arr.length === 0)
      return;
    let type = this.type || new BufferT();
    let sizes = [];
    let offset3 = 1;
    for (let item of arr) {
      let s2 = type.size(item, parent);
      sizes.push(s2);
      offset3 += s2;
    }
    let offsetType;
    if (offset3 <= 255)
      offsetType = uint8;
    else if (offset3 <= 65535)
      offsetType = uint16;
    else if (offset3 <= 16777215)
      offsetType = uint24;
    else if (offset3 <= 4294967295)
      offsetType = uint32;
    else
      throw new Error("Bad offset in CFFIndex");
    stream2.writeUInt8(offsetType.size());
    offset3 = 1;
    offsetType.encode(stream2, offset3);
    for (let size of sizes) {
      offset3 += size;
      offsetType.encode(stream2, offset3);
    }
    for (let item1 of arr)
      type.encode(stream2, item1, parent);
    return;
  }
  constructor(type) {
    this.type = type;
  }
};
var $c2d28e92708f99da$var$FLOAT_EOF = 15;
var $c2d28e92708f99da$var$FLOAT_LOOKUP = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  ".",
  "E",
  "E-",
  null,
  "-"
];
var $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP = {
  ".": 10,
  "E": 11,
  "E-": 12,
  "-": 14
};
var $c2d28e92708f99da$export$2e2bcd8739ae039 = class {
  static decode(stream2, value2) {
    if (32 <= value2 && value2 <= 246)
      return value2 - 139;
    if (247 <= value2 && value2 <= 250)
      return (value2 - 247) * 256 + stream2.readUInt8() + 108;
    if (251 <= value2 && value2 <= 254)
      return -(value2 - 251) * 256 - stream2.readUInt8() - 108;
    if (value2 === 28)
      return stream2.readInt16BE();
    if (value2 === 29)
      return stream2.readInt32BE();
    if (value2 === 30) {
      let str = "";
      while (true) {
        let b = stream2.readUInt8();
        let n1 = b >> 4;
        if (n1 === $c2d28e92708f99da$var$FLOAT_EOF)
          break;
        str += $c2d28e92708f99da$var$FLOAT_LOOKUP[n1];
        let n2 = b & 15;
        if (n2 === $c2d28e92708f99da$var$FLOAT_EOF)
          break;
        str += $c2d28e92708f99da$var$FLOAT_LOOKUP[n2];
      }
      return parseFloat(str);
    }
    return null;
  }
  static size(value2) {
    if (value2.forceLarge)
      value2 = 32768;
    if ((value2 | 0) !== value2) {
      let str = "" + value2;
      return 1 + Math.ceil((str.length + 1) / 2);
    } else if (-107 <= value2 && value2 <= 107)
      return 1;
    else if (108 <= value2 && value2 <= 1131 || -1131 <= value2 && value2 <= -108)
      return 2;
    else if (-32768 <= value2 && value2 <= 32767)
      return 3;
    else
      return 5;
  }
  static encode(stream2, value2) {
    let val = Number(value2);
    if (value2.forceLarge) {
      stream2.writeUInt8(29);
      return stream2.writeInt32BE(val);
    } else if ((val | 0) !== val) {
      stream2.writeUInt8(30);
      let str = "" + val;
      for (let i = 0; i < str.length; i += 2) {
        let c1 = str[i];
        let n1 = $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP[c1] || +c1;
        if (i === str.length - 1)
          var n2 = $c2d28e92708f99da$var$FLOAT_EOF;
        else {
          let c2 = str[i + 1];
          var n2 = $c2d28e92708f99da$var$FLOAT_ENCODE_LOOKUP[c2] || +c2;
        }
        stream2.writeUInt8(n1 << 4 | n2 & 15);
      }
      if (n2 !== $c2d28e92708f99da$var$FLOAT_EOF)
        return stream2.writeUInt8($c2d28e92708f99da$var$FLOAT_EOF << 4);
    } else if (-107 <= val && val <= 107)
      return stream2.writeUInt8(val + 139);
    else if (108 <= val && val <= 1131) {
      val -= 108;
      stream2.writeUInt8((val >> 8) + 247);
      return stream2.writeUInt8(val & 255);
    } else if (-1131 <= val && val <= -108) {
      val = -val - 108;
      stream2.writeUInt8((val >> 8) + 251);
      return stream2.writeUInt8(val & 255);
    } else if (-32768 <= val && val <= 32767) {
      stream2.writeUInt8(28);
      return stream2.writeInt16BE(val);
    } else {
      stream2.writeUInt8(29);
      return stream2.writeInt32BE(val);
    }
  }
};
var $61aa549f16d58b9b$export$2e2bcd8739ae039 = class {
  decodeOperands(type, stream2, ret, operands) {
    if (Array.isArray(type))
      return operands.map((op, i) => this.decodeOperands(type[i], stream2, ret, [
        op
      ]));
    else if (type.decode != null)
      return type.decode(stream2, ret, operands);
    else
      switch (type) {
        case "number":
        case "offset":
        case "sid":
          return operands[0];
        case "boolean":
          return !!operands[0];
        default:
          return operands;
      }
  }
  encodeOperands(type, stream2, ctx, operands) {
    if (Array.isArray(type))
      return operands.map((op, i) => this.encodeOperands(type[i], stream2, ctx, op)[0]);
    else if (type.encode != null)
      return type.encode(stream2, operands, ctx);
    else if (typeof operands === "number")
      return [
        operands
      ];
    else if (typeof operands === "boolean")
      return [
        +operands
      ];
    else if (Array.isArray(operands))
      return operands;
    else
      return [
        operands
      ];
  }
  decode(stream2, parent) {
    let end3 = stream2.pos + parent.length;
    let ret = {};
    let operands = [];
    Object.defineProperties(ret, {
      parent: {
        value: parent
      },
      _startOffset: {
        value: stream2.pos
      }
    });
    for (let key in this.fields) {
      let field = this.fields[key];
      ret[field[1]] = field[3];
    }
    while (stream2.pos < end3) {
      let b = stream2.readUInt8();
      if (b < 28) {
        if (b === 12)
          b = b << 8 | stream2.readUInt8();
        let field = this.fields[b];
        if (!field)
          throw new Error(`Unknown operator ${b}`);
        let val = this.decodeOperands(field[2], stream2, ret, operands);
        if (val != null) {
          if (val instanceof (0, PropertyDescriptor))
            Object.defineProperty(ret, field[1], val);
          else
            ret[field[1]] = val;
        }
        operands = [];
      } else
        operands.push((0, $c2d28e92708f99da$export$2e2bcd8739ae039).decode(stream2, b));
    }
    return ret;
  }
  size(dict, parent, includePointers = true) {
    let ctx = {
      parent,
      val: dict,
      pointerSize: 0,
      startOffset: parent.startOffset || 0
    };
    let len = 0;
    for (let k in this.fields) {
      let field = this.fields[k];
      let val = dict[field[1]];
      if (val == null || (0, import_fast_deep_equal.default)(val, field[3]))
        continue;
      let operands = this.encodeOperands(field[2], null, ctx, val);
      for (let op of operands)
        len += (0, $c2d28e92708f99da$export$2e2bcd8739ae039).size(op);
      let key = Array.isArray(field[0]) ? field[0] : [
        field[0]
      ];
      len += key.length;
    }
    if (includePointers)
      len += ctx.pointerSize;
    return len;
  }
  encode(stream2, dict, parent) {
    let ctx = {
      pointers: [],
      startOffset: stream2.pos,
      parent,
      val: dict,
      pointerSize: 0
    };
    ctx.pointerOffset = stream2.pos + this.size(dict, ctx, false);
    for (let field of this.ops) {
      let val = dict[field[1]];
      if (val == null || (0, import_fast_deep_equal.default)(val, field[3]))
        continue;
      let operands = this.encodeOperands(field[2], stream2, ctx, val);
      for (let op of operands)
        (0, $c2d28e92708f99da$export$2e2bcd8739ae039).encode(stream2, op);
      let key = Array.isArray(field[0]) ? field[0] : [
        field[0]
      ];
      for (let op1 of key)
        stream2.writeUInt8(op1);
    }
    let i = 0;
    while (i < ctx.pointers.length) {
      let ptr = ctx.pointers[i++];
      ptr.type.encode(stream2, ptr.val, ptr.parent);
    }
    return;
  }
  constructor(ops = []) {
    this.ops = ops;
    this.fields = {};
    for (let field of ops) {
      let key = Array.isArray(field[0]) ? field[0][0] << 8 | field[0][1] : field[0];
      this.fields[key] = field;
    }
  }
};
var $0e34a43d05bde82c$export$2e2bcd8739ae039 = class extends Pointer {
  decode(stream2, parent, operands) {
    this.offsetType = {
      decode: () => operands[0]
    };
    return super.decode(stream2, parent, operands);
  }
  encode(stream2, value2, ctx) {
    if (!stream2) {
      this.offsetType = {
        size: () => 0
      };
      this.size(value2, ctx);
      return [
        new $0e34a43d05bde82c$var$Ptr(0)
      ];
    }
    let ptr = null;
    this.offsetType = {
      encode: (stream3, val) => ptr = val
    };
    super.encode(stream2, value2, ctx);
    return [
      new $0e34a43d05bde82c$var$Ptr(ptr)
    ];
  }
  constructor(type, options = {}) {
    if (options.type == null)
      options.type = "global";
    super(null, type, options);
  }
};
var $0e34a43d05bde82c$var$Ptr = class {
  valueOf() {
    return this.val;
  }
  constructor(val) {
    this.val = val;
    this.forceLarge = true;
  }
};
var $6d59db2e29cc77b3$var$CFFBlendOp = class {
  static decode(stream2, parent, operands) {
    let numBlends = operands.pop();
    while (operands.length > numBlends)
      operands.pop();
  }
};
var $6d59db2e29cc77b3$export$2e2bcd8739ae039 = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  // key       name                    type                                          default
  [
    6,
    "BlueValues",
    "delta",
    null
  ],
  [
    7,
    "OtherBlues",
    "delta",
    null
  ],
  [
    8,
    "FamilyBlues",
    "delta",
    null
  ],
  [
    9,
    "FamilyOtherBlues",
    "delta",
    null
  ],
  [
    [
      12,
      9
    ],
    "BlueScale",
    "number",
    0.039625
  ],
  [
    [
      12,
      10
    ],
    "BlueShift",
    "number",
    7
  ],
  [
    [
      12,
      11
    ],
    "BlueFuzz",
    "number",
    1
  ],
  [
    10,
    "StdHW",
    "number",
    null
  ],
  [
    11,
    "StdVW",
    "number",
    null
  ],
  [
    [
      12,
      12
    ],
    "StemSnapH",
    "delta",
    null
  ],
  [
    [
      12,
      13
    ],
    "StemSnapV",
    "delta",
    null
  ],
  [
    [
      12,
      14
    ],
    "ForceBold",
    "boolean",
    false
  ],
  [
    [
      12,
      17
    ],
    "LanguageGroup",
    "number",
    0
  ],
  [
    [
      12,
      18
    ],
    "ExpansionFactor",
    "number",
    0.06
  ],
  [
    [
      12,
      19
    ],
    "initialRandomSeed",
    "number",
    0
  ],
  [
    20,
    "defaultWidthX",
    "number",
    0
  ],
  [
    21,
    "nominalWidthX",
    "number",
    0
  ],
  [
    22,
    "vsindex",
    "number",
    0
  ],
  [
    23,
    "blend",
    $6d59db2e29cc77b3$var$CFFBlendOp,
    null
  ],
  [
    19,
    "Subrs",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(), {
      type: "local"
    }),
    null
  ]
]);
var $229224aec43783c5$export$2e2bcd8739ae039 = [
  ".notdef",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "questiondown",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "AE",
  "ordfeminine",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "ae",
  "dotlessi",
  "lslash",
  "oslash",
  "oe",
  "germandbls",
  "onesuperior",
  "logicalnot",
  "mu",
  "trademark",
  "Eth",
  "onehalf",
  "plusminus",
  "Thorn",
  "onequarter",
  "divide",
  "brokenbar",
  "degree",
  "thorn",
  "threequarters",
  "twosuperior",
  "registered",
  "minus",
  "eth",
  "multiply",
  "threesuperior",
  "copyright",
  "Aacute",
  "Acircumflex",
  "Adieresis",
  "Agrave",
  "Aring",
  "Atilde",
  "Ccedilla",
  "Eacute",
  "Ecircumflex",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Ntilde",
  "Oacute",
  "Ocircumflex",
  "Odieresis",
  "Ograve",
  "Otilde",
  "Scaron",
  "Uacute",
  "Ucircumflex",
  "Udieresis",
  "Ugrave",
  "Yacute",
  "Ydieresis",
  "Zcaron",
  "aacute",
  "acircumflex",
  "adieresis",
  "agrave",
  "aring",
  "atilde",
  "ccedilla",
  "eacute",
  "ecircumflex",
  "edieresis",
  "egrave",
  "iacute",
  "icircumflex",
  "idieresis",
  "igrave",
  "ntilde",
  "oacute",
  "ocircumflex",
  "odieresis",
  "ograve",
  "otilde",
  "scaron",
  "uacute",
  "ucircumflex",
  "udieresis",
  "ugrave",
  "yacute",
  "ydieresis",
  "zcaron",
  "exclamsmall",
  "Hungarumlautsmall",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "Dotaccentsmall",
  "Macronsmall",
  "figuredash",
  "hypheninferior",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall",
  "001.000",
  "001.001",
  "001.002",
  "001.003",
  "Black",
  "Bold",
  "Book",
  "Light",
  "Medium",
  "Regular",
  "Roman",
  "Semibold"
];
var $bc0433d9b7e41f5f$export$dee0027060fa13bd = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "",
  "questiondown",
  "",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "",
  "ring",
  "cedilla",
  "",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "AE",
  "",
  "ordfeminine",
  "",
  "",
  "",
  "",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "",
  "",
  "",
  "",
  "",
  "ae",
  "",
  "",
  "",
  "dotlessi",
  "",
  "",
  "lslash",
  "oslash",
  "oe",
  "germandbls"
];
var $bc0433d9b7e41f5f$export$4f58f497e14a53c3 = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclamsmall",
  "Hungarumlautsmall",
  "",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "",
  "",
  "isuperior",
  "",
  "",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "",
  "",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "",
  "",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "",
  "Dotaccentsmall",
  "",
  "",
  "Macronsmall",
  "",
  "",
  "figuredash",
  "hypheninferior",
  "",
  "",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "",
  "",
  "",
  "onequarter",
  "onehalf",
  "threequarters",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "",
  "",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall"
];
var $ef658f5c9a1488b2$export$c33b50336c234f16 = [
  ".notdef",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "questiondown",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "AE",
  "ordfeminine",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "ae",
  "dotlessi",
  "lslash",
  "oslash",
  "oe",
  "germandbls",
  "onesuperior",
  "logicalnot",
  "mu",
  "trademark",
  "Eth",
  "onehalf",
  "plusminus",
  "Thorn",
  "onequarter",
  "divide",
  "brokenbar",
  "degree",
  "thorn",
  "threequarters",
  "twosuperior",
  "registered",
  "minus",
  "eth",
  "multiply",
  "threesuperior",
  "copyright",
  "Aacute",
  "Acircumflex",
  "Adieresis",
  "Agrave",
  "Aring",
  "Atilde",
  "Ccedilla",
  "Eacute",
  "Ecircumflex",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Ntilde",
  "Oacute",
  "Ocircumflex",
  "Odieresis",
  "Ograve",
  "Otilde",
  "Scaron",
  "Uacute",
  "Ucircumflex",
  "Udieresis",
  "Ugrave",
  "Yacute",
  "Ydieresis",
  "Zcaron",
  "aacute",
  "acircumflex",
  "adieresis",
  "agrave",
  "aring",
  "atilde",
  "ccedilla",
  "eacute",
  "ecircumflex",
  "edieresis",
  "egrave",
  "iacute",
  "icircumflex",
  "idieresis",
  "igrave",
  "ntilde",
  "oacute",
  "ocircumflex",
  "odieresis",
  "ograve",
  "otilde",
  "scaron",
  "uacute",
  "ucircumflex",
  "udieresis",
  "ugrave",
  "yacute",
  "ydieresis",
  "zcaron"
];
var $ef658f5c9a1488b2$export$3ed0f9e1fee8d489 = [
  ".notdef",
  "space",
  "exclamsmall",
  "Hungarumlautsmall",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "Dotaccentsmall",
  "Macronsmall",
  "figuredash",
  "hypheninferior",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "onequarter",
  "onehalf",
  "threequarters",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall"
];
var $ef658f5c9a1488b2$export$dc28be11139d4120 = [
  ".notdef",
  "space",
  "dollaroldstyle",
  "dollarsuperior",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "hyphensuperior",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "centoldstyle",
  "figuredash",
  "hypheninferior",
  "onequarter",
  "onehalf",
  "threequarters",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior"
];
var $7cbbe4e24ef3cb75$var$LangSysTable = new Struct({
  reserved: new Reserved(uint16),
  reqFeatureIndex: uint16,
  featureCount: uint16,
  featureIndexes: new ArrayT(uint16, "featureCount")
});
var $7cbbe4e24ef3cb75$var$LangSysRecord = new Struct({
  tag: new StringT(4),
  langSys: new Pointer(uint16, $7cbbe4e24ef3cb75$var$LangSysTable, {
    type: "parent"
  })
});
var $7cbbe4e24ef3cb75$var$Script = new Struct({
  defaultLangSys: new Pointer(uint16, $7cbbe4e24ef3cb75$var$LangSysTable),
  count: uint16,
  langSysRecords: new ArrayT($7cbbe4e24ef3cb75$var$LangSysRecord, "count")
});
var $7cbbe4e24ef3cb75$var$ScriptRecord = new Struct({
  tag: new StringT(4),
  script: new Pointer(uint16, $7cbbe4e24ef3cb75$var$Script, {
    type: "parent"
  })
});
var $7cbbe4e24ef3cb75$export$3e15fc05ce864229 = new ArrayT($7cbbe4e24ef3cb75$var$ScriptRecord, uint16);
var $7cbbe4e24ef3cb75$var$FeatureParams = new Struct({
  version: uint16,
  nameID: uint16
});
var $7cbbe4e24ef3cb75$export$6e91cf7616333d5 = new Struct({
  featureParams: new Pointer(uint16, $7cbbe4e24ef3cb75$var$FeatureParams),
  lookupCount: uint16,
  lookupListIndexes: new ArrayT(uint16, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$FeatureRecord = new Struct({
  tag: new StringT(4),
  feature: new Pointer(uint16, $7cbbe4e24ef3cb75$export$6e91cf7616333d5, {
    type: "parent"
  })
});
var $7cbbe4e24ef3cb75$export$aa18130def4b6cb4 = new ArrayT($7cbbe4e24ef3cb75$var$FeatureRecord, uint16);
var $7cbbe4e24ef3cb75$var$LookupFlags = new Struct({
  markAttachmentType: uint8,
  flags: new Bitfield(uint8, [
    "rightToLeft",
    "ignoreBaseGlyphs",
    "ignoreLigatures",
    "ignoreMarks",
    "useMarkFilteringSet"
  ])
});
function $7cbbe4e24ef3cb75$export$df0008c6ff2da22a(SubTable) {
  let Lookup = new Struct({
    lookupType: uint16,
    flags: $7cbbe4e24ef3cb75$var$LookupFlags,
    subTableCount: uint16,
    subTables: new ArrayT(new Pointer(uint16, SubTable), "subTableCount"),
    markFilteringSet: new Optional(uint16, (t2) => t2.flags.flags.useMarkFilteringSet)
  });
  return new LazyArray(new Pointer(uint16, Lookup), uint16);
}
var $7cbbe4e24ef3cb75$var$RangeRecord = new Struct({
  start: uint16,
  end: uint16,
  startCoverageIndex: uint16
});
var $7cbbe4e24ef3cb75$export$17608c3f81a6111 = new VersionedStruct(uint16, {
  1: {
    glyphCount: uint16,
    glyphs: new ArrayT(uint16, "glyphCount")
  },
  2: {
    rangeCount: uint16,
    rangeRecords: new ArrayT($7cbbe4e24ef3cb75$var$RangeRecord, "rangeCount")
  }
});
var $7cbbe4e24ef3cb75$var$ClassRangeRecord = new Struct({
  start: uint16,
  end: uint16,
  class: uint16
});
var $7cbbe4e24ef3cb75$export$843d551fbbafef71 = new VersionedStruct(uint16, {
  1: {
    startGlyph: uint16,
    glyphCount: uint16,
    classValueArray: new ArrayT(uint16, "glyphCount")
  },
  2: {
    classRangeCount: uint16,
    classRangeRecord: new ArrayT($7cbbe4e24ef3cb75$var$ClassRangeRecord, "classRangeCount")
  }
});
var $7cbbe4e24ef3cb75$export$8215d14a63d9fb10 = new Struct({
  a: uint16,
  b: uint16,
  deltaFormat: uint16
});
var $7cbbe4e24ef3cb75$var$LookupRecord = new Struct({
  sequenceIndex: uint16,
  lookupListIndex: uint16
});
var $7cbbe4e24ef3cb75$var$Rule = new Struct({
  glyphCount: uint16,
  lookupCount: uint16,
  input: new ArrayT(uint16, (t2) => t2.glyphCount - 1),
  lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$RuleSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$Rule), uint16);
var $7cbbe4e24ef3cb75$var$ClassRule = new Struct({
  glyphCount: uint16,
  lookupCount: uint16,
  classes: new ArrayT(uint16, (t2) => t2.glyphCount - 1),
  lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$ClassSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ClassRule), uint16);
var $7cbbe4e24ef3cb75$export$841858b892ce1f4c = new VersionedStruct(uint16, {
  1: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    ruleSetCount: uint16,
    ruleSets: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$RuleSet), "ruleSetCount")
  },
  2: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    classDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    classSetCnt: uint16,
    classSet: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ClassSet), "classSetCnt")
  },
  3: {
    glyphCount: uint16,
    lookupCount: uint16,
    coverages: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "glyphCount"),
    lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
  }
});
var $7cbbe4e24ef3cb75$var$ChainRule = new Struct({
  backtrackGlyphCount: uint16,
  backtrack: new ArrayT(uint16, "backtrackGlyphCount"),
  inputGlyphCount: uint16,
  input: new ArrayT(uint16, (t2) => t2.inputGlyphCount - 1),
  lookaheadGlyphCount: uint16,
  lookahead: new ArrayT(uint16, "lookaheadGlyphCount"),
  lookupCount: uint16,
  lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
});
var $7cbbe4e24ef3cb75$var$ChainRuleSet = new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRule), uint16);
var $7cbbe4e24ef3cb75$export$5e6d09e6861162f6 = new VersionedStruct(uint16, {
  1: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    chainCount: uint16,
    chainRuleSets: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRuleSet), "chainCount")
  },
  2: {
    coverage: new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111),
    backtrackClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    inputClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    lookaheadClassDef: new Pointer(uint16, $7cbbe4e24ef3cb75$export$843d551fbbafef71),
    chainCount: uint16,
    chainClassSet: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$var$ChainRuleSet), "chainCount")
  },
  3: {
    backtrackGlyphCount: uint16,
    backtrackCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "backtrackGlyphCount"),
    inputGlyphCount: uint16,
    inputCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "inputGlyphCount"),
    lookaheadGlyphCount: uint16,
    lookaheadCoverage: new ArrayT(new Pointer(uint16, $7cbbe4e24ef3cb75$export$17608c3f81a6111), "lookaheadGlyphCount"),
    lookupCount: uint16,
    lookupRecords: new ArrayT($7cbbe4e24ef3cb75$var$LookupRecord, "lookupCount")
  }
});
var $1a47b0c45c1c22fe$var$F2DOT14 = new Fixed(16, "BE", 14);
var $1a47b0c45c1c22fe$var$RegionAxisCoordinates = new Struct({
  startCoord: $1a47b0c45c1c22fe$var$F2DOT14,
  peakCoord: $1a47b0c45c1c22fe$var$F2DOT14,
  endCoord: $1a47b0c45c1c22fe$var$F2DOT14
});
var $1a47b0c45c1c22fe$var$VariationRegionList = new Struct({
  axisCount: uint16,
  regionCount: uint16,
  variationRegions: new ArrayT(new ArrayT($1a47b0c45c1c22fe$var$RegionAxisCoordinates, "axisCount"), "regionCount")
});
var $1a47b0c45c1c22fe$var$DeltaSet = new Struct({
  shortDeltas: new ArrayT(int16, (t2) => t2.parent.shortDeltaCount),
  regionDeltas: new ArrayT(int8, (t2) => t2.parent.regionIndexCount - t2.parent.shortDeltaCount),
  deltas: (t2) => t2.shortDeltas.concat(t2.regionDeltas)
});
var $1a47b0c45c1c22fe$var$ItemVariationData = new Struct({
  itemCount: uint16,
  shortDeltaCount: uint16,
  regionIndexCount: uint16,
  regionIndexes: new ArrayT(uint16, "regionIndexCount"),
  deltaSets: new ArrayT($1a47b0c45c1c22fe$var$DeltaSet, "itemCount")
});
var $1a47b0c45c1c22fe$export$fe1b122a2710f241 = new Struct({
  format: uint16,
  variationRegionList: new Pointer(uint32, $1a47b0c45c1c22fe$var$VariationRegionList),
  variationDataCount: uint16,
  itemVariationData: new ArrayT(new Pointer(uint32, $1a47b0c45c1c22fe$var$ItemVariationData), "variationDataCount")
});
var $1a47b0c45c1c22fe$var$ConditionTable = new VersionedStruct(uint16, {
  1: {
    axisIndex: uint16,
    axisIndex: uint16,
    filterRangeMinValue: $1a47b0c45c1c22fe$var$F2DOT14,
    filterRangeMaxValue: $1a47b0c45c1c22fe$var$F2DOT14
  }
});
var $1a47b0c45c1c22fe$var$ConditionSet = new Struct({
  conditionCount: uint16,
  conditionTable: new ArrayT(new Pointer(uint32, $1a47b0c45c1c22fe$var$ConditionTable), "conditionCount")
});
var $1a47b0c45c1c22fe$var$FeatureTableSubstitutionRecord = new Struct({
  featureIndex: uint16,
  alternateFeatureTable: new Pointer(uint32, (0, $7cbbe4e24ef3cb75$export$6e91cf7616333d5), {
    type: "parent"
  })
});
var $1a47b0c45c1c22fe$var$FeatureTableSubstitution = new Struct({
  version: fixed32,
  substitutionCount: uint16,
  substitutions: new ArrayT($1a47b0c45c1c22fe$var$FeatureTableSubstitutionRecord, "substitutionCount")
});
var $1a47b0c45c1c22fe$var$FeatureVariationRecord = new Struct({
  conditionSet: new Pointer(uint32, $1a47b0c45c1c22fe$var$ConditionSet, {
    type: "parent"
  }),
  featureTableSubstitution: new Pointer(uint32, $1a47b0c45c1c22fe$var$FeatureTableSubstitution, {
    type: "parent"
  })
});
var $1a47b0c45c1c22fe$export$441b70b7971dd419 = new Struct({
  majorVersion: uint16,
  minorVersion: uint16,
  featureVariationRecordCount: uint32,
  featureVariationRecords: new ArrayT($1a47b0c45c1c22fe$var$FeatureVariationRecord, "featureVariationRecordCount")
});
var $b84fd3dd9d8eddb2$var$PredefinedOp = class {
  decode(stream2, parent, operands) {
    if (this.predefinedOps[operands[0]])
      return this.predefinedOps[operands[0]];
    return this.type.decode(stream2, parent, operands);
  }
  size(value2, ctx) {
    return this.type.size(value2, ctx);
  }
  encode(stream2, value2, ctx) {
    let index3 = this.predefinedOps.indexOf(value2);
    if (index3 !== -1)
      return index3;
    return this.type.encode(stream2, value2, ctx);
  }
  constructor(predefinedOps, type) {
    this.predefinedOps = predefinedOps;
    this.type = type;
  }
};
var $b84fd3dd9d8eddb2$var$CFFEncodingVersion = class extends NumberT {
  decode(stream2) {
    return uint8.decode(stream2) & 127;
  }
  constructor() {
    super("UInt8");
  }
};
var $b84fd3dd9d8eddb2$var$Range1 = new Struct({
  first: uint16,
  nLeft: uint8
});
var $b84fd3dd9d8eddb2$var$Range2 = new Struct({
  first: uint16,
  nLeft: uint16
});
var $b84fd3dd9d8eddb2$var$CFFCustomEncoding = new VersionedStruct(new $b84fd3dd9d8eddb2$var$CFFEncodingVersion(), {
  0: {
    nCodes: uint8,
    codes: new ArrayT(uint8, "nCodes")
  },
  1: {
    nRanges: uint8,
    ranges: new ArrayT($b84fd3dd9d8eddb2$var$Range1, "nRanges")
  }
});
var $b84fd3dd9d8eddb2$var$CFFEncoding = new $b84fd3dd9d8eddb2$var$PredefinedOp([
  (0, $bc0433d9b7e41f5f$export$dee0027060fa13bd),
  (0, $bc0433d9b7e41f5f$export$4f58f497e14a53c3)
], new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFCustomEncoding, {
  lazy: true
}));
var $b84fd3dd9d8eddb2$var$RangeArray = class extends ArrayT {
  decode(stream2, parent) {
    let length4 = (0, resolveLength)(this.length, stream2, parent);
    let count = 0;
    let res = [];
    while (count < length4) {
      let range3 = this.type.decode(stream2, parent);
      range3.offset = count;
      count += range3.nLeft + 1;
      res.push(range3);
    }
    return res;
  }
};
var $b84fd3dd9d8eddb2$var$CFFCustomCharset = new VersionedStruct(uint8, {
  0: {
    glyphs: new ArrayT(uint16, (t2) => t2.parent.CharStrings.length - 1)
  },
  1: {
    ranges: new $b84fd3dd9d8eddb2$var$RangeArray($b84fd3dd9d8eddb2$var$Range1, (t2) => t2.parent.CharStrings.length - 1)
  },
  2: {
    ranges: new $b84fd3dd9d8eddb2$var$RangeArray($b84fd3dd9d8eddb2$var$Range2, (t2) => t2.parent.CharStrings.length - 1)
  }
});
var $b84fd3dd9d8eddb2$var$CFFCharset = new $b84fd3dd9d8eddb2$var$PredefinedOp([
  (0, $ef658f5c9a1488b2$export$c33b50336c234f16),
  (0, $ef658f5c9a1488b2$export$3ed0f9e1fee8d489),
  (0, $ef658f5c9a1488b2$export$dc28be11139d4120)
], new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFCustomCharset, {
  lazy: true
}));
var $b84fd3dd9d8eddb2$var$FDRange3 = new Struct({
  first: uint16,
  fd: uint8
});
var $b84fd3dd9d8eddb2$var$FDRange4 = new Struct({
  first: uint32,
  fd: uint16
});
var $b84fd3dd9d8eddb2$var$FDSelect = new VersionedStruct(uint8, {
  0: {
    fds: new ArrayT(uint8, (t2) => t2.parent.CharStrings.length)
  },
  3: {
    nRanges: uint16,
    ranges: new ArrayT($b84fd3dd9d8eddb2$var$FDRange3, "nRanges"),
    sentinel: uint16
  },
  4: {
    nRanges: uint32,
    ranges: new ArrayT($b84fd3dd9d8eddb2$var$FDRange4, "nRanges"),
    sentinel: uint32
  }
});
var $b84fd3dd9d8eddb2$var$ptr = new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)((0, $6d59db2e29cc77b3$export$2e2bcd8739ae039));
var $b84fd3dd9d8eddb2$var$CFFPrivateOp = class {
  decode(stream2, parent, operands) {
    parent.length = operands[0];
    return $b84fd3dd9d8eddb2$var$ptr.decode(stream2, parent, [
      operands[1]
    ]);
  }
  size(dict, ctx) {
    return [
      (0, $6d59db2e29cc77b3$export$2e2bcd8739ae039).size(dict, ctx, false),
      $b84fd3dd9d8eddb2$var$ptr.size(dict, ctx)[0]
    ];
  }
  encode(stream2, dict, ctx) {
    return [
      (0, $6d59db2e29cc77b3$export$2e2bcd8739ae039).size(dict, ctx, false),
      $b84fd3dd9d8eddb2$var$ptr.encode(stream2, dict, ctx)[0]
    ];
  }
};
var $b84fd3dd9d8eddb2$var$FontDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  // key       name                   type(s)                                 default
  [
    18,
    "Private",
    new $b84fd3dd9d8eddb2$var$CFFPrivateOp(),
    null
  ],
  [
    [
      12,
      38
    ],
    "FontName",
    "sid",
    null
  ],
  [
    [
      12,
      7
    ],
    "FontMatrix",
    "array",
    [
      1e-3,
      0,
      0,
      1e-3,
      0,
      0
    ]
  ],
  [
    [
      12,
      5
    ],
    "PaintType",
    "number",
    0
  ]
]);
var $b84fd3dd9d8eddb2$var$CFFTopDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  // key       name                   type(s)                                 default
  [
    [
      12,
      30
    ],
    "ROS",
    [
      "sid",
      "sid",
      "number"
    ],
    null
  ],
  [
    0,
    "version",
    "sid",
    null
  ],
  [
    1,
    "Notice",
    "sid",
    null
  ],
  [
    [
      12,
      0
    ],
    "Copyright",
    "sid",
    null
  ],
  [
    2,
    "FullName",
    "sid",
    null
  ],
  [
    3,
    "FamilyName",
    "sid",
    null
  ],
  [
    4,
    "Weight",
    "sid",
    null
  ],
  [
    [
      12,
      1
    ],
    "isFixedPitch",
    "boolean",
    false
  ],
  [
    [
      12,
      2
    ],
    "ItalicAngle",
    "number",
    0
  ],
  [
    [
      12,
      3
    ],
    "UnderlinePosition",
    "number",
    -100
  ],
  [
    [
      12,
      4
    ],
    "UnderlineThickness",
    "number",
    50
  ],
  [
    [
      12,
      5
    ],
    "PaintType",
    "number",
    0
  ],
  [
    [
      12,
      6
    ],
    "CharstringType",
    "number",
    2
  ],
  [
    [
      12,
      7
    ],
    "FontMatrix",
    "array",
    [
      1e-3,
      0,
      0,
      1e-3,
      0,
      0
    ]
  ],
  [
    13,
    "UniqueID",
    "number",
    null
  ],
  [
    5,
    "FontBBox",
    "array",
    [
      0,
      0,
      0,
      0
    ]
  ],
  [
    [
      12,
      8
    ],
    "StrokeWidth",
    "number",
    0
  ],
  [
    14,
    "XUID",
    "array",
    null
  ],
  [
    15,
    "charset",
    $b84fd3dd9d8eddb2$var$CFFCharset,
    (0, $ef658f5c9a1488b2$export$c33b50336c234f16)
  ],
  [
    16,
    "Encoding",
    $b84fd3dd9d8eddb2$var$CFFEncoding,
    (0, $bc0433d9b7e41f5f$export$dee0027060fa13bd)
  ],
  [
    17,
    "CharStrings",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()),
    null
  ],
  [
    18,
    "Private",
    new $b84fd3dd9d8eddb2$var$CFFPrivateOp(),
    null
  ],
  [
    [
      12,
      20
    ],
    "SyntheticBase",
    "number",
    null
  ],
  [
    [
      12,
      21
    ],
    "PostScript",
    "sid",
    null
  ],
  [
    [
      12,
      22
    ],
    "BaseFontName",
    "sid",
    null
  ],
  [
    [
      12,
      23
    ],
    "BaseFontBlend",
    "delta",
    null
  ],
  // CID font specific
  [
    [
      12,
      31
    ],
    "CIDFontVersion",
    "number",
    0
  ],
  [
    [
      12,
      32
    ],
    "CIDFontRevision",
    "number",
    0
  ],
  [
    [
      12,
      33
    ],
    "CIDFontType",
    "number",
    0
  ],
  [
    [
      12,
      34
    ],
    "CIDCount",
    "number",
    8720
  ],
  [
    [
      12,
      35
    ],
    "UIDBase",
    "number",
    null
  ],
  [
    [
      12,
      37
    ],
    "FDSelect",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FDSelect),
    null
  ],
  [
    [
      12,
      36
    ],
    "FDArray",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FontDict)),
    null
  ],
  [
    [
      12,
      38
    ],
    "FontName",
    "sid",
    null
  ]
]);
var $b84fd3dd9d8eddb2$var$VariationStore = new Struct({
  length: uint16,
  itemVariationStore: (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241)
});
var $b84fd3dd9d8eddb2$var$CFF2TopDict = new (0, $61aa549f16d58b9b$export$2e2bcd8739ae039)([
  [
    [
      12,
      7
    ],
    "FontMatrix",
    "array",
    [
      1e-3,
      0,
      0,
      1e-3,
      0,
      0
    ]
  ],
  [
    17,
    "CharStrings",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()),
    null
  ],
  [
    [
      12,
      37
    ],
    "FDSelect",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FDSelect),
    null
  ],
  [
    [
      12,
      36
    ],
    "FDArray",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)(new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$FontDict)),
    null
  ],
  [
    24,
    "vstore",
    new (0, $0e34a43d05bde82c$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$VariationStore),
    null
  ],
  [
    25,
    "maxstack",
    "number",
    193
  ]
]);
var $b84fd3dd9d8eddb2$var$CFFTop = new VersionedStruct(fixed16, {
  1: {
    hdrSize: uint8,
    offSize: uint8,
    nameIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(new StringT("length")),
    topDictIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)($b84fd3dd9d8eddb2$var$CFFTopDict),
    stringIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)(new StringT("length")),
    globalSubrIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()
  },
  2: {
    hdrSize: uint8,
    length: uint16,
    topDict: $b84fd3dd9d8eddb2$var$CFF2TopDict,
    globalSubrIndex: new (0, $43e9821ef3717eec$export$2e2bcd8739ae039)()
  }
});
var $b84fd3dd9d8eddb2$export$2e2bcd8739ae039 = $b84fd3dd9d8eddb2$var$CFFTop;
var $822ac0d589e4e237$var$CFFFont = class _$822ac0d589e4e237$var$CFFFont {
  static decode(stream2) {
    return new _$822ac0d589e4e237$var$CFFFont(stream2);
  }
  decode() {
    let start3 = this.stream.pos;
    let top = (0, $b84fd3dd9d8eddb2$export$2e2bcd8739ae039).decode(this.stream);
    for (let key in top) {
      let val = top[key];
      this[key] = val;
    }
    if (this.version < 2) {
      if (this.topDictIndex.length !== 1)
        throw new Error("Only a single font is allowed in CFF");
      this.topDict = this.topDictIndex[0];
    }
    this.isCIDFont = this.topDict.ROS != null;
    return this;
  }
  string(sid) {
    if (this.version >= 2)
      return null;
    if (sid < (0, $229224aec43783c5$export$2e2bcd8739ae039).length)
      return (0, $229224aec43783c5$export$2e2bcd8739ae039)[sid];
    return this.stringIndex[sid - (0, $229224aec43783c5$export$2e2bcd8739ae039).length];
  }
  get postscriptName() {
    if (this.version < 2)
      return this.nameIndex[0];
    return null;
  }
  get fullName() {
    return this.string(this.topDict.FullName);
  }
  get familyName() {
    return this.string(this.topDict.FamilyName);
  }
  getCharString(glyph) {
    this.stream.pos = this.topDict.CharStrings[glyph].offset;
    return this.stream.readBuffer(this.topDict.CharStrings[glyph].length);
  }
  getGlyphName(gid) {
    if (this.version >= 2)
      return null;
    if (this.isCIDFont)
      return null;
    let { charset } = this.topDict;
    if (Array.isArray(charset))
      return charset[gid];
    if (gid === 0)
      return ".notdef";
    gid -= 1;
    switch (charset.version) {
      case 0:
        return this.string(charset.glyphs[gid]);
      case 1:
      case 2:
        for (let i = 0; i < charset.ranges.length; i++) {
          let range3 = charset.ranges[i];
          if (range3.offset <= gid && gid <= range3.offset + range3.nLeft)
            return this.string(range3.first + (gid - range3.offset));
        }
        break;
    }
    return null;
  }
  fdForGlyph(gid) {
    if (!this.topDict.FDSelect)
      return null;
    switch (this.topDict.FDSelect.version) {
      case 0:
        return this.topDict.FDSelect.fds[gid];
      case 3:
      case 4:
        let { ranges } = this.topDict.FDSelect;
        let low = 0;
        let high = ranges.length - 1;
        while (low <= high) {
          let mid = low + high >> 1;
          if (gid < ranges[mid].first)
            high = mid - 1;
          else if (mid < high && gid >= ranges[mid + 1].first)
            low = mid + 1;
          else
            return ranges[mid].fd;
        }
      default:
        throw new Error(`Unknown FDSelect version: ${this.topDict.FDSelect.version}`);
    }
  }
  privateDictForGlyph(gid) {
    if (this.topDict.FDSelect) {
      let fd = this.fdForGlyph(gid);
      if (this.topDict.FDArray[fd])
        return this.topDict.FDArray[fd].Private;
      return null;
    }
    if (this.version < 2)
      return this.topDict.Private;
    return this.topDict.FDArray[0].Private;
  }
  constructor(stream2) {
    this.stream = stream2;
    this.decode();
  }
};
var $822ac0d589e4e237$export$2e2bcd8739ae039 = $822ac0d589e4e237$var$CFFFont;
var $2bbf2bc1ce37cd8f$var$VerticalOrigin = new Struct({
  glyphIndex: uint16,
  vertOriginY: int16
});
var $2bbf2bc1ce37cd8f$export$2e2bcd8739ae039 = new Struct({
  majorVersion: uint16,
  minorVersion: uint16,
  defaultVertOriginY: int16,
  numVertOriginYMetrics: uint16,
  metrics: new ArrayT($2bbf2bc1ce37cd8f$var$VerticalOrigin, "numVertOriginYMetrics")
});
var $0941618dc22a946d$export$16b227cb15d716a0 = new Struct({
  height: uint8,
  width: uint8,
  horiBearingX: int8,
  horiBearingY: int8,
  horiAdvance: uint8,
  vertBearingX: int8,
  vertBearingY: int8,
  vertAdvance: uint8
});
var $0941618dc22a946d$export$62c53e75f69bfe12 = new Struct({
  height: uint8,
  width: uint8,
  bearingX: int8,
  bearingY: int8,
  advance: uint8
});
var $0941618dc22a946d$var$EBDTComponent = new Struct({
  glyph: uint16,
  xOffset: int8,
  yOffset: int8
});
var $0941618dc22a946d$var$ByteAligned = class {
};
var $0941618dc22a946d$var$BitAligned = class {
};
var $0941618dc22a946d$export$f1f5ddeb20d14f = new VersionedStruct("version", {
  1: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    data: $0941618dc22a946d$var$ByteAligned
  },
  2: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    data: $0941618dc22a946d$var$BitAligned
  },
  // format 3 is deprecated
  // format 4 is not supported by Microsoft
  5: {
    data: $0941618dc22a946d$var$BitAligned
  },
  6: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    data: $0941618dc22a946d$var$ByteAligned
  },
  7: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    data: $0941618dc22a946d$var$BitAligned
  },
  8: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    pad: new Reserved(uint8),
    numComponents: uint16,
    components: new ArrayT($0941618dc22a946d$var$EBDTComponent, "numComponents")
  },
  9: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    pad: new Reserved(uint8),
    numComponents: uint16,
    components: new ArrayT($0941618dc22a946d$var$EBDTComponent, "numComponents")
  },
  17: {
    metrics: $0941618dc22a946d$export$62c53e75f69bfe12,
    dataLen: uint32,
    data: new BufferT("dataLen")
  },
  18: {
    metrics: $0941618dc22a946d$export$16b227cb15d716a0,
    dataLen: uint32,
    data: new BufferT("dataLen")
  },
  19: {
    dataLen: uint32,
    data: new BufferT("dataLen")
  }
});
var $9911c4c7201c13de$var$SBitLineMetrics = new Struct({
  ascender: int8,
  descender: int8,
  widthMax: uint8,
  caretSlopeNumerator: int8,
  caretSlopeDenominator: int8,
  caretOffset: int8,
  minOriginSB: int8,
  minAdvanceSB: int8,
  maxBeforeBL: int8,
  minAfterBL: int8,
  pad: new Reserved(int8, 2)
});
var $9911c4c7201c13de$var$CodeOffsetPair = new Struct({
  glyphCode: uint16,
  offset: uint16
});
var $9911c4c7201c13de$var$IndexSubtable = new VersionedStruct(uint16, {
  header: {
    imageFormat: uint16,
    imageDataOffset: uint32
  },
  1: {
    offsetArray: new ArrayT(uint32, (t2) => t2.parent.lastGlyphIndex - t2.parent.firstGlyphIndex + 1)
  },
  2: {
    imageSize: uint32,
    bigMetrics: (0, $0941618dc22a946d$export$16b227cb15d716a0)
  },
  3: {
    offsetArray: new ArrayT(uint16, (t2) => t2.parent.lastGlyphIndex - t2.parent.firstGlyphIndex + 1)
  },
  4: {
    numGlyphs: uint32,
    glyphArray: new ArrayT($9911c4c7201c13de$var$CodeOffsetPair, (t2) => t2.numGlyphs + 1)
  },
  5: {
    imageSize: uint32,
    bigMetrics: (0, $0941618dc22a946d$export$16b227cb15d716a0),
    numGlyphs: uint32,
    glyphCodeArray: new ArrayT(uint16, "numGlyphs")
  }
});
var $9911c4c7201c13de$var$IndexSubtableArray = new Struct({
  firstGlyphIndex: uint16,
  lastGlyphIndex: uint16,
  subtable: new Pointer(uint32, $9911c4c7201c13de$var$IndexSubtable)
});
var $9911c4c7201c13de$var$BitmapSizeTable = new Struct({
  indexSubTableArray: new Pointer(uint32, new ArrayT($9911c4c7201c13de$var$IndexSubtableArray, 1), {
    type: "parent"
  }),
  indexTablesSize: uint32,
  numberOfIndexSubTables: uint32,
  colorRef: uint32,
  hori: $9911c4c7201c13de$var$SBitLineMetrics,
  vert: $9911c4c7201c13de$var$SBitLineMetrics,
  startGlyphIndex: uint16,
  endGlyphIndex: uint16,
  ppemX: uint8,
  ppemY: uint8,
  bitDepth: uint8,
  flags: new Bitfield(uint8, [
    "horizontal",
    "vertical"
  ])
});
var $9911c4c7201c13de$export$2e2bcd8739ae039 = new Struct({
  version: uint32,
  numSizes: uint32,
  sizes: new ArrayT($9911c4c7201c13de$var$BitmapSizeTable, "numSizes")
});
var $abb847051efd51b1$var$ImageTable = new Struct({
  ppem: uint16,
  resolution: uint16,
  imageOffsets: new ArrayT(new Pointer(uint32, "void"), (t2) => t2.parent.parent.maxp.numGlyphs + 1)
});
var $abb847051efd51b1$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  flags: new Bitfield(uint16, [
    "renderOutlines"
  ]),
  numImgTables: uint32,
  imageTables: new ArrayT(new Pointer(uint32, $abb847051efd51b1$var$ImageTable), "numImgTables")
});
var $eb629188f3dfefdd$var$LayerRecord = new Struct({
  gid: uint16,
  paletteIndex: uint16
  // Index value to use in the appropriate palette. This value must
});
var $eb629188f3dfefdd$var$BaseGlyphRecord = new Struct({
  gid: uint16,
  // and is not rendered for color.
  firstLayerIndex: uint16,
  // There will be numLayers consecutive entries for this base glyph.
  numLayers: uint16
});
var $eb629188f3dfefdd$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numBaseGlyphRecords: uint16,
  baseGlyphRecord: new Pointer(uint32, new ArrayT($eb629188f3dfefdd$var$BaseGlyphRecord, "numBaseGlyphRecords")),
  layerRecords: new Pointer(uint32, new ArrayT($eb629188f3dfefdd$var$LayerRecord, "numLayerRecords"), {
    lazy: true
  }),
  numLayerRecords: uint16
});
var $08734b8e7dc64587$var$ColorRecord = new Struct({
  blue: uint8,
  green: uint8,
  red: uint8,
  alpha: uint8
});
var $08734b8e7dc64587$export$2e2bcd8739ae039 = new VersionedStruct(uint16, {
  header: {
    numPaletteEntries: uint16,
    numPalettes: uint16,
    numColorRecords: uint16,
    colorRecords: new Pointer(uint32, new ArrayT($08734b8e7dc64587$var$ColorRecord, "numColorRecords")),
    colorRecordIndices: new ArrayT(uint16, "numPalettes")
  },
  0: {},
  1: {
    offsetPaletteTypeArray: new Pointer(uint32, new ArrayT(uint32, "numPalettes")),
    offsetPaletteLabelArray: new Pointer(uint32, new ArrayT(uint16, "numPalettes")),
    offsetPaletteEntryLabelArray: new Pointer(uint32, new ArrayT(uint16, "numPaletteEntries"))
  }
});
var $497cef411d884e34$var$BaseCoord = new VersionedStruct(uint16, {
  1: {
    coordinate: int16
    // X or Y value, in design units
  },
  2: {
    coordinate: int16,
    referenceGlyph: uint16,
    baseCoordPoint: uint16
    // Index of contour point on the referenceGlyph
  },
  3: {
    coordinate: int16,
    deviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))
    // Device table for X or Y value
  }
});
var $497cef411d884e34$var$BaseValues = new Struct({
  defaultIndex: uint16,
  baseCoordCount: uint16,
  baseCoords: new ArrayT(new Pointer(uint16, $497cef411d884e34$var$BaseCoord), "baseCoordCount")
});
var $497cef411d884e34$var$FeatMinMaxRecord = new Struct({
  tag: new StringT(4),
  minCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord, {
    type: "parent"
  }),
  maxCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord, {
    type: "parent"
  })
  // May be NULL
});
var $497cef411d884e34$var$MinMax = new Struct({
  minCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord),
  maxCoord: new Pointer(uint16, $497cef411d884e34$var$BaseCoord),
  featMinMaxCount: uint16,
  featMinMaxRecords: new ArrayT($497cef411d884e34$var$FeatMinMaxRecord, "featMinMaxCount")
  // In alphabetical order
});
var $497cef411d884e34$var$BaseLangSysRecord = new Struct({
  tag: new StringT(4),
  minMax: new Pointer(uint16, $497cef411d884e34$var$MinMax, {
    type: "parent"
  })
});
var $497cef411d884e34$var$BaseScript = new Struct({
  baseValues: new Pointer(uint16, $497cef411d884e34$var$BaseValues),
  defaultMinMax: new Pointer(uint16, $497cef411d884e34$var$MinMax),
  baseLangSysCount: uint16,
  baseLangSysRecords: new ArrayT($497cef411d884e34$var$BaseLangSysRecord, "baseLangSysCount")
  // in alphabetical order by BaseLangSysTag
});
var $497cef411d884e34$var$BaseScriptRecord = new Struct({
  tag: new StringT(4),
  script: new Pointer(uint16, $497cef411d884e34$var$BaseScript, {
    type: "parent"
  })
});
var $497cef411d884e34$var$BaseScriptList = new ArrayT($497cef411d884e34$var$BaseScriptRecord, uint16);
var $497cef411d884e34$var$BaseTagList = new ArrayT(new StringT(4), uint16);
var $497cef411d884e34$var$Axis = new Struct({
  baseTagList: new Pointer(uint16, $497cef411d884e34$var$BaseTagList),
  baseScriptList: new Pointer(uint16, $497cef411d884e34$var$BaseScriptList)
});
var $497cef411d884e34$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    horizAxis: new Pointer(uint16, $497cef411d884e34$var$Axis),
    vertAxis: new Pointer(uint16, $497cef411d884e34$var$Axis)
    // May be NULL
  },
  65536: {},
  65537: {
    itemVariationStore: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241))
  }
});
var $cf5f33c63ef209e6$var$AttachPoint = new ArrayT(uint16, uint16);
var $cf5f33c63ef209e6$var$AttachList = new Struct({
  coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
  glyphCount: uint16,
  attachPoints: new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$AttachPoint), "glyphCount")
});
var $cf5f33c63ef209e6$var$CaretValue = new VersionedStruct(uint16, {
  1: {
    coordinate: int16
  },
  2: {
    caretValuePoint: uint16
  },
  3: {
    coordinate: int16,
    deviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))
  }
});
var $cf5f33c63ef209e6$var$LigGlyph = new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$CaretValue), uint16);
var $cf5f33c63ef209e6$var$LigCaretList = new Struct({
  coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
  ligGlyphCount: uint16,
  ligGlyphs: new ArrayT(new Pointer(uint16, $cf5f33c63ef209e6$var$LigGlyph), "ligGlyphCount")
});
var $cf5f33c63ef209e6$var$MarkGlyphSetsDef = new Struct({
  markSetTableFormat: uint16,
  markSetCount: uint16,
  coverage: new ArrayT(new Pointer(uint32, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), "markSetCount")
});
var $cf5f33c63ef209e6$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    glyphClassDef: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),
    attachList: new Pointer(uint16, $cf5f33c63ef209e6$var$AttachList),
    ligCaretList: new Pointer(uint16, $cf5f33c63ef209e6$var$LigCaretList),
    markAttachClassDef: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71))
  },
  65536: {},
  65538: {
    markGlyphSetsDef: new Pointer(uint16, $cf5f33c63ef209e6$var$MarkGlyphSetsDef)
  },
  65539: {
    markGlyphSetsDef: new Pointer(uint16, $cf5f33c63ef209e6$var$MarkGlyphSetsDef),
    itemVariationStore: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241))
  }
});
var $47e0e8ef515d9903$var$ValueFormat = new Bitfield(uint16, [
  "xPlacement",
  "yPlacement",
  "xAdvance",
  "yAdvance",
  "xPlaDevice",
  "yPlaDevice",
  "xAdvDevice",
  "yAdvDevice"
]);
var $47e0e8ef515d9903$var$types = {
  xPlacement: int16,
  yPlacement: int16,
  xAdvance: int16,
  yAdvance: int16,
  xPlaDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: (ctx) => ctx.rel
  }),
  yPlaDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: (ctx) => ctx.rel
  }),
  xAdvDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: (ctx) => ctx.rel
  }),
  yAdvDevice: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10), {
    type: "global",
    relativeTo: (ctx) => ctx.rel
  })
};
var $47e0e8ef515d9903$var$ValueRecord = class {
  buildStruct(parent) {
    let struct = parent;
    while (!struct[this.key] && struct.parent)
      struct = struct.parent;
    if (!struct[this.key])
      return;
    let fields = {};
    fields.rel = () => struct._startOffset;
    let format = struct[this.key];
    for (let key in format)
      if (format[key])
        fields[key] = $47e0e8ef515d9903$var$types[key];
    return new Struct(fields);
  }
  size(val, ctx) {
    return this.buildStruct(ctx).size(val, ctx);
  }
  decode(stream2, parent) {
    let res = this.buildStruct(parent).decode(stream2, parent);
    delete res.rel;
    return res;
  }
  constructor(key = "valueFormat") {
    this.key = key;
  }
};
var $47e0e8ef515d9903$var$PairValueRecord = new Struct({
  secondGlyph: uint16,
  value1: new $47e0e8ef515d9903$var$ValueRecord("valueFormat1"),
  value2: new $47e0e8ef515d9903$var$ValueRecord("valueFormat2")
});
var $47e0e8ef515d9903$var$PairSet = new ArrayT($47e0e8ef515d9903$var$PairValueRecord, uint16);
var $47e0e8ef515d9903$var$Class2Record = new Struct({
  value1: new $47e0e8ef515d9903$var$ValueRecord("valueFormat1"),
  value2: new $47e0e8ef515d9903$var$ValueRecord("valueFormat2")
});
var $47e0e8ef515d9903$var$Anchor = new VersionedStruct(uint16, {
  1: {
    xCoordinate: int16,
    yCoordinate: int16
  },
  2: {
    xCoordinate: int16,
    yCoordinate: int16,
    anchorPoint: uint16
  },
  3: {
    xCoordinate: int16,
    yCoordinate: int16,
    xDeviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10)),
    yDeviceTable: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$8215d14a63d9fb10))
  }
});
var $47e0e8ef515d9903$var$EntryExitRecord = new Struct({
  entryAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
    type: "parent"
  }),
  exitAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
    type: "parent"
  })
});
var $47e0e8ef515d9903$var$MarkRecord = new Struct({
  class: uint16,
  markAnchor: new Pointer(uint16, $47e0e8ef515d9903$var$Anchor, {
    type: "parent"
  })
});
var $47e0e8ef515d9903$var$MarkArray = new ArrayT($47e0e8ef515d9903$var$MarkRecord, uint16);
var $47e0e8ef515d9903$var$BaseRecord = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$Anchor), (t2) => t2.parent.classCount);
var $47e0e8ef515d9903$var$BaseArray = new ArrayT($47e0e8ef515d9903$var$BaseRecord, uint16);
var $47e0e8ef515d9903$var$ComponentRecord = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$Anchor), (t2) => t2.parent.parent.classCount);
var $47e0e8ef515d9903$var$LigatureAttach = new ArrayT($47e0e8ef515d9903$var$ComponentRecord, uint16);
var $47e0e8ef515d9903$var$LigatureArray = new ArrayT(new Pointer(uint16, $47e0e8ef515d9903$var$LigatureAttach), uint16);
var $47e0e8ef515d9903$export$73a8cfb19cd43a0f = new VersionedStruct("lookupType", {
  1: new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat: $47e0e8ef515d9903$var$ValueFormat,
      value: new $47e0e8ef515d9903$var$ValueRecord()
    },
    2: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat: $47e0e8ef515d9903$var$ValueFormat,
      valueCount: uint16,
      values: new LazyArray(new $47e0e8ef515d9903$var$ValueRecord(), "valueCount")
    }
  }),
  2: new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat1: $47e0e8ef515d9903$var$ValueFormat,
      valueFormat2: $47e0e8ef515d9903$var$ValueFormat,
      pairSetCount: uint16,
      pairSets: new LazyArray(new Pointer(uint16, $47e0e8ef515d9903$var$PairSet), "pairSetCount")
    },
    2: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      valueFormat1: $47e0e8ef515d9903$var$ValueFormat,
      valueFormat2: $47e0e8ef515d9903$var$ValueFormat,
      classDef1: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),
      classDef2: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$843d551fbbafef71)),
      class1Count: uint16,
      class2Count: uint16,
      classRecords: new LazyArray(new LazyArray($47e0e8ef515d9903$var$Class2Record, "class2Count"), "class1Count")
    }
  }),
  3: {
    format: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    entryExitCount: uint16,
    entryExitRecords: new ArrayT($47e0e8ef515d9903$var$EntryExitRecord, "entryExitCount")
  },
  4: {
    format: uint16,
    markCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    baseCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    classCount: uint16,
    markArray: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
    baseArray: new Pointer(uint16, $47e0e8ef515d9903$var$BaseArray)
  },
  5: {
    format: uint16,
    markCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    ligatureCoverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    classCount: uint16,
    markArray: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
    ligatureArray: new Pointer(uint16, $47e0e8ef515d9903$var$LigatureArray)
  },
  6: {
    format: uint16,
    mark1Coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    mark2Coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    classCount: uint16,
    mark1Array: new Pointer(uint16, $47e0e8ef515d9903$var$MarkArray),
    mark2Array: new Pointer(uint16, $47e0e8ef515d9903$var$BaseArray)
  },
  7: (0, $7cbbe4e24ef3cb75$export$841858b892ce1f4c),
  8: (0, $7cbbe4e24ef3cb75$export$5e6d09e6861162f6),
  9: {
    posFormat: uint16,
    lookupType: uint16,
    extension: new Pointer(uint32, null)
  }
});
$47e0e8ef515d9903$export$73a8cfb19cd43a0f.versions[9].extension.type = $47e0e8ef515d9903$export$73a8cfb19cd43a0f;
var $47e0e8ef515d9903$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    scriptList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$3e15fc05ce864229)),
    featureList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$aa18130def4b6cb4)),
    lookupList: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)($47e0e8ef515d9903$export$73a8cfb19cd43a0f))
  },
  65536: {},
  65537: {
    featureVariations: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$441b70b7971dd419))
  }
});
var $d3f442064af66e06$var$Sequence = new ArrayT(uint16, uint16);
var $d3f442064af66e06$var$AlternateSet = $d3f442064af66e06$var$Sequence;
var $d3f442064af66e06$var$Ligature = new Struct({
  glyph: uint16,
  compCount: uint16,
  components: new ArrayT(uint16, (t2) => t2.compCount - 1)
});
var $d3f442064af66e06$var$LigatureSet = new ArrayT(new Pointer(uint16, $d3f442064af66e06$var$Ligature), uint16);
var $d3f442064af66e06$var$GSUBLookup = new VersionedStruct("lookupType", {
  1: new VersionedStruct(uint16, {
    1: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      deltaGlyphID: int16
    },
    2: {
      coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
      glyphCount: uint16,
      substitute: new LazyArray(uint16, "glyphCount")
    }
  }),
  2: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    count: uint16,
    sequences: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$Sequence), "count")
  },
  3: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    count: uint16,
    alternateSet: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$AlternateSet), "count")
  },
  4: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    count: uint16,
    ligatureSets: new LazyArray(new Pointer(uint16, $d3f442064af66e06$var$LigatureSet), "count")
  },
  5: (0, $7cbbe4e24ef3cb75$export$841858b892ce1f4c),
  6: (0, $7cbbe4e24ef3cb75$export$5e6d09e6861162f6),
  7: {
    substFormat: uint16,
    lookupType: uint16,
    extension: new Pointer(uint32, null)
  },
  8: {
    substFormat: uint16,
    coverage: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)),
    backtrackCoverage: new ArrayT(new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), "backtrackGlyphCount"),
    lookaheadGlyphCount: uint16,
    lookaheadCoverage: new ArrayT(new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$17608c3f81a6111)), "lookaheadGlyphCount"),
    glyphCount: uint16,
    substitutes: new ArrayT(uint16, "glyphCount")
  }
});
$d3f442064af66e06$var$GSUBLookup.versions[7].extension.type = $d3f442064af66e06$var$GSUBLookup;
var $d3f442064af66e06$export$2e2bcd8739ae039 = new VersionedStruct(uint32, {
  header: {
    scriptList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$3e15fc05ce864229)),
    featureList: new Pointer(uint16, (0, $7cbbe4e24ef3cb75$export$aa18130def4b6cb4)),
    lookupList: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)($d3f442064af66e06$var$GSUBLookup))
  },
  65536: {},
  65537: {
    featureVariations: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$441b70b7971dd419))
  }
});
var $71cfb3c4767fbd0c$var$JstfGSUBModList = new ArrayT(uint16, uint16);
var $71cfb3c4767fbd0c$var$JstfPriority = new Struct({
  shrinkageEnableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageDisableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageEnableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageDisableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  shrinkageJstfMax: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)((0, $47e0e8ef515d9903$export$73a8cfb19cd43a0f))),
  extensionEnableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionDisableGSUB: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionEnableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionDisableGPOS: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfGSUBModList),
  extensionJstfMax: new Pointer(uint16, new (0, $7cbbe4e24ef3cb75$export$df0008c6ff2da22a)((0, $47e0e8ef515d9903$export$73a8cfb19cd43a0f)))
});
var $71cfb3c4767fbd0c$var$JstfLangSys = new ArrayT(new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfPriority), uint16);
var $71cfb3c4767fbd0c$var$JstfLangSysRecord = new Struct({
  tag: new StringT(4),
  jstfLangSys: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfLangSys)
});
var $71cfb3c4767fbd0c$var$JstfScript = new Struct({
  extenderGlyphs: new Pointer(uint16, new ArrayT(uint16, uint16)),
  defaultLangSys: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfLangSys),
  langSysCount: uint16,
  langSysRecords: new ArrayT($71cfb3c4767fbd0c$var$JstfLangSysRecord, "langSysCount")
});
var $71cfb3c4767fbd0c$var$JstfScriptRecord = new Struct({
  tag: new StringT(4),
  script: new Pointer(uint16, $71cfb3c4767fbd0c$var$JstfScript, {
    type: "parent"
  })
});
var $71cfb3c4767fbd0c$export$2e2bcd8739ae039 = new Struct({
  version: uint32,
  scriptCount: uint16,
  scriptList: new ArrayT($71cfb3c4767fbd0c$var$JstfScriptRecord, "scriptCount")
});
var $d059a6bd2d3b5b63$var$VariableSizeNumber = class {
  decode(stream2, parent) {
    switch (this.size(0, parent)) {
      case 1:
        return stream2.readUInt8();
      case 2:
        return stream2.readUInt16BE();
      case 3:
        return stream2.readUInt24BE();
      case 4:
        return stream2.readUInt32BE();
    }
  }
  size(val, parent) {
    return (0, resolveLength)(this._size, null, parent);
  }
  constructor(size) {
    this._size = size;
  }
};
var $d059a6bd2d3b5b63$var$MapDataEntry = new Struct({
  entry: new $d059a6bd2d3b5b63$var$VariableSizeNumber((t2) => ((t2.parent.entryFormat & 48) >> 4) + 1),
  outerIndex: (t2) => t2.entry >> (t2.parent.entryFormat & 15) + 1,
  innerIndex: (t2) => t2.entry & (1 << (t2.parent.entryFormat & 15) + 1) - 1
});
var $d059a6bd2d3b5b63$var$DeltaSetIndexMap = new Struct({
  entryFormat: uint16,
  mapCount: uint16,
  mapData: new ArrayT($d059a6bd2d3b5b63$var$MapDataEntry, "mapCount")
});
var $d059a6bd2d3b5b63$export$2e2bcd8739ae039 = new Struct({
  majorVersion: uint16,
  minorVersion: uint16,
  itemVariationStore: new Pointer(uint32, (0, $1a47b0c45c1c22fe$export$fe1b122a2710f241)),
  advanceWidthMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap),
  LSBMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap),
  RSBMapping: new Pointer(uint32, $d059a6bd2d3b5b63$var$DeltaSetIndexMap)
});
var $dceeca3e1977ce30$var$Signature = new Struct({
  format: uint32,
  length: uint32,
  offset: uint32
});
var $dceeca3e1977ce30$var$SignatureBlock = new Struct({
  reserved: new Reserved(uint16, 2),
  cbSignature: uint32,
  signature: new BufferT("cbSignature")
});
var $dceeca3e1977ce30$export$2e2bcd8739ae039 = new Struct({
  ulVersion: uint32,
  usNumSigs: uint16,
  usFlag: uint16,
  signatures: new ArrayT($dceeca3e1977ce30$var$Signature, "usNumSigs"),
  signatureBlocks: new ArrayT($dceeca3e1977ce30$var$SignatureBlock, "usNumSigs")
});
var $8acd740a9435aad0$var$GaspRange = new Struct({
  rangeMaxPPEM: uint16,
  rangeGaspBehavior: new Bitfield(uint16, [
    "grayscale",
    "gridfit",
    "symmetricSmoothing",
    "symmetricGridfit"
    // only in version 1, for ClearType
  ])
});
var $8acd740a9435aad0$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numRanges: uint16,
  gaspRanges: new ArrayT($8acd740a9435aad0$var$GaspRange, "numRanges")
  // Sorted by ppem
});
var $b5f380243c34d6a0$var$DeviceRecord = new Struct({
  pixelSize: uint8,
  maximumWidth: uint8,
  widths: new ArrayT(uint8, (t2) => t2.parent.parent.maxp.numGlyphs)
});
var $b5f380243c34d6a0$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numRecords: int16,
  sizeDeviceRecord: int32,
  records: new ArrayT($b5f380243c34d6a0$var$DeviceRecord, "numRecords")
});
var $ca2df1256966e313$var$KernPair = new Struct({
  left: uint16,
  right: uint16,
  value: int16
});
var $ca2df1256966e313$var$ClassTable = new Struct({
  firstGlyph: uint16,
  nGlyphs: uint16,
  offsets: new ArrayT(uint16, "nGlyphs"),
  max: (t2) => t2.offsets.length && Math.max.apply(Math, t2.offsets)
});
var $ca2df1256966e313$var$Kern2Array = new Struct({
  off: (t2) => t2._startOffset - t2.parent.parent._startOffset,
  len: (t2) => ((t2.parent.leftTable.max - t2.off) / t2.parent.rowWidth + 1) * (t2.parent.rowWidth / 2),
  values: new LazyArray(int16, "len")
});
var $ca2df1256966e313$var$KernSubtable = new VersionedStruct("format", {
  0: {
    nPairs: uint16,
    searchRange: uint16,
    entrySelector: uint16,
    rangeShift: uint16,
    pairs: new ArrayT($ca2df1256966e313$var$KernPair, "nPairs")
  },
  2: {
    rowWidth: uint16,
    leftTable: new Pointer(uint16, $ca2df1256966e313$var$ClassTable, {
      type: "parent"
    }),
    rightTable: new Pointer(uint16, $ca2df1256966e313$var$ClassTable, {
      type: "parent"
    }),
    array: new Pointer(uint16, $ca2df1256966e313$var$Kern2Array, {
      type: "parent"
    })
  },
  3: {
    glyphCount: uint16,
    kernValueCount: uint8,
    leftClassCount: uint8,
    rightClassCount: uint8,
    flags: uint8,
    kernValue: new ArrayT(int16, "kernValueCount"),
    leftClass: new ArrayT(uint8, "glyphCount"),
    rightClass: new ArrayT(uint8, "glyphCount"),
    kernIndex: new ArrayT(uint8, (t2) => t2.leftClassCount * t2.rightClassCount)
  }
});
var $ca2df1256966e313$var$KernTable = new VersionedStruct("version", {
  0: {
    subVersion: uint16,
    length: uint16,
    format: uint8,
    coverage: new Bitfield(uint8, [
      "horizontal",
      "minimum",
      "crossStream",
      "override"
      // If set to 1 the value in this table replaces the accumulated value
    ]),
    subtable: $ca2df1256966e313$var$KernSubtable,
    padding: new Reserved(uint8, (t2) => t2.length - t2._currentOffset)
  },
  1: {
    length: uint32,
    coverage: new Bitfield(uint8, [
      null,
      null,
      null,
      null,
      null,
      "variation",
      "crossStream",
      "vertical"
      // Set if table has vertical kerning values
    ]),
    format: uint8,
    tupleIndex: uint16,
    subtable: $ca2df1256966e313$var$KernSubtable,
    padding: new Reserved(uint8, (t2) => t2.length - t2._currentOffset)
  }
});
var $ca2df1256966e313$export$2e2bcd8739ae039 = new VersionedStruct(uint16, {
  0: {
    nTables: uint16,
    tables: new ArrayT($ca2df1256966e313$var$KernTable, "nTables")
  },
  1: {
    reserved: new Reserved(uint16),
    nTables: uint32,
    tables: new ArrayT($ca2df1256966e313$var$KernTable, "nTables")
  }
});
var $7a9f92b0c46ebe33$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numGlyphs: uint16,
  yPels: new ArrayT(uint8, "numGlyphs")
});
var $2b2ccc419d152631$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  fontNumber: uint32,
  pitch: uint16,
  xHeight: uint16,
  style: uint16,
  typeFamily: uint16,
  capHeight: uint16,
  symbolSet: uint16,
  typeface: new StringT(16),
  characterComplement: new StringT(8),
  fileName: new StringT(6),
  strokeWeight: new StringT(1),
  widthType: new StringT(1),
  serifStyle: uint8,
  reserved: new Reserved(uint8)
});
var $ca5b40b9bcda9c9b$var$Ratio = new Struct({
  bCharSet: uint8,
  xRatio: uint8,
  yStartRatio: uint8,
  yEndRatio: uint8
  // Ending y-Ratio value
});
var $ca5b40b9bcda9c9b$var$vTable = new Struct({
  yPelHeight: uint16,
  yMax: int16,
  yMin: int16
  // Minimum value (in pels) for this yPelHeight
});
var $ca5b40b9bcda9c9b$var$VdmxGroup = new Struct({
  recs: uint16,
  startsz: uint8,
  endsz: uint8,
  entries: new ArrayT($ca5b40b9bcda9c9b$var$vTable, "recs")
  // The VDMX records
});
var $ca5b40b9bcda9c9b$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  numRecs: uint16,
  numRatios: uint16,
  ratioRanges: new ArrayT($ca5b40b9bcda9c9b$var$Ratio, "numRatios"),
  offsets: new ArrayT(uint16, "numRatios"),
  groups: new ArrayT($ca5b40b9bcda9c9b$var$VdmxGroup, "numRecs")
  // The actual VDMX groupings
});
var $69530a3c40755af0$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  ascent: int16,
  descent: int16,
  lineGap: int16,
  advanceHeightMax: int16,
  minTopSideBearing: int16,
  minBottomSideBearing: int16,
  yMaxExtent: int16,
  caretSlopeRise: int16,
  caretSlopeRun: int16,
  caretOffset: int16,
  reserved: new Reserved(int16, 4),
  metricDataFormat: int16,
  numberOfMetrics: uint16
  // Number of advance heights in the Vertical Metrics table
});
var $344073dd270f0e62$var$VmtxEntry = new Struct({
  advance: uint16,
  bearing: int16
  // The top sidebearing of the glyph
});
var $344073dd270f0e62$export$2e2bcd8739ae039 = new Struct({
  metrics: new LazyArray($344073dd270f0e62$var$VmtxEntry, (t2) => t2.parent.vhea.numberOfMetrics),
  bearings: new LazyArray(int16, (t2) => t2.parent.maxp.numGlyphs - t2.parent.vhea.numberOfMetrics)
});
var $3793b781918cfced$var$shortFrac = new Fixed(16, "BE", 14);
var $3793b781918cfced$var$Correspondence = new Struct({
  fromCoord: $3793b781918cfced$var$shortFrac,
  toCoord: $3793b781918cfced$var$shortFrac
});
var $3793b781918cfced$var$Segment = new Struct({
  pairCount: uint16,
  correspondence: new ArrayT($3793b781918cfced$var$Correspondence, "pairCount")
});
var $3793b781918cfced$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  axisCount: uint32,
  segment: new ArrayT($3793b781918cfced$var$Segment, "axisCount")
});
var $6cb7dd5f47d82580$var$UnboundedArrayAccessor = class {
  getItem(index3) {
    if (this._items[index3] == null) {
      let pos = this.stream.pos;
      this.stream.pos = this.base + this.type.size(null, this.parent) * index3;
      this._items[index3] = this.type.decode(this.stream, this.parent);
      this.stream.pos = pos;
    }
    return this._items[index3];
  }
  inspect() {
    return `[UnboundedArray ${this.type.constructor.name}]`;
  }
  constructor(type, stream2, parent) {
    this.type = type;
    this.stream = stream2;
    this.parent = parent;
    this.base = this.stream.pos;
    this._items = [];
  }
};
var $6cb7dd5f47d82580$export$c5af1eebc882e39a = class extends ArrayT {
  decode(stream2, parent) {
    return new $6cb7dd5f47d82580$var$UnboundedArrayAccessor(this.type, stream2, parent);
  }
  constructor(type) {
    super(type, 0);
  }
};
var $6cb7dd5f47d82580$export$8351f8c2ae2f103c = function(ValueType = uint16) {
  class Shadow {
    decode(stream2, ctx) {
      ctx = ctx.parent.parent;
      return this.type.decode(stream2, ctx);
    }
    size(val, ctx) {
      ctx = ctx.parent.parent;
      return this.type.size(val, ctx);
    }
    encode(stream2, val, ctx) {
      ctx = ctx.parent.parent;
      return this.type.encode(stream2, val, ctx);
    }
    constructor(type) {
      this.type = type;
    }
  }
  ValueType = new Shadow(ValueType);
  let BinarySearchHeader = new Struct({
    unitSize: uint16,
    nUnits: uint16,
    searchRange: uint16,
    entrySelector: uint16,
    rangeShift: uint16
  });
  let LookupSegmentSingle = new Struct({
    lastGlyph: uint16,
    firstGlyph: uint16,
    value: ValueType
  });
  let LookupSegmentArray = new Struct({
    lastGlyph: uint16,
    firstGlyph: uint16,
    values: new Pointer(uint16, new ArrayT(ValueType, (t2) => t2.lastGlyph - t2.firstGlyph + 1), {
      type: "parent"
    })
  });
  let LookupSingle = new Struct({
    glyph: uint16,
    value: ValueType
  });
  return new VersionedStruct(uint16, {
    0: {
      values: new $6cb7dd5f47d82580$export$c5af1eebc882e39a(ValueType)
      // length == number of glyphs maybe?
    },
    2: {
      binarySearchHeader: BinarySearchHeader,
      segments: new ArrayT(LookupSegmentSingle, (t2) => t2.binarySearchHeader.nUnits)
    },
    4: {
      binarySearchHeader: BinarySearchHeader,
      segments: new ArrayT(LookupSegmentArray, (t2) => t2.binarySearchHeader.nUnits)
    },
    6: {
      binarySearchHeader: BinarySearchHeader,
      segments: new ArrayT(LookupSingle, (t2) => t2.binarySearchHeader.nUnits)
    },
    8: {
      firstGlyph: uint16,
      count: uint16,
      values: new ArrayT(ValueType, "count")
    }
  });
};
function $6cb7dd5f47d82580$export$79f7d93d790934ba(entryData = {}, lookupType = uint16) {
  let entry = Object.assign({
    newState: uint16,
    flags: uint16
  }, entryData);
  let Entry = new Struct(entry);
  let StateArray = new $6cb7dd5f47d82580$export$c5af1eebc882e39a(new ArrayT(uint16, (t2) => t2.nClasses));
  let StateHeader = new Struct({
    nClasses: uint32,
    classTable: new Pointer(uint32, new $6cb7dd5f47d82580$export$8351f8c2ae2f103c(lookupType)),
    stateArray: new Pointer(uint32, StateArray),
    entryTable: new Pointer(uint32, new $6cb7dd5f47d82580$export$c5af1eebc882e39a(Entry))
  });
  return StateHeader;
}
function $6cb7dd5f47d82580$export$105027425199cc51(entryData = {}, lookupType = uint16) {
  let ClassLookupTable = new Struct({
    version() {
      return 8;
    },
    firstGlyph: uint16,
    values: new ArrayT(uint8, uint16)
  });
  let entry = Object.assign({
    newStateOffset: uint16,
    // convert offset to stateArray index
    newState: (t2) => (t2.newStateOffset - (t2.parent.stateArray.base - t2.parent._startOffset)) / t2.parent.nClasses,
    flags: uint16
  }, entryData);
  let Entry = new Struct(entry);
  let StateArray = new $6cb7dd5f47d82580$export$c5af1eebc882e39a(new ArrayT(uint8, (t2) => t2.nClasses));
  let StateHeader1 = new Struct({
    nClasses: uint16,
    classTable: new Pointer(uint16, ClassLookupTable),
    stateArray: new Pointer(uint16, StateArray),
    entryTable: new Pointer(uint16, new $6cb7dd5f47d82580$export$c5af1eebc882e39a(Entry))
  });
  return StateHeader1;
}
var $6a3746e8c708f5a3$var$BslnSubtable = new VersionedStruct("format", {
  0: {
    deltas: new ArrayT(int16, 32)
  },
  1: {
    deltas: new ArrayT(int16, 32),
    mappingData: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(uint16)
  },
  2: {
    standardGlyph: uint16,
    controlPoints: new ArrayT(uint16, 32)
  },
  3: {
    standardGlyph: uint16,
    controlPoints: new ArrayT(uint16, 32),
    mappingData: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(uint16)
  }
});
var $6a3746e8c708f5a3$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  format: uint16,
  defaultBaseline: uint16,
  subtable: $6a3746e8c708f5a3$var$BslnSubtable
});
var $d0c76fac617b308a$var$Setting = new Struct({
  setting: uint16,
  nameIndex: int16,
  name: (t2) => t2.parent.parent.parent.name.records.fontFeatures[t2.nameIndex]
});
var $d0c76fac617b308a$var$FeatureName = new Struct({
  feature: uint16,
  nSettings: uint16,
  settingTable: new Pointer(uint32, new ArrayT($d0c76fac617b308a$var$Setting, "nSettings"), {
    type: "parent"
  }),
  featureFlags: new Bitfield(uint8, [
    null,
    null,
    null,
    null,
    null,
    null,
    "hasDefault",
    "exclusive"
  ]),
  defaultSetting: uint8,
  nameIndex: int16,
  name: (t2) => t2.parent.parent.name.records.fontFeatures[t2.nameIndex]
});
var $d0c76fac617b308a$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  featureNameCount: uint16,
  reserved1: new Reserved(uint16),
  reserved2: new Reserved(uint32),
  featureNames: new ArrayT($d0c76fac617b308a$var$FeatureName, "featureNameCount")
});
var $e83fd065f00fcd01$var$Axis = new Struct({
  axisTag: new StringT(4),
  minValue: fixed32,
  defaultValue: fixed32,
  maxValue: fixed32,
  flags: uint16,
  nameID: uint16,
  name: (t2) => t2.parent.parent.name.records.fontFeatures[t2.nameID]
});
var $e83fd065f00fcd01$var$Instance = new Struct({
  nameID: uint16,
  name: (t2) => t2.parent.parent.name.records.fontFeatures[t2.nameID],
  flags: uint16,
  coord: new ArrayT(fixed32, (t2) => t2.parent.axisCount),
  postscriptNameID: new Optional(uint16, (t2) => t2.parent.instanceSize - t2._currentOffset > 0)
});
var $e83fd065f00fcd01$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  offsetToData: uint16,
  countSizePairs: uint16,
  axisCount: uint16,
  axisSize: uint16,
  instanceCount: uint16,
  instanceSize: uint16,
  axis: new ArrayT($e83fd065f00fcd01$var$Axis, "axisCount"),
  instance: new ArrayT($e83fd065f00fcd01$var$Instance, "instanceCount")
});
var $dbe33c8d3a7f131c$var$shortFrac = new Fixed(16, "BE", 14);
var $dbe33c8d3a7f131c$var$Offset = class {
  static decode(stream2, parent) {
    return parent.flags ? stream2.readUInt32BE() : stream2.readUInt16BE() * 2;
  }
};
var $dbe33c8d3a7f131c$var$gvar = new Struct({
  version: uint16,
  reserved: new Reserved(uint16),
  axisCount: uint16,
  globalCoordCount: uint16,
  globalCoords: new Pointer(uint32, new ArrayT(new ArrayT($dbe33c8d3a7f131c$var$shortFrac, "axisCount"), "globalCoordCount")),
  glyphCount: uint16,
  flags: uint16,
  offsetToData: uint32,
  offsets: new ArrayT(new Pointer($dbe33c8d3a7f131c$var$Offset, "void", {
    relativeTo: (ctx) => ctx.offsetToData,
    allowNull: false
  }), (t2) => t2.glyphCount + 1)
});
var $dbe33c8d3a7f131c$export$2e2bcd8739ae039 = $dbe33c8d3a7f131c$var$gvar;
var $05b01887df96c4ee$var$ClassTable = new Struct({
  length: uint16,
  coverage: uint16,
  subFeatureFlags: uint32,
  stateTable: new (0, $6cb7dd5f47d82580$export$105027425199cc51)()
});
var $05b01887df96c4ee$var$WidthDeltaRecord = new Struct({
  justClass: uint32,
  beforeGrowLimit: fixed32,
  beforeShrinkLimit: fixed32,
  afterGrowLimit: fixed32,
  afterShrinkLimit: fixed32,
  growFlags: uint16,
  shrinkFlags: uint16
});
var $05b01887df96c4ee$var$WidthDeltaCluster = new ArrayT($05b01887df96c4ee$var$WidthDeltaRecord, uint32);
var $05b01887df96c4ee$var$ActionData = new VersionedStruct("actionType", {
  0: {
    lowerLimit: fixed32,
    upperLimit: fixed32,
    order: uint16,
    glyphs: new ArrayT(uint16, uint16)
  },
  1: {
    addGlyph: uint16
  },
  2: {
    substThreshold: fixed32,
    addGlyph: uint16,
    substGlyph: uint16
  },
  3: {},
  4: {
    variationAxis: uint32,
    minimumLimit: fixed32,
    noStretchValue: fixed32,
    maximumLimit: fixed32
  },
  5: {
    flags: uint16,
    glyph: uint16
  }
});
var $05b01887df96c4ee$var$Action = new Struct({
  actionClass: uint16,
  actionType: uint16,
  actionLength: uint32,
  actionData: $05b01887df96c4ee$var$ActionData,
  padding: new Reserved(uint8, (t2) => t2.actionLength - t2._currentOffset)
});
var $05b01887df96c4ee$var$PostcompensationAction = new ArrayT($05b01887df96c4ee$var$Action, uint32);
var $05b01887df96c4ee$var$PostCompensationTable = new Struct({
  lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(new Pointer(uint16, $05b01887df96c4ee$var$PostcompensationAction))
});
var $05b01887df96c4ee$var$JustificationTable = new Struct({
  classTable: new Pointer(uint16, $05b01887df96c4ee$var$ClassTable, {
    type: "parent"
  }),
  wdcOffset: uint16,
  postCompensationTable: new Pointer(uint16, $05b01887df96c4ee$var$PostCompensationTable, {
    type: "parent"
  }),
  widthDeltaClusters: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)(new Pointer(uint16, $05b01887df96c4ee$var$WidthDeltaCluster, {
    type: "parent",
    relativeTo: (ctx) => ctx.wdcOffset
  }))
});
var $05b01887df96c4ee$export$2e2bcd8739ae039 = new Struct({
  version: uint32,
  format: uint16,
  horizontal: new Pointer(uint16, $05b01887df96c4ee$var$JustificationTable),
  vertical: new Pointer(uint16, $05b01887df96c4ee$var$JustificationTable)
});
var $03ee6ebd54db1053$var$LigatureData = {
  action: uint16
};
var $03ee6ebd54db1053$var$ContextualData = {
  markIndex: uint16,
  currentIndex: uint16
};
var $03ee6ebd54db1053$var$InsertionData = {
  currentInsertIndex: uint16,
  markedInsertIndex: uint16
};
var $03ee6ebd54db1053$var$SubstitutionTable = new Struct({
  items: new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)()))
});
var $03ee6ebd54db1053$var$SubtableData = new VersionedStruct("type", {
  0: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)()
  },
  1: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$ContextualData),
    substitutionTable: new Pointer(uint32, $03ee6ebd54db1053$var$SubstitutionTable)
  },
  2: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$LigatureData),
    ligatureActions: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint32)),
    components: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint16)),
    ligatureList: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint16))
  },
  4: {
    lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)()
  },
  5: {
    stateTable: new (0, $6cb7dd5f47d82580$export$79f7d93d790934ba)($03ee6ebd54db1053$var$InsertionData),
    insertionActions: new Pointer(uint32, new (0, $6cb7dd5f47d82580$export$c5af1eebc882e39a)(uint16))
  }
});
var $03ee6ebd54db1053$var$Subtable = new Struct({
  length: uint32,
  coverage: uint24,
  type: uint8,
  subFeatureFlags: uint32,
  table: $03ee6ebd54db1053$var$SubtableData,
  padding: new Reserved(uint8, (t2) => t2.length - t2._currentOffset)
});
var $03ee6ebd54db1053$var$FeatureEntry = new Struct({
  featureType: uint16,
  featureSetting: uint16,
  enableFlags: uint32,
  disableFlags: uint32
});
var $03ee6ebd54db1053$var$MorxChain = new Struct({
  defaultFlags: uint32,
  chainLength: uint32,
  nFeatureEntries: uint32,
  nSubtables: uint32,
  features: new ArrayT($03ee6ebd54db1053$var$FeatureEntry, "nFeatureEntries"),
  subtables: new ArrayT($03ee6ebd54db1053$var$Subtable, "nSubtables")
});
var $03ee6ebd54db1053$export$2e2bcd8739ae039 = new Struct({
  version: uint16,
  unused: new Reserved(uint16),
  nChains: uint32,
  chains: new ArrayT($03ee6ebd54db1053$var$MorxChain, "nChains")
});
var $b7492a80b0d1a056$var$OpticalBounds = new Struct({
  left: int16,
  top: int16,
  right: int16,
  bottom: int16
});
var $b7492a80b0d1a056$export$2e2bcd8739ae039 = new Struct({
  version: fixed32,
  format: uint16,
  lookupTable: new (0, $6cb7dd5f47d82580$export$8351f8c2ae2f103c)($b7492a80b0d1a056$var$OpticalBounds)
});
var $c3395722bea751e2$var$tables = {};
var $c3395722bea751e2$export$2e2bcd8739ae039 = $c3395722bea751e2$var$tables;
$c3395722bea751e2$var$tables.cmap = (0, $26a62205ad06574e$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.head = (0, $f2612a29f92ac062$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.hhea = (0, $2c179dd593583073$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.hmtx = (0, $bdc9060542264b85$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.maxp = (0, $dbf51cb3d3fe409d$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.name = (0, $2bcf221753ec8e32$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["OS/2"] = (0, $84b272aa31b70606$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.post = (0, $32d9e2eb9565d93c$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.fpgm = (0, $5c0f37ca5ffb1850$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.loca = (0, $2b2b260902b1c57e$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.prep = (0, $7afb878c7bea4f66$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["cvt "] = (0, $5202bd9d9ad8eaac$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.glyf = (0, $6c92b6371bce8bd9$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["CFF "] = (0, $822ac0d589e4e237$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables["CFF2"] = (0, $822ac0d589e4e237$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.VORG = (0, $2bbf2bc1ce37cd8f$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.EBLC = (0, $9911c4c7201c13de$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.CBLC = $c3395722bea751e2$var$tables.EBLC;
$c3395722bea751e2$var$tables.sbix = (0, $abb847051efd51b1$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.COLR = (0, $eb629188f3dfefdd$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.CPAL = (0, $08734b8e7dc64587$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.BASE = (0, $497cef411d884e34$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.GDEF = (0, $cf5f33c63ef209e6$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.GPOS = (0, $47e0e8ef515d9903$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.GSUB = (0, $d3f442064af66e06$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.JSTF = (0, $71cfb3c4767fbd0c$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.HVAR = (0, $d059a6bd2d3b5b63$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.DSIG = (0, $dceeca3e1977ce30$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.gasp = (0, $8acd740a9435aad0$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.hdmx = (0, $b5f380243c34d6a0$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.kern = (0, $ca2df1256966e313$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.LTSH = (0, $7a9f92b0c46ebe33$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.PCLT = (0, $2b2ccc419d152631$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.VDMX = (0, $ca5b40b9bcda9c9b$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.vhea = (0, $69530a3c40755af0$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.vmtx = (0, $344073dd270f0e62$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.avar = (0, $3793b781918cfced$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.bsln = (0, $6a3746e8c708f5a3$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.feat = (0, $d0c76fac617b308a$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.fvar = (0, $e83fd065f00fcd01$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.gvar = (0, $dbe33c8d3a7f131c$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.just = (0, $05b01887df96c4ee$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.morx = (0, $03ee6ebd54db1053$export$2e2bcd8739ae039);
$c3395722bea751e2$var$tables.opbd = (0, $b7492a80b0d1a056$export$2e2bcd8739ae039);
var $816c07a04b6dba87$var$TableEntry = new Struct({
  tag: new StringT(4),
  checkSum: uint32,
  offset: new Pointer(uint32, "void", {
    type: "global"
  }),
  length: uint32
});
var $816c07a04b6dba87$var$Directory = new Struct({
  tag: new StringT(4),
  numTables: uint16,
  searchRange: uint16,
  entrySelector: uint16,
  rangeShift: uint16,
  tables: new ArrayT($816c07a04b6dba87$var$TableEntry, "numTables")
});
$816c07a04b6dba87$var$Directory.process = function() {
  let tables = {};
  for (let table of this.tables)
    tables[table.tag] = table;
  this.tables = tables;
};
$816c07a04b6dba87$var$Directory.preEncode = function() {
  if (!Array.isArray(this.tables)) {
    let tables = [];
    for (let tag in this.tables) {
      let table = this.tables[tag];
      if (table)
        tables.push({
          tag,
          checkSum: 0,
          offset: new VoidPointer((0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag], table),
          length: (0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag].size(table)
        });
    }
    this.tables = tables;
  }
  this.tag = "true";
  this.numTables = this.tables.length;
  let maxExponentFor2 = Math.floor(Math.log(this.numTables) / Math.LN2);
  let maxPowerOf2 = Math.pow(2, maxExponentFor2);
  this.searchRange = maxPowerOf2 * 16;
  this.entrySelector = Math.log(maxPowerOf2) / Math.LN2;
  this.rangeShift = this.numTables * 16 - this.searchRange;
};
var $816c07a04b6dba87$export$2e2bcd8739ae039 = $816c07a04b6dba87$var$Directory;
function $12727730ddfc8bfe$export$2e0ae67339d5f1ac(arr, cmp) {
  let min3 = 0;
  let max3 = arr.length - 1;
  while (min3 <= max3) {
    let mid = min3 + max3 >> 1;
    let res = cmp(arr[mid]);
    if (res < 0)
      max3 = mid - 1;
    else if (res > 0)
      min3 = mid + 1;
    else
      return mid;
  }
  return -1;
}
function $12727730ddfc8bfe$export$d02631cccf789723(index3, end3) {
  let range1 = [];
  while (index3 < end3)
    range1.push(index3++);
  return range1;
}
var $12727730ddfc8bfe$export$3d28c1996ced1f14 = new TextDecoder("ascii");
var $12727730ddfc8bfe$var$CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var $12727730ddfc8bfe$var$LOOKUP = new Uint8Array(256);
for (let i = 0; i < $12727730ddfc8bfe$var$CHARS.length; i++)
  $12727730ddfc8bfe$var$LOOKUP[$12727730ddfc8bfe$var$CHARS.charCodeAt(i)] = i;
function $12727730ddfc8bfe$export$94fdf11bafc8de6b(base64) {
  let bufferLength = base64.length * 0.75;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=")
      bufferLength--;
  }
  let bytes = new Uint8Array(bufferLength);
  let p = 0;
  for (let i1 = 0, len = base64.length; i1 < len; i1 += 4) {
    let encoded1 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i1)];
    let encoded2 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i1 + 1)];
    let encoded3 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i1 + 2)];
    let encoded4 = $12727730ddfc8bfe$var$LOOKUP[base64.charCodeAt(i1 + 3)];
    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return bytes;
}
var $f08dd41ef10b694c$export$2e2bcd8739ae039 = class {
  findSubtable(cmapTable, pairs3) {
    for (let [platformID, encodingID] of pairs3)
      for (let cmap of cmapTable.tables) {
        if (cmap.platformID === platformID && cmap.encodingID === encodingID)
          return cmap.table;
      }
    return null;
  }
  lookup(codepoint, variationSelector) {
    if (this.encoding)
      codepoint = this.encoding.get(codepoint) || codepoint;
    else if (variationSelector) {
      let gid = this.getVariationSelector(codepoint, variationSelector);
      if (gid)
        return gid;
    }
    let cmap = this.cmap;
    switch (cmap.version) {
      case 0:
        return cmap.codeMap.get(codepoint) || 0;
      case 4: {
        let min3 = 0;
        let max3 = cmap.segCount - 1;
        while (min3 <= max3) {
          let mid = min3 + max3 >> 1;
          if (codepoint < cmap.startCode.get(mid))
            max3 = mid - 1;
          else if (codepoint > cmap.endCode.get(mid))
            min3 = mid + 1;
          else {
            let rangeOffset = cmap.idRangeOffset.get(mid);
            let gid;
            if (rangeOffset === 0)
              gid = codepoint + cmap.idDelta.get(mid);
            else {
              let index3 = rangeOffset / 2 + (codepoint - cmap.startCode.get(mid)) - (cmap.segCount - mid);
              gid = cmap.glyphIndexArray.get(index3) || 0;
              if (gid !== 0)
                gid += cmap.idDelta.get(mid);
            }
            return gid & 65535;
          }
        }
        return 0;
      }
      case 8:
        throw new Error("TODO: cmap format 8");
      case 6:
      case 10:
        return cmap.glyphIndices.get(codepoint - cmap.firstCode) || 0;
      case 12:
      case 13: {
        let min3 = 0;
        let max3 = cmap.nGroups - 1;
        while (min3 <= max3) {
          let mid = min3 + max3 >> 1;
          let group = cmap.groups.get(mid);
          if (codepoint < group.startCharCode)
            max3 = mid - 1;
          else if (codepoint > group.endCharCode)
            min3 = mid + 1;
          else {
            if (cmap.version === 12)
              return group.glyphID + (codepoint - group.startCharCode);
            else
              return group.glyphID;
          }
        }
        return 0;
      }
      case 14:
        throw new Error("TODO: cmap format 14");
      default:
        throw new Error(`Unknown cmap format ${cmap.version}`);
    }
  }
  getVariationSelector(codepoint, variationSelector) {
    if (!this.uvs)
      return 0;
    let selectors = this.uvs.varSelectors.toArray();
    let i = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(selectors, (x) => variationSelector - x.varSelector);
    let sel = selectors[i];
    if (i !== -1 && sel.defaultUVS)
      i = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(sel.defaultUVS, (x) => codepoint < x.startUnicodeValue ? -1 : codepoint > x.startUnicodeValue + x.additionalCount ? 1 : 0);
    if (i !== -1 && sel.nonDefaultUVS) {
      i = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(sel.nonDefaultUVS, (x) => codepoint - x.unicodeValue);
      if (i !== -1)
        return sel.nonDefaultUVS[i].glyphID;
    }
    return 0;
  }
  getCharacterSet() {
    let cmap = this.cmap;
    switch (cmap.version) {
      case 0:
        return (0, $12727730ddfc8bfe$export$d02631cccf789723)(0, cmap.codeMap.length);
      case 4: {
        let res = [];
        let endCodes = cmap.endCode.toArray();
        for (let i = 0; i < endCodes.length; i++) {
          let tail = endCodes[i] + 1;
          let start3 = cmap.startCode.get(i);
          res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(start3, tail));
        }
        return res;
      }
      case 8:
        throw new Error("TODO: cmap format 8");
      case 6:
      case 10:
        return (0, $12727730ddfc8bfe$export$d02631cccf789723)(cmap.firstCode, cmap.firstCode + cmap.glyphIndices.length);
      case 12:
      case 13: {
        let res = [];
        for (let group of cmap.groups.toArray())
          res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(group.startCharCode, group.endCharCode + 1));
        return res;
      }
      case 14:
        throw new Error("TODO: cmap format 14");
      default:
        throw new Error(`Unknown cmap format ${cmap.version}`);
    }
  }
  codePointsForGlyph(gid) {
    let cmap = this.cmap;
    switch (cmap.version) {
      case 0: {
        let res = [];
        for (let i = 0; i < 256; i++)
          if (cmap.codeMap.get(i) === gid)
            res.push(i);
        return res;
      }
      case 4: {
        let res = [];
        for (let i = 0; i < cmap.segCount; i++) {
          let end3 = cmap.endCode.get(i);
          let start3 = cmap.startCode.get(i);
          let rangeOffset = cmap.idRangeOffset.get(i);
          let delta = cmap.idDelta.get(i);
          for (var c2 = start3; c2 <= end3; c2++) {
            let g3 = 0;
            if (rangeOffset === 0)
              g3 = c2 + delta;
            else {
              let index3 = rangeOffset / 2 + (c2 - start3) - (cmap.segCount - i);
              g3 = cmap.glyphIndexArray.get(index3) || 0;
              if (g3 !== 0)
                g3 += delta;
            }
            if (g3 === gid)
              res.push(c2);
          }
        }
        return res;
      }
      case 12: {
        let res = [];
        for (let group of cmap.groups.toArray())
          if (gid >= group.glyphID && gid <= group.glyphID + (group.endCharCode - group.startCharCode))
            res.push(group.startCharCode + (gid - group.glyphID));
        return res;
      }
      case 13: {
        let res = [];
        for (let group of cmap.groups.toArray())
          if (gid === group.glyphID)
            res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(group.startCharCode, group.endCharCode + 1));
        return res;
      }
      default:
        throw new Error(`Unknown cmap format ${cmap.version}`);
    }
  }
  constructor(cmapTable) {
    this.encoding = null;
    this.cmap = this.findSubtable(cmapTable, [
      // 32-bit subtables
      [
        3,
        10
      ],
      [
        0,
        6
      ],
      [
        0,
        4
      ],
      // 16-bit subtables
      [
        3,
        1
      ],
      [
        0,
        3
      ],
      [
        0,
        2
      ],
      [
        0,
        1
      ],
      [
        0,
        0
      ]
    ]);
    if (!this.cmap)
      for (let cmap of cmapTable.tables) {
        let encoding = (0, $e449ad78d50845fe$export$badc544e0651b6b1)(cmap.platformID, cmap.encodingID, cmap.table.language - 1);
        let mapping = (0, $e449ad78d50845fe$export$1dceb3c14ed68bee)(encoding);
        if (mapping) {
          this.cmap = cmap.table;
          this.encoding = mapping;
        }
      }
    if (!this.cmap)
      throw new Error("Could not find a supported cmap table");
    this.uvs = this.findSubtable(cmapTable, [
      [
        0,
        5
      ]
    ]);
    if (this.uvs && this.uvs.version !== 14)
      this.uvs = null;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f08dd41ef10b694c$export$2e2bcd8739ae039.prototype, "getCharacterSet", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f08dd41ef10b694c$export$2e2bcd8739ae039.prototype, "codePointsForGlyph", null);
var $0bba3a9db57637f3$export$2e2bcd8739ae039 = class {
  process(glyphs, positions) {
    for (let glyphIndex = 0; glyphIndex < glyphs.length - 1; glyphIndex++) {
      let left = glyphs[glyphIndex].id;
      let right = glyphs[glyphIndex + 1].id;
      positions[glyphIndex].xAdvance += this.getKerning(left, right);
    }
  }
  getKerning(left, right) {
    let res = 0;
    for (let table of this.kern.tables) {
      if (table.coverage.crossStream)
        continue;
      switch (table.version) {
        case 0:
          if (!table.coverage.horizontal)
            continue;
          break;
        case 1:
          if (table.coverage.vertical || table.coverage.variation)
            continue;
          break;
        default:
          throw new Error(`Unsupported kerning table version ${table.version}`);
      }
      let val = 0;
      let s2 = table.subtable;
      switch (table.format) {
        case 0:
          let pairIdx = (0, $12727730ddfc8bfe$export$2e0ae67339d5f1ac)(s2.pairs, function(pair) {
            return left - pair.left || right - pair.right;
          });
          if (pairIdx >= 0)
            val = s2.pairs[pairIdx].value;
          break;
        case 2:
          let leftOffset = 0, rightOffset = 0;
          if (left >= s2.leftTable.firstGlyph && left < s2.leftTable.firstGlyph + s2.leftTable.nGlyphs)
            leftOffset = s2.leftTable.offsets[left - s2.leftTable.firstGlyph];
          else
            leftOffset = s2.array.off;
          if (right >= s2.rightTable.firstGlyph && right < s2.rightTable.firstGlyph + s2.rightTable.nGlyphs)
            rightOffset = s2.rightTable.offsets[right - s2.rightTable.firstGlyph];
          let index3 = (leftOffset + rightOffset - s2.array.off) / 2;
          val = s2.array.values.get(index3);
          break;
        case 3:
          if (left >= s2.glyphCount || right >= s2.glyphCount)
            return 0;
          val = s2.kernValue[s2.kernIndex[s2.leftClass[left] * s2.rightClassCount + s2.rightClass[right]]];
          break;
        default:
          throw new Error(`Unsupported kerning sub-table format ${table.format}`);
      }
      if (table.coverage.override)
        res = val;
      else
        res += val;
    }
    return res;
  }
  constructor(font2) {
    this.kern = font2.kern;
  }
};
var $0a4bdfeb6dfd6f5e$export$2e2bcd8739ae039 = class {
  positionGlyphs(glyphs, positions) {
    let clusterStart = 0;
    let clusterEnd = 0;
    for (let index3 = 0; index3 < glyphs.length; index3++) {
      let glyph = glyphs[index3];
      if (glyph.isMark)
        clusterEnd = index3;
      else {
        if (clusterStart !== clusterEnd)
          this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
        clusterStart = clusterEnd = index3;
      }
    }
    if (clusterStart !== clusterEnd)
      this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
    return positions;
  }
  positionCluster(glyphs, positions, clusterStart, clusterEnd) {
    let base = glyphs[clusterStart];
    let baseBox = base.cbox.copy();
    if (base.codePoints.length > 1)
      baseBox.minX += (base.codePoints.length - 1) * baseBox.width / base.codePoints.length;
    let xOffset = -positions[clusterStart].xAdvance;
    let yOffset = 0;
    let yGap = this.font.unitsPerEm / 16;
    for (let index3 = clusterStart + 1; index3 <= clusterEnd; index3++) {
      let mark = glyphs[index3];
      let markBox = mark.cbox;
      let position = positions[index3];
      let combiningClass = this.getCombiningClass(mark.codePoints[0]);
      if (combiningClass !== "Not_Reordered") {
        position.xOffset = position.yOffset = 0;
        switch (combiningClass) {
          case "Double_Above":
          case "Double_Below":
            position.xOffset += baseBox.minX - markBox.width / 2 - markBox.minX;
            break;
          case "Attached_Below_Left":
          case "Below_Left":
          case "Above_Left":
            position.xOffset += baseBox.minX - markBox.minX;
            break;
          case "Attached_Above_Right":
          case "Below_Right":
          case "Above_Right":
            position.xOffset += baseBox.maxX - markBox.width - markBox.minX;
            break;
          default:
            position.xOffset += baseBox.minX + (baseBox.width - markBox.width) / 2 - markBox.minX;
        }
        switch (combiningClass) {
          case "Double_Below":
          case "Below_Left":
          case "Below":
          case "Below_Right":
          case "Attached_Below_Left":
          case "Attached_Below":
            if (combiningClass === "Attached_Below_Left" || combiningClass === "Attached_Below")
              baseBox.minY += yGap;
            position.yOffset = -baseBox.minY - markBox.maxY;
            baseBox.minY += markBox.height;
            break;
          case "Double_Above":
          case "Above_Left":
          case "Above":
          case "Above_Right":
          case "Attached_Above":
          case "Attached_Above_Right":
            if (combiningClass === "Attached_Above" || combiningClass === "Attached_Above_Right")
              baseBox.maxY += yGap;
            position.yOffset = baseBox.maxY - markBox.minY;
            baseBox.maxY += markBox.height;
            break;
        }
        position.xAdvance = position.yAdvance = 0;
        position.xOffset += xOffset;
        position.yOffset += yOffset;
      } else {
        xOffset -= position.xAdvance;
        yOffset -= position.yAdvance;
      }
    }
    return;
  }
  getCombiningClass(codePoint) {
    let combiningClass = (0, $747425b437e121da$export$c03b919c6651ed55)(codePoint);
    if ((codePoint & -256) === 3584) {
      if (combiningClass === "Not_Reordered")
        switch (codePoint) {
          case 3633:
          case 3636:
          case 3637:
          case 3638:
          case 3639:
          case 3655:
          case 3660:
          case 3645:
          case 3662:
            return "Above_Right";
          case 3761:
          case 3764:
          case 3765:
          case 3766:
          case 3767:
          case 3771:
          case 3788:
          case 3789:
            return "Above";
          case 3772:
            return "Below";
        }
      else if (codePoint === 3642)
        return "Below_Right";
    }
    switch (combiningClass) {
      case "CCC10":
      case "CCC11":
      case "CCC12":
      case "CCC13":
      case "CCC14":
      case "CCC15":
      case "CCC16":
      case "CCC17":
      case "CCC18":
      case "CCC20":
      case "CCC22":
        return "Below";
      case "CCC23":
        return "Attached_Above";
      case "CCC24":
        return "Above_Right";
      case "CCC25":
      case "CCC19":
        return "Above_Left";
      case "CCC26":
        return "Above";
      case "CCC21":
        break;
      case "CCC27":
      case "CCC28":
      case "CCC30":
      case "CCC31":
      case "CCC33":
      case "CCC34":
      case "CCC35":
      case "CCC36":
        return "Above";
      case "CCC29":
      case "CCC32":
        return "Below";
      case "CCC103":
        return "Below_Right";
      case "CCC107":
        return "Above_Right";
      case "CCC118":
        return "Below";
      case "CCC122":
        return "Above";
      case "CCC129":
      case "CCC132":
        return "Below";
      case "CCC130":
        return "Above";
    }
    return combiningClass;
  }
  constructor(font2) {
    this.font = font2;
  }
};
var $f34600ab9d7f70d8$export$2e2bcd8739ae039 = class _$f34600ab9d7f70d8$export$2e2bcd8739ae039 {
  /**
  * The width of the bounding box
  * @type {number}
  */
  get width() {
    return this.maxX - this.minX;
  }
  /**
  * The height of the bounding box
  * @type {number}
  */
  get height() {
    return this.maxY - this.minY;
  }
  addPoint(x, y) {
    if (Math.abs(x) !== Infinity) {
      if (x < this.minX)
        this.minX = x;
      if (x > this.maxX)
        this.maxX = x;
    }
    if (Math.abs(y) !== Infinity) {
      if (y < this.minY)
        this.minY = y;
      if (y > this.maxY)
        this.maxY = y;
    }
  }
  copy() {
    return new _$f34600ab9d7f70d8$export$2e2bcd8739ae039(this.minX, this.minY, this.maxX, this.maxY);
  }
  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
};
var $130d1a642ebcd2b7$var$UNICODE_SCRIPTS = {
  Caucasian_Albanian: "aghb",
  Arabic: "arab",
  Imperial_Aramaic: "armi",
  Armenian: "armn",
  Avestan: "avst",
  Balinese: "bali",
  Bamum: "bamu",
  Bassa_Vah: "bass",
  Batak: "batk",
  Bengali: [
    "bng2",
    "beng"
  ],
  Bopomofo: "bopo",
  Brahmi: "brah",
  Braille: "brai",
  Buginese: "bugi",
  Buhid: "buhd",
  Chakma: "cakm",
  Canadian_Aboriginal: "cans",
  Carian: "cari",
  Cham: "cham",
  Cherokee: "cher",
  Coptic: "copt",
  Cypriot: "cprt",
  Cyrillic: "cyrl",
  Devanagari: [
    "dev2",
    "deva"
  ],
  Deseret: "dsrt",
  Duployan: "dupl",
  Egyptian_Hieroglyphs: "egyp",
  Elbasan: "elba",
  Ethiopic: "ethi",
  Georgian: "geor",
  Glagolitic: "glag",
  Gothic: "goth",
  Grantha: "gran",
  Greek: "grek",
  Gujarati: [
    "gjr2",
    "gujr"
  ],
  Gurmukhi: [
    "gur2",
    "guru"
  ],
  Hangul: "hang",
  Han: "hani",
  Hanunoo: "hano",
  Hebrew: "hebr",
  Hiragana: "hira",
  Pahawh_Hmong: "hmng",
  Katakana_Or_Hiragana: "hrkt",
  Old_Italic: "ital",
  Javanese: "java",
  Kayah_Li: "kali",
  Katakana: "kana",
  Kharoshthi: "khar",
  Khmer: "khmr",
  Khojki: "khoj",
  Kannada: [
    "knd2",
    "knda"
  ],
  Kaithi: "kthi",
  Tai_Tham: "lana",
  Lao: "lao ",
  Latin: "latn",
  Lepcha: "lepc",
  Limbu: "limb",
  Linear_A: "lina",
  Linear_B: "linb",
  Lisu: "lisu",
  Lycian: "lyci",
  Lydian: "lydi",
  Mahajani: "mahj",
  Mandaic: "mand",
  Manichaean: "mani",
  Mende_Kikakui: "mend",
  Meroitic_Cursive: "merc",
  Meroitic_Hieroglyphs: "mero",
  Malayalam: [
    "mlm2",
    "mlym"
  ],
  Modi: "modi",
  Mongolian: "mong",
  Mro: "mroo",
  Meetei_Mayek: "mtei",
  Myanmar: [
    "mym2",
    "mymr"
  ],
  Old_North_Arabian: "narb",
  Nabataean: "nbat",
  Nko: "nko ",
  Ogham: "ogam",
  Ol_Chiki: "olck",
  Old_Turkic: "orkh",
  Oriya: [
    "ory2",
    "orya"
  ],
  Osmanya: "osma",
  Palmyrene: "palm",
  Pau_Cin_Hau: "pauc",
  Old_Permic: "perm",
  Phags_Pa: "phag",
  Inscriptional_Pahlavi: "phli",
  Psalter_Pahlavi: "phlp",
  Phoenician: "phnx",
  Miao: "plrd",
  Inscriptional_Parthian: "prti",
  Rejang: "rjng",
  Runic: "runr",
  Samaritan: "samr",
  Old_South_Arabian: "sarb",
  Saurashtra: "saur",
  Shavian: "shaw",
  Sharada: "shrd",
  Siddham: "sidd",
  Khudawadi: "sind",
  Sinhala: "sinh",
  Sora_Sompeng: "sora",
  Sundanese: "sund",
  Syloti_Nagri: "sylo",
  Syriac: "syrc",
  Tagbanwa: "tagb",
  Takri: "takr",
  Tai_Le: "tale",
  New_Tai_Lue: "talu",
  Tamil: [
    "tml2",
    "taml"
  ],
  Tai_Viet: "tavt",
  Telugu: [
    "tel2",
    "telu"
  ],
  Tifinagh: "tfng",
  Tagalog: "tglg",
  Thaana: "thaa",
  Thai: "thai",
  Tibetan: "tibt",
  Tirhuta: "tirh",
  Ugaritic: "ugar",
  Vai: "vai ",
  Warang_Citi: "wara",
  Old_Persian: "xpeo",
  Cuneiform: "xsux",
  Yi: "yi  ",
  Inherited: "zinh",
  Common: "zyyy",
  Unknown: "zzzz"
};
var $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS = {};
for (let script in $130d1a642ebcd2b7$var$UNICODE_SCRIPTS) {
  let tag = $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script];
  if (Array.isArray(tag))
    for (let t2 of tag)
      $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[t2] = script;
  else
    $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[tag] = script;
}
function $130d1a642ebcd2b7$export$ce50e82f12a827a4(tag) {
  return $130d1a642ebcd2b7$var$OPENTYPE_SCRIPTS[tag];
}
function $130d1a642ebcd2b7$export$e5cb25e204fb8450(string) {
  let len = string.length;
  let idx = 0;
  while (idx < len) {
    let code3 = string.charCodeAt(idx++);
    if (55296 <= code3 && code3 <= 56319 && idx < len) {
      let next2 = string.charCodeAt(idx);
      if (56320 <= next2 && next2 <= 57343) {
        idx++;
        code3 = ((code3 & 1023) << 10) + (next2 & 1023) + 65536;
      }
    }
    let script2 = (0, $747425b437e121da$export$941569448d136665)(code3);
    if (script2 !== "Common" && script2 !== "Inherited" && script2 !== "Unknown")
      return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script2];
  }
  return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS.Unknown;
}
function $130d1a642ebcd2b7$export$16fab0757cfc223d(codePoints) {
  for (let i = 0; i < codePoints.length; i++) {
    let codePoint = codePoints[i];
    let script3 = (0, $747425b437e121da$export$941569448d136665)(codePoint);
    if (script3 !== "Common" && script3 !== "Inherited" && script3 !== "Unknown")
      return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS[script3];
  }
  return $130d1a642ebcd2b7$var$UNICODE_SCRIPTS.Unknown;
}
var $130d1a642ebcd2b7$var$RTL = {
  arab: true,
  hebr: true,
  syrc: true,
  thaa: true,
  cprt: true,
  khar: true,
  phnx: true,
  "nko ": true,
  lydi: true,
  avst: true,
  armi: true,
  phli: true,
  prti: true,
  sarb: true,
  orkh: true,
  samr: true,
  mand: true,
  merc: true,
  mero: true,
  // Unicode 7.0 (not listed on http://www.microsoft.com/typography/otspec/scripttags.htm)
  mani: true,
  mend: true,
  nbat: true,
  narb: true,
  palm: true,
  phlp: true
  // Psalter Pahlavi
};
function $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script4) {
  if ($130d1a642ebcd2b7$var$RTL[script4])
    return "rtl";
  return "ltr";
}
var $be07b3e97a42687a$export$2e2bcd8739ae039 = class {
  /**
  * The total advance width of the run.
  * @type {number}
  */
  get advanceWidth() {
    let width = 0;
    for (let position of this.positions)
      width += position.xAdvance;
    return width;
  }
  /**
  * The total advance height of the run.
  * @type {number}
  */
  get advanceHeight() {
    let height5 = 0;
    for (let position of this.positions)
      height5 += position.yAdvance;
    return height5;
  }
  /**
  * The bounding box containing all glyphs in the run.
  * @type {BBox}
  */
  get bbox() {
    let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
    let x = 0;
    let y = 0;
    for (let index3 = 0; index3 < this.glyphs.length; index3++) {
      let glyph = this.glyphs[index3];
      let p = this.positions[index3];
      let b = glyph.bbox;
      bbox.addPoint(b.minX + x + p.xOffset, b.minY + y + p.yOffset);
      bbox.addPoint(b.maxX + x + p.xOffset, b.maxY + y + p.yOffset);
      x += p.xAdvance;
      y += p.yAdvance;
    }
    return bbox;
  }
  constructor(glyphs, features, script, language, direction) {
    this.glyphs = glyphs;
    this.positions = null;
    this.script = script;
    this.language = language || null;
    this.direction = direction || $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script);
    this.features = {};
    if (Array.isArray(features))
      for (let tag of features)
        this.features[tag] = true;
    else if (typeof features === "object")
      this.features = features;
  }
};
var $1ac75d9a55b67f01$export$2e2bcd8739ae039 = class {
  constructor(xAdvance = 0, yAdvance = 0, xOffset = 0, yOffset = 0) {
    this.xAdvance = xAdvance;
    this.yAdvance = yAdvance;
    this.xOffset = xOffset;
    this.yOffset = yOffset;
  }
};
var $3b6302b64eccc32c$var$features = {
  allTypographicFeatures: {
    code: 0,
    exclusive: false,
    allTypeFeatures: 0
  },
  ligatures: {
    code: 1,
    exclusive: false,
    requiredLigatures: 0,
    commonLigatures: 2,
    rareLigatures: 4,
    // logos: 6
    rebusPictures: 8,
    diphthongLigatures: 10,
    squaredLigatures: 12,
    abbrevSquaredLigatures: 14,
    symbolLigatures: 16,
    contextualLigatures: 18,
    historicalLigatures: 20
  },
  cursiveConnection: {
    code: 2,
    exclusive: true,
    unconnected: 0,
    partiallyConnected: 1,
    cursive: 2
  },
  letterCase: {
    code: 3,
    exclusive: true
  },
  // upperAndLowerCase: 0          # deprecated
  // allCaps: 1                    # deprecated
  // allLowerCase: 2               # deprecated
  // smallCaps: 3                  # deprecated
  // initialCaps: 4                # deprecated
  // initialCapsAndSmallCaps: 5    # deprecated
  verticalSubstitution: {
    code: 4,
    exclusive: false,
    substituteVerticalForms: 0
  },
  linguisticRearrangement: {
    code: 5,
    exclusive: false,
    linguisticRearrangement: 0
  },
  numberSpacing: {
    code: 6,
    exclusive: true,
    monospacedNumbers: 0,
    proportionalNumbers: 1,
    thirdWidthNumbers: 2,
    quarterWidthNumbers: 3
  },
  smartSwash: {
    code: 8,
    exclusive: false,
    wordInitialSwashes: 0,
    wordFinalSwashes: 2,
    // lineInitialSwashes: 4
    // lineFinalSwashes: 6
    nonFinalSwashes: 8
  },
  diacritics: {
    code: 9,
    exclusive: true,
    showDiacritics: 0,
    hideDiacritics: 1,
    decomposeDiacritics: 2
  },
  verticalPosition: {
    code: 10,
    exclusive: true,
    normalPosition: 0,
    superiors: 1,
    inferiors: 2,
    ordinals: 3,
    scientificInferiors: 4
  },
  fractions: {
    code: 11,
    exclusive: true,
    noFractions: 0,
    verticalFractions: 1,
    diagonalFractions: 2
  },
  overlappingCharacters: {
    code: 13,
    exclusive: false,
    preventOverlap: 0
  },
  typographicExtras: {
    code: 14,
    exclusive: false,
    // hyphensToEmDash: 0
    // hyphenToEnDash: 2
    slashedZero: 4
  },
  // formInterrobang: 6
  // smartQuotes: 8
  // periodsToEllipsis: 10
  mathematicalExtras: {
    code: 15,
    exclusive: false,
    // hyphenToMinus: 0
    // asteristoMultiply: 2
    // slashToDivide: 4
    // inequalityLigatures: 6
    // exponents: 8
    mathematicalGreek: 10
  },
  ornamentSets: {
    code: 16,
    exclusive: true,
    noOrnaments: 0,
    dingbats: 1,
    piCharacters: 2,
    fleurons: 3,
    decorativeBorders: 4,
    internationalSymbols: 5,
    mathSymbols: 6
  },
  characterAlternatives: {
    code: 17,
    exclusive: true,
    noAlternates: 0
  },
  // user defined options
  designComplexity: {
    code: 18,
    exclusive: true,
    designLevel1: 0,
    designLevel2: 1,
    designLevel3: 2,
    designLevel4: 3,
    designLevel5: 4
  },
  styleOptions: {
    code: 19,
    exclusive: true,
    noStyleOptions: 0,
    displayText: 1,
    engravedText: 2,
    illuminatedCaps: 3,
    titlingCaps: 4,
    tallCaps: 5
  },
  characterShape: {
    code: 20,
    exclusive: true,
    traditionalCharacters: 0,
    simplifiedCharacters: 1,
    JIS1978Characters: 2,
    JIS1983Characters: 3,
    JIS1990Characters: 4,
    traditionalAltOne: 5,
    traditionalAltTwo: 6,
    traditionalAltThree: 7,
    traditionalAltFour: 8,
    traditionalAltFive: 9,
    expertCharacters: 10,
    JIS2004Characters: 11,
    hojoCharacters: 12,
    NLCCharacters: 13,
    traditionalNamesCharacters: 14
  },
  numberCase: {
    code: 21,
    exclusive: true,
    lowerCaseNumbers: 0,
    upperCaseNumbers: 1
  },
  textSpacing: {
    code: 22,
    exclusive: true,
    proportionalText: 0,
    monospacedText: 1,
    halfWidthText: 2,
    thirdWidthText: 3,
    quarterWidthText: 4,
    altProportionalText: 5,
    altHalfWidthText: 6
  },
  transliteration: {
    code: 23,
    exclusive: true,
    noTransliteration: 0
  },
  // hanjaToHangul: 1
  // hiraganaToKatakana: 2
  // katakanaToHiragana: 3
  // kanaToRomanization: 4
  // romanizationToHiragana: 5
  // romanizationToKatakana: 6
  // hanjaToHangulAltOne: 7
  // hanjaToHangulAltTwo: 8
  // hanjaToHangulAltThree: 9
  annotation: {
    code: 24,
    exclusive: true,
    noAnnotation: 0,
    boxAnnotation: 1,
    roundedBoxAnnotation: 2,
    circleAnnotation: 3,
    invertedCircleAnnotation: 4,
    parenthesisAnnotation: 5,
    periodAnnotation: 6,
    romanNumeralAnnotation: 7,
    diamondAnnotation: 8,
    invertedBoxAnnotation: 9,
    invertedRoundedBoxAnnotation: 10
  },
  kanaSpacing: {
    code: 25,
    exclusive: true,
    fullWidthKana: 0,
    proportionalKana: 1
  },
  ideographicSpacing: {
    code: 26,
    exclusive: true,
    fullWidthIdeographs: 0,
    proportionalIdeographs: 1,
    halfWidthIdeographs: 2
  },
  unicodeDecomposition: {
    code: 27,
    exclusive: false,
    canonicalComposition: 0,
    compatibilityComposition: 2,
    transcodingComposition: 4
  },
  rubyKana: {
    code: 28,
    exclusive: false,
    // noRubyKana: 0     # deprecated - use rubyKanaOff instead
    // rubyKana: 1     # deprecated - use rubyKanaOn instead
    rubyKana: 2
  },
  CJKSymbolAlternatives: {
    code: 29,
    exclusive: true,
    noCJKSymbolAlternatives: 0,
    CJKSymbolAltOne: 1,
    CJKSymbolAltTwo: 2,
    CJKSymbolAltThree: 3,
    CJKSymbolAltFour: 4,
    CJKSymbolAltFive: 5
  },
  ideographicAlternatives: {
    code: 30,
    exclusive: true,
    noIdeographicAlternatives: 0,
    ideographicAltOne: 1,
    ideographicAltTwo: 2,
    ideographicAltThree: 3,
    ideographicAltFour: 4,
    ideographicAltFive: 5
  },
  CJKVerticalRomanPlacement: {
    code: 31,
    exclusive: true,
    CJKVerticalRomanCentered: 0,
    CJKVerticalRomanHBaseline: 1
  },
  italicCJKRoman: {
    code: 32,
    exclusive: false,
    // noCJKItalicRoman: 0     # deprecated - use CJKItalicRomanOff instead
    // CJKItalicRoman: 1     # deprecated - use CJKItalicRomanOn instead
    CJKItalicRoman: 2
  },
  caseSensitiveLayout: {
    code: 33,
    exclusive: false,
    caseSensitiveLayout: 0,
    caseSensitiveSpacing: 2
  },
  alternateKana: {
    code: 34,
    exclusive: false,
    alternateHorizKana: 0,
    alternateVertKana: 2
  },
  stylisticAlternatives: {
    code: 35,
    exclusive: false,
    noStylisticAlternates: 0,
    stylisticAltOne: 2,
    stylisticAltTwo: 4,
    stylisticAltThree: 6,
    stylisticAltFour: 8,
    stylisticAltFive: 10,
    stylisticAltSix: 12,
    stylisticAltSeven: 14,
    stylisticAltEight: 16,
    stylisticAltNine: 18,
    stylisticAltTen: 20,
    stylisticAltEleven: 22,
    stylisticAltTwelve: 24,
    stylisticAltThirteen: 26,
    stylisticAltFourteen: 28,
    stylisticAltFifteen: 30,
    stylisticAltSixteen: 32,
    stylisticAltSeventeen: 34,
    stylisticAltEighteen: 36,
    stylisticAltNineteen: 38,
    stylisticAltTwenty: 40
  },
  contextualAlternates: {
    code: 36,
    exclusive: false,
    contextualAlternates: 0,
    swashAlternates: 2,
    contextualSwashAlternates: 4
  },
  lowerCase: {
    code: 37,
    exclusive: true,
    defaultLowerCase: 0,
    lowerCaseSmallCaps: 1,
    lowerCasePetiteCaps: 2
  },
  upperCase: {
    code: 38,
    exclusive: true,
    defaultUpperCase: 0,
    upperCaseSmallCaps: 1,
    upperCasePetiteCaps: 2
  },
  languageTag: {
    code: 39,
    exclusive: true
  },
  CJKRomanSpacing: {
    code: 103,
    exclusive: true,
    halfWidthCJKRoman: 0,
    proportionalCJKRoman: 1,
    defaultCJKRoman: 2,
    fullWidthCJKRoman: 3
  }
};
var $3b6302b64eccc32c$var$feature = (name, selector) => [
  $3b6302b64eccc32c$var$features[name].code,
  $3b6302b64eccc32c$var$features[name][selector]
];
var $3b6302b64eccc32c$var$OTMapping = {
  rlig: $3b6302b64eccc32c$var$feature("ligatures", "requiredLigatures"),
  clig: $3b6302b64eccc32c$var$feature("ligatures", "contextualLigatures"),
  dlig: $3b6302b64eccc32c$var$feature("ligatures", "rareLigatures"),
  hlig: $3b6302b64eccc32c$var$feature("ligatures", "historicalLigatures"),
  liga: $3b6302b64eccc32c$var$feature("ligatures", "commonLigatures"),
  hist: $3b6302b64eccc32c$var$feature("ligatures", "historicalLigatures"),
  smcp: $3b6302b64eccc32c$var$feature("lowerCase", "lowerCaseSmallCaps"),
  pcap: $3b6302b64eccc32c$var$feature("lowerCase", "lowerCasePetiteCaps"),
  frac: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
  dnom: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
  numr: $3b6302b64eccc32c$var$feature("fractions", "diagonalFractions"),
  afrc: $3b6302b64eccc32c$var$feature("fractions", "verticalFractions"),
  // aalt
  // abvf, abvm, abvs, akhn, blwf, blwm, blws, cfar, cjct, cpsp, falt, isol, jalt, ljmo, mset?
  // ltra, ltrm, nukt, pref, pres, pstf, psts, rand, rkrf, rphf, rtla, rtlm, size, tjmo, tnum?
  // unic, vatu, vhal, vjmo, vpal, vrt2
  // dist -> trak table?
  // kern, vkrn -> kern table
  // lfbd + opbd + rtbd -> opbd table?
  // mark, mkmk -> acnt table?
  // locl -> languageTag + ltag table
  case: $3b6302b64eccc32c$var$feature("caseSensitiveLayout", "caseSensitiveLayout"),
  ccmp: $3b6302b64eccc32c$var$feature("unicodeDecomposition", "canonicalComposition"),
  cpct: $3b6302b64eccc32c$var$feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
  valt: $3b6302b64eccc32c$var$feature("CJKVerticalRomanPlacement", "CJKVerticalRomanCentered"),
  swsh: $3b6302b64eccc32c$var$feature("contextualAlternates", "swashAlternates"),
  cswh: $3b6302b64eccc32c$var$feature("contextualAlternates", "contextualSwashAlternates"),
  curs: $3b6302b64eccc32c$var$feature("cursiveConnection", "cursive"),
  c2pc: $3b6302b64eccc32c$var$feature("upperCase", "upperCasePetiteCaps"),
  c2sc: $3b6302b64eccc32c$var$feature("upperCase", "upperCaseSmallCaps"),
  init: $3b6302b64eccc32c$var$feature("smartSwash", "wordInitialSwashes"),
  fin2: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
  medi: $3b6302b64eccc32c$var$feature("smartSwash", "nonFinalSwashes"),
  med2: $3b6302b64eccc32c$var$feature("smartSwash", "nonFinalSwashes"),
  fin3: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
  fina: $3b6302b64eccc32c$var$feature("smartSwash", "wordFinalSwashes"),
  pkna: $3b6302b64eccc32c$var$feature("kanaSpacing", "proportionalKana"),
  half: $3b6302b64eccc32c$var$feature("textSpacing", "halfWidthText"),
  halt: $3b6302b64eccc32c$var$feature("textSpacing", "altHalfWidthText"),
  hkna: $3b6302b64eccc32c$var$feature("alternateKana", "alternateHorizKana"),
  vkna: $3b6302b64eccc32c$var$feature("alternateKana", "alternateVertKana"),
  // hngl: feature 'transliteration', 'hanjaToHangulSelector' # deprecated
  ital: $3b6302b64eccc32c$var$feature("italicCJKRoman", "CJKItalicRoman"),
  lnum: $3b6302b64eccc32c$var$feature("numberCase", "upperCaseNumbers"),
  onum: $3b6302b64eccc32c$var$feature("numberCase", "lowerCaseNumbers"),
  mgrk: $3b6302b64eccc32c$var$feature("mathematicalExtras", "mathematicalGreek"),
  // nalt: not enough info. what type of annotation?
  // ornm: ditto, which ornament style?
  calt: $3b6302b64eccc32c$var$feature("contextualAlternates", "contextualAlternates"),
  vrt2: $3b6302b64eccc32c$var$feature("verticalSubstitution", "substituteVerticalForms"),
  vert: $3b6302b64eccc32c$var$feature("verticalSubstitution", "substituteVerticalForms"),
  tnum: $3b6302b64eccc32c$var$feature("numberSpacing", "monospacedNumbers"),
  pnum: $3b6302b64eccc32c$var$feature("numberSpacing", "proportionalNumbers"),
  sups: $3b6302b64eccc32c$var$feature("verticalPosition", "superiors"),
  subs: $3b6302b64eccc32c$var$feature("verticalPosition", "inferiors"),
  ordn: $3b6302b64eccc32c$var$feature("verticalPosition", "ordinals"),
  pwid: $3b6302b64eccc32c$var$feature("textSpacing", "proportionalText"),
  hwid: $3b6302b64eccc32c$var$feature("textSpacing", "halfWidthText"),
  qwid: $3b6302b64eccc32c$var$feature("textSpacing", "quarterWidthText"),
  twid: $3b6302b64eccc32c$var$feature("textSpacing", "thirdWidthText"),
  fwid: $3b6302b64eccc32c$var$feature("textSpacing", "proportionalText"),
  palt: $3b6302b64eccc32c$var$feature("textSpacing", "altProportionalText"),
  trad: $3b6302b64eccc32c$var$feature("characterShape", "traditionalCharacters"),
  smpl: $3b6302b64eccc32c$var$feature("characterShape", "simplifiedCharacters"),
  jp78: $3b6302b64eccc32c$var$feature("characterShape", "JIS1978Characters"),
  jp83: $3b6302b64eccc32c$var$feature("characterShape", "JIS1983Characters"),
  jp90: $3b6302b64eccc32c$var$feature("characterShape", "JIS1990Characters"),
  jp04: $3b6302b64eccc32c$var$feature("characterShape", "JIS2004Characters"),
  expt: $3b6302b64eccc32c$var$feature("characterShape", "expertCharacters"),
  hojo: $3b6302b64eccc32c$var$feature("characterShape", "hojoCharacters"),
  nlck: $3b6302b64eccc32c$var$feature("characterShape", "NLCCharacters"),
  tnam: $3b6302b64eccc32c$var$feature("characterShape", "traditionalNamesCharacters"),
  ruby: $3b6302b64eccc32c$var$feature("rubyKana", "rubyKana"),
  titl: $3b6302b64eccc32c$var$feature("styleOptions", "titlingCaps"),
  zero: $3b6302b64eccc32c$var$feature("typographicExtras", "slashedZero"),
  ss01: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltOne"),
  ss02: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwo"),
  ss03: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltThree"),
  ss04: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFour"),
  ss05: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFive"),
  ss06: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSix"),
  ss07: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSeven"),
  ss08: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEight"),
  ss09: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltNine"),
  ss10: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTen"),
  ss11: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEleven"),
  ss12: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwelve"),
  ss13: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltThirteen"),
  ss14: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFourteen"),
  ss15: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltFifteen"),
  ss16: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSixteen"),
  ss17: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltSeventeen"),
  ss18: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltEighteen"),
  ss19: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltNineteen"),
  ss20: $3b6302b64eccc32c$var$feature("stylisticAlternatives", "stylisticAltTwenty")
};
for (let i = 1; i <= 99; i++)
  $3b6302b64eccc32c$var$OTMapping[`cv${`00${i}`.slice(-2)}`] = [
    $3b6302b64eccc32c$var$features.characterAlternatives.code,
    i
  ];
var $3b6302b64eccc32c$var$AATMapping = {};
for (let ot in $3b6302b64eccc32c$var$OTMapping) {
  let aat = $3b6302b64eccc32c$var$OTMapping[ot];
  if ($3b6302b64eccc32c$var$AATMapping[aat[0]] == null)
    $3b6302b64eccc32c$var$AATMapping[aat[0]] = {};
  $3b6302b64eccc32c$var$AATMapping[aat[0]][aat[1]] = ot;
}
function $3b6302b64eccc32c$export$b813f7d2a1677c16(features1) {
  let res = {};
  for (let k in features1) {
    let r;
    if (r = $3b6302b64eccc32c$var$OTMapping[k]) {
      if (res[r[0]] == null)
        res[r[0]] = {};
      res[r[0]][r[1]] = features1[k];
    }
  }
  return res;
}
function $3b6302b64eccc32c$var$mapFeatureStrings(f) {
  let [type, setting] = f;
  if (isNaN(type))
    var typeCode = $3b6302b64eccc32c$var$features[type] && $3b6302b64eccc32c$var$features[type].code;
  else
    var typeCode = type;
  if (isNaN(setting))
    var settingCode = $3b6302b64eccc32c$var$features[type] && $3b6302b64eccc32c$var$features[type][setting];
  else
    var settingCode = setting;
  return [
    typeCode,
    settingCode
  ];
}
function $3b6302b64eccc32c$export$bd6df347a4f391c4(features2) {
  let res = {};
  if (Array.isArray(features2))
    for (let k = 0; k < features2.length; k++) {
      let r;
      let f = $3b6302b64eccc32c$var$mapFeatureStrings(features2[k]);
      if (r = $3b6302b64eccc32c$var$AATMapping[f[0]] && $3b6302b64eccc32c$var$AATMapping[f[0]][f[1]])
        res[r] = true;
    }
  else if (typeof features2 === "object")
    for (let type in features2) {
      let feature1 = features2[type];
      for (let setting in feature1) {
        let r;
        let f = $3b6302b64eccc32c$var$mapFeatureStrings([
          type,
          setting
        ]);
        if (feature1[setting] && (r = $3b6302b64eccc32c$var$AATMapping[f[0]] && $3b6302b64eccc32c$var$AATMapping[f[0]][f[1]]))
          res[r] = true;
      }
    }
  return Object.keys(res);
}
var $ff5ce077dae0f144$export$2e2bcd8739ae039 = class {
  lookup(glyph) {
    switch (this.table.version) {
      case 0:
        return this.table.values.getItem(glyph);
      case 2:
      case 4: {
        let min3 = 0;
        let max3 = this.table.binarySearchHeader.nUnits - 1;
        while (min3 <= max3) {
          var mid = min3 + max3 >> 1;
          var seg = this.table.segments[mid];
          if (seg.firstGlyph === 65535)
            return null;
          if (glyph < seg.firstGlyph)
            max3 = mid - 1;
          else if (glyph > seg.lastGlyph)
            min3 = mid + 1;
          else {
            if (this.table.version === 2)
              return seg.value;
            else
              return seg.values[glyph - seg.firstGlyph];
          }
        }
        return null;
      }
      case 6: {
        let min3 = 0;
        let max3 = this.table.binarySearchHeader.nUnits - 1;
        while (min3 <= max3) {
          var mid = min3 + max3 >> 1;
          var seg = this.table.segments[mid];
          if (seg.glyph === 65535)
            return null;
          if (glyph < seg.glyph)
            max3 = mid - 1;
          else if (glyph > seg.glyph)
            min3 = mid + 1;
          else
            return seg.value;
        }
        return null;
      }
      case 8:
        return this.table.values[glyph - this.table.firstGlyph];
      default:
        throw new Error(`Unknown lookup table format: ${this.table.version}`);
    }
  }
  glyphsForValue(classValue) {
    let res = [];
    switch (this.table.version) {
      case 2:
      case 4:
        for (let segment of this.table.segments)
          if (this.table.version === 2 && segment.value === classValue)
            res.push(...(0, $12727730ddfc8bfe$export$d02631cccf789723)(segment.firstGlyph, segment.lastGlyph + 1));
          else {
            for (let index3 = 0; index3 < segment.values.length; index3++)
              if (segment.values[index3] === classValue)
                res.push(segment.firstGlyph + index3);
          }
        break;
      case 6:
        for (let segment1 of this.table.segments)
          if (segment1.value === classValue)
            res.push(segment1.glyph);
        break;
      case 8:
        for (let i = 0; i < this.table.values.length; i++)
          if (this.table.values[i] === classValue)
            res.push(this.table.firstGlyph + i);
        break;
      default:
        throw new Error(`Unknown lookup table format: ${this.table.version}`);
    }
    return res;
  }
  constructor(table) {
    this.table = table;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $ff5ce077dae0f144$export$2e2bcd8739ae039.prototype, "glyphsForValue", null);
var $50c7aac9316f2948$var$START_OF_TEXT_STATE = 0;
var $50c7aac9316f2948$var$END_OF_TEXT_CLASS = 0;
var $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS = 1;
var $50c7aac9316f2948$var$DELETED_GLYPH_CLASS = 2;
var $50c7aac9316f2948$var$DONT_ADVANCE = 16384;
var $50c7aac9316f2948$export$2e2bcd8739ae039 = class {
  process(glyphs, reverse5, processEntry) {
    let currentState = $50c7aac9316f2948$var$START_OF_TEXT_STATE;
    let index3 = reverse5 ? glyphs.length - 1 : 0;
    let dir = reverse5 ? -1 : 1;
    while (dir === 1 && index3 <= glyphs.length || dir === -1 && index3 >= -1) {
      let glyph = null;
      let classCode = $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS;
      let shouldAdvance = true;
      if (index3 === glyphs.length || index3 === -1)
        classCode = $50c7aac9316f2948$var$END_OF_TEXT_CLASS;
      else {
        glyph = glyphs[index3];
        if (glyph.id === 65535)
          classCode = $50c7aac9316f2948$var$DELETED_GLYPH_CLASS;
        else {
          classCode = this.lookupTable.lookup(glyph.id);
          if (classCode == null)
            classCode = $50c7aac9316f2948$var$OUT_OF_BOUNDS_CLASS;
        }
      }
      let row = this.stateTable.stateArray.getItem(currentState);
      let entryIndex = row[classCode];
      let entry = this.stateTable.entryTable.getItem(entryIndex);
      if (classCode !== $50c7aac9316f2948$var$END_OF_TEXT_CLASS && classCode !== $50c7aac9316f2948$var$DELETED_GLYPH_CLASS) {
        processEntry(glyph, entry, index3);
        shouldAdvance = !(entry.flags & $50c7aac9316f2948$var$DONT_ADVANCE);
      }
      currentState = entry.newState;
      if (shouldAdvance)
        index3 += dir;
    }
    return glyphs;
  }
  /**
  * Performs a depth-first traversal of the glyph strings
  * represented by the state machine.
  */
  traverse(opts2, state2 = 0, visited = /* @__PURE__ */ new Set()) {
    if (visited.has(state2))
      return;
    visited.add(state2);
    let { nClasses, stateArray, entryTable } = this.stateTable;
    let row = stateArray.getItem(state2);
    for (let classCode = 4; classCode < nClasses; classCode++) {
      let entryIndex = row[classCode];
      let entry = entryTable.getItem(entryIndex);
      for (let glyph of this.lookupTable.glyphsForValue(classCode)) {
        if (opts2.enter)
          opts2.enter(glyph, entry);
        if (entry.newState !== 0)
          this.traverse(opts2, entry.newState, visited);
        if (opts2.exit)
          opts2.exit(glyph, entry);
      }
    }
  }
  constructor(stateTable) {
    this.stateTable = stateTable;
    this.lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(stateTable.classTable);
  }
};
var $55f71433a605c87d$var$MARK_FIRST = 32768;
var $55f71433a605c87d$var$MARK_LAST = 8192;
var $55f71433a605c87d$var$VERB = 15;
var $55f71433a605c87d$var$SET_MARK = 32768;
var $55f71433a605c87d$var$SET_COMPONENT = 32768;
var $55f71433a605c87d$var$PERFORM_ACTION = 8192;
var $55f71433a605c87d$var$LAST_MASK = 2147483648;
var $55f71433a605c87d$var$STORE_MASK = 1073741824;
var $55f71433a605c87d$var$OFFSET_MASK = 1073741823;
var $55f71433a605c87d$var$REVERSE_DIRECTION = 4194304;
var $55f71433a605c87d$var$CURRENT_INSERT_BEFORE = 2048;
var $55f71433a605c87d$var$MARKED_INSERT_BEFORE = 1024;
var $55f71433a605c87d$var$CURRENT_INSERT_COUNT = 992;
var $55f71433a605c87d$var$MARKED_INSERT_COUNT = 31;
var $55f71433a605c87d$export$2e2bcd8739ae039 = class {
  // Processes an array of glyphs and applies the specified features
  // Features should be in the form of {featureType:{featureSetting:boolean}}
  process(glyphs, features = {}) {
    for (let chain of this.morx.chains) {
      let flags = chain.defaultFlags;
      for (let feature of chain.features) {
        let f;
        if (f = features[feature.featureType]) {
          if (f[feature.featureSetting]) {
            flags &= feature.disableFlags;
            flags |= feature.enableFlags;
          } else if (f[feature.featureSetting] === false) {
            flags |= ~feature.disableFlags;
            flags &= ~feature.enableFlags;
          }
        }
      }
      for (let subtable of chain.subtables)
        if (subtable.subFeatureFlags & flags)
          this.processSubtable(subtable, glyphs);
    }
    let index3 = glyphs.length - 1;
    while (index3 >= 0) {
      if (glyphs[index3].id === 65535)
        glyphs.splice(index3, 1);
      index3--;
    }
    return glyphs;
  }
  processSubtable(subtable, glyphs) {
    this.subtable = subtable;
    this.glyphs = glyphs;
    if (this.subtable.type === 4) {
      this.processNoncontextualSubstitutions(this.subtable, this.glyphs);
      return;
    }
    this.ligatureStack = [];
    this.markedGlyph = null;
    this.firstGlyph = null;
    this.lastGlyph = null;
    this.markedIndex = null;
    let stateMachine = this.getStateMachine(subtable);
    let process3 = this.getProcessor();
    let reverse5 = !!(this.subtable.coverage & $55f71433a605c87d$var$REVERSE_DIRECTION);
    return stateMachine.process(this.glyphs, reverse5, process3);
  }
  getStateMachine(subtable) {
    return new (0, $50c7aac9316f2948$export$2e2bcd8739ae039)(subtable.table.stateTable);
  }
  getProcessor() {
    switch (this.subtable.type) {
      case 0:
        return this.processIndicRearragement;
      case 1:
        return this.processContextualSubstitution;
      case 2:
        return this.processLigature;
      case 4:
        return this.processNoncontextualSubstitutions;
      case 5:
        return this.processGlyphInsertion;
      default:
        throw new Error(`Invalid morx subtable type: ${this.subtable.type}`);
    }
  }
  processIndicRearragement(glyph, entry, index3) {
    if (entry.flags & $55f71433a605c87d$var$MARK_FIRST)
      this.firstGlyph = index3;
    if (entry.flags & $55f71433a605c87d$var$MARK_LAST)
      this.lastGlyph = index3;
    $55f71433a605c87d$var$reorderGlyphs(this.glyphs, entry.flags & $55f71433a605c87d$var$VERB, this.firstGlyph, this.lastGlyph);
  }
  processContextualSubstitution(glyph, entry, index3) {
    let subsitutions = this.subtable.table.substitutionTable.items;
    if (entry.markIndex !== 65535) {
      let lookup4 = subsitutions.getItem(entry.markIndex);
      let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(lookup4);
      glyph = this.glyphs[this.markedGlyph];
      var gid = lookupTable.lookup(glyph.id);
      if (gid)
        this.glyphs[this.markedGlyph] = this.font.getGlyph(gid, glyph.codePoints);
    }
    if (entry.currentIndex !== 65535) {
      let lookup4 = subsitutions.getItem(entry.currentIndex);
      let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(lookup4);
      glyph = this.glyphs[index3];
      var gid = lookupTable.lookup(glyph.id);
      if (gid)
        this.glyphs[index3] = this.font.getGlyph(gid, glyph.codePoints);
    }
    if (entry.flags & $55f71433a605c87d$var$SET_MARK)
      this.markedGlyph = index3;
  }
  processLigature(glyph, entry, index3) {
    if (entry.flags & $55f71433a605c87d$var$SET_COMPONENT)
      this.ligatureStack.push(index3);
    if (entry.flags & $55f71433a605c87d$var$PERFORM_ACTION) {
      let actions = this.subtable.table.ligatureActions;
      let components = this.subtable.table.components;
      let ligatureList = this.subtable.table.ligatureList;
      let actionIndex = entry.action;
      let last3 = false;
      let ligatureIndex = 0;
      let codePoints = [];
      let ligatureGlyphs = [];
      while (!last3) {
        let componentGlyph = this.ligatureStack.pop();
        codePoints.unshift(...this.glyphs[componentGlyph].codePoints);
        let action = actions.getItem(actionIndex++);
        last3 = !!(action & $55f71433a605c87d$var$LAST_MASK);
        let store = !!(action & $55f71433a605c87d$var$STORE_MASK);
        let offset3 = (action & $55f71433a605c87d$var$OFFSET_MASK) << 2 >> 2;
        offset3 += this.glyphs[componentGlyph].id;
        let component = components.getItem(offset3);
        ligatureIndex += component;
        if (last3 || store) {
          let ligatureEntry = ligatureList.getItem(ligatureIndex);
          this.glyphs[componentGlyph] = this.font.getGlyph(ligatureEntry, codePoints);
          ligatureGlyphs.push(componentGlyph);
          ligatureIndex = 0;
          codePoints = [];
        } else
          this.glyphs[componentGlyph] = this.font.getGlyph(65535);
      }
      this.ligatureStack.push(...ligatureGlyphs);
    }
  }
  processNoncontextualSubstitutions(subtable, glyphs, index3) {
    let lookupTable = new (0, $ff5ce077dae0f144$export$2e2bcd8739ae039)(subtable.table.lookupTable);
    for (index3 = 0; index3 < glyphs.length; index3++) {
      let glyph = glyphs[index3];
      if (glyph.id !== 65535) {
        let gid = lookupTable.lookup(glyph.id);
        if (gid)
          glyphs[index3] = this.font.getGlyph(gid, glyph.codePoints);
      }
    }
  }
  _insertGlyphs(glyphIndex, insertionActionIndex, count, isBefore) {
    let insertions = [];
    while (count--) {
      let gid = this.subtable.table.insertionActions.getItem(insertionActionIndex++);
      insertions.push(this.font.getGlyph(gid));
    }
    if (!isBefore)
      glyphIndex++;
    this.glyphs.splice(glyphIndex, 0, ...insertions);
  }
  processGlyphInsertion(glyph, entry, index3) {
    if (entry.flags & $55f71433a605c87d$var$SET_MARK)
      this.markedIndex = index3;
    if (entry.markedInsertIndex !== 65535) {
      let count = (entry.flags & $55f71433a605c87d$var$MARKED_INSERT_COUNT) >>> 5;
      let isBefore = !!(entry.flags & $55f71433a605c87d$var$MARKED_INSERT_BEFORE);
      this._insertGlyphs(this.markedIndex, entry.markedInsertIndex, count, isBefore);
    }
    if (entry.currentInsertIndex !== 65535) {
      let count = (entry.flags & $55f71433a605c87d$var$CURRENT_INSERT_COUNT) >>> 5;
      let isBefore = !!(entry.flags & $55f71433a605c87d$var$CURRENT_INSERT_BEFORE);
      this._insertGlyphs(index3, entry.currentInsertIndex, count, isBefore);
    }
  }
  getSupportedFeatures() {
    let features = [];
    for (let chain of this.morx.chains)
      for (let feature of chain.features)
        features.push([
          feature.featureType,
          feature.featureSetting
        ]);
    return features;
  }
  generateInputs(gid) {
    if (!this.inputCache)
      this.generateInputCache();
    return this.inputCache[gid] || [];
  }
  generateInputCache() {
    this.inputCache = {};
    for (let chain of this.morx.chains) {
      let flags = chain.defaultFlags;
      for (let subtable of chain.subtables)
        if (subtable.subFeatureFlags & flags)
          this.generateInputsForSubtable(subtable);
    }
  }
  generateInputsForSubtable(subtable) {
    if (subtable.type !== 2)
      return;
    let reverse5 = !!(subtable.coverage & $55f71433a605c87d$var$REVERSE_DIRECTION);
    if (reverse5)
      throw new Error("Reverse subtable, not supported.");
    this.subtable = subtable;
    this.ligatureStack = [];
    let stateMachine = this.getStateMachine(subtable);
    let process3 = this.getProcessor();
    let input = [];
    let stack = [];
    this.glyphs = [];
    stateMachine.traverse({
      enter: (glyph, entry) => {
        let glyphs = this.glyphs;
        stack.push({
          glyphs: glyphs.slice(),
          ligatureStack: this.ligatureStack.slice()
        });
        let g1 = this.font.getGlyph(glyph);
        input.push(g1);
        glyphs.push(input[input.length - 1]);
        process3(glyphs[glyphs.length - 1], entry, glyphs.length - 1);
        let count = 0;
        let found = 0;
        for (let i = 0; i < glyphs.length && count <= 1; i++)
          if (glyphs[i].id !== 65535) {
            count++;
            found = glyphs[i].id;
          }
        if (count === 1) {
          let result = input.map((g3) => g3.id);
          let cache1 = this.inputCache[found];
          if (cache1)
            cache1.push(result);
          else
            this.inputCache[found] = [
              result
            ];
        }
      },
      exit: () => {
        ({ glyphs: this.glyphs, ligatureStack: this.ligatureStack } = stack.pop());
        input.pop();
      }
    });
  }
  constructor(font2) {
    this.processIndicRearragement = this.processIndicRearragement.bind(this);
    this.processContextualSubstitution = this.processContextualSubstitution.bind(this);
    this.processLigature = this.processLigature.bind(this);
    this.processNoncontextualSubstitutions = this.processNoncontextualSubstitutions.bind(this);
    this.processGlyphInsertion = this.processGlyphInsertion.bind(this);
    this.font = font2;
    this.morx = font2.morx;
    this.inputCache = null;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $55f71433a605c87d$export$2e2bcd8739ae039.prototype, "getStateMachine", null);
function $55f71433a605c87d$var$swap(glyphs, rangeA, rangeB, reverseA = false, reverseB = false) {
  let end3 = glyphs.splice(rangeB[0] - (rangeB[1] - 1), rangeB[1]);
  if (reverseB)
    end3.reverse();
  let start3 = glyphs.splice(rangeA[0], rangeA[1], ...end3);
  if (reverseA)
    start3.reverse();
  glyphs.splice(rangeB[0] - (rangeA[1] - 1), 0, ...start3);
  return glyphs;
}
function $55f71433a605c87d$var$reorderGlyphs(glyphs, verb, firstGlyph, lastGlyph) {
  let length4 = lastGlyph - firstGlyph + 1;
  switch (verb) {
    case 0:
      return glyphs;
    case 1:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        0
      ]);
    case 2:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        0
      ], [
        lastGlyph,
        1
      ]);
    case 3:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        1
      ]);
    case 4:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        0
      ]);
    case 5:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        0
      ], true, false);
    case 6:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        0
      ], [
        lastGlyph,
        2
      ]);
    case 7:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        0
      ], [
        lastGlyph,
        2
      ], false, true);
    case 8:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        2
      ]);
    case 9:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        1
      ], [
        lastGlyph,
        2
      ], false, true);
    case 10:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        1
      ]);
    case 11:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        1
      ], true, false);
    case 12:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ]);
    case 13:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ], true, false);
    case 14:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ], false, true);
    case 15:
      return $55f71433a605c87d$var$swap(glyphs, [
        firstGlyph,
        2
      ], [
        lastGlyph,
        2
      ], true, true);
    default:
      throw new Error(`Unknown verb: ${verb}`);
  }
}
var $ba6dd74203be8728$export$2e2bcd8739ae039 = class {
  substitute(glyphRun) {
    if (glyphRun.direction === "rtl")
      glyphRun.glyphs.reverse();
    this.morxProcessor.process(glyphRun.glyphs, $3b6302b64eccc32c$export$b813f7d2a1677c16(glyphRun.features));
  }
  getAvailableFeatures(script, language) {
    return $3b6302b64eccc32c$export$bd6df347a4f391c4(this.morxProcessor.getSupportedFeatures());
  }
  stringsForGlyph(gid) {
    let glyphStrings = this.morxProcessor.generateInputs(gid);
    let result = /* @__PURE__ */ new Set();
    for (let glyphs of glyphStrings)
      this._addStrings(glyphs, 0, result, "");
    return result;
  }
  _addStrings(glyphs, index3, strings, string) {
    let codePoints = this.font._cmapProcessor.codePointsForGlyph(glyphs[index3]);
    for (let codePoint of codePoints) {
      let s2 = string + String.fromCodePoint(codePoint);
      if (index3 < glyphs.length - 1)
        this._addStrings(glyphs, index3 + 1, strings, s2);
      else
        strings.add(s2);
    }
  }
  constructor(font2) {
    this.font = font2;
    this.morxProcessor = new (0, $55f71433a605c87d$export$2e2bcd8739ae039)(font2);
    this.fallbackPosition = false;
  }
};
var $94d7a73bd2edfc9a$export$2e2bcd8739ae039 = class {
  /**
  * Adds the given features to the last stage.
  * Ignores features that have already been applied.
  */
  _addFeatures(features, global2) {
    let stageIndex = this.stages.length - 1;
    let stage = this.stages[stageIndex];
    for (let feature of features)
      if (this.allFeatures[feature] == null) {
        stage.push(feature);
        this.allFeatures[feature] = stageIndex;
        if (global2)
          this.globalFeatures[feature] = true;
      }
  }
  /**
  * Add features to the last stage
  */
  add(arg, global2 = true) {
    if (this.stages.length === 0)
      this.stages.push([]);
    if (typeof arg === "string")
      arg = [
        arg
      ];
    if (Array.isArray(arg))
      this._addFeatures(arg, global2);
    else if (typeof arg === "object") {
      this._addFeatures(arg.global || [], true);
      this._addFeatures(arg.local || [], false);
    } else
      throw new Error("Unsupported argument to ShapingPlan#add");
  }
  /**
  * Add a new stage
  */
  addStage(arg, global2) {
    if (typeof arg === "function")
      this.stages.push(arg, []);
    else {
      this.stages.push([]);
      this.add(arg, global2);
    }
  }
  setFeatureOverrides(features) {
    if (Array.isArray(features))
      this.add(features);
    else if (typeof features === "object")
      for (let tag in features) {
        if (features[tag])
          this.add(tag);
        else if (this.allFeatures[tag] != null) {
          let stage = this.stages[this.allFeatures[tag]];
          stage.splice(stage.indexOf(tag), 1);
          delete this.allFeatures[tag];
          delete this.globalFeatures[tag];
        }
      }
  }
  /**
  * Assigns the global features to the given glyphs
  */
  assignGlobalFeatures(glyphs) {
    for (let glyph of glyphs)
      for (let feature in this.globalFeatures)
        glyph.features[feature] = true;
  }
  /**
  * Executes the planned stages using the given OTProcessor
  */
  process(processor, glyphs, positions) {
    for (let stage of this.stages) {
      if (typeof stage === "function") {
        if (!positions)
          stage(this.font, glyphs, this);
      } else if (stage.length > 0)
        processor.applyFeatures(stage, glyphs, positions);
    }
  }
  constructor(font2, script, direction) {
    this.font = font2;
    this.script = script;
    this.direction = direction;
    this.stages = [];
    this.globalFeatures = {};
    this.allFeatures = {};
  }
};
var $649970d87335b30f$var$VARIATION_FEATURES = [
  "rvrn"
];
var $649970d87335b30f$var$COMMON_FEATURES = [
  "ccmp",
  "locl",
  "rlig",
  "mark",
  "mkmk"
];
var $649970d87335b30f$var$FRACTIONAL_FEATURES = [
  "frac",
  "numr",
  "dnom"
];
var $649970d87335b30f$var$HORIZONTAL_FEATURES = [
  "calt",
  "clig",
  "liga",
  "rclt",
  "curs",
  "kern"
];
var $649970d87335b30f$var$DIRECTIONAL_FEATURES = {
  ltr: [
    "ltra",
    "ltrm"
  ],
  rtl: [
    "rtla",
    "rtlm"
  ]
};
var $649970d87335b30f$export$2e2bcd8739ae039 = class {
  static plan(plan, glyphs, features) {
    this.planPreprocessing(plan);
    this.planFeatures(plan);
    this.planPostprocessing(plan, features);
    plan.assignGlobalFeatures(glyphs);
    this.assignFeatures(plan, glyphs);
  }
  static planPreprocessing(plan) {
    plan.add({
      global: [
        ...$649970d87335b30f$var$VARIATION_FEATURES,
        ...$649970d87335b30f$var$DIRECTIONAL_FEATURES[plan.direction]
      ],
      local: $649970d87335b30f$var$FRACTIONAL_FEATURES
    });
  }
  static planFeatures(plan) {
  }
  static planPostprocessing(plan, userFeatures) {
    plan.add([
      ...$649970d87335b30f$var$COMMON_FEATURES,
      ...$649970d87335b30f$var$HORIZONTAL_FEATURES
    ]);
    plan.setFeatureOverrides(userFeatures);
  }
  static assignFeatures(plan, glyphs) {
    for (let i = 0; i < glyphs.length; i++) {
      let glyph = glyphs[i];
      if (glyph.codePoints[0] === 8260) {
        let start3 = i;
        let end3 = i + 1;
        while (start3 > 0 && (0, $747425b437e121da$export$727d9dbc4fbb948f)(glyphs[start3 - 1].codePoints[0])) {
          glyphs[start3 - 1].features.numr = true;
          glyphs[start3 - 1].features.frac = true;
          start3--;
        }
        while (end3 < glyphs.length && (0, $747425b437e121da$export$727d9dbc4fbb948f)(glyphs[end3].codePoints[0])) {
          glyphs[end3].features.dnom = true;
          glyphs[end3].features.frac = true;
          end3++;
        }
        glyph.features.frac = true;
        i = end3 - 1;
      }
    }
  }
};
(0, _defineProperty)($649970d87335b30f$export$2e2bcd8739ae039, "zeroMarkWidths", "AFTER_GPOS");
var $764eb544bbe1ccf0$var$trie = new (0, import_unicode_trie2.default)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)("ABABAAAAAACgMQAAAZUBav7t2CtPA0EUBeDZB00pin9AJZIEgyUEj0QhweDAgQOJxCBRBElQSBwSicLgkOAwnNKZ5GaY2c7uzj4o5yZfZrrbefbuIx2nSq3CGmzAWH/+K+UO7MIe7MMhHMMpnMMFXMIVXIt2t3CnP088iPqjqNN8e4Ij7Rle4LUH82rLm6i/92A+RERERERERERNmfz/89GDeRARERERzbN8ceps2Iwt9H0C9/AJ6yOlDkbTczcot5VSm8Pm1vcFWfb7+BKOLTuOd2UlTX4wGP85Eg953lWPFbnuN7PkjtLmalOWbNenkHOSa7T3KmR9MVTZ2zZkVj1kHa68MueVKH0R4zqQ44WEXLM8VjcWHP0PtKLfPzQnMtGn3W4QYf6qxFxceVI394r2xnV+1rih0fV1Vzf3fO1n3evL5J78ruvZ5ptX2Rwy92Tfb1wlEqut3U+sZ3HXOeJ7/zDrbyuP6+Zz0fqa6Nv3vhY7Yu1xWnGevmsvsUpTT/RYIe8waUH/rvHMWKFzLfN8L+rTfp645mfX7ftlnfDtYxN59w0="));
var $764eb544bbe1ccf0$var$FEATURES = [
  "isol",
  "fina",
  "fin2",
  "fin3",
  "medi",
  "med2",
  "init"
];
var $764eb544bbe1ccf0$var$ShapingClasses = {
  Non_Joining: 0,
  Left_Joining: 1,
  Right_Joining: 2,
  Dual_Joining: 3,
  Join_Causing: 3,
  ALAPH: 4,
  "DALATH RISH": 5,
  Transparent: 6
};
var $764eb544bbe1ccf0$var$ISOL = "isol";
var $764eb544bbe1ccf0$var$FINA = "fina";
var $764eb544bbe1ccf0$var$FIN2 = "fin2";
var $764eb544bbe1ccf0$var$FIN3 = "fin3";
var $764eb544bbe1ccf0$var$MEDI = "medi";
var $764eb544bbe1ccf0$var$MED2 = "med2";
var $764eb544bbe1ccf0$var$INIT = "init";
var $764eb544bbe1ccf0$var$NONE = null;
var $764eb544bbe1ccf0$var$STATE_TABLE = [
  //   Non_Joining,        Left_Joining,       Right_Joining,     Dual_Joining,           ALAPH,            DALATH RISH
  // State 0: prev was U,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 1: prev was R or ISOL/ALAPH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$FIN2,
      5
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 2: prev was D/L in ISOL form,  willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      1
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      3
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      4
    ],
    [
      $764eb544bbe1ccf0$var$INIT,
      $764eb544bbe1ccf0$var$FINA,
      6
    ]
  ],
  // State 3: prev was D in FINA form,  willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      1
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      3
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      4
    ],
    [
      $764eb544bbe1ccf0$var$MEDI,
      $764eb544bbe1ccf0$var$FINA,
      6
    ]
  ],
  // State 4: prev was FINA ALAPH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$FIN2,
      5
    ],
    [
      $764eb544bbe1ccf0$var$MED2,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 5: prev was FIN2/FIN3 ALAPH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$FIN2,
      5
    ],
    [
      $764eb544bbe1ccf0$var$ISOL,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ],
  // State 6: prev was DALATH/RISH,  not willing to join.
  [
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$NONE,
      0
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      1
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      2
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$FIN3,
      5
    ],
    [
      $764eb544bbe1ccf0$var$NONE,
      $764eb544bbe1ccf0$var$ISOL,
      6
    ]
  ]
];
var $764eb544bbe1ccf0$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static planFeatures(plan) {
    plan.add([
      "ccmp",
      "locl"
    ]);
    for (let i = 0; i < $764eb544bbe1ccf0$var$FEATURES.length; i++) {
      let feature = $764eb544bbe1ccf0$var$FEATURES[i];
      plan.addStage(feature, false);
    }
    plan.addStage("mset");
  }
  static assignFeatures(plan, glyphs) {
    super.assignFeatures(plan, glyphs);
    let prev = -1;
    let state2 = 0;
    let actions = [];
    for (let i = 0; i < glyphs.length; i++) {
      let curAction, prevAction;
      var glyph = glyphs[i];
      let type = $764eb544bbe1ccf0$var$getShapingClass(glyph.codePoints[0]);
      if (type === $764eb544bbe1ccf0$var$ShapingClasses.Transparent) {
        actions[i] = $764eb544bbe1ccf0$var$NONE;
        continue;
      }
      [prevAction, curAction, state2] = $764eb544bbe1ccf0$var$STATE_TABLE[state2][type];
      if (prevAction !== $764eb544bbe1ccf0$var$NONE && prev !== -1)
        actions[prev] = prevAction;
      actions[i] = curAction;
      prev = i;
    }
    for (let index3 = 0; index3 < glyphs.length; index3++) {
      let feature;
      var glyph = glyphs[index3];
      if (feature = actions[index3])
        glyph.features[feature] = true;
    }
  }
};
function $764eb544bbe1ccf0$var$getShapingClass(codePoint) {
  let res = $764eb544bbe1ccf0$var$trie.get(codePoint);
  if (res)
    return res - 1;
  let category = (0, $747425b437e121da$export$410364bbb673ddbc)(codePoint);
  if (category === "Mn" || category === "Me" || category === "Cf")
    return $764eb544bbe1ccf0$var$ShapingClasses.Transparent;
  return $764eb544bbe1ccf0$var$ShapingClasses.Non_Joining;
}
var $85d408632270248b$export$2e2bcd8739ae039 = class {
  reset(options = {}, index3 = 0) {
    this.options = options;
    this.flags = options.flags || {};
    this.markAttachmentType = options.markAttachmentType || 0;
    this.index = index3;
  }
  get cur() {
    return this.glyphs[this.index] || null;
  }
  shouldIgnore(glyph) {
    return this.flags.ignoreMarks && glyph.isMark || this.flags.ignoreBaseGlyphs && glyph.isBase || this.flags.ignoreLigatures && glyph.isLigature || this.markAttachmentType && glyph.isMark && glyph.markAttachmentType !== this.markAttachmentType;
  }
  move(dir) {
    this.index += dir;
    while (0 <= this.index && this.index < this.glyphs.length && this.shouldIgnore(this.glyphs[this.index]))
      this.index += dir;
    if (0 > this.index || this.index >= this.glyphs.length)
      return null;
    return this.glyphs[this.index];
  }
  next() {
    return this.move(1);
  }
  prev() {
    return this.move(-1);
  }
  peek(count = 1) {
    let idx = this.index;
    let res = this.increment(count);
    this.index = idx;
    return res;
  }
  peekIndex(count = 1) {
    let idx = this.index;
    this.increment(count);
    let res = this.index;
    this.index = idx;
    return res;
  }
  increment(count = 1) {
    let dir = count < 0 ? -1 : 1;
    count = Math.abs(count);
    while (count--)
      this.move(dir);
    return this.glyphs[this.index];
  }
  constructor(glyphs, options) {
    this.glyphs = glyphs;
    this.reset(options);
  }
};
var $a83b9c36aaa94fd3$var$DEFAULT_SCRIPTS = [
  "DFLT",
  "dflt",
  "latn"
];
var $a83b9c36aaa94fd3$export$2e2bcd8739ae039 = class {
  findScript(script) {
    if (this.table.scriptList == null)
      return null;
    if (!Array.isArray(script))
      script = [
        script
      ];
    for (let s2 of script)
      for (let entry of this.table.scriptList) {
        if (entry.tag === s2)
          return entry;
      }
    return null;
  }
  selectScript(script, language, direction) {
    let changed = false;
    let entry;
    if (!this.script || script !== this.scriptTag) {
      entry = this.findScript(script);
      if (!entry)
        entry = this.findScript($a83b9c36aaa94fd3$var$DEFAULT_SCRIPTS);
      if (!entry)
        return this.scriptTag;
      this.scriptTag = entry.tag;
      this.script = entry.script;
      this.language = null;
      this.languageTag = null;
      changed = true;
    }
    if (!direction || direction !== this.direction)
      this.direction = direction || $130d1a642ebcd2b7$export$9fddb9d0dd7d8a54(script);
    if (language && language.length < 4)
      language += " ".repeat(4 - language.length);
    if (!language || language !== this.languageTag) {
      this.language = null;
      for (let lang of this.script.langSysRecords)
        if (lang.tag === language) {
          this.language = lang.langSys;
          this.languageTag = lang.tag;
          break;
        }
      if (!this.language) {
        this.language = this.script.defaultLangSys;
        this.languageTag = null;
      }
      changed = true;
    }
    if (changed) {
      this.features = {};
      if (this.language)
        for (let featureIndex of this.language.featureIndexes) {
          let record = this.table.featureList[featureIndex];
          let substituteFeature = this.substituteFeatureForVariations(featureIndex);
          this.features[record.tag] = substituteFeature || record.feature;
        }
    }
    return this.scriptTag;
  }
  lookupsForFeatures(userFeatures = [], exclude) {
    let lookups = [];
    for (let tag of userFeatures) {
      let feature = this.features[tag];
      if (!feature)
        continue;
      for (let lookupIndex of feature.lookupListIndexes) {
        if (exclude && exclude.indexOf(lookupIndex) !== -1)
          continue;
        lookups.push({
          feature: tag,
          index: lookupIndex,
          lookup: this.table.lookupList.get(lookupIndex)
        });
      }
    }
    lookups.sort((a2, b) => a2.index - b.index);
    return lookups;
  }
  substituteFeatureForVariations(featureIndex) {
    if (this.variationsIndex === -1)
      return null;
    let record = this.table.featureVariations.featureVariationRecords[this.variationsIndex];
    let substitutions = record.featureTableSubstitution.substitutions;
    for (let substitution of substitutions) {
      if (substitution.featureIndex === featureIndex)
        return substitution.alternateFeatureTable;
    }
    return null;
  }
  findVariationsIndex(coords) {
    let variations = this.table.featureVariations;
    if (!variations)
      return -1;
    let records = variations.featureVariationRecords;
    for (let i = 0; i < records.length; i++) {
      let conditions = records[i].conditionSet.conditionTable;
      if (this.variationConditionsMatch(conditions, coords))
        return i;
    }
    return -1;
  }
  variationConditionsMatch(conditions, coords) {
    return conditions.every((condition) => {
      let coord = condition.axisIndex < coords.length ? coords[condition.axisIndex] : 0;
      return condition.filterRangeMinValue <= coord && coord <= condition.filterRangeMaxValue;
    });
  }
  applyFeatures(userFeatures, glyphs, advances) {
    let lookups = this.lookupsForFeatures(userFeatures);
    this.applyLookups(lookups, glyphs, advances);
  }
  applyLookups(lookups, glyphs, positions) {
    this.glyphs = glyphs;
    this.positions = positions;
    this.glyphIterator = new (0, $85d408632270248b$export$2e2bcd8739ae039)(glyphs);
    for (let { feature, lookup: lookup4 } of lookups) {
      this.currentFeature = feature;
      this.glyphIterator.reset(lookup4.flags);
      while (this.glyphIterator.index < glyphs.length) {
        if (!(feature in this.glyphIterator.cur.features)) {
          this.glyphIterator.next();
          continue;
        }
        for (let table of lookup4.subTables) {
          let res = this.applyLookup(lookup4.lookupType, table);
          if (res)
            break;
        }
        this.glyphIterator.next();
      }
    }
  }
  applyLookup(lookup4, table) {
    throw new Error("applyLookup must be implemented by subclasses");
  }
  applyLookupList(lookupRecords) {
    let options = this.glyphIterator.options;
    let glyphIndex = this.glyphIterator.index;
    for (let lookupRecord of lookupRecords) {
      this.glyphIterator.reset(options, glyphIndex);
      this.glyphIterator.increment(lookupRecord.sequenceIndex);
      let lookup4 = this.table.lookupList.get(lookupRecord.lookupListIndex);
      this.glyphIterator.reset(lookup4.flags, this.glyphIterator.index);
      for (let table of lookup4.subTables) {
        if (this.applyLookup(lookup4.lookupType, table))
          break;
      }
    }
    this.glyphIterator.reset(options, glyphIndex);
    return true;
  }
  coverageIndex(coverage, glyph) {
    if (glyph == null)
      glyph = this.glyphIterator.cur.id;
    switch (coverage.version) {
      case 1:
        return coverage.glyphs.indexOf(glyph);
      case 2:
        for (let range3 of coverage.rangeRecords) {
          if (range3.start <= glyph && glyph <= range3.end)
            return range3.startCoverageIndex + glyph - range3.start;
        }
        break;
    }
    return -1;
  }
  match(sequenceIndex, sequence, fn, matched) {
    let pos = this.glyphIterator.index;
    let glyph = this.glyphIterator.increment(sequenceIndex);
    let idx = 0;
    while (idx < sequence.length && glyph && fn(sequence[idx], glyph)) {
      if (matched)
        matched.push(this.glyphIterator.index);
      idx++;
      glyph = this.glyphIterator.next();
    }
    this.glyphIterator.index = pos;
    if (idx < sequence.length)
      return false;
    return matched || true;
  }
  sequenceMatches(sequenceIndex, sequence) {
    return this.match(sequenceIndex, sequence, (component, glyph) => component === glyph.id);
  }
  sequenceMatchIndices(sequenceIndex, sequence) {
    return this.match(sequenceIndex, sequence, (component, glyph) => {
      if (!(this.currentFeature in glyph.features))
        return false;
      return component === glyph.id;
    }, []);
  }
  coverageSequenceMatches(sequenceIndex, sequence) {
    return this.match(sequenceIndex, sequence, (coverage, glyph) => this.coverageIndex(coverage, glyph.id) >= 0);
  }
  getClassID(glyph, classDef) {
    switch (classDef.version) {
      case 1:
        let i = glyph - classDef.startGlyph;
        if (i >= 0 && i < classDef.classValueArray.length)
          return classDef.classValueArray[i];
        break;
      case 2:
        for (let range3 of classDef.classRangeRecord) {
          if (range3.start <= glyph && glyph <= range3.end)
            return range3.class;
        }
        break;
    }
    return 0;
  }
  classSequenceMatches(sequenceIndex, sequence, classDef) {
    return this.match(sequenceIndex, sequence, (classID, glyph) => classID === this.getClassID(glyph.id, classDef));
  }
  applyContext(table) {
    let index3, set7;
    switch (table.version) {
      case 1:
        index3 = this.coverageIndex(table.coverage);
        if (index3 === -1)
          return false;
        set7 = table.ruleSets[index3];
        for (let rule of set7) {
          if (this.sequenceMatches(1, rule.input))
            return this.applyLookupList(rule.lookupRecords);
        }
        break;
      case 2:
        if (this.coverageIndex(table.coverage) === -1)
          return false;
        index3 = this.getClassID(this.glyphIterator.cur.id, table.classDef);
        if (index3 === -1)
          return false;
        set7 = table.classSet[index3];
        for (let rule1 of set7) {
          if (this.classSequenceMatches(1, rule1.classes, table.classDef))
            return this.applyLookupList(rule1.lookupRecords);
        }
        break;
      case 3:
        if (this.coverageSequenceMatches(0, table.coverages))
          return this.applyLookupList(table.lookupRecords);
        break;
    }
    return false;
  }
  applyChainingContext(table) {
    let index3;
    switch (table.version) {
      case 1:
        index3 = this.coverageIndex(table.coverage);
        if (index3 === -1)
          return false;
        let set7 = table.chainRuleSets[index3];
        for (let rule of set7) {
          if (this.sequenceMatches(-rule.backtrack.length, rule.backtrack) && this.sequenceMatches(1, rule.input) && this.sequenceMatches(1 + rule.input.length, rule.lookahead))
            return this.applyLookupList(rule.lookupRecords);
        }
        break;
      case 2:
        if (this.coverageIndex(table.coverage) === -1)
          return false;
        index3 = this.getClassID(this.glyphIterator.cur.id, table.inputClassDef);
        let rules = table.chainClassSet[index3];
        if (!rules)
          return false;
        for (let rule2 of rules) {
          if (this.classSequenceMatches(-rule2.backtrack.length, rule2.backtrack, table.backtrackClassDef) && this.classSequenceMatches(1, rule2.input, table.inputClassDef) && this.classSequenceMatches(1 + rule2.input.length, rule2.lookahead, table.lookaheadClassDef))
            return this.applyLookupList(rule2.lookupRecords);
        }
        break;
      case 3:
        if (this.coverageSequenceMatches(-table.backtrackGlyphCount, table.backtrackCoverage) && this.coverageSequenceMatches(0, table.inputCoverage) && this.coverageSequenceMatches(table.inputGlyphCount, table.lookaheadCoverage))
          return this.applyLookupList(table.lookupRecords);
        break;
    }
    return false;
  }
  constructor(font2, table) {
    this.font = font2;
    this.table = table;
    this.script = null;
    this.scriptTag = null;
    this.language = null;
    this.languageTag = null;
    this.features = {};
    this.lookups = {};
    this.variationsIndex = font2._variationProcessor ? this.findVariationsIndex(font2._variationProcessor.normalizedCoords) : -1;
    this.selectScript();
    this.glyphs = [];
    this.positions = [];
    this.ligatureID = 1;
    this.currentFeature = null;
  }
};
var $10e7b257e1a9a756$export$2e2bcd8739ae039 = class _$10e7b257e1a9a756$export$2e2bcd8739ae039 {
  get id() {
    return this._id;
  }
  set id(id) {
    this._id = id;
    this.substituted = true;
    let GDEF = this._font.GDEF;
    if (GDEF && GDEF.glyphClassDef) {
      let classID = (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039).prototype.getClassID(id, GDEF.glyphClassDef);
      this.isBase = classID === 1;
      this.isLigature = classID === 2;
      this.isMark = classID === 3;
      this.markAttachmentType = GDEF.markAttachClassDef ? (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039).prototype.getClassID(id, GDEF.markAttachClassDef) : 0;
    } else {
      this.isMark = this.codePoints.length > 0 && this.codePoints.every((0, $747425b437e121da$export$e33ad6871e762338));
      this.isBase = !this.isMark;
      this.isLigature = this.codePoints.length > 1;
      this.markAttachmentType = 0;
    }
  }
  copy() {
    return new _$10e7b257e1a9a756$export$2e2bcd8739ae039(this._font, this.id, this.codePoints, this.features);
  }
  constructor(font2, id, codePoints = [], features) {
    this._font = font2;
    this.codePoints = codePoints;
    this.id = id;
    this.features = {};
    if (Array.isArray(features))
      for (let i = 0; i < features.length; i++) {
        let feature = features[i];
        this.features[feature] = true;
      }
    else if (typeof features === "object")
      Object.assign(this.features, features);
    this.ligatureID = null;
    this.ligatureComponent = null;
    this.isLigated = false;
    this.cursiveAttachment = null;
    this.markAttachment = null;
    this.shaperInfo = null;
    this.substituted = false;
    this.isMultiplied = false;
  }
};
var $e1c6bbc8cb416f8c$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static planFeatures(plan) {
    plan.add([
      "ljmo",
      "vjmo",
      "tjmo"
    ], false);
  }
  static assignFeatures(plan, glyphs) {
    let state2 = 0;
    let i = 0;
    while (i < glyphs.length) {
      let action;
      let glyph = glyphs[i];
      let code3 = glyph.codePoints[0];
      let type = $e1c6bbc8cb416f8c$var$getType(code3);
      [action, state2] = $e1c6bbc8cb416f8c$var$STATE_TABLE[state2][type];
      switch (action) {
        case $e1c6bbc8cb416f8c$var$DECOMPOSE:
          if (!plan.font.hasGlyphForCodePoint(code3))
            i = $e1c6bbc8cb416f8c$var$decompose(glyphs, i, plan.font);
          break;
        case $e1c6bbc8cb416f8c$var$COMPOSE:
          i = $e1c6bbc8cb416f8c$var$compose(glyphs, i, plan.font);
          break;
        case $e1c6bbc8cb416f8c$var$TONE_MARK:
          $e1c6bbc8cb416f8c$var$reorderToneMark(glyphs, i, plan.font);
          break;
        case $e1c6bbc8cb416f8c$var$INVALID:
          i = $e1c6bbc8cb416f8c$var$insertDottedCircle(glyphs, i, plan.font);
          break;
      }
      i++;
    }
  }
};
(0, _defineProperty)($e1c6bbc8cb416f8c$export$2e2bcd8739ae039, "zeroMarkWidths", "NONE");
var $e1c6bbc8cb416f8c$var$HANGUL_BASE = 44032;
var $e1c6bbc8cb416f8c$var$HANGUL_END = 55204;
var $e1c6bbc8cb416f8c$var$HANGUL_COUNT = $e1c6bbc8cb416f8c$var$HANGUL_END - $e1c6bbc8cb416f8c$var$HANGUL_BASE + 1;
var $e1c6bbc8cb416f8c$var$L_BASE = 4352;
var $e1c6bbc8cb416f8c$var$V_BASE = 4449;
var $e1c6bbc8cb416f8c$var$T_BASE = 4519;
var $e1c6bbc8cb416f8c$var$L_COUNT = 19;
var $e1c6bbc8cb416f8c$var$V_COUNT = 21;
var $e1c6bbc8cb416f8c$var$T_COUNT = 28;
var $e1c6bbc8cb416f8c$var$L_END = $e1c6bbc8cb416f8c$var$L_BASE + $e1c6bbc8cb416f8c$var$L_COUNT - 1;
var $e1c6bbc8cb416f8c$var$V_END = $e1c6bbc8cb416f8c$var$V_BASE + $e1c6bbc8cb416f8c$var$V_COUNT - 1;
var $e1c6bbc8cb416f8c$var$T_END = $e1c6bbc8cb416f8c$var$T_BASE + $e1c6bbc8cb416f8c$var$T_COUNT - 1;
var $e1c6bbc8cb416f8c$var$DOTTED_CIRCLE = 9676;
var $e1c6bbc8cb416f8c$var$isL = (code3) => 4352 <= code3 && code3 <= 4447 || 43360 <= code3 && code3 <= 43388;
var $e1c6bbc8cb416f8c$var$isV = (code3) => 4448 <= code3 && code3 <= 4519 || 55216 <= code3 && code3 <= 55238;
var $e1c6bbc8cb416f8c$var$isT = (code3) => 4520 <= code3 && code3 <= 4607 || 55243 <= code3 && code3 <= 55291;
var $e1c6bbc8cb416f8c$var$isTone = (code3) => 12334 <= code3 && code3 <= 12335;
var $e1c6bbc8cb416f8c$var$isLVT = (code3) => $e1c6bbc8cb416f8c$var$HANGUL_BASE <= code3 && code3 <= $e1c6bbc8cb416f8c$var$HANGUL_END;
var $e1c6bbc8cb416f8c$var$isLV = (code3) => code3 - $e1c6bbc8cb416f8c$var$HANGUL_BASE < $e1c6bbc8cb416f8c$var$HANGUL_COUNT && (code3 - $e1c6bbc8cb416f8c$var$HANGUL_BASE) % $e1c6bbc8cb416f8c$var$T_COUNT === 0;
var $e1c6bbc8cb416f8c$var$isCombiningL = (code3) => $e1c6bbc8cb416f8c$var$L_BASE <= code3 && code3 <= $e1c6bbc8cb416f8c$var$L_END;
var $e1c6bbc8cb416f8c$var$isCombiningV = (code3) => $e1c6bbc8cb416f8c$var$V_BASE <= code3 && code3 <= $e1c6bbc8cb416f8c$var$V_END;
var $e1c6bbc8cb416f8c$var$isCombiningT = (code3) => $e1c6bbc8cb416f8c$var$T_BASE + 1 && 1 <= code3 && code3 <= $e1c6bbc8cb416f8c$var$T_END;
var $e1c6bbc8cb416f8c$var$X = 0;
var $e1c6bbc8cb416f8c$var$L = 1;
var $e1c6bbc8cb416f8c$var$V = 2;
var $e1c6bbc8cb416f8c$var$T = 3;
var $e1c6bbc8cb416f8c$var$LV = 4;
var $e1c6bbc8cb416f8c$var$LVT = 5;
var $e1c6bbc8cb416f8c$var$M = 6;
function $e1c6bbc8cb416f8c$var$getType(code3) {
  if ($e1c6bbc8cb416f8c$var$isL(code3))
    return $e1c6bbc8cb416f8c$var$L;
  if ($e1c6bbc8cb416f8c$var$isV(code3))
    return $e1c6bbc8cb416f8c$var$V;
  if ($e1c6bbc8cb416f8c$var$isT(code3))
    return $e1c6bbc8cb416f8c$var$T;
  if ($e1c6bbc8cb416f8c$var$isLV(code3))
    return $e1c6bbc8cb416f8c$var$LV;
  if ($e1c6bbc8cb416f8c$var$isLVT(code3))
    return $e1c6bbc8cb416f8c$var$LVT;
  if ($e1c6bbc8cb416f8c$var$isTone(code3))
    return $e1c6bbc8cb416f8c$var$M;
  return $e1c6bbc8cb416f8c$var$X;
}
var $e1c6bbc8cb416f8c$var$NO_ACTION = 0;
var $e1c6bbc8cb416f8c$var$DECOMPOSE = 1;
var $e1c6bbc8cb416f8c$var$COMPOSE = 2;
var $e1c6bbc8cb416f8c$var$TONE_MARK = 4;
var $e1c6bbc8cb416f8c$var$INVALID = 5;
var $e1c6bbc8cb416f8c$var$STATE_TABLE = [
  //       X                 L                 V                T                  LV                LVT               M
  // State 0: start state
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$INVALID,
      0
    ]
  ],
  // State 1: <L>
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$COMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$INVALID,
      0
    ]
  ],
  // State 2: <L,V> or <LV>
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$COMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$TONE_MARK,
      0
    ]
  ],
  // State 3: <L,V,T> or <LVT>
  [
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      1
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$NO_ACTION,
      0
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      2
    ],
    [
      $e1c6bbc8cb416f8c$var$DECOMPOSE,
      3
    ],
    [
      $e1c6bbc8cb416f8c$var$TONE_MARK,
      0
    ]
  ]
];
function $e1c6bbc8cb416f8c$var$getGlyph(font2, code3, features) {
  return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font2, font2.glyphForCodePoint(code3).id, [
    code3
  ], features);
}
function $e1c6bbc8cb416f8c$var$decompose(glyphs, i, font2) {
  let glyph = glyphs[i];
  let code3 = glyph.codePoints[0];
  let s2 = code3 - $e1c6bbc8cb416f8c$var$HANGUL_BASE;
  let t2 = $e1c6bbc8cb416f8c$var$T_BASE + s2 % $e1c6bbc8cb416f8c$var$T_COUNT;
  s2 = s2 / $e1c6bbc8cb416f8c$var$T_COUNT | 0;
  let l2 = $e1c6bbc8cb416f8c$var$L_BASE + s2 / $e1c6bbc8cb416f8c$var$V_COUNT | 0;
  let v2 = $e1c6bbc8cb416f8c$var$V_BASE + s2 % $e1c6bbc8cb416f8c$var$V_COUNT;
  if (!font2.hasGlyphForCodePoint(l2) || !font2.hasGlyphForCodePoint(v2) || t2 !== $e1c6bbc8cb416f8c$var$T_BASE && !font2.hasGlyphForCodePoint(t2))
    return i;
  let ljmo = $e1c6bbc8cb416f8c$var$getGlyph(font2, l2, glyph.features);
  ljmo.features.ljmo = true;
  let vjmo = $e1c6bbc8cb416f8c$var$getGlyph(font2, v2, glyph.features);
  vjmo.features.vjmo = true;
  let insert3 = [
    ljmo,
    vjmo
  ];
  if (t2 > $e1c6bbc8cb416f8c$var$T_BASE) {
    let tjmo = $e1c6bbc8cb416f8c$var$getGlyph(font2, t2, glyph.features);
    tjmo.features.tjmo = true;
    insert3.push(tjmo);
  }
  glyphs.splice(i, 1, ...insert3);
  return i + insert3.length - 1;
}
function $e1c6bbc8cb416f8c$var$compose(glyphs, i, font2) {
  let glyph = glyphs[i];
  let code3 = glyphs[i].codePoints[0];
  let type = $e1c6bbc8cb416f8c$var$getType(code3);
  let prev = glyphs[i - 1].codePoints[0];
  let prevType = $e1c6bbc8cb416f8c$var$getType(prev);
  let lv, ljmo, vjmo, tjmo;
  if (prevType === $e1c6bbc8cb416f8c$var$LV && type === $e1c6bbc8cb416f8c$var$T) {
    lv = prev;
    tjmo = glyph;
  } else {
    if (type === $e1c6bbc8cb416f8c$var$V) {
      ljmo = glyphs[i - 1];
      vjmo = glyph;
    } else {
      ljmo = glyphs[i - 2];
      vjmo = glyphs[i - 1];
      tjmo = glyph;
    }
    let l2 = ljmo.codePoints[0];
    let v2 = vjmo.codePoints[0];
    if ($e1c6bbc8cb416f8c$var$isCombiningL(l2) && $e1c6bbc8cb416f8c$var$isCombiningV(v2))
      lv = $e1c6bbc8cb416f8c$var$HANGUL_BASE + ((l2 - $e1c6bbc8cb416f8c$var$L_BASE) * $e1c6bbc8cb416f8c$var$V_COUNT + (v2 - $e1c6bbc8cb416f8c$var$V_BASE)) * $e1c6bbc8cb416f8c$var$T_COUNT;
  }
  let t2 = tjmo && tjmo.codePoints[0] || $e1c6bbc8cb416f8c$var$T_BASE;
  if (lv != null && (t2 === $e1c6bbc8cb416f8c$var$T_BASE || $e1c6bbc8cb416f8c$var$isCombiningT(t2))) {
    let s2 = lv + (t2 - $e1c6bbc8cb416f8c$var$T_BASE);
    if (font2.hasGlyphForCodePoint(s2)) {
      let del = prevType === $e1c6bbc8cb416f8c$var$V ? 3 : 2;
      glyphs.splice(i - del + 1, del, $e1c6bbc8cb416f8c$var$getGlyph(font2, s2, glyph.features));
      return i - del + 1;
    }
  }
  if (ljmo)
    ljmo.features.ljmo = true;
  if (vjmo)
    vjmo.features.vjmo = true;
  if (tjmo)
    tjmo.features.tjmo = true;
  if (prevType === $e1c6bbc8cb416f8c$var$LV) {
    $e1c6bbc8cb416f8c$var$decompose(glyphs, i - 1, font2);
    return i + 1;
  }
  return i;
}
function $e1c6bbc8cb416f8c$var$getLength(code3) {
  switch ($e1c6bbc8cb416f8c$var$getType(code3)) {
    case $e1c6bbc8cb416f8c$var$LV:
    case $e1c6bbc8cb416f8c$var$LVT:
      return 1;
    case $e1c6bbc8cb416f8c$var$V:
      return 2;
    case $e1c6bbc8cb416f8c$var$T:
      return 3;
  }
}
function $e1c6bbc8cb416f8c$var$reorderToneMark(glyphs, i, font2) {
  let glyph = glyphs[i];
  let code3 = glyphs[i].codePoints[0];
  if (font2.glyphForCodePoint(code3).advanceWidth === 0)
    return;
  let prev = glyphs[i - 1].codePoints[0];
  let len = $e1c6bbc8cb416f8c$var$getLength(prev);
  glyphs.splice(i, 1);
  return glyphs.splice(i - len, 0, glyph);
}
function $e1c6bbc8cb416f8c$var$insertDottedCircle(glyphs, i, font2) {
  let glyph = glyphs[i];
  let code3 = glyphs[i].codePoints[0];
  if (font2.hasGlyphForCodePoint($e1c6bbc8cb416f8c$var$DOTTED_CIRCLE)) {
    let dottedCircle = $e1c6bbc8cb416f8c$var$getGlyph(font2, $e1c6bbc8cb416f8c$var$DOTTED_CIRCLE, glyph.features);
    let idx = font2.glyphForCodePoint(code3).advanceWidth === 0 ? i : i + 1;
    glyphs.splice(idx, 0, dottedCircle);
    i++;
  }
  return i;
}
var $4b0735ca6c692ea5$exports = {};
$4b0735ca6c692ea5$exports = JSON.parse('{"stateTable":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,2,3,4,5,6,7,8,9,0,10,11,11,12,13,14,15,16,17],[0,0,0,18,19,20,21,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,28,29,30,31,32,33,0,34,0,0,35,36,0,0,37,0],[0,0,0,38,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,39,0,0,0,40,41,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,43,44,44,8,9,0,0,0,0,12,43,0,0,0,0],[0,0,0,0,43,44,44,8,9,0,0,0,0,0,43,0,0,0,0],[0,0,0,45,46,47,48,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,50,0,0,51,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,0],[0,0,0,53,54,55,56,57,58,0,59,0,0,60,61,0,0,62,0],[0,0,0,4,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,63,64,0,0,40,41,0,9,0,10,0,0,0,42,0,63,0,0],[0,2,3,4,5,6,7,8,9,0,10,11,11,12,13,0,2,16,0],[0,0,0,18,65,20,21,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,0,66,67,67,8,9,0,10,0,0,0,68,0,0,0,0],[0,0,0,69,0,70,70,0,71,0,72,0,0,0,0,0,0,0,0],[0,0,0,73,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,75,0,0,0,76,77,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,79,80,80,22,23,0,0,0,0,25,79,0,0,0,0],[0,0,0,18,19,20,74,22,23,0,24,0,0,25,26,0,0,27,0],[0,0,0,81,82,83,84,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,86,0,0,87,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,88,0,0,0,0,0,0,0,0],[0,0,0,18,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,89,90,0,0,76,77,0,23,0,24,0,0,0,78,0,89,0,0],[0,0,0,0,91,92,92,22,23,0,24,0,0,0,93,0,0,0,0],[0,0,0,94,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,96,0,0,0,97,98,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,35,100,0,0,0,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,0,100,0,0,0,0],[0,0,0,102,103,104,105,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,107,0,0,108,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,109,0,0,0,0,0,0,0,0],[0,0,0,28,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,110,111,0,0,97,98,0,33,0,34,0,0,0,99,0,110,0,0],[0,0,0,0,112,113,113,32,33,0,34,0,0,0,114,0,0,0,0],[0,0,0,0,5,7,7,8,9,0,10,0,0,0,13,0,0,16,0],[0,0,0,115,116,117,118,8,9,0,10,0,0,119,120,0,0,16,0],[0,0,0,0,0,121,121,0,9,0,10,0,0,0,42,0,0,0,0],[0,39,0,122,0,123,123,8,9,0,10,0,0,0,42,0,39,0,0],[0,124,64,0,0,0,0,0,0,0,0,0,0,0,0,0,124,0,0],[0,39,0,0,0,121,125,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,126,126,8,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,46,47,48,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,47,47,49,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,127,127,49,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,128,127,127,49,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,129,130,131,132,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,50,0,0,0,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,134,0,0,0,0,0,0,0,0],[0,0,0,135,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,136,0,0,0,137,138,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,140,141,141,57,58,0,0,0,0,60,140,0,0,0,0],[0,0,0,0,140,141,141,57,58,0,0,0,0,0,140,0,0,0,0],[0,0,0,142,143,144,145,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,147,0,0,148,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,149,0,0,0,0,0,0,0,0],[0,0,0,53,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,150,151,0,0,137,138,0,58,0,59,0,0,0,139,0,150,0,0],[0,0,0,0,152,153,153,57,58,0,59,0,0,0,154,0,0,0,0],[0,0,0,155,116,156,157,8,9,0,10,0,0,158,120,0,0,16,0],[0,0,0,0,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,75,3,4,5,159,160,8,161,0,162,0,11,12,163,0,75,16,0],[0,0,0,0,0,40,164,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,0,165,0,0,0,0],[0,124,64,0,0,40,164,0,9,0,10,0,0,0,42,0,124,0,0],[0,0,0,0,0,70,70,0,71,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,71,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,166,0,0,167,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,168,0,0,0,0,0,0,0,0],[0,0,0,0,19,74,74,22,23,0,24,0,0,0,26,0,0,27,0],[0,0,0,0,79,80,80,22,23,0,0,0,0,0,79,0,0,0,0],[0,0,0,169,170,171,172,22,23,0,24,0,0,173,174,0,0,27,0],[0,0,0,0,0,175,175,0,23,0,24,0,0,0,78,0,0,0,0],[0,75,0,176,0,177,177,22,23,0,24,0,0,0,78,0,75,0,0],[0,178,90,0,0,0,0,0,0,0,0,0,0,0,0,0,178,0,0],[0,75,0,0,0,175,179,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,180,180,22,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,82,83,84,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,83,83,85,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,181,181,85,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,182,181,181,85,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,183,184,185,186,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,86,0,0,0,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,188,0,0,0,0,0,0,0,0],[0,0,0,189,170,190,191,22,23,0,24,0,0,192,174,0,0,27,0],[0,0,0,0,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,76,193,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,0,194,0,0,0,0],[0,178,90,0,0,76,193,0,23,0,24,0,0,0,78,0,178,0,0],[0,0,0,0,29,95,31,32,33,0,34,0,0,0,36,0,0,37,0],[0,0,0,0,100,101,101,32,33,0,0,0,0,0,100,0,0,0,0],[0,0,0,195,196,197,198,32,33,0,34,0,0,199,200,0,0,37,0],[0,0,0,0,0,201,201,0,33,0,34,0,0,0,99,0,0,0,0],[0,96,0,202,0,203,203,32,33,0,34,0,0,0,99,0,96,0,0],[0,204,111,0,0,0,0,0,0,0,0,0,0,0,0,0,204,0,0],[0,96,0,0,0,201,205,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,206,206,32,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,103,104,105,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,104,104,106,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,207,207,106,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,208,207,207,106,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,209,210,211,212,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,107,0,0,0,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,214,0,0,0,0,0,0,0,0],[0,0,0,215,196,216,217,32,33,0,34,0,0,218,200,0,0,37,0],[0,0,0,0,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,97,219,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,0,220,0,0,0,0],[0,204,111,0,0,97,219,0,33,0,34,0,0,0,99,0,204,0,0],[0,0,0,221,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,223,0,0,0,40,224,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,119,225,0,0,0,0],[0,0,0,115,116,117,222,8,9,0,10,0,0,119,120,0,0,16,0],[0,0,0,115,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,226,64,0,0,40,224,0,9,0,10,0,0,0,42,0,226,0,0],[0,0,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,39,0,0,0,121,121,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,44,44,8,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,227,0,228,229,0,9,0,10,0,0,230,0,0,0,0,0],[0,39,0,122,0,121,121,0,9,0,10,0,0,0,42,0,39,0,0],[0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,231,231,49,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,232,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,130,131,132,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,131,131,133,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,233,233,133,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,234,233,233,133,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,235,236,237,238,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,54,56,56,57,58,0,59,0,0,0,61,0,0,62,0],[0,0,0,240,241,242,243,57,58,0,59,0,0,244,245,0,0,62,0],[0,0,0,0,0,246,246,0,58,0,59,0,0,0,139,0,0,0,0],[0,136,0,247,0,248,248,57,58,0,59,0,0,0,139,0,136,0,0],[0,249,151,0,0,0,0,0,0,0,0,0,0,0,0,0,249,0,0],[0,136,0,0,0,246,250,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,251,251,57,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,143,144,145,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,144,144,146,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,252,252,146,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,253,252,252,146,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,254,255,256,257,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,147,0,0,0,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,259,0,0,0,0,0,0,0,0],[0,0,0,260,241,261,262,57,58,0,59,0,0,263,245,0,0,62,0],[0,0,0,0,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,137,264,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,0,265,0,0,0,0],[0,249,151,0,0,137,264,0,58,0,59,0,0,0,139,0,249,0,0],[0,0,0,221,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,158,225,0,0,0,0],[0,0,0,155,116,156,222,8,9,0,10,0,0,158,120,0,0,16,0],[0,0,0,155,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,43,266,266,8,161,0,24,0,0,12,267,0,0,0,0],[0,75,0,176,43,268,268,269,161,0,24,0,0,0,267,0,75,0,0],[0,0,0,0,0,270,0,0,271,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,272,0,0,0,0,0,0,0,0],[0,273,274,0,0,40,41,0,9,0,10,0,0,0,42,0,273,0,0],[0,0,0,40,0,123,123,8,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,121,275,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,166,0,0,0,0,72,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,276,0,0,0,0,0,0,0,0],[0,0,0,277,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,279,0,0,0,76,280,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,173,281,0,0,0,0],[0,0,0,169,170,171,278,22,23,0,24,0,0,173,174,0,0,27,0],[0,0,0,169,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,282,90,0,0,76,280,0,23,0,24,0,0,0,78,0,282,0,0],[0,0,0,0,0,0,0,0,23,0,0,0,0,0,0,0,0,0,0],[0,75,0,0,0,175,175,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,80,80,22,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,283,0,284,285,0,23,0,24,0,0,286,0,0,0,0,0],[0,75,0,176,0,175,175,0,23,0,24,0,0,0,78,0,75,0,0],[0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,287,287,85,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,288,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,184,185,186,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,185,185,187,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,289,289,187,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,290,289,289,187,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,291,292,293,294,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,277,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,192,281,0,0,0,0],[0,0,0,189,170,190,278,22,23,0,24,0,0,192,174,0,0,27,0],[0,0,0,189,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,76,0,177,177,22,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,175,296,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,297,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,299,0,0,0,97,300,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,199,301,0,0,0,0],[0,0,0,195,196,197,298,32,33,0,34,0,0,199,200,0,0,37,0],[0,0,0,195,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,302,111,0,0,97,300,0,33,0,34,0,0,0,99,0,302,0,0],[0,0,0,0,0,0,0,0,33,0,0,0,0,0,0,0,0,0,0],[0,96,0,0,0,201,201,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,101,101,32,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,303,0,304,305,0,33,0,34,0,0,306,0,0,0,0,0],[0,96,0,202,0,201,201,0,33,0,34,0,0,0,99,0,96,0,0],[0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,307,307,106,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,308,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,210,211,212,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,211,211,213,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,309,309,213,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,310,309,309,213,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,311,312,313,314,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,297,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,218,301,0,0,0,0],[0,0,0,215,196,216,298,32,33,0,34,0,0,218,200,0,0,37,0],[0,0,0,215,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,97,0,203,203,32,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,201,316,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,116,222,222,8,9,0,10,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,9,0,0,0,0,0,225,0,0,0,0],[0,0,0,317,318,319,320,8,9,0,10,0,0,321,322,0,0,16,0],[0,223,0,323,0,123,123,8,9,0,10,0,0,0,42,0,223,0,0],[0,223,0,0,0,121,324,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,325,318,326,327,8,9,0,10,0,0,328,322,0,0,16,0],[0,0,0,64,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,9,0,0,0,0,230,0,0,0,0,0],[0,0,0,227,0,228,121,0,9,0,10,0,0,230,0,0,0,0,0],[0,0,0,227,0,121,121,0,9,0,10,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,46,0,0],[0,0,0,0,0,329,329,133,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,330,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,236,237,238,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,237,237,239,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,331,331,239,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,332,331,331,239,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,333,40,121,334,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,335,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,337,0,0,0,137,338,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,244,339,0,0,0,0],[0,0,0,240,241,242,336,57,58,0,59,0,0,244,245,0,0,62,0],[0,0,0,240,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,340,151,0,0,137,338,0,58,0,59,0,0,0,139,0,340,0,0],[0,0,0,0,0,0,0,0,58,0,0,0,0,0,0,0,0,0,0],[0,136,0,0,0,246,246,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,141,141,57,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,341,0,342,343,0,58,0,59,0,0,344,0,0,0,0,0],[0,136,0,247,0,246,246,0,58,0,59,0,0,0,139,0,136,0,0],[0,0,0,0,0,0,0,57,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,345,345,146,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,346,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,255,256,257,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,256,256,258,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,347,347,258,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,348,347,347,258,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,349,350,351,352,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,335,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,263,339,0,0,0,0],[0,0,0,260,241,261,336,57,58,0,59,0,0,263,245,0,0,62,0],[0,0,0,260,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,137,0,248,248,57,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,246,354,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,126,126,8,23,0,0,0,0,0,0,0,0,0,0],[0,355,90,0,0,121,125,0,9,0,10,0,0,0,42,0,355,0,0],[0,0,0,0,0,356,356,269,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,357,358,359,360,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,270,0,0,0,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,363,0,0,0,0,0,0,0,0],[0,0,0,364,116,365,366,8,161,0,162,0,0,367,120,0,0,16,0],[0,0,0,0,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,40,0,121,121,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,170,278,278,22,23,0,24,0,0,0,174,0,0,27,0],[0,0,0,0,281,80,80,22,23,0,0,0,0,0,281,0,0,0,0],[0,0,0,369,370,371,372,22,23,0,24,0,0,373,374,0,0,27,0],[0,279,0,375,0,177,177,22,23,0,24,0,0,0,78,0,279,0,0],[0,279,0,0,0,175,376,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,377,370,378,379,22,23,0,24,0,0,380,374,0,0,27,0],[0,0,0,90,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,23,0,0,0,0,286,0,0,0,0,0],[0,0,0,283,0,284,175,0,23,0,24,0,0,286,0,0,0,0,0],[0,0,0,283,0,175,175,0,23,0,24,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,85,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,82,0,0],[0,0,0,0,0,381,381,187,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,382,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,292,293,294,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,293,293,295,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,0,383,383,295,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,384,383,383,295,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,385,76,175,386,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,76,0,175,175,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,196,298,298,32,33,0,34,0,0,0,200,0,0,37,0],[0,0,0,0,301,101,101,32,33,0,0,0,0,0,301,0,0,0,0],[0,0,0,387,388,389,390,32,33,0,34,0,0,391,392,0,0,37,0],[0,299,0,393,0,203,203,32,33,0,34,0,0,0,99,0,299,0,0],[0,299,0,0,0,201,394,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,395,388,396,397,32,33,0,34,0,0,398,392,0,0,37,0],[0,0,0,111,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,33,0,0,0,0,306,0,0,0,0,0],[0,0,0,303,0,304,201,0,33,0,34,0,0,306,0,0,0,0,0],[0,0,0,303,0,201,201,0,33,0,34,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,106,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,103,0,0],[0,0,0,0,0,399,399,213,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,400,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,312,313,314,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,313,313,315,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,0,401,401,315,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,402,401,401,315,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,403,97,201,404,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,97,0,201,201,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,405,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,407,0,0,0,40,408,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,321,409,0,0,0,0],[0,0,0,317,318,319,406,8,9,0,10,0,0,321,322,0,0,16,0],[0,0,0,317,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,410,64,0,0,40,408,0,9,0,10,0,0,0,42,0,410,0,0],[0,223,0,0,0,121,121,0,9,0,10,0,0,0,42,0,223,0,0],[0,223,0,323,0,121,121,0,9,0,10,0,0,0,42,0,223,0,0],[0,0,0,405,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,328,409,0,0,0,0],[0,0,0,325,318,326,406,8,9,0,10,0,0,328,322,0,0,16,0],[0,0,0,325,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,0,0,0,133,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0],[0,0,0,0,0,411,411,239,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,412,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,40,121,334,0,9,0,10,0,0,0,42,0,0,0,0],[0,0,0,0,413,0,0,0,9,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,241,336,336,57,58,0,59,0,0,0,245,0,0,62,0],[0,0,0,0,339,141,141,57,58,0,0,0,0,0,339,0,0,0,0],[0,0,0,414,415,416,417,57,58,0,59,0,0,418,419,0,0,62,0],[0,337,0,420,0,248,248,57,58,0,59,0,0,0,139,0,337,0,0],[0,337,0,0,0,246,421,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,422,415,423,424,57,58,0,59,0,0,425,419,0,0,62,0],[0,0,0,151,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,58,0,0,0,0,344,0,0,0,0,0],[0,0,0,341,0,342,246,0,58,0,59,0,0,344,0,0,0,0,0],[0,0,0,341,0,246,246,0,58,0,59,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,146,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,143,0,0],[0,0,0,0,0,426,426,258,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,427,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,350,351,352,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,351,351,353,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,0,428,428,353,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,429,428,428,353,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,430,137,246,431,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,137,0,246,246,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,432,116,433,434,8,161,0,162,0,0,435,120,0,0,16,0],[0,0,0,0,0,180,180,269,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,358,359,360,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,359,359,361,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,436,436,361,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,437,436,436,361,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,438,439,440,441,442,161,0,162,0,0,0,362,0,0,0,0],[0,443,274,0,0,0,0,0,0,0,0,0,0,0,0,0,443,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,444,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,367,225,0,0,0,0],[0,0,0,364,116,365,445,8,161,0,162,0,0,367,120,0,0,16,0],[0,0,0,364,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,0,0,0,0,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,446,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,448,0,0,0,76,449,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,373,450,0,0,0,0],[0,0,0,369,370,371,447,22,23,0,24,0,0,373,374,0,0,27,0],[0,0,0,369,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,451,90,0,0,76,449,0,23,0,24,0,0,0,78,0,451,0,0],[0,279,0,0,0,175,175,0,23,0,24,0,0,0,78,0,279,0,0],[0,279,0,375,0,175,175,0,23,0,24,0,0,0,78,0,279,0,0],[0,0,0,446,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,380,450,0,0,0,0],[0,0,0,377,370,378,447,22,23,0,24,0,0,380,374,0,0,27,0],[0,0,0,377,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,0,0,0,187,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,184,0,0],[0,0,0,0,0,452,452,295,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,453,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,76,175,386,0,23,0,24,0,0,0,78,0,0,0,0],[0,0,0,0,454,0,0,0,23,0,0,0,0,0,0,0,0,0,0],[0,0,0,455,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,457,0,0,0,97,458,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,391,459,0,0,0,0],[0,0,0,387,388,389,456,32,33,0,34,0,0,391,392,0,0,37,0],[0,0,0,387,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,460,111,0,0,97,458,0,33,0,34,0,0,0,99,0,460,0,0],[0,299,0,0,0,201,201,0,33,0,34,0,0,0,99,0,299,0,0],[0,299,0,393,0,201,201,0,33,0,34,0,0,0,99,0,299,0,0],[0,0,0,455,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,398,459,0,0,0,0],[0,0,0,395,388,396,456,32,33,0,34,0,0,398,392,0,0,37,0],[0,0,0,395,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,0,0,0,213,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,210,0,0],[0,0,0,0,0,461,461,315,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,462,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,97,201,404,0,33,0,34,0,0,0,99,0,0,0,0],[0,0,0,0,463,0,0,0,33,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,318,406,406,8,9,0,10,0,0,0,322,0,0,16,0],[0,0,0,0,409,44,44,8,9,0,0,0,0,0,409,0,0,0,0],[0,0,0,464,465,466,467,8,9,0,10,0,0,468,469,0,0,16,0],[0,407,0,470,0,123,123,8,9,0,10,0,0,0,42,0,407,0,0],[0,407,0,0,0,121,471,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,472,465,473,474,8,9,0,10,0,0,475,469,0,0,16,0],[0,0,0,0,0,0,0,239,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,236,0,0],[0,0,0,0,0,0,476,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,477,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,479,0,0,0,137,480,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,418,481,0,0,0,0],[0,0,0,414,415,416,478,57,58,0,59,0,0,418,419,0,0,62,0],[0,0,0,414,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,482,151,0,0,137,480,0,58,0,59,0,0,0,139,0,482,0,0],[0,337,0,0,0,246,246,0,58,0,59,0,0,0,139,0,337,0,0],[0,337,0,420,0,246,246,0,58,0,59,0,0,0,139,0,337,0,0],[0,0,0,477,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,425,481,0,0,0,0],[0,0,0,422,415,423,478,57,58,0,59,0,0,425,419,0,0,62,0],[0,0,0,422,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,0,0,0,258,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0],[0,0,0,0,0,483,483,353,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,484,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,137,246,431,0,58,0,59,0,0,0,139,0,0,0,0],[0,0,0,0,485,0,0,0,58,0,0,0,0,0,0,0,0,0,0],[0,0,0,444,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,435,225,0,0,0,0],[0,0,0,432,116,433,445,8,161,0,162,0,0,435,120,0,0,16,0],[0,0,0,432,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,0,486,486,361,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,487,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,439,440,441,442,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,440,440,442,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,488,488,442,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,489,488,488,442,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,490,491,492,493,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,495,0,496,497,0,161,0,162,0,0,498,0,0,0,0,0],[0,0,0,0,116,445,445,8,161,0,162,0,0,0,120,0,0,16,0],[0,0,0,0,225,44,44,8,161,0,0,0,0,0,225,0,0,0,0],[0,0,0,0,370,447,447,22,23,0,24,0,0,0,374,0,0,27,0],[0,0,0,0,450,80,80,22,23,0,0,0,0,0,450,0,0,0,0],[0,0,0,499,500,501,502,22,23,0,24,0,0,503,504,0,0,27,0],[0,448,0,505,0,177,177,22,23,0,24,0,0,0,78,0,448,0,0],[0,448,0,0,0,175,506,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,507,500,508,509,22,23,0,24,0,0,510,504,0,0,27,0],[0,0,0,0,0,0,0,295,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,292,0,0],[0,0,0,0,0,0,511,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,388,456,456,32,33,0,34,0,0,0,392,0,0,37,0],[0,0,0,0,459,101,101,32,33,0,0,0,0,0,459,0,0,0,0],[0,0,0,512,513,514,515,32,33,0,34,0,0,516,517,0,0,37,0],[0,457,0,518,0,203,203,32,33,0,34,0,0,0,99,0,457,0,0],[0,457,0,0,0,201,519,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,520,513,521,522,32,33,0,34,0,0,523,517,0,0,37,0],[0,0,0,0,0,0,0,315,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,312,0,0],[0,0,0,0,0,0,524,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,525,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,527,0,0,0,40,528,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,468,529,0,0,0,0],[0,0,0,464,465,466,526,8,9,0,10,0,0,468,469,0,0,16,0],[0,0,0,464,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,530,64,0,0,40,528,0,9,0,10,0,0,0,42,0,530,0,0],[0,407,0,0,0,121,121,0,9,0,10,0,0,0,42,0,407,0,0],[0,407,0,470,0,121,121,0,9,0,10,0,0,0,42,0,407,0,0],[0,0,0,525,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,475,529,0,0,0,0],[0,0,0,472,465,473,526,8,9,0,10,0,0,475,469,0,0,16,0],[0,0,0,472,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40,0,0],[0,0,0,0,415,478,478,57,58,0,59,0,0,0,419,0,0,62,0],[0,0,0,0,481,141,141,57,58,0,0,0,0,0,481,0,0,0,0],[0,0,0,531,532,533,534,57,58,0,59,0,0,535,536,0,0,62,0],[0,479,0,537,0,248,248,57,58,0,59,0,0,0,139,0,479,0,0],[0,479,0,0,0,246,538,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,539,532,540,541,57,58,0,59,0,0,542,536,0,0,62,0],[0,0,0,0,0,0,0,353,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,350,0,0],[0,0,0,0,0,0,543,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,361,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,358,0,0],[0,0,0,0,0,544,544,442,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,545,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,491,492,493,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,492,492,494,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,546,546,494,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,547,546,546,494,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,548,549,368,550,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,274,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,161,0,0,0,0,498,0,0,0,0,0],[0,0,0,495,0,496,368,0,161,0,162,0,0,498,0,0,0,0,0],[0,0,0,495,0,368,368,0,161,0,162,0,0,0,0,0,0,0,0],[0,0,0,551,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,553,0,0,0,76,554,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,503,555,0,0,0,0],[0,0,0,499,500,501,552,22,23,0,24,0,0,503,504,0,0,27,0],[0,0,0,499,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,556,90,0,0,76,554,0,23,0,24,0,0,0,78,0,556,0,0],[0,448,0,0,0,175,175,0,23,0,24,0,0,0,78,0,448,0,0],[0,448,0,505,0,175,175,0,23,0,24,0,0,0,78,0,448,0,0],[0,0,0,551,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,510,555,0,0,0,0],[0,0,0,507,500,508,552,22,23,0,24,0,0,510,504,0,0,27,0],[0,0,0,507,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,76,0,0],[0,0,0,557,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,559,0,0,0,97,560,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,516,561,0,0,0,0],[0,0,0,512,513,514,558,32,33,0,34,0,0,516,517,0,0,37,0],[0,0,0,512,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,562,111,0,0,97,560,0,33,0,34,0,0,0,99,0,562,0,0],[0,457,0,0,0,201,201,0,33,0,34,0,0,0,99,0,457,0,0],[0,457,0,518,0,201,201,0,33,0,34,0,0,0,99,0,457,0,0],[0,0,0,557,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,523,561,0,0,0,0],[0,0,0,520,513,521,558,32,33,0,34,0,0,523,517,0,0,37,0],[0,0,0,520,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,97,0,0],[0,0,0,0,465,526,526,8,9,0,10,0,0,0,469,0,0,16,0],[0,0,0,0,529,44,44,8,9,0,0,0,0,0,529,0,0,0,0],[0,0,0,563,66,564,565,8,9,0,10,0,0,566,68,0,0,16,0],[0,527,0,567,0,123,123,8,9,0,10,0,0,0,42,0,527,0,0],[0,527,0,0,0,121,568,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,569,66,570,571,8,9,0,10,0,0,572,68,0,0,16,0],[0,0,0,573,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,575,0,0,0,137,576,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,535,577,0,0,0,0],[0,0,0,531,532,533,574,57,58,0,59,0,0,535,536,0,0,62,0],[0,0,0,531,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,578,151,0,0,137,576,0,58,0,59,0,0,0,139,0,578,0,0],[0,479,0,0,0,246,246,0,58,0,59,0,0,0,139,0,479,0,0],[0,479,0,537,0,246,246,0,58,0,59,0,0,0,139,0,479,0,0],[0,0,0,573,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,542,577,0,0,0,0],[0,0,0,539,532,540,574,57,58,0,59,0,0,542,536,0,0,62,0],[0,0,0,539,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,137,0,0],[0,0,0,0,0,0,0,442,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,439,0,0],[0,0,0,0,0,579,579,494,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,580,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,549,368,550,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,0,368,368,0,161,0,162,0,0,0,362,0,0,0,0],[0,0,0,0,581,0,0,0,161,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,500,552,552,22,23,0,24,0,0,0,504,0,0,27,0],[0,0,0,0,555,80,80,22,23,0,0,0,0,0,555,0,0,0,0],[0,0,0,582,91,583,584,22,23,0,24,0,0,585,93,0,0,27,0],[0,553,0,586,0,177,177,22,23,0,24,0,0,0,78,0,553,0,0],[0,553,0,0,0,175,587,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,588,91,589,590,22,23,0,24,0,0,591,93,0,0,27,0],[0,0,0,0,513,558,558,32,33,0,34,0,0,0,517,0,0,37,0],[0,0,0,0,561,101,101,32,33,0,0,0,0,0,561,0,0,0,0],[0,0,0,592,112,593,594,32,33,0,34,0,0,595,114,0,0,37,0],[0,559,0,596,0,203,203,32,33,0,34,0,0,0,99,0,559,0,0],[0,559,0,0,0,201,597,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,598,112,599,600,32,33,0,34,0,0,601,114,0,0,37,0],[0,0,0,602,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,566,165,0,0,0,0],[0,0,0,563,66,564,67,8,9,0,10,0,0,566,68,0,0,16,0],[0,0,0,563,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,527,0,0,0,121,121,0,9,0,10,0,0,0,42,0,527,0,0],[0,527,0,567,0,121,121,0,9,0,10,0,0,0,42,0,527,0,0],[0,0,0,602,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,165,44,44,8,9,0,0,0,0,572,165,0,0,0,0],[0,0,0,569,66,570,67,8,9,0,10,0,0,572,68,0,0,16,0],[0,0,0,569,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,0,532,574,574,57,58,0,59,0,0,0,536,0,0,62,0],[0,0,0,0,577,141,141,57,58,0,0,0,0,0,577,0,0,0,0],[0,0,0,603,152,604,605,57,58,0,59,0,0,606,154,0,0,62,0],[0,575,0,607,0,248,248,57,58,0,59,0,0,0,139,0,575,0,0],[0,575,0,0,0,246,608,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,609,152,610,611,57,58,0,59,0,0,612,154,0,0,62,0],[0,0,0,0,0,0,0,494,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,491,0,0],[0,0,0,0,0,0,613,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,614,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,585,194,0,0,0,0],[0,0,0,582,91,583,92,22,23,0,24,0,0,585,93,0,0,27,0],[0,0,0,582,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,553,0,0,0,175,175,0,23,0,24,0,0,0,78,0,553,0,0],[0,553,0,586,0,175,175,0,23,0,24,0,0,0,78,0,553,0,0],[0,0,0,614,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,194,80,80,22,23,0,0,0,0,591,194,0,0,0,0],[0,0,0,588,91,589,92,22,23,0,24,0,0,591,93,0,0,27,0],[0,0,0,588,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,615,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,595,220,0,0,0,0],[0,0,0,592,112,593,113,32,33,0,34,0,0,595,114,0,0,37,0],[0,0,0,592,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,559,0,0,0,201,201,0,33,0,34,0,0,0,99,0,559,0,0],[0,559,0,596,0,201,201,0,33,0,34,0,0,0,99,0,559,0,0],[0,0,0,615,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,220,101,101,32,33,0,0,0,0,601,220,0,0,0,0],[0,0,0,598,112,599,113,32,33,0,34,0,0,601,114,0,0,37,0],[0,0,0,598,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,66,67,67,8,9,0,10,0,0,0,68,0,0,16,0],[0,0,0,616,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,606,265,0,0,0,0],[0,0,0,603,152,604,153,57,58,0,59,0,0,606,154,0,0,62,0],[0,0,0,603,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,575,0,0,0,246,246,0,58,0,59,0,0,0,139,0,575,0,0],[0,575,0,607,0,246,246,0,58,0,59,0,0,0,139,0,575,0,0],[0,0,0,616,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,265,141,141,57,58,0,0,0,0,612,265,0,0,0,0],[0,0,0,609,152,610,153,57,58,0,59,0,0,612,154,0,0,62,0],[0,0,0,609,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,549,0,0],[0,0,0,0,91,92,92,22,23,0,24,0,0,0,93,0,0,27,0],[0,0,0,0,112,113,113,32,33,0,34,0,0,0,114,0,0,37,0],[0,0,0,0,152,153,153,57,58,0,59,0,0,0,154,0,0,62,0]],"accepting":[false,true,true,true,true,true,false,false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,false,false,true,true,true,true,true,true,true,true,true,true,false,true,true,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,false,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,true,true,true,false,true,false,true,true,false,false,true,true,true,true,true,true,true,false,true,true,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,true,false,true,false,true,true,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,false,true,false,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,true,true,true,false,true,true,false,false,false,false,true,true,false,false,true,true,true,false,true,true,false,false,true,false,true,true,false,true,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,true,true,false,false,false,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,true,false,true,false,true,true,false,false,true,true,false,false,true,true,true,false,true,false,true,true,true,true,false,false,false,true,false,true,true,true,true,false,false,false,true,true,false,true,true,true,true,true,true,false,true,true,false,true,false,true,true,true,true,false,false,false,false,false,false,false,true,true,false,false,true,true,false,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,true,true,false,true,true,true,true,true,true,false,true,true,false,true,false,true,true,true,true,true,true,false,true,true,true,true,true,true,false,true,true,false,false,false,false,false,true,true,false,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,true,true,true,false,true,true,true,false,true,true,true,true,false,false,false,true,false,true,true,true,true,true,false,true,true,true,false,true,true,true,true,true,false,true,true,true,true,false,true,true,true,true,true,false,true,true,false,true,true,true],"tags":[[],["broken_cluster"],["consonant_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["consonant_syllable"],["broken_cluster"],["symbol_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["broken_cluster"],["broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],[],["broken_cluster"],["symbol_cluster"],[],["symbol_cluster"],["symbol_cluster"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["symbol_cluster"],["symbol_cluster"],["symbol_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],[],["broken_cluster"],["broken_cluster"],[],[],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["broken_cluster"],["symbol_cluster"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],[],["consonant_syllable"],["consonant_syllable"],[],[],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],[],["vowel_syllable"],["vowel_syllable"],[],[],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],[],[],[],["broken_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],["standalone_cluster"],["standalone_cluster"],[],[],["standalone_cluster"],["standalone_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],[],[],[],["consonant_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],[],[],[],["vowel_syllable"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],[],[],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],["standalone_cluster"],[],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],[],[],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],[],[],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],[],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],[],[],[],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],[],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],[],[],[],[],["consonant_syllable","broken_cluster"],["consonant_syllable","broken_cluster"],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],[],[],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],["consonant_syllable"],[],["consonant_syllable"],["consonant_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],["vowel_syllable"],[],["vowel_syllable"],["vowel_syllable"],["broken_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],["standalone_cluster"],[],["standalone_cluster"],["standalone_cluster"],[],["consonant_syllable"],["vowel_syllable"],["standalone_cluster"]]}');
var $aa333a9607471296$exports = {};
$aa333a9607471296$exports = JSON.parse('{"categories":["O","IND","S","GB","B","FM","CGJ","VMAbv","VMPst","VAbv","VPst","CMBlw","VPre","VBlw","H","VMBlw","CMAbv","MBlw","CS","R","SUB","MPst","MPre","FAbv","FPst","FBlw","SMAbv","SMBlw","VMPre","ZWNJ","ZWJ","WJ","VS","N","HN","MAbv"],"decompositions":{"2507":[2503,2494],"2508":[2503,2519],"2888":[2887,2902],"2891":[2887,2878],"2892":[2887,2903],"3018":[3014,3006],"3019":[3015,3006],"3020":[3014,3031],"3144":[3142,3158],"3264":[3263,3285],"3271":[3270,3285],"3272":[3270,3286],"3274":[3270,3266],"3275":[3270,3266,3285],"3402":[3398,3390],"3403":[3399,3390],"3404":[3398,3415],"3546":[3545,3530],"3548":[3545,3535],"3549":[3545,3535,3530],"3550":[3545,3551],"3635":[3661,3634],"3763":[3789,3762],"3955":[3953,3954],"3957":[3953,3956],"3958":[4018,3968],"3959":[4018,3953,3968],"3960":[4019,3968],"3961":[4019,3953,3968],"3969":[3953,3968],"6971":[6970,6965],"6973":[6972,6965],"6976":[6974,6965],"6977":[6975,6965],"6979":[6978,6965],"69934":[69937,69927],"69935":[69938,69927],"70475":[70471,70462],"70476":[70471,70487],"70843":[70841,70842],"70844":[70841,70832],"70846":[70841,70845],"71098":[71096,71087],"71099":[71097,71087]},"stateTable":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[2,2,3,4,4,5,0,6,7,8,9,10,11,12,13,14,15,16,0,17,18,11,19,20,21,22,0,0,23,0,0,2,0,24,0,25],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,26,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0,0,0,27,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,39,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,39,0,0,47],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,0,0,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,9,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,10,11,12,13,14,0,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,9,0,0,12,0,14,0,0,0,0,0,0,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,10,11,12,13,14,15,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,0,0,0,0,11,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,4,4,5,0,6,7,8,9,10,11,12,13,14,15,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,48,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,49,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,16,0,0,0,11,0,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,20,21,22,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,21,22,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,0,0,0,0,0,0,14,0,0,0,0,0,0,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,51,0],[0,0,0,0,0,5,0,6,7,8,9,0,11,12,0,14,0,16,0,0,0,11,0,20,21,22,0,0,23,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,27,28,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,0,0,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,33,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,0,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,33,0,0,36,0,38,0,0,0,0,0,0,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,34,35,36,37,38,39,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,0,0,0,0,35,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,52,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,53,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,40,0,0,0,35,0,43,44,45,0,0,46,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,43,44,45,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,44,45,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,0,0,0,0,0,0,38,0,0,0,0,0,0,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,29,0,30,31,32,33,0,35,36,0,38,0,40,0,0,0,35,0,43,44,45,0,0,46,0,0,0,0,0,0,0],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,0,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,5,0,6,7,8,9,48,11,12,13,14,48,16,0,0,18,11,19,20,21,22,0,0,23,0,0,0,0,0,0,25],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,51,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,54,0,0],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,0,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,0,0,0,47],[0,0,0,0,0,29,0,30,31,32,33,52,35,36,37,38,52,40,0,0,41,35,42,43,44,45,0,0,46,0,0,0,0,0,0,47],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,50,0,51,0]],"accepting":[false,true,true,true,true,true,true,true,true,true,true,true,true,false,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true],"tags":[[],["broken_cluster"],["independent_cluster"],["symbol_cluster"],["standard_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],[],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["broken_cluster"],["numeral_cluster"],["broken_cluster"],["independent_cluster"],["symbol_cluster"],["symbol_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["virama_terminated_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["standard_cluster"],["broken_cluster"],["broken_cluster"],["numeral_cluster"],["number_joiner_terminated_cluster"],["standard_cluster"],["standard_cluster"],["numeral_cluster"]]}');
var $90a9d3398ee54fe5$export$a513ea61a7bee91c = {
  X: 1,
  C: 2,
  V: 4,
  N: 8,
  H: 16,
  ZWNJ: 32,
  ZWJ: 64,
  M: 128,
  SM: 256,
  VD: 512,
  A: 1024,
  Placeholder: 2048,
  Dotted_Circle: 4096,
  RS: 8192,
  Coeng: 16384,
  Repha: 32768,
  Ra: 65536,
  CM: 131072,
  Symbol: 262144
  // Avagraha, etc that take marks (SM,A,VD).
};
var $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0 = {
  Start: 1,
  Ra_To_Become_Reph: 2,
  Pre_M: 4,
  Pre_C: 8,
  Base_C: 16,
  After_Main: 32,
  Above_C: 64,
  Before_Sub: 128,
  Below_C: 256,
  After_Sub: 512,
  Before_Post: 1024,
  Post_C: 2048,
  After_Post: 4096,
  Final_C: 8192,
  SMVD: 16384,
  End: 32768
};
var $90a9d3398ee54fe5$export$8519deaa7de2b07 = $90a9d3398ee54fe5$export$a513ea61a7bee91c.C | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Ra | $90a9d3398ee54fe5$export$a513ea61a7bee91c.CM | $90a9d3398ee54fe5$export$a513ea61a7bee91c.V | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Placeholder | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Dotted_Circle;
var $90a9d3398ee54fe5$export$bbcd928767338e0d = $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWJ | $90a9d3398ee54fe5$export$a513ea61a7bee91c.ZWNJ;
var $90a9d3398ee54fe5$export$ca9599b2a300afc = $90a9d3398ee54fe5$export$a513ea61a7bee91c.H | $90a9d3398ee54fe5$export$a513ea61a7bee91c.Coeng;
var $90a9d3398ee54fe5$export$e99d119da76a0fc5 = {
  Default: {
    hasOldSpec: false,
    virama: 0,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Devanagari: {
    hasOldSpec: true,
    virama: 2381,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Bengali: {
    hasOldSpec: true,
    virama: 2509,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Sub,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Gurmukhi: {
    hasOldSpec: true,
    virama: 2637,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Sub,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Gujarati: {
    hasOldSpec: true,
    virama: 2765,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Before_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Oriya: {
    hasOldSpec: true,
    virama: 2893,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Main,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Tamil: {
    hasOldSpec: true,
    virama: 3021,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
    rephMode: "Implicit",
    blwfMode: "Pre_And_Post"
  },
  Telugu: {
    hasOldSpec: true,
    virama: 3149,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
    rephMode: "Explicit",
    blwfMode: "Post_Only"
  },
  Kannada: {
    hasOldSpec: true,
    virama: 3277,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Post,
    rephMode: "Implicit",
    blwfMode: "Post_Only"
  },
  Malayalam: {
    hasOldSpec: true,
    virama: 3405,
    basePos: "Last",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.After_Main,
    rephMode: "Log_Repha",
    blwfMode: "Pre_And_Post"
  },
  // Handled by UniversalShaper
  // Sinhala: {
  //   hasOldSpec: false,
  //   virama: 0x0DCA,
  //   basePos: 'Last_Sinhala',
  //   rephPos: POSITIONS.After_Main,
  //   rephMode: 'Explicit',
  //   blwfMode: 'Pre_And_Post'
  // },
  Khmer: {
    hasOldSpec: false,
    virama: 6098,
    basePos: "First",
    rephPos: $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0.Ra_To_Become_Reph,
    rephMode: "Vis_Repha",
    blwfMode: "Pre_And_Post"
  }
};
var $90a9d3398ee54fe5$export$f647c9cfdd77d95a = {
  // Khmer
  6078: [
    6081,
    6078
  ],
  6079: [
    6081,
    6079
  ],
  6080: [
    6081,
    6080
  ],
  6084: [
    6081,
    6084
  ],
  6085: [
    6081,
    6085
  ]
};
var { decompositions: $7826f90f6f0cecc9$var$decompositions } = (0, $parcel$interopDefault2($aa333a9607471296$exports));
var $7826f90f6f0cecc9$var$trie = new (0, import_unicode_trie2.default)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)("AAARAAAAAACgwgAAAbENTvLtnX+sHUUVx/f13nd/vHf7bl+FRGL7R0OJMcWYphBrimkVCSJR2xiEaLEGQ7AkBGowbYRSgj8K2B/GkpRYE6wlQSyJKCagrSlGkmqsqUZMY7S2CWkgqQViQSkt4Hfuzrx77tyZ2fm1u+/RPcknuzs7O3PmnDOzs7N73zteS5KXwKvgDTCnniTvBfPBJeAVpP2vFr69GGUtAkvAModyr0DeT4BrwCpwPVgDbga3ga+DjYbyluLcCvBN8F2wGWwHO8Ej4DjyPIbtz0DCeZpvD4CD4E/gb+AoOAFOgtPgLKiNJkkbTIKLwALwfvAh8GGwHFwFPg2uAzeCm8Ft4E5wN7gPPAi+D34AfgR+Ap7kx8+AZ8HvwZ/BEXAMvAheAa+Bc6OpzvVGknTABY30eB62C8GlYDFYCpaDq/n5z2J7PVgDbgG3N1KbrOdbWzby/N/G9i6wlR8/wLebUNcOll7vX7PLsQ4bdpAy92B/L3gK7AO/A38EfwX/AC+AkyT/m3x7mqdtYz7Gfq2ZJOPgPc3UXu/D9uJmmmcRT1uC7TJwZTONJxFL1+J4JbgBrAG3gNv5Nev5dhO2m3l54rqtON7RNLd1V8Z5auMfI+8Wbvv12P4Ux78AvyZl/Bb7fwD34HwH/EVR/t8t6rRlrYgFlHnMsdyXIupRFP+Gzv8Bb4CklSSjrTR9bz21uZx/Nj8v+uIFOJ4HFnJo3kWtNG6WkPSzBl1YbC8jeVfx+q+R9Pg48lxN8jFdhd8+01LrLTCdq6io8GNb1a8qKioqKioqKioc2cbXGcrWQ2Ynf9a9rmV/zVua9Dc16V/gz8pfxvar4A6wAdwL7gdbwUPgh+BR8AR4qpWuLe3D9gA4CA6DI+AoOAFOtdL1nNexfYs937fxDA8ubKf1zmv3dViI/Uvb9m2sqKioqAiHrVtehrH3TK2/3l4WZduioqIiDq+Rd1Jbef9ehnHmSnCtNNf7nOPcr8PHilO8jrfBF9v996lfwf6tUpl3tPvvdSjsvcwGnLt3Gsw/kzkpK8CdYH83my3Id0iT91WkL5xMktXgIfD85OD54zjfmYu5OFgN7h1LkmdBMg5fgbvAChzv49ujfEuZ3xlOk7kReTaSfL/B/jl+fMXsJLkb7AcPj8TlHC/zsgnYcyLd3zSh1vGAJr2ioqKiIn/eKXkMjn3/cWF5t/z6y37+K5urwP2YB36vPfw8yr7zeRjpu8g8cTf2H2+n89EtivLE93fs27Ez/Br2vM2+qWPl/ZyX9StFfQxW5v724PPxzXz7XHu4Pps5Jvtmiq13szmzfP0hlHkYHGn358bHeD0vYvsy+K+kz9vt/jy8gT40G1w4Rua0PN98nnaGf/e1G+mXIO2DY8P6Xz7WPz7Ky/7omJ0PBff4+B91fAqsAp8HXwI3gR04txbbdWDDWDpP/g7Yxs6BXWAP2AueJHo+M5bOpw+Cw+AIOApOgFMW7Xkdec6AkXH1+QfgyzbOTY73jy/C/gJ+/CCOP4D9xfz4I9h+TFMWtf9SRWzZwq7f0yi/L9voWSRbDfV/clx/3TuKfjoT26/iX813URx4tiVG3ay/sfFuJenb7J50A4mr1di/CZzLKZ6y2reunup4qzT+fM0wHp0PUD9+A7bYNJ5fn3eNP/Ft5bc0+S4n9/l1Gj+K82zesd1wfj3fZ79h2YyyVvLj7djfCR4xjJEyuy1+S/FyDt/MPwodn5hB8axrxy9nSBtYjOyHrs+BQ+B58E+u+wsWbWBtpb/hYL8RuA/pJ8fT2GffX+wl+daSa08jz9nxNG2k4963XBG/ZVhpUS573mh3BtPo7x/Eb7pE2yd5XvZssY/M/RZLc9SLeDsfD5gfTidi9//pwrzWu7t9lKcN7dxynthAh8vcKrQu1frHTGKBNF662KfoOXU1FsaFxe6x2kjClkBnGvXxwX0bytZ5unK+S9n2jxabTc5M0HUaIyTrfFa+Ljmflc9Xz7JtNdPa4eKz6WAPlb5l6xfLBzopWxcfncvSf7rHRJk2KSN2bKRsvcu2UZmxVIb9qd551e8rZcTERGuQ+qwIjERkjl2+djOlhWfpibnp/qxmP92FVr1/bc9GYxxuI5o3UzdukzYpj+H6nOxra9nHiaksjhDdsasPe9ca/CvOU1GVwUT4t8P921H4T8gsnkdIh+dn/pXrU0mnOZw21CbJv1P5LP0r4jtkbLH171BbCvavnFfeZ8L8K2wv/CuQRU6n/qWSNSbr2mO8xtK/U+Mq6Y/1yQyFJHHtv8Kn2uOC/Gvbf2VEPxJ9SvhY5d+Q+y21iRxLruOzsY6MWGrOkPHZ1b+jFuPzqEX/VcmoZkyIPT53k36/DZnrMd+K/Dbjs6kv6+6VYl9OU+WT07TplvMvWWhfVo3f4t48S+rbjIZl/1b5Xyd5vJdQiTyf7tUdMlbn0J9d/cn6c7M5DO1TNF0+bmT0Z3qdKaaoXeg1Lv7NEhufzyT/6vIKEeO1jX/psdi38a889qpkStcI/u12U3zE1Re+/Yv6QNwvdTDJGi9t2ps1XtKYDJ0PmcZKcU812sRxvms7J47mZ5c+SWJD5LPRg4qqj+nWL8Q5sRVrGar1EG0sOI6ndH3DVWL7wpeuwaY6O1Nh19N+Oqs5uI7Eto3aICxNrCn5rAuZ7Cn2bdJtfZPlL/k8Ld+ki6v9E56XPUvT52mV/YVvmMj2Zz8TEuNMTxfHuFfFUJ60OLrz1utODnFG47fLbSjXy0xSy4gN63EywlhMxWcNmK71svszi5OGTvdJe3rtd8ifB6I/mKBr1ap7uU/sqqTsMb+H5fxBFyuq+yqLnd7cmj33TwyOVVOwuj3nVXRtQtUGWR9jzI6kecZrKSKPuFakU2hZmXXZMDlsS1W9jBavv6eHpf3EtfJ7mKwYV0lX2g9FVY5N+Ung9aH1590+n3KLgEredfiez6u9svisY/Suk9Jsnkli1a+C1m/T7rzqd5UY9mfiXX9R92ibdZUIawTC96b1GBn6rDG1JsPv/b392SkiXVUGmyN0LO5LYi46Zf/Adc/QMaCo8TtG/bH1Z/TsW1QfUPRjm2cZee5PRaT33lEbnhlMax4qe1o/Y8a0icdaoOv9bsh+Hj6jonueoGtHumcMlX9lxLxXq7/D84fSzznGt6rtUerXxYU47/IcPeG3vqBbJ1StETZqg9fS2Akd/0Ovp+/CxD3P+/6bQwzJtsvyh5w+XjeXH9KfXGH3/VbSX4tS4XoftPZbnvcyxX1G5QvW1wbWTkbs7c3mTco6NWODbdxk3R9lGZo/aGxhiknTmETXLVs1c90u9+mBGCf6hs6fsmTq29sxPv8d82CuhCpNjGNjg31blGHrz1i41hd6nuYzbU3XhLQzj7Jt67Otw0uXUdDoH8e4F/joMdVui2dMJc3E+Tetvr6jEtPnPhJaVwz9Y7TDVlx1qnfitlEbtzlTVD0qX/pcm1esxI65PO3mU4eNrr5SZMz46FDE+aIlb5tntb1o/WOUETsW847pvNpaZH225eUpNnrS9yDy9wTysyr9XVOe63+qd3M6e4X6Ptd1Dpc1SdV53ZqFag1hpP+bE5f4ivY74BzXilzWWW1+S0TjJng91Gd9wmbNgpMVz6W8d7GJZwWtWp8p++c8fpjW0Vzff3dJfzGuoersEtnmpjVLupY48H6o7n8/C+kvJn+Lcd6q3QHx3usvZax3W8apvP6rev+UJSHfiCYe/h2aTwTaRi5DO28ZSd9zNhTfJ8b2je7drOo9HtNNbPMW03zOpq2qNqnKFN+0huhlMye2Pe9TdzfCedfxMlRfG7xjncaJ7fiXMYZk3X+ZvuKbXCGh8y8XH8TybajPTfq4tjG2/qb0RJO3SB19ba2SMuoNbW8R/g653qa9sdsRYsssu+ZxPss+tnayFd94yjofEi+hZdvo73q9jd3yisUYbfEpQ9XmMqUIm2fFZh4xkZeE1BNDL5v+ZcqXh/90bSwjflz8U0QcFWHzPOpy0amM+stqf1ad7LltVPqWmG3p3+GiIvLJf8duYA3NcBwbWRpkDXmo7RP+z5E6+8Xswz512dbrW2aMNrpKaBt9y45VR2j9efhAQL/PF38Xadq907NYC5dpZLy3kMX6PUHgeGGS3nfoPn9rObJ9s/4uMntnSt/J5TX+2ZRhtFcB8ZgVmyZbit8GCd/7/C7EOcYK7LdyjNhIlL81nqN/Xf9mOHt/anovP4X0tyem/OUZF9TmscY2nzEulq96ZeVwv2Bxxnwk3s9njT8m/YWOKl199fe53tTXyu5DLojfKWXej6R3RAPtDf1ex/PvtdJ8Q7aP7Ht6XpdXSJf8/wMdQuS/j0/HtKny9KbT+oT2K2ETuW7Tt09Uss5nCdWhjPuMTXzrztO4FHMy+V6TJaH9I6+2C5HPq9oc8xlKRva5rF8M/7tC26/6BsNFivQ//e1pVsyP19VrNrH1D5Wi7oUDdVp8Q5HVr1ztlzXPtH2Gc30+lMX3edH3ecm3fp0+Ps/IPvWH6OpiV7meEMlbzyIkpi1jtDU0Pmm6nMd0jU8bXK7N0jWkb/joHyNebfWgtrJpc0h7QiQP24aKqcwYPnTRIUmG63fRQ5VXLsekgy5NtVXVadLfpjzV9S6xYnuNri159ZmsmLCpJ8/6XSRGOaH659H+GLYtwhd51xvq31B9Qm0UavM84qhoKaNOnfwf"));
var $7826f90f6f0cecc9$var$stateMachine = new (0, import_dfa.default)((0, $parcel$interopDefault2($4b0735ca6c692ea5$exports)));
var $7826f90f6f0cecc9$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static planFeatures(plan) {
    plan.addStage($7826f90f6f0cecc9$var$setupSyllables);
    plan.addStage([
      "locl",
      "ccmp"
    ]);
    plan.addStage($7826f90f6f0cecc9$var$initialReordering);
    plan.addStage("nukt");
    plan.addStage("akhn");
    plan.addStage("rphf", false);
    plan.addStage("rkrf");
    plan.addStage("pref", false);
    plan.addStage("blwf", false);
    plan.addStage("abvf", false);
    plan.addStage("half", false);
    plan.addStage("pstf", false);
    plan.addStage("vatu");
    plan.addStage("cjct");
    plan.addStage("cfar", false);
    plan.addStage($7826f90f6f0cecc9$var$finalReordering);
    plan.addStage({
      local: [
        "init"
      ],
      global: [
        "pres",
        "abvs",
        "blws",
        "psts",
        "haln",
        "dist",
        "abvm",
        "blwm",
        "calt",
        "clig"
      ]
    });
    plan.unicodeScript = $130d1a642ebcd2b7$export$ce50e82f12a827a4(plan.script);
    plan.indicConfig = (0, $90a9d3398ee54fe5$export$e99d119da76a0fc5)[plan.unicodeScript] || (0, $90a9d3398ee54fe5$export$e99d119da76a0fc5).Default;
    plan.isOldSpec = plan.indicConfig.hasOldSpec && plan.script[plan.script.length - 1] !== "2";
  }
  static assignFeatures(plan, glyphs) {
    for (let i = glyphs.length - 1; i >= 0; i--) {
      let codepoint = glyphs[i].codePoints[0];
      let d = (0, $90a9d3398ee54fe5$export$f647c9cfdd77d95a)[codepoint] || $7826f90f6f0cecc9$var$decompositions[codepoint];
      if (d) {
        let decomposed = d.map((c2) => {
          let g3 = plan.font.glyphForCodePoint(c2);
          return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(plan.font, g3.id, [
            c2
          ], glyphs[i].features);
        });
        glyphs.splice(i, 1, ...decomposed);
      }
    }
  }
};
(0, _defineProperty)($7826f90f6f0cecc9$export$2e2bcd8739ae039, "zeroMarkWidths", "NONE");
function $7826f90f6f0cecc9$var$indicCategory(glyph) {
  return $7826f90f6f0cecc9$var$trie.get(glyph.codePoints[0]) >> 8;
}
function $7826f90f6f0cecc9$var$indicPosition(glyph) {
  return 1 << ($7826f90f6f0cecc9$var$trie.get(glyph.codePoints[0]) & 255);
}
var $7826f90f6f0cecc9$var$IndicInfo = class {
  constructor(category, position, syllableType, syllable) {
    this.category = category;
    this.position = position;
    this.syllableType = syllableType;
    this.syllable = syllable;
  }
};
function $7826f90f6f0cecc9$var$setupSyllables(font2, glyphs) {
  let syllable = 0;
  let last3 = 0;
  for (let [start3, end3, tags] of $7826f90f6f0cecc9$var$stateMachine.match(glyphs.map($7826f90f6f0cecc9$var$indicCategory))) {
    if (start3 > last3) {
      ++syllable;
      for (let i = last3; i < start3; i++)
        glyphs[i].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).X, (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).End, "non_indic_cluster", syllable);
    }
    ++syllable;
    for (let i = start3; i <= end3; i++)
      glyphs[i].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo(1 << $7826f90f6f0cecc9$var$indicCategory(glyphs[i]), $7826f90f6f0cecc9$var$indicPosition(glyphs[i]), tags[0], syllable);
    last3 = end3 + 1;
  }
  if (last3 < glyphs.length) {
    ++syllable;
    for (let i = last3; i < glyphs.length; i++)
      glyphs[i].shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).X, (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).End, "non_indic_cluster", syllable);
  }
}
function $7826f90f6f0cecc9$var$isConsonant(glyph) {
  return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$8519deaa7de2b07);
}
function $7826f90f6f0cecc9$var$isJoiner(glyph) {
  return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$bbcd928767338e0d);
}
function $7826f90f6f0cecc9$var$isHalantOrCoeng(glyph) {
  return glyph.shaperInfo.category & (0, $90a9d3398ee54fe5$export$ca9599b2a300afc);
}
function $7826f90f6f0cecc9$var$wouldSubstitute(glyphs, feature) {
  for (let glyph of glyphs)
    glyph.features = {
      [feature]: true
    };
  let GSUB = glyphs[0]._font._layoutEngine.engine.GSUBProcessor;
  GSUB.applyFeatures([
    feature
  ], glyphs);
  return glyphs.length === 1;
}
function $7826f90f6f0cecc9$var$consonantPosition(font2, consonant, virama) {
  let glyphs = [
    virama,
    consonant,
    virama
  ];
  if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "blwf") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "blwf"))
    return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C;
  else if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "pstf") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "pstf"))
    return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C;
  else if ($7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(0, 2), "pref") || $7826f90f6f0cecc9$var$wouldSubstitute(glyphs.slice(1, 3), "pref"))
    return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C;
  return (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;
}
function $7826f90f6f0cecc9$var$initialReordering(font2, glyphs, plan) {
  let indicConfig = plan.indicConfig;
  let features = font2._layoutEngine.engine.GSUBProcessor.features;
  let dottedCircle = font2.glyphForCodePoint(9676).id;
  let virama = font2.glyphForCodePoint(indicConfig.virama).id;
  if (virama) {
    let info = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font2, virama, [
      indicConfig.virama
    ]);
    for (let i = 0; i < glyphs.length; i++)
      if (glyphs[i].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C)
        glyphs[i].shaperInfo.position = $7826f90f6f0cecc9$var$consonantPosition(font2, glyphs[i].copy(), info);
  }
  for (let start3 = 0, end3 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, 0); start3 < glyphs.length; start3 = end3, end3 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, start3)) {
    let { category, syllableType } = glyphs[start3].shaperInfo;
    if (syllableType === "symbol_cluster" || syllableType === "non_indic_cluster")
      continue;
    if (syllableType === "broken_cluster" && dottedCircle) {
      let g3 = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font2, dottedCircle, [
        9676
      ]);
      g3.shaperInfo = new $7826f90f6f0cecc9$var$IndicInfo(1 << $7826f90f6f0cecc9$var$indicCategory(g3), $7826f90f6f0cecc9$var$indicPosition(g3), glyphs[start3].shaperInfo.syllableType, glyphs[start3].shaperInfo.syllable);
      let i = start3;
      while (i < end3 && glyphs[i].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha)
        i++;
      glyphs.splice(i++, 0, g3);
      end3++;
    }
    let base = end3;
    let limit = start3;
    let hasReph = false;
    if (indicConfig.rephPos !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph && features.rphf && start3 + 3 <= end3 && (indicConfig.rephMode === "Implicit" && !$7826f90f6f0cecc9$var$isJoiner(glyphs[start3 + 2]) || indicConfig.rephMode === "Explicit" && glyphs[start3 + 2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ)) {
      let g3 = [
        glyphs[start3].copy(),
        glyphs[start3 + 1].copy(),
        glyphs[start3 + 2].copy()
      ];
      if ($7826f90f6f0cecc9$var$wouldSubstitute(g3.slice(0, 2), "rphf") || indicConfig.rephMode === "Explicit" && $7826f90f6f0cecc9$var$wouldSubstitute(g3, "rphf")) {
        limit += 2;
        while (limit < end3 && $7826f90f6f0cecc9$var$isJoiner(glyphs[limit]))
          limit++;
        base = start3;
        hasReph = true;
      }
    } else if (indicConfig.rephMode === "Log_Repha" && glyphs[start3].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha) {
      limit++;
      while (limit < end3 && $7826f90f6f0cecc9$var$isJoiner(glyphs[limit]))
        limit++;
      base = start3;
      hasReph = true;
    }
    switch (indicConfig.basePos) {
      case "Last": {
        let i = end3;
        let seenBelow = false;
        do {
          let info = glyphs[--i].shaperInfo;
          if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i])) {
            if (info.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C && (info.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C || seenBelow)) {
              base = i;
              break;
            }
            if (info.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C)
              seenBelow = true;
            base = i;
          } else if (start3 < i && info.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ && glyphs[i - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H)
            break;
        } while (i > limit);
        break;
      }
      case "First":
        base = start3;
        for (let i = base + 1; i < end3; i++)
          if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i]))
            glyphs[i].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C;
    }
    if (hasReph && base === start3 && limit - base <= 2)
      hasReph = false;
    for (let i1 = start3; i1 < base; i1++) {
      let info = glyphs[i1].shaperInfo;
      info.position = Math.min((0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_C, info.position);
    }
    if (base < end3)
      glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;
    for (let i2 = base + 1; i2 < end3; i2++)
      if (glyphs[i2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {
        for (let j = i2 + 1; j < end3; j++)
          if ($7826f90f6f0cecc9$var$isConsonant(glyphs[j])) {
            glyphs[j].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Final_C;
            break;
          }
        break;
      }
    if (hasReph)
      glyphs[start3].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph;
    if (plan.isOldSpec) {
      let disallowDoubleHalants = plan.unicodeScript !== "Malayalam";
      for (let i = base + 1; i < end3; i++)
        if (glyphs[i].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H) {
          let j;
          for (j = end3 - 1; j > i; j--) {
            if ($7826f90f6f0cecc9$var$isConsonant(glyphs[j]) || disallowDoubleHalants && glyphs[j].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H)
              break;
          }
          if (glyphs[j].shaperInfo.category !== (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && j > i) {
            let t2 = glyphs[i];
            glyphs.splice(i, 0, ...glyphs.splice(i + 1, j - i));
            glyphs[j] = t2;
          }
          break;
        }
    }
    let lastPos = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Start;
    for (let i3 = start3; i3 < end3; i3++) {
      let info = glyphs[i3].shaperInfo;
      if (info.category & ((0, $90a9d3398ee54fe5$export$bbcd928767338e0d) | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).N | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).RS | (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).CM | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc) & info.category)) {
        info.position = lastPos;
        if (info.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && info.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
          for (let j = i3; j > start3; j--)
            if (glyphs[j - 1].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
              info.position = glyphs[j - 1].shaperInfo.position;
              break;
            }
        }
      } else if (info.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD)
        lastPos = info.position;
    }
    let last3 = base;
    for (let i4 = base + 1; i4 < end3; i4++) {
      if ($7826f90f6f0cecc9$var$isConsonant(glyphs[i4])) {
        for (let j = last3 + 1; j < i4; j++)
          if (glyphs[j].shaperInfo.position < (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD)
            glyphs[j].shaperInfo.position = glyphs[i4].shaperInfo.position;
        last3 = i4;
      } else if (glyphs[i4].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M)
        last3 = i4;
    }
    let arr = glyphs.slice(start3, end3);
    arr.sort((a2, b) => a2.shaperInfo.position - b.shaperInfo.position);
    glyphs.splice(start3, arr.length, ...arr);
    for (let i5 = start3; i5 < end3; i5++)
      if (glyphs[i5].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) {
        base = i5;
        break;
      }
    for (let i6 = start3; i6 < end3 && glyphs[i6].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph; i6++)
      glyphs[i6].features.rphf = true;
    let blwf = !plan.isOldSpec && indicConfig.blwfMode === "Pre_And_Post";
    for (let i7 = start3; i7 < base; i7++) {
      glyphs[i7].features.half = true;
      if (blwf)
        glyphs[i7].features.blwf = true;
    }
    for (let i8 = base + 1; i8 < end3; i8++) {
      glyphs[i8].features.abvf = true;
      glyphs[i8].features.pstf = true;
      glyphs[i8].features.blwf = true;
    }
    if (plan.isOldSpec && plan.unicodeScript === "Devanagari") {
      for (let i = start3; i + 1 < base; i++)
        if (glyphs[i].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Ra && glyphs[i + 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).H && (i + 1 === base || glyphs[i + 2].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ)) {
          glyphs[i].features.blwf = true;
          glyphs[i + 1].features.blwf = true;
        }
    }
    let prefLen = 2;
    if (features.pref && base + prefLen < end3)
      for (let i9 = base + 1; i9 + prefLen - 1 < end3; i9++) {
        let g3 = [
          glyphs[i9].copy(),
          glyphs[i9 + 1].copy()
        ];
        if ($7826f90f6f0cecc9$var$wouldSubstitute(g3, "pref")) {
          for (let j = 0; j < prefLen; j++)
            glyphs[i9++].features.pref = true;
          if (features.cfar)
            for (; i9 < end3; i9++)
              glyphs[i9].features.cfar = true;
          break;
        }
      }
    for (let i10 = start3 + 1; i10 < end3; i10++)
      if ($7826f90f6f0cecc9$var$isJoiner(glyphs[i10])) {
        let nonJoiner = glyphs[i10].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWNJ;
        let j = i10;
        do {
          j--;
          if (nonJoiner)
            delete glyphs[j].features.half;
        } while (j > start3 && !$7826f90f6f0cecc9$var$isConsonant(glyphs[j]));
      }
  }
}
function $7826f90f6f0cecc9$var$finalReordering(font2, glyphs, plan) {
  let indicConfig = plan.indicConfig;
  let features = font2._layoutEngine.engine.GSUBProcessor.features;
  for (let start3 = 0, end3 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, 0); start3 < glyphs.length; start3 = end3, end3 = $7826f90f6f0cecc9$var$nextSyllable(glyphs, start3)) {
    let tryPref = !!features.pref;
    let base = start3;
    for (; base < end3; base++)
      if (glyphs[base].shaperInfo.position >= (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C) {
        if (tryPref && base + 1 < end3) {
          for (let i = base + 1; i < end3; i++)
            if (glyphs[i].features.pref) {
              if (!(glyphs[i].substituted && glyphs[i].isLigated && !glyphs[i].isMultiplied)) {
                base = i;
                while (base < end3 && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[base]))
                  base++;
                glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).BASE_C;
                tryPref = false;
              }
              break;
            }
        }
        if (plan.unicodeScript === "Malayalam")
          for (let i = base + 1; i < end3; i++) {
            while (i < end3 && $7826f90f6f0cecc9$var$isJoiner(glyphs[i]))
              i++;
            if (i === end3 || !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[i]))
              break;
            i++;
            while (i < end3 && $7826f90f6f0cecc9$var$isJoiner(glyphs[i]))
              i++;
            if (i < end3 && $7826f90f6f0cecc9$var$isConsonant(glyphs[i]) && glyphs[i].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Below_C) {
              base = i;
              glyphs[base].shaperInfo.position = (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C;
            }
          }
        if (start3 < base && glyphs[base].shaperInfo.position > (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Base_C)
          base--;
        break;
      }
    if (base === end3 && start3 < base && glyphs[base - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).ZWJ)
      base--;
    if (base < end3)
      while (start3 < base && glyphs[base].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).N | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc)))
        base--;
    if (start3 + 1 < end3 && start3 < base) {
      let newPos = base === end3 ? base - 2 : base - 1;
      if (plan.unicodeScript !== "Malayalam" && plan.unicodeScript !== "Tamil") {
        while (newPos > start3 && !(glyphs[newPos].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc))))
          newPos--;
        if ($7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newPos]) && glyphs[newPos].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
          if (newPos + 1 < end3 && $7826f90f6f0cecc9$var$isJoiner(glyphs[newPos + 1]))
            newPos++;
        } else
          newPos = start3;
      }
      if (start3 < newPos && glyphs[newPos].shaperInfo.position !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
        for (let i = newPos; i > start3; i--)
          if (glyphs[i - 1].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M) {
            let oldPos = i - 1;
            if (oldPos < base && base <= newPos)
              base--;
            let tmp = glyphs[oldPos];
            glyphs.splice(oldPos, 0, ...glyphs.splice(oldPos + 1, newPos - oldPos));
            glyphs[newPos] = tmp;
            newPos--;
          }
      }
    }
    if (start3 + 1 < end3 && glyphs[start3].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Ra_To_Become_Reph && glyphs[start3].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).Repha !== (glyphs[start3].isLigated && !glyphs[start3].isMultiplied)) {
      let newRephPos;
      let rephPos = indicConfig.rephPos;
      let found = false;
      if (rephPos !== (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Post) {
        newRephPos = start3 + 1;
        while (newRephPos < base && !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos]))
          newRephPos++;
        if (newRephPos < base && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
          if (newRephPos + 1 < base && $7826f90f6f0cecc9$var$isJoiner(glyphs[newRephPos + 1]))
            newRephPos++;
          found = true;
        }
        if (!found && rephPos === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Main) {
          newRephPos = base;
          while (newRephPos + 1 < end3 && glyphs[newRephPos + 1].shaperInfo.position <= (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Main)
            newRephPos++;
          found = newRephPos < end3;
        }
        if (!found && rephPos === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Sub) {
          newRephPos = base;
          while (newRephPos + 1 < end3 && !(glyphs[newRephPos + 1].shaperInfo.position & ((0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Post_C | (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).After_Post | (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD)))
            newRephPos++;
          found = newRephPos < end3;
        }
      }
      if (!found) {
        newRephPos = start3 + 1;
        while (newRephPos < base && !$7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos]))
          newRephPos++;
        if (newRephPos < base && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
          if (newRephPos + 1 < base && $7826f90f6f0cecc9$var$isJoiner(glyphs[newRephPos + 1]))
            newRephPos++;
          found = true;
        }
      }
      if (!found) {
        newRephPos = end3 - 1;
        while (newRephPos > start3 && glyphs[newRephPos].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).SMVD)
          newRephPos--;
        if ($7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newRephPos])) {
          for (let i = base + 1; i < newRephPos; i++)
            if (glyphs[i].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M)
              newRephPos--;
        }
      }
      let reph = glyphs[start3];
      glyphs.splice(start3, 0, ...glyphs.splice(start3 + 1, newRephPos - start3));
      glyphs[newRephPos] = reph;
      if (start3 < base && base <= newRephPos)
        base--;
    }
    if (tryPref && base + 1 < end3) {
      for (let i = base + 1; i < end3; i++)
        if (glyphs[i].features.pref) {
          if (glyphs[i].isLigated && !glyphs[i].isMultiplied) {
            let newPos = base;
            if (plan.unicodeScript !== "Malayalam" && plan.unicodeScript !== "Tamil") {
              while (newPos > start3 && !(glyphs[newPos - 1].shaperInfo.category & ((0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M | (0, $90a9d3398ee54fe5$export$ca9599b2a300afc))))
                newPos--;
              if (newPos > start3 && glyphs[newPos - 1].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {
                let oldPos2 = i;
                for (let j = base + 1; j < oldPos2; j++)
                  if (glyphs[j].shaperInfo.category === (0, $90a9d3398ee54fe5$export$a513ea61a7bee91c).M) {
                    newPos--;
                    break;
                  }
              }
            }
            if (newPos > start3 && $7826f90f6f0cecc9$var$isHalantOrCoeng(glyphs[newPos - 1])) {
              if (newPos < end3 && $7826f90f6f0cecc9$var$isJoiner(glyphs[newPos]))
                newPos++;
            }
            let oldPos = i;
            let tmp = glyphs[oldPos];
            glyphs.splice(newPos + 1, 0, ...glyphs.splice(newPos, oldPos - newPos));
            glyphs[newPos] = tmp;
            if (newPos <= base && base < oldPos)
              base++;
          }
          break;
        }
    }
    if (glyphs[start3].shaperInfo.position === (0, $90a9d3398ee54fe5$export$1a1f61c9c4dd9df0).Pre_M && (!start3 || !/Cf|Mn/.test((0, $747425b437e121da$export$410364bbb673ddbc)(glyphs[start3 - 1].codePoints[0]))))
      glyphs[start3].features.init = true;
  }
}
function $7826f90f6f0cecc9$var$nextSyllable(glyphs, start3) {
  if (start3 >= glyphs.length)
    return start3;
  let syllable = glyphs[start3].shaperInfo.syllable;
  while (++start3 < glyphs.length && glyphs[start3].shaperInfo.syllable === syllable)
    ;
  return start3;
}
var { categories: $7ab494fe977143c6$var$categories, decompositions: $7ab494fe977143c6$var$decompositions } = (0, $parcel$interopDefault2($aa333a9607471296$exports));
var $7ab494fe977143c6$var$trie = new (0, import_unicode_trie2.default)((0, $12727730ddfc8bfe$export$94fdf11bafc8de6b)("AAACAAAAAADQqQAAAVEMrvPtnH+oHUcVx+fd99799W5e8mx+9NkYm7YUI2KtimkVDG3FWgVTFY1Fqa2VJirYB0IaUFLBaKGJViXir6oxKCSBoi0UTKtg2yA26h+milYNtMH+0WK1VQyvtBS/487hnncyMzuzu7N7n7kHPszu7OzMmTNzdmdmfzzfUmpiUqkemAMbwSZwKbjcxM1XEL4VvB28G3zAk+56cLMlfgdYADvBbvBF8GWwH9xl+CFLfwj8BPwU/MKS38/AMfA86v9ro9ucQcdR+CjCP4CT4EnwDPg3eAFMTik1A+bAPNgINoFLwGawZSpLfzXCrWAb+AjYDm4BO8FusAfsA/vBXeAgOALuNfv3g4fAcXACPAaeAE+B58Bp8NJUpnN7WqlZsHY629+A8GLwWvAG8BZwJXinOf5ehB8EN4AdYGE6q7dmF9uugs8hvz0V58nZK/L+Kva/BX4ADoN7prP6HgUPgkfA73L0eQzHnwBPgX+Y80+DF8FUW6lBO4tbjXA9uAi8pj3sS2/E9mawBVwNtoJt5pzrTXgzwk+B7awP7sT+7nY6WxFfQBlfAl8H3wU/Anezcu/D9s/BMRN3HOEJ8EdwMkC/J5HmmXZmq2fBIjgEVEepbieLX4Fw0MnSrzRxmrVsm7MB8ReDV4vjr3ekJy7rZGVPMb196Xm6oug83oRyt4CrwDVgK9gGPtzxn3uTOD6YPDPNJ5Hm0+AznazffJ7Z4KSnXncg3VfAN8EBhx42/z/UGdbrx52sr9yH8AFTrt5+2GzfnWPbKuw7ZszZyNh/xowZM2bMmDFjxsQyZ5lPNs3h9nBNYHuAfr9ic9ffiHnsJzznU91/j3P+2snWYf6G8O/gn+A0eMnEt7vQp5ulX4NwHmwEm7rZ8UsRXg6uMPvXIHwPuK7rLl+nu9FzfMyYMWPGpGVuslmarv+YMWPSkNq/d2D8uNDNngvdivA2y3jy9m72bF9v3ymOf2MExp8fG2TsAcfA2wJYBJetWBq3i+0fwPafwLmzSl0LFmZNPMLHZ4fpnsX2AdjgcXB+T6kPge+AG7D/vXYW/tLsc9r9M+MkVyLNR1m6g9g+ZfYvmMExcHCm+ftP0+T5y/e17Uw/PYLwHnC0m80TH+zG30/3mjSDnPS2/B4pUJ4rX3n+b5H3o92l6UjfvZ7y/oJzToGnu8O66XTPYf8/Jr8XWL6TPXf9bPnHtmVs+89AnxVgDVgPLgKvAg+Y/F6H7c1gC7jKHH8XeJ/x15vAjt4wvwVs7wKfBXvAPvA18G1wsJevj36f5gjS3etIq+ft9+PYQ73h/nFsn2D7f+5l75bo/VPYftpTblFb2/Jo2pdjfL0uXOX/qxfnp8vZVk2Xv9hbmu+LxvYt3A/7/WZsPoptPkr9bdCv1ya+d4TuMO8Tre5n4XkILwSbzP4l/WHazX1//r2O/z7cFHnvSYW8R/Vm02ZXIHxHze1Xdf9bbn7p0z2kDroNr2X9WL+7937sX9fP+v9h9n6jTrfI3jG9EfsfN3G35PR/G4uRfY3eMTwdkFa/C3hrf2kcfy/xYTOmprrfZsLbEe7rDPW/U9Rrv9k/ahmTL0cWWxP/YxRkgtES+zwNhZPs+FQgMj/liEsto2HxsZBQX2pZoLZqWc5riXDaQBLSt1L3hcnE+Vct7aYVKCEhbXk2+b7NZ84mmXAwCiL14Ne85S62MYPcXi5StM/YxlJF2lfabznZsC6/C807xvZV+yFve9d1KY//d3HNO8pKUXuTDh0Gpp7B852q6QFMgdWM2dfbAxOuEPQEfcEsO5fquJLZrMfyCtWP0heZF6oSdiH9u4aQvJRIJ/eL6BBynItLp5D2JRkY5L5u3xAf6lviXHWSZcfaKO/+5zvO/c9Xtq8uRXSObd+8bS0zJrS1rxTyX7k/a0nrk5D+mHeOC90uq1Q216X57lykfqHt62uTGJ2rat+i/kttyq/RSi29PlclZf2Xxq55ZeSV34T96d5X5PqZJ9I3ZX2lnkXt3xL1Kyrav/LutbZ6uGxuS6ss6V3pXOXY4kP7EBfyJT7+4TJQS9uf74f6n+3+6ZIi9bCtieatFfCxUMx4KMYfy/pzrB30vm88q9SZ11K+n9eeNN612UFKWX8uI9TmRca7TbWvKy2JvF6naF+b/0uRupZp35cZikhZvyniY2R/CbdB3vXynIC6hbRBHf4l1xps6w4x/lVEtxRtGZMuRA8uNh/jfYV8kdpsBUszcODrD7E2JT2KrB3V6XMhbdNjcXItxzaOJWkpf976/I5glQn1sbLP86U9FQvz4l0S28/lcWUJbbrE2l+Z/TlHvi4/kvZXLMyrmy1PW7x8hl6UFgvlmNM1Jq3aJ3Se0yJcpdwS6mOp/ZgLX5N1rdFKaIzH9ztquMbqq+/qCFRk+hRoyZvrTHuO8fNd/djmEzZJ3TdisN1bNQNl7y96DV/3mVkTtwasVdk1ai6ybGlDek8nT1fXc4M5tVSPvhqOsWQeXQs8L1n3IradU8OxCeVjK7dr7Dpl0cMHnUvt18TzfVsfb/pZY56fV2GnVPVIYaOi9xcZJ8cmKcu3wcuPsVHV5cdKFfZXNZefp5sWft+wzR1cczKCxh99NRx76HvwOpWNv6YZtAajt6WPyPswtVVs/VOJ7xpYx3VR31er7gMxNuV9Q443CDlW43KuYSXblsybfKYt58trfez7A1X7Tdm+V7TcoudL+LpVGf2khN63U5OyD5Af0NoUv06l7Jc0Rte+so4xL9Ayy3Rz+SufY5Jf267xcm7J4dd3kumIOrmk7Pl549bUY1puI91Gdb8Tpu+9tjmhXFdwtfVsTv5SQvXKW0cK4eXgPBO6iJ07NNVOHH7/tF1jyJdnWbrU/Uau3VNI156QZ2ZaZFu76i6vQXy9YJ2H9QZ97aF3p1xlx1yfuYRcd0Kl7NyaX190+pUOKI0tvus5j7/nSWKLo3FER8R3LHEx8gqwge1POgi1l1yfirV3zHpISHxs3vLeFXOellcG1DFGbGP00PPkeKEOaXIsqhzbruOh9Qk5L08nW2grJ0avsvWocv0zRh/fGCG0TV35hB4v0rds5Vddjm/sFCKx+aXSt2yalPZsolxXW46CDnXp0YQ0rdso9OUYPSYT6+yzuxxzlrVfFfavQ/LKqsP+dbVzE/0qRb8pKin6V9U6Fnn24pqHufLMWy90nV+0DkXmcrb0Uq+6pU7/qcs/67SHTeTaaBk9ipyXQvLqW1U7uPKpux/ESlP9umydR8H3UjzHoXxj0/J1Yr5ubHsPrWOJqxK+hk5r+EVtH3pe1XWIXa+1vQ9YJ/oZre1bGReh3xKWeX7BxfYstwh5errGJi59be8482cSsfUPQT4Xlc9K+XMmatcY0fo2+SxYQs/4XO8M03Ng/TxujYH+FRELSdH+6mtveu8itb1Cy7C9X8GfsVOcfN86RHg56wJ0ob5qOz/E/rIdq7YhF34/0cfoeWKVftJjIbWDbDfXeXR/prBOKWJ/3dd43+sr+32TvgEIEZ6/7Zt5/l7ghMm77u+ey4gcz5xfktA5vE9C5vy2Y3lpXeX40tHcLMX42qZHS/ltZluXiSlDxillt3VdIvufbc0j75wy5aWaOxWRUZmfl5nDSh3LzoWbXJOg8uumKkndp1PnH2IPfe+U33z7vjWhdPQuWMh4raqxWMh9X89RZtSZ7/JpyXs3NWQcETN3CZHU/lmVnstZB1+ZfM5A/1VJ2V9t8wTXN1S+f27mzaulbCxJHePwC1Tz/0K1/VdPvtOsba+vL7ZxM1/jakJ/V9/yfdtNx+i7bhVRRll/rrK+sk3qLt/3T0afH+tzz1HDfxzZ/HlGDduK1y/GL21zvKptQGWFSpVlFm0z+ZxD/vdAt9EqQ971NkRHW7qytog53+cfVfeFGLStfddfYka5x6dl+yi//4z6/559aUn4/+/k2pv8BqfM/0qVCnu+If2OJPRZUcyzJF/5RQm5xtM9ln+LRN+8U9+iMQS1Veg9q2z/TlV3Ett3/rLOIXOookidy/5X3GYD+S8a1z2e0vH695T9vhEqdbY//0dU3jWZ2rYq/cvCRT8r08/NLlT5/zySdSurv1ybLiup5tAp5+NNzfPJ5r61warapajItfTQNeK610/rWEMPyb+uOo/ierRNbGU01Z+rqneIPWNsT9t1rD+OYr8rm0eKvp/Ch1P4Yepyy+hWVD/f+VWXX5X+TZdfZZ+KLb9J+S8="));
var $7ab494fe977143c6$var$stateMachine = new (0, import_dfa.default)((0, $parcel$interopDefault2($aa333a9607471296$exports)));
var $7ab494fe977143c6$export$2e2bcd8739ae039 = class extends (0, $649970d87335b30f$export$2e2bcd8739ae039) {
  static planFeatures(plan) {
    plan.addStage($7ab494fe977143c6$var$setupSyllables);
    plan.addStage([
      "locl",
      "ccmp",
      "nukt",
      "akhn"
    ]);
    plan.addStage($7ab494fe977143c6$var$clearSubstitutionFlags);
    plan.addStage([
      "rphf"
    ], false);
    plan.addStage($7ab494fe977143c6$var$recordRphf);
    plan.addStage($7ab494fe977143c6$var$clearSubstitutionFlags);
    plan.addStage([
      "pref"
    ]);
    plan.addStage($7ab494fe977143c6$var$recordPref);
    plan.addStage([
      "rkrf",
      "abvf",
      "blwf",
      "half",
      "pstf",
      "vatu",
      "cjct"
    ]);
    plan.addStage($7ab494fe977143c6$var$reorder);
    plan.addStage([
      "abvs",
      "blws",
      "pres",
      "psts",
      "dist",
      "abvm",
      "blwm"
    ]);
  }
  static assignFeatures(plan, glyphs) {
    for (let i = glyphs.length - 1; i >= 0; i--) {
      let codepoint = glyphs[i].codePoints[0];
      if ($7ab494fe977143c6$var$decompositions[codepoint]) {
        let decomposed = $7ab494fe977143c6$var$decompositions[codepoint].map((c2) => {
          let g3 = plan.font.glyphForCodePoint(c2);
          return new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(plan.font, g3.id, [
            c2
          ], glyphs[i].features);
        });
        glyphs.splice(i, 1, ...decomposed);
      }
    }
  }
};
(0, _defineProperty)($7ab494fe977143c6$export$2e2bcd8739ae039, "zeroMarkWidths", "BEFORE_GPOS");
function $7ab494fe977143c6$var$useCategory(glyph) {
  return $7ab494fe977143c6$var$trie.get(glyph.codePoints[0]);
}
var $7ab494fe977143c6$var$USEInfo = class {
  constructor(category, syllableType, syllable) {
    this.category = category;
    this.syllableType = syllableType;
    this.syllable = syllable;
  }
};
function $7ab494fe977143c6$var$setupSyllables(font2, glyphs) {
  let syllable = 0;
  for (let [start3, end3, tags] of $7ab494fe977143c6$var$stateMachine.match(glyphs.map($7ab494fe977143c6$var$useCategory))) {
    ++syllable;
    for (let i = start3; i <= end3; i++)
      glyphs[i].shaperInfo = new $7ab494fe977143c6$var$USEInfo($7ab494fe977143c6$var$categories[$7ab494fe977143c6$var$useCategory(glyphs[i])], tags[0], syllable);
    let limit = glyphs[start3].shaperInfo.category === "R" ? 1 : Math.min(3, end3 - start3);
    for (let i1 = start3; i1 < start3 + limit; i1++)
      glyphs[i1].features.rphf = true;
  }
}
function $7ab494fe977143c6$var$clearSubstitutionFlags(font2, glyphs) {
  for (let glyph of glyphs)
    glyph.substituted = false;
}
function $7ab494fe977143c6$var$recordRphf(font2, glyphs) {
  for (let glyph of glyphs)
    if (glyph.substituted && glyph.features.rphf)
      glyph.shaperInfo.category = "R";
}
function $7ab494fe977143c6$var$recordPref(font2, glyphs) {
  for (let glyph of glyphs)
    if (glyph.substituted)
      glyph.shaperInfo.category = "VPre";
}
function $7ab494fe977143c6$var$reorder(font2, glyphs) {
  let dottedCircle = font2.glyphForCodePoint(9676).id;
  for (let start3 = 0, end3 = $7ab494fe977143c6$var$nextSyllable(glyphs, 0); start3 < glyphs.length; start3 = end3, end3 = $7ab494fe977143c6$var$nextSyllable(glyphs, start3)) {
    let i, j;
    let info = glyphs[start3].shaperInfo;
    let type = info.syllableType;
    if (type !== "virama_terminated_cluster" && type !== "standard_cluster" && type !== "broken_cluster")
      continue;
    if (type === "broken_cluster" && dottedCircle) {
      let g3 = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(font2, dottedCircle, [
        9676
      ]);
      g3.shaperInfo = info;
      for (i = start3; i < end3 && glyphs[i].shaperInfo.category === "R"; i++)
        ;
      glyphs.splice(++i, 0, g3);
      end3++;
    }
    if (info.category === "R" && end3 - start3 > 1)
      for (i = start3 + 1; i < end3; i++) {
        info = glyphs[i].shaperInfo;
        if ($7ab494fe977143c6$var$isBase(info) || $7ab494fe977143c6$var$isHalant(glyphs[i])) {
          if ($7ab494fe977143c6$var$isHalant(glyphs[i]))
            i--;
          glyphs.splice(start3, 0, ...glyphs.splice(start3 + 1, i - start3), glyphs[i]);
          break;
        }
      }
    for (i = start3, j = end3; i < end3; i++) {
      info = glyphs[i].shaperInfo;
      if ($7ab494fe977143c6$var$isBase(info) || $7ab494fe977143c6$var$isHalant(glyphs[i]))
        j = $7ab494fe977143c6$var$isHalant(glyphs[i]) ? i + 1 : i;
      else if ((info.category === "VPre" || info.category === "VMPre") && j < i)
        glyphs.splice(j, 1, glyphs[i], ...glyphs.splice(j, i - j));
    }
  }
}
function $7ab494fe977143c6$var$nextSyllable(glyphs, start3) {
  if (start3 >= glyphs.length)
    return start3;
  let syllable = glyphs[start3].shaperInfo.syllable;
  while (++start3 < glyphs.length && glyphs[start3].shaperInfo.syllable === syllable)
    ;
  return start3;
}
function $7ab494fe977143c6$var$isHalant(glyph) {
  return glyph.shaperInfo.category === "H" && !glyph.isLigated;
}
function $7ab494fe977143c6$var$isBase(info) {
  return info.category === "B" || info.category === "GB";
}
var $102b6fe50f1d50b4$var$SHAPERS = {
  arab: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  mong: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  syrc: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  "nko ": (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  phag: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  mand: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  mani: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  phlp: (0, $764eb544bbe1ccf0$export$2e2bcd8739ae039),
  hang: (0, $e1c6bbc8cb416f8c$export$2e2bcd8739ae039),
  bng2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  beng: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  dev2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  deva: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  gjr2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  gujr: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  guru: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  gur2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  knda: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  knd2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  mlm2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  mlym: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  ory2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  orya: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  taml: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  tml2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  telu: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  tel2: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  khmr: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  bali: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  batk: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  brah: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  bugi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  buhd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  cakm: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  cham: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  dupl: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  egyp: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  gran: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  hano: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  java: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  kthi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  kali: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  khar: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  khoj: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sind: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  lepc: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  limb: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  mahj: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  // mand: UniversalShaper, // Mandaic
  // mani: UniversalShaper, // Manichaean
  mtei: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  modi: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  // mong: UniversalShaper, // Mongolian
  // 'nko ': UniversalShaper, // N’Ko
  hmng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  // phag: UniversalShaper, // Phags-pa
  // phlp: UniversalShaper, // Psalter Pahlavi
  rjng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  saur: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  shrd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sidd: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sinh: (0, $7826f90f6f0cecc9$export$2e2bcd8739ae039),
  sund: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  sylo: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tglg: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tagb: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tale: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  lana: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tavt: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  takr: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tibt: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tfng: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  tirh: (0, $7ab494fe977143c6$export$2e2bcd8739ae039),
  latn: (0, $649970d87335b30f$export$2e2bcd8739ae039),
  DFLT: (0, $649970d87335b30f$export$2e2bcd8739ae039)
};
function $102b6fe50f1d50b4$export$7877a478dd30fd3d(script) {
  if (!Array.isArray(script))
    script = [
      script
    ];
  for (let s2 of script) {
    let shaper = $102b6fe50f1d50b4$var$SHAPERS[s2];
    if (shaper)
      return shaper;
  }
  return 0, $649970d87335b30f$export$2e2bcd8739ae039;
}
var $0a876c45f1f7c41c$export$2e2bcd8739ae039 = class extends (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039) {
  applyLookup(lookupType, table) {
    switch (lookupType) {
      case 1: {
        let index3 = this.coverageIndex(table.coverage);
        if (index3 === -1)
          return false;
        let glyph = this.glyphIterator.cur;
        switch (table.version) {
          case 1:
            glyph.id = glyph.id + table.deltaGlyphID & 65535;
            break;
          case 2:
            glyph.id = table.substitute.get(index3);
            break;
        }
        return true;
      }
      case 2: {
        let index3 = this.coverageIndex(table.coverage);
        if (index3 !== -1) {
          let sequence = table.sequences.get(index3);
          if (sequence.length === 0) {
            this.glyphs.splice(this.glyphIterator.index, 1);
            return true;
          }
          this.glyphIterator.cur.id = sequence[0];
          this.glyphIterator.cur.ligatureComponent = 0;
          let features = this.glyphIterator.cur.features;
          let curGlyph = this.glyphIterator.cur;
          let replacement = sequence.slice(1).map((gid, i) => {
            let glyph = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, gid, void 0, features);
            glyph.shaperInfo = curGlyph.shaperInfo;
            glyph.isLigated = curGlyph.isLigated;
            glyph.ligatureComponent = i + 1;
            glyph.substituted = true;
            glyph.isMultiplied = true;
            return glyph;
          });
          this.glyphs.splice(this.glyphIterator.index + 1, 0, ...replacement);
          return true;
        }
        return false;
      }
      case 3: {
        let index3 = this.coverageIndex(table.coverage);
        if (index3 !== -1) {
          let USER_INDEX = 0;
          this.glyphIterator.cur.id = table.alternateSet.get(index3)[USER_INDEX];
          return true;
        }
        return false;
      }
      case 4: {
        let index3 = this.coverageIndex(table.coverage);
        if (index3 === -1)
          return false;
        for (let ligature of table.ligatureSets.get(index3)) {
          let matched = this.sequenceMatchIndices(1, ligature.components);
          if (!matched)
            continue;
          let curGlyph = this.glyphIterator.cur;
          let characters2 = curGlyph.codePoints.slice();
          for (let index4 of matched)
            characters2.push(...this.glyphs[index4].codePoints);
          let ligatureGlyph = new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, ligature.glyph, characters2, curGlyph.features);
          ligatureGlyph.shaperInfo = curGlyph.shaperInfo;
          ligatureGlyph.isLigated = true;
          ligatureGlyph.substituted = true;
          let isMarkLigature = curGlyph.isMark;
          for (let i = 0; i < matched.length && isMarkLigature; i++)
            isMarkLigature = this.glyphs[matched[i]].isMark;
          ligatureGlyph.ligatureID = isMarkLigature ? null : this.ligatureID++;
          let lastLigID = curGlyph.ligatureID;
          let lastNumComps = curGlyph.codePoints.length;
          let curComps = lastNumComps;
          let idx = this.glyphIterator.index + 1;
          for (let matchIndex of matched) {
            if (isMarkLigature)
              idx = matchIndex;
            else
              while (idx < matchIndex) {
                var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[idx].ligatureComponent || 1, lastNumComps);
                this.glyphs[idx].ligatureID = ligatureGlyph.ligatureID;
                this.glyphs[idx].ligatureComponent = ligatureComponent;
                idx++;
              }
            lastLigID = this.glyphs[idx].ligatureID;
            lastNumComps = this.glyphs[idx].codePoints.length;
            curComps += lastNumComps;
            idx++;
          }
          if (lastLigID && !isMarkLigature)
            for (let i1 = idx; i1 < this.glyphs.length; i1++) {
              if (this.glyphs[i1].ligatureID === lastLigID) {
                var ligatureComponent = curComps - lastNumComps + Math.min(this.glyphs[i1].ligatureComponent || 1, lastNumComps);
                this.glyphs[i1].ligatureComponent = ligatureComponent;
              } else
                break;
            }
          for (let i2 = matched.length - 1; i2 >= 0; i2--)
            this.glyphs.splice(matched[i2], 1);
          this.glyphs[this.glyphIterator.index] = ligatureGlyph;
          return true;
        }
        return false;
      }
      case 5:
        return this.applyContext(table);
      case 6:
        return this.applyChainingContext(table);
      case 7:
        return this.applyLookup(table.lookupType, table.extension);
      default:
        throw new Error(`GSUB lookupType ${lookupType} is not supported`);
    }
  }
};
var $c96c93587d49c14d$export$2e2bcd8739ae039 = class extends (0, $a83b9c36aaa94fd3$export$2e2bcd8739ae039) {
  applyPositionValue(sequenceIndex, value2) {
    let position = this.positions[this.glyphIterator.peekIndex(sequenceIndex)];
    if (value2.xAdvance != null)
      position.xAdvance += value2.xAdvance;
    if (value2.yAdvance != null)
      position.yAdvance += value2.yAdvance;
    if (value2.xPlacement != null)
      position.xOffset += value2.xPlacement;
    if (value2.yPlacement != null)
      position.yOffset += value2.yPlacement;
    let variationProcessor = this.font._variationProcessor;
    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
    if (variationProcessor && variationStore) {
      if (value2.xPlaDevice)
        position.xOffset += variationProcessor.getDelta(variationStore, value2.xPlaDevice.a, value2.xPlaDevice.b);
      if (value2.yPlaDevice)
        position.yOffset += variationProcessor.getDelta(variationStore, value2.yPlaDevice.a, value2.yPlaDevice.b);
      if (value2.xAdvDevice)
        position.xAdvance += variationProcessor.getDelta(variationStore, value2.xAdvDevice.a, value2.xAdvDevice.b);
      if (value2.yAdvDevice)
        position.yAdvance += variationProcessor.getDelta(variationStore, value2.yAdvDevice.a, value2.yAdvDevice.b);
    }
  }
  applyLookup(lookupType, table) {
    switch (lookupType) {
      case 1: {
        let index3 = this.coverageIndex(table.coverage);
        if (index3 === -1)
          return false;
        switch (table.version) {
          case 1:
            this.applyPositionValue(0, table.value);
            break;
          case 2:
            this.applyPositionValue(0, table.values.get(index3));
            break;
        }
        return true;
      }
      case 2: {
        let nextGlyph = this.glyphIterator.peek();
        if (!nextGlyph)
          return false;
        let index3 = this.coverageIndex(table.coverage);
        if (index3 === -1)
          return false;
        switch (table.version) {
          case 1:
            let set7 = table.pairSets.get(index3);
            for (let pair of set7)
              if (pair.secondGlyph === nextGlyph.id) {
                this.applyPositionValue(0, pair.value1);
                this.applyPositionValue(1, pair.value2);
                return true;
              }
            return false;
          case 2:
            let class1 = this.getClassID(this.glyphIterator.cur.id, table.classDef1);
            let class2 = this.getClassID(nextGlyph.id, table.classDef2);
            if (class1 === -1 || class2 === -1)
              return false;
            var pair1 = table.classRecords.get(class1).get(class2);
            this.applyPositionValue(0, pair1.value1);
            this.applyPositionValue(1, pair1.value2);
            return true;
        }
      }
      case 3: {
        let nextIndex = this.glyphIterator.peekIndex();
        let nextGlyph = this.glyphs[nextIndex];
        if (!nextGlyph)
          return false;
        let curRecord = table.entryExitRecords[this.coverageIndex(table.coverage)];
        if (!curRecord || !curRecord.exitAnchor)
          return false;
        let nextRecord = table.entryExitRecords[this.coverageIndex(table.coverage, nextGlyph.id)];
        if (!nextRecord || !nextRecord.entryAnchor)
          return false;
        let entry = this.getAnchor(nextRecord.entryAnchor);
        let exit = this.getAnchor(curRecord.exitAnchor);
        let cur = this.positions[this.glyphIterator.index];
        let next2 = this.positions[nextIndex];
        let d;
        switch (this.direction) {
          case "ltr":
            cur.xAdvance = exit.x + cur.xOffset;
            d = entry.x + next2.xOffset;
            next2.xAdvance -= d;
            next2.xOffset -= d;
            break;
          case "rtl":
            d = exit.x + cur.xOffset;
            cur.xAdvance -= d;
            cur.xOffset -= d;
            next2.xAdvance = entry.x + next2.xOffset;
            break;
        }
        if (this.glyphIterator.flags.rightToLeft) {
          this.glyphIterator.cur.cursiveAttachment = nextIndex;
          cur.yOffset = entry.y - exit.y;
        } else {
          nextGlyph.cursiveAttachment = this.glyphIterator.index;
          cur.yOffset = exit.y - entry.y;
        }
        return true;
      }
      case 4: {
        let markIndex = this.coverageIndex(table.markCoverage);
        if (markIndex === -1)
          return false;
        let baseGlyphIndex = this.glyphIterator.index;
        while (--baseGlyphIndex >= 0 && (this.glyphs[baseGlyphIndex].isMark || this.glyphs[baseGlyphIndex].ligatureComponent > 0))
          ;
        if (baseGlyphIndex < 0)
          return false;
        let baseIndex = this.coverageIndex(table.baseCoverage, this.glyphs[baseGlyphIndex].id);
        if (baseIndex === -1)
          return false;
        let markRecord = table.markArray[markIndex];
        let baseAnchor = table.baseArray[baseIndex][markRecord.class];
        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
        return true;
      }
      case 5: {
        let markIndex = this.coverageIndex(table.markCoverage);
        if (markIndex === -1)
          return false;
        let baseGlyphIndex = this.glyphIterator.index;
        while (--baseGlyphIndex >= 0 && this.glyphs[baseGlyphIndex].isMark)
          ;
        if (baseGlyphIndex < 0)
          return false;
        let ligIndex = this.coverageIndex(table.ligatureCoverage, this.glyphs[baseGlyphIndex].id);
        if (ligIndex === -1)
          return false;
        let ligAttach = table.ligatureArray[ligIndex];
        let markGlyph = this.glyphIterator.cur;
        let ligGlyph = this.glyphs[baseGlyphIndex];
        let compIndex = ligGlyph.ligatureID && ligGlyph.ligatureID === markGlyph.ligatureID && markGlyph.ligatureComponent > 0 ? Math.min(markGlyph.ligatureComponent, ligGlyph.codePoints.length) - 1 : ligGlyph.codePoints.length - 1;
        let markRecord = table.markArray[markIndex];
        let baseAnchor = ligAttach[compIndex][markRecord.class];
        this.applyAnchor(markRecord, baseAnchor, baseGlyphIndex);
        return true;
      }
      case 6: {
        let mark1Index = this.coverageIndex(table.mark1Coverage);
        if (mark1Index === -1)
          return false;
        let prevIndex = this.glyphIterator.peekIndex(-1);
        let prev = this.glyphs[prevIndex];
        if (!prev || !prev.isMark)
          return false;
        let cur = this.glyphIterator.cur;
        let good = false;
        if (cur.ligatureID === prev.ligatureID) {
          if (!cur.ligatureID)
            good = true;
          else if (cur.ligatureComponent === prev.ligatureComponent)
            good = true;
        } else if (cur.ligatureID && !cur.ligatureComponent || prev.ligatureID && !prev.ligatureComponent)
          good = true;
        if (!good)
          return false;
        let mark2Index = this.coverageIndex(table.mark2Coverage, prev.id);
        if (mark2Index === -1)
          return false;
        let markRecord = table.mark1Array[mark1Index];
        let baseAnchor = table.mark2Array[mark2Index][markRecord.class];
        this.applyAnchor(markRecord, baseAnchor, prevIndex);
        return true;
      }
      case 7:
        return this.applyContext(table);
      case 8:
        return this.applyChainingContext(table);
      case 9:
        return this.applyLookup(table.lookupType, table.extension);
      default:
        throw new Error(`Unsupported GPOS table: ${lookupType}`);
    }
  }
  applyAnchor(markRecord, baseAnchor, baseGlyphIndex) {
    let baseCoords = this.getAnchor(baseAnchor);
    let markCoords = this.getAnchor(markRecord.markAnchor);
    let basePos = this.positions[baseGlyphIndex];
    let markPos = this.positions[this.glyphIterator.index];
    markPos.xOffset = baseCoords.x - markCoords.x;
    markPos.yOffset = baseCoords.y - markCoords.y;
    this.glyphIterator.cur.markAttachment = baseGlyphIndex;
  }
  getAnchor(anchor) {
    let x = anchor.xCoordinate;
    let y = anchor.yCoordinate;
    let variationProcessor = this.font._variationProcessor;
    let variationStore = this.font.GDEF && this.font.GDEF.itemVariationStore;
    if (variationProcessor && variationStore) {
      if (anchor.xDeviceTable)
        x += variationProcessor.getDelta(variationStore, anchor.xDeviceTable.a, anchor.xDeviceTable.b);
      if (anchor.yDeviceTable)
        y += variationProcessor.getDelta(variationStore, anchor.yDeviceTable.a, anchor.yDeviceTable.b);
    }
    return {
      x,
      y
    };
  }
  applyFeatures(userFeatures, glyphs, advances) {
    super.applyFeatures(userFeatures, glyphs, advances);
    for (var i = 0; i < this.glyphs.length; i++)
      this.fixCursiveAttachment(i);
    this.fixMarkAttachment();
  }
  fixCursiveAttachment(i) {
    let glyph = this.glyphs[i];
    if (glyph.cursiveAttachment != null) {
      let j = glyph.cursiveAttachment;
      glyph.cursiveAttachment = null;
      this.fixCursiveAttachment(j);
      this.positions[i].yOffset += this.positions[j].yOffset;
    }
  }
  fixMarkAttachment() {
    for (let i = 0; i < this.glyphs.length; i++) {
      let glyph = this.glyphs[i];
      if (glyph.markAttachment != null) {
        let j = glyph.markAttachment;
        this.positions[i].xOffset += this.positions[j].xOffset;
        this.positions[i].yOffset += this.positions[j].yOffset;
        if (this.direction === "ltr")
          for (let k = j; k < i; k++) {
            this.positions[i].xOffset -= this.positions[k].xAdvance;
            this.positions[i].yOffset -= this.positions[k].yAdvance;
          }
        else
          for (let k1 = j + 1; k1 < i + 1; k1++) {
            this.positions[i].xOffset += this.positions[k1].xAdvance;
            this.positions[i].yOffset += this.positions[k1].yAdvance;
          }
      }
    }
  }
};
var $a62492810de27e3d$export$2e2bcd8739ae039 = class {
  setup(glyphRun) {
    this.glyphInfos = glyphRun.glyphs.map((glyph) => new (0, $10e7b257e1a9a756$export$2e2bcd8739ae039)(this.font, glyph.id, [
      ...glyph.codePoints
    ]));
    let script = null;
    if (this.GPOSProcessor)
      script = this.GPOSProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
    if (this.GSUBProcessor)
      script = this.GSUBProcessor.selectScript(glyphRun.script, glyphRun.language, glyphRun.direction);
    this.shaper = $102b6fe50f1d50b4$export$7877a478dd30fd3d(script);
    this.plan = new (0, $94d7a73bd2edfc9a$export$2e2bcd8739ae039)(this.font, script, glyphRun.direction);
    this.shaper.plan(this.plan, this.glyphInfos, glyphRun.features);
    for (let key in this.plan.allFeatures)
      glyphRun.features[key] = true;
  }
  substitute(glyphRun) {
    if (this.GSUBProcessor) {
      this.plan.process(this.GSUBProcessor, this.glyphInfos);
      glyphRun.glyphs = this.glyphInfos.map((glyphInfo) => this.font.getGlyph(glyphInfo.id, glyphInfo.codePoints));
    }
  }
  position(glyphRun) {
    if (this.shaper.zeroMarkWidths === "BEFORE_GPOS")
      this.zeroMarkAdvances(glyphRun.positions);
    if (this.GPOSProcessor)
      this.plan.process(this.GPOSProcessor, this.glyphInfos, glyphRun.positions);
    if (this.shaper.zeroMarkWidths === "AFTER_GPOS")
      this.zeroMarkAdvances(glyphRun.positions);
    if (glyphRun.direction === "rtl") {
      glyphRun.glyphs.reverse();
      glyphRun.positions.reverse();
    }
    return this.GPOSProcessor && this.GPOSProcessor.features;
  }
  zeroMarkAdvances(positions) {
    for (let i = 0; i < this.glyphInfos.length; i++)
      if (this.glyphInfos[i].isMark) {
        positions[i].xAdvance = 0;
        positions[i].yAdvance = 0;
      }
  }
  cleanup() {
    this.glyphInfos = null;
    this.plan = null;
    this.shaper = null;
  }
  getAvailableFeatures(script, language) {
    let features = [];
    if (this.GSUBProcessor) {
      this.GSUBProcessor.selectScript(script, language);
      features.push(...Object.keys(this.GSUBProcessor.features));
    }
    if (this.GPOSProcessor) {
      this.GPOSProcessor.selectScript(script, language);
      features.push(...Object.keys(this.GPOSProcessor.features));
    }
    return features;
  }
  constructor(font2) {
    this.font = font2;
    this.glyphInfos = null;
    this.plan = null;
    this.GSUBProcessor = null;
    this.GPOSProcessor = null;
    this.fallbackPosition = true;
    if (font2.GSUB)
      this.GSUBProcessor = new (0, $0a876c45f1f7c41c$export$2e2bcd8739ae039)(font2, font2.GSUB);
    if (font2.GPOS)
      this.GPOSProcessor = new (0, $c96c93587d49c14d$export$2e2bcd8739ae039)(font2, font2.GPOS);
  }
};
var $4c0a7fa5df7a9ab1$export$2e2bcd8739ae039 = class {
  layout(string, features, script, language, direction) {
    if (typeof features === "string") {
      direction = language;
      language = script;
      script = features;
      features = [];
    }
    if (typeof string === "string") {
      if (script == null)
        script = $130d1a642ebcd2b7$export$e5cb25e204fb8450(string);
      var glyphs = this.font.glyphsForString(string);
    } else {
      if (script == null) {
        let codePoints = [];
        for (let glyph of string)
          codePoints.push(...glyph.codePoints);
        script = $130d1a642ebcd2b7$export$16fab0757cfc223d(codePoints);
      }
      var glyphs = string;
    }
    let glyphRun = new (0, $be07b3e97a42687a$export$2e2bcd8739ae039)(glyphs, features, script, language, direction);
    if (glyphs.length === 0) {
      glyphRun.positions = [];
      return glyphRun;
    }
    if (this.engine && this.engine.setup)
      this.engine.setup(glyphRun);
    this.substitute(glyphRun);
    this.position(glyphRun);
    this.hideDefaultIgnorables(glyphRun.glyphs, glyphRun.positions);
    if (this.engine && this.engine.cleanup)
      this.engine.cleanup();
    return glyphRun;
  }
  substitute(glyphRun) {
    if (this.engine && this.engine.substitute)
      this.engine.substitute(glyphRun);
  }
  position(glyphRun) {
    glyphRun.positions = glyphRun.glyphs.map((glyph) => new (0, $1ac75d9a55b67f01$export$2e2bcd8739ae039)(glyph.advanceWidth));
    let positioned = null;
    if (this.engine && this.engine.position)
      positioned = this.engine.position(glyphRun);
    if (!positioned && (!this.engine || this.engine.fallbackPosition)) {
      if (!this.unicodeLayoutEngine)
        this.unicodeLayoutEngine = new (0, $0a4bdfeb6dfd6f5e$export$2e2bcd8739ae039)(this.font);
      this.unicodeLayoutEngine.positionGlyphs(glyphRun.glyphs, glyphRun.positions);
    }
    if ((!positioned || !positioned.kern) && glyphRun.features.kern !== false && this.font.kern) {
      if (!this.kernProcessor)
        this.kernProcessor = new (0, $0bba3a9db57637f3$export$2e2bcd8739ae039)(this.font);
      this.kernProcessor.process(glyphRun.glyphs, glyphRun.positions);
      glyphRun.features.kern = true;
    }
  }
  hideDefaultIgnorables(glyphs, positions) {
    let space = this.font.glyphForCodePoint(32);
    for (let i = 0; i < glyphs.length; i++)
      if (this.isDefaultIgnorable(glyphs[i].codePoints[0])) {
        glyphs[i] = space;
        positions[i].xAdvance = 0;
        positions[i].yAdvance = 0;
      }
  }
  isDefaultIgnorable(ch) {
    let plane = ch >> 16;
    if (plane === 0)
      switch (ch >> 8) {
        case 0:
          return ch === 173;
        case 3:
          return ch === 847;
        case 6:
          return ch === 1564;
        case 23:
          return 6068 <= ch && ch <= 6069;
        case 24:
          return 6155 <= ch && ch <= 6158;
        case 32:
          return 8203 <= ch && ch <= 8207 || 8234 <= ch && ch <= 8238 || 8288 <= ch && ch <= 8303;
        case 254:
          return 65024 <= ch && ch <= 65039 || ch === 65279;
        case 255:
          return 65520 <= ch && ch <= 65528;
        default:
          return false;
      }
    else
      switch (plane) {
        case 1:
          return 113824 <= ch && ch <= 113827 || 119155 <= ch && ch <= 119162;
        case 14:
          return 917504 <= ch && ch <= 921599;
        default:
          return false;
      }
  }
  getAvailableFeatures(script, language) {
    let features = [];
    if (this.engine)
      features.push(...this.engine.getAvailableFeatures(script, language));
    if (this.font.kern && features.indexOf("kern") === -1)
      features.push("kern");
    return features;
  }
  stringsForGlyph(gid) {
    let result = /* @__PURE__ */ new Set();
    let codePoints = this.font._cmapProcessor.codePointsForGlyph(gid);
    for (let codePoint of codePoints)
      result.add(String.fromCodePoint(codePoint));
    if (this.engine && this.engine.stringsForGlyph)
      for (let string of this.engine.stringsForGlyph(gid))
        result.add(string);
    return Array.from(result);
  }
  constructor(font2) {
    this.font = font2;
    this.unicodeLayoutEngine = null;
    this.kernProcessor = null;
    if (this.font.morx)
      this.engine = new (0, $ba6dd74203be8728$export$2e2bcd8739ae039)(this.font);
    else if (this.font.GSUB || this.font.GPOS)
      this.engine = new (0, $a62492810de27e3d$export$2e2bcd8739ae039)(this.font);
  }
};
var $f43aec954cdfdf21$var$SVG_COMMANDS = {
  moveTo: "M",
  lineTo: "L",
  quadraticCurveTo: "Q",
  bezierCurveTo: "C",
  closePath: "Z"
};
var $f43aec954cdfdf21$export$2e2bcd8739ae039 = class _$f43aec954cdfdf21$export$2e2bcd8739ae039 {
  /**
  * Compiles the path to a JavaScript function that can be applied with
  * a graphics context in order to render the path.
  * @return {string}
  */
  toFunction() {
    return (ctx) => {
      this.commands.forEach((c2) => {
        return ctx[c2.command].apply(ctx, c2.args);
      });
    };
  }
  /**
  * Converts the path to an SVG path data string
  * @return {string}
  */
  toSVG() {
    let cmds = this.commands.map((c2) => {
      let args = c2.args.map((arg) => Math.round(arg * 100) / 100);
      return `${$f43aec954cdfdf21$var$SVG_COMMANDS[c2.command]}${args.join(" ")}`;
    });
    return cmds.join("");
  }
  /**
  * Gets the "control box" of a path.
  * This is like the bounding box, but it includes all points including
  * control points of bezier segments and is much faster to compute than
  * the real bounding box.
  * @type {BBox}
  */
  get cbox() {
    if (!this._cbox) {
      let cbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
      for (let command1 of this.commands)
        for (let i = 0; i < command1.args.length; i += 2)
          cbox.addPoint(command1.args[i], command1.args[i + 1]);
      this._cbox = Object.freeze(cbox);
    }
    return this._cbox;
  }
  /**
  * Gets the exact bounding box of the path by evaluating curve segments.
  * Slower to compute than the control box, but more accurate.
  * @type {BBox}
  */
  get bbox() {
    if (this._bbox)
      return this._bbox;
    let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
    let cx2 = 0, cy2 = 0;
    let f = (t2) => Math.pow(1 - t2, 3) * p0[i] + 3 * Math.pow(1 - t2, 2) * t2 * p1[i] + 3 * (1 - t2) * Math.pow(t2, 2) * p2[i] + Math.pow(t2, 3) * p3[i];
    for (let c2 of this.commands)
      switch (c2.command) {
        case "moveTo":
        case "lineTo":
          let [x, y] = c2.args;
          bbox.addPoint(x, y);
          cx2 = x;
          cy2 = y;
          break;
        case "quadraticCurveTo":
        case "bezierCurveTo":
          if (c2.command === "quadraticCurveTo") {
            var [qp1x, qp1y, p3x, p3y] = c2.args;
            var cp1x = cx2 + 2 / 3 * (qp1x - cx2);
            var cp1y = cy2 + 2 / 3 * (qp1y - cy2);
            var cp2x = p3x + 2 / 3 * (qp1x - p3x);
            var cp2y = p3y + 2 / 3 * (qp1y - p3y);
          } else
            var [cp1x, cp1y, cp2x, cp2y, p3x, p3y] = c2.args;
          bbox.addPoint(p3x, p3y);
          var p0 = [
            cx2,
            cy2
          ];
          var p1 = [
            cp1x,
            cp1y
          ];
          var p2 = [
            cp2x,
            cp2y
          ];
          var p3 = [
            p3x,
            p3y
          ];
          for (var i = 0; i <= 1; i++) {
            let b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
            let a2 = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
            c2 = 3 * p1[i] - 3 * p0[i];
            if (a2 === 0) {
              if (b === 0)
                continue;
              let t3 = -c2 / b;
              if (0 < t3 && t3 < 1) {
                if (i === 0)
                  bbox.addPoint(f(t3), bbox.maxY);
                else if (i === 1)
                  bbox.addPoint(bbox.maxX, f(t3));
              }
              continue;
            }
            let b2ac = Math.pow(b, 2) - 4 * c2 * a2;
            if (b2ac < 0)
              continue;
            let t1 = (-b + Math.sqrt(b2ac)) / (2 * a2);
            if (0 < t1 && t1 < 1) {
              if (i === 0)
                bbox.addPoint(f(t1), bbox.maxY);
              else if (i === 1)
                bbox.addPoint(bbox.maxX, f(t1));
            }
            let t2 = (-b - Math.sqrt(b2ac)) / (2 * a2);
            if (0 < t2 && t2 < 1) {
              if (i === 0)
                bbox.addPoint(f(t2), bbox.maxY);
              else if (i === 1)
                bbox.addPoint(bbox.maxX, f(t2));
            }
          }
          cx2 = p3x;
          cy2 = p3y;
          break;
      }
    return this._bbox = Object.freeze(bbox);
  }
  /**
  * Applies a mapping function to each point in the path.
  * @param {function} fn
  * @return {Path}
  */
  mapPoints(fn) {
    let path2 = new _$f43aec954cdfdf21$export$2e2bcd8739ae039();
    for (let c2 of this.commands) {
      let args = [];
      for (let i = 0; i < c2.args.length; i += 2) {
        let [x, y] = fn(c2.args[i], c2.args[i + 1]);
        args.push(x, y);
      }
      path2[c2.command](...args);
    }
    return path2;
  }
  /**
  * Transforms the path by the given matrix.
  */
  transform(m0, m1, m2, m3, m4, m5) {
    return this.mapPoints((x, y) => {
      const tx = m0 * x + m2 * y + m4;
      const ty = m1 * x + m3 * y + m5;
      return [
        tx,
        ty
      ];
    });
  }
  /**
  * Translates the path by the given offset.
  */
  translate(x, y) {
    return this.transform(1, 0, 0, 1, x, y);
  }
  /**
  * Rotates the path by the given angle (in radians).
  */
  rotate(angle) {
    let cos = Math.cos(angle);
    let sin = Math.sin(angle);
    return this.transform(cos, sin, -sin, cos, 0, 0);
  }
  /**
  * Scales the path.
  */
  scale(scaleX, scaleY = scaleX) {
    return this.transform(scaleX, 0, 0, scaleY, 0, 0);
  }
  constructor() {
    this.commands = [];
    this._bbox = null;
    this._cbox = null;
  }
};
for (let command of [
  "moveTo",
  "lineTo",
  "quadraticCurveTo",
  "bezierCurveTo",
  "closePath"
])
  $f43aec954cdfdf21$export$2e2bcd8739ae039.prototype[command] = function(...args) {
    this._bbox = this._cbox = null;
    this.commands.push({
      command,
      args
    });
    return this;
  };
var $7713b9b7b438dff8$export$2e2bcd8739ae039 = [
  ".notdef",
  ".null",
  "nonmarkingreturn",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quotesingle",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "grave",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "Adieresis",
  "Aring",
  "Ccedilla",
  "Eacute",
  "Ntilde",
  "Odieresis",
  "Udieresis",
  "aacute",
  "agrave",
  "acircumflex",
  "adieresis",
  "atilde",
  "aring",
  "ccedilla",
  "eacute",
  "egrave",
  "ecircumflex",
  "edieresis",
  "iacute",
  "igrave",
  "icircumflex",
  "idieresis",
  "ntilde",
  "oacute",
  "ograve",
  "ocircumflex",
  "odieresis",
  "otilde",
  "uacute",
  "ugrave",
  "ucircumflex",
  "udieresis",
  "dagger",
  "degree",
  "cent",
  "sterling",
  "section",
  "bullet",
  "paragraph",
  "germandbls",
  "registered",
  "copyright",
  "trademark",
  "acute",
  "dieresis",
  "notequal",
  "AE",
  "Oslash",
  "infinity",
  "plusminus",
  "lessequal",
  "greaterequal",
  "yen",
  "mu",
  "partialdiff",
  "summation",
  "product",
  "pi",
  "integral",
  "ordfeminine",
  "ordmasculine",
  "Omega",
  "ae",
  "oslash",
  "questiondown",
  "exclamdown",
  "logicalnot",
  "radical",
  "florin",
  "approxequal",
  "Delta",
  "guillemotleft",
  "guillemotright",
  "ellipsis",
  "nonbreakingspace",
  "Agrave",
  "Atilde",
  "Otilde",
  "OE",
  "oe",
  "endash",
  "emdash",
  "quotedblleft",
  "quotedblright",
  "quoteleft",
  "quoteright",
  "divide",
  "lozenge",
  "ydieresis",
  "Ydieresis",
  "fraction",
  "currency",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "daggerdbl",
  "periodcentered",
  "quotesinglbase",
  "quotedblbase",
  "perthousand",
  "Acircumflex",
  "Ecircumflex",
  "Aacute",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Oacute",
  "Ocircumflex",
  "apple",
  "Ograve",
  "Uacute",
  "Ucircumflex",
  "Ugrave",
  "dotlessi",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "Lslash",
  "lslash",
  "Scaron",
  "scaron",
  "Zcaron",
  "zcaron",
  "brokenbar",
  "Eth",
  "eth",
  "Yacute",
  "yacute",
  "Thorn",
  "thorn",
  "minus",
  "multiply",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "onehalf",
  "onequarter",
  "threequarters",
  "franc",
  "Gbreve",
  "gbreve",
  "Idotaccent",
  "Scedilla",
  "scedilla",
  "Cacute",
  "cacute",
  "Ccaron",
  "ccaron",
  "dcroat"
];
var $f92906be28e61769$export$2e2bcd8739ae039 = class {
  _getPath() {
    return new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();
  }
  _getCBox() {
    return this.path.cbox;
  }
  _getBBox() {
    return this.path.bbox;
  }
  _getTableMetrics(table) {
    if (this.id < table.metrics.length)
      return table.metrics.get(this.id);
    let metric = table.metrics.get(table.metrics.length - 1);
    let res = {
      advance: metric ? metric.advance : 0,
      bearing: table.bearings.get(this.id - table.metrics.length) || 0
    };
    return res;
  }
  _getMetrics(cbox) {
    if (this._metrics)
      return this._metrics;
    let { advance: advanceWidth5, bearing: leftBearing } = this._getTableMetrics(this._font.hmtx);
    if (this._font.vmtx)
      var { advance: advanceHeight, bearing: topBearing } = this._getTableMetrics(this._font.vmtx);
    else {
      let os2;
      if (typeof cbox === "undefined" || cbox === null)
        ({ cbox } = this);
      if ((os2 = this._font["OS/2"]) && os2.version > 0) {
        var advanceHeight = Math.abs(os2.typoAscender - os2.typoDescender);
        var topBearing = os2.typoAscender - cbox.maxY;
      } else {
        let { hhea } = this._font;
        var advanceHeight = Math.abs(hhea.ascent - hhea.descent);
        var topBearing = hhea.ascent - cbox.maxY;
      }
    }
    if (this._font._variationProcessor && this._font.HVAR)
      advanceWidth5 += this._font._variationProcessor.getAdvanceAdjustment(this.id, this._font.HVAR);
    return this._metrics = {
      advanceWidth: advanceWidth5,
      advanceHeight,
      leftBearing,
      topBearing
    };
  }
  /**
  * The glyph’s control box.
  * This is often the same as the bounding box, but is faster to compute.
  * Because of the way bezier curves are defined, some of the control points
  * can be outside of the bounding box. Where `bbox` takes this into account,
  * `cbox` does not. Thus, cbox is less accurate, but faster to compute.
  * See [here](http://www.freetype.org/freetype2/docs/glyphs/glyphs-6.html#section-2)
  * for a more detailed description.
  *
  * @type {BBox}
  */
  get cbox() {
    return this._getCBox();
  }
  /**
  * The glyph’s bounding box, i.e. the rectangle that encloses the
  * glyph outline as tightly as possible.
  * @type {BBox}
  */
  get bbox() {
    return this._getBBox();
  }
  /**
  * A vector Path object representing the glyph outline.
  * @type {Path}
  */
  get path() {
    return this._getPath();
  }
  /**
  * Returns a path scaled to the given font size.
  * @param {number} size
  * @return {Path}
  */
  getScaledPath(size) {
    let scale4 = 1 / this._font.unitsPerEm * size;
    return this.path.scale(scale4);
  }
  /**
  * The glyph's advance width.
  * @type {number}
  */
  get advanceWidth() {
    return this._getMetrics().advanceWidth;
  }
  /**
  * The glyph's advance height.
  * @type {number}
  */
  get advanceHeight() {
    return this._getMetrics().advanceHeight;
  }
  get ligatureCaretPositions() {
  }
  _getName() {
    let { post } = this._font;
    if (!post)
      return null;
    switch (post.version) {
      case 1:
        return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[this.id];
      case 2:
        let id = post.glyphNameIndex[this.id];
        if (id < (0, $7713b9b7b438dff8$export$2e2bcd8739ae039).length)
          return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[id];
        return post.names[id - (0, $7713b9b7b438dff8$export$2e2bcd8739ae039).length];
      case 2.5:
        return (0, $7713b9b7b438dff8$export$2e2bcd8739ae039)[this.id + post.offsets[this.id]];
      case 4:
        return String.fromCharCode(post.map[this.id]);
    }
  }
  /**
  * The glyph's name
  * @type {string}
  */
  get name() {
    return this._getName();
  }
  /**
  * Renders the glyph to the given graphics context, at the specified font size.
  * @param {CanvasRenderingContext2d} ctx
  * @param {number} size
  */
  render(ctx, size) {
    ctx.save();
    let scale4 = 1 / this._font.head.unitsPerEm * size;
    ctx.scale(scale4, scale4);
    let fn = this.path.toFunction();
    fn(ctx);
    ctx.fill();
    ctx.restore();
  }
  constructor(id, codePoints, font2) {
    this.id = id;
    this.codePoints = codePoints;
    this._font = font2;
    this.isMark = this.codePoints.length > 0 && this.codePoints.every((0, $747425b437e121da$export$e33ad6871e762338));
    this.isLigature = this.codePoints.length > 1;
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "cbox", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "bbox", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "path", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "advanceWidth", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "advanceHeight", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $f92906be28e61769$export$2e2bcd8739ae039.prototype, "name", null);
var $69aac16029968692$var$GlyfHeader = new Struct({
  numberOfContours: int16,
  xMin: int16,
  yMin: int16,
  xMax: int16,
  yMax: int16
});
var $69aac16029968692$var$ON_CURVE = 1;
var $69aac16029968692$var$X_SHORT_VECTOR = 2;
var $69aac16029968692$var$Y_SHORT_VECTOR = 4;
var $69aac16029968692$var$REPEAT = 8;
var $69aac16029968692$var$SAME_X = 16;
var $69aac16029968692$var$SAME_Y = 32;
var $69aac16029968692$var$ARG_1_AND_2_ARE_WORDS = 1;
var $69aac16029968692$var$WE_HAVE_A_SCALE = 8;
var $69aac16029968692$var$MORE_COMPONENTS = 32;
var $69aac16029968692$var$WE_HAVE_AN_X_AND_Y_SCALE = 64;
var $69aac16029968692$var$WE_HAVE_A_TWO_BY_TWO = 128;
var $69aac16029968692$var$WE_HAVE_INSTRUCTIONS = 256;
var $69aac16029968692$export$baf26146a414f24a = class _$69aac16029968692$export$baf26146a414f24a {
  copy() {
    return new _$69aac16029968692$export$baf26146a414f24a(this.onCurve, this.endContour, this.x, this.y);
  }
  constructor(onCurve, endContour, x = 0, y = 0) {
    this.onCurve = onCurve;
    this.endContour = endContour;
    this.x = x;
    this.y = y;
  }
};
var $69aac16029968692$var$Component = class {
  constructor(glyphID, dx, dy) {
    this.glyphID = glyphID;
    this.dx = dx;
    this.dy = dy;
    this.pos = 0;
    this.scaleX = this.scaleY = 1;
    this.scale01 = this.scale10 = 0;
  }
};
var $69aac16029968692$export$2e2bcd8739ae039 = class extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {
  // Parses just the glyph header and returns the bounding box
  _getCBox(internal) {
    if (this._font._variationProcessor && !internal)
      return this.path.cbox;
    let stream2 = this._font._getTableStream("glyf");
    stream2.pos += this._font.loca.offsets[this.id];
    let glyph = $69aac16029968692$var$GlyfHeader.decode(stream2);
    let cbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)(glyph.xMin, glyph.yMin, glyph.xMax, glyph.yMax);
    return Object.freeze(cbox);
  }
  // Parses a single glyph coordinate
  _parseGlyphCoord(stream2, prev, short, same) {
    if (short) {
      var val = stream2.readUInt8();
      if (!same)
        val = -val;
      val += prev;
    } else if (same)
      var val = prev;
    else
      var val = prev + stream2.readInt16BE();
    return val;
  }
  // Decodes the glyph data into points for simple glyphs,
  // or components for composite glyphs
  _decode() {
    let glyfPos = this._font.loca.offsets[this.id];
    let nextPos = this._font.loca.offsets[this.id + 1];
    if (glyfPos === nextPos)
      return null;
    let stream2 = this._font._getTableStream("glyf");
    stream2.pos += glyfPos;
    let startPos = stream2.pos;
    let glyph = $69aac16029968692$var$GlyfHeader.decode(stream2);
    if (glyph.numberOfContours > 0)
      this._decodeSimple(glyph, stream2);
    else if (glyph.numberOfContours < 0)
      this._decodeComposite(glyph, stream2, startPos);
    return glyph;
  }
  _decodeSimple(glyph, stream2) {
    glyph.points = [];
    let endPtsOfContours = new ArrayT(uint16, glyph.numberOfContours).decode(stream2);
    glyph.instructions = new ArrayT(uint8, uint16).decode(stream2);
    let flags = [];
    let numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;
    while (flags.length < numCoords) {
      var flag = stream2.readUInt8();
      flags.push(flag);
      if (flag & $69aac16029968692$var$REPEAT) {
        let count = stream2.readUInt8();
        for (let j = 0; j < count; j++)
          flags.push(flag);
      }
    }
    for (var i = 0; i < flags.length; i++) {
      var flag = flags[i];
      let point = new $69aac16029968692$export$baf26146a414f24a(!!(flag & $69aac16029968692$var$ON_CURVE), endPtsOfContours.indexOf(i) >= 0, 0, 0);
      glyph.points.push(point);
    }
    let px2 = 0;
    for (var i = 0; i < flags.length; i++) {
      var flag = flags[i];
      glyph.points[i].x = px2 = this._parseGlyphCoord(stream2, px2, flag & $69aac16029968692$var$X_SHORT_VECTOR, flag & $69aac16029968692$var$SAME_X);
    }
    let py2 = 0;
    for (var i = 0; i < flags.length; i++) {
      var flag = flags[i];
      glyph.points[i].y = py2 = this._parseGlyphCoord(stream2, py2, flag & $69aac16029968692$var$Y_SHORT_VECTOR, flag & $69aac16029968692$var$SAME_Y);
    }
    if (this._font._variationProcessor) {
      let points = glyph.points.slice();
      points.push(...this._getPhantomPoints(glyph));
      this._font._variationProcessor.transformPoints(this.id, points);
      glyph.phantomPoints = points.slice(-4);
    }
    return;
  }
  _decodeComposite(glyph, stream2, offset3 = 0) {
    glyph.components = [];
    let haveInstructions = false;
    let flags = $69aac16029968692$var$MORE_COMPONENTS;
    while (flags & $69aac16029968692$var$MORE_COMPONENTS) {
      flags = stream2.readUInt16BE();
      let gPos = stream2.pos - offset3;
      let glyphID = stream2.readUInt16BE();
      if (!haveInstructions)
        haveInstructions = (flags & $69aac16029968692$var$WE_HAVE_INSTRUCTIONS) !== 0;
      if (flags & $69aac16029968692$var$ARG_1_AND_2_ARE_WORDS) {
        var dx = stream2.readInt16BE();
        var dy = stream2.readInt16BE();
      } else {
        var dx = stream2.readInt8();
        var dy = stream2.readInt8();
      }
      var component = new $69aac16029968692$var$Component(glyphID, dx, dy);
      component.pos = gPos;
      if (flags & $69aac16029968692$var$WE_HAVE_A_SCALE)
        component.scaleX = component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
      else if (flags & $69aac16029968692$var$WE_HAVE_AN_X_AND_Y_SCALE) {
        component.scaleX = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
      } else if (flags & $69aac16029968692$var$WE_HAVE_A_TWO_BY_TWO) {
        component.scaleX = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scale01 = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scale10 = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
        component.scaleY = (stream2.readUInt8() << 24 | stream2.readUInt8() << 16) / 1073741824;
      }
      glyph.components.push(component);
    }
    if (this._font._variationProcessor) {
      let points = [];
      for (let j = 0; j < glyph.components.length; j++) {
        var component = glyph.components[j];
        points.push(new $69aac16029968692$export$baf26146a414f24a(true, true, component.dx, component.dy));
      }
      points.push(...this._getPhantomPoints(glyph));
      this._font._variationProcessor.transformPoints(this.id, points);
      glyph.phantomPoints = points.splice(-4, 4);
      for (let i = 0; i < points.length; i++) {
        let point = points[i];
        glyph.components[i].dx = point.x;
        glyph.components[i].dy = point.y;
      }
    }
    return haveInstructions;
  }
  _getPhantomPoints(glyph) {
    let cbox = this._getCBox(true);
    if (this._metrics == null)
      this._metrics = (0, $f92906be28e61769$export$2e2bcd8739ae039).prototype._getMetrics.call(this, cbox);
    let { advanceWidth: advanceWidth5, advanceHeight, leftBearing, topBearing } = this._metrics;
    return [
      new $69aac16029968692$export$baf26146a414f24a(false, true, glyph.xMin - leftBearing, 0),
      new $69aac16029968692$export$baf26146a414f24a(false, true, glyph.xMin - leftBearing + advanceWidth5, 0),
      new $69aac16029968692$export$baf26146a414f24a(false, true, 0, glyph.yMax + topBearing),
      new $69aac16029968692$export$baf26146a414f24a(false, true, 0, glyph.yMax + topBearing + advanceHeight)
    ];
  }
  // Decodes font data, resolves composite glyphs, and returns an array of contours
  _getContours() {
    let glyph = this._decode();
    if (!glyph)
      return [];
    let points = [];
    if (glyph.numberOfContours < 0)
      for (let component of glyph.components) {
        let contours2 = this._font.getGlyph(component.glyphID)._getContours();
        for (let i = 0; i < contours2.length; i++) {
          let contour = contours2[i];
          for (let j = 0; j < contour.length; j++) {
            let point2 = contour[j];
            let x = point2.x * component.scaleX + point2.y * component.scale01 + component.dx;
            let y = point2.y * component.scaleY + point2.x * component.scale10 + component.dy;
            points.push(new $69aac16029968692$export$baf26146a414f24a(point2.onCurve, point2.endContour, x, y));
          }
        }
      }
    else
      points = glyph.points || [];
    if (glyph.phantomPoints && !this._font.directory.tables.HVAR) {
      this._metrics.advanceWidth = glyph.phantomPoints[1].x - glyph.phantomPoints[0].x;
      this._metrics.advanceHeight = glyph.phantomPoints[3].y - glyph.phantomPoints[2].y;
      this._metrics.leftBearing = glyph.xMin - glyph.phantomPoints[0].x;
      this._metrics.topBearing = glyph.phantomPoints[2].y - glyph.yMax;
    }
    let contours = [];
    let cur = [];
    for (let k = 0; k < points.length; k++) {
      var point = points[k];
      cur.push(point);
      if (point.endContour) {
        contours.push(cur);
        cur = [];
      }
    }
    return contours;
  }
  _getMetrics() {
    if (this._metrics)
      return this._metrics;
    let cbox = this._getCBox(true);
    super._getMetrics(cbox);
    if (this._font._variationProcessor && !this._font.HVAR)
      this.path;
    return this._metrics;
  }
  // Converts contours to a Path object that can be rendered
  _getPath() {
    let contours = this._getContours();
    let path2 = new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();
    for (let i = 0; i < contours.length; i++) {
      let contour = contours[i];
      let firstPt = contour[0];
      let lastPt = contour[contour.length - 1];
      let start3 = 0;
      if (firstPt.onCurve) {
        var curvePt = null;
        start3 = 1;
      } else {
        if (lastPt.onCurve)
          firstPt = lastPt;
        else
          firstPt = new $69aac16029968692$export$baf26146a414f24a(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);
        var curvePt = firstPt;
      }
      path2.moveTo(firstPt.x, firstPt.y);
      for (let j = start3; j < contour.length; j++) {
        let pt = contour[j];
        let prevPt = j === 0 ? firstPt : contour[j - 1];
        if (prevPt.onCurve && pt.onCurve)
          path2.lineTo(pt.x, pt.y);
        else if (prevPt.onCurve && !pt.onCurve)
          var curvePt = pt;
        else if (!prevPt.onCurve && !pt.onCurve) {
          let midX = (prevPt.x + pt.x) / 2;
          let midY = (prevPt.y + pt.y) / 2;
          path2.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);
          var curvePt = pt;
        } else if (!prevPt.onCurve && pt.onCurve) {
          path2.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
          var curvePt = null;
        } else
          throw new Error("Unknown TTF path state");
      }
      if (curvePt)
        path2.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
      path2.closePath();
    }
    return path2;
  }
  constructor(...args) {
    super(...args);
    (0, _defineProperty)(this, "type", "TTF");
  }
};
var $62cc5109c6101893$export$2e2bcd8739ae039 = class extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {
  _getName() {
    if (this._font.CFF2)
      return super._getName();
    return this._font["CFF "].getGlyphName(this.id);
  }
  bias(s2) {
    if (s2.length < 1240)
      return 107;
    else if (s2.length < 33900)
      return 1131;
    else
      return 32768;
  }
  _getPath() {
    let cff = this._font.CFF2 || this._font["CFF "];
    let { stream: stream2 } = cff;
    let str = cff.topDict.CharStrings[this.id];
    let end3 = str.offset + str.length;
    stream2.pos = str.offset;
    let path2 = new (0, $f43aec954cdfdf21$export$2e2bcd8739ae039)();
    let stack = [];
    let trans = [];
    let width = null;
    let nStems = 0;
    let x1 = 0, y1 = 0;
    let usedGsubrs;
    let usedSubrs;
    let open = false;
    this._usedGsubrs = usedGsubrs = {};
    this._usedSubrs = usedSubrs = {};
    let gsubrs = cff.globalSubrIndex || [];
    let gsubrsBias = this.bias(gsubrs);
    let privateDict = cff.privateDictForGlyph(this.id) || {};
    let subrs = privateDict.Subrs || [];
    let subrsBias = this.bias(subrs);
    let vstore = cff.topDict.vstore && cff.topDict.vstore.itemVariationStore;
    let vsindex = privateDict.vsindex;
    let variationProcessor = this._font._variationProcessor;
    function checkWidth() {
      if (width == null)
        width = stack.shift() + privateDict.nominalWidthX;
    }
    function parseStems() {
      if (stack.length % 2 !== 0)
        checkWidth();
      nStems += stack.length >> 1;
      return stack.length = 0;
    }
    function moveTo2(x, y) {
      if (open)
        path2.closePath();
      path2.moveTo(x, y);
      open = true;
    }
    let parse3 = function() {
      while (stream2.pos < end3) {
        let op = stream2.readUInt8();
        if (op < 32) {
          let index3, subr, phase;
          switch (op) {
            case 1:
            case 3:
            case 18:
            case 23:
              parseStems();
              break;
            case 4:
              if (stack.length > 1)
                checkWidth();
              y1 += stack.shift();
              moveTo2(x1, y1);
              break;
            case 5:
              while (stack.length >= 2) {
                x1 += stack.shift();
                y1 += stack.shift();
                path2.lineTo(x1, y1);
              }
              break;
            case 6:
            case 7:
              phase = op === 6;
              while (stack.length >= 1) {
                if (phase)
                  x1 += stack.shift();
                else
                  y1 += stack.shift();
                path2.lineTo(x1, y1);
                phase = !phase;
              }
              break;
            case 8:
              while (stack.length > 0) {
                var c1x = x1 + stack.shift();
                var c1y = y1 + stack.shift();
                var c2x = c1x + stack.shift();
                var c2y = c1y + stack.shift();
                x1 = c2x + stack.shift();
                y1 = c2y + stack.shift();
                path2.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
              }
              break;
            case 10:
              index3 = stack.pop() + subrsBias;
              subr = subrs[index3];
              if (subr) {
                usedSubrs[index3] = true;
                var p = stream2.pos;
                var e = end3;
                stream2.pos = subr.offset;
                end3 = subr.offset + subr.length;
                parse3();
                stream2.pos = p;
                end3 = e;
              }
              break;
            case 11:
              if (cff.version >= 2)
                break;
              return;
            case 14:
              if (cff.version >= 2)
                break;
              if (stack.length > 0)
                checkWidth();
              if (open) {
                path2.closePath();
                open = false;
              }
              break;
            case 15:
              if (cff.version < 2)
                throw new Error("vsindex operator not supported in CFF v1");
              vsindex = stack.pop();
              break;
            case 16: {
              if (cff.version < 2)
                throw new Error("blend operator not supported in CFF v1");
              if (!variationProcessor)
                throw new Error("blend operator in non-variation font");
              let blendVector = variationProcessor.getBlendVector(vstore, vsindex);
              let numBlends = stack.pop();
              let numOperands = numBlends * blendVector.length;
              let delta = stack.length - numOperands;
              let base = delta - numBlends;
              for (let i = 0; i < numBlends; i++) {
                let sum = stack[base + i];
                for (let j = 0; j < blendVector.length; j++)
                  sum += blendVector[j] * stack[delta++];
                stack[base + i] = sum;
              }
              while (numOperands--)
                stack.pop();
              break;
            }
            case 19:
            case 20:
              parseStems();
              stream2.pos += nStems + 7 >> 3;
              break;
            case 21:
              if (stack.length > 2)
                checkWidth();
              x1 += stack.shift();
              y1 += stack.shift();
              moveTo2(x1, y1);
              break;
            case 22:
              if (stack.length > 1)
                checkWidth();
              x1 += stack.shift();
              moveTo2(x1, y1);
              break;
            case 24:
              while (stack.length >= 8) {
                var c1x = x1 + stack.shift();
                var c1y = y1 + stack.shift();
                var c2x = c1x + stack.shift();
                var c2y = c1y + stack.shift();
                x1 = c2x + stack.shift();
                y1 = c2y + stack.shift();
                path2.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
              }
              x1 += stack.shift();
              y1 += stack.shift();
              path2.lineTo(x1, y1);
              break;
            case 25:
              while (stack.length >= 8) {
                x1 += stack.shift();
                y1 += stack.shift();
                path2.lineTo(x1, y1);
              }
              var c1x = x1 + stack.shift();
              var c1y = y1 + stack.shift();
              var c2x = c1x + stack.shift();
              var c2y = c1y + stack.shift();
              x1 = c2x + stack.shift();
              y1 = c2y + stack.shift();
              path2.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
              break;
            case 26:
              if (stack.length % 2)
                x1 += stack.shift();
              while (stack.length >= 4) {
                c1x = x1;
                c1y = y1 + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x1 = c2x;
                y1 = c2y + stack.shift();
                path2.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
              }
              break;
            case 27:
              if (stack.length % 2)
                y1 += stack.shift();
              while (stack.length >= 4) {
                c1x = x1 + stack.shift();
                c1y = y1;
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x1 = c2x + stack.shift();
                y1 = c2y;
                path2.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
              }
              break;
            case 28:
              stack.push(stream2.readInt16BE());
              break;
            case 29:
              index3 = stack.pop() + gsubrsBias;
              subr = gsubrs[index3];
              if (subr) {
                usedGsubrs[index3] = true;
                var p = stream2.pos;
                var e = end3;
                stream2.pos = subr.offset;
                end3 = subr.offset + subr.length;
                parse3();
                stream2.pos = p;
                end3 = e;
              }
              break;
            case 30:
            case 31:
              phase = op === 31;
              while (stack.length >= 4) {
                if (phase) {
                  c1x = x1 + stack.shift();
                  c1y = y1;
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  y1 = c2y + stack.shift();
                  x1 = c2x + (stack.length === 1 ? stack.shift() : 0);
                } else {
                  c1x = x1;
                  c1y = y1 + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  x1 = c2x + stack.shift();
                  y1 = c2y + (stack.length === 1 ? stack.shift() : 0);
                }
                path2.bezierCurveTo(c1x, c1y, c2x, c2y, x1, y1);
                phase = !phase;
              }
              break;
            case 12:
              op = stream2.readUInt8();
              switch (op) {
                case 3:
                  let a2 = stack.pop();
                  let b = stack.pop();
                  stack.push(a2 && b ? 1 : 0);
                  break;
                case 4:
                  a2 = stack.pop();
                  b = stack.pop();
                  stack.push(a2 || b ? 1 : 0);
                  break;
                case 5:
                  a2 = stack.pop();
                  stack.push(a2 ? 0 : 1);
                  break;
                case 9:
                  a2 = stack.pop();
                  stack.push(Math.abs(a2));
                  break;
                case 10:
                  a2 = stack.pop();
                  b = stack.pop();
                  stack.push(a2 + b);
                  break;
                case 11:
                  a2 = stack.pop();
                  b = stack.pop();
                  stack.push(a2 - b);
                  break;
                case 12:
                  a2 = stack.pop();
                  b = stack.pop();
                  stack.push(a2 / b);
                  break;
                case 14:
                  a2 = stack.pop();
                  stack.push(-a2);
                  break;
                case 15:
                  a2 = stack.pop();
                  b = stack.pop();
                  stack.push(a2 === b ? 1 : 0);
                  break;
                case 18:
                  stack.pop();
                  break;
                case 20:
                  let val = stack.pop();
                  let idx = stack.pop();
                  trans[idx] = val;
                  break;
                case 21:
                  idx = stack.pop();
                  stack.push(trans[idx] || 0);
                  break;
                case 22:
                  let s1 = stack.pop();
                  let s2 = stack.pop();
                  let v1 = stack.pop();
                  let v2 = stack.pop();
                  stack.push(v1 <= v2 ? s1 : s2);
                  break;
                case 23:
                  stack.push(Math.random());
                  break;
                case 24:
                  a2 = stack.pop();
                  b = stack.pop();
                  stack.push(a2 * b);
                  break;
                case 26:
                  a2 = stack.pop();
                  stack.push(Math.sqrt(a2));
                  break;
                case 27:
                  a2 = stack.pop();
                  stack.push(a2, a2);
                  break;
                case 28:
                  a2 = stack.pop();
                  b = stack.pop();
                  stack.push(b, a2);
                  break;
                case 29:
                  idx = stack.pop();
                  if (idx < 0)
                    idx = 0;
                  else if (idx > stack.length - 1)
                    idx = stack.length - 1;
                  stack.push(stack[idx]);
                  break;
                case 30:
                  let n = stack.pop();
                  let j = stack.pop();
                  if (j >= 0)
                    while (j > 0) {
                      var t2 = stack[n - 1];
                      for (let i = n - 2; i >= 0; i--)
                        stack[i + 1] = stack[i];
                      stack[0] = t2;
                      j--;
                    }
                  else
                    while (j < 0) {
                      var t2 = stack[0];
                      for (let i = 0; i <= n; i++)
                        stack[i] = stack[i + 1];
                      stack[n - 1] = t2;
                      j++;
                    }
                  break;
                case 34:
                  c1x = x1 + stack.shift();
                  c1y = y1;
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  let c3x = c2x + stack.shift();
                  let c3y = c2y;
                  let c4x = c3x + stack.shift();
                  let c4y = c3y;
                  let c5x = c4x + stack.shift();
                  let c5y = c4y;
                  let c6x = c5x + stack.shift();
                  let c6y = c5y;
                  x1 = c6x;
                  y1 = c6y;
                  path2.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                  path2.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                  break;
                case 35:
                  let pts = [];
                  for (let i = 0; i <= 5; i++) {
                    x1 += stack.shift();
                    y1 += stack.shift();
                    pts.push(x1, y1);
                  }
                  path2.bezierCurveTo(...pts.slice(0, 6));
                  path2.bezierCurveTo(...pts.slice(6));
                  stack.shift();
                  break;
                case 36:
                  c1x = x1 + stack.shift();
                  c1y = y1 + stack.shift();
                  c2x = c1x + stack.shift();
                  c2y = c1y + stack.shift();
                  c3x = c2x + stack.shift();
                  c3y = c2y;
                  c4x = c3x + stack.shift();
                  c4y = c3y;
                  c5x = c4x + stack.shift();
                  c5y = c4y + stack.shift();
                  c6x = c5x + stack.shift();
                  c6y = c5y;
                  x1 = c6x;
                  y1 = c6y;
                  path2.bezierCurveTo(c1x, c1y, c2x, c2y, c3x, c3y);
                  path2.bezierCurveTo(c4x, c4y, c5x, c5y, c6x, c6y);
                  break;
                case 37:
                  let startx = x1;
                  let starty = y1;
                  pts = [];
                  for (let i1 = 0; i1 <= 4; i1++) {
                    x1 += stack.shift();
                    y1 += stack.shift();
                    pts.push(x1, y1);
                  }
                  if (Math.abs(x1 - startx) > Math.abs(y1 - starty)) {
                    x1 += stack.shift();
                    y1 = starty;
                  } else {
                    x1 = startx;
                    y1 += stack.shift();
                  }
                  pts.push(x1, y1);
                  path2.bezierCurveTo(...pts.slice(0, 6));
                  path2.bezierCurveTo(...pts.slice(6));
                  break;
                default:
                  throw new Error(`Unknown op: 12 ${op}`);
              }
              break;
            default:
              throw new Error(`Unknown op: ${op}`);
          }
        } else if (op < 247)
          stack.push(op - 139);
        else if (op < 251) {
          var b1 = stream2.readUInt8();
          stack.push((op - 247) * 256 + b1 + 108);
        } else if (op < 255) {
          var b1 = stream2.readUInt8();
          stack.push(-(op - 251) * 256 - b1 - 108);
        } else
          stack.push(stream2.readInt32BE() / 65536);
      }
    };
    parse3();
    if (open)
      path2.closePath();
    return path2;
  }
  constructor(...args) {
    super(...args);
    (0, _defineProperty)(this, "type", "CFF");
  }
};
var $25d8f049c222084c$var$SBIXImage = new Struct({
  originX: uint16,
  originY: uint16,
  type: new StringT(4),
  data: new BufferT((t2) => t2.parent.buflen - t2._currentOffset)
});
var $25d8f049c222084c$export$2e2bcd8739ae039 = class extends (0, $69aac16029968692$export$2e2bcd8739ae039) {
  /**
  * Returns an object representing a glyph image at the given point size.
  * The object has a data property with a Buffer containing the actual image data,
  * along with the image type, and origin.
  *
  * @param {number} size
  * @return {object}
  */
  getImageForSize(size) {
    for (let i = 0; i < this._font.sbix.imageTables.length; i++) {
      var table = this._font.sbix.imageTables[i];
      if (table.ppem >= size)
        break;
    }
    let offsets = table.imageOffsets;
    let start3 = offsets[this.id];
    let end3 = offsets[this.id + 1];
    if (start3 === end3)
      return null;
    this._font.stream.pos = start3;
    return $25d8f049c222084c$var$SBIXImage.decode(this._font.stream, {
      buflen: end3 - start3
    });
  }
  render(ctx, size) {
    let img = this.getImageForSize(size);
    if (img != null) {
      let scale4 = size / this._font.unitsPerEm;
      ctx.image(img.data, {
        height: size,
        x: img.originX,
        y: (this.bbox.minY - img.originY) * scale4
      });
    }
    if (this._font.sbix.flags.renderOutlines)
      super.render(ctx, size);
  }
  constructor(...args) {
    super(...args);
    (0, _defineProperty)(this, "type", "SBIX");
  }
};
var $0d411f0165859681$var$COLRLayer = class {
  constructor(glyph, color) {
    this.glyph = glyph;
    this.color = color;
  }
};
var $0d411f0165859681$export$2e2bcd8739ae039 = class extends (0, $f92906be28e61769$export$2e2bcd8739ae039) {
  _getBBox() {
    let bbox = new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)();
    for (let i = 0; i < this.layers.length; i++) {
      let layer = this.layers[i];
      let b = layer.glyph.bbox;
      bbox.addPoint(b.minX, b.minY);
      bbox.addPoint(b.maxX, b.maxY);
    }
    return bbox;
  }
  /**
  * Returns an array of objects containing the glyph and color for
  * each layer in the composite color glyph.
  * @type {object[]}
  */
  get layers() {
    let cpal = this._font.CPAL;
    let colr = this._font.COLR;
    let low = 0;
    let high = colr.baseGlyphRecord.length - 1;
    while (low <= high) {
      let mid = low + high >> 1;
      var rec = colr.baseGlyphRecord[mid];
      if (this.id < rec.gid)
        high = mid - 1;
      else if (this.id > rec.gid)
        low = mid + 1;
      else {
        var baseLayer = rec;
        break;
      }
    }
    if (baseLayer == null) {
      var g3 = this._font._getBaseGlyph(this.id);
      var color = {
        red: 0,
        green: 0,
        blue: 0,
        alpha: 255
      };
      return [
        new $0d411f0165859681$var$COLRLayer(g3, color)
      ];
    }
    let layers = [];
    for (let i = baseLayer.firstLayerIndex; i < baseLayer.firstLayerIndex + baseLayer.numLayers; i++) {
      var rec = colr.layerRecords[i];
      var color = cpal.colorRecords[rec.paletteIndex];
      var g3 = this._font._getBaseGlyph(rec.gid);
      layers.push(new $0d411f0165859681$var$COLRLayer(g3, color));
    }
    return layers;
  }
  render(ctx, size) {
    for (let { glyph, color } of this.layers) {
      ctx.fillColor([
        color.red,
        color.green,
        color.blue
      ], color.alpha / 255 * 100);
      glyph.render(ctx, size);
    }
    return;
  }
  constructor(...args) {
    super(...args);
    (0, _defineProperty)(this, "type", "COLR");
  }
};
var $0bb840cac04e911b$var$TUPLES_SHARE_POINT_NUMBERS = 32768;
var $0bb840cac04e911b$var$TUPLE_COUNT_MASK = 4095;
var $0bb840cac04e911b$var$EMBEDDED_TUPLE_COORD = 32768;
var $0bb840cac04e911b$var$INTERMEDIATE_TUPLE = 16384;
var $0bb840cac04e911b$var$PRIVATE_POINT_NUMBERS = 8192;
var $0bb840cac04e911b$var$TUPLE_INDEX_MASK = 4095;
var $0bb840cac04e911b$var$POINTS_ARE_WORDS = 128;
var $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK = 127;
var $0bb840cac04e911b$var$DELTAS_ARE_ZERO = 128;
var $0bb840cac04e911b$var$DELTAS_ARE_WORDS = 64;
var $0bb840cac04e911b$var$DELTA_RUN_COUNT_MASK = 63;
var $0bb840cac04e911b$export$2e2bcd8739ae039 = class {
  normalizeCoords(coords) {
    let normalized = [];
    for (var i = 0; i < this.font.fvar.axis.length; i++) {
      let axis = this.font.fvar.axis[i];
      if (coords[i] < axis.defaultValue)
        normalized.push((coords[i] - axis.defaultValue + Number.EPSILON) / (axis.defaultValue - axis.minValue + Number.EPSILON));
      else
        normalized.push((coords[i] - axis.defaultValue + Number.EPSILON) / (axis.maxValue - axis.defaultValue + Number.EPSILON));
    }
    if (this.font.avar)
      for (var i = 0; i < this.font.avar.segment.length; i++) {
        let segment = this.font.avar.segment[i];
        for (let j = 0; j < segment.correspondence.length; j++) {
          let pair = segment.correspondence[j];
          if (j >= 1 && normalized[i] < pair.fromCoord) {
            let prev = segment.correspondence[j - 1];
            normalized[i] = ((normalized[i] - prev.fromCoord) * (pair.toCoord - prev.toCoord) + Number.EPSILON) / (pair.fromCoord - prev.fromCoord + Number.EPSILON) + prev.toCoord;
            break;
          }
        }
      }
    return normalized;
  }
  transformPoints(gid, glyphPoints) {
    if (!this.font.fvar || !this.font.gvar)
      return;
    let { gvar } = this.font;
    if (gid >= gvar.glyphCount)
      return;
    let offset3 = gvar.offsets[gid];
    if (offset3 === gvar.offsets[gid + 1])
      return;
    let { stream: stream2 } = this.font;
    stream2.pos = offset3;
    if (stream2.pos >= stream2.length)
      return;
    let tupleCount = stream2.readUInt16BE();
    let offsetToData = offset3 + stream2.readUInt16BE();
    if (tupleCount & $0bb840cac04e911b$var$TUPLES_SHARE_POINT_NUMBERS) {
      var here = stream2.pos;
      stream2.pos = offsetToData;
      var sharedPoints = this.decodePoints();
      offsetToData = stream2.pos;
      stream2.pos = here;
    }
    let origPoints = glyphPoints.map((pt) => pt.copy());
    tupleCount &= $0bb840cac04e911b$var$TUPLE_COUNT_MASK;
    for (let i = 0; i < tupleCount; i++) {
      let tupleDataSize = stream2.readUInt16BE();
      let tupleIndex = stream2.readUInt16BE();
      if (tupleIndex & $0bb840cac04e911b$var$EMBEDDED_TUPLE_COORD) {
        var tupleCoords = [];
        for (let a2 = 0; a2 < gvar.axisCount; a2++)
          tupleCoords.push(stream2.readInt16BE() / 16384);
      } else {
        if ((tupleIndex & $0bb840cac04e911b$var$TUPLE_INDEX_MASK) >= gvar.globalCoordCount)
          throw new Error("Invalid gvar table");
        var tupleCoords = gvar.globalCoords[tupleIndex & $0bb840cac04e911b$var$TUPLE_INDEX_MASK];
      }
      if (tupleIndex & $0bb840cac04e911b$var$INTERMEDIATE_TUPLE) {
        var startCoords = [];
        for (let a2 = 0; a2 < gvar.axisCount; a2++)
          startCoords.push(stream2.readInt16BE() / 16384);
        var endCoords = [];
        for (let a1 = 0; a1 < gvar.axisCount; a1++)
          endCoords.push(stream2.readInt16BE() / 16384);
      }
      let factor3 = this.tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords);
      if (factor3 === 0) {
        offsetToData += tupleDataSize;
        continue;
      }
      var here = stream2.pos;
      stream2.pos = offsetToData;
      if (tupleIndex & $0bb840cac04e911b$var$PRIVATE_POINT_NUMBERS)
        var points = this.decodePoints();
      else
        var points = sharedPoints;
      let nPoints = points.length === 0 ? glyphPoints.length : points.length;
      let xDeltas = this.decodeDeltas(nPoints);
      let yDeltas = this.decodeDeltas(nPoints);
      if (points.length === 0)
        for (let i2 = 0; i2 < glyphPoints.length; i2++) {
          var point = glyphPoints[i2];
          point.x += Math.round(xDeltas[i2] * factor3);
          point.y += Math.round(yDeltas[i2] * factor3);
        }
      else {
        let outPoints = origPoints.map((pt) => pt.copy());
        let hasDelta = glyphPoints.map(() => false);
        for (let i2 = 0; i2 < points.length; i2++) {
          let idx = points[i2];
          if (idx < glyphPoints.length) {
            let point2 = outPoints[idx];
            hasDelta[idx] = true;
            point2.x += Math.round(xDeltas[i2] * factor3);
            point2.y += Math.round(yDeltas[i2] * factor3);
          }
        }
        this.interpolateMissingDeltas(outPoints, origPoints, hasDelta);
        for (let i1 = 0; i1 < glyphPoints.length; i1++) {
          let deltaX = outPoints[i1].x - origPoints[i1].x;
          let deltaY = outPoints[i1].y - origPoints[i1].y;
          glyphPoints[i1].x += deltaX;
          glyphPoints[i1].y += deltaY;
        }
      }
      offsetToData += tupleDataSize;
      stream2.pos = here;
    }
  }
  decodePoints() {
    let stream2 = this.font.stream;
    let count = stream2.readUInt8();
    if (count & $0bb840cac04e911b$var$POINTS_ARE_WORDS)
      count = (count & $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK) << 8 | stream2.readUInt8();
    let points = new Uint16Array(count);
    let i = 0;
    let point = 0;
    while (i < count) {
      let run = stream2.readUInt8();
      let runCount = (run & $0bb840cac04e911b$var$POINT_RUN_COUNT_MASK) + 1;
      let fn = run & $0bb840cac04e911b$var$POINTS_ARE_WORDS ? stream2.readUInt16 : stream2.readUInt8;
      for (let j = 0; j < runCount && i < count; j++) {
        point += fn.call(stream2);
        points[i++] = point;
      }
    }
    return points;
  }
  decodeDeltas(count) {
    let stream2 = this.font.stream;
    let i = 0;
    let deltas = new Int16Array(count);
    while (i < count) {
      let run = stream2.readUInt8();
      let runCount = (run & $0bb840cac04e911b$var$DELTA_RUN_COUNT_MASK) + 1;
      if (run & $0bb840cac04e911b$var$DELTAS_ARE_ZERO)
        i += runCount;
      else {
        let fn = run & $0bb840cac04e911b$var$DELTAS_ARE_WORDS ? stream2.readInt16BE : stream2.readInt8;
        for (let j = 0; j < runCount && i < count; j++)
          deltas[i++] = fn.call(stream2);
      }
    }
    return deltas;
  }
  tupleFactor(tupleIndex, tupleCoords, startCoords, endCoords) {
    let normalized = this.normalizedCoords;
    let { gvar } = this.font;
    let factor3 = 1;
    for (let i = 0; i < gvar.axisCount; i++) {
      if (tupleCoords[i] === 0)
        continue;
      if (normalized[i] === 0)
        return 0;
      if ((tupleIndex & $0bb840cac04e911b$var$INTERMEDIATE_TUPLE) === 0) {
        if (normalized[i] < Math.min(0, tupleCoords[i]) || normalized[i] > Math.max(0, tupleCoords[i]))
          return 0;
        factor3 = (factor3 * normalized[i] + Number.EPSILON) / (tupleCoords[i] + Number.EPSILON);
      } else {
        if (normalized[i] < startCoords[i] || normalized[i] > endCoords[i])
          return 0;
        else if (normalized[i] < tupleCoords[i])
          factor3 = factor3 * (normalized[i] - startCoords[i] + Number.EPSILON) / (tupleCoords[i] - startCoords[i] + Number.EPSILON);
        else
          factor3 = factor3 * (endCoords[i] - normalized[i] + Number.EPSILON) / (endCoords[i] - tupleCoords[i] + Number.EPSILON);
      }
    }
    return factor3;
  }
  // Interpolates points without delta values.
  // Needed for the Ø and Q glyphs in Skia.
  // Algorithm from Freetype.
  interpolateMissingDeltas(points, inPoints, hasDelta) {
    if (points.length === 0)
      return;
    let point = 0;
    while (point < points.length) {
      let firstPoint = point;
      let endPoint = point;
      let pt = points[endPoint];
      while (!pt.endContour)
        pt = points[++endPoint];
      while (point <= endPoint && !hasDelta[point])
        point++;
      if (point > endPoint)
        continue;
      let firstDelta = point;
      let curDelta = point;
      point++;
      while (point <= endPoint) {
        if (hasDelta[point]) {
          this.deltaInterpolate(curDelta + 1, point - 1, curDelta, point, inPoints, points);
          curDelta = point;
        }
        point++;
      }
      if (curDelta === firstDelta)
        this.deltaShift(firstPoint, endPoint, curDelta, inPoints, points);
      else {
        this.deltaInterpolate(curDelta + 1, endPoint, curDelta, firstDelta, inPoints, points);
        if (firstDelta > 0)
          this.deltaInterpolate(firstPoint, firstDelta - 1, curDelta, firstDelta, inPoints, points);
      }
      point = endPoint + 1;
    }
  }
  deltaInterpolate(p1, p2, ref1, ref2, inPoints, outPoints) {
    if (p1 > p2)
      return;
    let iterable = [
      "x",
      "y"
    ];
    for (let i = 0; i < iterable.length; i++) {
      let k = iterable[i];
      if (inPoints[ref1][k] > inPoints[ref2][k]) {
        var p = ref1;
        ref1 = ref2;
        ref2 = p;
      }
      let in1 = inPoints[ref1][k];
      let in2 = inPoints[ref2][k];
      let out1 = outPoints[ref1][k];
      let out2 = outPoints[ref2][k];
      if (in1 !== in2 || out1 === out2) {
        let scale4 = in1 === in2 ? 0 : (out2 - out1) / (in2 - in1);
        for (let p3 = p1; p3 <= p2; p3++) {
          let out = inPoints[p3][k];
          if (out <= in1)
            out += out1 - in1;
          else if (out >= in2)
            out += out2 - in2;
          else
            out = out1 + (out - in1) * scale4;
          outPoints[p3][k] = out;
        }
      }
    }
  }
  deltaShift(p1, p2, ref, inPoints, outPoints) {
    let deltaX = outPoints[ref].x - inPoints[ref].x;
    let deltaY = outPoints[ref].y - inPoints[ref].y;
    if (deltaX === 0 && deltaY === 0)
      return;
    for (let p = p1; p <= p2; p++)
      if (p !== ref) {
        outPoints[p].x += deltaX;
        outPoints[p].y += deltaY;
      }
  }
  getAdvanceAdjustment(gid, table) {
    let outerIndex, innerIndex;
    if (table.advanceWidthMapping) {
      let idx = gid;
      if (idx >= table.advanceWidthMapping.mapCount)
        idx = table.advanceWidthMapping.mapCount - 1;
      let entryFormat = table.advanceWidthMapping.entryFormat;
      ({ outerIndex, innerIndex } = table.advanceWidthMapping.mapData[idx]);
    } else {
      outerIndex = 0;
      innerIndex = gid;
    }
    return this.getDelta(table.itemVariationStore, outerIndex, innerIndex);
  }
  // See pseudo code from `Font Variations Overview'
  // in the OpenType specification.
  getDelta(itemStore, outerIndex, innerIndex) {
    if (outerIndex >= itemStore.itemVariationData.length)
      return 0;
    let varData = itemStore.itemVariationData[outerIndex];
    if (innerIndex >= varData.deltaSets.length)
      return 0;
    let deltaSet = varData.deltaSets[innerIndex];
    let blendVector = this.getBlendVector(itemStore, outerIndex);
    let netAdjustment = 0;
    for (let master = 0; master < varData.regionIndexCount; master++)
      netAdjustment += deltaSet.deltas[master] * blendVector[master];
    return netAdjustment;
  }
  getBlendVector(itemStore, outerIndex) {
    let varData = itemStore.itemVariationData[outerIndex];
    if (this.blendVectors.has(varData))
      return this.blendVectors.get(varData);
    let normalizedCoords = this.normalizedCoords;
    let blendVector = [];
    for (let master = 0; master < varData.regionIndexCount; master++) {
      let scalar = 1;
      let regionIndex = varData.regionIndexes[master];
      let axes = itemStore.variationRegionList.variationRegions[regionIndex];
      for (let j = 0; j < axes.length; j++) {
        let axis = axes[j];
        let axisScalar;
        if (axis.startCoord > axis.peakCoord || axis.peakCoord > axis.endCoord)
          axisScalar = 1;
        else if (axis.startCoord < 0 && axis.endCoord > 0 && axis.peakCoord !== 0)
          axisScalar = 1;
        else if (axis.peakCoord === 0)
          axisScalar = 1;
        else if (normalizedCoords[j] < axis.startCoord || normalizedCoords[j] > axis.endCoord)
          axisScalar = 0;
        else {
          if (normalizedCoords[j] === axis.peakCoord)
            axisScalar = 1;
          else if (normalizedCoords[j] < axis.peakCoord)
            axisScalar = (normalizedCoords[j] - axis.startCoord + Number.EPSILON) / (axis.peakCoord - axis.startCoord + Number.EPSILON);
          else
            axisScalar = (axis.endCoord - normalizedCoords[j] + Number.EPSILON) / (axis.endCoord - axis.peakCoord + Number.EPSILON);
        }
        scalar *= axisScalar;
      }
      blendVector[master] = scalar;
    }
    this.blendVectors.set(varData, blendVector);
    return blendVector;
  }
  constructor(font2, coords) {
    this.font = font2;
    this.normalizedCoords = this.normalizeCoords(coords);
    this.blendVectors = /* @__PURE__ */ new Map();
  }
};
var $5cc7476da92df375$var$resolved = Promise.resolve();
var $5cc7476da92df375$export$2e2bcd8739ae039 = class {
  includeGlyph(glyph) {
    if (typeof glyph === "object")
      glyph = glyph.id;
    if (this.mapping[glyph] == null) {
      this.glyphs.push(glyph);
      this.mapping[glyph] = this.glyphs.length - 1;
    }
    return this.mapping[glyph];
  }
  constructor(font2) {
    this.font = font2;
    this.glyphs = [];
    this.mapping = {};
    this.includeGlyph(0);
  }
};
var $807e58506be70005$var$ON_CURVE = 1;
var $807e58506be70005$var$X_SHORT_VECTOR = 2;
var $807e58506be70005$var$Y_SHORT_VECTOR = 4;
var $807e58506be70005$var$REPEAT = 8;
var $807e58506be70005$var$SAME_X = 16;
var $807e58506be70005$var$SAME_Y = 32;
var $807e58506be70005$var$Point = class {
  static size(val) {
    return val >= 0 && val <= 255 ? 1 : 2;
  }
  static encode(stream2, value2) {
    if (value2 >= 0 && value2 <= 255)
      stream2.writeUInt8(value2);
    else
      stream2.writeInt16BE(value2);
  }
};
var $807e58506be70005$var$Glyf = new Struct({
  numberOfContours: int16,
  xMin: int16,
  yMin: int16,
  xMax: int16,
  yMax: int16,
  endPtsOfContours: new ArrayT(uint16, "numberOfContours"),
  instructions: new ArrayT(uint8, uint16),
  flags: new ArrayT(uint8, 0),
  xPoints: new ArrayT($807e58506be70005$var$Point, 0),
  yPoints: new ArrayT($807e58506be70005$var$Point, 0)
});
var $807e58506be70005$export$2e2bcd8739ae039 = class {
  encodeSimple(path2, instructions = []) {
    let endPtsOfContours = [];
    let xPoints = [];
    let yPoints = [];
    let flags = [];
    let same = 0;
    let lastX = 0, lastY = 0, lastFlag = 0;
    let pointCount = 0;
    for (let i = 0; i < path2.commands.length; i++) {
      let c2 = path2.commands[i];
      for (let j = 0; j < c2.args.length; j += 2) {
        let x = c2.args[j];
        let y = c2.args[j + 1];
        let flag = 0;
        if (c2.command === "quadraticCurveTo" && j === 2) {
          let next2 = path2.commands[i + 1];
          if (next2 && next2.command === "quadraticCurveTo") {
            let midX = (lastX + next2.args[0]) / 2;
            let midY = (lastY + next2.args[1]) / 2;
            if (x === midX && y === midY)
              continue;
          }
        }
        if (!(c2.command === "quadraticCurveTo" && j === 0))
          flag |= $807e58506be70005$var$ON_CURVE;
        flag = this._encodePoint(x, lastX, xPoints, flag, $807e58506be70005$var$X_SHORT_VECTOR, $807e58506be70005$var$SAME_X);
        flag = this._encodePoint(y, lastY, yPoints, flag, $807e58506be70005$var$Y_SHORT_VECTOR, $807e58506be70005$var$SAME_Y);
        if (flag === lastFlag && same < 255) {
          flags[flags.length - 1] |= $807e58506be70005$var$REPEAT;
          same++;
        } else {
          if (same > 0) {
            flags.push(same);
            same = 0;
          }
          flags.push(flag);
          lastFlag = flag;
        }
        lastX = x;
        lastY = y;
        pointCount++;
      }
      if (c2.command === "closePath")
        endPtsOfContours.push(pointCount - 1);
    }
    if (path2.commands.length > 1 && path2.commands[path2.commands.length - 1].command !== "closePath")
      endPtsOfContours.push(pointCount - 1);
    let bbox = path2.bbox;
    let glyf = {
      numberOfContours: endPtsOfContours.length,
      xMin: bbox.minX,
      yMin: bbox.minY,
      xMax: bbox.maxX,
      yMax: bbox.maxY,
      endPtsOfContours,
      instructions,
      flags,
      xPoints,
      yPoints
    };
    let size = $807e58506be70005$var$Glyf.size(glyf);
    let tail = 4 - size % 4;
    let stream2 = new EncodeStream(size + tail);
    $807e58506be70005$var$Glyf.encode(stream2, glyf);
    if (tail !== 0)
      stream2.fill(0, tail);
    return stream2.buffer;
  }
  _encodePoint(value2, last3, points, flag, shortFlag, sameFlag) {
    let diff = value2 - last3;
    if (value2 === last3)
      flag |= sameFlag;
    else {
      if (-255 <= diff && diff <= 255) {
        flag |= shortFlag;
        if (diff < 0)
          diff = -diff;
        else
          flag |= sameFlag;
      }
      points.push(diff);
    }
    return flag;
  }
};
var $4abbb6a5dbdc441a$export$2e2bcd8739ae039 = class extends (0, $5cc7476da92df375$export$2e2bcd8739ae039) {
  _addGlyph(gid) {
    let glyph = this.font.getGlyph(gid);
    let glyf = glyph._decode();
    let curOffset = this.font.loca.offsets[gid];
    let nextOffset = this.font.loca.offsets[gid + 1];
    let stream2 = this.font._getTableStream("glyf");
    stream2.pos += curOffset;
    let buffer3 = stream2.readBuffer(nextOffset - curOffset);
    if (glyf && glyf.numberOfContours < 0) {
      buffer3 = new Uint8Array(buffer3);
      let view = new DataView(buffer3.buffer);
      for (let component of glyf.components) {
        gid = this.includeGlyph(component.glyphID);
        view.setUint16(component.pos, gid);
      }
    } else if (glyf && this.font._variationProcessor)
      buffer3 = this.glyphEncoder.encodeSimple(glyph.path, glyf.instructions);
    this.glyf.push(buffer3);
    this.loca.offsets.push(this.offset);
    this.hmtx.metrics.push({
      advance: glyph.advanceWidth,
      bearing: glyph._getMetrics().leftBearing
    });
    this.offset += buffer3.length;
    return this.glyf.length - 1;
  }
  encode() {
    this.glyf = [];
    this.offset = 0;
    this.loca = {
      offsets: [],
      version: this.font.loca.version
    };
    this.hmtx = {
      metrics: [],
      bearings: []
    };
    let i = 0;
    while (i < this.glyphs.length)
      this._addGlyph(this.glyphs[i++]);
    let maxp = (0, import_clone.default)(this.font.maxp);
    maxp.numGlyphs = this.glyf.length;
    this.loca.offsets.push(this.offset);
    let head = (0, import_clone.default)(this.font.head);
    head.indexToLocFormat = this.loca.version;
    let hhea = (0, import_clone.default)(this.font.hhea);
    hhea.numberOfMetrics = this.hmtx.metrics.length;
    return (0, $816c07a04b6dba87$export$2e2bcd8739ae039).toBuffer({
      tables: {
        head,
        hhea,
        loca: this.loca,
        maxp,
        "cvt ": this.font["cvt "],
        prep: this.font.prep,
        glyf: this.glyf,
        hmtx: this.hmtx,
        fpgm: this.font.fpgm
      }
    });
  }
  constructor(font2) {
    super(font2);
    this.glyphEncoder = new (0, $807e58506be70005$export$2e2bcd8739ae039)();
  }
};
var $001d739428a71d5a$export$2e2bcd8739ae039 = class extends (0, $5cc7476da92df375$export$2e2bcd8739ae039) {
  subsetCharstrings() {
    this.charstrings = [];
    let gsubrs = {};
    for (let gid of this.glyphs) {
      this.charstrings.push(this.cff.getCharString(gid));
      let glyph = this.font.getGlyph(gid);
      let path2 = glyph.path;
      for (let subr in glyph._usedGsubrs)
        gsubrs[subr] = true;
    }
    this.gsubrs = this.subsetSubrs(this.cff.globalSubrIndex, gsubrs);
  }
  subsetSubrs(subrs, used) {
    let res = [];
    for (let i = 0; i < subrs.length; i++) {
      let subr = subrs[i];
      if (used[i]) {
        this.cff.stream.pos = subr.offset;
        res.push(this.cff.stream.readBuffer(subr.length));
      } else
        res.push(new Uint8Array([
          11
        ]));
    }
    return res;
  }
  subsetFontdict(topDict) {
    topDict.FDArray = [];
    topDict.FDSelect = {
      version: 0,
      fds: []
    };
    let used_fds = {};
    let used_subrs = [];
    let fd_select = {};
    for (let gid of this.glyphs) {
      let fd = this.cff.fdForGlyph(gid);
      if (fd == null)
        continue;
      if (!used_fds[fd]) {
        topDict.FDArray.push(Object.assign({}, this.cff.topDict.FDArray[fd]));
        used_subrs.push({});
        fd_select[fd] = topDict.FDArray.length - 1;
      }
      used_fds[fd] = true;
      topDict.FDSelect.fds.push(fd_select[fd]);
      let glyph = this.font.getGlyph(gid);
      let path2 = glyph.path;
      for (let subr in glyph._usedSubrs)
        used_subrs[fd_select[fd]][subr] = true;
    }
    for (let i = 0; i < topDict.FDArray.length; i++) {
      let dict = topDict.FDArray[i];
      delete dict.FontName;
      if (dict.Private && dict.Private.Subrs) {
        dict.Private = Object.assign({}, dict.Private);
        dict.Private.Subrs = this.subsetSubrs(dict.Private.Subrs, used_subrs[i]);
      }
    }
    return;
  }
  createCIDFontdict(topDict) {
    let used_subrs = {};
    for (let gid of this.glyphs) {
      let glyph = this.font.getGlyph(gid);
      let path2 = glyph.path;
      for (let subr in glyph._usedSubrs)
        used_subrs[subr] = true;
    }
    let privateDict = Object.assign({}, this.cff.topDict.Private);
    if (this.cff.topDict.Private && this.cff.topDict.Private.Subrs)
      privateDict.Subrs = this.subsetSubrs(this.cff.topDict.Private.Subrs, used_subrs);
    topDict.FDArray = [
      {
        Private: privateDict
      }
    ];
    return topDict.FDSelect = {
      version: 3,
      nRanges: 1,
      ranges: [
        {
          first: 0,
          fd: 0
        }
      ],
      sentinel: this.charstrings.length
    };
  }
  addString(string) {
    if (!string)
      return null;
    if (!this.strings)
      this.strings = [];
    this.strings.push(string);
    return (0, $229224aec43783c5$export$2e2bcd8739ae039).length + this.strings.length - 1;
  }
  encode() {
    this.subsetCharstrings();
    let charset = {
      version: this.charstrings.length > 255 ? 2 : 1,
      ranges: [
        {
          first: 1,
          nLeft: this.charstrings.length - 2
        }
      ]
    };
    let topDict = Object.assign({}, this.cff.topDict);
    topDict.Private = null;
    topDict.charset = charset;
    topDict.Encoding = null;
    topDict.CharStrings = this.charstrings;
    for (let key of [
      "version",
      "Notice",
      "Copyright",
      "FullName",
      "FamilyName",
      "Weight",
      "PostScript",
      "BaseFontName",
      "FontName"
    ])
      topDict[key] = this.addString(this.cff.string(topDict[key]));
    topDict.ROS = [
      this.addString("Adobe"),
      this.addString("Identity"),
      0
    ];
    topDict.CIDCount = this.charstrings.length;
    if (this.cff.isCIDFont)
      this.subsetFontdict(topDict);
    else
      this.createCIDFontdict(topDict);
    let top = {
      version: 1,
      hdrSize: this.cff.hdrSize,
      offSize: 4,
      header: this.cff.header,
      nameIndex: [
        this.cff.postscriptName
      ],
      topDictIndex: [
        topDict
      ],
      stringIndex: this.strings,
      globalSubrIndex: this.gsubrs
    };
    return (0, $b84fd3dd9d8eddb2$export$2e2bcd8739ae039).toBuffer(top);
  }
  constructor(font2) {
    super(font2);
    this.cff = this.font["CFF "];
    if (!this.cff)
      throw new Error("Not a CFF Font");
  }
};
var $4c1709dee528ea76$export$2e2bcd8739ae039 = class _$4c1709dee528ea76$export$2e2bcd8739ae039 {
  static probe(buffer3) {
    let format = (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer3.slice(0, 4));
    return format === "true" || format === "OTTO" || format === String.fromCharCode(0, 1, 0, 0);
  }
  setDefaultLanguage(lang = null) {
    this.defaultLanguage = lang;
  }
  _getTable(table) {
    if (!(table.tag in this._tables))
      try {
        this._tables[table.tag] = this._decodeTable(table);
      } catch (e) {
        if ($d636bc798e7178db$export$bd5c5d8b8dcafd78) {
          console.error(`Error decoding table ${table.tag}`);
          console.error(e.stack);
        }
      }
    return this._tables[table.tag];
  }
  _getTableStream(tag) {
    let table = this.directory.tables[tag];
    if (table) {
      this.stream.pos = table.offset;
      return this.stream;
    }
    return null;
  }
  _decodeDirectory() {
    return this.directory = (0, $816c07a04b6dba87$export$2e2bcd8739ae039).decode(this.stream, {
      _startOffset: 0
    });
  }
  _decodeTable(table) {
    let pos = this.stream.pos;
    let stream2 = this._getTableStream(table.tag);
    let result = (0, $c3395722bea751e2$export$2e2bcd8739ae039)[table.tag].decode(stream2, this, table.length);
    this.stream.pos = pos;
    return result;
  }
  /**
  * Gets a string from the font's `name` table
  * `lang` is a BCP-47 language code.
  * @return {string}
  */
  getName(key, lang = this.defaultLanguage || $d636bc798e7178db$export$42940898df819940) {
    let record = this.name && this.name.records[key];
    if (record)
      return record[lang] || record[this.defaultLanguage] || record[$d636bc798e7178db$export$42940898df819940] || record["en"] || record[Object.keys(record)[0]] || null;
    return null;
  }
  /**
  * The unique PostScript name for this font, e.g. "Helvetica-Bold"
  * @type {string}
  */
  get postscriptName() {
    return this.getName("postscriptName");
  }
  /**
  * The font's full name, e.g. "Helvetica Bold"
  * @type {string}
  */
  get fullName() {
    return this.getName("fullName");
  }
  /**
  * The font's family name, e.g. "Helvetica"
  * @type {string}
  */
  get familyName() {
    return this.getName("fontFamily");
  }
  /**
  * The font's sub-family, e.g. "Bold".
  * @type {string}
  */
  get subfamilyName() {
    return this.getName("fontSubfamily");
  }
  /**
  * The font's copyright information
  * @type {string}
  */
  get copyright() {
    return this.getName("copyright");
  }
  /**
  * The font's version number
  * @type {string}
  */
  get version() {
    return this.getName("version");
  }
  /**
  * The font’s [ascender](https://en.wikipedia.org/wiki/Ascender_(typography))
  * @type {number}
  */
  get ascent() {
    return this.hhea.ascent;
  }
  /**
  * The font’s [descender](https://en.wikipedia.org/wiki/Descender)
  * @type {number}
  */
  get descent() {
    return this.hhea.descent;
  }
  /**
  * The amount of space that should be included between lines
  * @type {number}
  */
  get lineGap() {
    return this.hhea.lineGap;
  }
  /**
  * The offset from the normal underline position that should be used
  * @type {number}
  */
  get underlinePosition() {
    return this.post.underlinePosition;
  }
  /**
  * The weight of the underline that should be used
  * @type {number}
  */
  get underlineThickness() {
    return this.post.underlineThickness;
  }
  /**
  * If this is an italic font, the angle the cursor should be drawn at to match the font design
  * @type {number}
  */
  get italicAngle() {
    return this.post.italicAngle;
  }
  /**
  * The height of capital letters above the baseline.
  * See [here](https://en.wikipedia.org/wiki/Cap_height) for more details.
  * @type {number}
  */
  get capHeight() {
    let os2 = this["OS/2"];
    return os2 ? os2.capHeight : this.ascent;
  }
  /**
  * The height of lower case letters in the font.
  * See [here](https://en.wikipedia.org/wiki/X-height) for more details.
  * @type {number}
  */
  get xHeight() {
    let os2 = this["OS/2"];
    return os2 ? os2.xHeight : 0;
  }
  /**
  * The number of glyphs in the font.
  * @type {number}
  */
  get numGlyphs() {
    return this.maxp.numGlyphs;
  }
  /**
  * The size of the font’s internal coordinate grid
  * @type {number}
  */
  get unitsPerEm() {
    return this.head.unitsPerEm;
  }
  /**
  * The font’s bounding box, i.e. the box that encloses all glyphs in the font.
  * @type {BBox}
  */
  get bbox() {
    return Object.freeze(new (0, $f34600ab9d7f70d8$export$2e2bcd8739ae039)(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax));
  }
  get _cmapProcessor() {
    return new (0, $f08dd41ef10b694c$export$2e2bcd8739ae039)(this.cmap);
  }
  /**
  * An array of all of the unicode code points supported by the font.
  * @type {number[]}
  */
  get characterSet() {
    return this._cmapProcessor.getCharacterSet();
  }
  /**
  * Returns whether there is glyph in the font for the given unicode code point.
  *
  * @param {number} codePoint
  * @return {boolean}
  */
  hasGlyphForCodePoint(codePoint) {
    return !!this._cmapProcessor.lookup(codePoint);
  }
  /**
  * Maps a single unicode code point to a Glyph object.
  * Does not perform any advanced substitutions (there is no context to do so).
  *
  * @param {number} codePoint
  * @return {Glyph}
  */
  glyphForCodePoint(codePoint) {
    return this.getGlyph(this._cmapProcessor.lookup(codePoint), [
      codePoint
    ]);
  }
  /**
  * Returns an array of Glyph objects for the given string.
  * This is only a one-to-one mapping from characters to glyphs.
  * For most uses, you should use font.layout (described below), which
  * provides a much more advanced mapping supporting AAT and OpenType shaping.
  *
  * @param {string} string
  * @return {Glyph[]}
  */
  glyphsForString(string) {
    let glyphs = [];
    let len = string.length;
    let idx = 0;
    let last3 = -1;
    let state2 = -1;
    while (idx <= len) {
      let code3 = 0;
      let nextState = 0;
      if (idx < len) {
        code3 = string.charCodeAt(idx++);
        if (55296 <= code3 && code3 <= 56319 && idx < len) {
          let next2 = string.charCodeAt(idx);
          if (56320 <= next2 && next2 <= 57343) {
            idx++;
            code3 = ((code3 & 1023) << 10) + (next2 & 1023) + 65536;
          }
        }
        nextState = 65024 <= code3 && code3 <= 65039 || 917760 <= code3 && code3 <= 917999 ? 1 : 0;
      } else
        idx++;
      if (state2 === 0 && nextState === 1)
        glyphs.push(this.getGlyph(this._cmapProcessor.lookup(last3, code3), [
          last3,
          code3
        ]));
      else if (state2 === 0 && nextState === 0)
        glyphs.push(this.glyphForCodePoint(last3));
      last3 = code3;
      state2 = nextState;
    }
    return glyphs;
  }
  get _layoutEngine() {
    return new (0, $4c0a7fa5df7a9ab1$export$2e2bcd8739ae039)(this);
  }
  /**
  * Returns a GlyphRun object, which includes an array of Glyphs and GlyphPositions for the given string.
  *
  * @param {string} string
  * @param {string[]} [userFeatures]
  * @param {string} [script]
  * @param {string} [language]
  * @param {string} [direction]
  * @return {GlyphRun}
  */
  layout(string, userFeatures, script, language, direction) {
    return this._layoutEngine.layout(string, userFeatures, script, language, direction);
  }
  /**
  * Returns an array of strings that map to the given glyph id.
  * @param {number} gid - glyph id
  */
  stringsForGlyph(gid) {
    return this._layoutEngine.stringsForGlyph(gid);
  }
  /**
  * An array of all [OpenType feature tags](https://www.microsoft.com/typography/otspec/featuretags.htm)
  * (or mapped AAT tags) supported by the font.
  * The features parameter is an array of OpenType feature tags to be applied in addition to the default set.
  * If this is an AAT font, the OpenType feature tags are mapped to AAT features.
  *
  * @type {string[]}
  */
  get availableFeatures() {
    return this._layoutEngine.getAvailableFeatures();
  }
  getAvailableFeatures(script, language) {
    return this._layoutEngine.getAvailableFeatures(script, language);
  }
  _getBaseGlyph(glyph, characters2 = []) {
    if (!this._glyphs[glyph]) {
      if (this.directory.tables.glyf)
        this._glyphs[glyph] = new (0, $69aac16029968692$export$2e2bcd8739ae039)(glyph, characters2, this);
      else if (this.directory.tables["CFF "] || this.directory.tables.CFF2)
        this._glyphs[glyph] = new (0, $62cc5109c6101893$export$2e2bcd8739ae039)(glyph, characters2, this);
    }
    return this._glyphs[glyph] || null;
  }
  /**
  * Returns a glyph object for the given glyph id.
  * You can pass the array of code points this glyph represents for
  * your use later, and it will be stored in the glyph object.
  *
  * @param {number} glyph
  * @param {number[]} characters
  * @return {Glyph}
  */
  getGlyph(glyph, characters2 = []) {
    if (!this._glyphs[glyph]) {
      if (this.directory.tables.sbix)
        this._glyphs[glyph] = new (0, $25d8f049c222084c$export$2e2bcd8739ae039)(glyph, characters2, this);
      else if (this.directory.tables.COLR && this.directory.tables.CPAL)
        this._glyphs[glyph] = new (0, $0d411f0165859681$export$2e2bcd8739ae039)(glyph, characters2, this);
      else
        this._getBaseGlyph(glyph, characters2);
    }
    return this._glyphs[glyph] || null;
  }
  /**
  * Returns a Subset for this font.
  * @return {Subset}
  */
  createSubset() {
    if (this.directory.tables["CFF "])
      return new (0, $001d739428a71d5a$export$2e2bcd8739ae039)(this);
    return new (0, $4abbb6a5dbdc441a$export$2e2bcd8739ae039)(this);
  }
  /**
  * Returns an object describing the available variation axes
  * that this font supports. Keys are setting tags, and values
  * contain the axis name, range, and default value.
  *
  * @type {object}
  */
  get variationAxes() {
    let res = {};
    if (!this.fvar)
      return res;
    for (let axis of this.fvar.axis)
      res[axis.axisTag.trim()] = {
        name: axis.name.en,
        min: axis.minValue,
        default: axis.defaultValue,
        max: axis.maxValue
      };
    return res;
  }
  /**
  * Returns an object describing the named variation instances
  * that the font designer has specified. Keys are variation names
  * and values are the variation settings for this instance.
  *
  * @type {object}
  */
  get namedVariations() {
    let res = {};
    if (!this.fvar)
      return res;
    for (let instance of this.fvar.instance) {
      let settings = {};
      for (let i = 0; i < this.fvar.axis.length; i++) {
        let axis = this.fvar.axis[i];
        settings[axis.axisTag.trim()] = instance.coord[i];
      }
      res[instance.name.en] = settings;
    }
    return res;
  }
  /**
  * Returns a new font with the given variation settings applied.
  * Settings can either be an instance name, or an object containing
  * variation tags as specified by the `variationAxes` property.
  *
  * @param {object} settings
  * @return {TTFFont}
  */
  getVariation(settings) {
    if (!(this.directory.tables.fvar && (this.directory.tables.gvar && this.directory.tables.glyf || this.directory.tables.CFF2)))
      throw new Error("Variations require a font with the fvar, gvar and glyf, or CFF2 tables.");
    if (typeof settings === "string")
      settings = this.namedVariations[settings];
    if (typeof settings !== "object")
      throw new Error("Variation settings must be either a variation name or settings object.");
    let coords = this.fvar.axis.map((axis, i) => {
      let axisTag = axis.axisTag.trim();
      if (axisTag in settings)
        return Math.max(axis.minValue, Math.min(axis.maxValue, settings[axisTag]));
      else
        return axis.defaultValue;
    });
    let stream2 = new DecodeStream(this.stream.buffer);
    stream2.pos = this._directoryPos;
    let font2 = new _$4c1709dee528ea76$export$2e2bcd8739ae039(stream2, coords);
    font2._tables = this._tables;
    return font2;
  }
  get _variationProcessor() {
    if (!this.fvar)
      return null;
    let variationCoords = this.variationCoords;
    if (!variationCoords && !this.CFF2)
      return null;
    if (!variationCoords)
      variationCoords = this.fvar.axis.map((axis) => axis.defaultValue);
    return new (0, $0bb840cac04e911b$export$2e2bcd8739ae039)(this, variationCoords);
  }
  // Standardized format plugin API
  getFont(name) {
    return this.getVariation(name);
  }
  constructor(stream2, variationCoords = null) {
    (0, _defineProperty)(this, "type", "TTF");
    this.defaultLanguage = null;
    this.stream = stream2;
    this.variationCoords = variationCoords;
    this._directoryPos = this.stream.pos;
    this._tables = {};
    this._glyphs = {};
    this._decodeDirectory();
    for (let tag in this.directory.tables) {
      let table = this.directory.tables[tag];
      if ((0, $c3395722bea751e2$export$2e2bcd8739ae039)[tag] && table.length > 0)
        Object.defineProperty(this, tag, {
          get: this._getTable.bind(this, table)
        });
    }
  }
};
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "bbox", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_cmapProcessor", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "characterSet", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_layoutEngine", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "variationAxes", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "namedVariations", null);
(0, __decorate)([
  (0, $e71565f2ce09cb6b$export$69a3209f1a06c04d)
], $4c1709dee528ea76$export$2e2bcd8739ae039.prototype, "_variationProcessor", null);
var $c1726355ecc5b889$var$WOFFDirectoryEntry = new Struct({
  tag: new StringT(4),
  offset: new Pointer(uint32, "void", {
    type: "global"
  }),
  compLength: uint32,
  length: uint32,
  origChecksum: uint32
});
var $c1726355ecc5b889$var$WOFFDirectory = new Struct({
  tag: new StringT(4),
  flavor: uint32,
  length: uint32,
  numTables: uint16,
  reserved: new Reserved(uint16),
  totalSfntSize: uint32,
  majorVersion: uint16,
  minorVersion: uint16,
  metaOffset: uint32,
  metaLength: uint32,
  metaOrigLength: uint32,
  privOffset: uint32,
  privLength: uint32,
  tables: new ArrayT($c1726355ecc5b889$var$WOFFDirectoryEntry, "numTables")
});
$c1726355ecc5b889$var$WOFFDirectory.process = function() {
  let tables1 = {};
  for (let table of this.tables)
    tables1[table.tag] = table;
  this.tables = tables1;
};
var $c1726355ecc5b889$export$2e2bcd8739ae039 = $c1726355ecc5b889$var$WOFFDirectory;
var $760785214b9fc52c$export$2e2bcd8739ae039 = class extends (0, $4c1709dee528ea76$export$2e2bcd8739ae039) {
  static probe(buffer3) {
    return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer3.slice(0, 4)) === "wOFF";
  }
  _decodeDirectory() {
    this.directory = (0, $c1726355ecc5b889$export$2e2bcd8739ae039).decode(this.stream, {
      _startOffset: 0
    });
  }
  _getTableStream(tag) {
    let table = this.directory.tables[tag];
    if (table) {
      this.stream.pos = table.offset;
      if (table.compLength < table.length) {
        this.stream.pos += 2;
        let outBuffer = new Uint8Array(table.length);
        let buf = (0, import_tiny_inflate.default)(this.stream.readBuffer(table.compLength - 2), outBuffer);
        return new DecodeStream(buf);
      } else
        return this.stream;
    }
    return null;
  }
  constructor(...args) {
    super(...args);
    (0, _defineProperty)(this, "type", "WOFF");
  }
};
var $8046190c9f1ad19e$export$2e2bcd8739ae039 = class extends (0, $69aac16029968692$export$2e2bcd8739ae039) {
  _decode() {
    return this._font._transformedGlyphs[this.id];
  }
  _getCBox() {
    return this.path.bbox;
  }
  constructor(...args) {
    super(...args);
    (0, _defineProperty)(this, "type", "WOFF2");
  }
};
var $c28ec7bbb3b8de3a$var$Base128 = {
  decode(stream2) {
    let result = 0;
    let iterable = [
      0,
      1,
      2,
      3,
      4
    ];
    for (let j = 0; j < iterable.length; j++) {
      let i = iterable[j];
      let code3 = stream2.readUInt8();
      if (result & 3758096384)
        throw new Error("Overflow");
      result = result << 7 | code3 & 127;
      if ((code3 & 128) === 0)
        return result;
    }
    throw new Error("Bad base 128 number");
  }
};
var $c28ec7bbb3b8de3a$var$knownTags = [
  "cmap",
  "head",
  "hhea",
  "hmtx",
  "maxp",
  "name",
  "OS/2",
  "post",
  "cvt ",
  "fpgm",
  "glyf",
  "loca",
  "prep",
  "CFF ",
  "VORG",
  "EBDT",
  "EBLC",
  "gasp",
  "hdmx",
  "kern",
  "LTSH",
  "PCLT",
  "VDMX",
  "vhea",
  "vmtx",
  "BASE",
  "GDEF",
  "GPOS",
  "GSUB",
  "EBSC",
  "JSTF",
  "MATH",
  "CBDT",
  "CBLC",
  "COLR",
  "CPAL",
  "SVG ",
  "sbix",
  "acnt",
  "avar",
  "bdat",
  "bloc",
  "bsln",
  "cvar",
  "fdsc",
  "feat",
  "fmtx",
  "fvar",
  "gvar",
  "hsty",
  "just",
  "lcar",
  "mort",
  "morx",
  "opbd",
  "prop",
  "trak",
  "Zapf",
  "Silf",
  "Glat",
  "Gloc",
  "Feat",
  "Sill"
];
var $c28ec7bbb3b8de3a$var$WOFF2DirectoryEntry = new Struct({
  flags: uint8,
  customTag: new Optional(new StringT(4), (t2) => (t2.flags & 63) === 63),
  tag: (t2) => t2.customTag || $c28ec7bbb3b8de3a$var$knownTags[t2.flags & 63],
  length: $c28ec7bbb3b8de3a$var$Base128,
  transformVersion: (t2) => t2.flags >>> 6 & 3,
  transformed: (t2) => t2.tag === "glyf" || t2.tag === "loca" ? t2.transformVersion === 0 : t2.transformVersion !== 0,
  transformLength: new Optional($c28ec7bbb3b8de3a$var$Base128, (t2) => t2.transformed)
});
var $c28ec7bbb3b8de3a$var$WOFF2Directory = new Struct({
  tag: new StringT(4),
  flavor: uint32,
  length: uint32,
  numTables: uint16,
  reserved: new Reserved(uint16),
  totalSfntSize: uint32,
  totalCompressedSize: uint32,
  majorVersion: uint16,
  minorVersion: uint16,
  metaOffset: uint32,
  metaLength: uint32,
  metaOrigLength: uint32,
  privOffset: uint32,
  privLength: uint32,
  tables: new ArrayT($c28ec7bbb3b8de3a$var$WOFF2DirectoryEntry, "numTables")
});
$c28ec7bbb3b8de3a$var$WOFF2Directory.process = function() {
  let tables = {};
  for (let i = 0; i < this.tables.length; i++) {
    let table = this.tables[i];
    tables[table.tag] = table;
  }
  return this.tables = tables;
};
var $c28ec7bbb3b8de3a$export$2e2bcd8739ae039 = $c28ec7bbb3b8de3a$var$WOFF2Directory;
var $21ee218f84ac7f32$export$2e2bcd8739ae039 = class extends (0, $4c1709dee528ea76$export$2e2bcd8739ae039) {
  static probe(buffer3) {
    return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer3.slice(0, 4)) === "wOF2";
  }
  _decodeDirectory() {
    this.directory = (0, $c28ec7bbb3b8de3a$export$2e2bcd8739ae039).decode(this.stream);
    this._dataPos = this.stream.pos;
  }
  _decompress() {
    if (!this._decompressed) {
      this.stream.pos = this._dataPos;
      let buffer3 = this.stream.readBuffer(this.directory.totalCompressedSize);
      let decompressedSize = 0;
      for (let tag in this.directory.tables) {
        let entry = this.directory.tables[tag];
        entry.offset = decompressedSize;
        decompressedSize += entry.transformLength != null ? entry.transformLength : entry.length;
      }
      let decompressed = (0, import_decompress.default)(buffer3, decompressedSize);
      if (!decompressed)
        throw new Error("Error decoding compressed data in WOFF2");
      this.stream = new DecodeStream(decompressed);
      this._decompressed = true;
    }
  }
  _decodeTable(table) {
    this._decompress();
    return super._decodeTable(table);
  }
  // Override this method to get a glyph and return our
  // custom subclass if there is a glyf table.
  _getBaseGlyph(glyph, characters2 = []) {
    if (!this._glyphs[glyph]) {
      if (this.directory.tables.glyf && this.directory.tables.glyf.transformed) {
        if (!this._transformedGlyphs)
          this._transformGlyfTable();
        return this._glyphs[glyph] = new (0, $8046190c9f1ad19e$export$2e2bcd8739ae039)(glyph, characters2, this);
      } else
        return super._getBaseGlyph(glyph, characters2);
    }
  }
  _transformGlyfTable() {
    this._decompress();
    this.stream.pos = this.directory.tables.glyf.offset;
    let table = $21ee218f84ac7f32$var$GlyfTable.decode(this.stream);
    let glyphs = [];
    for (let index3 = 0; index3 < table.numGlyphs; index3++) {
      let glyph = {};
      let nContours = table.nContours.readInt16BE();
      glyph.numberOfContours = nContours;
      if (nContours > 0) {
        let nPoints = [];
        let totalPoints = 0;
        for (let i = 0; i < nContours; i++) {
          let r1 = $21ee218f84ac7f32$var$read255UInt16(table.nPoints);
          totalPoints += r1;
          nPoints.push(totalPoints);
        }
        glyph.points = $21ee218f84ac7f32$var$decodeTriplet(table.flags, table.glyphs, totalPoints);
        for (let i1 = 0; i1 < nContours; i1++)
          glyph.points[nPoints[i1] - 1].endContour = true;
        var instructionSize = $21ee218f84ac7f32$var$read255UInt16(table.glyphs);
      } else if (nContours < 0) {
        let haveInstructions = (0, $69aac16029968692$export$2e2bcd8739ae039).prototype._decodeComposite.call({
          _font: this
        }, glyph, table.composites);
        if (haveInstructions)
          var instructionSize = $21ee218f84ac7f32$var$read255UInt16(table.glyphs);
      }
      glyphs.push(glyph);
    }
    this._transformedGlyphs = glyphs;
  }
  constructor(...args) {
    super(...args);
    (0, _defineProperty)(this, "type", "WOFF2");
  }
};
var $21ee218f84ac7f32$var$Substream = class {
  decode(stream2, parent) {
    return new DecodeStream(this._buf.decode(stream2, parent));
  }
  constructor(length4) {
    this.length = length4;
    this._buf = new BufferT(length4);
  }
};
var $21ee218f84ac7f32$var$GlyfTable = new Struct({
  version: uint32,
  numGlyphs: uint16,
  indexFormat: uint16,
  nContourStreamSize: uint32,
  nPointsStreamSize: uint32,
  flagStreamSize: uint32,
  glyphStreamSize: uint32,
  compositeStreamSize: uint32,
  bboxStreamSize: uint32,
  instructionStreamSize: uint32,
  nContours: new $21ee218f84ac7f32$var$Substream("nContourStreamSize"),
  nPoints: new $21ee218f84ac7f32$var$Substream("nPointsStreamSize"),
  flags: new $21ee218f84ac7f32$var$Substream("flagStreamSize"),
  glyphs: new $21ee218f84ac7f32$var$Substream("glyphStreamSize"),
  composites: new $21ee218f84ac7f32$var$Substream("compositeStreamSize"),
  bboxes: new $21ee218f84ac7f32$var$Substream("bboxStreamSize"),
  instructions: new $21ee218f84ac7f32$var$Substream("instructionStreamSize")
});
var $21ee218f84ac7f32$var$WORD_CODE = 253;
var $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE2 = 254;
var $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE1 = 255;
var $21ee218f84ac7f32$var$LOWEST_U_CODE = 253;
function $21ee218f84ac7f32$var$read255UInt16(stream2) {
  let code3 = stream2.readUInt8();
  if (code3 === $21ee218f84ac7f32$var$WORD_CODE)
    return stream2.readUInt16BE();
  if (code3 === $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE1)
    return stream2.readUInt8() + $21ee218f84ac7f32$var$LOWEST_U_CODE;
  if (code3 === $21ee218f84ac7f32$var$ONE_MORE_BYTE_CODE2)
    return stream2.readUInt8() + $21ee218f84ac7f32$var$LOWEST_U_CODE * 2;
  return code3;
}
function $21ee218f84ac7f32$var$withSign(flag, baseval) {
  return flag & 1 ? baseval : -baseval;
}
function $21ee218f84ac7f32$var$decodeTriplet(flags, glyphs, nPoints) {
  let y;
  let x = y = 0;
  let res = [];
  for (let i = 0; i < nPoints; i++) {
    let dx = 0, dy = 0;
    let flag = flags.readUInt8();
    let onCurve = !(flag >> 7);
    flag &= 127;
    if (flag < 10) {
      dx = 0;
      dy = $21ee218f84ac7f32$var$withSign(flag, ((flag & 14) << 7) + glyphs.readUInt8());
    } else if (flag < 20) {
      dx = $21ee218f84ac7f32$var$withSign(flag, ((flag - 10 & 14) << 7) + glyphs.readUInt8());
      dy = 0;
    } else if (flag < 84) {
      var b0 = flag - 20;
      var b1 = glyphs.readUInt8();
      dx = $21ee218f84ac7f32$var$withSign(flag, 1 + (b0 & 48) + (b1 >> 4));
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, 1 + ((b0 & 12) << 2) + (b1 & 15));
    } else if (flag < 120) {
      var b0 = flag - 84;
      dx = $21ee218f84ac7f32$var$withSign(flag, 1 + (b0 / 12 << 8) + glyphs.readUInt8());
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, 1 + (b0 % 12 >> 2 << 8) + glyphs.readUInt8());
    } else if (flag < 124) {
      var b1 = glyphs.readUInt8();
      let b2 = glyphs.readUInt8();
      dx = $21ee218f84ac7f32$var$withSign(flag, (b1 << 4) + (b2 >> 4));
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, ((b2 & 15) << 8) + glyphs.readUInt8());
    } else {
      dx = $21ee218f84ac7f32$var$withSign(flag, glyphs.readUInt16BE());
      dy = $21ee218f84ac7f32$var$withSign(flag >> 1, glyphs.readUInt16BE());
    }
    x += dx;
    y += dy;
    res.push(new (0, $69aac16029968692$export$baf26146a414f24a)(onCurve, false, x, y));
  }
  return res;
}
var $cd5853a56c68fec7$var$TTCHeader = new VersionedStruct(uint32, {
  65536: {
    numFonts: uint32,
    offsets: new ArrayT(uint32, "numFonts")
  },
  131072: {
    numFonts: uint32,
    offsets: new ArrayT(uint32, "numFonts"),
    dsigTag: uint32,
    dsigLength: uint32,
    dsigOffset: uint32
  }
});
var $cd5853a56c68fec7$export$2e2bcd8739ae039 = class {
  static probe(buffer3) {
    return (0, $12727730ddfc8bfe$export$3d28c1996ced1f14).decode(buffer3.slice(0, 4)) === "ttcf";
  }
  getFont(name) {
    for (let offset3 of this.header.offsets) {
      let stream2 = new DecodeStream(this.stream.buffer);
      stream2.pos = offset3;
      let font2 = new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2);
      if (font2.postscriptName === name || font2.postscriptName instanceof Uint8Array && name instanceof Uint8Array && font2.postscriptName.every((v2, i) => name[i] === v2))
        return font2;
    }
    return null;
  }
  get fonts() {
    let fonts = [];
    for (let offset3 of this.header.offsets) {
      let stream2 = new DecodeStream(this.stream.buffer);
      stream2.pos = offset3;
      fonts.push(new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2));
    }
    return fonts;
  }
  constructor(stream2) {
    (0, _defineProperty)(this, "type", "TTC");
    this.stream = stream2;
    if (stream2.readString(4) !== "ttcf")
      throw new Error("Not a TrueType collection");
    this.header = $cd5853a56c68fec7$var$TTCHeader.decode(stream2);
  }
};
var $05f49f930186144e$var$DFontName = new StringT(uint8);
var $05f49f930186144e$var$DFontData = new Struct({
  len: uint32,
  buf: new BufferT("len")
});
var $05f49f930186144e$var$Ref = new Struct({
  id: uint16,
  nameOffset: int16,
  attr: uint8,
  dataOffset: uint24,
  handle: uint32
});
var $05f49f930186144e$var$Type = new Struct({
  name: new StringT(4),
  maxTypeIndex: uint16,
  refList: new Pointer(uint16, new ArrayT($05f49f930186144e$var$Ref, (t2) => t2.maxTypeIndex + 1), {
    type: "parent"
  })
});
var $05f49f930186144e$var$TypeList = new Struct({
  length: uint16,
  types: new ArrayT($05f49f930186144e$var$Type, (t2) => t2.length + 1)
});
var $05f49f930186144e$var$DFontMap = new Struct({
  reserved: new Reserved(uint8, 24),
  typeList: new Pointer(uint16, $05f49f930186144e$var$TypeList),
  nameListOffset: new Pointer(uint16, "void")
});
var $05f49f930186144e$var$DFontHeader = new Struct({
  dataOffset: uint32,
  map: new Pointer(uint32, $05f49f930186144e$var$DFontMap),
  dataLength: uint32,
  mapLength: uint32
});
var $05f49f930186144e$export$2e2bcd8739ae039 = class {
  static probe(buffer3) {
    let stream2 = new DecodeStream(buffer3);
    try {
      var header = $05f49f930186144e$var$DFontHeader.decode(stream2);
    } catch (e) {
      return false;
    }
    for (let type of header.map.typeList.types) {
      if (type.name === "sfnt")
        return true;
    }
    return false;
  }
  getFont(name) {
    if (!this.sfnt)
      return null;
    for (let ref of this.sfnt.refList) {
      let pos = this.header.dataOffset + ref.dataOffset + 4;
      let stream2 = new DecodeStream(this.stream.buffer.slice(pos));
      let font2 = new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2);
      if (font2.postscriptName === name || font2.postscriptName instanceof Uint8Array && name instanceof Uint8Array && font2.postscriptName.every((v2, i) => name[i] === v2))
        return font2;
    }
    return null;
  }
  get fonts() {
    let fonts = [];
    for (let ref of this.sfnt.refList) {
      let pos = this.header.dataOffset + ref.dataOffset + 4;
      let stream2 = new DecodeStream(this.stream.buffer.slice(pos));
      fonts.push(new (0, $4c1709dee528ea76$export$2e2bcd8739ae039)(stream2));
    }
    return fonts;
  }
  constructor(stream2) {
    (0, _defineProperty)(this, "type", "DFont");
    this.stream = stream2;
    this.header = $05f49f930186144e$var$DFontHeader.decode(this.stream);
    for (let type of this.header.map.typeList.types) {
      for (let ref of type.refList)
        if (ref.nameOffset >= 0) {
          this.stream.pos = ref.nameOffset + this.header.map.nameListOffset;
          ref.name = $05f49f930186144e$var$DFontName.decode(this.stream);
        } else
          ref.name = null;
      if (type.name === "sfnt")
        this.sfnt = type;
    }
  }
};
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $4c1709dee528ea76$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $760785214b9fc52c$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $21ee218f84ac7f32$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $cd5853a56c68fec7$export$2e2bcd8739ae039));
(0, $d636bc798e7178db$export$36b2f24e97d43be)((0, $05f49f930186144e$export$2e2bcd8739ae039));

// ../node_modules/@react-pdf/font/lib/index.browser.es.js
var _excluded = ["src", "fontWeight", "fontStyle"];
var FONT_WEIGHTS = {
  thin: 100,
  hairline: 100,
  ultralight: 200,
  extralight: 200,
  light: 300,
  normal: 400,
  medium: 500,
  semibold: 600,
  demibold: 600,
  bold: 700,
  ultrabold: 800,
  extrabold: 800,
  heavy: 900,
  black: 900
};
var fetchFont = function() {
  var _ref = _asyncToGenerator2(_regeneratorRuntime2().mark(function _callee(src3, options) {
    var response, data2;
    return _regeneratorRuntime2().wrap(function _callee$(_context) {
      while (1)
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return (0, import_cross_fetch.default)(src3, options);
          case 2:
            response = _context.sent;
            _context.next = 5;
            return response.arrayBuffer();
          case 5:
            data2 = _context.sent;
            return _context.abrupt("return", new Uint8Array(data2));
          case 7:
          case "end":
            return _context.stop();
        }
    }, _callee);
  }));
  return function fetchFont2(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
var isDataUrl = function isDataUrl2(dataUrl) {
  var header = dataUrl.split(",")[0];
  var hasDataPrefix = header.substring(0, 5) === "data:";
  var hasBase64Prefix = header.split(";")[1] === "base64";
  return hasDataPrefix && hasBase64Prefix;
};
var resolveFontWeight = function resolveFontWeight2(value2) {
  return typeof value2 === "string" ? FONT_WEIGHTS[value2] : value2;
};
var sortByFontWeight = function sortByFontWeight2(a2, b) {
  return a2.fontWeight - b.fontWeight;
};
var FontSource = function() {
  function FontSource2(src3, fontFamily, fontStyle, fontWeight, options) {
    this.src = src3;
    this.fontFamily = fontFamily;
    this.fontStyle = fontStyle || "normal";
    this.fontWeight = fontWeight || 400;
    this.data = null;
    this.options = options;
    this.loadResultPromise = null;
  }
  var _proto = FontSource2.prototype;
  _proto._load = function() {
    var _load2 = _asyncToGenerator2(_regeneratorRuntime2().mark(function _callee2() {
      var postscriptName, raw, uint8Array, _this$options, headers, body, _this$options$method, method, data2;
      return _regeneratorRuntime2().wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              postscriptName = this.options.postscriptName;
              if (!isDataUrl(this.src)) {
                _context2.next = 7;
                break;
              }
              raw = this.src.split(",")[1];
              uint8Array = new Uint8Array(atob(raw).split("").map(function(c2) {
                return c2.charCodeAt(0);
              }));
              this.data = $d636bc798e7178db$export$185802fd694ee1f5(uint8Array, postscriptName);
              _context2.next = 19;
              break;
            case 7:
              _this$options = this.options, headers = _this$options.headers, body = _this$options.body, _this$options$method = _this$options.method, method = _this$options$method === void 0 ? "GET" : _this$options$method;
              _context2.next = 11;
              return fetchFont(this.src, {
                method,
                body,
                headers
              });
            case 11:
              data2 = _context2.sent;
              this.data = $d636bc798e7178db$export$185802fd694ee1f5(data2, postscriptName);
              _context2.next = 19;
              break;
            case 15: {
              _context2.next = 19;
              break;
            }
            case 18:
              this.data = _context2.sent;
            case 19:
            case "end":
              return _context2.stop();
          }
      }, _callee2, this);
    }));
    function _load() {
      return _load2.apply(this, arguments);
    }
    return _load;
  }();
  _proto.load = function() {
    var _load3 = _asyncToGenerator2(_regeneratorRuntime2().mark(function _callee3() {
      return _regeneratorRuntime2().wrap(function _callee3$(_context3) {
        while (1)
          switch (_context3.prev = _context3.next) {
            case 0:
              if (this.loadResultPromise === null) {
                this.loadResultPromise = this._load();
              }
              return _context3.abrupt("return", this.loadResultPromise);
            case 2:
            case "end":
              return _context3.stop();
          }
      }, _callee3, this);
    }));
    function load() {
      return _load3.apply(this, arguments);
    }
    return load;
  }();
  return FontSource2;
}();
var Font = function() {
  Font3.create = function create2(family) {
    return new Font3(family);
  };
  function Font3(family) {
    this.family = family;
    this.sources = [];
  }
  var _proto2 = Font3.prototype;
  _proto2.register = function register(_ref2) {
    var src3 = _ref2.src, fontWeight = _ref2.fontWeight, fontStyle = _ref2.fontStyle, options = _objectWithoutPropertiesLoose(_ref2, _excluded);
    var numericFontWeight = resolveFontWeight(fontWeight);
    this.sources.push(new FontSource(src3, this.family, fontStyle, numericFontWeight, options));
  };
  _proto2.resolve = function resolve3(descriptor) {
    var _descriptor$fontWeigh = descriptor.fontWeight, fontWeight = _descriptor$fontWeigh === void 0 ? 400 : _descriptor$fontWeigh, _descriptor$fontStyle = descriptor.fontStyle, fontStyle = _descriptor$fontStyle === void 0 ? "normal" : _descriptor$fontStyle;
    var styleSources = this.sources.filter(function(s2) {
      return s2.fontStyle === fontStyle;
    });
    var exactFit = styleSources.find(function(s2) {
      return s2.fontWeight === fontWeight;
    });
    if (exactFit)
      return exactFit;
    var res;
    if (fontWeight >= 400 && fontWeight <= 500) {
      var leftOffset = styleSources.filter(function(s2) {
        return s2.fontWeight <= fontWeight;
      });
      var rightOffset = styleSources.filter(function(s2) {
        return s2.fontWeight > 500;
      });
      var fit = styleSources.filter(function(s2) {
        return s2.fontWeight >= fontWeight && s2.fontWeight < 500;
      });
      res = fit[0] || leftOffset[leftOffset.length - 1] || rightOffset[0];
    }
    var lt = styleSources.filter(function(s2) {
      return s2.fontWeight < fontWeight;
    }).sort(sortByFontWeight);
    var gt = styleSources.filter(function(s2) {
      return s2.fontWeight > fontWeight;
    }).sort(sortByFontWeight);
    if (fontWeight < 400) {
      res = lt[lt.length - 1] || gt[0];
    }
    if (fontWeight > 500) {
      res = gt[0] || lt[lt.length - 1];
    }
    if (!res) {
      throw new Error("Could not resolve font for " + this.family + ", fontWeight " + fontWeight);
    }
    return res;
  };
  return Font3;
}();
var standard = ["Courier", "Courier-Bold", "Courier-Oblique", "Courier-BoldOblique", "Helvetica", "Helvetica-Bold", "Helvetica-Oblique", "Helvetica-BoldOblique", "Times-Roman", "Times-Bold", "Times-Italic", "Times-BoldItalic"];
function FontStore() {
  var _this = this;
  var fonts = {};
  var emojiSource = null;
  var hyphenationCallback = null;
  this.register = function(data2) {
    var family = data2.family;
    if (!fonts[family]) {
      fonts[family] = Font.create(family);
    }
    if (data2.fonts) {
      for (var i = 0; i < data2.fonts.length; i += 1) {
        fonts[family].register(_extends2({
          family
        }, data2.fonts[i]));
      }
    } else {
      fonts[family].register(data2);
    }
  };
  this.registerEmojiSource = function(_ref) {
    var url = _ref.url, _ref$format = _ref.format, format = _ref$format === void 0 ? "png" : _ref$format, builder = _ref.builder;
    emojiSource = {
      url,
      format,
      builder
    };
  };
  this.registerHyphenationCallback = function(callback) {
    hyphenationCallback = callback;
  };
  this.getFont = function(descriptor) {
    var fontFamily = descriptor.fontFamily;
    var isStandard = standard.includes(fontFamily);
    if (isStandard)
      return null;
    if (!fonts[fontFamily]) {
      throw new Error("Font family not registered: " + fontFamily + ". Please register it calling Font.register() method.");
    }
    return fonts[fontFamily].resolve(descriptor);
  };
  this.load = function() {
    var _ref2 = _asyncToGenerator2(_regeneratorRuntime2().mark(function _callee(descriptor) {
      var fontFamily, isStandard, f;
      return _regeneratorRuntime2().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              fontFamily = descriptor.fontFamily;
              isStandard = standard.includes(fontFamily);
              if (!isStandard) {
                _context.next = 4;
                break;
              }
              return _context.abrupt("return");
            case 4:
              f = _this.getFont(descriptor);
              _context.next = 7;
              return f.load();
            case 7:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function(_x) {
      return _ref2.apply(this, arguments);
    };
  }();
  this.reset = function() {
    var keys5 = Object.keys(fonts);
    for (var i = 0; i < keys5.length; i += 1) {
      var key = keys5[i];
      fonts[key].data = null;
    }
  };
  this.clear = function() {
    fonts = {};
  };
  this.getRegisteredFonts = function() {
    return fonts;
  };
  this.getEmojiSource = function() {
    return emojiSource;
  };
  this.getHyphenationCallback = function() {
    return hyphenationCallback;
  };
  this.getRegisteredFontFamilies = function() {
    return Object.keys(fonts);
  };
}

// ../node_modules/@react-pdf/fns/node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof3(obj) {
  "@babel/helpers - typeof";
  return _typeof3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof3(obj);
}

// ../node_modules/@react-pdf/fns/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js
function _regeneratorRuntime3() {
  "use strict";
  _regeneratorRuntime3 = function _regeneratorRuntime6() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn3 = Op.hasOwnProperty, defineProperty5 = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define4(obj, key, value2) {
    return Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define4({}, "");
  } catch (err2) {
    define4 = function define5(obj, key, value2) {
      return obj[key] = value2;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty5(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err2) {
      return {
        type: "throw",
        arg: err2
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction3() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define4(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto3 = Object.getPrototypeOf, NativeIteratorPrototype = getProto3 && getProto3(getProto3(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn3.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define4(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve3, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value2 = result.value;
        return value2 && "object" == _typeof3(value2) && hasOwn3.call(value2, "__await") ? PromiseImpl.resolve(value2.__await).then(function(value3) {
          invoke("next", value3, resolve3, reject);
        }, function(err2) {
          invoke("throw", err2, resolve3, reject);
        }) : PromiseImpl.resolve(value2).then(function(unwrapped) {
          result.value = unwrapped, resolve3(result);
        }, function(error) {
          return invoke("throw", error, resolve3, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty5(this, "_invoke", {
      value: function value2(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve3, reject) {
            invoke(method, arg, resolve3, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state2 = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state2)
        throw new Error("Generator is already running");
      if ("completed" === state2) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state2)
            throw state2 = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state2 = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state2 = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state2 = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next2 = function next3() {
          for (; ++i < iterable.length; )
            if (hasOwn3.call(iterable, i))
              return next3.value = iterable[i], next3.done = false, next3;
          return next3.value = void 0, next3.done = true, next3;
        };
        return next2.next = next2;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction3.prototype = GeneratorFunctionPrototype, defineProperty5(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty5(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction3,
    configurable: true
  }), GeneratorFunction3.displayName = define4(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction3 || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define4(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define4(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define4(Gp, toStringTagSymbol, "Generator"), define4(Gp, iteratorSymbol, function() {
    return this;
  }), define4(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys5 = [];
    for (var key in object)
      keys5.push(key);
    return keys5.reverse(), function next2() {
      for (; keys5.length; ) {
        var key2 = keys5.pop();
        if (key2 in object)
          return next2.value = key2, next2.done = false, next2;
      }
      return next2.done = true, next2;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn3.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function stop() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn3.call(entry, "catchLoc"), hasFinally = hasOwn3.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn3.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}

// ../node_modules/@react-pdf/fns/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep3(gen, resolve3, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value2 = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve3(value2);
  } else {
    Promise.resolve(value2).then(_next, _throw);
  }
}
function _asyncToGenerator3(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve3, reject) {
      var gen = fn.apply(self2, args);
      function _next(value2) {
        asyncGeneratorStep3(gen, resolve3, reject, _next, _throw, "next", value2);
      }
      function _throw(err2) {
        asyncGeneratorStep3(gen, resolve3, reject, _next, _throw, "throw", err2);
      }
      _next(void 0);
    });
  };
}

// ../node_modules/@react-pdf/fns/lib/index.es.js
var adjust = function adjust2(index3, fn, collection) {
  var _Object$assign;
  if (index3 >= 0 && index3 >= collection.length)
    return collection;
  if (index3 < 0 && Math.abs(index3) > collection.length)
    return collection;
  var i = index3 < 0 ? collection.length + index3 : index3;
  return Object.assign([], collection, (_Object$assign = {}, _Object$assign[i] = fn(collection[i]), _Object$assign));
};
var reverse = function reverse2(list) {
  return Array.prototype.slice.call(list, 0).reverse();
};
var asyncCompose = function asyncCompose2() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }
  return function() {
    var _ref = _asyncToGenerator3(_regeneratorRuntime3().mark(function _callee(value2) {
      var result, reversedFns, _len2, args, _key2, i, fn, _args = arguments;
      return _regeneratorRuntime3().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              result = value2;
              reversedFns = reverse(fns);
              for (_len2 = _args.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = _args[_key2];
              }
              i = 0;
            case 4:
              if (!(i < reversedFns.length)) {
                _context.next = 12;
                break;
              }
              fn = reversedFns[i];
              _context.next = 8;
              return fn.apply(void 0, [result].concat(args));
            case 8:
              result = _context.sent;
            case 9:
              i += 1;
              _context.next = 4;
              break;
            case 12:
              return _context.abrupt("return", result);
            case 13:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function(_x) {
      return _ref.apply(this, arguments);
    };
  }();
};
var capitalize = function capitalize2(value2) {
  if (!value2)
    return value2;
  return value2.replace(/(^|\s)\S/g, function(l2) {
    return l2.toUpperCase();
  });
};
var castArray = function castArray2(value2) {
  return Array.isArray(value2) ? value2 : [value2];
};
var compose = function compose2() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }
  return function(value2) {
    var result = value2;
    var reversedFns = reverse(fns);
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    for (var i = 0; i < reversedFns.length; i += 1) {
      var fn = reversedFns[i];
      result = fn.apply(void 0, [result].concat(args));
    }
    return result;
  };
};
var dropLast = function dropLast2(array) {
  return array.slice(0, array.length - 1);
};
var evolve = function evolve2(transformations, object) {
  var result = object instanceof Array ? [] : {};
  var keys5 = Object.keys(object);
  for (var i = 0; i < keys5.length; i += 1) {
    var key = keys5[i];
    var transformation = transformations[key];
    var type = typeof transformation;
    if (type === "function") {
      result[key] = transformation(object[key]);
    } else if (transformation && type === "object") {
      result[key] = evolve2(transformation, object[key]);
    } else
      result[key] = object[key];
  }
  return result;
};
var isNil = function isNil2(value2) {
  return value2 === null || value2 === void 0;
};
var get = function get2(target, path2, defaultValue) {
  if (isNil(target))
    return defaultValue;
  var _path = castArray(path2);
  var result = target;
  for (var i = 0; i < _path.length; i += 1) {
    if (isNil(result))
      return void 0;
    result = result[_path[i]];
  }
  return isNil(result) ? defaultValue : result;
};
var last = function last2(value2) {
  return value2 === "" ? "" : value2[value2.length - 1];
};
var mapValues = function mapValues2(object, fn) {
  var entries = Object.entries(object);
  return entries.reduce(function(acc, _ref, index3) {
    var key = _ref[0], value2 = _ref[1];
    acc[key] = fn(value2, key, index3);
    return acc;
  }, {});
};
var isPercent = function isPercent2(value2) {
  return /((-)?\d+\.?\d*)%/g.exec(value2);
};
var matchPercent = function matchPercent2(value2) {
  var match = isPercent(value2);
  if (match) {
    var f = parseFloat(match[1], 10);
    var percent = f / 100;
    return {
      percent,
      value: f
    };
  }
  return null;
};
var omit = function omit2(keys5, object) {
  var _keys = castArray(keys5);
  var copy6 = Object.assign({}, object);
  _keys.forEach(function(key) {
    delete copy6[key];
  });
  return copy6;
};
var pick = function pick2(keys5, obj) {
  var result = {};
  for (var i = 0; i < keys5.length; i += 1) {
    var key = keys5[i];
    if (key in obj)
      result[key] = obj[key];
  }
  return result;
};
var upperFirst = function upperFirst2(value2) {
  if (!value2)
    return value2;
  return value2.charAt(0).toUpperCase() + value2.slice(1);
};

// ../node_modules/@react-pdf/render/lib/index.es.js
var import_abs_svg_path = __toESM(require_abs_svg_path());
var import_parse_svg_path = __toESM(require_parse_svg_path());

// ../node_modules/svg-arc-to-cubic-bezier/modules/index.js
var _slicedToArray = function() {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err2) {
      _d = true;
      _e = err2;
    } finally {
      try {
        if (!_n && _i["return"])
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  return function(arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
var TAU = Math.PI * 2;
var mapToEllipse = function mapToEllipse2(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
  var x = _ref.x, y = _ref.y;
  x *= rx;
  y *= ry;
  var xp = cosphi * x - sinphi * y;
  var yp = sinphi * x + cosphi * y;
  return {
    x: xp + centerx,
    y: yp + centery
  };
};
var approxUnitArc = function approxUnitArc2(ang1, ang2) {
  var a2 = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  var x1 = Math.cos(ang1);
  var y1 = Math.sin(ang1);
  var x2 = Math.cos(ang1 + ang2);
  var y2 = Math.sin(ang1 + ang2);
  return [{
    x: x1 - y1 * a2,
    y: y1 + x1 * a2
  }, {
    x: x2 + y2 * a2,
    y: y2 - x2 * a2
  }, {
    x: x2,
    y: y2
  }];
};
var vectorAngle = function vectorAngle2(ux, uy, vx, vy) {
  var sign = ux * vy - uy * vx < 0 ? -1 : 1;
  var dot = ux * vx + uy * vy;
  if (dot > 1) {
    dot = 1;
  }
  if (dot < -1) {
    dot = -1;
  }
  return sign * Math.acos(dot);
};
var getArcCenter = function getArcCenter2(px2, py2, cx2, cy2, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
  var rxsq = Math.pow(rx, 2);
  var rysq = Math.pow(ry, 2);
  var pxpsq = Math.pow(pxp, 2);
  var pypsq = Math.pow(pyp, 2);
  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;
  if (radicant < 0) {
    radicant = 0;
  }
  radicant /= rxsq * pypsq + rysq * pxpsq;
  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
  var centerxp = radicant * rx / ry * pyp;
  var centeryp = radicant * -ry / rx * pxp;
  var centerx = cosphi * centerxp - sinphi * centeryp + (px2 + cx2) / 2;
  var centery = sinphi * centerxp + cosphi * centeryp + (py2 + cy2) / 2;
  var vx1 = (pxp - centerxp) / rx;
  var vy1 = (pyp - centeryp) / ry;
  var vx2 = (-pxp - centerxp) / rx;
  var vy2 = (-pyp - centeryp) / ry;
  var ang1 = vectorAngle(1, 0, vx1, vy1);
  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);
  if (sweepFlag === 0 && ang2 > 0) {
    ang2 -= TAU;
  }
  if (sweepFlag === 1 && ang2 < 0) {
    ang2 += TAU;
  }
  return [centerx, centery, ang1, ang2];
};
var arcToBezier = function arcToBezier2(_ref2) {
  var px2 = _ref2.px, py2 = _ref2.py, cx2 = _ref2.cx, cy2 = _ref2.cy, rx = _ref2.rx, ry = _ref2.ry, _ref2$xAxisRotation = _ref2.xAxisRotation, xAxisRotation = _ref2$xAxisRotation === void 0 ? 0 : _ref2$xAxisRotation, _ref2$largeArcFlag = _ref2.largeArcFlag, largeArcFlag = _ref2$largeArcFlag === void 0 ? 0 : _ref2$largeArcFlag, _ref2$sweepFlag = _ref2.sweepFlag, sweepFlag = _ref2$sweepFlag === void 0 ? 0 : _ref2$sweepFlag;
  var curves = [];
  if (rx === 0 || ry === 0) {
    return [];
  }
  var sinphi = Math.sin(xAxisRotation * TAU / 360);
  var cosphi = Math.cos(xAxisRotation * TAU / 360);
  var pxp = cosphi * (px2 - cx2) / 2 + sinphi * (py2 - cy2) / 2;
  var pyp = -sinphi * (px2 - cx2) / 2 + cosphi * (py2 - cy2) / 2;
  if (pxp === 0 && pyp === 0) {
    return [];
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var _getArcCenter = getArcCenter(px2, py2, cx2, cy2, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp), _getArcCenter2 = _slicedToArray(_getArcCenter, 4), centerx = _getArcCenter2[0], centery = _getArcCenter2[1], ang1 = _getArcCenter2[2], ang2 = _getArcCenter2[3];
  var ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  var segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  for (var i = 0; i < segments; i++) {
    curves.push(approxUnitArc(ang1, ang2));
    ang1 += ang2;
  }
  return curves.map(function(curve) {
    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery), x1 = _mapToEllipse.x, y1 = _mapToEllipse.y;
    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery), x2 = _mapToEllipse2.x, y2 = _mapToEllipse2.y;
    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery), x = _mapToEllipse3.x, y = _mapToEllipse3.y;
    return { x1, y1, x2, y2, x, y };
  });
};
var modules_default = arcToBezier;

// ../node_modules/normalize-svg-path/index.mjs
function normalize(path2) {
  var prev;
  var result = [];
  var bezierX = 0;
  var bezierY = 0;
  var startX = 0;
  var startY = 0;
  var quadX = null;
  var quadY = null;
  var x = 0;
  var y = 0;
  for (var i = 0, len = path2.length; i < len; i++) {
    var seg = path2[i];
    var command = seg[0];
    switch (command) {
      case "M":
        startX = seg[1];
        startY = seg[2];
        break;
      case "A":
        var curves = modules_default({
          px: x,
          py: y,
          cx: seg[6],
          cy: seg[7],
          rx: seg[1],
          ry: seg[2],
          xAxisRotation: seg[3],
          largeArcFlag: seg[4],
          sweepFlag: seg[5]
        });
        if (!curves.length)
          continue;
        for (var j = 0, c2; j < curves.length; j++) {
          c2 = curves[j];
          seg = ["C", c2.x1, c2.y1, c2.x2, c2.y2, c2.x, c2.y];
          if (j < curves.length - 1)
            result.push(seg);
        }
        break;
      case "S":
        var cx2 = x;
        var cy2 = y;
        if (prev == "C" || prev == "S") {
          cx2 += cx2 - bezierX;
          cy2 += cy2 - bezierY;
        }
        seg = ["C", cx2, cy2, seg[1], seg[2], seg[3], seg[4]];
        break;
      case "T":
        if (prev == "Q" || prev == "T") {
          quadX = x * 2 - quadX;
          quadY = y * 2 - quadY;
        } else {
          quadX = x;
          quadY = y;
        }
        seg = quadratic(x, y, quadX, quadY, seg[1], seg[2]);
        break;
      case "Q":
        quadX = seg[1];
        quadY = seg[2];
        seg = quadratic(x, y, seg[1], seg[2], seg[3], seg[4]);
        break;
      case "L":
        seg = line(x, y, seg[1], seg[2]);
        break;
      case "H":
        seg = line(x, y, seg[1], y);
        break;
      case "V":
        seg = line(x, y, x, seg[1]);
        break;
      case "Z":
        seg = line(x, y, startX, startY);
        break;
    }
    prev = command;
    x = seg[seg.length - 2];
    y = seg[seg.length - 1];
    if (seg.length > 4) {
      bezierX = seg[seg.length - 4];
      bezierY = seg[seg.length - 3];
    } else {
      bezierX = x;
      bezierY = y;
    }
    result.push(seg);
  }
  return result;
}
function line(x1, y1, x2, y2) {
  return ["C", x1, y1, x2, y2, x2, y2];
}
function quadratic(x1, y1, cx2, cy2, x2, y2) {
  return [
    "C",
    x1 / 3 + 2 / 3 * cx2,
    y1 / 3 + 2 / 3 * cy2,
    x2 / 3 + 2 / 3 * cx2,
    y2 / 3 + 2 / 3 * cy2,
    x2,
    y2
  ];
}

// ../node_modules/@react-pdf/render/lib/index.es.js
var import_color_string = __toESM(require_color_string());

// ../node_modules/@react-pdf/render/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends3() {
  _extends3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}

// ../node_modules/@react-pdf/render/lib/index.es.js
var renderPath = function renderPath2(ctx, node) {
  var _node$props;
  var d = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.d;
  if (d)
    ctx.path(node.props.d);
};
var KAPPA$3 = 4 * ((Math.sqrt(2) - 1) / 3);
var renderRect = function renderRect2(ctx, node) {
  var _node$props, _node$props2, _node$props3, _node$props4, _node$props5, _node$props6;
  var x = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.x) || 0;
  var y = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.y) || 0;
  var rx = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.rx) || 0;
  var ry = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.ry) || 0;
  var width = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.width) || 0;
  var height5 = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.height) || 0;
  if (!width || !height5)
    return;
  if (rx && ry) {
    var krx = rx * KAPPA$3;
    var kry = ry * KAPPA$3;
    ctx.moveTo(x + rx, y);
    ctx.lineTo(x - rx + width, y);
    ctx.bezierCurveTo(x - rx + width + krx, y, x + width, y + ry - kry, x + width, y + ry);
    ctx.lineTo(x + width, y + height5 - ry);
    ctx.bezierCurveTo(x + width, y + height5 - ry + kry, x - rx + width + krx, y + height5, x - rx + width, y + height5);
    ctx.lineTo(x + rx, y + height5);
    ctx.bezierCurveTo(x + rx - krx, y + height5, x, y + height5 - ry + kry, x, y + height5 - ry);
    ctx.lineTo(x, y + ry);
    ctx.bezierCurveTo(x, y + ry - kry, x + rx - krx, y, x + rx, y);
  } else {
    ctx.moveTo(x, y);
    ctx.lineTo(x + width, y);
    ctx.lineTo(x + width, y + height5);
    ctx.lineTo(x, y + height5);
  }
  ctx.closePath();
};
var renderLine$1 = function renderLine(ctx, node) {
  var _ref = node.props || {}, x1 = _ref.x1, x2 = _ref.x2, y1 = _ref.y1, y2 = _ref.y2;
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
};
var renderGroup = function renderGroup2() {
};
var KAPPA$2 = 4 * ((Math.sqrt(2) - 1) / 3);
var drawEllipse = function drawEllipse2(ctx, cx2, cy2, rx, ry) {
  if (cx2 === void 0) {
    cx2 = 0;
  }
  if (cy2 === void 0) {
    cy2 = 0;
  }
  var x = cx2 - rx;
  var y = cy2 - ry;
  var ox = rx * KAPPA$2;
  var oy = ry * KAPPA$2;
  var xe = x + rx * 2;
  var ye = y + ry * 2;
  var xm = x + rx;
  var ym = y + ry;
  ctx.moveTo(x, ym);
  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
  ctx.closePath();
};
var renderEllipse = function renderEllipse2(ctx, node) {
  var _ref = node.props || {}, cx2 = _ref.cx, cy2 = _ref.cy, rx = _ref.rx, ry = _ref.ry;
  drawEllipse(ctx, cx2, cy2, rx, ry);
};
var renderCircle = function renderCircle2(ctx, node) {
  var _node$props, _node$props2, _node$props3;
  var cx2 = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.cx;
  var cy2 = (_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.cy;
  var r = (_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.r;
  drawEllipse(ctx, cx2, cy2, r, r);
};
var renderGlyphs = function renderGlyphs2(ctx, glyphs, positions, x, y, options) {
  if (options === void 0) {
    options = {};
  }
  var scale4 = 1e3 / ctx._fontSize;
  var unitsPerEm = ctx._font.font.unitsPerEm || 1e3;
  var advanceWidthScale = 1e3 / unitsPerEm;
  var encodedGlyphs = ctx._font.encodeGlyphs(glyphs);
  var encodedPositions = positions.map(function(pos, i) {
    return {
      xAdvance: pos.xAdvance * scale4,
      yAdvance: pos.yAdvance * scale4,
      xOffset: pos.xOffset,
      yOffset: pos.yOffset,
      advanceWidth: glyphs[i].advanceWidth * advanceWidthScale
    };
  });
  return ctx._glyphs(encodedGlyphs, encodedPositions, x, y, options);
};
var renderRun$1 = function renderRun(ctx, run) {
  var runAdvanceWidth = run.xAdvance;
  var _run$attributes = run.attributes, font2 = _run$attributes.font, fontSize2 = _run$attributes.fontSize, color = _run$attributes.color, opacity2 = _run$attributes.opacity;
  ctx.fillColor(color);
  ctx.fillOpacity(opacity2);
  if (font2.sbix || font2.COLR && font2.CPAL) {
    ctx.save();
    ctx.translate(0, -run.ascent);
    for (var i = 0; i < run.glyphs.length; i += 1) {
      var position = run.positions[i];
      var glyph = run.glyphs[i];
      ctx.save();
      ctx.translate(position.xOffset, position.yOffset);
      glyph.render(ctx, fontSize2);
      ctx.restore();
      ctx.translate(position.xAdvance, position.yAdvance);
    }
    ctx.restore();
  } else {
    ctx.font(typeof font2.name === "string" ? font2.name : font2, fontSize2);
    try {
      renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);
    } catch (error) {
      console.log(error);
    }
  }
  ctx.translate(runAdvanceWidth, 0);
};
var renderSpan = function renderSpan2(ctx, line2, textAnchor, dominantBaseline) {
  var _line$box, _line$box2, _line$runs$, _line$runs$2, _line$runs$2$attribut;
  ctx.save();
  var x = ((_line$box = line2.box) === null || _line$box === void 0 ? void 0 : _line$box.x) || 0;
  var y = ((_line$box2 = line2.box) === null || _line$box2 === void 0 ? void 0 : _line$box2.y) || 0;
  var font2 = (_line$runs$ = line2.runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes.font;
  var scale4 = ((_line$runs$2 = line2.runs[0]) === null || _line$runs$2 === void 0 ? void 0 : (_line$runs$2$attribut = _line$runs$2.attributes) === null || _line$runs$2$attribut === void 0 ? void 0 : _line$runs$2$attribut.scale) || 1;
  var width = line2.xAdvance;
  var ascent4 = font2.ascent * scale4;
  var xHeight = font2.xHeight * scale4;
  var descent3 = font2.descent * scale4;
  var capHeight = font2.capHeight * scale4;
  var xTranslate = x;
  var yTranslate = y;
  switch (textAnchor) {
    case "middle":
      xTranslate = x - width / 2;
      break;
    case "end":
      xTranslate = x - width;
      break;
    default:
      xTranslate = x;
      break;
  }
  switch (dominantBaseline) {
    case "middle":
    case "central":
      yTranslate = y + capHeight / 2;
      break;
    case "hanging":
      yTranslate = y + capHeight;
      break;
    case "mathematical":
      yTranslate = y + xHeight;
      break;
    case "text-after-edge":
      yTranslate = y + descent3;
      break;
    case "text-before-edge":
      yTranslate = y + ascent4;
      break;
    default:
      yTranslate = y;
      break;
  }
  ctx.translate(xTranslate, yTranslate);
  line2.runs.forEach(function(run) {
    return renderRun$1(ctx, run);
  });
  ctx.restore();
};
var renderSvgText = function renderSvgText2(ctx, node) {
  node.children.forEach(function(span) {
    return renderSpan(ctx, span.lines[0], span.props.textAnchor, span.props.dominantBaseline);
  });
};
var pairs = function pairs2(values) {
  var result = [];
  for (var i = 0; i < values.length; i += 2) {
    result.push([values[i], values[i + 1]]);
  }
  return result;
};
var parsePoints = function parsePoints2(points) {
  var values = (points || "").trim().replace(/,/g, " ").replace(/(\d)-(\d)/g, "$1 -$2").split(/\s+/);
  if (values.length % 2 !== 0) {
    values = values.slice(0, -1);
  }
  values = values.map(parseFloat);
  return pairs(values);
};
var drawPolyline = function drawPolyline2(ctx, points) {
  if (points.length > 0) {
    ctx.moveTo(points[0][0], points[0][1]);
    points.slice(1).forEach(function(p) {
      return ctx.lineTo(p[0], p[1]);
    });
  }
};
var renderPolyline = function renderPolyline2(ctx, node) {
  var points = parsePoints(node.props.points || "");
  drawPolyline(ctx, points);
};
var renderPolygon = function renderPolygon2(ctx, node) {
  renderPolyline(ctx, node);
  ctx.closePath();
};
var renderImage$1 = function renderImage(ctx, node) {
  if (!node.image.data)
    return;
  var _node$props = node.props, x = _node$props.x, y = _node$props.y;
  var _node$style = node.style, width = _node$style.width, height5 = _node$style.height, opacity2 = _node$style.opacity;
  var paddingTop = node.box.paddingLeft || 0;
  var paddingLeft = node.box.paddingLeft || 0;
  if (width === 0 || height5 === 0) {
    console.warn("Image with src '" + node.props.href + "' skipped due to invalid dimensions");
    return;
  }
  ctx.save();
  ctx.fillOpacity(opacity2 || 1).image(node.image.data, x + paddingLeft, y + paddingTop, {
    width,
    height: height5
  });
  ctx.restore();
};
var KAPPA$1 = 4 * ((Math.sqrt(2) - 1) / 3);
var clipNode = function clipNode2(ctx, node) {
  if (!node.style)
    return;
  var _node$box = node.box, top = _node$box.top, left = _node$box.left, width = _node$box.width, height5 = _node$box.height;
  var _node$style = node.style, _node$style$borderTop = _node$style.borderTopLeftRadius, borderTopLeftRadius = _node$style$borderTop === void 0 ? 0 : _node$style$borderTop, _node$style$borderTop2 = _node$style.borderTopRightRadius, borderTopRightRadius = _node$style$borderTop2 === void 0 ? 0 : _node$style$borderTop2, _node$style$borderBot = _node$style.borderBottomRightRadius, borderBottomRightRadius = _node$style$borderBot === void 0 ? 0 : _node$style$borderBot, _node$style$borderBot2 = _node$style.borderBottomLeftRadius, borderBottomLeftRadius = _node$style$borderBot2 === void 0 ? 0 : _node$style$borderBot2;
  var rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height5);
  var ctr = rtr * (1 - KAPPA$1);
  ctx.moveTo(left + rtr, top);
  ctx.lineTo(left + width - rtr, top);
  ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr);
  var rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height5);
  var cbr = rbr * (1 - KAPPA$1);
  ctx.lineTo(left + width, top + height5 - rbr);
  ctx.bezierCurveTo(left + width, top + height5 - cbr, left + width - cbr, top + height5, left + width - rbr, top + height5);
  var rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height5);
  var cbl = rbl * (1 - KAPPA$1);
  ctx.lineTo(left + rbl, top + height5);
  ctx.bezierCurveTo(left + cbl, top + height5, left, top + height5 - cbl, left, top + height5 - rbl);
  var rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height5);
  var ctl = rtl * (1 - KAPPA$1);
  ctx.lineTo(left, top + rtl);
  ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);
  ctx.closePath();
  ctx.clip();
};
var applySingleTransformation = function applySingleTransformation2(ctx, transform4, origin) {
  var operation = transform4.operation, value2 = transform4.value;
  switch (operation) {
    case "scale": {
      var scaleX = value2[0], scaleY = value2[1];
      ctx.scale(scaleX, scaleY, {
        origin
      });
      break;
    }
    case "rotate": {
      var angle = value2[0];
      ctx.rotate(angle, {
        origin
      });
      break;
    }
    case "translate": {
      var x = value2[0], _value$ = value2[1], y = _value$ === void 0 ? 0 : _value$;
      ctx.translate(x, y, {
        origin
      });
      break;
    }
    case "skew": {
      var xAngle = value2[0], yAngle = value2[1];
      ctx.skew(xAngle, yAngle, {
        origin
      });
      break;
    }
    case "matrix": {
      ctx.transform.apply(ctx, value2);
      break;
    }
    default: {
      console.error("Transform operation: '" + operation + "' doesn't supported");
    }
  }
};
var applyTransformations = function applyTransformations2(ctx, node) {
  var _node$style, _node$props;
  if (!node.origin)
    return;
  var origin = [node.origin.left, node.origin.top];
  var operations = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.transform) || ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.transform) || [];
  operations.forEach(function(operation) {
    applySingleTransformation(ctx, operation, origin);
  });
};
var _boundingBoxFns;
var getPathBoundingBox = function getPathBoundingBox2(node) {
  var _node$props;
  var path2 = normalize((0, import_abs_svg_path.default)((0, import_parse_svg_path.default)(((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.d) || "")));
  if (!path2.length)
    return [0, 0, 0, 0];
  var bounds = [Infinity, Infinity, -Infinity, -Infinity];
  for (var i = 0, l2 = path2.length; i < l2; i += 1) {
    var points = path2[i].slice(1);
    for (var j = 0; j < points.length; j += 2) {
      if (points[j + 0] < bounds[0])
        bounds[0] = points[j + 0];
      if (points[j + 1] < bounds[1])
        bounds[1] = points[j + 1];
      if (points[j + 0] > bounds[2])
        bounds[2] = points[j + 0];
      if (points[j + 1] > bounds[3])
        bounds[3] = points[j + 1];
    }
  }
  return bounds;
};
var getCircleBoundingBox = function getCircleBoundingBox2(node) {
  var _node$props2, _node$props3, _node$props4;
  var r = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.r) || 0;
  var cx2 = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.cx) || 0;
  var cy2 = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.cy) || 0;
  return [cx2 - r, cy2 - r, cx2 + r, cy2 + r];
};
var getEllipseBoundingBox = function getEllipseBoundingBox2(node) {
  var _node$props5, _node$props6, _node$props7, _node$props8;
  var cx2 = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.cx) || 0;
  var cy2 = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.cy) || 0;
  var rx = ((_node$props7 = node.props) === null || _node$props7 === void 0 ? void 0 : _node$props7.rx) || 0;
  var ry = ((_node$props8 = node.props) === null || _node$props8 === void 0 ? void 0 : _node$props8.ry) || 0;
  return [cx2 - rx, cy2 - ry, cx2 + rx, cy2 + ry];
};
var getLineBoundingBox = function getLineBoundingBox2(node) {
  var _node$props9, _node$props10, _node$props11, _node$props12;
  var x1 = ((_node$props9 = node.props) === null || _node$props9 === void 0 ? void 0 : _node$props9.x1) || 0;
  var y1 = ((_node$props10 = node.props) === null || _node$props10 === void 0 ? void 0 : _node$props10.y1) || 0;
  var x2 = ((_node$props11 = node.props) === null || _node$props11 === void 0 ? void 0 : _node$props11.x2) || 0;
  var y2 = ((_node$props12 = node.props) === null || _node$props12 === void 0 ? void 0 : _node$props12.y2) || 0;
  return [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];
};
var getRectBoundingBox = function getRectBoundingBox2(node) {
  var _node$props13, _node$props14, _node$props15, _node$props16;
  var x = ((_node$props13 = node.props) === null || _node$props13 === void 0 ? void 0 : _node$props13.x) || 0;
  var y = ((_node$props14 = node.props) === null || _node$props14 === void 0 ? void 0 : _node$props14.y) || 0;
  var width = ((_node$props15 = node.props) === null || _node$props15 === void 0 ? void 0 : _node$props15.width) || 0;
  var height5 = ((_node$props16 = node.props) === null || _node$props16 === void 0 ? void 0 : _node$props16.height) || 0;
  return [x, y, x + width, y + height5];
};
var max = function max2(values) {
  return Math.max.apply(Math, [-Infinity].concat(values));
};
var min = function min2(values) {
  return Math.min.apply(Math, [Infinity].concat(values));
};
var getPolylineBoundingBox = function getPolylineBoundingBox2(node) {
  var _node$props17;
  var points = parsePoints(((_node$props17 = node.props) === null || _node$props17 === void 0 ? void 0 : _node$props17.points) || []);
  var xValues = points.map(function(p) {
    return p[0];
  });
  var yValues = points.map(function(p) {
    return p[1];
  });
  return [min(xValues), min(yValues), max(xValues), max(yValues)];
};
var boundingBoxFns = (_boundingBoxFns = {}, _boundingBoxFns[Rect] = getRectBoundingBox, _boundingBoxFns[Line] = getLineBoundingBox, _boundingBoxFns[Path] = getPathBoundingBox, _boundingBoxFns[Circle] = getCircleBoundingBox, _boundingBoxFns[Ellipse] = getEllipseBoundingBox, _boundingBoxFns[Polygon] = getPolylineBoundingBox, _boundingBoxFns[Polyline] = getPolylineBoundingBox, _boundingBoxFns);
var getBoundingBox = function getBoundingBox2(node) {
  var boundingBoxFn = boundingBoxFns[node.type];
  return boundingBoxFn ? boundingBoxFn(node) : [0, 0, 0, 0];
};
var _renderFns$1;
var setStrokeWidth = function setStrokeWidth2(ctx, node) {
  var _node$props;
  var lineWidth2 = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.strokeWidth) || 0;
  if (lineWidth2)
    ctx.lineWidth(lineWidth2);
};
var setStrokeColor = function setStrokeColor2(ctx, node) {
  var _node$props2;
  var strokeColor2 = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.stroke) || null;
  if (strokeColor2)
    ctx.strokeColor(strokeColor2);
};
var setOpacity = function setOpacity2(ctx, node) {
  var _node$props3;
  var opacity2 = ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.opacity) || null;
  if (!isNil(opacity2))
    ctx.opacity(opacity2);
};
var setFillOpacity = function setFillOpacity2(ctx, node) {
  var _node$props4;
  var fillOpacity2 = ((_node$props4 = node.props) === null || _node$props4 === void 0 ? void 0 : _node$props4.fillOpacity) || null;
  if (!isNil(fillOpacity2))
    ctx.fillOpacity(fillOpacity2);
};
var setStrokeOpacity = function setStrokeOpacity2(ctx, node) {
  var _node$props5;
  var strokeOpacity2 = ((_node$props5 = node.props) === null || _node$props5 === void 0 ? void 0 : _node$props5.strokeOpacity) || null;
  if (!isNil(strokeOpacity2))
    ctx.strokeOpacity(strokeOpacity2);
};
var setLineJoin = function setLineJoin2(ctx, node) {
  var _node$props6;
  var lineJoin2 = ((_node$props6 = node.props) === null || _node$props6 === void 0 ? void 0 : _node$props6.strokeLinejoin) || null;
  if (lineJoin2)
    ctx.lineJoin(lineJoin2);
};
var setLineCap = function setLineCap2(ctx, node) {
  var _node$props7;
  var lineCap2 = ((_node$props7 = node.props) === null || _node$props7 === void 0 ? void 0 : _node$props7.strokeLinecap) || null;
  if (lineCap2)
    ctx.lineCap(lineCap2);
};
var setLineDash = function setLineDash2(ctx, node) {
  var _node$props8;
  var value2 = ((_node$props8 = node.props) === null || _node$props8 === void 0 ? void 0 : _node$props8.strokeDasharray) || null;
  if (value2)
    ctx.dash(value2.split(","));
};
var hasLinearGradientFill = function hasLinearGradientFill2(node) {
  var _node$props9, _node$props9$fill;
  return ((_node$props9 = node.props) === null || _node$props9 === void 0 ? void 0 : (_node$props9$fill = _node$props9.fill) === null || _node$props9$fill === void 0 ? void 0 : _node$props9$fill.type) === LinearGradient;
};
var hasRadialGradientFill = function hasRadialGradientFill2(node) {
  var _node$props10, _node$props10$fill;
  return ((_node$props10 = node.props) === null || _node$props10 === void 0 ? void 0 : (_node$props10$fill = _node$props10.fill) === null || _node$props10$fill === void 0 ? void 0 : _node$props10$fill.type) === RadialGradient;
};
var setLinearGradientFill = function setLinearGradientFill2(ctx, node) {
  var _node$props11;
  var bbox = getBoundingBox(node);
  var gradient = ((_node$props11 = node.props) === null || _node$props11 === void 0 ? void 0 : _node$props11.fill) || null;
  var x1 = gradient.props.x1 || 0;
  var y1 = gradient.props.y1 || 0;
  var x2 = gradient.props.x2 || 1;
  var y2 = gradient.props.y2 || 0;
  var m0 = bbox[2] - bbox[0];
  var m3 = bbox[3] - bbox[1];
  var m4 = bbox[0];
  var m5 = bbox[1];
  var gx1 = m0 * x1 + m4;
  var gy1 = m3 * y1 + m5;
  var gx2 = m0 * x2 + m4;
  var gy2 = m3 * y2 + m5;
  var grad = ctx.linearGradient(gx1, gy1, gx2, gy2);
  gradient.children.forEach(function(stop) {
    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);
  });
  ctx.fill(grad);
};
var setRadialGradientFill = function setRadialGradientFill2(ctx, node) {
  var _node$props12;
  var bbox = getBoundingBox(node);
  var gradient = ((_node$props12 = node.props) === null || _node$props12 === void 0 ? void 0 : _node$props12.fill) || null;
  var cx2 = gradient.props.cx || 0.5;
  var cy2 = gradient.props.cy || 0.5;
  var fx = gradient.props.fx || cx2;
  var fy = gradient.props.fy || cy2;
  var r = gradient.props.r || 0.5;
  var m0 = bbox[2] - bbox[0];
  var m3 = bbox[3] - bbox[1];
  var m4 = bbox[0];
  var m5 = bbox[1];
  var gr = r * m0;
  var gcx = m0 * cx2 + m4;
  var gcy = m3 * cy2 + m5;
  var gfx = m0 * fx + m4;
  var gfy = m3 * fy + m5;
  var grad = ctx.radialGradient(gfx, gfy, 0, gcx, gcy, gr);
  gradient.children.forEach(function(stop) {
    grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);
  });
  ctx.fill(grad);
};
var setFillColor = function setFillColor2(ctx, node) {
  var _node$props13;
  var fillColor2 = ((_node$props13 = node.props) === null || _node$props13 === void 0 ? void 0 : _node$props13.fill) || null;
  if (fillColor2)
    ctx.fillColor(fillColor2);
};
var setFill = function setFill2(ctx, node) {
  if (hasLinearGradientFill(node))
    return setLinearGradientFill(ctx, node);
  if (hasRadialGradientFill(node))
    return setRadialGradientFill(ctx, node);
  return setFillColor(ctx, node);
};
var draw = function draw2(ctx, node) {
  var props = node.props || {};
  if (props.fill && props.stroke) {
    ctx.fillAndStroke(props.fillRule);
  } else if (props.fill) {
    ctx.fill(props.fillRule);
  } else if (props.stroke) {
    ctx.stroke();
  } else {
    ctx.save();
    ctx.opacity(0);
    ctx.fill(null);
    ctx.restore();
  }
};
var noop = function noop2() {
};
var renderFns$1 = (_renderFns$1 = {}, _renderFns$1[Tspan] = noop, _renderFns$1[TextInstance] = noop, _renderFns$1[Path] = renderPath, _renderFns$1[Rect] = renderRect, _renderFns$1[Line] = renderLine$1, _renderFns$1[G] = renderGroup, _renderFns$1[Text] = renderSvgText, _renderFns$1[Circle] = renderCircle, _renderFns$1[Image] = renderImage$1, _renderFns$1[Ellipse] = renderEllipse, _renderFns$1[Polygon] = renderPolygon, _renderFns$1[Polyline] = renderPolyline, _renderFns$1);
var renderNode$1 = function renderNode(ctx, node) {
  var renderFn = renderFns$1[node.type];
  if (renderFns$1) {
    renderFn(ctx, node);
  } else {
    console.warn("SVG node of type " + node.type + " is not currenty supported");
  }
};
var drawNode = function drawNode2(ctx, node) {
  setLineCap(ctx, node);
  setLineDash(ctx, node);
  setLineJoin(ctx, node);
  setStrokeWidth(ctx, node);
  setStrokeColor(ctx, node);
  setFill(ctx, node);
  setStrokeOpacity(ctx, node);
  setFillOpacity(ctx, node);
  setOpacity(ctx, node);
  applyTransformations(ctx, node);
  renderNode$1(ctx, node);
  draw(ctx, node);
};
var clipPath = function clipPath2(ctx, node) {
  var _node$props14;
  var value2 = (_node$props14 = node.props) === null || _node$props14 === void 0 ? void 0 : _node$props14.clipPath;
  if (value2) {
    var children = value2.children || [];
    children.forEach(function(child) {
      return renderNode$1(ctx, child);
    });
    ctx.clip();
  }
};
var drawChildren = function drawChildren2(ctx, node) {
  var children = node.children || [];
  children.forEach(function(child) {
    ctx.save();
    clipPath(ctx, child);
    drawNode(ctx, child);
    drawChildren2(ctx, child);
    ctx.restore();
  });
};
var resolveAspectRatio = function resolveAspectRatio2(ctx, node) {
  var _node$box = node.box, width = _node$box.width, height5 = _node$box.height;
  var _node$props15 = node.props, viewBox = _node$props15.viewBox, _node$props15$preserv = _node$props15.preserveAspectRatio, preserveAspectRatio = _node$props15$preserv === void 0 ? {} : _node$props15$preserv;
  var _preserveAspectRatio$ = preserveAspectRatio.meetOrSlice, meetOrSlice = _preserveAspectRatio$ === void 0 ? "meet" : _preserveAspectRatio$, _preserveAspectRatio$2 = preserveAspectRatio.align, align = _preserveAspectRatio$2 === void 0 ? "xMidYMid" : _preserveAspectRatio$2;
  if (viewBox == null || width == null || height5 == null)
    return;
  var x = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.minX) || 0;
  var y = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.minY) || 0;
  var logicalWidth = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.maxX) || width;
  var logicalHeight = (viewBox === null || viewBox === void 0 ? void 0 : viewBox.maxY) || height5;
  var logicalRatio = logicalWidth / logicalHeight;
  var physicalRatio = width / height5;
  var scaleX = width / logicalWidth;
  var scaleY = height5 / logicalHeight;
  if (align === "none") {
    ctx.scale(scaleX, scaleY);
    ctx.translate(-x, -y);
    return;
  }
  if (logicalRatio < physicalRatio && meetOrSlice === "meet" || logicalRatio >= physicalRatio && meetOrSlice === "slice") {
    ctx.scale(scaleY, scaleY);
    switch (align) {
      case "xMinYMin":
      case "xMinYMid":
      case "xMinYMax":
        ctx.translate(-x, -y);
        break;
      case "xMidYMin":
      case "xMidYMid":
      case "xMidYMax":
        ctx.translate(-x - (logicalWidth - width * logicalHeight / height5) / 2, -y);
        break;
      default:
        ctx.translate(-x - (logicalWidth - width * logicalHeight / height5), -y);
    }
  } else {
    ctx.scale(scaleX, scaleX);
    switch (align) {
      case "xMinYMin":
      case "xMidYMin":
      case "xMaxYMin":
        ctx.translate(-x, -y);
        break;
      case "xMinYMid":
      case "xMidYMid":
      case "xMaxYMid":
        ctx.translate(-x, -y - (logicalHeight - height5 * logicalWidth / width) / 2);
        break;
      default:
        ctx.translate(-x, -y - (logicalHeight - height5 * logicalWidth / width));
    }
  }
};
var moveToOrigin = function moveToOrigin2(ctx, node) {
  var _node$box2 = node.box, top = _node$box2.top, left = _node$box2.left;
  var paddingLeft = node.box.paddingLeft || 0;
  var paddingTop = node.box.paddingTop || 0;
  ctx.translate(left + paddingLeft, top + paddingTop);
};
var renderSvg = function renderSvg2(ctx, node) {
  ctx.save();
  clipNode(ctx, node);
  moveToOrigin(ctx, node);
  resolveAspectRatio(ctx, node);
  drawChildren(ctx, node);
  ctx.restore();
};
var parseColor = function parseColor2(hex) {
  var parsed = import_color_string.default.get(hex);
  var value2 = import_color_string.default.to.hex(parsed.value.slice(0, 3));
  var opacity2 = parsed.value[3];
  return {
    value: value2,
    opacity: opacity2
  };
};
var DEST_REGEXP = /^#.+/;
var isSrcId$1 = function isSrcId(src3) {
  return src3.match(DEST_REGEXP);
};
var renderAttachment = function renderAttachment2(ctx, attachment) {
  var _attachment$xOffset = attachment.xOffset, xOffset = _attachment$xOffset === void 0 ? 0 : _attachment$xOffset, _attachment$yOffset = attachment.yOffset, yOffset = _attachment$yOffset === void 0 ? 0 : _attachment$yOffset, width = attachment.width, height5 = attachment.height, image2 = attachment.image;
  ctx.translate(-width + xOffset, -height5 + yOffset);
  ctx.image(image2, 0, 0, {
    fit: [width, height5],
    align: "center",
    valign: "bottom"
  });
};
var renderAttachments = function renderAttachments2(ctx, run) {
  ctx.save();
  var font2 = run.attributes.font;
  var space = font2.glyphForCodePoint(32);
  var objectReplacement = font2.glyphForCodePoint(65532);
  var attachmentAdvance = 0;
  for (var i = 0; i < run.glyphs.length; i += 1) {
    var position = run.positions[i];
    var glyph = run.glyphs[i];
    attachmentAdvance += position.xAdvance || 0;
    if (glyph.id === objectReplacement.id && run.attributes.attachment) {
      ctx.translate(attachmentAdvance, position.yOffset || 0);
      renderAttachment(ctx, run.attributes.attachment);
      run.glyphs[i] = space;
      attachmentAdvance = 0;
    }
  }
  ctx.restore();
};
var renderRun2 = function renderRun3(ctx, run, options) {
  var _run$attributes = run.attributes, font2 = _run$attributes.font, fontSize2 = _run$attributes.fontSize, link2 = _run$attributes.link;
  var color = parseColor(run.attributes.color);
  var opacity2 = isNil(run.attributes.opacity) ? color.opacity : run.attributes.opacity;
  var height5 = run.height, descent3 = run.descent, xAdvance = run.xAdvance;
  if (options.outlineRuns) {
    ctx.rect(0, -height5, xAdvance, height5).stroke();
  }
  ctx.fillColor(color.value);
  ctx.fillOpacity(opacity2);
  if (link2) {
    if (isSrcId$1(link2)) {
      ctx.goTo(0, -height5 - descent3, xAdvance, height5, link2.slice(1));
    } else {
      ctx.link(0, -height5 - descent3, xAdvance, height5, link2);
    }
  }
  renderAttachments(ctx, run);
  if (font2.sbix || font2.COLR && font2.CPAL) {
    ctx.save();
    ctx.translate(0, -run.ascent);
    for (var i = 0; i < run.glyphs.length; i += 1) {
      var position = run.positions[i];
      var glyph = run.glyphs[i];
      ctx.save();
      ctx.translate(position.xOffset, position.yOffset);
      glyph.render(ctx, fontSize2);
      ctx.restore();
      ctx.translate(position.xAdvance, position.yAdvance);
    }
    ctx.restore();
  } else {
    ctx.font(typeof font2.name === "string" ? font2.name : font2, fontSize2);
    try {
      renderGlyphs(ctx, run.glyphs, run.positions, 0, 0);
    } catch (error) {
      console.log(error);
    }
  }
  ctx.translate(xAdvance, 0);
};
var renderBackground$1 = function renderBackground(ctx, rect2, backgroundColor) {
  var color = parseColor(backgroundColor);
  ctx.save();
  ctx.fillOpacity(color.opacity);
  ctx.rect(rect2.x, rect2.y, rect2.width, rect2.height);
  ctx.fill(color.value);
  ctx.restore();
};
var renderDecorationLine = function renderDecorationLine2(ctx, line2) {
  ctx.save();
  ctx.lineWidth(line2.rect.height);
  ctx.strokeOpacity(line2.opacity);
  if (/dashed/.test(line2.style)) {
    ctx.dash(3 * line2.rect.height);
  } else if (/dotted/.test(line2.style)) {
    ctx.dash(line2.rect.height);
  }
  if (/wavy/.test(line2.style)) {
    var dist = Math.max(2, line2.rect.height);
    var step = 1.1 * dist;
    var stepCount = Math.floor(line2.rect.width / (2 * step));
    var remainingWidth = line2.rect.width - stepCount * 2 * step;
    var adjustment = remainingWidth / stepCount / 2;
    step += adjustment;
    var cp1y = line2.rect.y + dist;
    var cp2y = line2.rect.y - dist;
    var x = line2.rect.x;
    ctx.moveTo(line2.rect.x, line2.rect.y);
    for (var i = 0; i < stepCount; i += 1) {
      ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, line2.rect.y);
      x += 2 * step;
    }
  } else {
    ctx.moveTo(line2.rect.x, line2.rect.y);
    ctx.lineTo(line2.rect.x + line2.rect.width, line2.rect.y);
    if (/double/.test(line2.style)) {
      ctx.moveTo(line2.rect.x, line2.rect.y + line2.rect.height * 2);
      ctx.lineTo(line2.rect.x + line2.rect.width, line2.rect.y + line2.rect.height * 2);
    }
  }
  ctx.stroke(line2.color);
  ctx.restore();
};
var renderLine2 = function renderLine3(ctx, line2, options) {
  var lineAscent = line2.ascent;
  if (options.outlineLines) {
    ctx.rect(line2.box.x, line2.box.y, line2.box.width, line2.box.height).stroke();
  }
  ctx.save();
  ctx.translate(line2.box.x, line2.box.y + lineAscent);
  for (var i = 0; i < line2.runs.length; i += 1) {
    var run = line2.runs[i];
    var isLastRun = i === line2.runs.length - 1;
    if (run.attributes.backgroundColor) {
      var overflowRight = isLastRun ? line2.overflowRight : 0;
      var backgroundRect = {
        x: 0,
        y: -lineAscent,
        height: line2.box.height,
        width: run.xAdvance - overflowRight
      };
      renderBackground$1(ctx, backgroundRect, run.attributes.backgroundColor);
    }
    renderRun2(ctx, run, options);
  }
  ctx.restore();
  ctx.save();
  ctx.translate(line2.box.x, line2.box.y);
  for (var _i = 0; _i < line2.decorationLines.length; _i += 1) {
    var decorationLine = line2.decorationLines[_i];
    renderDecorationLine(ctx, decorationLine);
  }
  ctx.restore();
};
var renderBlock = function renderBlock2(ctx, block, options) {
  block.forEach(function(line2) {
    renderLine2(ctx, line2, options);
  });
};
var renderText = function renderText2(ctx, node) {
  var _node$box2, _node$box3;
  var _node$box = node.box, top = _node$box.top, left = _node$box.left;
  var blocks = [node.lines];
  var paddingTop = ((_node$box2 = node.box) === null || _node$box2 === void 0 ? void 0 : _node$box2.paddingTop) || 0;
  var paddingLeft = ((_node$box3 = node.box) === null || _node$box3 === void 0 ? void 0 : _node$box3.paddingLeft) || 0;
  var initialY = node.lines[0] ? node.lines[0].box.y : 0;
  var offsetX = node.alignOffset || 0;
  ctx.save();
  ctx.translate(left + paddingLeft - offsetX, top + paddingTop - initialY);
  blocks.forEach(function(block) {
    renderBlock(ctx, block, {});
  });
  ctx.restore();
};
var renderPage = function renderPage2(ctx, node) {
  var _node$props;
  var _node$box = node.box, width = _node$box.width, height5 = _node$box.height;
  var dpi = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.dpi) || 72;
  var userUnit = dpi / 72;
  ctx.addPage({
    size: [width, height5],
    margin: 0,
    userUnit
  });
};
var renderNote = function renderNote2(ctx, node) {
  var _node$children, _node$style, _node$style2;
  var _node$box = node.box, top = _node$box.top, left = _node$box.left;
  var value2 = (node === null || node === void 0 ? void 0 : (_node$children = node.children) === null || _node$children === void 0 ? void 0 : _node$children[0].value) || "";
  var color = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.backgroundColor) || null;
  var borderWidth = ((_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.borderWidth) || null;
  ctx.note(left, top, 0, 0, value2, {
    color,
    borderWidth
  });
};
var isNumeric = function isNumeric2(n) {
  return !Number.isNaN(parseFloat(n)) && Number.isFinite(n);
};
var applyContainObjectFit = function applyContainObjectFit2(cw, ch, iw, ih, px2, py2) {
  var cr = cw / ch;
  var ir = iw / ih;
  var pxp = matchPercent(px2);
  var pyp = matchPercent(py2);
  var pxv = pxp ? pxp.percent : 0.5;
  var pyv = pyp ? pyp.percent : 0.5;
  if (cr > ir) {
    var _height = ch;
    var _width = _height * ir;
    var _yOffset = isNumeric(py2) ? py2 : 0;
    var _xOffset = isNumeric(px2) ? px2 : (cw - _width) * pxv;
    return {
      width: _width,
      height: _height,
      xOffset: _xOffset,
      yOffset: _yOffset
    };
  }
  var width = cw;
  var height5 = width / ir;
  var xOffset = isNumeric(px2) ? px2 : 0;
  var yOffset = isNumeric(py2) ? py2 : (ch - height5) * pyv;
  return {
    width,
    height: height5,
    yOffset,
    xOffset
  };
};
var applyNoneObjectFit = function applyNoneObjectFit2(cw, ch, iw, ih, px2, py2) {
  var width = iw;
  var height5 = ih;
  var pxp = matchPercent(px2);
  var pyp = matchPercent(py2);
  var pxv = pxp ? pxp.percent : 0.5;
  var pyv = pyp ? pyp.percent : 0.5;
  var xOffset = isNumeric(px2) ? px2 : (cw - width) * pxv;
  var yOffset = isNumeric(py2) ? py2 : (ch - height5) * pyv;
  return {
    width,
    height: height5,
    xOffset,
    yOffset
  };
};
var applyCoverObjectFit = function applyCoverObjectFit2(cw, ch, iw, ih, px2, py2) {
  var ir = iw / ih;
  var cr = cw / ch;
  var pxp = matchPercent(px2);
  var pyp = matchPercent(py2);
  var pxv = pxp ? pxp.percent : 0.5;
  var pyv = pyp ? pyp.percent : 0.5;
  if (cr > ir) {
    var _width2 = cw;
    var _height2 = _width2 / ir;
    var _xOffset2 = isNumeric(px2) ? px2 : 0;
    var _yOffset2 = isNumeric(py2) ? py2 : (ch - _height2) * pyv;
    return {
      width: _width2,
      height: _height2,
      yOffset: _yOffset2,
      xOffset: _xOffset2
    };
  }
  var height5 = ch;
  var width = height5 * ir;
  var xOffset = isNumeric(px2) ? px2 : (cw - width) * pxv;
  var yOffset = isNumeric(py2) ? py2 : 0;
  return {
    width,
    height: height5,
    xOffset,
    yOffset
  };
};
var applyScaleDownObjectFit = function applyScaleDownObjectFit2(cw, ch, iw, ih, px2, py2) {
  var containDimension = applyContainObjectFit(cw, ch, iw, ih, px2, py2);
  var noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px2, py2);
  return containDimension.width < noneDimension.width ? containDimension : noneDimension;
};
var applyFillObjectFit = function applyFillObjectFit2(cw, ch, px2, py2) {
  return {
    width: cw,
    height: ch,
    xOffset: matchPercent(px2) ? 0 : px2 || 0,
    yOffset: matchPercent(py2) ? 0 : py2 || 0
  };
};
var resolveObjectFit = function resolveObjectFit2(type, cw, ch, iw, ih, px2, py2) {
  if (type === void 0) {
    type = "fill";
  }
  switch (type) {
    case "contain":
      return applyContainObjectFit(cw, ch, iw, ih, px2, py2);
    case "cover":
      return applyCoverObjectFit(cw, ch, iw, ih, px2, py2);
    case "none":
      return applyNoneObjectFit(cw, ch, iw, ih, px2, py2);
    case "scale-down":
      return applyScaleDownObjectFit(cw, ch, iw, ih, px2, py2);
    default:
      return applyFillObjectFit(cw, ch, px2, py2);
  }
};
var drawImage = function drawImage2(ctx, node, options) {
  var _node$style, _node$style2, _node$style3, _node$style4;
  if (options === void 0) {
    options = {};
  }
  var _node$box = node.box, left = _node$box.left, top = _node$box.top;
  var opacity2 = (_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.opacity;
  var objectFit = (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.objectFit;
  var objectPositionX = (_node$style3 = node.style) === null || _node$style3 === void 0 ? void 0 : _node$style3.objectPositionX;
  var objectPositionY = (_node$style4 = node.style) === null || _node$style4 === void 0 ? void 0 : _node$style4.objectPositionY;
  var paddingTop = node.box.paddingTop || 0;
  var paddingRight = node.box.paddingRight || 0;
  var paddingBottom = node.box.paddingBottom || 0;
  var paddingLeft = node.box.paddingLeft || 0;
  var imageCache = options.imageCache || /* @__PURE__ */ new Map();
  var _resolveObjectFit = resolveObjectFit(objectFit, node.box.width - paddingLeft - paddingRight, node.box.height - paddingTop - paddingBottom, node.image.width, node.image.height, objectPositionX, objectPositionY), width = _resolveObjectFit.width, height5 = _resolveObjectFit.height, xOffset = _resolveObjectFit.xOffset, yOffset = _resolveObjectFit.yOffset;
  if (node.image.data) {
    if (width !== 0 && height5 !== 0) {
      var cacheKey = node.image.key;
      var image2 = imageCache.get(cacheKey) || ctx.embedImage(node.image.data);
      if (cacheKey)
        imageCache.set(cacheKey, image2);
      var imageOpacity = isNil(opacity2) ? 1 : opacity2;
      ctx.fillOpacity(imageOpacity).image(image2, left + paddingLeft + xOffset, top + paddingTop + yOffset, {
        width,
        height: height5
      });
    } else {
      console.warn("Image with src '" + JSON.stringify(node.props.src) + "' skipped due to invalid dimensions");
    }
  }
};
var renderImage2 = function renderImage3(ctx, node, options) {
  ctx.save();
  clipNode(ctx, node);
  drawImage(ctx, node, options);
  ctx.restore();
};
var CONTENT_COLOR = "#a1c6e7";
var PADDING_COLOR = "#c4deb9";
var MARGIN_COLOR = "#f8cca1";
var debugContent = function debugContent2(ctx, node) {
  var _node$box = node.box, left = _node$box.left, top = _node$box.top, width = _node$box.width, height5 = _node$box.height, _node$box$paddingLeft = _node$box.paddingLeft, paddingLeft = _node$box$paddingLeft === void 0 ? 0 : _node$box$paddingLeft, _node$box$paddingTop = _node$box.paddingTop, paddingTop = _node$box$paddingTop === void 0 ? 0 : _node$box$paddingTop, _node$box$paddingRigh = _node$box.paddingRight, paddingRight = _node$box$paddingRigh === void 0 ? 0 : _node$box$paddingRigh, _node$box$paddingBott = _node$box.paddingBottom, paddingBottom = _node$box$paddingBott === void 0 ? 0 : _node$box$paddingBott, _node$box$borderLeftW = _node$box.borderLeftWidth, borderLeftWidth = _node$box$borderLeftW === void 0 ? 0 : _node$box$borderLeftW, _node$box$borderTopWi = _node$box.borderTopWidth, borderTopWidth = _node$box$borderTopWi === void 0 ? 0 : _node$box$borderTopWi, _node$box$borderRight = _node$box.borderRightWidth, borderRightWidth = _node$box$borderRight === void 0 ? 0 : _node$box$borderRight, _node$box$borderBotto = _node$box.borderBottomWidth, borderBottomWidth = _node$box$borderBotto === void 0 ? 0 : _node$box$borderBotto;
  ctx.fillColor(CONTENT_COLOR).opacity(0.5).rect(left + paddingLeft + borderLeftWidth, top + paddingTop + borderTopWidth, width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth, height5 - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth).fill();
};
var debugPadding = function debugPadding2(ctx, node) {
  var _node$box2 = node.box, left = _node$box2.left, top = _node$box2.top, width = _node$box2.width, height5 = _node$box2.height, _node$box2$paddingLef = _node$box2.paddingLeft, paddingLeft = _node$box2$paddingLef === void 0 ? 0 : _node$box2$paddingLef, _node$box2$paddingTop = _node$box2.paddingTop, paddingTop = _node$box2$paddingTop === void 0 ? 0 : _node$box2$paddingTop, _node$box2$paddingRig = _node$box2.paddingRight, paddingRight = _node$box2$paddingRig === void 0 ? 0 : _node$box2$paddingRig, _node$box2$paddingBot = _node$box2.paddingBottom, paddingBottom = _node$box2$paddingBot === void 0 ? 0 : _node$box2$paddingBot, _node$box2$borderLeft = _node$box2.borderLeftWidth, borderLeftWidth = _node$box2$borderLeft === void 0 ? 0 : _node$box2$borderLeft, _node$box2$borderTopW = _node$box2.borderTopWidth, borderTopWidth = _node$box2$borderTopW === void 0 ? 0 : _node$box2$borderTopW, _node$box2$borderRigh = _node$box2.borderRightWidth, borderRightWidth = _node$box2$borderRigh === void 0 ? 0 : _node$box2$borderRigh, _node$box2$borderBott = _node$box2.borderBottomWidth, borderBottomWidth = _node$box2$borderBott === void 0 ? 0 : _node$box2$borderBott;
  ctx.fillColor(PADDING_COLOR).opacity(0.5);
  ctx.rect(left + paddingLeft + borderLeftWidth, top + borderTopWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingTop).fill();
  ctx.rect(left + borderLeftWidth, top + borderTopWidth, paddingLeft, height5 - borderTopWidth - borderBottomWidth).fill();
  ctx.rect(left + width - paddingRight - borderRightWidth, top + borderTopWidth, paddingRight, height5 - borderTopWidth - borderBottomWidth).fill();
  ctx.rect(left + paddingLeft + borderLeftWidth, top + height5 - paddingBottom - borderBottomWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingBottom).fill();
};
var getMargin = function getMargin2(box) {
  var marginLeft = box.marginLeft === "auto" ? 0 : box.marginLeft;
  var marginTop = box.marginTop === "auto" ? 0 : box.marginTop;
  var marginRight = box.marginRight === "auto" ? 0 : box.marginRight;
  var marginBottom = box.marginBottom === "auto" ? 0 : box.marginBottom;
  return {
    marginLeft,
    marginTop,
    marginRight,
    marginBottom
  };
};
var debugMargin = function debugMargin2(ctx, node) {
  var _node$box3 = node.box, left = _node$box3.left, top = _node$box3.top, width = _node$box3.width, height5 = _node$box3.height;
  var _getMargin = getMargin(node.box), _getMargin$marginLeft = _getMargin.marginLeft, marginLeft = _getMargin$marginLeft === void 0 ? 0 : _getMargin$marginLeft, _getMargin$marginTop = _getMargin.marginTop, marginTop = _getMargin$marginTop === void 0 ? 0 : _getMargin$marginTop, _getMargin$marginRigh = _getMargin.marginRight, marginRight = _getMargin$marginRigh === void 0 ? 0 : _getMargin$marginRigh, _getMargin$marginBott = _getMargin.marginBottom, marginBottom = _getMargin$marginBott === void 0 ? 0 : _getMargin$marginBott;
  ctx.fillColor(MARGIN_COLOR).opacity(0.5);
  ctx.rect(left, top - marginTop, width, marginTop).fill();
  ctx.rect(left - marginLeft, top - marginTop, marginLeft, height5 + marginTop + marginBottom).fill();
  ctx.rect(left + width, top - marginTop, marginRight, height5 + marginTop + marginBottom).fill();
  ctx.rect(left, top + height5, width, marginBottom).fill();
};
var debugText = function debugText2(ctx, node) {
  var _node$box4 = node.box, left = _node$box4.left, top = _node$box4.top, width = _node$box4.width, height5 = _node$box4.height;
  var _getMargin2 = getMargin(node.box), _getMargin2$marginLef = _getMargin2.marginLeft, marginLeft = _getMargin2$marginLef === void 0 ? 0 : _getMargin2$marginLef, _getMargin2$marginTop = _getMargin2.marginTop, marginTop = _getMargin2$marginTop === void 0 ? 0 : _getMargin2$marginTop, _getMargin2$marginRig = _getMargin2.marginRight, marginRight = _getMargin2$marginRig === void 0 ? 0 : _getMargin2$marginRig, _getMargin2$marginBot = _getMargin2.marginBottom, marginBottom = _getMargin2$marginBot === void 0 ? 0 : _getMargin2$marginBot;
  var roundedWidth = Math.round(width + marginLeft + marginRight);
  var roundedHeight = Math.round(height5 + marginTop + marginBottom);
  ctx.fontSize(6).opacity(1).fillColor("black").text(roundedWidth + " x " + roundedHeight, left - marginLeft, Math.max(top - marginTop - 4, 1));
};
var debugOrigin = function debugOrigin2(ctx, node) {
  if (node.origin) {
    ctx.circle(node.origin.left, node.origin.top, 3).fill("red").circle(node.origin.left, node.origin.top, 5).stroke("red");
  }
};
var renderDebug = function renderDebug2(ctx, node) {
  var _node$props;
  if (!((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.debug))
    return;
  ctx.save();
  debugContent(ctx, node);
  debugPadding(ctx, node);
  debugMargin(ctx, node);
  debugText(ctx, node);
  debugOrigin(ctx, node);
  ctx.restore();
};
var availableMethods = ["dash", "clip", "save", "path", "fill", "font", "text", "rect", "scale", "moveTo", "lineTo", "stroke", "rotate", "circle", "lineCap", "opacity", "ellipse", "polygon", "restore", "lineJoin", "fontSize", "fillColor", "lineWidth", "translate", "miterLimit", "strokeColor", "fillOpacity", "roundedRect", "fillAndStroke", "strokeOpacity", "bezierCurveTo", "quadraticCurveTo", "linearGradient", "radialGradient"];
var painter = function painter2(ctx) {
  var p = availableMethods.reduce(function(acc, prop) {
    var _extends22;
    return _extends3({}, acc, (_extends22 = {}, _extends22[prop] = function() {
      ctx[prop].apply(ctx, arguments);
      return p;
    }, _extends22));
  }, {});
  return p;
};
var renderCanvas = function renderCanvas2(ctx, node) {
  var _node$box = node.box, top = _node$box.top, left = _node$box.left, width = _node$box.width, height5 = _node$box.height;
  var paddingTop = node.box.paddingTop || 0;
  var paddingLeft = node.box.paddingLeft || 0;
  var paddingRight = node.box.paddingRight || 0;
  var paddingBottom = node.box.paddingBottom || 0;
  var availableWidth = width - paddingLeft - paddingRight;
  var availableHeight = height5 - paddingTop - paddingBottom;
  if (!availableWidth || !availableHeight) {
    console.warn("Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.");
  }
  ctx.save().translate(left + paddingLeft, top + paddingTop);
  if (node.props.paint) {
    node.props.paint(painter(ctx), availableWidth, availableHeight);
  }
  ctx.restore();
};
var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
var clipBorderTop = function clipBorderTop2(ctx, layout2, style, rtr, rtl) {
  var top = layout2.top, left = layout2.left, width = layout2.width, height5 = layout2.height;
  var borderTopWidth = style.borderTopWidth, borderRightWidth = style.borderRightWidth, borderLeftWidth = style.borderLeftWidth;
  ctx.moveTo(left + rtl, top);
  ctx.lineTo(left + width - rtr, top);
  var c0 = rtr * (1 - KAPPA);
  ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr);
  var topRightYCoord = top + Math.max(borderTopWidth, rtr);
  ctx.lineTo(left + width, topRightYCoord);
  ctx.lineTo(left + width - borderRightWidth, topRightYCoord);
  var innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);
  var innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);
  var c1 = innerTopRightRadiusX * (1 - KAPPA);
  var c2 = innerTopRightRadiusY * (1 - KAPPA);
  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth);
  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth);
  var innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);
  var innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);
  var c3 = innerTopLeftRadiusX * (1 - KAPPA);
  var c4 = innerTopLeftRadiusY * (1 - KAPPA);
  var topLeftYCoord = top + Math.max(borderTopWidth, rtl);
  ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);
  ctx.lineTo(left, topLeftYCoord);
  ctx.lineTo(left, top + rtl);
  var c5 = rtl * (1 - KAPPA);
  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);
  ctx.closePath();
  ctx.clip();
  if (borderRightWidth) {
    var trSlope = -borderTopWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left, top);
    ctx.lineTo(left, top + height5);
    ctx.closePath();
    ctx.clip();
  }
  if (borderLeftWidth) {
    var _trSlope = -borderTopWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, _trSlope * (-width / 2) + top);
    ctx.lineTo(left, top);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left + width, top + height5);
    ctx.closePath();
    ctx.clip();
  }
};
var fillBorderTop = function fillBorderTop2(ctx, layout2, style, rtr, rtl) {
  var top = layout2.top, left = layout2.left, width = layout2.width;
  var borderTopColor = style.borderTopColor, borderTopWidth = style.borderTopWidth, borderTopStyle = style.borderTopStyle, borderRightWidth = style.borderRightWidth, borderLeftWidth = style.borderLeftWidth;
  var c0 = rtl * (1 - KAPPA);
  var c1 = rtr * (1 - KAPPA);
  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));
  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);
  ctx.lineTo(left + width - rtr, top);
  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);
  ctx.strokeColor(borderTopColor);
  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);
  if (borderTopStyle === "dashed") {
    ctx.dash(borderTopWidth * 2, {
      space: borderTopWidth * 1.2
    });
  } else if (borderTopStyle === "dotted") {
    ctx.dash(borderTopWidth, {
      space: borderTopWidth * 1.2
    });
  }
  ctx.stroke();
  ctx.undash();
};
var clipBorderRight = function clipBorderRight2(ctx, layout2, style, rtr, rbr) {
  var top = layout2.top, left = layout2.left, width = layout2.width, height5 = layout2.height;
  var borderTopWidth = style.borderTopWidth, borderRightWidth = style.borderRightWidth, borderBottomWidth = style.borderBottomWidth;
  ctx.moveTo(left + width, top + rtr);
  ctx.lineTo(left + width, top + height5 - rbr);
  var c0 = rbr * (1 - KAPPA);
  ctx.bezierCurveTo(left + width, top + height5 - c0, left + width - c0, top + height5, left + width - rbr, top + height5);
  var topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);
  ctx.lineTo(topBottomXCoord, top + height5);
  ctx.lineTo(topBottomXCoord, top + height5 - borderBottomWidth);
  var innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);
  var innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);
  var c1 = innerBottomRightRadiusX * (1 - KAPPA);
  var c2 = innerBottomRightRadiusY * (1 - KAPPA);
  ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height5 - borderBottomWidth, left + width - borderRightWidth, top + height5 - borderBottomWidth - c2, left + width - borderRightWidth, top + height5 - Math.max(rbr, borderBottomWidth));
  ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth));
  var innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);
  var innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);
  var c3 = innerTopRightRadiusX * (1 - KAPPA);
  var c4 = innerTopRightRadiusY * (1 - KAPPA);
  var topRightXCoord = left + width - Math.max(rtr, borderRightWidth);
  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);
  ctx.lineTo(topRightXCoord, top);
  ctx.lineTo(left + width - rtr, top);
  var c5 = rtr * (1 - KAPPA);
  ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);
  ctx.closePath();
  ctx.clip();
  if (borderTopWidth) {
    var trSlope = -borderTopWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left + width, top + height5);
    ctx.lineTo(left, top + height5);
    ctx.closePath();
    ctx.clip();
  }
  if (borderBottomWidth) {
    var brSlope = borderBottomWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height5);
    ctx.lineTo(left + width, top + height5);
    ctx.lineTo(left + width, top);
    ctx.lineTo(left, top);
    ctx.closePath();
    ctx.clip();
  }
};
var fillBorderRight = function fillBorderRight2(ctx, layout2, style, rtr, rbr) {
  var top = layout2.top, left = layout2.left, width = layout2.width, height5 = layout2.height;
  var borderRightColor = style.borderRightColor, borderRightStyle = style.borderRightStyle, borderRightWidth = style.borderRightWidth, borderTopWidth = style.borderTopWidth, borderBottomWidth = style.borderBottomWidth;
  var c0 = rbr * (1 - KAPPA);
  var c1 = rtr * (1 - KAPPA);
  ctx.moveTo(left + width - rtr, top);
  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);
  ctx.lineTo(left + width, top + height5 - rbr);
  ctx.bezierCurveTo(left + width, top + height5 - c0, left + width - c0, top + height5, left + width - rbr, top + height5);
  ctx.strokeColor(borderRightColor);
  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);
  if (borderRightStyle === "dashed") {
    ctx.dash(borderRightWidth * 2, {
      space: borderRightWidth * 1.2
    });
  } else if (borderRightStyle === "dotted") {
    ctx.dash(borderRightWidth, {
      space: borderRightWidth * 1.2
    });
  }
  ctx.stroke();
  ctx.undash();
};
var clipBorderBottom = function clipBorderBottom2(ctx, layout2, style, rbl, rbr) {
  var top = layout2.top, left = layout2.left, width = layout2.width, height5 = layout2.height;
  var borderBottomWidth = style.borderBottomWidth, borderRightWidth = style.borderRightWidth, borderLeftWidth = style.borderLeftWidth;
  ctx.moveTo(left + width - rbr, top + height5);
  ctx.lineTo(left + rbl, top + height5);
  var c0 = rbl * (1 - KAPPA);
  ctx.bezierCurveTo(left + c0, top + height5, left, top + height5 - c0, left, top + height5 - rbl);
  var bottomLeftYCoord = top + height5 - Math.max(borderBottomWidth, rbl);
  ctx.lineTo(left, bottomLeftYCoord);
  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord);
  var innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);
  var innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);
  var c1 = innerBottomLeftRadiusX * (1 - KAPPA);
  var c2 = innerBottomLeftRadiusY * (1 - KAPPA);
  ctx.bezierCurveTo(left + borderLeftWidth, top + height5 - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height5 - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height5 - borderBottomWidth);
  ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height5 - borderBottomWidth);
  var innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);
  var innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);
  var c3 = innerBottomRightRadiusX * (1 - KAPPA);
  var c4 = innerBottomRightRadiusY * (1 - KAPPA);
  var bottomRightYCoord = top + height5 - Math.max(borderBottomWidth, rbr);
  ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height5 - borderBottomWidth, left + width - borderRightWidth, top + height5 - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);
  ctx.lineTo(left + width, bottomRightYCoord);
  ctx.lineTo(left + width, top + height5 - rbr);
  var c5 = rbr * (1 - KAPPA);
  ctx.bezierCurveTo(left + width, top + height5 - c5, left + width - c5, top + height5, left + width - rbr, top + height5);
  ctx.closePath();
  ctx.clip();
  if (borderRightWidth) {
    var brSlope = borderBottomWidth / borderRightWidth;
    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height5);
    ctx.lineTo(left + width, top + height5);
    ctx.lineTo(left, top + height5);
    ctx.lineTo(left, top);
    ctx.closePath();
    ctx.clip();
  }
  if (borderLeftWidth) {
    var trSlope = -borderBottomWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height5);
    ctx.lineTo(left, top + height5);
    ctx.lineTo(left + width, top + height5);
    ctx.lineTo(left + width, top);
    ctx.closePath();
    ctx.clip();
  }
};
var fillBorderBottom = function fillBorderBottom2(ctx, layout2, style, rbl, rbr) {
  var top = layout2.top, left = layout2.left, width = layout2.width, height5 = layout2.height;
  var borderBottomColor = style.borderBottomColor, borderBottomStyle = style.borderBottomStyle, borderBottomWidth = style.borderBottomWidth, borderRightWidth = style.borderRightWidth, borderLeftWidth = style.borderLeftWidth;
  var c0 = rbl * (1 - KAPPA);
  var c1 = rbr * (1 - KAPPA);
  ctx.moveTo(left + width, top + height5 - rbr);
  ctx.bezierCurveTo(left + width, top + height5 - c1, left + width - c1, top + height5, left + width - rbr, top + height5);
  ctx.lineTo(left + rbl, top + height5);
  ctx.bezierCurveTo(left + c0, top + height5, left, top + height5 - c0, left, top + height5 - rbl);
  ctx.strokeColor(borderBottomColor);
  ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);
  if (borderBottomStyle === "dashed") {
    ctx.dash(borderBottomWidth * 2, {
      space: borderBottomWidth * 1.2
    });
  } else if (borderBottomStyle === "dotted") {
    ctx.dash(borderBottomWidth, {
      space: borderBottomWidth * 1.2
    });
  }
  ctx.stroke();
  ctx.undash();
};
var clipBorderLeft = function clipBorderLeft2(ctx, layout2, style, rbl, rtl) {
  var top = layout2.top, left = layout2.left, width = layout2.width, height5 = layout2.height;
  var borderTopWidth = style.borderTopWidth, borderLeftWidth = style.borderLeftWidth, borderBottomWidth = style.borderBottomWidth;
  ctx.moveTo(left, top + height5 - rbl);
  ctx.lineTo(left, top + rtl);
  var c0 = rtl * (1 - KAPPA);
  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);
  var topLeftCoordX = left + Math.max(borderLeftWidth, rtl);
  ctx.lineTo(topLeftCoordX, top);
  ctx.lineTo(topLeftCoordX, top + borderTopWidth);
  var innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);
  var innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);
  var c1 = innerTopLeftRadiusX * (1 - KAPPA);
  var c2 = innerTopLeftRadiusY * (1 - KAPPA);
  ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth));
  ctx.lineTo(left + borderLeftWidth, top + height5 - Math.max(rbl, borderBottomWidth));
  var innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);
  var innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);
  var c3 = innerBottomLeftRadiusX * (1 - KAPPA);
  var c4 = innerBottomLeftRadiusY * (1 - KAPPA);
  var bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth);
  ctx.bezierCurveTo(left + borderLeftWidth, top + height5 - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height5 - borderBottomWidth, bottomLeftXCoord, top + height5 - borderBottomWidth);
  ctx.lineTo(bottomLeftXCoord, top + height5);
  ctx.lineTo(left + rbl, top + height5);
  var c5 = rbl * (1 - KAPPA);
  ctx.bezierCurveTo(left + c5, top + height5, left, top + height5 - c5, left, top + height5 - rbl);
  ctx.closePath();
  ctx.clip();
  if (borderBottomWidth) {
    var trSlope = -borderBottomWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height5);
    ctx.lineTo(left, top + height5);
    ctx.lineTo(left, top);
    ctx.lineTo(left + width, top);
    ctx.closePath();
    ctx.clip();
  }
  if (borderBottomWidth) {
    var _trSlope2 = -borderTopWidth / borderLeftWidth;
    ctx.moveTo(left + width / 2, _trSlope2 * (-width / 2) + top);
    ctx.lineTo(left, top);
    ctx.lineTo(left, top + height5);
    ctx.lineTo(left + width, top + height5);
    ctx.closePath();
    ctx.clip();
  }
};
var fillBorderLeft = function fillBorderLeft2(ctx, layout2, style, rbl, rtl) {
  var top = layout2.top, left = layout2.left, height5 = layout2.height;
  var borderLeftColor = style.borderLeftColor, borderLeftStyle = style.borderLeftStyle, borderLeftWidth = style.borderLeftWidth, borderTopWidth = style.borderTopWidth, borderBottomWidth = style.borderBottomWidth;
  var c0 = rbl * (1 - KAPPA);
  var c1 = rtl * (1 - KAPPA);
  ctx.moveTo(left + rbl, top + height5);
  ctx.bezierCurveTo(left + c0, top + height5, left, top + height5 - c0, left, top + height5 - rbl);
  ctx.lineTo(left, top + rtl);
  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);
  ctx.strokeColor(borderLeftColor);
  ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);
  if (borderLeftStyle === "dashed") {
    ctx.dash(borderLeftWidth * 2, {
      space: borderLeftWidth * 1.2
    });
  } else if (borderLeftStyle === "dotted") {
    ctx.dash(borderLeftWidth, {
      space: borderLeftWidth * 1.2
    });
  }
  ctx.stroke();
  ctx.undash();
};
var shouldRenderBorders = function shouldRenderBorders2(node) {
  return node.box && (node.box.borderTopWidth || node.box.borderRightWidth || node.box.borderBottomWidth || node.box.borderLeftWidth);
};
var renderBorders = function renderBorders2(ctx, node) {
  if (!shouldRenderBorders(node))
    return;
  var _node$box = node.box, width = _node$box.width, height5 = _node$box.height, borderTopWidth = _node$box.borderTopWidth, borderLeftWidth = _node$box.borderLeftWidth, borderRightWidth = _node$box.borderRightWidth, borderBottomWidth = _node$box.borderBottomWidth;
  var _node$style = node.style, opacity2 = _node$style.opacity, _node$style$borderTop = _node$style.borderTopLeftRadius, borderTopLeftRadius = _node$style$borderTop === void 0 ? 0 : _node$style$borderTop, _node$style$borderTop2 = _node$style.borderTopRightRadius, borderTopRightRadius = _node$style$borderTop2 === void 0 ? 0 : _node$style$borderTop2, _node$style$borderBot = _node$style.borderBottomLeftRadius, borderBottomLeftRadius = _node$style$borderBot === void 0 ? 0 : _node$style$borderBot, _node$style$borderBot2 = _node$style.borderBottomRightRadius, borderBottomRightRadius = _node$style$borderBot2 === void 0 ? 0 : _node$style$borderBot2, _node$style$borderTop3 = _node$style.borderTopColor, borderTopColor = _node$style$borderTop3 === void 0 ? "black" : _node$style$borderTop3, _node$style$borderTop4 = _node$style.borderTopStyle, borderTopStyle = _node$style$borderTop4 === void 0 ? "solid" : _node$style$borderTop4, _node$style$borderLef = _node$style.borderLeftColor, borderLeftColor = _node$style$borderLef === void 0 ? "black" : _node$style$borderLef, _node$style$borderLef2 = _node$style.borderLeftStyle, borderLeftStyle = _node$style$borderLef2 === void 0 ? "solid" : _node$style$borderLef2, _node$style$borderRig = _node$style.borderRightColor, borderRightColor = _node$style$borderRig === void 0 ? "black" : _node$style$borderRig, _node$style$borderRig2 = _node$style.borderRightStyle, borderRightStyle = _node$style$borderRig2 === void 0 ? "solid" : _node$style$borderRig2, _node$style$borderBot3 = _node$style.borderBottomColor, borderBottomColor = _node$style$borderBot3 === void 0 ? "black" : _node$style$borderBot3, _node$style$borderBot4 = _node$style.borderBottomStyle, borderBottomStyle = _node$style$borderBot4 === void 0 ? "solid" : _node$style$borderBot4;
  var style = {
    borderTopColor,
    borderTopWidth,
    borderTopStyle,
    borderLeftColor,
    borderLeftWidth,
    borderLeftStyle,
    borderRightColor,
    borderRightWidth,
    borderRightStyle,
    borderBottomColor,
    borderBottomWidth,
    borderBottomStyle,
    borderTopLeftRadius,
    borderTopRightRadius,
    borderBottomLeftRadius,
    borderBottomRightRadius
  };
  var rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height5);
  var rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height5);
  var rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height5);
  var rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height5);
  ctx.save();
  ctx.strokeOpacity(opacity2);
  if (borderTopWidth) {
    ctx.save();
    clipBorderTop(ctx, node.box, style, rtr, rtl);
    fillBorderTop(ctx, node.box, style, rtr, rtl);
    ctx.restore();
  }
  if (borderRightWidth) {
    ctx.save();
    clipBorderRight(ctx, node.box, style, rtr, rbr);
    fillBorderRight(ctx, node.box, style, rtr, rbr);
    ctx.restore();
  }
  if (borderBottomWidth) {
    ctx.save();
    clipBorderBottom(ctx, node.box, style, rbl, rbr);
    fillBorderBottom(ctx, node.box, style, rbl, rbr);
    ctx.restore();
  }
  if (borderLeftWidth) {
    ctx.save();
    clipBorderLeft(ctx, node.box, style, rbl, rtl);
    fillBorderLeft(ctx, node.box, style, rbl, rtl);
    ctx.restore();
  }
  ctx.restore();
};
var drawBackground = function drawBackground2(ctx, node) {
  var _node$style;
  var _node$box = node.box, top = _node$box.top, left = _node$box.left, width = _node$box.width, height5 = _node$box.height;
  var color = parseColor(node.style.backgroundColor);
  var nodeOpacity = isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.opacity) ? 1 : node.style.opacity;
  var opacity2 = Math.min(color.opacity, nodeOpacity);
  ctx.fillOpacity(opacity2).fillColor(color.value).rect(left, top, width, height5).fill();
};
var renderBackground2 = function renderBackground3(ctx, node) {
  var _node$style2;
  var hasBackground = !!node.box && !!((_node$style2 = node.style) !== null && _node$style2 !== void 0 && _node$style2.backgroundColor);
  if (hasBackground) {
    ctx.save();
    clipNode(ctx, node);
    drawBackground(ctx, node);
    ctx.restore();
  }
};
var isSrcId2 = function isSrcId3(value2) {
  return /^#.+/.test(value2);
};
var setLink = function setLink2(ctx, node) {
  var props = node.props || {};
  var _node$box = node.box, top = _node$box.top, left = _node$box.left, width = _node$box.width, height5 = _node$box.height;
  var src3 = props.src || props.href;
  if (src3) {
    var isId = isSrcId2(src3);
    var method = isId ? "goTo" : "link";
    var value2 = isId ? src3.slice(1) : src3;
    ctx[method](left, top, width, height5, value2);
  }
};
var setDestination = function setDestination2(ctx, node) {
  var _node$props;
  if ((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.id) {
    ctx.addNamedDestination(node.props.id, "XYZ", null, node.box.top, null);
  }
};
var _renderFns;
var isRecursiveNode = function isRecursiveNode2(node) {
  return node.type !== Text && node.type !== Svg;
};
var renderChildren = function renderChildren2(ctx, node, options) {
  ctx.save();
  if (node.box) {
    ctx.translate(node.box.left, node.box.top);
  }
  var children = node.children || [];
  var renderChild = function renderChild2(child) {
    return renderNode2(ctx, child, options);
  };
  children.forEach(renderChild);
  ctx.restore();
};
var renderFns = (_renderFns = {}, _renderFns[Text] = renderText, _renderFns[Note] = renderNote, _renderFns[Image] = renderImage2, _renderFns[Canvas] = renderCanvas, _renderFns[Svg] = renderSvg, _renderFns[Link] = setLink, _renderFns);
var renderNode2 = function renderNode3(ctx, node, options) {
  var _node$style;
  var overflowHidden = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.overflow) === "hidden";
  var shouldRenderChildren = isRecursiveNode(node);
  if (node.type === Page)
    renderPage(ctx, node);
  ctx.save();
  if (overflowHidden)
    clipNode(ctx, node);
  applyTransformations(ctx, node);
  renderBackground2(ctx, node);
  renderBorders(ctx, node);
  var renderFn = renderFns[node.type];
  if (renderFn)
    renderFn(ctx, node, options);
  if (shouldRenderChildren)
    renderChildren(ctx, node, options);
  setDestination(ctx, node);
  renderDebug(ctx, node);
  ctx.restore();
};
var setPDFMetadata = function setPDFMetadata2(target) {
  return function(key, value2) {
    if (value2)
      target.info[key] = value2;
  };
};
var addMetadata = function addMetadata2(ctx, doc) {
  var _props$creator, _props$producer;
  var setProp = setPDFMetadata(ctx);
  var props = doc.props || {};
  var title3 = props.title || null;
  var author = props.author || null;
  var subject = props.subject || null;
  var keywords = props.keywords || null;
  var creator = (_props$creator = props.creator) != null ? _props$creator : "react-pdf";
  var producer = (_props$producer = props.producer) != null ? _props$producer : "react-pdf";
  setProp("Title", title3);
  setProp("Author", author);
  setProp("Subject", subject);
  setProp("Keywords", keywords);
  setProp("Creator", creator);
  setProp("Producer", producer);
};
var addNodeBookmark = function addNodeBookmark2(ctx, node, pageNumber, registry) {
  var _node$props;
  var bookmark = (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.bookmark;
  if (bookmark) {
    var title3 = bookmark.title, parent = bookmark.parent, expanded = bookmark.expanded, zoom = bookmark.zoom, fit = bookmark.fit;
    var outline = registry[parent] || ctx.outline;
    var top = bookmark.top || node.box.top;
    var left = bookmark.left || node.box.left;
    var instance = outline.addItem(title3, {
      pageNumber,
      expanded,
      top,
      left,
      zoom,
      fit
    });
    registry[bookmark.ref] = instance;
  }
  if (!node.children)
    return;
  node.children.forEach(function(child) {
    return addNodeBookmark2(ctx, child, pageNumber, registry);
  });
};
var addBookmarks = function addBookmarks2(ctx, root) {
  var registry = {};
  var pages = root.children || [];
  pages.forEach(function(page, i) {
    addNodeBookmark(ctx, page, i, registry);
  });
};
var render = function render2(ctx, doc) {
  var pages = doc.children || [];
  var options = {
    imageCache: /* @__PURE__ */ new Map()
  };
  addMetadata(ctx, doc);
  pages.forEach(function(page) {
    return renderNode2(ctx, page, options);
  });
  addBookmarks(ctx, doc);
  ctx.end();
  return ctx;
};

// ../node_modules/@react-pdf/pdfkit/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf4(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}

// ../node_modules/@react-pdf/pdfkit/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}

// ../node_modules/@react-pdf/pdfkit/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}

// ../node_modules/@react-pdf/pdfkit/lib/pdfkit.browser.es.js
var import_zstream = __toESM(require_zstream());
var import_deflate = __toESM(require_deflate());
var import_inflate = __toESM(require_inflate());
var import_constants = __toESM(require_constants());

// ../node_modules/@react-pdf/pdfkit/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}

// ../node_modules/@react-pdf/pdfkit/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}

// ../node_modules/@react-pdf/pdfkit/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelperLoose.js
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return {
          done: true
        };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// ../node_modules/@react-pdf/pdfkit/node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof4(obj) {
  "@babel/helpers - typeof";
  return _typeof4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof4(obj);
}

// ../node_modules/@react-pdf/pdfkit/node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function _toPrimitive(input, hint) {
  if (_typeof4(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof4(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

// ../node_modules/@react-pdf/pdfkit/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof4(key) === "symbol" ? key : String(key);
}

// ../node_modules/@react-pdf/pdfkit/node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

// ../node_modules/@react-pdf/pdfkit/lib/pdfkit.browser.es.js
var import_md5 = __toESM(require_md5());

// ../node_modules/@react-pdf/png-js/lib/png-js.browser.es.js
var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup$1 = [];
var revLookup$1 = [];
var Arr$1 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited = false;
function init() {
  inited = true;
  var code3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code3.length; i < len; ++i) {
    lookup$1[i] = code3[i];
    revLookup$1[code3.charCodeAt(i)] = i;
  }
  revLookup$1["-".charCodeAt(0)] = 62;
  revLookup$1["_".charCodeAt(0)] = 63;
}
function toByteArray$1(b64) {
  if (!inited) {
    init();
  }
  var i, j, l2, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr$1(len * 3 / 4 - placeHolders);
  l2 = placeHolders > 0 ? len - 4 : len;
  var L2 = 0;
  for (i = 0, j = 0; i < l2; i += 4, j += 3) {
    tmp = revLookup$1[b64.charCodeAt(i)] << 18 | revLookup$1[b64.charCodeAt(i + 1)] << 12 | revLookup$1[b64.charCodeAt(i + 2)] << 6 | revLookup$1[b64.charCodeAt(i + 3)];
    arr[L2++] = tmp >> 16 & 255;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup$1[b64.charCodeAt(i)] << 2 | revLookup$1[b64.charCodeAt(i + 1)] >> 4;
    arr[L2++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup$1[b64.charCodeAt(i)] << 10 | revLookup$1[b64.charCodeAt(i + 1)] << 4 | revLookup$1[b64.charCodeAt(i + 2)] >> 2;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64$1(num) {
  return lookup$1[num >> 18 & 63] + lookup$1[num >> 12 & 63] + lookup$1[num >> 6 & 63] + lookup$1[num & 63];
}
function encodeChunk$1(uint82, start3, end3) {
  var tmp;
  var output = [];
  for (var i = start3; i < end3; i += 3) {
    tmp = (uint82[i] << 16) + (uint82[i + 1] << 8) + uint82[i + 2];
    output.push(tripletToBase64$1(tmp));
  }
  return output.join("");
}
function fromByteArray$1(uint82) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk$1(uint82, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    output += lookup$1[tmp >> 2];
    output += lookup$1[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    output += lookup$1[tmp >> 10];
    output += lookup$1[tmp >> 4 & 63];
    output += lookup$1[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer3, offset3, isLE, mLen, nBytes) {
  var e, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s2 = buffer3[offset3 + i];
  i += d;
  e = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer3[offset3 + i], i += d, nBits -= 8) {
  }
  m2 = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer3[offset3 + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e - mLen);
}
function write(buffer3, value2, offset3, isLE, mLen, nBytes) {
  var e, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m2 = isNaN(value2) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c2 = Math.pow(2, -e)) < 1) {
      e--;
      c2 *= 2;
    }
    if (e + eBias >= 1) {
      value2 += rt / c2;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c2 >= 2) {
      e++;
      c2 /= 2;
    }
    if (e + eBias >= eMax) {
      m2 = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m2 = (value2 * c2 - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer3[offset3 + i] = m2 & 255, i += d, m2 /= 256, mLen -= 8) {
  }
  e = e << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer3[offset3 + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer3[offset3 + i - d] |= s2 * 128;
}
var toString$1 = {}.toString;
var isArray = Array.isArray || function(arr) {
  return toString$1.call(arr) == "[object Array]";
};
var INSPECT_MAX_BYTES = 50;
Buffer$1.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
function kMaxLength() {
  return Buffer$1.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length4) {
  if (kMaxLength() < length4) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length4);
    that.__proto__ = Buffer$1.prototype;
  } else {
    if (that === null) {
      that = new Buffer$1(length4);
    }
    that.length = length4;
  }
  return that;
}
function Buffer$1(arg, encodingOrOffset, length4) {
  if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
    return new Buffer$1(arg, encodingOrOffset, length4);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length4);
}
Buffer$1.poolSize = 8192;
Buffer$1._augment = function(arr) {
  arr.__proto__ = Buffer$1.prototype;
  return arr;
};
function from(that, value2, encodingOrOffset, length4) {
  if (typeof value2 === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value2, encodingOrOffset, length4);
  }
  if (typeof value2 === "string") {
    return fromString(that, value2, encodingOrOffset);
  }
  return fromObject(that, value2);
}
Buffer$1.from = function(value2, encodingOrOffset, length4) {
  return from(null, value2, encodingOrOffset, length4);
};
if (Buffer$1.TYPED_ARRAY_SUPPORT) {
  Buffer$1.prototype.__proto__ = Uint8Array.prototype;
  Buffer$1.__proto__ = Uint8Array;
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill5, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill5 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill5, encoding) : createBuffer(that, size).fill(fill5);
  }
  return createBuffer(that, size);
}
Buffer$1.alloc = function(size, fill5, encoding) {
  return alloc(null, size, fill5, encoding);
};
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
Buffer$1.allocUnsafe = function(size) {
  return allocUnsafe(null, size);
};
Buffer$1.allocUnsafeSlow = function(size) {
  return allocUnsafe(null, size);
};
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer$1.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length4 = byteLength$1(string, encoding) | 0;
  that = createBuffer(that, length4);
  var actual = that.write(string, encoding);
  if (actual !== length4) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length4 = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length4);
  for (var i = 0; i < length4; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length4) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length4 || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length4 === void 0) {
    array = new Uint8Array(array);
  } else if (length4 === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length4);
  }
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer$1.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(length4) {
  if (length4 >= kMaxLength()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  }
  return length4 | 0;
}
Buffer$1.isBuffer = isBuffer;
function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}
Buffer$1.compare = function compare(a2, b) {
  if (!internalIsBuffer(a2) || !internalIsBuffer(b)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a2 === b)
    return 0;
  var x = a2.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a2[i] !== b[i]) {
      x = a2[i];
      y = b[i];
      break;
    }
  }
  if (x < y)
    return -1;
  if (y < x)
    return 1;
  return 0;
};
Buffer$1.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer$1.concat = function concat(list, length4) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer$1.alloc(0);
  }
  var i;
  if (length4 === void 0) {
    length4 = 0;
    for (i = 0; i < list.length; ++i) {
      length4 += list[i].length;
    }
  }
  var buffer3 = Buffer$1.allocUnsafe(length4);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer3, pos);
    pos += buf.length;
  }
  return buffer3;
};
function byteLength$1(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$1.byteLength = byteLength$1;
function slowToString(encoding, start3, end3) {
  var loweredCase = false;
  if (start3 === void 0 || start3 < 0) {
    start3 = 0;
  }
  if (start3 > this.length) {
    return "";
  }
  if (end3 === void 0 || end3 > this.length) {
    end3 = this.length;
  }
  if (end3 <= 0) {
    return "";
  }
  end3 >>>= 0;
  start3 >>>= 0;
  if (end3 <= start3) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start3, end3);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start3, end3);
      case "ascii":
        return asciiSlice(this, start3, end3);
      case "latin1":
      case "binary":
        return latin1Slice(this, start3, end3);
      case "base64":
        return base64Slice(this, start3, end3);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start3, end3);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$1.prototype._isBuffer = true;
function swap(b, n, m2) {
  var i = b[n];
  b[n] = b[m2];
  b[m2] = i;
}
Buffer$1.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};
Buffer$1.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};
Buffer$1.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};
Buffer$1.prototype.toString = function toString() {
  var length4 = this.length | 0;
  if (length4 === 0)
    return "";
  if (arguments.length === 0)
    return utf8Slice(this, 0, length4);
  return slowToString.apply(this, arguments);
};
Buffer$1.prototype.equals = function equals(b) {
  if (!internalIsBuffer(b))
    throw new TypeError("Argument must be a Buffer");
  if (this === b)
    return true;
  return Buffer$1.compare(this, b) === 0;
};
Buffer$1.prototype.inspect = function inspect() {
  var str = "";
  var max3 = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString("hex", 0, max3).match(/.{2}/g).join(" ");
    if (this.length > max3)
      str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer$1.prototype.compare = function compare2(target, start3, end3, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start3 === void 0) {
    start3 = 0;
  }
  if (end3 === void 0) {
    end3 = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start3 < 0 || end3 > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start3 >= end3) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start3 >= end3) {
    return 1;
  }
  start3 >>>= 0;
  end3 >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target)
    return 0;
  var x = thisEnd - thisStart;
  var y = end3 - start3;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start3, end3);
  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }
  if (x < y)
    return -1;
  if (y < x)
    return 1;
  return 0;
};
function bidirectionalIndexOf(buffer3, val, byteOffset, encoding, dir) {
  if (buffer3.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer3.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer3.length + byteOffset;
  if (byteOffset >= buffer3.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer3.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer$1.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer3, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer$1.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer3, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer3, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer3, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read4(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read4(arr, i) === read4(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read4(arr, i + j) !== read4(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
}
Buffer$1.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer$1.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer$1.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset3, length4) {
  offset3 = Number(offset3) || 0;
  var remaining = buf.length - offset3;
  if (!length4) {
    length4 = remaining;
  } else {
    length4 = Number(length4);
    if (length4 > remaining) {
      length4 = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length4 > strLen / 2) {
    length4 = strLen / 2;
  }
  for (var i = 0; i < length4; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset3 + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset3, length4) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset3), buf, offset3, length4);
}
function asciiWrite(buf, string, offset3, length4) {
  return blitBuffer(asciiToBytes(string), buf, offset3, length4);
}
function latin1Write(buf, string, offset3, length4) {
  return asciiWrite(buf, string, offset3, length4);
}
function base64Write(buf, string, offset3, length4) {
  return blitBuffer(base64ToBytes(string), buf, offset3, length4);
}
function ucs2Write(buf, string, offset3, length4) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset3), buf, offset3, length4);
}
Buffer$1.prototype.write = function write2(string, offset3, length4, encoding) {
  if (offset3 === void 0) {
    encoding = "utf8";
    length4 = this.length;
    offset3 = 0;
  } else if (length4 === void 0 && typeof offset3 === "string") {
    encoding = offset3;
    length4 = this.length;
    offset3 = 0;
  } else if (isFinite(offset3)) {
    offset3 = offset3 | 0;
    if (isFinite(length4)) {
      length4 = length4 | 0;
      if (encoding === void 0)
        encoding = "utf8";
    } else {
      encoding = length4;
      length4 = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset3;
  if (length4 === void 0 || length4 > remaining)
    length4 = remaining;
  if (string.length > 0 && (length4 < 0 || offset3 < 0) || offset3 > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding)
    encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite(this, string, offset3, length4);
      case "utf8":
      case "utf-8":
        return utf8Write(this, string, offset3, length4);
      case "ascii":
        return asciiWrite(this, string, offset3, length4);
      case "latin1":
      case "binary":
        return latin1Write(this, string, offset3, length4);
      case "base64":
        return base64Write(this, string, offset3, length4);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write(this, string, offset3, length4);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer$1.prototype.toJSON = function toJSON() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(buf, start3, end3) {
  if (start3 === 0 && end3 === buf.length) {
    return fromByteArray$1(buf);
  } else {
    return fromByteArray$1(buf.slice(start3, end3));
  }
}
function utf8Slice(buf, start3, end3) {
  end3 = Math.min(buf.length, end3);
  var res = [];
  var i = start3;
  while (i < end3) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end3) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}
function asciiSlice(buf, start3, end3) {
  var ret = "";
  end3 = Math.min(buf.length, end3);
  for (var i = start3; i < end3; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice(buf, start3, end3) {
  var ret = "";
  end3 = Math.min(buf.length, end3);
  for (var i = start3; i < end3; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start3, end3) {
  var len = buf.length;
  if (!start3 || start3 < 0)
    start3 = 0;
  if (!end3 || end3 < 0 || end3 > len)
    end3 = len;
  var out = "";
  for (var i = start3; i < end3; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start3, end3) {
  var bytes = buf.slice(start3, end3);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
Buffer$1.prototype.slice = function slice(start3, end3) {
  var len = this.length;
  start3 = ~~start3;
  end3 = end3 === void 0 ? len : ~~end3;
  if (start3 < 0) {
    start3 += len;
    if (start3 < 0)
      start3 = 0;
  } else if (start3 > len) {
    start3 = len;
  }
  if (end3 < 0) {
    end3 += len;
    if (end3 < 0)
      end3 = 0;
  } else if (end3 > len) {
    end3 = len;
  }
  if (end3 < start3)
    end3 = start3;
  var newBuf;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start3, end3);
    newBuf.__proto__ = Buffer$1.prototype;
  } else {
    var sliceLen = end3 - start3;
    newBuf = new Buffer$1(sliceLen, void 0);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start3];
    }
  }
  return newBuf;
};
function checkOffset(offset3, ext, length4) {
  if (offset3 % 1 !== 0 || offset3 < 0)
    throw new RangeError("offset is not uint");
  if (offset3 + ext > length4)
    throw new RangeError("Trying to access beyond buffer length");
}
Buffer$1.prototype.readUIntLE = function readUIntLE(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert)
    checkOffset(offset3, byteLength5, this.length);
  var val = this[offset3];
  var mul = 1;
  var i = 0;
  while (++i < byteLength5 && (mul *= 256)) {
    val += this[offset3 + i] * mul;
  }
  return val;
};
Buffer$1.prototype.readUIntBE = function readUIntBE(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    checkOffset(offset3, byteLength5, this.length);
  }
  var val = this[offset3 + --byteLength5];
  var mul = 1;
  while (byteLength5 > 0 && (mul *= 256)) {
    val += this[offset3 + --byteLength5] * mul;
  }
  return val;
};
Buffer$1.prototype.readUInt8 = function readUInt8(offset3, noAssert) {
  if (!noAssert)
    checkOffset(offset3, 1, this.length);
  return this[offset3];
};
Buffer$1.prototype.readUInt16LE = function readUInt16LE(offset3, noAssert) {
  if (!noAssert)
    checkOffset(offset3, 2, this.length);
  return this[offset3] | this[offset3 + 1] << 8;
};
Buffer$1.prototype.readUInt16BE = function readUInt16BE(offset3, noAssert) {
  if (!noAssert)
    checkOffset(offset3, 2, this.length);
  return this[offset3] << 8 | this[offset3 + 1];
};
Buffer$1.prototype.readUInt32LE = function readUInt32LE(offset3, noAssert) {
  if (!noAssert)
    checkOffset(offset3, 4, this.length);
  return (this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16) + this[offset3 + 3] * 16777216;
};
Buffer$1.prototype.readUInt32BE = function readUInt32BE(offset3, noAssert) {
  if (!noAssert)
    checkOffset(offset3, 4, this.length);
  return this[offset3] * 16777216 + (this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3]);
};
Buffer$1.prototype.readIntLE = function readIntLE(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert)
    checkOffset(offset3, byteLength5, this.length);
  var val = this[offset3];
  var mul = 1;
  var i = 0;
  while (++i < byteLength5 && (mul *= 256)) {
    val += this[offset3 + i] * mul;
  }
  mul *= 128;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer$1.prototype.readIntBE = function readIntBE(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert)
    checkOffset(offset3, byteLength5, this.length);
  var i = byteLength5;
  var mul = 1;
  var val = this[offset3 + --i];
  while (i > 0 && (mul *= 256)) {
    val += this[offset3 + --i] * mul;
  }
  mul *= 128;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer$1.prototype.readInt8 = function readInt8(offset3, noAssert) {
  if (!noAssert)
    checkOffset(offset3, 1, this.length);
  if (!(this[offset3] & 128))
    return this[offset3];
  return (255 - this[offset3] + 1) * -1;
};
Buffer$1.prototype.readInt16LE = function readInt16LE(offset3, noAssert) {
  if (!noAssert)
    checkOffset(offset3, 2, this.length);
  var val = this[offset3] | this[offset3 + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$1.prototype.readInt16BE = function readInt16BE(offset3, noAssert) {
  if (!noAssert)
    checkOffset(offset3, 2, this.length);
  var val = this[offset3 + 1] | this[offset3] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$1.prototype.readInt32LE = function readInt32LE(offset3, noAssert) {
  if (!noAssert)
    checkOffset(offset3, 4, this.length);
  return this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16 | this[offset3 + 3] << 24;
};
Buffer$1.prototype.readInt32BE = function readInt32BE(offset3, noAssert) {
  if (!noAssert)
    checkOffset(offset3, 4, this.length);
  return this[offset3] << 24 | this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3];
};
Buffer$1.prototype.readFloatLE = function readFloatLE(offset3, noAssert) {
  if (!noAssert)
    checkOffset(offset3, 4, this.length);
  return read(this, offset3, true, 23, 4);
};
Buffer$1.prototype.readFloatBE = function readFloatBE(offset3, noAssert) {
  if (!noAssert)
    checkOffset(offset3, 4, this.length);
  return read(this, offset3, false, 23, 4);
};
Buffer$1.prototype.readDoubleLE = function readDoubleLE(offset3, noAssert) {
  if (!noAssert)
    checkOffset(offset3, 8, this.length);
  return read(this, offset3, true, 52, 8);
};
Buffer$1.prototype.readDoubleBE = function readDoubleBE(offset3, noAssert) {
  if (!noAssert)
    checkOffset(offset3, 8, this.length);
  return read(this, offset3, false, 52, 8);
};
function checkInt(buf, value2, offset3, ext, max3, min3) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value2 > max3 || value2 < min3)
    throw new RangeError('"value" argument is out of bounds');
  if (offset3 + ext > buf.length)
    throw new RangeError("Index out of range");
}
Buffer$1.prototype.writeUIntLE = function writeUIntLE(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt(this, value2, offset3, byteLength5, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset3] = value2 & 255;
  while (++i < byteLength5 && (mul *= 256)) {
    this[offset3 + i] = value2 / mul & 255;
  }
  return offset3 + byteLength5;
};
Buffer$1.prototype.writeUIntBE = function writeUIntBE(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt(this, value2, offset3, byteLength5, maxBytes, 0);
  }
  var i = byteLength5 - 1;
  var mul = 1;
  this[offset3 + i] = value2 & 255;
  while (--i >= 0 && (mul *= 256)) {
    this[offset3 + i] = value2 / mul & 255;
  }
  return offset3 + byteLength5;
};
Buffer$1.prototype.writeUInt8 = function writeUInt8(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt(this, value2, offset3, 1, 255, 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT)
    value2 = Math.floor(value2);
  this[offset3] = value2 & 255;
  return offset3 + 1;
};
function objectWriteUInt16(buf, value2, offset3, littleEndian) {
  if (value2 < 0)
    value2 = 65535 + value2 + 1;
  for (var i = 0, j = Math.min(buf.length - offset3, 2); i < j; ++i) {
    buf[offset3 + i] = (value2 & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
Buffer$1.prototype.writeUInt16LE = function writeUInt16LE(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt(this, value2, offset3, 2, 65535, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt16(this, value2, offset3, true);
  }
  return offset3 + 2;
};
Buffer$1.prototype.writeUInt16BE = function writeUInt16BE(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt(this, value2, offset3, 2, 65535, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 8;
    this[offset3 + 1] = value2 & 255;
  } else {
    objectWriteUInt16(this, value2, offset3, false);
  }
  return offset3 + 2;
};
function objectWriteUInt32(buf, value2, offset3, littleEndian) {
  if (value2 < 0)
    value2 = 4294967295 + value2 + 1;
  for (var i = 0, j = Math.min(buf.length - offset3, 4); i < j; ++i) {
    buf[offset3 + i] = value2 >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
Buffer$1.prototype.writeUInt32LE = function writeUInt32LE(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt(this, value2, offset3, 4, 4294967295, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset3 + 3] = value2 >>> 24;
    this[offset3 + 2] = value2 >>> 16;
    this[offset3 + 1] = value2 >>> 8;
    this[offset3] = value2 & 255;
  } else {
    objectWriteUInt32(this, value2, offset3, true);
  }
  return offset3 + 4;
};
Buffer$1.prototype.writeUInt32BE = function writeUInt32BE(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt(this, value2, offset3, 4, 4294967295, 0);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 24;
    this[offset3 + 1] = value2 >>> 16;
    this[offset3 + 2] = value2 >>> 8;
    this[offset3 + 3] = value2 & 255;
  } else {
    objectWriteUInt32(this, value2, offset3, false);
  }
  return offset3 + 4;
};
Buffer$1.prototype.writeIntLE = function writeIntLE(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt(this, value2, offset3, byteLength5, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset3] = value2 & 255;
  while (++i < byteLength5 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset3 + i - 1] !== 0) {
      sub = 1;
    }
    this[offset3 + i] = (value2 / mul >> 0) - sub & 255;
  }
  return offset3 + byteLength5;
};
Buffer$1.prototype.writeIntBE = function writeIntBE(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt(this, value2, offset3, byteLength5, limit - 1, -limit);
  }
  var i = byteLength5 - 1;
  var mul = 1;
  var sub = 0;
  this[offset3 + i] = value2 & 255;
  while (--i >= 0 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset3 + i + 1] !== 0) {
      sub = 1;
    }
    this[offset3 + i] = (value2 / mul >> 0) - sub & 255;
  }
  return offset3 + byteLength5;
};
Buffer$1.prototype.writeInt8 = function writeInt8(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt(this, value2, offset3, 1, 127, -128);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT)
    value2 = Math.floor(value2);
  if (value2 < 0)
    value2 = 255 + value2 + 1;
  this[offset3] = value2 & 255;
  return offset3 + 1;
};
Buffer$1.prototype.writeInt16LE = function writeInt16LE(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt(this, value2, offset3, 2, 32767, -32768);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt16(this, value2, offset3, true);
  }
  return offset3 + 2;
};
Buffer$1.prototype.writeInt16BE = function writeInt16BE(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt(this, value2, offset3, 2, 32767, -32768);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 8;
    this[offset3 + 1] = value2 & 255;
  } else {
    objectWriteUInt16(this, value2, offset3, false);
  }
  return offset3 + 2;
};
Buffer$1.prototype.writeInt32LE = function writeInt32LE(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt(this, value2, offset3, 4, 2147483647, -2147483648);
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
    this[offset3 + 2] = value2 >>> 16;
    this[offset3 + 3] = value2 >>> 24;
  } else {
    objectWriteUInt32(this, value2, offset3, true);
  }
  return offset3 + 4;
};
Buffer$1.prototype.writeInt32BE = function writeInt32BE(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt(this, value2, offset3, 4, 2147483647, -2147483648);
  if (value2 < 0)
    value2 = 4294967295 + value2 + 1;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 24;
    this[offset3 + 1] = value2 >>> 16;
    this[offset3 + 2] = value2 >>> 8;
    this[offset3 + 3] = value2 & 255;
  } else {
    objectWriteUInt32(this, value2, offset3, false);
  }
  return offset3 + 4;
};
function checkIEEE754(buf, value2, offset3, ext, max3, min3) {
  if (offset3 + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset3 < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value2, offset3, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value2, offset3, 4);
  }
  write(buf, value2, offset3, littleEndian, 23, 4);
  return offset3 + 4;
}
Buffer$1.prototype.writeFloatLE = function writeFloatLE(value2, offset3, noAssert) {
  return writeFloat(this, value2, offset3, true, noAssert);
};
Buffer$1.prototype.writeFloatBE = function writeFloatBE(value2, offset3, noAssert) {
  return writeFloat(this, value2, offset3, false, noAssert);
};
function writeDouble(buf, value2, offset3, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value2, offset3, 8);
  }
  write(buf, value2, offset3, littleEndian, 52, 8);
  return offset3 + 8;
}
Buffer$1.prototype.writeDoubleLE = function writeDoubleLE(value2, offset3, noAssert) {
  return writeDouble(this, value2, offset3, true, noAssert);
};
Buffer$1.prototype.writeDoubleBE = function writeDoubleBE(value2, offset3, noAssert) {
  return writeDouble(this, value2, offset3, false, noAssert);
};
Buffer$1.prototype.copy = function copy(target, targetStart, start3, end3) {
  if (!start3)
    start3 = 0;
  if (!end3 && end3 !== 0)
    end3 = this.length;
  if (targetStart >= target.length)
    targetStart = target.length;
  if (!targetStart)
    targetStart = 0;
  if (end3 > 0 && end3 < start3)
    end3 = start3;
  if (end3 === start3)
    return 0;
  if (target.length === 0 || this.length === 0)
    return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start3 < 0 || start3 >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (end3 < 0)
    throw new RangeError("sourceEnd out of bounds");
  if (end3 > this.length)
    end3 = this.length;
  if (target.length - targetStart < end3 - start3) {
    end3 = target.length - targetStart + start3;
  }
  var len = end3 - start3;
  var i;
  if (this === target && start3 < targetStart && targetStart < end3) {
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start3];
    }
  } else if (len < 1e3 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start3];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start3, start3 + len),
      targetStart
    );
  }
  return len;
};
Buffer$1.prototype.fill = function fill(val, start3, end3, encoding) {
  if (typeof val === "string") {
    if (typeof start3 === "string") {
      encoding = start3;
      start3 = 0;
      end3 = this.length;
    } else if (typeof end3 === "string") {
      encoding = end3;
      end3 = this.length;
    }
    if (val.length === 1) {
      var code3 = val.charCodeAt(0);
      if (code3 < 256) {
        val = code3;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer$1.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start3 < 0 || this.length < start3 || this.length < end3) {
    throw new RangeError("Out of range index");
  }
  if (end3 <= start3) {
    return this;
  }
  start3 = start3 >>> 0;
  end3 = end3 === void 0 ? this.length : end3 >>> 0;
  if (!val)
    val = 0;
  var i;
  if (typeof val === "number") {
    for (i = start3; i < end3; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer$1(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end3 - start3; ++i) {
      this[i + start3] = bytes[i % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n) {
  if (n < 16)
    return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length4 = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length4; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length4) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c2, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0)
      break;
    c2 = str.charCodeAt(i);
    hi = c2 >> 8;
    lo = c2 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray$1(base64clean(str));
}
function blitBuffer(src3, dst, offset3, length4) {
  for (var i = 0; i < length4; ++i) {
    if (i + offset3 >= dst.length || i >= src3.length)
      break;
    dst[i + offset3] = src3[i];
  }
  return i;
}
function isnan(val) {
  return val !== val;
}
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
function defaultSetTimout$1() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout$1() {
  throw new Error("clearTimeout has not been defined");
}
var cachedSetTimeout$1 = defaultSetTimout$1;
var cachedClearTimeout$1 = defaultClearTimeout$1;
if (typeof global$1.setTimeout === "function") {
  cachedSetTimeout$1 = setTimeout;
}
if (typeof global$1.clearTimeout === "function") {
  cachedClearTimeout$1 = clearTimeout;
}
function runTimeout$1(fun) {
  if (cachedSetTimeout$1 === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout$1 === defaultSetTimout$1 || !cachedSetTimeout$1) && setTimeout) {
    cachedSetTimeout$1 = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout$1(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout$1.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout$1.call(this, fun, 0);
    }
  }
}
function runClearTimeout$1(marker) {
  if (cachedClearTimeout$1 === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout$1 === defaultClearTimeout$1 || !cachedClearTimeout$1) && clearTimeout) {
    cachedClearTimeout$1 = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout$1(marker);
  } catch (e) {
    try {
      return cachedClearTimeout$1.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout$1.call(this, marker);
    }
  }
}
var queue$1 = [];
var draining$1 = false;
var currentQueue$1;
var queueIndex$1 = -1;
function cleanUpNextTick$1() {
  if (!draining$1 || !currentQueue$1) {
    return;
  }
  draining$1 = false;
  if (currentQueue$1.length) {
    queue$1 = currentQueue$1.concat(queue$1);
  } else {
    queueIndex$1 = -1;
  }
  if (queue$1.length) {
    drainQueue$1();
  }
}
function drainQueue$1() {
  if (draining$1) {
    return;
  }
  var timeout = runTimeout$1(cleanUpNextTick$1);
  draining$1 = true;
  var len = queue$1.length;
  while (len) {
    currentQueue$1 = queue$1;
    queue$1 = [];
    while (++queueIndex$1 < len) {
      if (currentQueue$1) {
        currentQueue$1[queueIndex$1].run();
      }
    }
    queueIndex$1 = -1;
    len = queue$1.length;
  }
  currentQueue$1 = null;
  draining$1 = false;
  runClearTimeout$1(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue$1.push(new Item$1(fun, args));
  if (queue$1.length === 1 && !draining$1) {
    runTimeout$1(drainQueue$1);
  }
}
function Item$1(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item$1.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title = "browser";
var platform = "browser";
var browser$1 = true;
var env = {};
var argv = [];
var version = "";
var versions = {};
var release = {};
var config = {};
function noop$1() {
}
var on = noop$1;
var addListener = noop$1;
var once$1 = noop$1;
var off = noop$1;
var removeListener = noop$1;
var removeAllListeners = noop$1;
var emit = noop$1;
function binding$1(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
var performance = global$1.performance || {};
var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
var startTime = /* @__PURE__ */ new Date();
function uptime() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var browser$1$1 = {
  nextTick,
  title,
  browser: browser$1,
  env,
  argv,
  version,
  versions,
  on,
  addListener,
  once: once$1,
  off,
  removeListener,
  removeAllListeners,
  emit,
  binding: binding$1,
  cwd,
  chdir,
  umask,
  hrtime,
  platform,
  release,
  config,
  uptime
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var a2 = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a2, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a2;
}
var lib = {};
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength2;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
var i;
var len;
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength2(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint82, start3, end3) {
  var tmp;
  var output = [];
  for (var i = start3; i < end3; i += 3) {
    tmp = (uint82[i] << 16 & 16711680) + (uint82[i + 1] << 8 & 65280) + (uint82[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint82) {
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint82, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
  }
  return parts.join("");
}
var ieee754 = {};
ieee754.read = function(buffer3, offset3, isLE, mLen, nBytes) {
  var e, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s2 = buffer3[offset3 + i];
  i += d;
  e = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer3[offset3 + i], i += d, nBits -= 8) {
  }
  m2 = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer3[offset3 + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer3, value2, offset3, isLE, mLen, nBytes) {
  var e, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m2 = isNaN(value2) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c2 = Math.pow(2, -e)) < 1) {
      e--;
      c2 *= 2;
    }
    if (e + eBias >= 1) {
      value2 += rt / c2;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c2 >= 2) {
      e++;
      c2 /= 2;
    }
    if (e + eBias >= eMax) {
      m2 = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m2 = (value2 * c2 - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer3[offset3 + i] = m2 & 255, i += d, m2 /= 256, mLen -= 8) {
  }
  e = e << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer3[offset3 + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer3[offset3 + i - d] |= s2 * 128;
};
(function(exports) {
  var base64 = base64Js;
  var ieee754$1 = ieee754;
  var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer5;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  var K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer5.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer5.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      var arr = new Uint8Array(1);
      var proto = {
        foo: function foo() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer5.prototype, "parent", {
    enumerable: true,
    get: function get18() {
      if (!Buffer5.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer5.prototype, "offset", {
    enumerable: true,
    get: function get18() {
      if (!Buffer5.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer4(length4) {
    if (length4 > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length4 + '" is invalid for option "size"');
    }
    var buf = new Uint8Array(length4);
    Object.setPrototypeOf(buf, Buffer5.prototype);
    return buf;
  }
  function Buffer5(arg, encodingOrOffset, length4) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe4(arg);
    }
    return from4(arg, encodingOrOffset, length4);
  }
  Buffer5.poolSize = 8192;
  function from4(value2, encodingOrOffset, length4) {
    if (typeof value2 === "string") {
      return fromString4(value2, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value2)) {
      return fromArrayView(value2);
    }
    if (value2 == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2);
    }
    if (isInstance(value2, ArrayBuffer) || value2 && isInstance(value2.buffer, ArrayBuffer)) {
      return fromArrayBuffer4(value2, encodingOrOffset, length4);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value2, SharedArrayBuffer) || value2 && isInstance(value2.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer4(value2, encodingOrOffset, length4);
    }
    if (typeof value2 === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    var valueOf = value2.valueOf && value2.valueOf();
    if (valueOf != null && valueOf !== value2) {
      return Buffer5.from(valueOf, encodingOrOffset, length4);
    }
    var b = fromObject4(value2);
    if (b)
      return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value2[Symbol.toPrimitive] === "function") {
      return Buffer5.from(value2[Symbol.toPrimitive]("string"), encodingOrOffset, length4);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2);
  }
  Buffer5.from = function(value2, encodingOrOffset, length4) {
    return from4(value2, encodingOrOffset, length4);
  };
  Object.setPrototypeOf(Buffer5.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer5, Uint8Array);
  function assertSize4(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc4(size, fill5, encoding) {
    assertSize4(size);
    if (size <= 0) {
      return createBuffer4(size);
    }
    if (fill5 !== void 0) {
      return typeof encoding === "string" ? createBuffer4(size).fill(fill5, encoding) : createBuffer4(size).fill(fill5);
    }
    return createBuffer4(size);
  }
  Buffer5.alloc = function(size, fill5, encoding) {
    return alloc4(size, fill5, encoding);
  };
  function allocUnsafe4(size) {
    assertSize4(size);
    return createBuffer4(size < 0 ? 0 : checked4(size) | 0);
  }
  Buffer5.allocUnsafe = function(size) {
    return allocUnsafe4(size);
  };
  Buffer5.allocUnsafeSlow = function(size) {
    return allocUnsafe4(size);
  };
  function fromString4(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer5.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    var length4 = byteLength5(string, encoding) | 0;
    var buf = createBuffer4(length4);
    var actual = buf.write(string, encoding);
    if (actual !== length4) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike4(array) {
    var length4 = array.length < 0 ? 0 : checked4(array.length) | 0;
    var buf = createBuffer4(length4);
    for (var i = 0; i < length4; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      var copy6 = new Uint8Array(arrayView);
      return fromArrayBuffer4(copy6.buffer, copy6.byteOffset, copy6.byteLength);
    }
    return fromArrayLike4(arrayView);
  }
  function fromArrayBuffer4(array, byteOffset, length4) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length4 || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    var buf;
    if (byteOffset === void 0 && length4 === void 0) {
      buf = new Uint8Array(array);
    } else if (length4 === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length4);
    }
    Object.setPrototypeOf(buf, Buffer5.prototype);
    return buf;
  }
  function fromObject4(obj) {
    if (Buffer5.isBuffer(obj)) {
      var len = checked4(obj.length) | 0;
      var buf = createBuffer4(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN5(obj.length)) {
        return createBuffer4(0);
      }
      return fromArrayLike4(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike4(obj.data);
    }
  }
  function checked4(length4) {
    if (length4 >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length4 | 0;
  }
  function SlowBuffer(length4) {
    if (+length4 != length4) {
      length4 = 0;
    }
    return Buffer5.alloc(+length4);
  }
  Buffer5.isBuffer = function isBuffer6(b) {
    return b != null && b._isBuffer === true && b !== Buffer5.prototype;
  };
  Buffer5.compare = function compare9(a2, b) {
    if (isInstance(a2, Uint8Array))
      a2 = Buffer5.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b, Uint8Array))
      b = Buffer5.from(b, b.offset, b.byteLength);
    if (!Buffer5.isBuffer(a2) || !Buffer5.isBuffer(b)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a2 === b)
      return 0;
    var x = a2.length;
    var y = b.length;
    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a2[i] !== b[i]) {
        x = a2[i];
        y = b[i];
        break;
      }
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer5.isEncoding = function isEncoding6(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer5.concat = function concat8(list, length4) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer5.alloc(0);
    }
    var i;
    if (length4 === void 0) {
      length4 = 0;
      for (i = 0; i < list.length; ++i) {
        length4 += list[i].length;
      }
    }
    var buffer3 = Buffer5.allocUnsafe(length4);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer3.length) {
          Buffer5.from(buf).copy(buffer3, pos);
        } else {
          Uint8Array.prototype.set.call(buffer3, buf, pos);
        }
      } else if (!Buffer5.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer3, pos);
      }
      pos += buf.length;
    }
    return buffer3;
  };
  function byteLength5(string, encoding) {
    if (Buffer5.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes4(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes4(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes4(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer5.byteLength = byteLength5;
  function slowToString4(encoding, start3, end3) {
    var loweredCase = false;
    if (start3 === void 0 || start3 < 0) {
      start3 = 0;
    }
    if (start3 > this.length) {
      return "";
    }
    if (end3 === void 0 || end3 > this.length) {
      end3 = this.length;
    }
    if (end3 <= 0) {
      return "";
    }
    end3 >>>= 0;
    start3 >>>= 0;
    if (end3 <= start3) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice4(this, start3, end3);
        case "utf8":
        case "utf-8":
          return utf8Slice4(this, start3, end3);
        case "ascii":
          return asciiSlice4(this, start3, end3);
        case "latin1":
        case "binary":
          return latin1Slice4(this, start3, end3);
        case "base64":
          return base64Slice4(this, start3, end3);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice4(this, start3, end3);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer5.prototype._isBuffer = true;
  function swap4(b, n, m2) {
    var i = b[n];
    b[n] = b[m2];
    b[m2] = i;
  }
  Buffer5.prototype.swap16 = function swap164() {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i = 0; i < len; i += 2) {
      swap4(this, i, i + 1);
    }
    return this;
  };
  Buffer5.prototype.swap32 = function swap324() {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i = 0; i < len; i += 4) {
      swap4(this, i, i + 3);
      swap4(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer5.prototype.swap64 = function swap644() {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i = 0; i < len; i += 8) {
      swap4(this, i, i + 7);
      swap4(this, i + 1, i + 6);
      swap4(this, i + 2, i + 5);
      swap4(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer5.prototype.toString = function toString7() {
    var length4 = this.length;
    if (length4 === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice4(this, 0, length4);
    return slowToString4.apply(this, arguments);
  };
  Buffer5.prototype.toLocaleString = Buffer5.prototype.toString;
  Buffer5.prototype.equals = function equals4(b) {
    if (!Buffer5.isBuffer(b))
      throw new TypeError("Argument must be a Buffer");
    if (this === b)
      return true;
    return Buffer5.compare(this, b) === 0;
  };
  Buffer5.prototype.inspect = function inspect6() {
    var str = "";
    var max3 = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max3).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max3)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer5.prototype[customInspectSymbol] = Buffer5.prototype.inspect;
  }
  Buffer5.prototype.compare = function compare9(target, start3, end3, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer5.from(target, target.offset, target.byteLength);
    }
    if (!Buffer5.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start3 === void 0) {
      start3 = 0;
    }
    if (end3 === void 0) {
      end3 = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start3 < 0 || end3 > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start3 >= end3) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start3 >= end3) {
      return 1;
    }
    start3 >>>= 0;
    end3 >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    var x = thisEnd - thisStart;
    var y = end3 - start3;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start3, end3);
    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf4(buffer3, val, byteOffset, encoding, dir) {
    if (buffer3.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN5(byteOffset)) {
      byteOffset = dir ? 0 : buffer3.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer3.length + byteOffset;
    if (byteOffset >= buffer3.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer3.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer5.from(val, encoding);
    }
    if (Buffer5.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf4(buffer3, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer3, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer3, val, byteOffset);
        }
      }
      return arrayIndexOf4(buffer3, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf4(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read4(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read4(arr, i) === read4(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read4(arr, i + j) !== read4(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i;
      }
    }
    return -1;
  }
  Buffer5.prototype.includes = function includes6(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer5.prototype.indexOf = function indexOf8(val, byteOffset, encoding) {
    return bidirectionalIndexOf4(this, val, byteOffset, encoding, true);
  };
  Buffer5.prototype.lastIndexOf = function lastIndexOf4(val, byteOffset, encoding) {
    return bidirectionalIndexOf4(this, val, byteOffset, encoding, false);
  };
  function hexWrite4(buf, string, offset3, length4) {
    offset3 = Number(offset3) || 0;
    var remaining = buf.length - offset3;
    if (!length4) {
      length4 = remaining;
    } else {
      length4 = Number(length4);
      if (length4 > remaining) {
        length4 = remaining;
      }
    }
    var strLen = string.length;
    if (length4 > strLen / 2) {
      length4 = strLen / 2;
    }
    for (var i = 0; i < length4; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN5(parsed))
        return i;
      buf[offset3 + i] = parsed;
    }
    return i;
  }
  function utf8Write4(buf, string, offset3, length4) {
    return blitBuffer4(utf8ToBytes4(string, buf.length - offset3), buf, offset3, length4);
  }
  function asciiWrite4(buf, string, offset3, length4) {
    return blitBuffer4(asciiToBytes4(string), buf, offset3, length4);
  }
  function base64Write4(buf, string, offset3, length4) {
    return blitBuffer4(base64ToBytes4(string), buf, offset3, length4);
  }
  function ucs2Write4(buf, string, offset3, length4) {
    return blitBuffer4(utf16leToBytes4(string, buf.length - offset3), buf, offset3, length4);
  }
  Buffer5.prototype.write = function write7(string, offset3, length4, encoding) {
    if (offset3 === void 0) {
      encoding = "utf8";
      length4 = this.length;
      offset3 = 0;
    } else if (length4 === void 0 && typeof offset3 === "string") {
      encoding = offset3;
      length4 = this.length;
      offset3 = 0;
    } else if (isFinite(offset3)) {
      offset3 = offset3 >>> 0;
      if (isFinite(length4)) {
        length4 = length4 >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length4;
        length4 = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    var remaining = this.length - offset3;
    if (length4 === void 0 || length4 > remaining)
      length4 = remaining;
    if (string.length > 0 && (length4 < 0 || offset3 < 0) || offset3 > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite4(this, string, offset3, length4);
        case "utf8":
        case "utf-8":
          return utf8Write4(this, string, offset3, length4);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite4(this, string, offset3, length4);
        case "base64":
          return base64Write4(this, string, offset3, length4);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write4(this, string, offset3, length4);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer5.prototype.toJSON = function toJSON4() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice4(buf, start3, end3) {
    if (start3 === 0 && end3 === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start3, end3));
    }
  }
  function utf8Slice4(buf, start3, end3) {
    end3 = Math.min(buf.length, end3);
    var res = [];
    var i = start3;
    while (i < end3) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end3) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray4(res);
  }
  var MAX_ARGUMENTS_LENGTH4 = 4096;
  function decodeCodePointsArray4(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH4) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH4));
    }
    return res;
  }
  function asciiSlice4(buf, start3, end3) {
    var ret = "";
    end3 = Math.min(buf.length, end3);
    for (var i = start3; i < end3; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice4(buf, start3, end3) {
    var ret = "";
    end3 = Math.min(buf.length, end3);
    for (var i = start3; i < end3; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice4(buf, start3, end3) {
    var len = buf.length;
    if (!start3 || start3 < 0)
      start3 = 0;
    if (!end3 || end3 < 0 || end3 > len)
      end3 = len;
    var out = "";
    for (var i = start3; i < end3; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice4(buf, start3, end3) {
    var bytes = buf.slice(start3, end3);
    var res = "";
    for (var i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer5.prototype.slice = function slice10(start3, end3) {
    var len = this.length;
    start3 = ~~start3;
    end3 = end3 === void 0 ? len : ~~end3;
    if (start3 < 0) {
      start3 += len;
      if (start3 < 0)
        start3 = 0;
    } else if (start3 > len) {
      start3 = len;
    }
    if (end3 < 0) {
      end3 += len;
      if (end3 < 0)
        end3 = 0;
    } else if (end3 > len) {
      end3 = len;
    }
    if (end3 < start3)
      end3 = start3;
    var newBuf = this.subarray(start3, end3);
    Object.setPrototypeOf(newBuf, Buffer5.prototype);
    return newBuf;
  };
  function checkOffset4(offset3, ext, length4) {
    if (offset3 % 1 !== 0 || offset3 < 0)
      throw new RangeError("offset is not uint");
    if (offset3 + ext > length4)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer5.prototype.readUintLE = Buffer5.prototype.readUIntLE = function readUIntLE4(offset3, byteLength6, noAssert) {
    offset3 = offset3 >>> 0;
    byteLength6 = byteLength6 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, byteLength6, this.length);
    var val = this[offset3];
    var mul = 1;
    var i = 0;
    while (++i < byteLength6 && (mul *= 256)) {
      val += this[offset3 + i] * mul;
    }
    return val;
  };
  Buffer5.prototype.readUintBE = Buffer5.prototype.readUIntBE = function readUIntBE4(offset3, byteLength6, noAssert) {
    offset3 = offset3 >>> 0;
    byteLength6 = byteLength6 >>> 0;
    if (!noAssert) {
      checkOffset4(offset3, byteLength6, this.length);
    }
    var val = this[offset3 + --byteLength6];
    var mul = 1;
    while (byteLength6 > 0 && (mul *= 256)) {
      val += this[offset3 + --byteLength6] * mul;
    }
    return val;
  };
  Buffer5.prototype.readUint8 = Buffer5.prototype.readUInt8 = function readUInt84(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 1, this.length);
    return this[offset3];
  };
  Buffer5.prototype.readUint16LE = Buffer5.prototype.readUInt16LE = function readUInt16LE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 2, this.length);
    return this[offset3] | this[offset3 + 1] << 8;
  };
  Buffer5.prototype.readUint16BE = Buffer5.prototype.readUInt16BE = function readUInt16BE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 2, this.length);
    return this[offset3] << 8 | this[offset3 + 1];
  };
  Buffer5.prototype.readUint32LE = Buffer5.prototype.readUInt32LE = function readUInt32LE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 4, this.length);
    return (this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16) + this[offset3 + 3] * 16777216;
  };
  Buffer5.prototype.readUint32BE = Buffer5.prototype.readUInt32BE = function readUInt32BE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 4, this.length);
    return this[offset3] * 16777216 + (this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3]);
  };
  Buffer5.prototype.readIntLE = function readIntLE4(offset3, byteLength6, noAssert) {
    offset3 = offset3 >>> 0;
    byteLength6 = byteLength6 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, byteLength6, this.length);
    var val = this[offset3];
    var mul = 1;
    var i = 0;
    while (++i < byteLength6 && (mul *= 256)) {
      val += this[offset3 + i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength6);
    return val;
  };
  Buffer5.prototype.readIntBE = function readIntBE4(offset3, byteLength6, noAssert) {
    offset3 = offset3 >>> 0;
    byteLength6 = byteLength6 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, byteLength6, this.length);
    var i = byteLength6;
    var mul = 1;
    var val = this[offset3 + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset3 + --i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength6);
    return val;
  };
  Buffer5.prototype.readInt8 = function readInt84(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 1, this.length);
    if (!(this[offset3] & 128))
      return this[offset3];
    return (255 - this[offset3] + 1) * -1;
  };
  Buffer5.prototype.readInt16LE = function readInt16LE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 2, this.length);
    var val = this[offset3] | this[offset3 + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer5.prototype.readInt16BE = function readInt16BE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 2, this.length);
    var val = this[offset3 + 1] | this[offset3] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer5.prototype.readInt32LE = function readInt32LE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 4, this.length);
    return this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16 | this[offset3 + 3] << 24;
  };
  Buffer5.prototype.readInt32BE = function readInt32BE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 4, this.length);
    return this[offset3] << 24 | this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3];
  };
  Buffer5.prototype.readFloatLE = function readFloatLE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 4, this.length);
    return ieee754$1.read(this, offset3, true, 23, 4);
  };
  Buffer5.prototype.readFloatBE = function readFloatBE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 4, this.length);
    return ieee754$1.read(this, offset3, false, 23, 4);
  };
  Buffer5.prototype.readDoubleLE = function readDoubleLE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 8, this.length);
    return ieee754$1.read(this, offset3, true, 52, 8);
  };
  Buffer5.prototype.readDoubleBE = function readDoubleBE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 8, this.length);
    return ieee754$1.read(this, offset3, false, 52, 8);
  };
  function checkInt4(buf, value2, offset3, ext, max3, min3) {
    if (!Buffer5.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value2 > max3 || value2 < min3)
      throw new RangeError('"value" argument is out of bounds');
    if (offset3 + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer5.prototype.writeUintLE = Buffer5.prototype.writeUIntLE = function writeUIntLE4(value2, offset3, byteLength6, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    byteLength6 = byteLength6 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength6) - 1;
      checkInt4(this, value2, offset3, byteLength6, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset3] = value2 & 255;
    while (++i < byteLength6 && (mul *= 256)) {
      this[offset3 + i] = value2 / mul & 255;
    }
    return offset3 + byteLength6;
  };
  Buffer5.prototype.writeUintBE = Buffer5.prototype.writeUIntBE = function writeUIntBE4(value2, offset3, byteLength6, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    byteLength6 = byteLength6 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength6) - 1;
      checkInt4(this, value2, offset3, byteLength6, maxBytes, 0);
    }
    var i = byteLength6 - 1;
    var mul = 1;
    this[offset3 + i] = value2 & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset3 + i] = value2 / mul & 255;
    }
    return offset3 + byteLength6;
  };
  Buffer5.prototype.writeUint8 = Buffer5.prototype.writeUInt8 = function writeUInt84(value2, offset3, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkInt4(this, value2, offset3, 1, 255, 0);
    this[offset3] = value2 & 255;
    return offset3 + 1;
  };
  Buffer5.prototype.writeUint16LE = Buffer5.prototype.writeUInt16LE = function writeUInt16LE4(value2, offset3, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkInt4(this, value2, offset3, 2, 65535, 0);
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
    return offset3 + 2;
  };
  Buffer5.prototype.writeUint16BE = Buffer5.prototype.writeUInt16BE = function writeUInt16BE4(value2, offset3, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkInt4(this, value2, offset3, 2, 65535, 0);
    this[offset3] = value2 >>> 8;
    this[offset3 + 1] = value2 & 255;
    return offset3 + 2;
  };
  Buffer5.prototype.writeUint32LE = Buffer5.prototype.writeUInt32LE = function writeUInt32LE4(value2, offset3, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkInt4(this, value2, offset3, 4, 4294967295, 0);
    this[offset3 + 3] = value2 >>> 24;
    this[offset3 + 2] = value2 >>> 16;
    this[offset3 + 1] = value2 >>> 8;
    this[offset3] = value2 & 255;
    return offset3 + 4;
  };
  Buffer5.prototype.writeUint32BE = Buffer5.prototype.writeUInt32BE = function writeUInt32BE4(value2, offset3, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkInt4(this, value2, offset3, 4, 4294967295, 0);
    this[offset3] = value2 >>> 24;
    this[offset3 + 1] = value2 >>> 16;
    this[offset3 + 2] = value2 >>> 8;
    this[offset3 + 3] = value2 & 255;
    return offset3 + 4;
  };
  Buffer5.prototype.writeIntLE = function writeIntLE4(value2, offset3, byteLength6, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength6 - 1);
      checkInt4(this, value2, offset3, byteLength6, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset3] = value2 & 255;
    while (++i < byteLength6 && (mul *= 256)) {
      if (value2 < 0 && sub === 0 && this[offset3 + i - 1] !== 0) {
        sub = 1;
      }
      this[offset3 + i] = (value2 / mul >> 0) - sub & 255;
    }
    return offset3 + byteLength6;
  };
  Buffer5.prototype.writeIntBE = function writeIntBE4(value2, offset3, byteLength6, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength6 - 1);
      checkInt4(this, value2, offset3, byteLength6, limit - 1, -limit);
    }
    var i = byteLength6 - 1;
    var mul = 1;
    var sub = 0;
    this[offset3 + i] = value2 & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value2 < 0 && sub === 0 && this[offset3 + i + 1] !== 0) {
        sub = 1;
      }
      this[offset3 + i] = (value2 / mul >> 0) - sub & 255;
    }
    return offset3 + byteLength6;
  };
  Buffer5.prototype.writeInt8 = function writeInt84(value2, offset3, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkInt4(this, value2, offset3, 1, 127, -128);
    if (value2 < 0)
      value2 = 255 + value2 + 1;
    this[offset3] = value2 & 255;
    return offset3 + 1;
  };
  Buffer5.prototype.writeInt16LE = function writeInt16LE4(value2, offset3, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkInt4(this, value2, offset3, 2, 32767, -32768);
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
    return offset3 + 2;
  };
  Buffer5.prototype.writeInt16BE = function writeInt16BE4(value2, offset3, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkInt4(this, value2, offset3, 2, 32767, -32768);
    this[offset3] = value2 >>> 8;
    this[offset3 + 1] = value2 & 255;
    return offset3 + 2;
  };
  Buffer5.prototype.writeInt32LE = function writeInt32LE4(value2, offset3, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkInt4(this, value2, offset3, 4, 2147483647, -2147483648);
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
    this[offset3 + 2] = value2 >>> 16;
    this[offset3 + 3] = value2 >>> 24;
    return offset3 + 4;
  };
  Buffer5.prototype.writeInt32BE = function writeInt32BE4(value2, offset3, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkInt4(this, value2, offset3, 4, 2147483647, -2147483648);
    if (value2 < 0)
      value2 = 4294967295 + value2 + 1;
    this[offset3] = value2 >>> 24;
    this[offset3 + 1] = value2 >>> 16;
    this[offset3 + 2] = value2 >>> 8;
    this[offset3 + 3] = value2 & 255;
    return offset3 + 4;
  };
  function checkIEEE7544(buf, value2, offset3, ext, max3, min3) {
    if (offset3 + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset3 < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat4(buf, value2, offset3, littleEndian, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert) {
      checkIEEE7544(buf, value2, offset3, 4);
    }
    ieee754$1.write(buf, value2, offset3, littleEndian, 23, 4);
    return offset3 + 4;
  }
  Buffer5.prototype.writeFloatLE = function writeFloatLE4(value2, offset3, noAssert) {
    return writeFloat4(this, value2, offset3, true, noAssert);
  };
  Buffer5.prototype.writeFloatBE = function writeFloatBE4(value2, offset3, noAssert) {
    return writeFloat4(this, value2, offset3, false, noAssert);
  };
  function writeDouble4(buf, value2, offset3, littleEndian, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert) {
      checkIEEE7544(buf, value2, offset3, 8);
    }
    ieee754$1.write(buf, value2, offset3, littleEndian, 52, 8);
    return offset3 + 8;
  }
  Buffer5.prototype.writeDoubleLE = function writeDoubleLE4(value2, offset3, noAssert) {
    return writeDouble4(this, value2, offset3, true, noAssert);
  };
  Buffer5.prototype.writeDoubleBE = function writeDoubleBE4(value2, offset3, noAssert) {
    return writeDouble4(this, value2, offset3, false, noAssert);
  };
  Buffer5.prototype.copy = function copy6(target, targetStart, start3, end3) {
    if (!Buffer5.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start3)
      start3 = 0;
    if (!end3 && end3 !== 0)
      end3 = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end3 > 0 && end3 < start3)
      end3 = start3;
    if (end3 === start3)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start3 < 0 || start3 >= this.length)
      throw new RangeError("Index out of range");
    if (end3 < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end3 > this.length)
      end3 = this.length;
    if (target.length - targetStart < end3 - start3) {
      end3 = target.length - targetStart + start3;
    }
    var len = end3 - start3;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start3, end3);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start3, end3), targetStart);
    }
    return len;
  };
  Buffer5.prototype.fill = function fill5(val, start3, end3, encoding) {
    if (typeof val === "string") {
      if (typeof start3 === "string") {
        encoding = start3;
        start3 = 0;
        end3 = this.length;
      } else if (typeof end3 === "string") {
        encoding = end3;
        end3 = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer5.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        var code3 = val.charCodeAt(0);
        if (encoding === "utf8" && code3 < 128 || encoding === "latin1") {
          val = code3;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start3 < 0 || this.length < start3 || this.length < end3) {
      throw new RangeError("Out of range index");
    }
    if (end3 <= start3) {
      return this;
    }
    start3 = start3 >>> 0;
    end3 = end3 === void 0 ? this.length : end3 >>> 0;
    if (!val)
      val = 0;
    var i;
    if (typeof val === "number") {
      for (i = start3; i < end3; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = Buffer5.isBuffer(val) ? val : Buffer5.from(val, encoding);
      var len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end3 - start3; ++i) {
        this[i + start3] = bytes[i % len];
      }
    }
    return this;
  };
  var INVALID_BASE64_RE4 = /[^+/0-9A-Za-z-_]/g;
  function base64clean4(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE4, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes4(string, units) {
    units = units || Infinity;
    var codePoint;
    var length4 = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length4; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length4) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes4(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes4(str, units) {
    var c2, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes4(str) {
    return base64.toByteArray(base64clean4(str));
  }
  function blitBuffer4(src3, dst, offset3, length4) {
    for (var i = 0; i < length4; ++i) {
      if (i + offset3 >= dst.length || i >= src3.length)
        break;
      dst[i + offset3] = src3[i];
    }
    return i;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN5(obj) {
    return obj !== obj;
  }
  var hexSliceLookupTable = function() {
    var alphabet = "0123456789abcdef";
    var table = new Array(256);
    for (var i = 0; i < 16; ++i) {
      var i16 = i * 16;
      for (var j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j];
      }
    }
    return table;
  }();
})(buffer);
var events = { exports: {} };
var R = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === "function") {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys3(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys3(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn)
    console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value2) {
  return value2 !== value2;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once2;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: true,
  get: function get3() {
    return defaultMaxListeners;
  },
  set: function set(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit2(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) {
    args.push(arguments[i]);
  }
  var doError = type === "error";
  var events4 = this._events;
  if (events4 !== void 0)
    doError = doError && events4.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er2;
    if (args.length > 0)
      er2 = args[0];
    if (er2 instanceof Error) {
      throw er2;
    }
    var err2 = new Error("Unhandled error." + (er2 ? " (" + er2.message + ")" : ""));
    err2.context = er2;
    throw err2;
  }
  var handler = events4[type];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners3 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) {
      ReflectApply(listeners3[i], this, args);
    }
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m2;
  var events4;
  var existing;
  checkListener(listener);
  events4 = target._events;
  if (events4 === void 0) {
    events4 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events4.newListener !== void 0) {
      target.emit("newListener", type, listener.listener ? listener.listener : listener);
      events4 = target._events;
    }
    existing = events4[type];
  }
  if (existing === void 0) {
    existing = events4[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events4[type] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m2 = _getMaxListeners(target);
    if (m2 > 0 && existing.length > m2 && !existing.warned) {
      existing.warned = true;
      var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w.name = "MaxListenersExceededWarning";
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener2(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state2 = {
    fired: false,
    wrapFn: void 0,
    target,
    type,
    listener
  };
  var wrapped = onceWrapper.bind(state2);
  wrapped.listener = listener;
  state2.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener2(type, listener) {
  var list, events4, position, i, originalListener;
  checkListener(listener);
  events4 = this._events;
  if (events4 === void 0)
    return this;
  list = events4[type];
  if (list === void 0)
    return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events4[type];
      if (events4.removeListener)
        this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0)
      return this;
    if (position === 0)
      list.shift();
    else {
      spliceOne(list, position);
    }
    if (list.length === 1)
      events4[type] = list[0];
    if (events4.removeListener !== void 0)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners2(type) {
  var listeners3, events4, i;
  events4 = this._events;
  if (events4 === void 0)
    return this;
  if (events4.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events4[type] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events4[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys5 = Object.keys(events4);
    var key;
    for (i = 0; i < keys5.length; ++i) {
      key = keys5[i];
      if (key === "removeListener")
        continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners3 = events4[type];
  if (typeof listeners3 === "function") {
    this.removeListener(type, listeners3);
  } else if (listeners3 !== void 0) {
    for (i = listeners3.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners3[i]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events4 = target._events;
  if (events4 === void 0)
    return [];
  var evlistener = events4[type];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount$1.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount$1;
function listenerCount$1(type) {
  var events4 = this._events;
  if (events4 !== void 0) {
    var evlistener = events4[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
  var copy6 = new Array(n);
  for (var i = 0; i < n; ++i) {
    copy6[i] = arr[i];
  }
  return copy6;
}
function spliceOne(list, index3) {
  for (; index3 + 1 < list.length; index3++) {
    list[index3] = list[index3 + 1];
  }
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
function once2(emitter, name) {
  return new Promise(function(resolve3, reject) {
    function errorListener(err2) {
      emitter.removeListener(name, resolver);
      reject(err2);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve3([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });
    if (name !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var EE = events.exports;
var util$1 = {};
var types = {};
var shams$1 = function hasSymbols() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = shams$1;
var hasSymbols$3 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var slice$1 = Array.prototype.slice;
var toStr$4 = Object.prototype.toString;
var funcType = "[object Function]";
var implementation$8 = function bind(that) {
  var target = this;
  if (typeof target !== "function" || toStr$4.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slice$1.call(arguments, 1);
  var bound;
  var binder = function binder2() {
    if (this instanceof bound) {
      var result = target.apply(this, args.concat(slice$1.call(arguments)));
      if (Object(result) === result) {
        return result;
      }
      return this;
    } else {
      return target.apply(that, args.concat(slice$1.call(arguments)));
    }
  };
  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs.push("$" + i);
  }
  bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};
var implementation$7 = implementation$8;
var functionBind = Function.prototype.bind || implementation$7;
var bind$1 = functionBind;
var src = bind$1.call(Function.call, Object.prototype.hasOwnProperty);
var undefined$1;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;
var getEvalledConstructor = function getEvalledConstructor2(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e) {
  }
};
var $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1) {
  try {
    $gOPD$1({}, "");
  } catch (e) {
    $gOPD$1 = null;
  }
}
var throwTypeError = function throwTypeError2() {
  throw new $TypeError();
};
var ThrowTypeError = $gOPD$1 ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols$2 = hasSymbols$3();
var getProto$1 = Object.getPrototypeOf || function(x) {
  return x.__proto__;
};
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto$1(Uint8Array);
var INTRINSICS = {
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols$2 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols$2 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$2 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$2 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols$2 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols$2 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
var doEval = function doEval2(name) {
  var value2;
  if (name === "%AsyncFunction%") {
    value2 = getEvalledConstructor("async function () {}");
  } else if (name === "%GeneratorFunction%") {
    value2 = getEvalledConstructor("function* () {}");
  } else if (name === "%AsyncGeneratorFunction%") {
    value2 = getEvalledConstructor("async function* () {}");
  } else if (name === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value2 = fn.prototype;
    }
  } else if (name === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen) {
      value2 = getProto$1(gen.prototype);
    }
  }
  INTRINSICS[name] = value2;
  return value2;
};
var LEGACY_ALIASES = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind2 = functionBind;
var hasOwn$1 = src;
var $concat = bind2.call(Function.call, Array.prototype.concat);
var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
var $replace = bind2.call(Function.call, String.prototype.replace);
var $strSlice = bind2.call(Function.call, String.prototype.slice);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first = $strSlice(string, 0, 1);
  var last3 = $strSlice(string, -1);
  if (first === "%" && last3 !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
  } else if (last3 === "%" && first !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace(string, rePropName, function(match, number2, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$1(INTRINSICS, intrinsicName)) {
    var value2 = INTRINSICS[intrinsicName];
    if (value2 === needsEval) {
      value2 = doEval(intrinsicName);
    }
    if (typeof value2 === "undefined" && !allowMissing) {
      throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value: value2
    };
  }
  throw new $SyntaxError("intrinsic " + name + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== "string" || name.length === 0) {
    throw new $TypeError("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError('"allowMissing" argument must be a boolean');
  }
  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value2 = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last3 = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === "`" || last3 === '"' || last3 === "'" || last3 === "`") && first !== last3) {
      throw new $SyntaxError("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
      value2 = INTRINSICS[intrinsicRealName];
    } else if (value2 != null) {
      if (!(part in value2)) {
        if (!allowMissing) {
          throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD$1 && i + 1 >= parts.length) {
        var desc = $gOPD$1(value2, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value2 = desc.get;
        } else {
          value2 = value2[part];
        }
      } else {
        isOwn = hasOwn$1(value2, part);
        value2 = value2[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value2;
      }
    }
  }
  return value2;
};
var callBind$3 = { exports: {} };
(function(module) {
  var bind5 = functionBind;
  var GetIntrinsic5 = getIntrinsic;
  var $apply = GetIntrinsic5("%Function.prototype.apply%");
  var $call = GetIntrinsic5("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic5("%Reflect.apply%", true) || bind5.call($call, $apply);
  var $gOPD3 = GetIntrinsic5("%Object.getOwnPropertyDescriptor%", true);
  var $defineProperty = GetIntrinsic5("%Object.defineProperty%", true);
  var $max = GetIntrinsic5("%Math.max%");
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", {
        value: 1
      });
    } catch (e) {
      $defineProperty = null;
    }
  }
  module.exports = function callBind3(originalFunction) {
    var func = $reflectApply(bind5, $call, arguments);
    if ($gOPD3 && $defineProperty) {
      var desc = $gOPD3(func, "length");
      if (desc.configurable) {
        $defineProperty(func, "length", {
          value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
        });
      }
    }
    return func;
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind5, $apply, arguments);
  };
  if ($defineProperty) {
    $defineProperty(module.exports, "apply", {
      value: applyBind
    });
  } else {
    module.exports.apply = applyBind;
  }
})(callBind$3);
var GetIntrinsic$1 = getIntrinsic;
var callBind$2 = callBind$3.exports;
var $indexOf$1 = callBind$2(GetIntrinsic$1("String.prototype.indexOf"));
var callBound$3 = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic$1(name, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf$1(name, ".prototype.") > -1) {
    return callBind$2(intrinsic);
  }
  return intrinsic;
};
var hasToStringTag$3 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
var callBound$2 = callBound$3;
var $toString$2 = callBound$2("Object.prototype.toString");
var isStandardArguments = function isArguments(value2) {
  if (hasToStringTag$3 && value2 && typeof value2 === "object" && Symbol.toStringTag in value2) {
    return false;
  }
  return $toString$2(value2) === "[object Arguments]";
};
var isLegacyArguments = function isArguments2(value2) {
  if (isStandardArguments(value2)) {
    return true;
  }
  return value2 !== null && typeof value2 === "object" && typeof value2.length === "number" && value2.length >= 0 && $toString$2(value2) !== "[object Array]" && $toString$2(value2.callee) === "[object Function]";
};
var supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments$1 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
var hasSymbols$1 = shams$1;
var shams = function hasToStringTagShams() {
  return hasSymbols$1() && !!Symbol.toStringTag;
};
var toStr$3 = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag$2 = shams();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function getGeneratorFunc2() {
  if (!hasToStringTag$2) {
    return false;
  }
  try {
    return Function("return function*() {}")();
  } catch (e) {
  }
};
var GeneratorFunction;
var isGeneratorFunction = function isGeneratorFunction2(fn) {
  if (typeof fn !== "function") {
    return false;
  }
  if (isFnRegex.test(fnToStr.call(fn))) {
    return true;
  }
  if (!hasToStringTag$2) {
    var str = toStr$3.call(fn);
    return str === "[object GeneratorFunction]";
  }
  if (!getProto) {
    return false;
  }
  if (typeof GeneratorFunction === "undefined") {
    var generatorFunc = getGeneratorFunc();
    GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
  }
  return getProto(fn) === GeneratorFunction;
};
var hasOwn = Object.prototype.hasOwnProperty;
var toString2 = Object.prototype.toString;
var foreach = function forEach(obj, fn, ctx) {
  if (toString2.call(fn) !== "[object Function]") {
    throw new TypeError("iterator must be a function");
  }
  var l2 = obj.length;
  if (l2 === +l2) {
    for (var i = 0; i < l2; i++) {
      fn.call(ctx, obj[i], i, obj);
    }
  } else {
    for (var k in obj) {
      if (hasOwn.call(obj, k)) {
        fn.call(ctx, obj[k], k, obj);
      }
    }
  }
};
var possibleNames = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"];
var g$2 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
var availableTypedArrays$2 = function availableTypedArrays() {
  var out = [];
  for (var i = 0; i < possibleNames.length; i++) {
    if (typeof g$2[possibleNames[i]] === "function") {
      out[out.length] = possibleNames[i];
    }
  }
  return out;
};
var GetIntrinsic2 = getIntrinsic;
var $gOPD = GetIntrinsic2("%Object.getOwnPropertyDescriptor%", true);
if ($gOPD) {
  try {
    $gOPD([], "length");
  } catch (e) {
    $gOPD = null;
  }
}
var getOwnPropertyDescriptor = $gOPD;
var forEach$2 = foreach;
var availableTypedArrays$1 = availableTypedArrays$2;
var callBound$1 = callBound$3;
var $toString$1 = callBound$1("Object.prototype.toString");
var hasToStringTag$1 = shams();
var g$1 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
var typedArrays$1 = availableTypedArrays$1();
var $indexOf = callBound$1("Array.prototype.indexOf", true) || function indexOf2(array, value2) {
  for (var i = 0; i < array.length; i += 1) {
    if (array[i] === value2) {
      return i;
    }
  }
  return -1;
};
var $slice$1 = callBound$1("String.prototype.slice");
var toStrTags$1 = {};
var gOPD$1 = getOwnPropertyDescriptor;
var getPrototypeOf$1 = Object.getPrototypeOf;
if (hasToStringTag$1 && gOPD$1 && getPrototypeOf$1) {
  forEach$2(typedArrays$1, function(typedArray) {
    var arr = new g$1[typedArray]();
    if (Symbol.toStringTag in arr) {
      var proto = getPrototypeOf$1(arr);
      var descriptor = gOPD$1(proto, Symbol.toStringTag);
      if (!descriptor) {
        var superProto = getPrototypeOf$1(proto);
        descriptor = gOPD$1(superProto, Symbol.toStringTag);
      }
      toStrTags$1[typedArray] = descriptor.get;
    }
  });
}
var tryTypedArrays$1 = function tryAllTypedArrays(value2) {
  var anyTrue = false;
  forEach$2(toStrTags$1, function(getter, typedArray) {
    if (!anyTrue) {
      try {
        anyTrue = getter.call(value2) === typedArray;
      } catch (e) {
      }
    }
  });
  return anyTrue;
};
var isTypedArray$1 = function isTypedArray(value2) {
  if (!value2 || typeof value2 !== "object") {
    return false;
  }
  if (!hasToStringTag$1 || !(Symbol.toStringTag in value2)) {
    var tag = $slice$1($toString$1(value2), 8, -1);
    return $indexOf(typedArrays$1, tag) > -1;
  }
  if (!gOPD$1) {
    return false;
  }
  return tryTypedArrays$1(value2);
};
var forEach$1 = foreach;
var availableTypedArrays2 = availableTypedArrays$2;
var callBound = callBound$3;
var $toString = callBound("Object.prototype.toString");
var hasToStringTag = shams();
var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
var typedArrays = availableTypedArrays2();
var $slice = callBound("String.prototype.slice");
var toStrTags = {};
var gOPD = getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
if (hasToStringTag && gOPD && getPrototypeOf) {
  forEach$1(typedArrays, function(typedArray) {
    if (typeof g[typedArray] === "function") {
      var arr = new g[typedArray]();
      if (Symbol.toStringTag in arr) {
        var proto = getPrototypeOf(arr);
        var descriptor = gOPD(proto, Symbol.toStringTag);
        if (!descriptor) {
          var superProto = getPrototypeOf(proto);
          descriptor = gOPD(superProto, Symbol.toStringTag);
        }
        toStrTags[typedArray] = descriptor.get;
      }
    }
  });
}
var tryTypedArrays = function tryAllTypedArrays2(value2) {
  var foundName = false;
  forEach$1(toStrTags, function(getter, typedArray) {
    if (!foundName) {
      try {
        var name = getter.call(value2);
        if (name === typedArray) {
          foundName = name;
        }
      } catch (e) {
      }
    }
  });
  return foundName;
};
var isTypedArray2 = isTypedArray$1;
var whichTypedArray = function whichTypedArray2(value2) {
  if (!isTypedArray2(value2)) {
    return false;
  }
  if (!hasToStringTag || !(Symbol.toStringTag in value2)) {
    return $slice($toString(value2), 8, -1);
  }
  return tryTypedArrays(value2);
};
(function(exports) {
  var isArgumentsObject = isArguments$1;
  var isGeneratorFunction$1 = isGeneratorFunction;
  var whichTypedArray$1 = whichTypedArray;
  var isTypedArray5 = isTypedArray$1;
  function uncurryThis3(f) {
    return f.call.bind(f);
  }
  var BigIntSupported = typeof BigInt !== "undefined";
  var SymbolSupported = typeof Symbol !== "undefined";
  var ObjectToString = uncurryThis3(Object.prototype.toString);
  var numberValue = uncurryThis3(Number.prototype.valueOf);
  var stringValue = uncurryThis3(String.prototype.valueOf);
  var booleanValue = uncurryThis3(Boolean.prototype.valueOf);
  if (BigIntSupported) {
    var bigIntValue = uncurryThis3(BigInt.prototype.valueOf);
  }
  if (SymbolSupported) {
    var symbolValue = uncurryThis3(Symbol.prototype.valueOf);
  }
  function checkBoxedPrimitive(value2, prototypeValueOf) {
    if (typeof value2 !== "object") {
      return false;
    }
    try {
      prototypeValueOf(value2);
      return true;
    } catch (e) {
      return false;
    }
  }
  exports.isArgumentsObject = isArgumentsObject;
  exports.isGeneratorFunction = isGeneratorFunction$1;
  exports.isTypedArray = isTypedArray5;
  function isPromise3(input) {
    return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
  }
  exports.isPromise = isPromise3;
  function isArrayBufferView3(value2) {
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      return ArrayBuffer.isView(value2);
    }
    return isTypedArray5(value2) || isDataView(value2);
  }
  exports.isArrayBufferView = isArrayBufferView3;
  function isUint8Array(value2) {
    return whichTypedArray$1(value2) === "Uint8Array";
  }
  exports.isUint8Array = isUint8Array;
  function isUint8ClampedArray(value2) {
    return whichTypedArray$1(value2) === "Uint8ClampedArray";
  }
  exports.isUint8ClampedArray = isUint8ClampedArray;
  function isUint16Array(value2) {
    return whichTypedArray$1(value2) === "Uint16Array";
  }
  exports.isUint16Array = isUint16Array;
  function isUint32Array(value2) {
    return whichTypedArray$1(value2) === "Uint32Array";
  }
  exports.isUint32Array = isUint32Array;
  function isInt8Array(value2) {
    return whichTypedArray$1(value2) === "Int8Array";
  }
  exports.isInt8Array = isInt8Array;
  function isInt16Array(value2) {
    return whichTypedArray$1(value2) === "Int16Array";
  }
  exports.isInt16Array = isInt16Array;
  function isInt32Array(value2) {
    return whichTypedArray$1(value2) === "Int32Array";
  }
  exports.isInt32Array = isInt32Array;
  function isFloat32Array3(value2) {
    return whichTypedArray$1(value2) === "Float32Array";
  }
  exports.isFloat32Array = isFloat32Array3;
  function isFloat64Array3(value2) {
    return whichTypedArray$1(value2) === "Float64Array";
  }
  exports.isFloat64Array = isFloat64Array3;
  function isBigInt64Array(value2) {
    return whichTypedArray$1(value2) === "BigInt64Array";
  }
  exports.isBigInt64Array = isBigInt64Array;
  function isBigUint64Array(value2) {
    return whichTypedArray$1(value2) === "BigUint64Array";
  }
  exports.isBigUint64Array = isBigUint64Array;
  function isMapToString(value2) {
    return ObjectToString(value2) === "[object Map]";
  }
  isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
  function isMap3(value2) {
    if (typeof Map === "undefined") {
      return false;
    }
    return isMapToString.working ? isMapToString(value2) : value2 instanceof Map;
  }
  exports.isMap = isMap3;
  function isSetToString(value2) {
    return ObjectToString(value2) === "[object Set]";
  }
  isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
  function isSet3(value2) {
    if (typeof Set === "undefined") {
      return false;
    }
    return isSetToString.working ? isSetToString(value2) : value2 instanceof Set;
  }
  exports.isSet = isSet3;
  function isWeakMapToString(value2) {
    return ObjectToString(value2) === "[object WeakMap]";
  }
  isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
  function isWeakMap(value2) {
    if (typeof WeakMap === "undefined") {
      return false;
    }
    return isWeakMapToString.working ? isWeakMapToString(value2) : value2 instanceof WeakMap;
  }
  exports.isWeakMap = isWeakMap;
  function isWeakSetToString(value2) {
    return ObjectToString(value2) === "[object WeakSet]";
  }
  isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
  function isWeakSet(value2) {
    return isWeakSetToString(value2);
  }
  exports.isWeakSet = isWeakSet;
  function isArrayBufferToString(value2) {
    return ObjectToString(value2) === "[object ArrayBuffer]";
  }
  isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
  function isArrayBuffer(value2) {
    if (typeof ArrayBuffer === "undefined") {
      return false;
    }
    return isArrayBufferToString.working ? isArrayBufferToString(value2) : value2 instanceof ArrayBuffer;
  }
  exports.isArrayBuffer = isArrayBuffer;
  function isDataViewToString(value2) {
    return ObjectToString(value2) === "[object DataView]";
  }
  isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
  function isDataView(value2) {
    if (typeof DataView === "undefined") {
      return false;
    }
    return isDataViewToString.working ? isDataViewToString(value2) : value2 instanceof DataView;
  }
  exports.isDataView = isDataView;
  var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
  function isSharedArrayBufferToString(value2) {
    return ObjectToString(value2) === "[object SharedArrayBuffer]";
  }
  function isSharedArrayBuffer(value2) {
    if (typeof SharedArrayBufferCopy === "undefined") {
      return false;
    }
    if (typeof isSharedArrayBufferToString.working === "undefined") {
      isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
    }
    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value2) : value2 instanceof SharedArrayBufferCopy;
  }
  exports.isSharedArrayBuffer = isSharedArrayBuffer;
  function isAsyncFunction(value2) {
    return ObjectToString(value2) === "[object AsyncFunction]";
  }
  exports.isAsyncFunction = isAsyncFunction;
  function isMapIterator(value2) {
    return ObjectToString(value2) === "[object Map Iterator]";
  }
  exports.isMapIterator = isMapIterator;
  function isSetIterator(value2) {
    return ObjectToString(value2) === "[object Set Iterator]";
  }
  exports.isSetIterator = isSetIterator;
  function isGeneratorObject(value2) {
    return ObjectToString(value2) === "[object Generator]";
  }
  exports.isGeneratorObject = isGeneratorObject;
  function isWebAssemblyCompiledModule(value2) {
    return ObjectToString(value2) === "[object WebAssembly.Module]";
  }
  exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
  function isNumberObject3(value2) {
    return checkBoxedPrimitive(value2, numberValue);
  }
  exports.isNumberObject = isNumberObject3;
  function isStringObject3(value2) {
    return checkBoxedPrimitive(value2, stringValue);
  }
  exports.isStringObject = isStringObject3;
  function isBooleanObject3(value2) {
    return checkBoxedPrimitive(value2, booleanValue);
  }
  exports.isBooleanObject = isBooleanObject3;
  function isBigIntObject3(value2) {
    return BigIntSupported && checkBoxedPrimitive(value2, bigIntValue);
  }
  exports.isBigIntObject = isBigIntObject3;
  function isSymbolObject3(value2) {
    return SymbolSupported && checkBoxedPrimitive(value2, symbolValue);
  }
  exports.isSymbolObject = isSymbolObject3;
  function isBoxedPrimitive3(value2) {
    return isNumberObject3(value2) || isStringObject3(value2) || isBooleanObject3(value2) || isBigIntObject3(value2) || isSymbolObject3(value2);
  }
  exports.isBoxedPrimitive = isBoxedPrimitive3;
  function isAnyArrayBuffer3(value2) {
    return typeof Uint8Array !== "undefined" && (isArrayBuffer(value2) || isSharedArrayBuffer(value2));
  }
  exports.isAnyArrayBuffer = isAnyArrayBuffer3;
  ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
    Object.defineProperty(exports, method, {
      enumerable: false,
      value: function value2() {
        throw new Error(method + " is not supported in userland");
      }
    });
  });
})(types);
var isBufferBrowser = function isBuffer2(arg) {
  return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
};
var inherits_browser = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  inherits_browser.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function TempCtor2() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
(function(exports) {
  var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
    var keys5 = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys5.length; i++) {
      descriptors[keys5[i]] = Object.getOwnPropertyDescriptor(obj, keys5[i]);
    }
    return descriptors;
  };
  var formatRegExp = /%[sdj%]/g;
  exports.format = function(f) {
    if (!isString3(f)) {
      var objects = [];
      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect6(arguments[i]));
      }
      return objects.join(" ");
    }
    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x2) {
      if (x2 === "%%")
        return "%";
      if (i >= len)
        return x2;
      switch (x2) {
        case "%s":
          return String(args[i++]);
        case "%d":
          return Number(args[i++]);
        case "%j":
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return "[Circular]";
          }
        default:
          return x2;
      }
    });
    for (var x = args[i]; i < len; x = args[++i]) {
      if (isNull(x) || !isObject(x)) {
        str += " " + x;
      } else {
        str += " " + inspect6(x);
      }
    }
    return str;
  };
  exports.deprecate = function(fn, msg2) {
    if (typeof browser$1$1 !== "undefined" && browser$1$1.noDeprecation === true) {
      return fn;
    }
    if (typeof browser$1$1 === "undefined") {
      return function() {
        return exports.deprecate(fn, msg2).apply(this, arguments);
      };
    }
    var warned3 = false;
    function deprecated() {
      if (!warned3) {
        {
          console.error(msg2);
        }
        warned3 = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  };
  var debugs = {};
  var debugEnvRegex = /^$/;
  if (browser$1$1.env.NODE_DEBUG) {
    var debugEnv = browser$1$1.env.NODE_DEBUG;
    debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
    debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
  }
  exports.debuglog = function(set7) {
    set7 = set7.toUpperCase();
    if (!debugs[set7]) {
      if (debugEnvRegex.test(set7)) {
        var pid = browser$1$1.pid;
        debugs[set7] = function() {
          var msg2 = exports.format.apply(exports, arguments);
          console.error("%s %d: %s", set7, pid, msg2);
        };
      } else {
        debugs[set7] = function() {
        };
      }
    }
    return debugs[set7];
  };
  function inspect6(obj, opts2) {
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    if (arguments.length >= 3)
      ctx.depth = arguments[2];
    if (arguments.length >= 4)
      ctx.colors = arguments[3];
    if (isBoolean(opts2)) {
      ctx.showHidden = opts2;
    } else if (opts2) {
      exports._extend(ctx, opts2);
    }
    if (isUndefined(ctx.showHidden))
      ctx.showHidden = false;
    if (isUndefined(ctx.depth))
      ctx.depth = 2;
    if (isUndefined(ctx.colors))
      ctx.colors = false;
    if (isUndefined(ctx.customInspect))
      ctx.customInspect = true;
    if (ctx.colors)
      ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }
  exports.inspect = inspect6;
  inspect6.colors = {
    "bold": [1, 22],
    "italic": [3, 23],
    "underline": [4, 24],
    "inverse": [7, 27],
    "white": [37, 39],
    "grey": [90, 39],
    "black": [30, 39],
    "blue": [34, 39],
    "cyan": [36, 39],
    "green": [32, 39],
    "magenta": [35, 39],
    "red": [31, 39],
    "yellow": [33, 39]
  };
  inspect6.styles = {
    "special": "cyan",
    "number": "yellow",
    "boolean": "yellow",
    "undefined": "grey",
    "null": "bold",
    "string": "green",
    "date": "magenta",
    // "name": intentionally not styling
    "regexp": "red"
  };
  function stylizeWithColor(str, styleType) {
    var style = inspect6.styles[styleType];
    if (style) {
      return "\x1B[" + inspect6.colors[style][0] + "m" + str + "\x1B[" + inspect6.colors[style][1] + "m";
    } else {
      return str;
    }
  }
  function stylizeNoColor(str, styleType) {
    return str;
  }
  function arrayToHash(array) {
    var hash = {};
    array.forEach(function(val, idx) {
      hash[val] = true;
    });
    return hash;
  }
  function formatValue(ctx, value2, recurseTimes) {
    if (ctx.customInspect && value2 && isFunction5(value2.inspect) && // Filter out the util module, it's inspect function is special
    value2.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
    !(value2.constructor && value2.constructor.prototype === value2)) {
      var ret = value2.inspect(recurseTimes, ctx);
      if (!isString3(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }
    var primitive = formatPrimitive(ctx, value2);
    if (primitive) {
      return primitive;
    }
    var keys5 = Object.keys(value2);
    var visibleKeys = arrayToHash(keys5);
    if (ctx.showHidden) {
      keys5 = Object.getOwnPropertyNames(value2);
    }
    if (isError(value2) && (keys5.indexOf("message") >= 0 || keys5.indexOf("description") >= 0)) {
      return formatError(value2);
    }
    if (keys5.length === 0) {
      if (isFunction5(value2)) {
        var name = value2.name ? ": " + value2.name : "";
        return ctx.stylize("[Function" + name + "]", "special");
      }
      if (isRegExp3(value2)) {
        return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
      }
      if (isDate3(value2)) {
        return ctx.stylize(Date.prototype.toString.call(value2), "date");
      }
      if (isError(value2)) {
        return formatError(value2);
      }
    }
    var base = "", array = false, braces = ["{", "}"];
    if (isArray4(value2)) {
      array = true;
      braces = ["[", "]"];
    }
    if (isFunction5(value2)) {
      var n = value2.name ? ": " + value2.name : "";
      base = " [Function" + n + "]";
    }
    if (isRegExp3(value2)) {
      base = " " + RegExp.prototype.toString.call(value2);
    }
    if (isDate3(value2)) {
      base = " " + Date.prototype.toUTCString.call(value2);
    }
    if (isError(value2)) {
      base = " " + formatError(value2);
    }
    if (keys5.length === 0 && (!array || value2.length == 0)) {
      return braces[0] + base + braces[1];
    }
    if (recurseTimes < 0) {
      if (isRegExp3(value2)) {
        return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
      } else {
        return ctx.stylize("[Object]", "special");
      }
    }
    ctx.seen.push(value2);
    var output;
    if (array) {
      output = formatArray(ctx, value2, recurseTimes, visibleKeys, keys5);
    } else {
      output = keys5.map(function(key) {
        return formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array);
      });
    }
    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
  }
  function formatPrimitive(ctx, value2) {
    if (isUndefined(value2))
      return ctx.stylize("undefined", "undefined");
    if (isString3(value2)) {
      var simple = "'" + JSON.stringify(value2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return ctx.stylize(simple, "string");
    }
    if (isNumber5(value2))
      return ctx.stylize("" + value2, "number");
    if (isBoolean(value2))
      return ctx.stylize("" + value2, "boolean");
    if (isNull(value2))
      return ctx.stylize("null", "null");
  }
  function formatError(value2) {
    return "[" + Error.prototype.toString.call(value2) + "]";
  }
  function formatArray(ctx, value2, recurseTimes, visibleKeys, keys5) {
    var output = [];
    for (var i = 0, l2 = value2.length; i < l2; ++i) {
      if (hasOwnProperty3(value2, String(i))) {
        output.push(formatProperty(ctx, value2, recurseTimes, visibleKeys, String(i), true));
      } else {
        output.push("");
      }
    }
    keys5.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value2, recurseTimes, visibleKeys, key, true));
      }
    });
    return output;
  }
  function formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value2, key) || {
      value: value2[key]
    };
    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize("[Getter/Setter]", "special");
      } else {
        str = ctx.stylize("[Getter]", "special");
      }
    } else {
      if (desc.set) {
        str = ctx.stylize("[Setter]", "special");
      }
    }
    if (!hasOwnProperty3(visibleKeys, key)) {
      name = "[" + key + "]";
    }
    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str.indexOf("\n") > -1) {
          if (array) {
            str = str.split("\n").map(function(line2) {
              return "  " + line2;
            }).join("\n").substr(2);
          } else {
            str = "\n" + str.split("\n").map(function(line2) {
              return "   " + line2;
            }).join("\n");
          }
        }
      } else {
        str = ctx.stylize("[Circular]", "special");
      }
    }
    if (isUndefined(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }
      name = JSON.stringify("" + key);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, "name");
      } else {
        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, "string");
      }
    }
    return name + ": " + str;
  }
  function reduceToSingleString(output, base, braces) {
    var length4 = output.reduce(function(prev, cur) {
      if (cur.indexOf("\n") >= 0)
        ;
      return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (length4 > 60) {
      return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
    }
    return braces[0] + base + " " + output.join(", ") + " " + braces[1];
  }
  exports.types = types;
  function isArray4(ar2) {
    return Array.isArray(ar2);
  }
  exports.isArray = isArray4;
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  exports.isBoolean = isBoolean;
  function isNull(arg) {
    return arg === null;
  }
  exports.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports.isNullOrUndefined = isNullOrUndefined;
  function isNumber5(arg) {
    return typeof arg === "number";
  }
  exports.isNumber = isNumber5;
  function isString3(arg) {
    return typeof arg === "string";
  }
  exports.isString = isString3;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  exports.isSymbol = isSymbol;
  function isUndefined(arg) {
    return arg === void 0;
  }
  exports.isUndefined = isUndefined;
  function isRegExp3(re) {
    return isObject(re) && objectToString3(re) === "[object RegExp]";
  }
  exports.isRegExp = isRegExp3;
  exports.types.isRegExp = isRegExp3;
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports.isObject = isObject;
  function isDate3(d) {
    return isObject(d) && objectToString3(d) === "[object Date]";
  }
  exports.isDate = isDate3;
  exports.types.isDate = isDate3;
  function isError(e) {
    return isObject(e) && (objectToString3(e) === "[object Error]" || e instanceof Error);
  }
  exports.isError = isError;
  exports.types.isNativeError = isError;
  function isFunction5(arg) {
    return typeof arg === "function";
  }
  exports.isFunction = isFunction5;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
  }
  exports.isPrimitive = isPrimitive;
  exports.isBuffer = isBufferBrowser;
  function objectToString3(o) {
    return Object.prototype.toString.call(o);
  }
  function pad3(n) {
    return n < 10 ? "0" + n.toString(10) : n.toString(10);
  }
  var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  function timestamp() {
    var d = /* @__PURE__ */ new Date();
    var time = [pad3(d.getHours()), pad3(d.getMinutes()), pad3(d.getSeconds())].join(":");
    return [d.getDate(), months[d.getMonth()], time].join(" ");
  }
  exports.log = function() {
    console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
  };
  exports.inherits = inherits_browser.exports;
  exports._extend = function(origin, add3) {
    if (!add3 || !isObject(add3))
      return origin;
    var keys5 = Object.keys(add3);
    var i = keys5.length;
    while (i--) {
      origin[keys5[i]] = add3[keys5[i]];
    }
    return origin;
  };
  function hasOwnProperty3(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
  exports.promisify = function promisify(original) {
    if (typeof original !== "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
      var fn = original[kCustomPromisifiedSymbol];
      if (typeof fn !== "function") {
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      }
      Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return fn;
    }
    function fn() {
      var promiseResolve, promiseReject;
      var promise = new Promise(function(resolve3, reject) {
        promiseResolve = resolve3;
        promiseReject = reject;
      });
      var args = [];
      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }
      args.push(function(err2, value2) {
        if (err2) {
          promiseReject(err2);
        } else {
          promiseResolve(value2);
        }
      });
      try {
        original.apply(this, args);
      } catch (err2) {
        promiseReject(err2);
      }
      return promise;
    }
    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    if (kCustomPromisifiedSymbol)
      Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
  };
  exports.promisify.custom = kCustomPromisifiedSymbol;
  function callbackifyOnRejected(reason, cb) {
    if (!reason) {
      var newReason = new Error("Promise was rejected with a falsy value");
      newReason.reason = reason;
      reason = newReason;
    }
    return cb(reason);
  }
  function callbackify(original) {
    if (typeof original !== "function") {
      throw new TypeError('The "original" argument must be of type Function');
    }
    function callbackified() {
      var args = [];
      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }
      var maybeCb = args.pop();
      if (typeof maybeCb !== "function") {
        throw new TypeError("The last argument must be of type Function");
      }
      var self2 = this;
      var cb = function cb2() {
        return maybeCb.apply(self2, arguments);
      };
      original.apply(this, args).then(function(ret) {
        browser$1$1.nextTick(cb.bind(null, null, ret));
      }, function(rej) {
        browser$1$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
      });
    }
    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
    return callbackified;
  }
  exports.callbackify = callbackify;
})(util$1);
var browser = { exports: {} };
var process2 = browser.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process2.nextTick = function(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process2.title = "browser";
process2.browser = true;
process2.env = {};
process2.argv = [];
process2.version = "";
process2.versions = {};
function noop3() {
}
process2.on = noop3;
process2.addListener = noop3;
process2.once = noop3;
process2.off = noop3;
process2.removeListener = noop3;
process2.removeAllListeners = noop3;
process2.emit = noop3;
process2.prependListener = noop3;
process2.prependOnceListener = noop3;
process2.listeners = function(name) {
  return [];
};
process2.binding = function(name) {
  throw new Error("process.binding is not supported");
};
process2.cwd = function() {
  return "/";
};
process2.chdir = function(dir) {
  throw new Error("process.chdir is not supported");
};
process2.umask = function() {
  return 0;
};
function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
BufferList.prototype.push = function(v2) {
  var entry = { data: v2, next: null };
  if (this.length > 0)
    this.tail.next = entry;
  else
    this.head = entry;
  this.tail = entry;
  ++this.length;
};
BufferList.prototype.unshift = function(v2) {
  var entry = { data: v2, next: this.head };
  if (this.length === 0)
    this.tail = entry;
  this.head = entry;
  ++this.length;
};
BufferList.prototype.shift = function() {
  if (this.length === 0)
    return;
  var ret = this.head.data;
  if (this.length === 1)
    this.head = this.tail = null;
  else
    this.head = this.head.next;
  --this.length;
  return ret;
};
BufferList.prototype.clear = function() {
  this.head = this.tail = null;
  this.length = 0;
};
BufferList.prototype.join = function(s2) {
  if (this.length === 0)
    return "";
  var p = this.head;
  var ret = "" + p.data;
  while (p = p.next) {
    ret += s2 + p.data;
  }
  return ret;
};
BufferList.prototype.concat = function(n) {
  if (this.length === 0)
    return buffer.Buffer.alloc(0);
  if (this.length === 1)
    return this.head.data;
  var ret = buffer.Buffer.allocUnsafe(n >>> 0);
  var p = this.head;
  var i = 0;
  while (p) {
    p.data.copy(ret, i);
    i += p.data.length;
    p = p.next;
  }
  return ret;
};
var safeBuffer = { exports: {} };
(function(module, exports) {
  var buffer$1 = buffer;
  var Buffer5 = buffer$1.Buffer;
  function copyProps(src3, dst) {
    for (var key in src3) {
      dst[key] = src3[key];
    }
  }
  if (Buffer5.from && Buffer5.alloc && Buffer5.allocUnsafe && Buffer5.allocUnsafeSlow) {
    module.exports = buffer$1;
  } else {
    copyProps(buffer$1, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length4) {
    return Buffer5(arg, encodingOrOffset, length4);
  }
  SafeBuffer.prototype = Object.create(Buffer5.prototype);
  copyProps(Buffer5, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length4) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer5(arg, encodingOrOffset, length4);
  };
  SafeBuffer.alloc = function(size, fill5, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer5(size);
    if (fill5 !== void 0) {
      if (typeof encoding === "string") {
        buf.fill(fill5, encoding);
      } else {
        buf.fill(fill5);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer5(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer$1.SlowBuffer(size);
  };
})(safeBuffer, safeBuffer.exports);
var Buffer2 = safeBuffer.exports.Buffer;
var isEncoding2 = Buffer2.isEncoding || function(encoding) {
  encoding = "" + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function _normalizeEncoding(enc) {
  if (!enc)
    return "utf8";
  var retried;
  while (true) {
    switch (enc) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return enc;
      default:
        if (retried)
          return;
        enc = ("" + enc).toLowerCase();
        retried = true;
    }
  }
}
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding2 || !isEncoding2(enc)))
    throw new Error("Unknown encoding: " + enc);
  return nenc || enc;
}
var StringDecoder_1 = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case "utf16le":
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case "utf8":
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case "base64":
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer2.allocUnsafe(nb);
}
StringDecoder.prototype.write = function(buf) {
  if (buf.length === 0)
    return "";
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === void 0)
      return "";
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length)
    return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || "";
};
StringDecoder.prototype.end = utf8End;
StringDecoder.prototype.text = utf8Text;
StringDecoder.prototype.fillLast = function(buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};
function utf8CheckByte(byte) {
  if (byte <= 127)
    return 0;
  else if (byte >> 5 === 6)
    return 2;
  else if (byte >> 4 === 14)
    return 3;
  else if (byte >> 3 === 30)
    return 4;
  return byte >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(self2, buf, i) {
  var j = buf.length - 1;
  if (j < i)
    return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0)
      self2.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2)
    return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0)
      self2.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2)
    return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2)
        nb = 0;
      else
        self2.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}
function utf8CheckExtraBytes(self2, buf, p) {
  if ((buf[0] & 192) !== 128) {
    self2.lastNeed = 0;
    return "�";
  }
  if (self2.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 192) !== 128) {
      self2.lastNeed = 1;
      return "�";
    }
    if (self2.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 192) !== 128) {
        self2.lastNeed = 2;
        return "�";
      }
    }
  }
}
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf);
  if (r !== void 0)
    return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed)
    return buf.toString("utf8", i);
  this.lastTotal = total;
  var end3 = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end3);
  return buf.toString("utf8", i, end3);
}
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed)
    return r + "�";
  return r;
}
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString("utf16le", i);
    if (r) {
      var c2 = r.charCodeAt(r.length - 1);
      if (c2 >= 55296 && c2 <= 56319) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString("utf16le", i, buf.length - 1);
}
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed) {
    var end3 = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString("utf16le", 0, end3);
  }
  return r;
}
function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0)
    return buf.toString("base64", i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString("base64", i, buf.length - n);
}
function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed)
    return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
  return r;
}
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}
function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : "";
}
Readable.ReadableState = ReadableState;
var debug = util$1.debuglog("stream");
util$1.inherits(Readable, EE);
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount(emitter, type) {
  return emitter.listeners(type).length;
}
function ReadableState(options, stream2) {
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream2 instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    this.decoder = new StringDecoder_1(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);
  this._readableState = new ReadableState(options, this);
  this.readable = true;
  if (options && typeof options.read === "function")
    this._read = options.read;
  EE.call(this);
}
Readable.prototype.push = function(chunk, encoding) {
  var state2 = this._readableState;
  if (!state2.objectMode && typeof chunk === "string") {
    encoding = encoding || state2.defaultEncoding;
    if (encoding !== state2.encoding) {
      chunk = Buffer$1.from(chunk, encoding);
      encoding = "";
    }
  }
  return readableAddChunk(this, state2, chunk, encoding, false);
};
Readable.prototype.unshift = function(chunk) {
  var state2 = this._readableState;
  return readableAddChunk(this, state2, chunk, "", true);
};
Readable.prototype.isPaused = function() {
  return this._readableState.flowing === false;
};
function readableAddChunk(stream2, state2, chunk, encoding, addToFront) {
  var er2 = chunkInvalid(state2, chunk);
  if (er2) {
    stream2.emit("error", er2);
  } else if (chunk === null) {
    state2.reading = false;
    onEofChunk(stream2, state2);
  } else if (state2.objectMode || chunk && chunk.length > 0) {
    if (state2.ended && !addToFront) {
      var e = new Error("stream.push() after EOF");
      stream2.emit("error", e);
    } else if (state2.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event");
      stream2.emit("error", _e);
    } else {
      var skipAdd;
      if (state2.decoder && !addToFront && !encoding) {
        chunk = state2.decoder.write(chunk);
        skipAdd = !state2.objectMode && chunk.length === 0;
      }
      if (!addToFront)
        state2.reading = false;
      if (!skipAdd) {
        if (state2.flowing && state2.length === 0 && !state2.sync) {
          stream2.emit("data", chunk);
          stream2.read(0);
        } else {
          state2.length += state2.objectMode ? 1 : chunk.length;
          if (addToFront)
            state2.buffer.unshift(chunk);
          else
            state2.buffer.push(chunk);
          if (state2.needReadable)
            emitReadable(stream2);
        }
      }
      maybeReadMore(stream2, state2);
    }
  } else if (!addToFront) {
    state2.reading = false;
  }
  return needMoreData(state2);
}
function needMoreData(state2) {
  return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
}
Readable.prototype.setEncoding = function(enc) {
  this._readableState.decoder = new StringDecoder_1(enc);
  this._readableState.encoding = enc;
  return this;
};
var MAX_HWM = 8388608;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}
function howMuchToRead(n, state2) {
  if (n <= 0 || state2.length === 0 && state2.ended)
    return 0;
  if (state2.objectMode)
    return 1;
  if (n !== n) {
    if (state2.flowing && state2.length)
      return state2.buffer.head.data.length;
    else
      return state2.length;
  }
  if (n > state2.highWaterMark)
    state2.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state2.length)
    return n;
  if (!state2.ended) {
    state2.needReadable = true;
    return 0;
  }
  return state2.length;
}
Readable.prototype.read = function(n) {
  debug("read", n);
  n = parseInt(n, 10);
  var state2 = this._readableState;
  var nOrig = n;
  if (n !== 0)
    state2.emittedReadable = false;
  if (n === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
    debug("read: emitReadable", state2.length, state2.ended);
    if (state2.length === 0 && state2.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }
  n = howMuchToRead(n, state2);
  if (n === 0 && state2.ended) {
    if (state2.length === 0)
      endReadable(this);
    return null;
  }
  var doRead = state2.needReadable;
  debug("need readable", doRead);
  if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
    doRead = true;
    debug("length less than watermark", doRead);
  }
  if (state2.ended || state2.reading) {
    doRead = false;
    debug("reading or ended", doRead);
  } else if (doRead) {
    debug("do read");
    state2.reading = true;
    state2.sync = true;
    if (state2.length === 0)
      state2.needReadable = true;
    this._read(state2.highWaterMark);
    state2.sync = false;
    if (!state2.reading)
      n = howMuchToRead(nOrig, state2);
  }
  var ret;
  if (n > 0)
    ret = fromList(n, state2);
  else
    ret = null;
  if (ret === null) {
    state2.needReadable = true;
    n = 0;
  } else {
    state2.length -= n;
  }
  if (state2.length === 0) {
    if (!state2.ended)
      state2.needReadable = true;
    if (nOrig !== n && state2.ended)
      endReadable(this);
  }
  if (ret !== null)
    this.emit("data", ret);
  return ret;
};
function chunkInvalid(state2, chunk) {
  var er2 = null;
  if (!Buffer$1.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state2.objectMode) {
    er2 = new TypeError("Invalid non-string/buffer chunk");
  }
  return er2;
}
function onEofChunk(stream2, state2) {
  if (state2.ended)
    return;
  if (state2.decoder) {
    var chunk = state2.decoder.end();
    if (chunk && chunk.length) {
      state2.buffer.push(chunk);
      state2.length += state2.objectMode ? 1 : chunk.length;
    }
  }
  state2.ended = true;
  emitReadable(stream2);
}
function emitReadable(stream2) {
  var state2 = stream2._readableState;
  state2.needReadable = false;
  if (!state2.emittedReadable) {
    debug("emitReadable", state2.flowing);
    state2.emittedReadable = true;
    if (state2.sync)
      browser.exports.nextTick(emitReadable_, stream2);
    else
      emitReadable_(stream2);
  }
}
function emitReadable_(stream2) {
  debug("emit readable");
  stream2.emit("readable");
  flow(stream2);
}
function maybeReadMore(stream2, state2) {
  if (!state2.readingMore) {
    state2.readingMore = true;
    browser.exports.nextTick(maybeReadMore_, stream2, state2);
  }
}
function maybeReadMore_(stream2, state2) {
  var len = state2.length;
  while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
    debug("maybeReadMore read 0");
    stream2.read(0);
    if (len === state2.length)
      break;
    else
      len = state2.length;
  }
  state2.readingMore = false;
}
Readable.prototype._read = function(n) {
  this.emit("error", new Error("not implemented"));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
  var src3 = this;
  var state2 = this._readableState;
  switch (state2.pipesCount) {
    case 0:
      state2.pipes = dest;
      break;
    case 1:
      state2.pipes = [state2.pipes, dest];
      break;
    default:
      state2.pipes.push(dest);
      break;
  }
  state2.pipesCount += 1;
  debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
  var doEnd = !pipeOpts || pipeOpts.end !== false;
  var endFn = doEnd ? onend3 : cleanup;
  if (state2.endEmitted)
    browser.exports.nextTick(endFn);
  else
    src3.once("end", endFn);
  dest.on("unpipe", onunpipe);
  function onunpipe(readable) {
    debug("onunpipe");
    if (readable === src3) {
      cleanup();
    }
  }
  function onend3() {
    debug("onend");
    dest.end();
  }
  var ondrain = pipeOnDrain(src3);
  dest.on("drain", ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug("cleanup");
    dest.removeListener("close", onclose);
    dest.removeListener("finish", onfinish);
    dest.removeListener("drain", ondrain);
    dest.removeListener("error", onerror);
    dest.removeListener("unpipe", onunpipe);
    src3.removeListener("end", onend3);
    src3.removeListener("end", cleanup);
    src3.removeListener("data", ondata);
    cleanedUp = true;
    if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }
  var increasedAwaitDrain = false;
  src3.on("data", ondata);
  function ondata(chunk) {
    debug("ondata");
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf3(state2.pipes, dest) !== -1) && !cleanedUp) {
        debug("false write response, pause", src3._readableState.awaitDrain);
        src3._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src3.pause();
    }
  }
  function onerror(er2) {
    debug("onerror", er2);
    unpipe();
    dest.removeListener("error", onerror);
    if (listenerCount(dest, "error") === 0)
      dest.emit("error", er2);
  }
  prependListener2(dest, "error", onerror);
  function onclose() {
    dest.removeListener("finish", onfinish);
    unpipe();
  }
  dest.once("close", onclose);
  function onfinish() {
    debug("onfinish");
    dest.removeListener("close", onclose);
    unpipe();
  }
  dest.once("finish", onfinish);
  function unpipe() {
    debug("unpipe");
    src3.unpipe(dest);
  }
  dest.emit("pipe", src3);
  if (!state2.flowing) {
    debug("pipe resume");
    src3.resume();
  }
  return dest;
};
function pipeOnDrain(src3) {
  return function() {
    var state2 = src3._readableState;
    debug("pipeOnDrain", state2.awaitDrain);
    if (state2.awaitDrain)
      state2.awaitDrain--;
    if (state2.awaitDrain === 0 && src3.listeners("data").length) {
      state2.flowing = true;
      flow(src3);
    }
  };
}
Readable.prototype.unpipe = function(dest) {
  var state2 = this._readableState;
  if (state2.pipesCount === 0)
    return this;
  if (state2.pipesCount === 1) {
    if (dest && dest !== state2.pipes)
      return this;
    if (!dest)
      dest = state2.pipes;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    if (dest)
      dest.emit("unpipe", this);
    return this;
  }
  if (!dest) {
    var dests = state2.pipes;
    var len = state2.pipesCount;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    for (var _i = 0; _i < len; _i++) {
      dests[_i].emit("unpipe", this);
    }
    return this;
  }
  var i = indexOf3(state2.pipes, dest);
  if (i === -1)
    return this;
  state2.pipes.splice(i, 1);
  state2.pipesCount -= 1;
  if (state2.pipesCount === 1)
    state2.pipes = state2.pipes[0];
  dest.emit("unpipe", this);
  return this;
};
Readable.prototype.on = function(ev, fn) {
  var res = EE.prototype.on.call(this, ev, fn);
  if (ev === "data") {
    if (this._readableState.flowing !== false)
      this.resume();
  } else if (ev === "readable") {
    var state2 = this._readableState;
    if (!state2.endEmitted && !state2.readableListening) {
      state2.readableListening = state2.needReadable = true;
      state2.emittedReadable = false;
      if (!state2.reading) {
        browser.exports.nextTick(nReadingNextTick, this);
      } else if (state2.length) {
        emitReadable(this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
Readable.prototype.resume = function() {
  var state2 = this._readableState;
  if (!state2.flowing) {
    debug("resume");
    state2.flowing = true;
    resume(this, state2);
  }
  return this;
};
function resume(stream2, state2) {
  if (!state2.resumeScheduled) {
    state2.resumeScheduled = true;
    browser.exports.nextTick(resume_, stream2, state2);
  }
}
function resume_(stream2, state2) {
  if (!state2.reading) {
    debug("resume read 0");
    stream2.read(0);
  }
  state2.resumeScheduled = false;
  state2.awaitDrain = 0;
  stream2.emit("resume");
  flow(stream2);
  if (state2.flowing && !state2.reading)
    stream2.read(0);
}
Readable.prototype.pause = function() {
  debug("call pause flowing=%j", this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug("pause");
    this._readableState.flowing = false;
    this.emit("pause");
  }
  return this;
};
function flow(stream2) {
  var state2 = stream2._readableState;
  debug("flow", state2.flowing);
  while (state2.flowing && stream2.read() !== null) {
  }
}
Readable.prototype.wrap = function(stream2) {
  var state2 = this._readableState;
  var paused = false;
  var self2 = this;
  stream2.on("end", function() {
    debug("wrapped end");
    if (state2.decoder && !state2.ended) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length)
        self2.push(chunk);
    }
    self2.push(null);
  });
  stream2.on("data", function(chunk) {
    debug("wrapped data");
    if (state2.decoder)
      chunk = state2.decoder.write(chunk);
    if (state2.objectMode && (chunk === null || chunk === void 0))
      return;
    else if (!state2.objectMode && (!chunk || !chunk.length))
      return;
    var ret = self2.push(chunk);
    if (!ret) {
      paused = true;
      stream2.pause();
    }
  });
  for (var i in stream2) {
    if (this[i] === void 0 && typeof stream2[i] === "function") {
      this[i] = function(method) {
        return function() {
          return stream2[method].apply(stream2, arguments);
        };
      }(i);
    }
  }
  var events4 = ["error", "close", "destroy", "pause", "resume"];
  forEach2(events4, function(ev) {
    stream2.on(ev, self2.emit.bind(self2, ev));
  });
  self2._read = function(n) {
    debug("wrapped _read", n);
    if (paused) {
      paused = false;
      stream2.resume();
    }
  };
  return self2;
};
Readable._fromList = fromList;
function fromList(n, state2) {
  if (state2.length === 0)
    return null;
  var ret;
  if (state2.objectMode)
    ret = state2.buffer.shift();
  else if (!n || n >= state2.length) {
    if (state2.decoder)
      ret = state2.buffer.join("");
    else if (state2.buffer.length === 1)
      ret = state2.buffer.head.data;
    else
      ret = state2.buffer.concat(state2.length);
    state2.buffer.clear();
  } else {
    ret = fromListPartial(n, state2.buffer, state2.decoder);
  }
  return ret;
}
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    ret = list.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}
function copyFromBufferString(n, list) {
  var p = list.head;
  var c2 = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length)
      ret += str;
    else
      ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c2;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c2;
  }
  list.length -= c2;
  return ret;
}
function copyFromBuffer(n, list) {
  var ret = Buffer$1.allocUnsafe(n);
  var p = list.head;
  var c2 = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c2;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c2;
  }
  list.length -= c2;
  return ret;
}
function endReadable(stream2) {
  var state2 = stream2._readableState;
  if (state2.length > 0)
    throw new Error('"endReadable()" called on non-empty stream');
  if (!state2.endEmitted) {
    state2.ended = true;
    browser.exports.nextTick(endReadableNT, state2, stream2);
  }
}
function endReadableNT(state2, stream2) {
  if (!state2.endEmitted && state2.length === 0) {
    state2.endEmitted = true;
    stream2.readable = false;
    stream2.emit("end");
  }
}
function forEach2(xs, f) {
  for (var i = 0, l2 = xs.length; i < l2; i++) {
    f(xs[i], i);
  }
}
function indexOf3(xs, x) {
  for (var i = 0, l2 = xs.length; i < l2; i++) {
    if (xs[i] === x)
      return i;
  }
  return -1;
}
Writable.WritableState = WritableState;
util$1.inherits(Writable, events.exports.EventEmitter);
function nop() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}
function WritableState(options, stream2) {
  Object.defineProperty(this, "buffer", {
    get: util$1.deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream2 instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er2) {
    onwrite(stream2, er2);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
function Writable(options) {
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);
  this._writableState = new WritableState(options, this);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function")
      this._write = options.write;
    if (typeof options.writev === "function")
      this._writev = options.writev;
  }
  events.exports.EventEmitter.call(this);
}
Writable.prototype.pipe = function() {
  this.emit("error", new Error("Cannot pipe, not readable"));
};
function writeAfterEnd(stream2, cb) {
  var er2 = new Error("write after end");
  stream2.emit("error", er2);
  browser.exports.nextTick(cb, er2);
}
function validChunk(stream2, state2, chunk, cb) {
  var valid = true;
  var er2 = false;
  if (chunk === null) {
    er2 = new TypeError("May not write null values to stream");
  } else if (!buffer.Buffer.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
    er2 = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er2) {
    stream2.emit("error", er2);
    browser.exports.nextTick(cb, er2);
    valid = false;
  }
  return valid;
}
Writable.prototype.write = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  var ret = false;
  if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (buffer.Buffer.isBuffer(chunk))
    encoding = "buffer";
  else if (!encoding)
    encoding = state2.defaultEncoding;
  if (typeof cb !== "function")
    cb = nop;
  if (state2.ended)
    writeAfterEnd(this, cb);
  else if (validChunk(this, state2, chunk, cb)) {
    state2.pendingcb++;
    ret = writeOrBuffer(this, state2, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function() {
  var state2 = this._writableState;
  state2.corked++;
};
Writable.prototype.uncork = function() {
  var state2 = this._writableState;
  if (state2.corked) {
    state2.corked--;
    if (!state2.writing && !state2.corked && !state2.finished && !state2.bufferProcessing && state2.bufferedRequest)
      clearBuffer(this, state2);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  if (typeof encoding === "string")
    encoding = encoding.toLowerCase();
  if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
    throw new TypeError("Unknown encoding: " + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
function decodeChunk(state2, chunk, encoding) {
  if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
    chunk = buffer.Buffer.from(chunk, encoding);
  }
  return chunk;
}
function writeOrBuffer(stream2, state2, chunk, encoding, cb) {
  chunk = decodeChunk(state2, chunk, encoding);
  if (buffer.Buffer.isBuffer(chunk))
    encoding = "buffer";
  var len = state2.objectMode ? 1 : chunk.length;
  state2.length += len;
  var ret = state2.length < state2.highWaterMark;
  if (!ret)
    state2.needDrain = true;
  if (state2.writing || state2.corked) {
    var last3 = state2.lastBufferedRequest;
    state2.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last3) {
      last3.next = state2.lastBufferedRequest;
    } else {
      state2.bufferedRequest = state2.lastBufferedRequest;
    }
    state2.bufferedRequestCount += 1;
  } else {
    doWrite(stream2, state2, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
  state2.writelen = len;
  state2.writecb = cb;
  state2.writing = true;
  state2.sync = true;
  if (writev)
    stream2._writev(chunk, state2.onwrite);
  else
    stream2._write(chunk, encoding, state2.onwrite);
  state2.sync = false;
}
function onwriteError(stream2, state2, sync, er2, cb) {
  --state2.pendingcb;
  if (sync)
    browser.exports.nextTick(cb, er2);
  else
    cb(er2);
  stream2._writableState.errorEmitted = true;
  stream2.emit("error", er2);
}
function onwriteStateUpdate(state2) {
  state2.writing = false;
  state2.writecb = null;
  state2.length -= state2.writelen;
  state2.writelen = 0;
}
function onwrite(stream2, er2) {
  var state2 = stream2._writableState;
  var sync = state2.sync;
  var cb = state2.writecb;
  onwriteStateUpdate(state2);
  if (er2)
    onwriteError(stream2, state2, sync, er2, cb);
  else {
    var finished2 = needFinish(state2);
    if (!finished2 && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
      clearBuffer(stream2, state2);
    }
    if (sync) {
      browser.exports.nextTick(afterWrite, stream2, state2, finished2, cb);
    } else {
      afterWrite(stream2, state2, finished2, cb);
    }
  }
}
function afterWrite(stream2, state2, finished2, cb) {
  if (!finished2)
    onwriteDrain(stream2, state2);
  state2.pendingcb--;
  cb();
  finishMaybe(stream2, state2);
}
function onwriteDrain(stream2, state2) {
  if (state2.length === 0 && state2.needDrain) {
    state2.needDrain = false;
    stream2.emit("drain");
  }
}
function clearBuffer(stream2, state2) {
  state2.bufferProcessing = true;
  var entry = state2.bufferedRequest;
  if (stream2._writev && entry && entry.next) {
    var l2 = state2.bufferedRequestCount;
    var buffer3 = new Array(l2);
    var holder = state2.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    while (entry) {
      buffer3[count] = entry;
      entry = entry.next;
      count += 1;
    }
    doWrite(stream2, state2, true, state2.length, buffer3, "", holder.finish);
    state2.pendingcb++;
    state2.lastBufferedRequest = null;
    if (holder.next) {
      state2.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state2.corkedRequestsFree = new CorkedRequest(state2);
    }
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state2.objectMode ? 1 : chunk.length;
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
      entry = entry.next;
      if (state2.writing) {
        break;
      }
    }
    if (entry === null)
      state2.lastBufferedRequest = null;
  }
  state2.bufferedRequestCount = 0;
  state2.bufferedRequest = entry;
  state2.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error("not implemented"));
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  if (typeof chunk === "function") {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== void 0)
    this.write(chunk, encoding);
  if (state2.corked) {
    state2.corked = 1;
    this.uncork();
  }
  if (!state2.ending && !state2.finished)
    endWritable(this, state2, cb);
};
function needFinish(state2) {
  return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
}
function prefinish(stream2, state2) {
  if (!state2.prefinished) {
    state2.prefinished = true;
    stream2.emit("prefinish");
  }
}
function finishMaybe(stream2, state2) {
  var need = needFinish(state2);
  if (need) {
    if (state2.pendingcb === 0) {
      prefinish(stream2, state2);
      state2.finished = true;
      stream2.emit("finish");
    } else {
      prefinish(stream2, state2);
    }
  }
  return need;
}
function endWritable(stream2, state2, cb) {
  state2.ending = true;
  finishMaybe(stream2, state2);
  if (cb) {
    if (state2.finished)
      browser.exports.nextTick(cb);
    else
      stream2.once("finish", cb);
  }
  state2.ended = true;
  stream2.writable = false;
}
function CorkedRequest(state2) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err2) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err2);
      entry = entry.next;
    }
    if (state2.corkedRequestsFree) {
      state2.corkedRequestsFree.next = _this;
    } else {
      state2.corkedRequestsFree = _this;
    }
  };
}
util$1.inherits(Duplex, Readable);
var keys$1 = Object.keys(Writable.prototype);
for (v2 = 0; v2 < keys$1.length; v2++) {
  method = keys$1[v2];
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
}
var method;
var v2;
function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false)
    this.readable = false;
  if (options && options.writable === false)
    this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;
  this.once("end", onend);
}
function onend() {
  if (this.allowHalfOpen || this._writableState.ended)
    return;
  browser.exports.nextTick(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
util$1.inherits(Transform2, Duplex);
function TransformState(stream2) {
  this.afterTransform = function(er2, data2) {
    return afterTransform(stream2, er2, data2);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform(stream2, er2, data2) {
  var ts = stream2._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb)
    return stream2.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null;
  ts.writecb = null;
  if (data2 !== null && data2 !== void 0)
    stream2.push(data2);
  cb(er2);
  var rs = stream2._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream2._read(rs.highWaterMark);
  }
}
function Transform2(options) {
  if (!(this instanceof Transform2))
    return new Transform2(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(this);
  var stream2 = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function")
      this._transform = options.transform;
    if (typeof options.flush === "function")
      this._flush = options.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function")
      this._flush(function(er2) {
        done(stream2, er2);
      });
    else
      done(stream2);
  });
}
Transform2.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};
Transform2.prototype._transform = function(chunk, encoding, cb) {
  throw new Error("Not implemented");
};
Transform2.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};
Transform2.prototype._read = function(n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    ts.needTransform = true;
  }
};
function done(stream2, er2) {
  if (er2)
    return stream2.emit("error", er2);
  var ws = stream2._writableState;
  var ts = stream2._transformState;
  if (ws.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming)
    throw new Error("Calling transform done when still transforming");
  return stream2.push(null);
}
util$1.inherits(PassThrough, Transform2);
function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);
  Transform2.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
util$1.inherits(Stream, EE);
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex;
Stream.Transform = Transform2;
Stream.PassThrough = PassThrough;
Stream.Stream = Stream;
function Stream() {
  EE.call(this);
}
Stream.prototype.pipe = function(dest, options) {
  var source = this;
  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }
  source.on("data", ondata);
  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }
  dest.on("drain", ondrain);
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on("end", onend3);
    source.on("close", onclose);
  }
  var didOnEnd = false;
  function onend3() {
    if (didOnEnd)
      return;
    didOnEnd = true;
    dest.end();
  }
  function onclose() {
    if (didOnEnd)
      return;
    didOnEnd = true;
    if (typeof dest.destroy === "function")
      dest.destroy();
  }
  function onerror(er2) {
    cleanup();
    if (EE.listenerCount(this, "error") === 0) {
      throw er2;
    }
  }
  source.on("error", onerror);
  dest.on("error", onerror);
  function cleanup() {
    source.removeListener("data", ondata);
    dest.removeListener("drain", ondrain);
    source.removeListener("end", onend3);
    source.removeListener("close", onclose);
    source.removeListener("error", onerror);
    dest.removeListener("error", onerror);
    source.removeListener("end", cleanup);
    source.removeListener("close", cleanup);
    dest.removeListener("close", cleanup);
  }
  source.on("end", cleanup);
  source.on("close", cleanup);
  dest.on("close", cleanup);
  dest.emit("pipe", source);
  return dest;
};
var _polyfillNode_stream = Object.freeze({
  __proto__: null,
  "default": Stream,
  Readable,
  Writable,
  Duplex,
  Transform: Transform2,
  PassThrough,
  Stream
});
var require$$1 = getAugmentedNamespace(_polyfillNode_stream);
var binding = {};
var assert$2 = { exports: {} };
var errors = {};
function _typeof$3(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function _typeof9(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$3 = function _typeof9(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$3(obj);
}
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$1(self2, call2) {
  if (call2 && (_typeof$3(call2) === "object" || typeof call2 === "function")) {
    return call2;
  }
  return _assertThisInitialized$1(self2);
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _getPrototypeOf$1(o) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1(o);
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf$1(subClass, superClass);
}
function _setPrototypeOf$1(o, p) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf4(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$1(o, p);
}
var codes = {};
var assert$1;
var util;
function createErrorType(code3, message, Base2) {
  if (!Base2) {
    Base2 = Error;
  }
  function getMessage(arg1, arg2, arg3) {
    if (typeof message === "string") {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = function(_Base) {
    _inherits$1(NodeError2, _Base);
    function NodeError2(arg1, arg2, arg3) {
      var _this;
      _classCallCheck$2(this, NodeError2);
      _this = _possibleConstructorReturn$1(this, _getPrototypeOf$1(NodeError2).call(this, getMessage(arg1, arg2, arg3)));
      _this.code = code3;
      return _this;
    }
    return NodeError2;
  }(Base2);
  codes[code3] = NodeError;
}
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function(i) {
      return String(i);
    });
    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
}
function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}
function endsWith$1(str, search, this_len) {
  if (this_len === void 0 || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}
function includes2(str, search, start3) {
  if (typeof start3 !== "number") {
    start3 = 0;
  }
  if (start3 + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start3) !== -1;
  }
}
createErrorType("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
  if (assert$1 === void 0)
    assert$1 = assert$2.exports;
  assert$1(typeof name === "string", "'name' must be a string");
  var determiner;
  if (typeof expected === "string" && startsWith(expected, "not ")) {
    determiner = "must not be";
    expected = expected.replace(/^not /, "");
  } else {
    determiner = "must be";
  }
  var msg2;
  if (endsWith$1(name, " argument")) {
    msg2 = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  } else {
    var type = includes2(name, ".") ? "property" : "argument";
    msg2 = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  }
  msg2 += ". Received type ".concat(_typeof$3(actual));
  return msg2;
}, TypeError);
createErrorType("ERR_INVALID_ARG_VALUE", function(name, value2) {
  var reason = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
  if (util === void 0)
    util = util$1;
  var inspected = util.inspect(value2);
  if (inspected.length > 128) {
    inspected = "".concat(inspected.slice(0, 128), "...");
  }
  return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
}, TypeError);
createErrorType("ERR_INVALID_RETURN_VALUE", function(input, name, value2) {
  var type;
  if (value2 && value2.constructor && value2.constructor.name) {
    type = "instance of ".concat(value2.constructor.name);
  } else {
    type = "type ".concat(_typeof$3(value2));
  }
  return "Expected ".concat(input, ' to be returned from the "').concat(name, '"') + " function but got ".concat(type, ".");
}, TypeError);
createErrorType("ERR_MISSING_ARGS", function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (assert$1 === void 0)
    assert$1 = assert$2.exports;
  assert$1(args.length > 0, "At least one arg needs to be specified");
  var msg2 = "The ";
  var len = args.length;
  args = args.map(function(a2) {
    return '"'.concat(a2, '"');
  });
  switch (len) {
    case 1:
      msg2 += "".concat(args[0], " argument");
      break;
    case 2:
      msg2 += "".concat(args[0], " and ").concat(args[1], " arguments");
      break;
    default:
      msg2 += args.slice(0, len - 1).join(", ");
      msg2 += ", and ".concat(args[len - 1], " arguments");
      break;
  }
  return "".concat(msg2, " must be specified");
}, TypeError);
errors.codes = codes;
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    });
  }
  return target;
}
function _defineProperty2(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn(self2, call2) {
  if (call2 && (_typeof$2(call2) === "object" || typeof call2 === "function")) {
    return call2;
  }
  return _assertThisInitialized2(self2);
}
function _assertThisInitialized2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf2(subClass, superClass);
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper3(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf2(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct3(Parent2, args2, Class2) {
      var a2 = [null];
      a2.push.apply(a2, args2);
      var Constructor = Function.bind.apply(Parent2, a2);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf2(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _setPrototypeOf2(o, p) {
  _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf4(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf2(o, p);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _typeof$2(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$2 = function _typeof9(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$2 = function _typeof9(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$2(obj);
}
var _require$1 = util$1;
var inspect$1 = _require$1.inspect;
var _require2$1 = errors;
var ERR_INVALID_ARG_TYPE$1 = _require2$1.codes.ERR_INVALID_ARG_TYPE;
function endsWith(str, search, this_len) {
  if (this_len === void 0 || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}
function repeat(str, count) {
  count = Math.floor(count);
  if (str.length == 0 || count == 0)
    return "";
  var maxCount = str.length * count;
  count = Math.floor(Math.log(count) / Math.log(2));
  while (count) {
    str += str;
    count--;
  }
  str += str.substring(0, maxCount - str.length);
  return str;
}
var blue = "";
var green = "";
var red = "";
var white = "";
var kReadableOperator = {
  deepStrictEqual: "Expected values to be strictly deep-equal:",
  strictEqual: "Expected values to be strictly equal:",
  strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
  deepEqual: "Expected values to be loosely deep-equal:",
  equal: "Expected values to be loosely equal:",
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:',
  notIdentical: "Values identical but not reference-equal:"
};
var kMaxShortLength = 10;
function copyError(source) {
  var keys5 = Object.keys(source);
  var target = Object.create(Object.getPrototypeOf(source));
  keys5.forEach(function(key) {
    target[key] = source[key];
  });
  Object.defineProperty(target, "message", {
    value: source.message
  });
  return target;
}
function inspectValue(val) {
  return inspect$1(val, {
    compact: false,
    customInspect: false,
    depth: 1e3,
    maxArrayLength: Infinity,
    // Assert compares only enumerable properties (with a few exceptions).
    showHidden: false,
    // Having a long line as error is better than wrapping the line for
    // comparison for now.
    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
    // have meta information about the inspected properties (i.e., know where
    // in what line the property starts and ends).
    breakLength: Infinity,
    // Assert does not detect proxies currently.
    showProxy: false,
    sorted: true,
    // Inspect getters as we also check them when comparing entries.
    getters: true
  });
}
function createErrDiff(actual, expected, operator) {
  var other = "";
  var res = "";
  var lastPos = 0;
  var end3 = "";
  var skipped = false;
  var actualInspected = inspectValue(actual);
  var actualLines = actualInspected.split("\n");
  var expectedLines = inspectValue(expected).split("\n");
  var i = 0;
  var indicator = "";
  if (operator === "strictEqual" && _typeof$2(actual) === "object" && _typeof$2(expected) === "object" && actual !== null && expected !== null) {
    operator = "strictEqualObject";
  }
  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
    var inputLength = actualLines[0].length + expectedLines[0].length;
    if (inputLength <= kMaxShortLength) {
      if ((_typeof$2(actual) !== "object" || actual === null) && (_typeof$2(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
        return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
      }
    } else if (operator !== "strictEqualObject") {
      var maxLength = 80;
      if (inputLength < maxLength) {
        while (actualLines[0][i] === expectedLines[0][i]) {
          i++;
        }
        if (i > 2) {
          indicator = "\n  ".concat(repeat(" ", i), "^");
          i = 0;
        }
      }
    }
  }
  var a2 = actualLines[actualLines.length - 1];
  var b = expectedLines[expectedLines.length - 1];
  while (a2 === b) {
    if (i++ < 2) {
      end3 = "\n  ".concat(a2).concat(end3);
    } else {
      other = a2;
    }
    actualLines.pop();
    expectedLines.pop();
    if (actualLines.length === 0 || expectedLines.length === 0)
      break;
    a2 = actualLines[actualLines.length - 1];
    b = expectedLines[expectedLines.length - 1];
  }
  var maxLines = Math.max(actualLines.length, expectedLines.length);
  if (maxLines === 0) {
    var _actualLines = actualInspected.split("\n");
    if (_actualLines.length > 30) {
      _actualLines[26] = "".concat(blue, "...").concat(white);
      while (_actualLines.length > 27) {
        _actualLines.pop();
      }
    }
    return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
  }
  if (i > 3) {
    end3 = "\n".concat(blue, "...").concat(white).concat(end3);
    skipped = true;
  }
  if (other !== "") {
    end3 = "\n  ".concat(other).concat(end3);
    other = "";
  }
  var printedLines = 0;
  var msg2 = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
  var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
  for (i = 0; i < maxLines; i++) {
    var cur = i - lastPos;
    if (actualLines.length < i + 1) {
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(expectedLines[i - 2]);
          printedLines++;
        }
        res += "\n  ".concat(expectedLines[i - 1]);
        printedLines++;
      }
      lastPos = i;
      other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
      printedLines++;
    } else if (expectedLines.length < i + 1) {
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue, "...").concat(white);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(actualLines[i - 2]);
          printedLines++;
        }
        res += "\n  ".concat(actualLines[i - 1]);
        printedLines++;
      }
      lastPos = i;
      res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
      printedLines++;
    } else {
      var expectedLine = expectedLines[i];
      var actualLine = actualLines[i];
      var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
      if (divergingLines && endsWith(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
        divergingLines = false;
        actualLine += ",";
      }
      if (divergingLines) {
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += "\n".concat(blue, "...").concat(white);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(actualLines[i - 2]);
            printedLines++;
          }
          res += "\n  ".concat(actualLines[i - 1]);
          printedLines++;
        }
        lastPos = i;
        res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
        other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
        printedLines += 2;
      } else {
        res += other;
        other = "";
        if (cur === 1 || i === 0) {
          res += "\n  ".concat(actualLine);
          printedLines++;
        }
      }
    }
    if (printedLines > 20 && i < maxLines - 2) {
      return "".concat(msg2).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
    }
  }
  return "".concat(msg2).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end3).concat(indicator);
}
var AssertionError$1 = function(_Error) {
  _inherits(AssertionError3, _Error);
  function AssertionError3(options) {
    var _this;
    _classCallCheck$1(this, AssertionError3);
    if (_typeof$2(options) !== "object" || options === null) {
      throw new ERR_INVALID_ARG_TYPE$1("options", "Object", options);
    }
    var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
    var actual = options.actual, expected = options.expected;
    var limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    if (message != null) {
      _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError3).call(this, String(message)));
    } else {
      if (_typeof$2(actual) === "object" && actual !== null && _typeof$2(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
        actual = copyError(actual);
        expected = copyError(expected);
      }
      if (operator === "deepStrictEqual" || operator === "strictEqual") {
        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError3).call(this, createErrDiff(actual, expected, operator)));
      } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
        var base = kReadableOperator[operator];
        var res = inspectValue(actual).split("\n");
        if (operator === "notStrictEqual" && _typeof$2(actual) === "object" && actual !== null) {
          base = kReadableOperator.notStrictEqualObject;
        }
        if (res.length > 30) {
          res[26] = "".concat(blue, "...").concat(white);
          while (res.length > 27) {
            res.pop();
          }
        }
        if (res.length === 1) {
          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError3).call(this, "".concat(base, " ").concat(res[0])));
        } else {
          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError3).call(this, "".concat(base, "\n\n").concat(res.join("\n"), "\n")));
        }
      } else {
        var _res = inspectValue(actual);
        var other = "";
        var knownOperators = kReadableOperator[operator];
        if (operator === "notDeepEqual" || operator === "notEqual") {
          _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
          if (_res.length > 1024) {
            _res = "".concat(_res.slice(0, 1021), "...");
          }
        } else {
          other = "".concat(inspectValue(expected));
          if (_res.length > 512) {
            _res = "".concat(_res.slice(0, 509), "...");
          }
          if (other.length > 512) {
            other = "".concat(other.slice(0, 509), "...");
          }
          if (operator === "deepEqual" || operator === "equal") {
            _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
          } else {
            other = " ".concat(operator, " ").concat(other);
          }
        }
        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError3).call(this, "".concat(_res).concat(other)));
      }
    }
    Error.stackTraceLimit = limit;
    _this.generatedMessage = !message;
    Object.defineProperty(_assertThisInitialized2(_this), "name", {
      value: "AssertionError [ERR_ASSERTION]",
      enumerable: false,
      writable: true,
      configurable: true
    });
    _this.code = "ERR_ASSERTION";
    _this.actual = actual;
    _this.expected = expected;
    _this.operator = operator;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(_assertThisInitialized2(_this), stackStartFn);
    }
    _this.stack;
    _this.name = "AssertionError";
    return _possibleConstructorReturn(_this);
  }
  _createClass2(AssertionError3, [{
    key: "toString",
    value: function toString7() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    }
  }, {
    key: inspect$1.custom,
    value: function value2(recurseTimes, ctx) {
      return inspect$1(this, _objectSpread({}, ctx, {
        customInspect: false,
        depth: 0
      }));
    }
  }]);
  return AssertionError3;
}(_wrapNativeSuper(Error));
var assertion_error = AssertionError$1;
function assign(target, firstSource) {
  if (target === void 0 || target === null) {
    throw new TypeError("Cannot convert first argument to object");
  }
  var to = Object(target);
  for (var i = 1; i < arguments.length; i++) {
    var nextSource = arguments[i];
    if (nextSource === void 0 || nextSource === null) {
      continue;
    }
    var keysArray = Object.keys(Object(nextSource));
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
      var nextKey = keysArray[nextIndex];
      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
      if (desc !== void 0 && desc.enumerable) {
        to[nextKey] = nextSource[nextKey];
      }
    }
  }
  return to;
}
function polyfill$4() {
  if (!Object.assign) {
    Object.defineProperty(Object, "assign", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: assign
    });
  }
}
var es6ObjectAssign = {
  assign,
  polyfill: polyfill$4
};
var toStr$2 = Object.prototype.toString;
var isArguments3 = function isArguments4(value2) {
  var str = toStr$2.call(value2);
  var isArgs3 = str === "[object Arguments]";
  if (!isArgs3) {
    isArgs3 = str !== "[object Array]" && value2 !== null && typeof value2 === "object" && typeof value2.length === "number" && value2.length >= 0 && toStr$2.call(value2.callee) === "[object Function]";
  }
  return isArgs3;
};
var keysShim$1;
if (!Object.keys) {
  has = Object.prototype.hasOwnProperty;
  toStr$1 = Object.prototype.toString;
  isArgs$1 = isArguments3;
  isEnumerable = Object.prototype.propertyIsEnumerable;
  hasDontEnumBug = !isEnumerable.call({
    toString: null
  }, "toString");
  hasProtoEnumBug = isEnumerable.call(function() {
  }, "prototype");
  dontEnums = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"];
  equalsConstructorPrototype = function equalsConstructorPrototype2(o) {
    var ctor = o.constructor;
    return ctor && ctor.prototype === o;
  };
  excludedKeys = {
    $applicationCache: true,
    $console: true,
    $external: true,
    $frame: true,
    $frameElement: true,
    $frames: true,
    $innerHeight: true,
    $innerWidth: true,
    $onmozfullscreenchange: true,
    $onmozfullscreenerror: true,
    $outerHeight: true,
    $outerWidth: true,
    $pageXOffset: true,
    $pageYOffset: true,
    $parent: true,
    $scrollLeft: true,
    $scrollTop: true,
    $scrollX: true,
    $scrollY: true,
    $self: true,
    $webkitIndexedDB: true,
    $webkitStorageInfo: true,
    $window: true
  };
  hasAutomationEqualityBug = function() {
    if (typeof window === "undefined") {
      return false;
    }
    for (var k in window) {
      try {
        if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
          try {
            equalsConstructorPrototype(window[k]);
          } catch (e) {
            return true;
          }
        }
      } catch (e) {
        return true;
      }
    }
    return false;
  }();
  equalsConstructorPrototypeIfNotBuggy = function equalsConstructorPrototypeIfNotBuggy2(o) {
    if (typeof window === "undefined" || !hasAutomationEqualityBug) {
      return equalsConstructorPrototype(o);
    }
    try {
      return equalsConstructorPrototype(o);
    } catch (e) {
      return false;
    }
  };
  keysShim$1 = function keys5(object) {
    var isObject = object !== null && typeof object === "object";
    var isFunction5 = toStr$1.call(object) === "[object Function]";
    var isArguments9 = isArgs$1(object);
    var isString3 = isObject && toStr$1.call(object) === "[object String]";
    var theKeys = [];
    if (!isObject && !isFunction5 && !isArguments9) {
      throw new TypeError("Object.keys called on a non-object");
    }
    var skipProto = hasProtoEnumBug && isFunction5;
    if (isString3 && object.length > 0 && !has.call(object, 0)) {
      for (var i = 0; i < object.length; ++i) {
        theKeys.push(String(i));
      }
    }
    if (isArguments9 && object.length > 0) {
      for (var j = 0; j < object.length; ++j) {
        theKeys.push(String(j));
      }
    } else {
      for (var name in object) {
        if (!(skipProto && name === "prototype") && has.call(object, name)) {
          theKeys.push(String(name));
        }
      }
    }
    if (hasDontEnumBug) {
      var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
      for (var k = 0; k < dontEnums.length; ++k) {
        if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
          theKeys.push(dontEnums[k]);
        }
      }
    }
    return theKeys;
  };
}
var has;
var toStr$1;
var isArgs$1;
var isEnumerable;
var hasDontEnumBug;
var hasProtoEnumBug;
var dontEnums;
var equalsConstructorPrototype;
var excludedKeys;
var hasAutomationEqualityBug;
var equalsConstructorPrototypeIfNotBuggy;
var implementation$6 = keysShim$1;
var slice2 = Array.prototype.slice;
var isArgs = isArguments3;
var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) {
  return origKeys(o);
} : implementation$6;
var originalKeys = Object.keys;
keysShim.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function() {
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);
    if (!keysWorksWithArguments) {
      Object.keys = function keys5(object) {
        if (isArgs(object)) {
          return originalKeys(slice2.call(object));
        }
        return originalKeys(object);
      };
    }
  } else {
    Object.keys = keysShim;
  }
  return Object.keys || keysShim;
};
var objectKeys = keysShim;
var keys2 = objectKeys;
var hasSymbols2 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
var toStr = Object.prototype.toString;
var concat2 = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;
var isFunction = function isFunction2(fn) {
  return typeof fn === "function" && toStr.call(fn) === "[object Function]";
};
var arePropertyDescriptorsSupported = function arePropertyDescriptorsSupported2() {
  var obj = {};
  try {
    origDefineProperty(obj, "x", {
      enumerable: false,
      value: obj
    });
    for (var _ in obj) {
      return false;
    }
    return obj.x === obj;
  } catch (e) {
    return false;
  }
};
var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();
var defineProperty = function defineProperty2(object, name, value2, predicate) {
  if (name in object && (!isFunction(predicate) || !predicate())) {
    return;
  }
  if (supportsDescriptors) {
    origDefineProperty(object, name, {
      configurable: true,
      enumerable: false,
      value: value2,
      writable: true
    });
  } else {
    object[name] = value2;
  }
};
var defineProperties = function defineProperties2(object, map) {
  var predicates = arguments.length > 2 ? arguments[2] : {};
  var props = keys2(map);
  if (hasSymbols2) {
    props = concat2.call(props, Object.getOwnPropertySymbols(map));
  }
  for (var i = 0; i < props.length; i += 1) {
    defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
  }
};
defineProperties.supportsDescriptors = !!supportsDescriptors;
var defineProperties_1 = defineProperties;
var numberIsNaN$1 = function numberIsNaN(value2) {
  return value2 !== value2;
};
var implementation$5 = function is(a2, b) {
  if (a2 === 0 && b === 0) {
    return 1 / a2 === 1 / b;
  }
  if (a2 === b) {
    return true;
  }
  if (numberIsNaN$1(a2) && numberIsNaN$1(b)) {
    return true;
  }
  return false;
};
var implementation$4 = implementation$5;
var polyfill$3 = function getPolyfill() {
  return typeof Object.is === "function" ? Object.is : implementation$4;
};
var getPolyfill$3 = polyfill$3;
var define$3 = defineProperties_1;
var shim$3 = function shimObjectIs() {
  var polyfill3 = getPolyfill$3();
  define$3(Object, {
    is: polyfill3
  }, {
    is: function testObjectIs() {
      return Object.is !== polyfill3;
    }
  });
  return polyfill3;
};
var define$2 = defineProperties_1;
var callBind$1 = callBind$3.exports;
var implementation$3 = implementation$5;
var getPolyfill$2 = polyfill$3;
var shim$2 = shim$3;
var polyfill$2 = callBind$1(getPolyfill$2(), Object);
define$2(polyfill$2, {
  getPolyfill: getPolyfill$2,
  implementation: implementation$3,
  shim: shim$2
});
var objectIs$2 = polyfill$2;
var implementation$2 = function isNaN2(value2) {
  return value2 !== value2;
};
var implementation$1 = implementation$2;
var polyfill$1 = function getPolyfill2() {
  if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")) {
    return Number.isNaN;
  }
  return implementation$1;
};
var define$1 = defineProperties_1;
var getPolyfill$1 = polyfill$1;
var shim$1 = function shimNumberIsNaN() {
  var polyfill3 = getPolyfill$1();
  define$1(Number, {
    isNaN: polyfill3
  }, {
    isNaN: function testIsNaN() {
      return Number.isNaN !== polyfill3;
    }
  });
  return polyfill3;
};
var callBind = callBind$3.exports;
var define2 = defineProperties_1;
var implementation = implementation$2;
var getPolyfill3 = polyfill$1;
var shim = shim$1;
var polyfill = callBind(getPolyfill3(), Number);
define2(polyfill, {
  getPolyfill: getPolyfill3,
  implementation,
  shim
});
var isNan = polyfill;
function _slicedToArray2(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err2) {
    _d = true;
    _e = err2;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _typeof$1(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function _typeof9(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1 = function _typeof9(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1(obj);
}
var regexFlagsSupported = /a/g.flags !== void 0;
var arrayFromSet = function arrayFromSet2(set7) {
  var array = [];
  set7.forEach(function(value2) {
    return array.push(value2);
  });
  return array;
};
var arrayFromMap = function arrayFromMap2(map) {
  var array = [];
  map.forEach(function(value2, key) {
    return array.push([key, value2]);
  });
  return array;
};
var objectIs$1 = Object.is ? Object.is : objectIs$2;
var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
  return [];
};
var numberIsNaN2 = Number.isNaN ? Number.isNaN : isNan;
function uncurryThis(f) {
  return f.call.bind(f);
}
var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
var objectToString = uncurryThis(Object.prototype.toString);
var _require$types$1 = util$1.types;
var isAnyArrayBuffer = _require$types$1.isAnyArrayBuffer;
var isArrayBufferView = _require$types$1.isArrayBufferView;
var isDate = _require$types$1.isDate;
var isMap = _require$types$1.isMap;
var isRegExp$1 = _require$types$1.isRegExp;
var isSet = _require$types$1.isSet;
var isNativeError = _require$types$1.isNativeError;
var isBoxedPrimitive = _require$types$1.isBoxedPrimitive;
var isNumberObject = _require$types$1.isNumberObject;
var isStringObject = _require$types$1.isStringObject;
var isBooleanObject = _require$types$1.isBooleanObject;
var isBigIntObject = _require$types$1.isBigIntObject;
var isSymbolObject = _require$types$1.isSymbolObject;
var isFloat32Array = _require$types$1.isFloat32Array;
var isFloat64Array = _require$types$1.isFloat64Array;
function isNonIndex(key) {
  if (key.length === 0 || key.length > 10)
    return true;
  for (var i = 0; i < key.length; i++) {
    var code3 = key.charCodeAt(i);
    if (code3 < 48 || code3 > 57)
      return true;
  }
  return key.length === 10 && key >= Math.pow(2, 32);
}
function getOwnNonIndexProperties(value2) {
  return Object.keys(value2).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value2).filter(Object.prototype.propertyIsEnumerable.bind(value2)));
}
function compare3(a2, b) {
  if (a2 === b) {
    return 0;
  }
  var x = a2.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a2[i] !== b[i]) {
      x = a2[i];
      y = b[i];
      break;
    }
  }
  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
var kStrict = true;
var kLoose = false;
var kNoIterator = 0;
var kIsArray = 1;
var kIsSet = 2;
var kIsMap = 3;
function areSimilarRegExps(a2, b) {
  return regexFlagsSupported ? a2.source === b.source && a2.flags === b.flags : RegExp.prototype.toString.call(a2) === RegExp.prototype.toString.call(b);
}
function areSimilarFloatArrays(a2, b) {
  if (a2.byteLength !== b.byteLength) {
    return false;
  }
  for (var offset3 = 0; offset3 < a2.byteLength; offset3++) {
    if (a2[offset3] !== b[offset3]) {
      return false;
    }
  }
  return true;
}
function areSimilarTypedArrays(a2, b) {
  if (a2.byteLength !== b.byteLength) {
    return false;
  }
  return compare3(new Uint8Array(a2.buffer, a2.byteOffset, a2.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
}
function areEqualArrayBuffers(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && compare3(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive(val1, val2) {
  if (isNumberObject(val1)) {
    return isNumberObject(val2) && objectIs$1(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
  }
  if (isStringObject(val1)) {
    return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
  }
  if (isBooleanObject(val1)) {
    return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
  }
  if (isBigIntObject(val1)) {
    return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
  }
  return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
}
function innerDeepEqual(val1, val2, strict3, memos) {
  if (val1 === val2) {
    if (val1 !== 0)
      return true;
    return strict3 ? objectIs$1(val1, val2) : true;
  }
  if (strict3) {
    if (_typeof$1(val1) !== "object") {
      return typeof val1 === "number" && numberIsNaN2(val1) && numberIsNaN2(val2);
    }
    if (_typeof$1(val2) !== "object" || val1 === null || val2 === null) {
      return false;
    }
    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || _typeof$1(val1) !== "object") {
      if (val2 === null || _typeof$1(val2) !== "object") {
        return val1 == val2;
      }
      return false;
    }
    if (val2 === null || _typeof$1(val2) !== "object") {
      return false;
    }
  }
  var val1Tag = objectToString(val1);
  var val2Tag = objectToString(val2);
  if (val1Tag !== val2Tag) {
    return false;
  }
  if (Array.isArray(val1)) {
    if (val1.length !== val2.length) {
      return false;
    }
    var keys1 = getOwnNonIndexProperties(val1);
    var keys22 = getOwnNonIndexProperties(val2);
    if (keys1.length !== keys22.length) {
      return false;
    }
    return keyCheck(val1, val2, strict3, memos, kIsArray, keys1);
  }
  if (val1Tag === "[object Object]") {
    if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
      return false;
    }
  }
  if (isDate(val1)) {
    if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
      return false;
    }
  } else if (isRegExp$1(val1)) {
    if (!isRegExp$1(val2) || !areSimilarRegExps(val1, val2)) {
      return false;
    }
  } else if (isNativeError(val1) || val1 instanceof Error) {
    if (val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if (isArrayBufferView(val1)) {
    if (!strict3 && (isFloat32Array(val1) || isFloat64Array(val1))) {
      if (!areSimilarFloatArrays(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays(val1, val2)) {
      return false;
    }
    var _keys = getOwnNonIndexProperties(val1);
    var _keys2 = getOwnNonIndexProperties(val2);
    if (_keys.length !== _keys2.length) {
      return false;
    }
    return keyCheck(val1, val2, strict3, memos, kNoIterator, _keys);
  } else if (isSet(val1)) {
    if (!isSet(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck(val1, val2, strict3, memos, kIsSet);
  } else if (isMap(val1)) {
    if (!isMap(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck(val1, val2, strict3, memos, kIsMap);
  } else if (isAnyArrayBuffer(val1)) {
    if (!areEqualArrayBuffers(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
    return false;
  }
  return keyCheck(val1, val2, strict3, memos, kNoIterator);
}
function getEnumerables(val, keys5) {
  return keys5.filter(function(k) {
    return propertyIsEnumerable(val, k);
  });
}
function keyCheck(val1, val2, strict3, memos, iterationType, aKeys) {
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    var bKeys = Object.keys(val2);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
  }
  var i = 0;
  for (; i < aKeys.length; i++) {
    if (!hasOwnProperty(val2, aKeys[i])) {
      return false;
    }
  }
  if (strict3 && arguments.length === 5) {
    var symbolKeysA = objectGetOwnPropertySymbols(val1);
    if (symbolKeysA.length !== 0) {
      var count = 0;
      for (i = 0; i < symbolKeysA.length; i++) {
        var key = symbolKeysA[i];
        if (propertyIsEnumerable(val1, key)) {
          if (!propertyIsEnumerable(val2, key)) {
            return false;
          }
          aKeys.push(key);
          count++;
        } else if (propertyIsEnumerable(val2, key)) {
          return false;
        }
      }
      var symbolKeysB = objectGetOwnPropertySymbols(val2);
      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      var _symbolKeysB = objectGetOwnPropertySymbols(val2);
      if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
        return false;
      }
    }
  }
  if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
    return true;
  }
  if (memos === void 0) {
    memos = {
      val1: /* @__PURE__ */ new Map(),
      val2: /* @__PURE__ */ new Map(),
      position: 0
    };
  } else {
    var val2MemoA = memos.val1.get(val1);
    if (val2MemoA !== void 0) {
      var val2MemoB = memos.val2.get(val2);
      if (val2MemoB !== void 0) {
        return val2MemoA === val2MemoB;
      }
    }
    memos.position++;
  }
  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  var areEq = objEquiv(val1, val2, strict3, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}
function setHasEqualElement(set7, val1, strict3, memo) {
  var setValues = arrayFromSet(set7);
  for (var i = 0; i < setValues.length; i++) {
    var val2 = setValues[i];
    if (innerDeepEqual(val1, val2, strict3, memo)) {
      set7.delete(val2);
      return true;
    }
  }
  return false;
}
function findLooseMatchingPrimitives(prim) {
  switch (_typeof$1(prim)) {
    case "undefined":
      return null;
    case "object":
      return void 0;
    case "symbol":
      return false;
    case "string":
      prim = +prim;
    case "number":
      if (numberIsNaN2(prim)) {
        return false;
      }
  }
  return true;
}
function setMightHaveLoosePrim(a2, b, prim) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null)
    return altValue;
  return b.has(altValue) && !a2.has(altValue);
}
function mapMightHaveLoosePrim(a2, b, prim, item, memo) {
  var altValue = findLooseMatchingPrimitives(prim);
  if (altValue != null) {
    return altValue;
  }
  var curB = b.get(altValue);
  if (curB === void 0 && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
    return false;
  }
  return !a2.has(altValue) && innerDeepEqual(item, curB, false, memo);
}
function setEquiv(a2, b, strict3, memo) {
  var set7 = null;
  var aValues = arrayFromSet(a2);
  for (var i = 0; i < aValues.length; i++) {
    var val = aValues[i];
    if (_typeof$1(val) === "object" && val !== null) {
      if (set7 === null) {
        set7 = /* @__PURE__ */ new Set();
      }
      set7.add(val);
    } else if (!b.has(val)) {
      if (strict3)
        return false;
      if (!setMightHaveLoosePrim(a2, b, val)) {
        return false;
      }
      if (set7 === null) {
        set7 = /* @__PURE__ */ new Set();
      }
      set7.add(val);
    }
  }
  if (set7 !== null) {
    var bValues = arrayFromSet(b);
    for (var _i = 0; _i < bValues.length; _i++) {
      var _val = bValues[_i];
      if (_typeof$1(_val) === "object" && _val !== null) {
        if (!setHasEqualElement(set7, _val, strict3, memo))
          return false;
      } else if (!strict3 && !a2.has(_val) && !setHasEqualElement(set7, _val, strict3, memo)) {
        return false;
      }
    }
    return set7.size === 0;
  }
  return true;
}
function mapHasEqualEntry(set7, map, key1, item1, strict3, memo) {
  var setValues = arrayFromSet(set7);
  for (var i = 0; i < setValues.length; i++) {
    var key2 = setValues[i];
    if (innerDeepEqual(key1, key2, strict3, memo) && innerDeepEqual(item1, map.get(key2), strict3, memo)) {
      set7.delete(key2);
      return true;
    }
  }
  return false;
}
function mapEquiv(a2, b, strict3, memo) {
  var set7 = null;
  var aEntries = arrayFromMap(a2);
  for (var i = 0; i < aEntries.length; i++) {
    var _aEntries$i = _slicedToArray2(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
    if (_typeof$1(key) === "object" && key !== null) {
      if (set7 === null) {
        set7 = /* @__PURE__ */ new Set();
      }
      set7.add(key);
    } else {
      var item2 = b.get(key);
      if (item2 === void 0 && !b.has(key) || !innerDeepEqual(item1, item2, strict3, memo)) {
        if (strict3)
          return false;
        if (!mapMightHaveLoosePrim(a2, b, key, item1, memo))
          return false;
        if (set7 === null) {
          set7 = /* @__PURE__ */ new Set();
        }
        set7.add(key);
      }
    }
  }
  if (set7 !== null) {
    var bEntries = arrayFromMap(b);
    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
      var _bEntries$_i = _slicedToArray2(bEntries[_i2], 2), key = _bEntries$_i[0], item = _bEntries$_i[1];
      if (_typeof$1(key) === "object" && key !== null) {
        if (!mapHasEqualEntry(set7, a2, key, item, strict3, memo))
          return false;
      } else if (!strict3 && (!a2.has(key) || !innerDeepEqual(a2.get(key), item, false, memo)) && !mapHasEqualEntry(set7, a2, key, item, false, memo)) {
        return false;
      }
    }
    return set7.size === 0;
  }
  return true;
}
function objEquiv(a2, b, strict3, keys5, memos, iterationType) {
  var i = 0;
  if (iterationType === kIsSet) {
    if (!setEquiv(a2, b, strict3, memos)) {
      return false;
    }
  } else if (iterationType === kIsMap) {
    if (!mapEquiv(a2, b, strict3, memos)) {
      return false;
    }
  } else if (iterationType === kIsArray) {
    for (; i < a2.length; i++) {
      if (hasOwnProperty(a2, i)) {
        if (!hasOwnProperty(b, i) || !innerDeepEqual(a2[i], b[i], strict3, memos)) {
          return false;
        }
      } else if (hasOwnProperty(b, i)) {
        return false;
      } else {
        var keysA = Object.keys(a2);
        for (; i < keysA.length; i++) {
          var key = keysA[i];
          if (!hasOwnProperty(b, key) || !innerDeepEqual(a2[key], b[key], strict3, memos)) {
            return false;
          }
        }
        if (keysA.length !== Object.keys(b).length) {
          return false;
        }
        return true;
      }
    }
  }
  for (i = 0; i < keys5.length; i++) {
    var _key = keys5[i];
    if (!innerDeepEqual(a2[_key], b[_key], strict3, memos)) {
      return false;
    }
  }
  return true;
}
function isDeepEqual$1(val1, val2) {
  return innerDeepEqual(val1, val2, kLoose);
}
function isDeepStrictEqual$1(val1, val2) {
  return innerDeepEqual(val1, val2, kStrict);
}
var comparisons = {
  isDeepEqual: isDeepEqual$1,
  isDeepStrictEqual: isDeepStrictEqual$1
};
function _typeof5(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof5 = function _typeof9(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof5 = function _typeof9(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof5(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var _require = errors;
var _require$codes = _require.codes;
var ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT;
var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
var ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE;
var ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE;
var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
var AssertionError = assertion_error;
var _require2 = util$1;
var inspect2 = _require2.inspect;
var _require$types = util$1.types;
var isPromise = _require$types.isPromise;
var isRegExp = _require$types.isRegExp;
var objectAssign = Object.assign ? Object.assign : es6ObjectAssign.assign;
var objectIs = Object.is ? Object.is : objectIs$2;
var isDeepEqual;
var isDeepStrictEqual;
function lazyLoadComparison() {
  var comparison = comparisons;
  isDeepEqual = comparison.isDeepEqual;
  isDeepStrictEqual = comparison.isDeepStrictEqual;
}
var warned = false;
var assert = assert$2.exports = ok;
var NO_EXCEPTION_SENTINEL = {};
function innerFail(obj) {
  if (obj.message instanceof Error)
    throw obj.message;
  throw new AssertionError(obj);
}
function fail(actual, expected, message, operator, stackStartFn) {
  var argsLen = arguments.length;
  var internalMessage;
  if (argsLen === 0) {
    internalMessage = "Failed";
  } else if (argsLen === 1) {
    message = actual;
    actual = void 0;
  } else {
    if (warned === false) {
      warned = true;
      var warn = console.warn.bind(console);
      warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
    }
    if (argsLen === 2)
      operator = "!=";
  }
  if (message instanceof Error)
    throw message;
  var errArgs = {
    actual,
    expected,
    operator: operator === void 0 ? "fail" : operator,
    stackStartFn: stackStartFn || fail
  };
  if (message !== void 0) {
    errArgs.message = message;
  }
  var err2 = new AssertionError(errArgs);
  if (internalMessage) {
    err2.message = internalMessage;
    err2.generatedMessage = true;
  }
  throw err2;
}
assert.fail = fail;
assert.AssertionError = AssertionError;
function innerOk(fn, argLen, value2, message) {
  if (!value2) {
    var generatedMessage = false;
    if (argLen === 0) {
      generatedMessage = true;
      message = "No value argument passed to `assert.ok()`";
    } else if (message instanceof Error) {
      throw message;
    }
    var err2 = new AssertionError({
      actual: value2,
      expected: true,
      message,
      operator: "==",
      stackStartFn: fn
    });
    err2.generatedMessage = generatedMessage;
    throw err2;
  }
}
function ok() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  innerOk.apply(void 0, [ok, args.length].concat(args));
}
assert.ok = ok;
assert.equal = function equal(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS("actual", "expected");
  }
  if (actual != expected) {
    innerFail({
      actual,
      expected,
      message,
      operator: "==",
      stackStartFn: equal
    });
  }
};
assert.notEqual = function notEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS("actual", "expected");
  }
  if (actual == expected) {
    innerFail({
      actual,
      expected,
      message,
      operator: "!=",
      stackStartFn: notEqual
    });
  }
};
assert.deepEqual = function deepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS("actual", "expected");
  }
  if (isDeepEqual === void 0)
    lazyLoadComparison();
  if (!isDeepEqual(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: "deepEqual",
      stackStartFn: deepEqual
    });
  }
};
assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS("actual", "expected");
  }
  if (isDeepEqual === void 0)
    lazyLoadComparison();
  if (isDeepEqual(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: "notDeepEqual",
      stackStartFn: notDeepEqual
    });
  }
};
assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS("actual", "expected");
  }
  if (isDeepEqual === void 0)
    lazyLoadComparison();
  if (!isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: "deepStrictEqual",
      stackStartFn: deepStrictEqual
    });
  }
};
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS("actual", "expected");
  }
  if (isDeepEqual === void 0)
    lazyLoadComparison();
  if (isDeepStrictEqual(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: "notDeepStrictEqual",
      stackStartFn: notDeepStrictEqual
    });
  }
}
assert.strictEqual = function strictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS("actual", "expected");
  }
  if (!objectIs(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: "strictEqual",
      stackStartFn: strictEqual
    });
  }
};
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS("actual", "expected");
  }
  if (objectIs(actual, expected)) {
    innerFail({
      actual,
      expected,
      message,
      operator: "notStrictEqual",
      stackStartFn: notStrictEqual
    });
  }
};
var Comparison = function Comparison2(obj, keys5, actual) {
  var _this = this;
  _classCallCheck(this, Comparison2);
  keys5.forEach(function(key) {
    if (key in obj) {
      if (actual !== void 0 && typeof actual[key] === "string" && isRegExp(obj[key]) && obj[key].test(actual[key])) {
        _this[key] = actual[key];
      } else {
        _this[key] = obj[key];
      }
    }
  });
};
function compareExceptionKey(actual, expected, key, message, keys5, fn) {
  if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
    if (!message) {
      var a2 = new Comparison(actual, keys5);
      var b = new Comparison(expected, keys5, actual);
      var err2 = new AssertionError({
        actual: a2,
        expected: b,
        operator: "deepStrictEqual",
        stackStartFn: fn
      });
      err2.actual = actual;
      err2.expected = expected;
      err2.operator = fn.name;
      throw err2;
    }
    innerFail({
      actual,
      expected,
      message,
      operator: fn.name,
      stackStartFn: fn
    });
  }
}
function expectedException(actual, expected, msg2, fn) {
  if (typeof expected !== "function") {
    if (isRegExp(expected))
      return expected.test(actual);
    if (arguments.length === 2) {
      throw new ERR_INVALID_ARG_TYPE("expected", ["Function", "RegExp"], expected);
    }
    if (_typeof5(actual) !== "object" || actual === null) {
      var err2 = new AssertionError({
        actual,
        expected,
        message: msg2,
        operator: "deepStrictEqual",
        stackStartFn: fn
      });
      err2.operator = fn.name;
      throw err2;
    }
    var keys5 = Object.keys(expected);
    if (expected instanceof Error) {
      keys5.push("name", "message");
    } else if (keys5.length === 0) {
      throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
    }
    if (isDeepEqual === void 0)
      lazyLoadComparison();
    keys5.forEach(function(key) {
      if (typeof actual[key] === "string" && isRegExp(expected[key]) && expected[key].test(actual[key])) {
        return;
      }
      compareExceptionKey(actual, expected, key, msg2, keys5, fn);
    });
    return true;
  }
  if (expected.prototype !== void 0 && actual instanceof expected) {
    return true;
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function getActual(fn) {
  if (typeof fn !== "function") {
    throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn);
  }
  try {
    fn();
  } catch (e) {
    return e;
  }
  return NO_EXCEPTION_SENTINEL;
}
function checkIsPromise(obj) {
  return isPromise(obj) || obj !== null && _typeof5(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
}
function waitForActual(promiseFn) {
  return Promise.resolve().then(function() {
    var resultPromise;
    if (typeof promiseFn === "function") {
      resultPromise = promiseFn();
      if (!checkIsPromise(resultPromise)) {
        throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
      }
    } else if (checkIsPromise(promiseFn)) {
      resultPromise = promiseFn;
    } else {
      throw new ERR_INVALID_ARG_TYPE("promiseFn", ["Function", "Promise"], promiseFn);
    }
    return Promise.resolve().then(function() {
      return resultPromise;
    }).then(function() {
      return NO_EXCEPTION_SENTINEL;
    }).catch(function(e) {
      return e;
    });
  });
}
function expectsError(stackStartFn, actual, error, message) {
  if (typeof error === "string") {
    if (arguments.length === 4) {
      throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
    }
    if (_typeof5(actual) === "object" && actual !== null) {
      if (actual.message === error) {
        throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
      }
    } else if (actual === error) {
      throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
    }
    message = error;
    error = void 0;
  } else if (error != null && _typeof5(error) !== "object" && typeof error !== "function") {
    throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
  }
  if (actual === NO_EXCEPTION_SENTINEL) {
    var details = "";
    if (error && error.name) {
      details += " (".concat(error.name, ")");
    }
    details += message ? ": ".concat(message) : ".";
    var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
    innerFail({
      actual: void 0,
      expected: error,
      operator: stackStartFn.name,
      message: "Missing expected ".concat(fnType).concat(details),
      stackStartFn
    });
  }
  if (error && !expectedException(actual, error, message, stackStartFn)) {
    throw actual;
  }
}
function expectsNoError(stackStartFn, actual, error, message) {
  if (actual === NO_EXCEPTION_SENTINEL)
    return;
  if (typeof error === "string") {
    message = error;
    error = void 0;
  }
  if (!error || expectedException(actual, error)) {
    var details = message ? ": ".concat(message) : ".";
    var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
    innerFail({
      actual,
      expected: error,
      operator: stackStartFn.name,
      message: "Got unwanted ".concat(fnType).concat(details, "\n") + 'Actual message: "'.concat(actual && actual.message, '"'),
      stackStartFn
    });
  }
  throw actual;
}
assert.throws = function throws(promiseFn) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
};
assert.rejects = function rejects(promiseFn) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }
  return waitForActual(promiseFn).then(function(result) {
    return expectsError.apply(void 0, [rejects, result].concat(args));
  });
};
assert.doesNotThrow = function doesNotThrow(fn) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }
  expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
};
assert.doesNotReject = function doesNotReject(fn) {
  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }
  return waitForActual(fn).then(function(result) {
    return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
  });
};
assert.ifError = function ifError(err2) {
  if (err2 !== null && err2 !== void 0) {
    var message = "ifError got unwanted exception: ";
    if (_typeof5(err2) === "object" && typeof err2.message === "string") {
      if (err2.message.length === 0 && err2.constructor) {
        message += err2.constructor.name;
      } else {
        message += err2.message;
      }
    } else {
      message += inspect2(err2);
    }
    var newErr = new AssertionError({
      actual: err2,
      expected: null,
      operator: "ifError",
      message,
      stackStartFn: ifError
    });
    var origStack = err2.stack;
    if (typeof origStack === "string") {
      var tmp2 = origStack.split("\n");
      tmp2.shift();
      var tmp1 = newErr.stack.split("\n");
      for (var i = 0; i < tmp2.length; i++) {
        var pos = tmp1.indexOf(tmp2[i]);
        if (pos !== -1) {
          tmp1 = tmp1.slice(0, pos);
          break;
        }
      }
      newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
    }
    throw newErr;
  }
};
function strict() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }
  innerOk.apply(void 0, [strict, args.length].concat(args));
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var deflate$1 = {};
var common = {};
(function(exports) {
  var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  function _has(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  exports.assign = function(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      var source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (var p in source) {
        if (_has(source, p)) {
          obj[p] = source[p];
        }
      }
    }
    return obj;
  };
  exports.shrinkBuf = function(buf, size) {
    if (buf.length === size) {
      return buf;
    }
    if (buf.subarray) {
      return buf.subarray(0, size);
    }
    buf.length = size;
    return buf;
  };
  var fnTyped = {
    arraySet: function arraySet(dest, src3, src_offs, len, dest_offs) {
      if (src3.subarray && dest.subarray) {
        dest.set(src3.subarray(src_offs, src_offs + len), dest_offs);
        return;
      }
      for (var i = 0; i < len; i++) {
        dest[dest_offs + i] = src3[src_offs + i];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function flattenChunks(chunks) {
      var i, l2, len, pos, chunk, result;
      len = 0;
      for (i = 0, l2 = chunks.length; i < l2; i++) {
        len += chunks[i].length;
      }
      result = new Uint8Array(len);
      pos = 0;
      for (i = 0, l2 = chunks.length; i < l2; i++) {
        chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    }
  };
  var fnUntyped = {
    arraySet: function arraySet(dest, src3, src_offs, len, dest_offs) {
      for (var i = 0; i < len; i++) {
        dest[dest_offs + i] = src3[src_offs + i];
      }
    },
    // Join array of chunks to single array.
    flattenChunks: function flattenChunks(chunks) {
      return [].concat.apply([], chunks);
    }
  };
  exports.setTyped = function(on3) {
    if (on3) {
      exports.Buf8 = Uint8Array;
      exports.Buf16 = Uint16Array;
      exports.Buf32 = Int32Array;
      exports.assign(exports, fnTyped);
    } else {
      exports.Buf8 = Array;
      exports.Buf16 = Array;
      exports.Buf32 = Array;
      exports.assign(exports, fnUntyped);
    }
  };
  exports.setTyped(TYPED_OK);
})(common);
var trees$1 = {};
var utils$3 = common;
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
);
var extra_dbits = (
  /* extra bits for each distance code */
  [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
);
var extra_blbits = (
  /* extra bits for each bit length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
);
var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}
function put_short(s2, w) {
  s2.pending_buf[s2.pending++] = w & 255;
  s2.pending_buf[s2.pending++] = w >>> 8 & 255;
}
function send_bits(s2, value2, length4) {
  if (s2.bi_valid > Buf_size - length4) {
    s2.bi_buf |= value2 << s2.bi_valid & 65535;
    put_short(s2, s2.bi_buf);
    s2.bi_buf = value2 >> Buf_size - s2.bi_valid;
    s2.bi_valid += length4 - Buf_size;
  } else {
    s2.bi_buf |= value2 << s2.bi_valid & 65535;
    s2.bi_valid += length4;
  }
}
function send_code(s2, c2, tree) {
  send_bits(
    s2,
    tree[c2 * 2],
    tree[c2 * 2 + 1]
    /*.Len*/
  );
}
function bi_reverse(code3, len) {
  var res = 0;
  do {
    res |= code3 & 1;
    code3 >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}
function bi_flush(s2) {
  if (s2.bi_valid === 16) {
    put_short(s2, s2.bi_buf);
    s2.bi_buf = 0;
    s2.bi_valid = 0;
  } else if (s2.bi_valid >= 8) {
    s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
    s2.bi_buf >>= 8;
    s2.bi_valid -= 8;
  }
}
function gen_bitlen(s2, desc) {
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h2;
  var n, m2;
  var bits;
  var xbits;
  var f;
  var overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s2.bl_count[bits] = 0;
  }
  tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
  for (h2 = s2.heap_max + 1; h2 < HEAP_SIZE$1; h2++) {
    n = s2.heap[h2];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s2.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s2.opt_len += f * (bits + xbits);
    if (has_stree) {
      s2.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s2.bl_count[bits] === 0) {
      bits--;
    }
    s2.bl_count[bits]--;
    s2.bl_count[bits + 1] += 2;
    s2.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s2.bl_count[bits];
    while (n !== 0) {
      m2 = s2.heap[--h2];
      if (m2 > max_code) {
        continue;
      }
      if (tree[m2 * 2 + 1] !== bits) {
        s2.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
        tree[m2 * 2 + 1] = bits;
      }
      n--;
    }
  }
}
function gen_codes(tree, max_code, bl_count) {
  var next_code = new Array(MAX_BITS$1 + 1);
  var code3 = 0;
  var bits;
  var n;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    next_code[bits] = code3 = code3 + bl_count[bits - 1] << 1;
  }
  for (n = 0; n <= max_code; n++) {
    var len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
}
function tr_static_init() {
  var n;
  var bits;
  var length4;
  var code3;
  var dist;
  var bl_count = new Array(MAX_BITS$1 + 1);
  length4 = 0;
  for (code3 = 0; code3 < LENGTH_CODES$1 - 1; code3++) {
    base_length[code3] = length4;
    for (n = 0; n < 1 << extra_lbits[code3]; n++) {
      _length_code[length4++] = code3;
    }
  }
  _length_code[length4 - 1] = code3;
  dist = 0;
  for (code3 = 0; code3 < 16; code3++) {
    base_dist[code3] = dist;
    for (n = 0; n < 1 << extra_dbits[code3]; n++) {
      _dist_code[dist++] = code3;
    }
  }
  dist >>= 7;
  for (; code3 < D_CODES$1; code3++) {
    base_dist[code3] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code3] - 7; n++) {
      _dist_code[256 + dist++] = code3;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
}
function init_block(s2) {
  var n;
  for (n = 0; n < L_CODES$1; n++) {
    s2.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s2.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s2.bl_tree[n * 2] = 0;
  }
  s2.dyn_ltree[END_BLOCK * 2] = 1;
  s2.opt_len = s2.static_len = 0;
  s2.last_lit = s2.matches = 0;
}
function bi_windup(s2) {
  if (s2.bi_valid > 8) {
    put_short(s2, s2.bi_buf);
  } else if (s2.bi_valid > 0) {
    s2.pending_buf[s2.pending++] = s2.bi_buf;
  }
  s2.bi_buf = 0;
  s2.bi_valid = 0;
}
function copy_block(s2, buf, len, header) {
  bi_windup(s2);
  if (header) {
    put_short(s2, len);
    put_short(s2, ~len);
  }
  utils$3.arraySet(s2.pending_buf, s2.window, buf, len, s2.pending);
  s2.pending += len;
}
function smaller(tree, n, m2, depth) {
  var _n2 = n * 2;
  var _m2 = m2 * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m2];
}
function pqdownheap(s2, tree, k) {
  var v2 = s2.heap[k];
  var j = k << 1;
  while (j <= s2.heap_len) {
    if (j < s2.heap_len && smaller(tree, s2.heap[j + 1], s2.heap[j], s2.depth)) {
      j++;
    }
    if (smaller(tree, v2, s2.heap[j], s2.depth)) {
      break;
    }
    s2.heap[k] = s2.heap[j];
    k = j;
    j <<= 1;
  }
  s2.heap[k] = v2;
}
function compress_block(s2, ltree, dtree) {
  var dist;
  var lc;
  var lx = 0;
  var code3;
  var extra;
  if (s2.last_lit !== 0) {
    do {
      dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
      lc = s2.pending_buf[s2.l_buf + lx];
      lx++;
      if (dist === 0) {
        send_code(s2, lc, ltree);
      } else {
        code3 = _length_code[lc];
        send_code(s2, code3 + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code3];
        if (extra !== 0) {
          lc -= base_length[code3];
          send_bits(s2, lc, extra);
        }
        dist--;
        code3 = d_code(dist);
        send_code(s2, code3, dtree);
        extra = extra_dbits[code3];
        if (extra !== 0) {
          dist -= base_dist[code3];
          send_bits(s2, dist, extra);
        }
      }
    } while (lx < s2.last_lit);
  }
  send_code(s2, END_BLOCK, ltree);
}
function build_tree(s2, desc) {
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n, m2;
  var max_code = -1;
  var node;
  s2.heap_len = 0;
  s2.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s2.heap[++s2.heap_len] = max_code = n;
      s2.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s2.heap_len < 2) {
    node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s2.depth[node] = 0;
    s2.opt_len--;
    if (has_stree) {
      s2.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s2.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s2, tree, n);
  }
  node = elems;
  do {
    n = s2.heap[
      1
      /*SMALLEST*/
    ];
    s2.heap[
      1
      /*SMALLEST*/
    ] = s2.heap[s2.heap_len--];
    pqdownheap(
      s2,
      tree,
      1
      /*SMALLEST*/
    );
    m2 = s2.heap[
      1
      /*SMALLEST*/
    ];
    s2.heap[--s2.heap_max] = n;
    s2.heap[--s2.heap_max] = m2;
    tree[node * 2] = tree[n * 2] + tree[m2 * 2];
    s2.depth[node] = (s2.depth[n] >= s2.depth[m2] ? s2.depth[n] : s2.depth[m2]) + 1;
    tree[n * 2 + 1] = tree[m2 * 2 + 1] = node;
    s2.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s2,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s2.heap_len >= 2);
  s2.heap[--s2.heap_max] = s2.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s2, desc);
  gen_codes(tree, max_code, s2.bl_count);
}
function scan_tree(s2, tree, max_code) {
  var n;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s2.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s2.bl_tree[curlen * 2]++;
      }
      s2.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s2.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s2.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function send_tree(s2, tree, max_code) {
  var n;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s2, curlen, s2.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s2, curlen, s2.bl_tree);
        count--;
      }
      send_code(s2, REP_3_6, s2.bl_tree);
      send_bits(s2, count - 3, 2);
    } else if (count <= 10) {
      send_code(s2, REPZ_3_10, s2.bl_tree);
      send_bits(s2, count - 3, 3);
    } else {
      send_code(s2, REPZ_11_138, s2.bl_tree);
      send_bits(s2, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function build_bl_tree(s2) {
  var max_blindex;
  scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
  scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
  build_tree(s2, s2.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
}
function send_all_trees(s2, lcodes, dcodes, blcodes) {
  var rank2;
  send_bits(s2, lcodes - 257, 5);
  send_bits(s2, dcodes - 1, 5);
  send_bits(s2, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(
      s2,
      s2.bl_tree[bl_order[rank2] * 2 + 1],
      3
    );
  }
  send_tree(s2, s2.dyn_ltree, lcodes - 1);
  send_tree(s2, s2.dyn_dtree, dcodes - 1);
}
function detect_data_type(s2) {
  var black_mask = 4093624447;
  var n;
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s2.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s2.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
}
var static_init_done = false;
function _tr_init(s2) {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
  s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
  s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
  s2.bi_buf = 0;
  s2.bi_valid = 0;
  init_block(s2);
}
function _tr_stored_block(s2, buf, stored_len, last3) {
  send_bits(s2, (STORED_BLOCK << 1) + (last3 ? 1 : 0), 3);
  copy_block(s2, buf, stored_len, true);
}
function _tr_align(s2) {
  send_bits(s2, STATIC_TREES << 1, 3);
  send_code(s2, END_BLOCK, static_ltree);
  bi_flush(s2);
}
function _tr_flush_block(s2, buf, stored_len, last3) {
  var opt_lenb, static_lenb;
  var max_blindex = 0;
  if (s2.level > 0) {
    if (s2.strm.data_type === Z_UNKNOWN$1) {
      s2.strm.data_type = detect_data_type(s2);
    }
    build_tree(s2, s2.l_desc);
    build_tree(s2, s2.d_desc);
    max_blindex = build_bl_tree(s2);
    opt_lenb = s2.opt_len + 3 + 7 >>> 3;
    static_lenb = s2.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block(s2, buf, stored_len, last3);
  } else if (s2.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s2, (STATIC_TREES << 1) + (last3 ? 1 : 0), 3);
    compress_block(s2, static_ltree, static_dtree);
  } else {
    send_bits(s2, (DYN_TREES << 1) + (last3 ? 1 : 0), 3);
    send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
  }
  init_block(s2);
  if (last3) {
    bi_windup(s2);
  }
}
function _tr_tally(s2, dist, lc) {
  s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
  s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
  s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
  s2.last_lit++;
  if (dist === 0) {
    s2.dyn_ltree[lc * 2]++;
  } else {
    s2.matches++;
    dist--;
    s2.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s2.dyn_dtree[d_code(dist) * 2]++;
  }
  return s2.last_lit === s2.lit_bufsize - 1;
}
trees$1._tr_init = _tr_init;
trees$1._tr_stored_block = _tr_stored_block;
trees$1._tr_flush_block = _tr_flush_block;
trees$1._tr_tally = _tr_tally;
trees$1._tr_align = _tr_align;
function adler32$2(adler, buf, len, pos) {
  var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
}
var adler32_1 = adler32$2;
function makeTable() {
  var c2, table = [];
  for (var n = 0; n < 256; n++) {
    c2 = n;
    for (var k = 0; k < 8; k++) {
      c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
    }
    table[n] = c2;
  }
  return table;
}
var crcTable = makeTable();
function crc32$2(crc, buf, len, pos) {
  var t2 = crcTable, end3 = pos + len;
  crc ^= -1;
  for (var i = pos; i < end3; i++) {
    crc = crc >>> 8 ^ t2[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
}
var crc32_1 = crc32$2;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var utils$2 = common;
var trees = trees$1;
var adler32$1 = adler32_1;
var crc32$1 = crc32_1;
var msg = messages;
var Z_NO_FLUSH = 0;
var Z_PARTIAL_FLUSH = 1;
var Z_FULL_FLUSH = 3;
var Z_FINISH$1 = 4;
var Z_BLOCK$1 = 5;
var Z_OK$1 = 0;
var Z_STREAM_END$1 = 1;
var Z_STREAM_ERROR$1 = -2;
var Z_DATA_ERROR$1 = -3;
var Z_BUF_ERROR$1 = -5;
var Z_DEFAULT_COMPRESSION = -1;
var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY = 0;
var Z_UNKNOWN = 2;
var Z_DEFLATED$1 = 8;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}
function rank(f) {
  return (f << 1) - (f > 4 ? 9 : 0);
}
function zero(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
function flush_pending(strm) {
  var s2 = strm.state;
  var len = s2.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  utils$2.arraySet(strm.output, s2.pending_buf, s2.pending_out, len, strm.next_out);
  strm.next_out += len;
  s2.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s2.pending -= len;
  if (s2.pending === 0) {
    s2.pending_out = 0;
  }
}
function flush_block_only(s2, last3) {
  trees._tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last3);
  s2.block_start = s2.strstart;
  flush_pending(s2.strm);
}
function put_byte(s2, b) {
  s2.pending_buf[s2.pending++] = b;
}
function putShortMSB(s2, b) {
  s2.pending_buf[s2.pending++] = b >>> 8 & 255;
  s2.pending_buf[s2.pending++] = b & 255;
}
function read_buf(strm, buf, start3, size) {
  var len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  utils$2.arraySet(buf, strm.input, strm.next_in, len, start3);
  if (strm.state.wrap === 1) {
    strm.adler = adler32$1(strm.adler, buf, len, start3);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32$1(strm.adler, buf, len, start3);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
}
function longest_match(s2, cur_match) {
  var chain_length = s2.max_chain_length;
  var scan = s2.strstart;
  var match;
  var len;
  var best_len = s2.prev_length;
  var nice_match = s2.nice_match;
  var limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
  var _win = s2.window;
  var wmask = s2.w_mask;
  var prev = s2.prev;
  var strend = s2.strstart + MAX_MATCH;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];
  if (s2.prev_length >= s2.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s2.lookahead) {
    nice_match = s2.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s2.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s2.lookahead) {
    return best_len;
  }
  return s2.lookahead;
}
function fill_window(s2) {
  var _w_size = s2.w_size;
  var p, n, m2, more, str;
  do {
    more = s2.window_size - s2.lookahead - s2.strstart;
    if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      utils$2.arraySet(s2.window, s2.window, _w_size, _w_size, 0);
      s2.match_start -= _w_size;
      s2.strstart -= _w_size;
      s2.block_start -= _w_size;
      n = s2.hash_size;
      p = n;
      do {
        m2 = s2.head[--p];
        s2.head[p] = m2 >= _w_size ? m2 - _w_size : 0;
      } while (--n);
      n = _w_size;
      p = n;
      do {
        m2 = s2.prev[--p];
        s2.prev[p] = m2 >= _w_size ? m2 - _w_size : 0;
      } while (--n);
      more += _w_size;
    }
    if (s2.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
    s2.lookahead += n;
    if (s2.lookahead + s2.insert >= MIN_MATCH) {
      str = s2.strstart - s2.insert;
      s2.ins_h = s2.window[str];
      s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + 1]) & s2.hash_mask;
      while (s2.insert) {
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
        s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = str;
        str++;
        s2.insert--;
        if (s2.lookahead + s2.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
}
function deflate_stored(s2, flush) {
  var max_block_size = 65535;
  if (max_block_size > s2.pending_buf_size - 5) {
    max_block_size = s2.pending_buf_size - 5;
  }
  for (; ; ) {
    if (s2.lookahead <= 1) {
      fill_window(s2);
      if (s2.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    s2.strstart += s2.lookahead;
    s2.lookahead = 0;
    var max_start = s2.block_start + max_block_size;
    if (s2.strstart === 0 || s2.strstart >= max_start) {
      s2.lookahead = s2.strstart - max_start;
      s2.strstart = max_start;
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.strstart > s2.block_start) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_NEED_MORE;
}
function deflate_fast(s2, flush) {
  var hash_head;
  var bflush;
  for (; ; ) {
    if (s2.lookahead < MIN_LOOKAHEAD) {
      fill_window(s2);
      if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s2.lookahead >= MIN_MATCH) {
      s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
      hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = s2.strstart;
    }
    if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
      s2.match_length = longest_match(s2, hash_head);
    }
    if (s2.match_length >= MIN_MATCH) {
      bflush = trees._tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
      s2.lookahead -= s2.match_length;
      if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
        s2.match_length--;
        do {
          s2.strstart++;
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        } while (--s2.match_length !== 0);
        s2.strstart++;
      } else {
        s2.strstart += s2.match_length;
        s2.match_length = 0;
        s2.ins_h = s2.window[s2.strstart];
        s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + 1]) & s2.hash_mask;
      }
    } else {
      bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
    }
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_slow(s2, flush) {
  var hash_head;
  var bflush;
  var max_insert;
  for (; ; ) {
    if (s2.lookahead < MIN_LOOKAHEAD) {
      fill_window(s2);
      if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s2.lookahead >= MIN_MATCH) {
      s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
      hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = s2.strstart;
    }
    s2.prev_length = s2.match_length;
    s2.prev_match = s2.match_start;
    s2.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
      s2.match_length = longest_match(s2, hash_head);
      if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
        s2.match_length = MIN_MATCH - 1;
      }
    }
    if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
      max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
      bflush = trees._tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
      s2.lookahead -= s2.prev_length - 1;
      s2.prev_length -= 2;
      do {
        if (++s2.strstart <= max_insert) {
          s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH - 1]) & s2.hash_mask;
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
      } while (--s2.prev_length !== 0);
      s2.match_available = 0;
      s2.match_length = MIN_MATCH - 1;
      s2.strstart++;
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s2.match_available) {
      bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
      if (bflush) {
        flush_block_only(s2, false);
      }
      s2.strstart++;
      s2.lookahead--;
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s2.match_available = 1;
      s2.strstart++;
      s2.lookahead--;
    }
  }
  if (s2.match_available) {
    bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart - 1]);
    s2.match_available = 0;
  }
  s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_rle(s2, flush) {
  var bflush;
  var prev;
  var scan, strend;
  var _win = s2.window;
  for (; ; ) {
    if (s2.lookahead <= MAX_MATCH) {
      fill_window(s2);
      if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s2.lookahead === 0) {
        break;
      }
    }
    s2.match_length = 0;
    if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
      scan = s2.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s2.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s2.match_length = MAX_MATCH - (strend - scan);
        if (s2.match_length > s2.lookahead) {
          s2.match_length = s2.lookahead;
        }
      }
    }
    if (s2.match_length >= MIN_MATCH) {
      bflush = trees._tr_tally(s2, 1, s2.match_length - MIN_MATCH);
      s2.lookahead -= s2.match_length;
      s2.strstart += s2.match_length;
      s2.match_length = 0;
    } else {
      bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
    }
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_huff(s2, flush) {
  var bflush;
  for (; ; ) {
    if (s2.lookahead === 0) {
      fill_window(s2);
      if (s2.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s2.match_length = 0;
    bflush = trees._tr_tally(s2, 0, s2.window[s2.strstart]);
    s2.lookahead--;
    s2.strstart++;
    if (bflush) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s2.insert = 0;
  if (flush === Z_FINISH$1) {
    flush_block_only(s2, true);
    if (s2.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s2.last_lit) {
    flush_block_only(s2, false);
    if (s2.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table;
configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
function lm_init(s2) {
  s2.window_size = 2 * s2.w_size;
  zero(s2.head);
  s2.max_lazy_match = configuration_table[s2.level].max_lazy;
  s2.good_match = configuration_table[s2.level].good_length;
  s2.nice_match = configuration_table[s2.level].nice_length;
  s2.max_chain_length = configuration_table[s2.level].max_chain;
  s2.strstart = 0;
  s2.block_start = 0;
  s2.lookahead = 0;
  s2.insert = 0;
  s2.match_length = s2.prev_length = MIN_MATCH - 1;
  s2.match_available = 0;
  s2.ins_h = 0;
}
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$1;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new utils$2.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree = new utils$2.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree = new utils$2.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new utils$2.Buf16(MAX_BITS + 1);
  this.heap = new utils$2.Buf16(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new utils$2.Buf16(2 * L_CODES + 1);
  zero(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
function deflateResetKeep(strm) {
  var s2;
  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  s2 = strm.state;
  s2.pending = 0;
  s2.pending_out = 0;
  if (s2.wrap < 0) {
    s2.wrap = -s2.wrap;
  }
  s2.status = s2.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s2.wrap === 2 ? 0 : 1;
  s2.last_flush = Z_NO_FLUSH;
  trees._tr_init(s2);
  return Z_OK$1;
}
function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK$1) {
    lm_init(strm.state);
  }
  return ret;
}
function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$1;
  }
  strm.state.gzhead = head;
  return Z_OK$1;
}
function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  var wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$1 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  var s2 = new DeflateState();
  strm.state = s2;
  s2.strm = strm;
  s2.wrap = wrap;
  s2.gzhead = null;
  s2.w_bits = windowBits;
  s2.w_size = 1 << s2.w_bits;
  s2.w_mask = s2.w_size - 1;
  s2.hash_bits = memLevel + 7;
  s2.hash_size = 1 << s2.hash_bits;
  s2.hash_mask = s2.hash_size - 1;
  s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s2.window = new utils$2.Buf8(s2.w_size * 2);
  s2.head = new utils$2.Buf16(s2.hash_size);
  s2.prev = new utils$2.Buf16(s2.w_size);
  s2.lit_bufsize = 1 << memLevel + 6;
  s2.pending_buf_size = s2.lit_bufsize * 4;
  s2.pending_buf = new utils$2.Buf8(s2.pending_buf_size);
  s2.d_buf = 1 * s2.lit_bufsize;
  s2.l_buf = (1 + 2) * s2.lit_bufsize;
  s2.level = level;
  s2.strategy = strategy;
  s2.method = method;
  return deflateReset(strm);
}
function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED$1, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}
function deflate(strm, flush) {
  var old_flush, s2;
  var beg, val;
  if (!strm || !strm.state || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$1) : Z_STREAM_ERROR$1;
  }
  s2 = strm.state;
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE && flush !== Z_FINISH$1) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$1);
  }
  s2.strm = strm;
  old_flush = s2.last_flush;
  s2.last_flush = flush;
  if (s2.status === INIT_STATE) {
    if (s2.wrap === 2) {
      strm.adler = 0;
      put_byte(s2, 31);
      put_byte(s2, 139);
      put_byte(s2, 8);
      if (!s2.gzhead) {
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
        put_byte(s2, OS_CODE);
        s2.status = BUSY_STATE;
      } else {
        put_byte(s2, (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16));
        put_byte(s2, s2.gzhead.time & 255);
        put_byte(s2, s2.gzhead.time >> 8 & 255);
        put_byte(s2, s2.gzhead.time >> 16 & 255);
        put_byte(s2, s2.gzhead.time >> 24 & 255);
        put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
        put_byte(s2, s2.gzhead.os & 255);
        if (s2.gzhead.extra && s2.gzhead.extra.length) {
          put_byte(s2, s2.gzhead.extra.length & 255);
          put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
        }
        if (s2.gzhead.hcrc) {
          strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending, 0);
        }
        s2.gzindex = 0;
        s2.status = EXTRA_STATE;
      }
    } else {
      var header = Z_DEFLATED$1 + (s2.w_bits - 8 << 4) << 8;
      var level_flags = -1;
      if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
        level_flags = 0;
      } else if (s2.level < 6) {
        level_flags = 1;
      } else if (s2.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s2.strstart !== 0) {
        header |= PRESET_DICT;
      }
      header += 31 - header % 31;
      s2.status = BUSY_STATE;
      putShortMSB(s2, header);
      if (s2.strstart !== 0) {
        putShortMSB(s2, strm.adler >>> 16);
        putShortMSB(s2, strm.adler & 65535);
      }
      strm.adler = 1;
    }
  }
  if (s2.status === EXTRA_STATE) {
    if (s2.gzhead.extra) {
      beg = s2.pending;
      while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s2.pending;
          if (s2.pending === s2.pending_buf_size) {
            break;
          }
        }
        put_byte(s2, s2.gzhead.extra[s2.gzindex] & 255);
        s2.gzindex++;
      }
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      if (s2.gzindex === s2.gzhead.extra.length) {
        s2.gzindex = 0;
        s2.status = NAME_STATE;
      }
    } else {
      s2.status = NAME_STATE;
    }
  }
  if (s2.status === NAME_STATE) {
    if (s2.gzhead.name) {
      beg = s2.pending;
      do {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s2.pending;
          if (s2.pending === s2.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s2.gzindex < s2.gzhead.name.length) {
          val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s2, val);
      } while (val !== 0);
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      if (val === 0) {
        s2.gzindex = 0;
        s2.status = COMMENT_STATE;
      }
    } else {
      s2.status = COMMENT_STATE;
    }
  }
  if (s2.status === COMMENT_STATE) {
    if (s2.gzhead.comment) {
      beg = s2.pending;
      do {
        if (s2.pending === s2.pending_buf_size) {
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s2.pending;
          if (s2.pending === s2.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s2.gzindex < s2.gzhead.comment.length) {
          val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s2, val);
      } while (val !== 0);
      if (s2.gzhead.hcrc && s2.pending > beg) {
        strm.adler = crc32$1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
      }
      if (val === 0) {
        s2.status = HCRC_STATE;
      }
    } else {
      s2.status = HCRC_STATE;
    }
  }
  if (s2.status === HCRC_STATE) {
    if (s2.gzhead.hcrc) {
      if (s2.pending + 2 > s2.pending_buf_size) {
        flush_pending(strm);
      }
      if (s2.pending + 2 <= s2.pending_buf_size) {
        put_byte(s2, strm.adler & 255);
        put_byte(s2, strm.adler >> 8 & 255);
        strm.adler = 0;
        s2.status = BUSY_STATE;
      }
    } else {
      s2.status = BUSY_STATE;
    }
  }
  if (s2.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s2.last_flush = -1;
      return Z_OK$1;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$1) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH && s2.status !== FINISH_STATE) {
    var bstate = s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s2.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
      }
      return Z_OK$1;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s2);
      } else if (flush !== Z_BLOCK$1) {
        trees._tr_stored_block(s2, 0, 0, false);
        if (flush === Z_FULL_FLUSH) {
          zero(s2.head);
          if (s2.lookahead === 0) {
            s2.strstart = 0;
            s2.block_start = 0;
            s2.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
        return Z_OK$1;
      }
    }
  }
  if (flush !== Z_FINISH$1) {
    return Z_OK$1;
  }
  if (s2.wrap <= 0) {
    return Z_STREAM_END$1;
  }
  if (s2.wrap === 2) {
    put_byte(s2, strm.adler & 255);
    put_byte(s2, strm.adler >> 8 & 255);
    put_byte(s2, strm.adler >> 16 & 255);
    put_byte(s2, strm.adler >> 24 & 255);
    put_byte(s2, strm.total_in & 255);
    put_byte(s2, strm.total_in >> 8 & 255);
    put_byte(s2, strm.total_in >> 16 & 255);
    put_byte(s2, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s2, strm.adler >>> 16);
    putShortMSB(s2, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s2.wrap > 0) {
    s2.wrap = -s2.wrap;
  }
  return s2.pending !== 0 ? Z_OK$1 : Z_STREAM_END$1;
}
function deflateEnd(strm) {
  var status;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  status = strm.state.status;
  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR$1);
  }
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$1) : Z_OK$1;
}
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var s2;
  var str, n;
  var wrap;
  var avail;
  var next2;
  var input;
  var tmpDict;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  s2 = strm.state;
  wrap = s2.wrap;
  if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
    return Z_STREAM_ERROR$1;
  }
  if (wrap === 1) {
    strm.adler = adler32$1(strm.adler, dictionary, dictLength, 0);
  }
  s2.wrap = 0;
  if (dictLength >= s2.w_size) {
    if (wrap === 0) {
      zero(s2.head);
      s2.strstart = 0;
      s2.block_start = 0;
      s2.insert = 0;
    }
    tmpDict = new utils$2.Buf8(s2.w_size);
    utils$2.arraySet(tmpDict, dictionary, dictLength - s2.w_size, s2.w_size, 0);
    dictionary = tmpDict;
    dictLength = s2.w_size;
  }
  avail = strm.avail_in;
  next2 = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s2);
  while (s2.lookahead >= MIN_MATCH) {
    str = s2.strstart;
    n = s2.lookahead - (MIN_MATCH - 1);
    do {
      s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH - 1]) & s2.hash_mask;
      s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
      s2.head[s2.ins_h] = str;
      str++;
    } while (--n);
    s2.strstart = str;
    s2.lookahead = MIN_MATCH - 1;
    fill_window(s2);
  }
  s2.strstart += s2.lookahead;
  s2.block_start = s2.strstart;
  s2.insert = s2.lookahead;
  s2.lookahead = 0;
  s2.match_length = s2.prev_length = MIN_MATCH - 1;
  s2.match_available = 0;
  strm.next_in = next2;
  strm.input = input;
  strm.avail_in = avail;
  s2.wrap = wrap;
  return Z_OK$1;
}
deflate$1.deflateInit = deflateInit;
deflate$1.deflateInit2 = deflateInit2;
deflate$1.deflateReset = deflateReset;
deflate$1.deflateResetKeep = deflateResetKeep;
deflate$1.deflateSetHeader = deflateSetHeader;
deflate$1.deflate = deflate;
deflate$1.deflateEnd = deflateEnd;
deflate$1.deflateSetDictionary = deflateSetDictionary;
deflate$1.deflateInfo = "pako deflate (from Nodeca project)";
var inflate$1 = {};
var BAD$1 = 30;
var TYPE$1 = 12;
var inffast = function inflate_fast(strm, start3) {
  var state2;
  var _in;
  var last3;
  var _out;
  var beg;
  var end3;
  var dmax;
  var wsize;
  var whave;
  var wnext;
  var s_window;
  var hold;
  var bits;
  var lcode;
  var dcode;
  var lmask;
  var dmask;
  var here;
  var op;
  var len;
  var dist;
  var from4;
  var from_source;
  var input, output;
  state2 = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last3 = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start3 - strm.avail_out);
  end3 = _out + (strm.avail_out - 257);
  dmax = state2.dmax;
  wsize = state2.wsize;
  whave = state2.whave;
  wnext = state2.wnext;
  s_window = state2.window;
  hold = state2.hold;
  bits = state2.bits;
  lcode = state2.lencode;
  dcode = state2.distcode;
  lmask = (1 << state2.lenbits) - 1;
  dmask = (1 << state2.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state2.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state2.sane) {
                        strm.msg = "invalid distance too far back";
                        state2.mode = BAD$1;
                        break top;
                      }
                    }
                    from4 = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from4 += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from4++];
                        } while (--op);
                        from4 = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from4 += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from4++];
                        } while (--op);
                        from4 = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from4++];
                          } while (--op);
                          from4 = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from4 += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from4++];
                        } while (--op);
                        from4 = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from4++];
                      output[_out++] = from_source[from4++];
                      output[_out++] = from_source[from4++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from4++];
                      if (len > 1) {
                        output[_out++] = from_source[from4++];
                      }
                    }
                  } else {
                    from4 = _out - dist;
                    do {
                      output[_out++] = output[from4++];
                      output[_out++] = output[from4++];
                      output[_out++] = output[from4++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from4++];
                      if (len > 1) {
                        output[_out++] = output[from4++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state2.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state2.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state2.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last3 && _out < end3);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last3 ? 5 + (last3 - _in) : 5 - (_in - last3);
  strm.avail_out = _out < end3 ? 257 + (end3 - _out) : 257 - (_out - end3);
  state2.hold = hold;
  state2.bits = bits;
  return;
};
var utils$1 = common;
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = [
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
];
var lext = [
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
];
var dbase = [
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
];
var dext = [
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
];
var inftrees = function inflate_table(type, lens, lens_index, codes3, table, table_index, work, opts2) {
  var bits = opts2.bits;
  var len = 0;
  var sym = 0;
  var min3 = 0, max3 = 0;
  var root = 0;
  var curr = 0;
  var drop = 0;
  var left = 0;
  var used = 0;
  var huff = 0;
  var incr;
  var fill5;
  var low;
  var mask;
  var next2;
  var base = null;
  var base_index = 0;
  var end3;
  var count = new utils$1.Buf16(MAXBITS + 1);
  var offs = new utils$1.Buf16(MAXBITS + 1);
  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes3; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max3 = MAXBITS; max3 >= 1; max3--) {
    if (count[max3] !== 0) {
      break;
    }
  }
  if (root > max3) {
    root = max3;
  }
  if (max3 === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts2.bits = 1;
    return 0;
  }
  for (min3 = 1; min3 < max3; min3++) {
    if (count[min3] !== 0) {
      break;
    }
  }
  if (root < min3) {
    root = min3;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max3 !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes3; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    end3 = 19;
  } else if (type === LENS$1) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end3 = 256;
  } else {
    base = dbase;
    extra = dext;
    end3 = -1;
  }
  huff = 0;
  sym = 0;
  len = min3;
  next2 = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] < end3) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end3) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill5 = 1 << curr;
    min3 = fill5;
    do {
      fill5 -= incr;
      table[next2 + (huff >> drop) + fill5] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill5 !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max3) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next2 += min3;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max3) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next2 - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next2 + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts2.bits = root;
  return 0;
};
var utils = common;
var adler32 = adler32_1;
var crc32 = crc32_1;
var inflate_fast2 = inffast;
var inflate_table2 = inftrees;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_TREES = 6;
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5;
var Z_DEFLATED = 8;
var HEAD = 1;
var FLAGS = 2;
var TIME = 3;
var OS = 4;
var EXLEN = 5;
var EXTRA = 6;
var NAME = 7;
var COMMENT = 8;
var HCRC = 9;
var DICTID = 10;
var DICT = 11;
var TYPE = 12;
var TYPEDO = 13;
var STORED = 14;
var COPY_ = 15;
var COPY = 16;
var TABLE = 17;
var LENLENS = 18;
var CODELENS = 19;
var LEN_ = 20;
var LEN = 21;
var LENEXT = 22;
var DIST = 23;
var DISTEXT = 24;
var MATCH = 25;
var LIT = 26;
var CHECK = 27;
var LENGTH = 28;
var DONE = 29;
var BAD = 30;
var MEM = 31;
var SYNC = 32;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
function zswap32(q2) {
  return (q2 >>> 24 & 255) + (q2 >>> 8 & 65280) + ((q2 & 65280) << 8) + ((q2 & 255) << 24);
}
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new utils.Buf16(320);
  this.work = new utils.Buf16(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
function inflateResetKeep(strm) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  strm.total_in = strm.total_out = state2.total = 0;
  strm.msg = "";
  if (state2.wrap) {
    strm.adler = state2.wrap & 1;
  }
  state2.mode = HEAD;
  state2.last = 0;
  state2.havedict = 0;
  state2.dmax = 32768;
  state2.head = null;
  state2.hold = 0;
  state2.bits = 0;
  state2.lencode = state2.lendyn = new utils.Buf32(ENOUGH_LENS);
  state2.distcode = state2.distdyn = new utils.Buf32(ENOUGH_DISTS);
  state2.sane = 1;
  state2.back = -1;
  return Z_OK;
}
function inflateReset(strm) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  state2.wsize = 0;
  state2.whave = 0;
  state2.wnext = 0;
  return inflateResetKeep(strm);
}
function inflateReset2(strm, windowBits) {
  var wrap;
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state2.window !== null && state2.wbits !== windowBits) {
    state2.window = null;
  }
  state2.wrap = wrap;
  state2.wbits = windowBits;
  return inflateReset(strm);
}
function inflateInit2(strm, windowBits) {
  var ret;
  var state2;
  if (!strm) {
    return Z_STREAM_ERROR;
  }
  state2 = new InflateState();
  strm.state = state2;
  state2.window = null;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null;
  }
  return ret;
}
function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}
var virgin = true;
var lenfix;
var distfix;
function fixedtables(state2) {
  if (virgin) {
    var sym;
    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);
    sym = 0;
    while (sym < 144) {
      state2.lens[sym++] = 8;
    }
    while (sym < 256) {
      state2.lens[sym++] = 9;
    }
    while (sym < 280) {
      state2.lens[sym++] = 7;
    }
    while (sym < 288) {
      state2.lens[sym++] = 8;
    }
    inflate_table2(LENS, state2.lens, 0, 288, lenfix, 0, state2.work, {
      bits: 9
    });
    sym = 0;
    while (sym < 32) {
      state2.lens[sym++] = 5;
    }
    inflate_table2(DISTS, state2.lens, 0, 32, distfix, 0, state2.work, {
      bits: 5
    });
    virgin = false;
  }
  state2.lencode = lenfix;
  state2.lenbits = 9;
  state2.distcode = distfix;
  state2.distbits = 5;
}
function updatewindow(strm, src3, end3, copy6) {
  var dist;
  var state2 = strm.state;
  if (state2.window === null) {
    state2.wsize = 1 << state2.wbits;
    state2.wnext = 0;
    state2.whave = 0;
    state2.window = new utils.Buf8(state2.wsize);
  }
  if (copy6 >= state2.wsize) {
    utils.arraySet(state2.window, src3, end3 - state2.wsize, state2.wsize, 0);
    state2.wnext = 0;
    state2.whave = state2.wsize;
  } else {
    dist = state2.wsize - state2.wnext;
    if (dist > copy6) {
      dist = copy6;
    }
    utils.arraySet(state2.window, src3, end3 - copy6, dist, state2.wnext);
    copy6 -= dist;
    if (copy6) {
      utils.arraySet(state2.window, src3, end3 - copy6, copy6, 0);
      state2.wnext = copy6;
      state2.whave = state2.wsize;
    } else {
      state2.wnext += dist;
      if (state2.wnext === state2.wsize) {
        state2.wnext = 0;
      }
      if (state2.whave < state2.wsize) {
        state2.whave += dist;
      }
    }
  }
  return 0;
}
function inflate(strm, flush) {
  var state2;
  var input, output;
  var next2;
  var put;
  var have, left;
  var hold;
  var bits;
  var _in, _out;
  var copy6;
  var from4;
  var from_source;
  var here = 0;
  var here_bits, here_op, here_val;
  var last_bits, last_op, last_val;
  var len;
  var ret;
  var hbuf = new utils.Buf8(4);
  var opts2;
  var n;
  var order = (
    /* permutation of code lengths */
    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
  );
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if (state2.mode === TYPE) {
    state2.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next2 = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state2.hold;
  bits = state2.bits;
  _in = have;
  _out = left;
  ret = Z_OK;
  inf_leave:
    for (; ; ) {
      switch (state2.mode) {
        case HEAD:
          if (state2.wrap === 0) {
            state2.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (state2.wrap & 2 && hold === 35615) {
            state2.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32(state2.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state2.mode = FLAGS;
            break;
          }
          state2.flags = 0;
          if (state2.head) {
            state2.head.done = false;
          }
          if (!(state2.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state2.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state2.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state2.wbits === 0) {
            state2.wbits = len;
          } else if (len > state2.wbits) {
            strm.msg = "invalid window size";
            state2.mode = BAD;
            break;
          }
          state2.dmax = 1 << len;
          strm.adler = state2.check = 1;
          state2.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          state2.flags = hold;
          if ((state2.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state2.mode = BAD;
            break;
          }
          if (state2.flags & 57344) {
            strm.msg = "unknown header flags set";
            state2.mode = BAD;
            break;
          }
          if (state2.head) {
            state2.head.text = hold >> 8 & 1;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32(state2.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (state2.head) {
            state2.head.time = hold;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state2.check = crc32(state2.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (state2.head) {
            state2.head.xflags = hold & 255;
            state2.head.os = hold >> 8;
          }
          if (state2.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state2.check = crc32(state2.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state2.mode = EXLEN;
        case EXLEN:
          if (state2.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state2.length = hold;
            if (state2.head) {
              state2.head.extra_len = hold;
            }
            if (state2.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc32(state2.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state2.head) {
            state2.head.extra = null;
          }
          state2.mode = EXTRA;
        case EXTRA:
          if (state2.flags & 1024) {
            copy6 = state2.length;
            if (copy6 > have) {
              copy6 = have;
            }
            if (copy6) {
              if (state2.head) {
                len = state2.head.extra_len - state2.length;
                if (!state2.head.extra) {
                  state2.head.extra = new Array(state2.head.extra_len);
                }
                utils.arraySet(
                  state2.head.extra,
                  input,
                  next2,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  copy6,
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state2.flags & 512) {
                state2.check = crc32(state2.check, input, copy6, next2);
              }
              have -= copy6;
              next2 += copy6;
              state2.length -= copy6;
            }
            if (state2.length) {
              break inf_leave;
            }
          }
          state2.length = 0;
          state2.mode = NAME;
        case NAME:
          if (state2.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy6 = 0;
            do {
              len = input[next2 + copy6++];
              if (state2.head && len && state2.length < 65536) {
                state2.head.name += String.fromCharCode(len);
              }
            } while (len && copy6 < have);
            if (state2.flags & 512) {
              state2.check = crc32(state2.check, input, copy6, next2);
            }
            have -= copy6;
            next2 += copy6;
            if (len) {
              break inf_leave;
            }
          } else if (state2.head) {
            state2.head.name = null;
          }
          state2.length = 0;
          state2.mode = COMMENT;
        case COMMENT:
          if (state2.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy6 = 0;
            do {
              len = input[next2 + copy6++];
              if (state2.head && len && state2.length < 65536) {
                state2.head.comment += String.fromCharCode(len);
              }
            } while (len && copy6 < have);
            if (state2.flags & 512) {
              state2.check = crc32(state2.check, input, copy6, next2);
            }
            have -= copy6;
            next2 += copy6;
            if (len) {
              break inf_leave;
            }
          } else if (state2.head) {
            state2.head.comment = null;
          }
          state2.mode = HCRC;
        case HCRC:
          if (state2.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (hold !== (state2.check & 65535)) {
              strm.msg = "header crc mismatch";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state2.head) {
            state2.head.hcrc = state2.flags >> 9 & 1;
            state2.head.done = true;
          }
          strm.adler = state2.check = 0;
          state2.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          strm.adler = state2.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state2.mode = DICT;
        case DICT:
          if (state2.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next2;
            strm.avail_in = have;
            state2.hold = hold;
            state2.bits = bits;
            return Z_NEED_DICT;
          }
          strm.adler = state2.check = 1;
          state2.mode = TYPE;
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state2.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state2.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          state2.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state2.mode = STORED;
              break;
            case 1:
              fixedtables(state2);
              state2.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state2.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state2.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state2.mode = BAD;
            break;
          }
          state2.length = hold & 65535;
          hold = 0;
          bits = 0;
          state2.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state2.mode = COPY;
        case COPY:
          copy6 = state2.length;
          if (copy6) {
            if (copy6 > have) {
              copy6 = have;
            }
            if (copy6 > left) {
              copy6 = left;
            }
            if (copy6 === 0) {
              break inf_leave;
            }
            utils.arraySet(output, input, next2, copy6, put);
            have -= copy6;
            next2 += copy6;
            left -= copy6;
            put += copy6;
            state2.length -= copy6;
            break;
          }
          state2.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          state2.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state2.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state2.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state2.nlen > 286 || state2.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state2.mode = BAD;
            break;
          }
          state2.have = 0;
          state2.mode = LENLENS;
        case LENLENS:
          while (state2.have < state2.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state2.lens[order[state2.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state2.have < 19) {
            state2.lens[order[state2.have++]] = 0;
          }
          state2.lencode = state2.lendyn;
          state2.lenbits = 7;
          opts2 = {
            bits: state2.lenbits
          };
          ret = inflate_table2(CODES, state2.lens, 0, 19, state2.lencode, 0, state2.work, opts2);
          state2.lenbits = opts2.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state2.mode = BAD;
            break;
          }
          state2.have = 0;
          state2.mode = CODELENS;
        case CODELENS:
          while (state2.have < state2.nlen + state2.ndist) {
            for (; ; ) {
              here = state2.lencode[hold & (1 << state2.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state2.lens[state2.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state2.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state2.mode = BAD;
                  break;
                }
                len = state2.lens[state2.have - 1];
                copy6 = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy6 = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy6 = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state2.have + copy6 > state2.nlen + state2.ndist) {
                strm.msg = "invalid bit length repeat";
                state2.mode = BAD;
                break;
              }
              while (copy6--) {
                state2.lens[state2.have++] = len;
              }
            }
          }
          if (state2.mode === BAD) {
            break;
          }
          if (state2.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state2.mode = BAD;
            break;
          }
          state2.lenbits = 9;
          opts2 = {
            bits: state2.lenbits
          };
          ret = inflate_table2(LENS, state2.lens, 0, state2.nlen, state2.lencode, 0, state2.work, opts2);
          state2.lenbits = opts2.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state2.mode = BAD;
            break;
          }
          state2.distbits = 6;
          state2.distcode = state2.distdyn;
          opts2 = {
            bits: state2.distbits
          };
          ret = inflate_table2(DISTS, state2.lens, state2.nlen, state2.ndist, state2.distcode, 0, state2.work, opts2);
          state2.distbits = opts2.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state2.mode = BAD;
            break;
          }
          state2.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state2.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next2;
            strm.avail_in = have;
            state2.hold = hold;
            state2.bits = bits;
            inflate_fast2(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next2 = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state2.hold;
            bits = state2.bits;
            if (state2.mode === TYPE) {
              state2.back = -1;
            }
            break;
          }
          state2.back = 0;
          for (; ; ) {
            here = state2.lencode[hold & (1 << state2.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state2.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state2.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state2.back += here_bits;
          state2.length = here_val;
          if (here_op === 0) {
            state2.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state2.back = -1;
            state2.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state2.mode = BAD;
            break;
          }
          state2.extra = here_op & 15;
          state2.mode = LENEXT;
        case LENEXT:
          if (state2.extra) {
            n = state2.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state2.length += hold & (1 << state2.extra) - 1;
            hold >>>= state2.extra;
            bits -= state2.extra;
            state2.back += state2.extra;
          }
          state2.was = state2.length;
          state2.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state2.distcode[hold & (1 << state2.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next2++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state2.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state2.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state2.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state2.mode = BAD;
            break;
          }
          state2.offset = here_val;
          state2.extra = here_op & 15;
          state2.mode = DISTEXT;
        case DISTEXT:
          if (state2.extra) {
            n = state2.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state2.offset += hold & (1 << state2.extra) - 1;
            hold >>>= state2.extra;
            bits -= state2.extra;
            state2.back += state2.extra;
          }
          if (state2.offset > state2.dmax) {
            strm.msg = "invalid distance too far back";
            state2.mode = BAD;
            break;
          }
          state2.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy6 = _out - left;
          if (state2.offset > copy6) {
            copy6 = state2.offset - copy6;
            if (copy6 > state2.whave) {
              if (state2.sane) {
                strm.msg = "invalid distance too far back";
                state2.mode = BAD;
                break;
              }
            }
            if (copy6 > state2.wnext) {
              copy6 -= state2.wnext;
              from4 = state2.wsize - copy6;
            } else {
              from4 = state2.wnext - copy6;
            }
            if (copy6 > state2.length) {
              copy6 = state2.length;
            }
            from_source = state2.window;
          } else {
            from_source = output;
            from4 = put - state2.offset;
            copy6 = state2.length;
          }
          if (copy6 > left) {
            copy6 = left;
          }
          left -= copy6;
          state2.length -= copy6;
          do {
            output[put++] = from_source[from4++];
          } while (--copy6);
          if (state2.length === 0) {
            state2.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state2.length;
          left--;
          state2.mode = LEN;
          break;
        case CHECK:
          if (state2.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next2++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state2.total += _out;
            if (_out) {
              strm.adler = state2.check = /*UPDATE(state.check, put - _out, _out);*/
              state2.flags ? crc32(state2.check, output, _out, put - _out) : adler32(state2.check, output, _out, put - _out);
            }
            _out = left;
            if ((state2.flags ? hold : zswap32(hold)) !== state2.check) {
              strm.msg = "incorrect data check";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state2.mode = LENGTH;
        case LENGTH:
          if (state2.wrap && state2.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (hold !== (state2.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state2.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state2.mode = DONE;
        case DONE:
          ret = Z_STREAM_END;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR;
        case SYNC:
        default:
          return Z_STREAM_ERROR;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next2;
  strm.avail_in = have;
  state2.hold = hold;
  state2.bits = bits;
  if (state2.wsize || _out !== strm.avail_out && state2.mode < BAD && (state2.mode < CHECK || flush !== Z_FINISH)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state2.total += _out;
  if (state2.wrap && _out) {
    strm.adler = state2.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state2.flags ? crc32(state2.check, output, _out, strm.next_out - _out) : adler32(state2.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state2.bits + (state2.last ? 64 : 0) + (state2.mode === TYPE ? 128 : 0) + (state2.mode === LEN_ || state2.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}
function inflateEnd(strm) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  var state2 = strm.state;
  if (state2.window) {
    state2.window = null;
  }
  strm.state = null;
  return Z_OK;
}
function inflateGetHeader(strm, head) {
  var state2;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if ((state2.wrap & 2) === 0) {
    return Z_STREAM_ERROR;
  }
  state2.head = head;
  head.done = false;
  return Z_OK;
}
function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var state2;
  var dictid;
  var ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  state2 = strm.state;
  if (state2.wrap !== 0 && state2.mode !== DICT) {
    return Z_STREAM_ERROR;
  }
  if (state2.mode === DICT) {
    dictid = 1;
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state2.check) {
      return Z_DATA_ERROR;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state2.mode = MEM;
    return Z_MEM_ERROR;
  }
  state2.havedict = 1;
  return Z_OK;
}
inflate$1.inflateReset = inflateReset;
inflate$1.inflateReset2 = inflateReset2;
inflate$1.inflateResetKeep = inflateResetKeep;
inflate$1.inflateInit = inflateInit;
inflate$1.inflateInit2 = inflateInit2;
inflate$1.inflate = inflate;
inflate$1.inflateEnd = inflateEnd;
inflate$1.inflateGetHeader = inflateGetHeader;
inflate$1.inflateSetDictionary = inflateSetDictionary;
inflate$1.inflateInfo = "pako inflate (from Nodeca project)";
var constants = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
(function(exports) {
  var assert3 = assert$2.exports;
  var Zstream = zstream;
  var zlib_deflate = deflate$1;
  var zlib_inflate = inflate$1;
  var constants$1 = constants;
  for (var key in constants$1) {
    exports[key] = constants$1[key];
  }
  exports.NONE = 0;
  exports.DEFLATE = 1;
  exports.INFLATE = 2;
  exports.GZIP = 3;
  exports.GUNZIP = 4;
  exports.DEFLATERAW = 5;
  exports.INFLATERAW = 6;
  exports.UNZIP = 7;
  var GZIP_HEADER_ID1 = 31;
  var GZIP_HEADER_ID2 = 139;
  function Zlib(mode) {
    if (typeof mode !== "number" || mode < exports.DEFLATE || mode > exports.UNZIP) {
      throw new TypeError("Bad argument");
    }
    this.dictionary = null;
    this.err = 0;
    this.flush = 0;
    this.init_done = false;
    this.level = 0;
    this.memLevel = 0;
    this.mode = mode;
    this.strategy = 0;
    this.windowBits = 0;
    this.write_in_progress = false;
    this.pending_close = false;
    this.gzip_id_bytes_read = 0;
  }
  Zlib.prototype.close = function() {
    if (this.write_in_progress) {
      this.pending_close = true;
      return;
    }
    this.pending_close = false;
    assert3(this.init_done, "close before init");
    assert3(this.mode <= exports.UNZIP);
    if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
      zlib_deflate.deflateEnd(this.strm);
    } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {
      zlib_inflate.inflateEnd(this.strm);
    }
    this.mode = exports.NONE;
    this.dictionary = null;
  };
  Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
    assert3.equal(arguments.length, 8);
    assert3(this.init_done, "write before init");
    assert3(this.mode !== exports.NONE, "already finalized");
    assert3.equal(false, this.write_in_progress, "write already in progress");
    assert3.equal(false, this.pending_close, "close is pending");
    this.write_in_progress = true;
    assert3.equal(false, flush === void 0, "must provide flush value");
    this.write_in_progress = true;
    if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
      throw new Error("Invalid flush value");
    }
    if (input == null) {
      input = Buffer$1.alloc(0);
      in_len = 0;
      in_off = 0;
    }
    this.strm.avail_in = in_len;
    this.strm.input = input;
    this.strm.next_in = in_off;
    this.strm.avail_out = out_len;
    this.strm.output = out;
    this.strm.next_out = out_off;
    this.flush = flush;
    if (!async) {
      this._process();
      if (this._checkError()) {
        return this._afterSync();
      }
      return;
    }
    var self2 = this;
    browser$1$1.nextTick(function() {
      self2._process();
      self2._after();
    });
    return this;
  };
  Zlib.prototype._afterSync = function() {
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    return [avail_in, avail_out];
  };
  Zlib.prototype._process = function() {
    var next_expected_header_byte = null;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.GZIP:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflate(this.strm, this.flush);
        break;
      case exports.UNZIP:
        if (this.strm.avail_in > 0) {
          next_expected_header_byte = this.strm.next_in;
        }
        switch (this.gzip_id_bytes_read) {
          case 0:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
              this.gzip_id_bytes_read = 1;
              next_expected_header_byte++;
              if (this.strm.avail_in === 1) {
                break;
              }
            } else {
              this.mode = exports.INFLATE;
              break;
            }
          case 1:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
              this.gzip_id_bytes_read = 2;
              this.mode = exports.GUNZIP;
            } else {
              this.mode = exports.INFLATE;
            }
            break;
          default:
            throw new Error("invalid number of gzip magic number bytes read");
        }
      case exports.INFLATE:
      case exports.GUNZIP:
      case exports.INFLATERAW:
        this.err = zlib_inflate.inflate(
          this.strm,
          this.flush
          // If data was encoded with dictionary
        );
        if (this.err === exports.Z_NEED_DICT && this.dictionary) {
          this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
          if (this.err === exports.Z_OK) {
            this.err = zlib_inflate.inflate(this.strm, this.flush);
          } else if (this.err === exports.Z_DATA_ERROR) {
            this.err = exports.Z_NEED_DICT;
          }
        }
        while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0) {
          this.reset();
          this.err = zlib_inflate.inflate(this.strm, this.flush);
        }
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
  };
  Zlib.prototype._checkError = function() {
    switch (this.err) {
      case exports.Z_OK:
      case exports.Z_BUF_ERROR:
        if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {
          this._error("unexpected end of file");
          return false;
        }
        break;
      case exports.Z_STREAM_END:
        break;
      case exports.Z_NEED_DICT:
        if (this.dictionary == null) {
          this._error("Missing dictionary");
        } else {
          this._error("Bad dictionary");
        }
        return false;
      default:
        this._error("Zlib error");
        return false;
    }
    return true;
  };
  Zlib.prototype._after = function() {
    if (!this._checkError()) {
      return;
    }
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    this.callback(avail_in, avail_out);
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype._error = function(message) {
    if (this.strm.msg) {
      message = this.strm.msg;
    }
    this.onerror(
      message,
      this.err
      // no hope of rescue.
    );
    this.write_in_progress = false;
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
    assert3(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
    assert3(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
    assert3(level >= -1 && level <= 9, "invalid compression level");
    assert3(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
    assert3(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, "invalid strategy");
    this._init(level, windowBits, memLevel, strategy, dictionary);
    this._setDictionary();
  };
  Zlib.prototype.params = function() {
    throw new Error("deflateParams Not supported");
  };
  Zlib.prototype.reset = function() {
    this._reset();
    this._setDictionary();
  };
  Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
    this.level = level;
    this.windowBits = windowBits;
    this.memLevel = memLevel;
    this.strategy = strategy;
    this.flush = exports.Z_NO_FLUSH;
    this.err = exports.Z_OK;
    if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {
      this.windowBits += 16;
    }
    if (this.mode === exports.UNZIP) {
      this.windowBits += 32;
    }
    if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {
      this.windowBits = -1 * this.windowBits;
    }
    this.strm = new Zstream();
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.GZIP:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
        break;
      case exports.INFLATE:
      case exports.GUNZIP:
      case exports.INFLATERAW:
      case exports.UNZIP:
        this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
    if (this.err !== exports.Z_OK) {
      this._error("Init error");
    }
    this.dictionary = dictionary;
    this.write_in_progress = false;
    this.init_done = true;
  };
  Zlib.prototype._setDictionary = function() {
    if (this.dictionary == null) {
      return;
    }
    this.err = exports.Z_OK;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
        break;
    }
    if (this.err !== exports.Z_OK) {
      this._error("Failed to set dictionary");
    }
  };
  Zlib.prototype._reset = function() {
    this.err = exports.Z_OK;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.DEFLATERAW:
      case exports.GZIP:
        this.err = zlib_deflate.deflateReset(this.strm);
        break;
      case exports.INFLATE:
      case exports.INFLATERAW:
      case exports.GUNZIP:
        this.err = zlib_inflate.inflateReset(this.strm);
        break;
    }
    if (this.err !== exports.Z_OK) {
      this._error("Failed to reset stream");
    }
  };
  exports.Zlib = Zlib;
})(binding);
(function(exports) {
  var Buffer5 = buffer.Buffer;
  var Transform3 = require$$1.Transform;
  var binding$13 = binding;
  var util3 = util$1;
  var assert3 = assert$2.exports.ok;
  var kMaxLength4 = buffer.kMaxLength;
  var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength4.toString(16) + " bytes";
  binding$13.Z_MIN_WINDOWBITS = 8;
  binding$13.Z_MAX_WINDOWBITS = 15;
  binding$13.Z_DEFAULT_WINDOWBITS = 15;
  binding$13.Z_MIN_CHUNK = 64;
  binding$13.Z_MAX_CHUNK = Infinity;
  binding$13.Z_DEFAULT_CHUNK = 16 * 1024;
  binding$13.Z_MIN_MEMLEVEL = 1;
  binding$13.Z_MAX_MEMLEVEL = 9;
  binding$13.Z_DEFAULT_MEMLEVEL = 8;
  binding$13.Z_MIN_LEVEL = -1;
  binding$13.Z_MAX_LEVEL = 9;
  binding$13.Z_DEFAULT_LEVEL = binding$13.Z_DEFAULT_COMPRESSION;
  var bkeys = Object.keys(binding$13);
  for (var bk = 0; bk < bkeys.length; bk++) {
    var bkey = bkeys[bk];
    if (bkey.match(/^Z/)) {
      Object.defineProperty(exports, bkey, {
        enumerable: true,
        value: binding$13[bkey],
        writable: false
      });
    }
  }
  var codes3 = {
    Z_OK: binding$13.Z_OK,
    Z_STREAM_END: binding$13.Z_STREAM_END,
    Z_NEED_DICT: binding$13.Z_NEED_DICT,
    Z_ERRNO: binding$13.Z_ERRNO,
    Z_STREAM_ERROR: binding$13.Z_STREAM_ERROR,
    Z_DATA_ERROR: binding$13.Z_DATA_ERROR,
    Z_MEM_ERROR: binding$13.Z_MEM_ERROR,
    Z_BUF_ERROR: binding$13.Z_BUF_ERROR,
    Z_VERSION_ERROR: binding$13.Z_VERSION_ERROR
  };
  var ckeys = Object.keys(codes3);
  for (var ck = 0; ck < ckeys.length; ck++) {
    var ckey = ckeys[ck];
    codes3[codes3[ckey]] = ckey;
  }
  Object.defineProperty(exports, "codes", {
    enumerable: true,
    value: Object.freeze(codes3),
    writable: false
  });
  exports.Deflate = Deflate;
  exports.Inflate = Inflate;
  exports.Gzip = Gzip;
  exports.Gunzip = Gunzip;
  exports.DeflateRaw = DeflateRaw;
  exports.InflateRaw = InflateRaw;
  exports.Unzip = Unzip;
  exports.createDeflate = function(o) {
    return new Deflate(o);
  };
  exports.createInflate = function(o) {
    return new Inflate(o);
  };
  exports.createDeflateRaw = function(o) {
    return new DeflateRaw(o);
  };
  exports.createInflateRaw = function(o) {
    return new InflateRaw(o);
  };
  exports.createGzip = function(o) {
    return new Gzip(o);
  };
  exports.createGunzip = function(o) {
    return new Gunzip(o);
  };
  exports.createUnzip = function(o) {
    return new Unzip(o);
  };
  exports.deflate = function(buffer3, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Deflate(opts2), buffer3, callback);
  };
  exports.deflateSync = function(buffer3, opts2) {
    return zlibBufferSync(new Deflate(opts2), buffer3);
  };
  exports.gzip = function(buffer3, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gzip(opts2), buffer3, callback);
  };
  exports.gzipSync = function(buffer3, opts2) {
    return zlibBufferSync(new Gzip(opts2), buffer3);
  };
  exports.deflateRaw = function(buffer3, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new DeflateRaw(opts2), buffer3, callback);
  };
  exports.deflateRawSync = function(buffer3, opts2) {
    return zlibBufferSync(new DeflateRaw(opts2), buffer3);
  };
  exports.unzip = function(buffer3, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Unzip(opts2), buffer3, callback);
  };
  exports.unzipSync = function(buffer3, opts2) {
    return zlibBufferSync(new Unzip(opts2), buffer3);
  };
  exports.inflate = function(buffer3, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Inflate(opts2), buffer3, callback);
  };
  exports.inflateSync = function(buffer3, opts2) {
    return zlibBufferSync(new Inflate(opts2), buffer3);
  };
  exports.gunzip = function(buffer3, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gunzip(opts2), buffer3, callback);
  };
  exports.gunzipSync = function(buffer3, opts2) {
    return zlibBufferSync(new Gunzip(opts2), buffer3);
  };
  exports.inflateRaw = function(buffer3, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new InflateRaw(opts2), buffer3, callback);
  };
  exports.inflateRawSync = function(buffer3, opts2) {
    return zlibBufferSync(new InflateRaw(opts2), buffer3);
  };
  function zlibBuffer(engine2, buffer3, callback) {
    var buffers = [];
    var nread = 0;
    engine2.on("error", onError);
    engine2.on("end", onEnd);
    engine2.end(buffer3);
    flow3();
    function flow3() {
      var chunk;
      while (null !== (chunk = engine2.read())) {
        buffers.push(chunk);
        nread += chunk.length;
      }
      engine2.once("readable", flow3);
    }
    function onError(err2) {
      engine2.removeListener("end", onEnd);
      engine2.removeListener("readable", flow3);
      callback(err2);
    }
    function onEnd() {
      var buf;
      var err2 = null;
      if (nread >= kMaxLength4) {
        err2 = new RangeError(kRangeErrorMessage);
      } else {
        buf = Buffer5.concat(buffers, nread);
      }
      buffers = [];
      engine2.close();
      callback(err2, buf);
    }
  }
  function zlibBufferSync(engine2, buffer3) {
    if (typeof buffer3 === "string")
      buffer3 = Buffer5.from(buffer3);
    if (!Buffer5.isBuffer(buffer3))
      throw new TypeError("Not a string or buffer");
    var flushFlag = engine2._finishFlushFlag;
    return engine2._processChunk(buffer3, flushFlag);
  }
  function Deflate(opts2) {
    if (!(this instanceof Deflate))
      return new Deflate(opts2);
    Zlib.call(this, opts2, binding$13.DEFLATE);
  }
  function Inflate(opts2) {
    if (!(this instanceof Inflate))
      return new Inflate(opts2);
    Zlib.call(this, opts2, binding$13.INFLATE);
  }
  function Gzip(opts2) {
    if (!(this instanceof Gzip))
      return new Gzip(opts2);
    Zlib.call(this, opts2, binding$13.GZIP);
  }
  function Gunzip(opts2) {
    if (!(this instanceof Gunzip))
      return new Gunzip(opts2);
    Zlib.call(this, opts2, binding$13.GUNZIP);
  }
  function DeflateRaw(opts2) {
    if (!(this instanceof DeflateRaw))
      return new DeflateRaw(opts2);
    Zlib.call(this, opts2, binding$13.DEFLATERAW);
  }
  function InflateRaw(opts2) {
    if (!(this instanceof InflateRaw))
      return new InflateRaw(opts2);
    Zlib.call(this, opts2, binding$13.INFLATERAW);
  }
  function Unzip(opts2) {
    if (!(this instanceof Unzip))
      return new Unzip(opts2);
    Zlib.call(this, opts2, binding$13.UNZIP);
  }
  function isValidFlushFlag(flag) {
    return flag === binding$13.Z_NO_FLUSH || flag === binding$13.Z_PARTIAL_FLUSH || flag === binding$13.Z_SYNC_FLUSH || flag === binding$13.Z_FULL_FLUSH || flag === binding$13.Z_FINISH || flag === binding$13.Z_BLOCK;
  }
  function Zlib(opts2, mode) {
    var _this = this;
    this._opts = opts2 = opts2 || {};
    this._chunkSize = opts2.chunkSize || exports.Z_DEFAULT_CHUNK;
    Transform3.call(this, opts2);
    if (opts2.flush && !isValidFlushFlag(opts2.flush)) {
      throw new Error("Invalid flush flag: " + opts2.flush);
    }
    if (opts2.finishFlush && !isValidFlushFlag(opts2.finishFlush)) {
      throw new Error("Invalid flush flag: " + opts2.finishFlush);
    }
    this._flushFlag = opts2.flush || binding$13.Z_NO_FLUSH;
    this._finishFlushFlag = typeof opts2.finishFlush !== "undefined" ? opts2.finishFlush : binding$13.Z_FINISH;
    if (opts2.chunkSize) {
      if (opts2.chunkSize < exports.Z_MIN_CHUNK || opts2.chunkSize > exports.Z_MAX_CHUNK) {
        throw new Error("Invalid chunk size: " + opts2.chunkSize);
      }
    }
    if (opts2.windowBits) {
      if (opts2.windowBits < exports.Z_MIN_WINDOWBITS || opts2.windowBits > exports.Z_MAX_WINDOWBITS) {
        throw new Error("Invalid windowBits: " + opts2.windowBits);
      }
    }
    if (opts2.level) {
      if (opts2.level < exports.Z_MIN_LEVEL || opts2.level > exports.Z_MAX_LEVEL) {
        throw new Error("Invalid compression level: " + opts2.level);
      }
    }
    if (opts2.memLevel) {
      if (opts2.memLevel < exports.Z_MIN_MEMLEVEL || opts2.memLevel > exports.Z_MAX_MEMLEVEL) {
        throw new Error("Invalid memLevel: " + opts2.memLevel);
      }
    }
    if (opts2.strategy) {
      if (opts2.strategy != exports.Z_FILTERED && opts2.strategy != exports.Z_HUFFMAN_ONLY && opts2.strategy != exports.Z_RLE && opts2.strategy != exports.Z_FIXED && opts2.strategy != exports.Z_DEFAULT_STRATEGY) {
        throw new Error("Invalid strategy: " + opts2.strategy);
      }
    }
    if (opts2.dictionary) {
      if (!Buffer5.isBuffer(opts2.dictionary)) {
        throw new Error("Invalid dictionary: it should be a Buffer instance");
      }
    }
    this._handle = new binding$13.Zlib(mode);
    var self2 = this;
    this._hadError = false;
    this._handle.onerror = function(message, errno) {
      _close(self2);
      self2._hadError = true;
      var error = new Error(message);
      error.errno = errno;
      error.code = exports.codes[errno];
      self2.emit("error", error);
    };
    var level = exports.Z_DEFAULT_COMPRESSION;
    if (typeof opts2.level === "number")
      level = opts2.level;
    var strategy = exports.Z_DEFAULT_STRATEGY;
    if (typeof opts2.strategy === "number")
      strategy = opts2.strategy;
    this._handle.init(opts2.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts2.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts2.dictionary);
    this._buffer = Buffer5.allocUnsafe(this._chunkSize);
    this._offset = 0;
    this._level = level;
    this._strategy = strategy;
    this.once("end", this.close);
    Object.defineProperty(this, "_closed", {
      get: function get18() {
        return !_this._handle;
      },
      configurable: true,
      enumerable: true
    });
  }
  util3.inherits(Zlib, Transform3);
  Zlib.prototype.params = function(level, strategy, callback) {
    if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
      throw new RangeError("Invalid compression level: " + level);
    }
    if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new TypeError("Invalid strategy: " + strategy);
    }
    if (this._level !== level || this._strategy !== strategy) {
      var self2 = this;
      this.flush(binding$13.Z_SYNC_FLUSH, function() {
        assert3(self2._handle, "zlib binding closed");
        self2._handle.params(level, strategy);
        if (!self2._hadError) {
          self2._level = level;
          self2._strategy = strategy;
          if (callback)
            callback();
        }
      });
    } else {
      browser$1$1.nextTick(callback);
    }
  };
  Zlib.prototype.reset = function() {
    assert3(this._handle, "zlib binding closed");
    return this._handle.reset();
  };
  Zlib.prototype._flush = function(callback) {
    this._transform(Buffer5.alloc(0), "", callback);
  };
  Zlib.prototype.flush = function(kind, callback) {
    var _this2 = this;
    var ws = this._writableState;
    if (typeof kind === "function" || kind === void 0 && !callback) {
      callback = kind;
      kind = binding$13.Z_FULL_FLUSH;
    }
    if (ws.ended) {
      if (callback)
        browser$1$1.nextTick(callback);
    } else if (ws.ending) {
      if (callback)
        this.once("end", callback);
    } else if (ws.needDrain) {
      if (callback) {
        this.once("drain", function() {
          return _this2.flush(kind, callback);
        });
      }
    } else {
      this._flushFlag = kind;
      this.write(Buffer5.alloc(0), "", callback);
    }
  };
  Zlib.prototype.close = function(callback) {
    _close(this, callback);
    browser$1$1.nextTick(emitCloseNT2, this);
  };
  function _close(engine2, callback) {
    if (callback)
      browser$1$1.nextTick(callback);
    if (!engine2._handle)
      return;
    engine2._handle.close();
    engine2._handle = null;
  }
  function emitCloseNT2(self2) {
    self2.emit("close");
  }
  Zlib.prototype._transform = function(chunk, encoding, cb) {
    var flushFlag;
    var ws = this._writableState;
    var ending = ws.ending || ws.ended;
    var last3 = ending && (!chunk || ws.length === chunk.length);
    if (chunk !== null && !Buffer5.isBuffer(chunk))
      return cb(new Error("invalid input"));
    if (!this._handle)
      return cb(new Error("zlib binding closed"));
    if (last3)
      flushFlag = this._finishFlushFlag;
    else {
      flushFlag = this._flushFlag;
      if (chunk.length >= ws.length) {
        this._flushFlag = this._opts.flush || binding$13.Z_NO_FLUSH;
      }
    }
    this._processChunk(chunk, flushFlag, cb);
  };
  Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
    var availInBefore = chunk && chunk.length;
    var availOutBefore = this._chunkSize - this._offset;
    var inOff = 0;
    var self2 = this;
    var async = typeof cb === "function";
    if (!async) {
      var buffers = [];
      var nread = 0;
      var error;
      this.on("error", function(er2) {
        error = er2;
      });
      assert3(this._handle, "zlib binding closed");
      do {
        var res = this._handle.writeSync(
          flushFlag,
          chunk,
          // in
          inOff,
          // in_off
          availInBefore,
          // in_len
          this._buffer,
          // out
          this._offset,
          //out_off
          availOutBefore
        );
      } while (!this._hadError && callback(res[0], res[1]));
      if (this._hadError) {
        throw error;
      }
      if (nread >= kMaxLength4) {
        _close(this);
        throw new RangeError(kRangeErrorMessage);
      }
      var buf = Buffer5.concat(buffers, nread);
      _close(this);
      return buf;
    }
    assert3(this._handle, "zlib binding closed");
    var req = this._handle.write(
      flushFlag,
      chunk,
      // in
      inOff,
      // in_off
      availInBefore,
      // in_len
      this._buffer,
      // out
      this._offset,
      //out_off
      availOutBefore
    );
    req.buffer = chunk;
    req.callback = callback;
    function callback(availInAfter, availOutAfter) {
      if (this) {
        this.buffer = null;
        this.callback = null;
      }
      if (self2._hadError)
        return;
      var have = availOutBefore - availOutAfter;
      assert3(have >= 0, "have should not go down");
      if (have > 0) {
        var out = self2._buffer.slice(self2._offset, self2._offset + have);
        self2._offset += have;
        if (async) {
          self2.push(out);
        } else {
          buffers.push(out);
          nread += out.length;
        }
      }
      if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
        availOutBefore = self2._chunkSize;
        self2._offset = 0;
        self2._buffer = Buffer5.allocUnsafe(self2._chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        if (!async)
          return true;
        var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
        newReq.callback = callback;
        newReq.buffer = chunk;
        return;
      }
      if (!async)
        return false;
      cb();
    }
  };
  util3.inherits(Deflate, Zlib);
  util3.inherits(Inflate, Zlib);
  util3.inherits(Gzip, Zlib);
  util3.inherits(Gunzip, Zlib);
  util3.inherits(DeflateRaw, Zlib);
  util3.inherits(InflateRaw, Zlib);
  util3.inherits(Unzip, Zlib);
})(lib);
var PNG = function() {
  PNG2.decode = function decode(path2, fn) {
    {
      throw new Error("PNG.decode not available in browser build");
    }
  };
  PNG2.load = function load(path2) {
    {
      throw new Error("PNG.load not available in browser build");
    }
  };
  function PNG2(data2) {
    var i;
    this.data = data2;
    this.pos = 8;
    this.palette = [];
    this.imgData = [];
    this.transparency = {};
    this.text = {};
    while (true) {
      var chunkSize = this.readUInt32();
      var section = "";
      for (i = 0; i < 4; i++) {
        section += String.fromCharCode(this.data[this.pos++]);
      }
      switch (section) {
        case "IHDR":
          this.width = this.readUInt32();
          this.height = this.readUInt32();
          this.bits = this.data[this.pos++];
          this.colorType = this.data[this.pos++];
          this.compressionMethod = this.data[this.pos++];
          this.filterMethod = this.data[this.pos++];
          this.interlaceMethod = this.data[this.pos++];
          break;
        case "PLTE":
          this.palette = this.read(chunkSize);
          break;
        case "IDAT":
          for (i = 0; i < chunkSize; i++) {
            this.imgData.push(this.data[this.pos++]);
          }
          break;
        case "tRNS":
          this.transparency = {};
          switch (this.colorType) {
            case 3:
              this.transparency.indexed = this.read(chunkSize);
              var short = 255 - this.transparency.indexed.length;
              if (short > 0) {
                for (i = 0; i < short; i++) {
                  this.transparency.indexed.push(255);
                }
              }
              break;
            case 0:
              this.transparency.grayscale = this.read(chunkSize)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(chunkSize);
              break;
          }
          break;
        case "tEXt":
          var text2 = this.read(chunkSize);
          var index3 = text2.indexOf(0);
          var key = String.fromCharCode.apply(String, text2.slice(0, index3));
          this.text[key] = String.fromCharCode.apply(String, text2.slice(index3 + 1));
          break;
        case "IEND":
          switch (this.colorType) {
            case 0:
            case 3:
            case 4:
              this.colors = 1;
              break;
            case 2:
            case 6:
              this.colors = 3;
              break;
          }
          this.hasAlphaChannel = [4, 6].includes(this.colorType);
          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
          this.pixelBitlength = this.bits * colors;
          switch (this.colors) {
            case 1:
              this.colorSpace = "DeviceGray";
              break;
            case 3:
              this.colorSpace = "DeviceRGB";
              break;
          }
          this.imgData = Buffer$1.from(this.imgData);
          return;
        default:
          this.pos += chunkSize;
      }
      this.pos += 4;
      if (this.pos > this.data.length) {
        throw new Error("Incomplete or corrupt PNG file");
      }
    }
  }
  var _proto = PNG2.prototype;
  _proto.read = function read4(bytes) {
    var result = new Array(bytes);
    for (var i = 0; i < bytes; i++) {
      result[i] = this.data[this.pos++];
    }
    return result;
  };
  _proto.readUInt32 = function readUInt32() {
    var b1 = this.data[this.pos++] << 24;
    var b2 = this.data[this.pos++] << 16;
    var b3 = this.data[this.pos++] << 8;
    var b4 = this.data[this.pos++];
    return b1 | b2 | b3 | b4;
  };
  _proto.readUInt16 = function readUInt16() {
    var b1 = this.data[this.pos++] << 8;
    var b2 = this.data[this.pos++];
    return b1 | b2;
  };
  _proto.decodePixels = function decodePixels(fn) {
    var _this = this;
    return lib.inflate(this.imgData, function(err2, data2) {
      if (err2)
        throw err2;
      var pos = 0;
      var width = _this.width, height5 = _this.height;
      var pixelBytes = _this.pixelBitlength / 8;
      var pixels = Buffer$1.alloc(width * height5 * pixelBytes);
      function pass(x0, y0, dx, dy, singlePass) {
        if (singlePass === void 0) {
          singlePass = false;
        }
        var w = Math.ceil((width - x0) / dx);
        var h2 = Math.ceil((height5 - y0) / dy);
        var scanlineLength = pixelBytes * w;
        var buffer3 = singlePass ? pixels : Buffer$1.alloc(scanlineLength * h2);
        var row = 0;
        var c2 = 0;
        while (row < h2 && pos < data2.length) {
          var byte;
          var col;
          var i;
          var left;
          var upper;
          switch (data2[pos++]) {
            case 0:
              for (i = 0; i < scanlineLength; i++) {
                buffer3[c2++] = data2[pos++];
              }
              break;
            case 1:
              for (i = 0; i < scanlineLength; i++) {
                byte = data2[pos++];
                left = i < pixelBytes ? 0 : buffer3[c2 - pixelBytes];
                buffer3[c2++] = (byte + left) % 256;
              }
              break;
            case 2:
              for (i = 0; i < scanlineLength; i++) {
                byte = data2[pos++];
                col = (i - i % pixelBytes) / pixelBytes;
                upper = row && buffer3[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                buffer3[c2++] = (upper + byte) % 256;
              }
              break;
            case 3:
              for (i = 0; i < scanlineLength; i++) {
                byte = data2[pos++];
                col = (i - i % pixelBytes) / pixelBytes;
                left = i < pixelBytes ? 0 : buffer3[c2 - pixelBytes];
                upper = row && buffer3[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                buffer3[c2++] = (byte + Math.floor((left + upper) / 2)) % 256;
              }
              break;
            case 4:
              for (i = 0; i < scanlineLength; i++) {
                var paeth;
                var upperLeft;
                byte = data2[pos++];
                col = (i - i % pixelBytes) / pixelBytes;
                left = i < pixelBytes ? 0 : buffer3[c2 - pixelBytes];
                if (row === 0) {
                  upper = upperLeft = 0;
                } else {
                  upper = buffer3[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                  upperLeft = col && buffer3[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];
                }
                var p = left + upper - upperLeft;
                var pa = Math.abs(p - left);
                var pb = Math.abs(p - upper);
                var pc = Math.abs(p - upperLeft);
                if (pa <= pb && pa <= pc) {
                  paeth = left;
                } else if (pb <= pc) {
                  paeth = upper;
                } else {
                  paeth = upperLeft;
                }
                buffer3[c2++] = (byte + paeth) % 256;
              }
              break;
            default:
              throw new Error("Invalid filter algorithm: " + data2[pos - 1]);
          }
          if (!singlePass) {
            var pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;
            var bufferPos = row * scanlineLength;
            for (i = 0; i < w; i++) {
              for (var j = 0; j < pixelBytes; j++) {
                pixels[pixelsPos++] = buffer3[bufferPos++];
              }
              pixelsPos += (dx - 1) * pixelBytes;
            }
          }
          row++;
        }
      }
      if (_this.interlaceMethod === 1) {
        pass(0, 0, 8, 8);
        pass(4, 0, 8, 8);
        pass(0, 4, 4, 8);
        pass(2, 0, 4, 4);
        pass(0, 2, 2, 4);
        pass(1, 0, 2, 2);
        pass(0, 1, 1, 2);
      } else {
        pass(0, 0, 1, 1, true);
      }
      return fn(pixels);
    });
  };
  _proto.decodePalette = function decodePalette() {
    var palette = this.palette;
    var length4 = palette.length;
    var transparency = this.transparency.indexed || [];
    var ret = Buffer$1.alloc(transparency.length + length4);
    var pos = 0;
    var c2 = 0;
    for (var i = 0; i < length4; i += 3) {
      var left;
      ret[pos++] = palette[i];
      ret[pos++] = palette[i + 1];
      ret[pos++] = palette[i + 2];
      ret[pos++] = (left = transparency[c2++]) != null ? left : 255;
    }
    return ret;
  };
  _proto.copyToImageData = function copyToImageData(imageData, pixels) {
    var j;
    var k;
    var colors = this.colors;
    var palette = null;
    var alpha = this.hasAlphaChannel;
    if (this.palette.length) {
      palette = this._decodedPalette || (this._decodedPalette = this.decodePalette());
      colors = 4;
      alpha = true;
    }
    var data2 = imageData.data || imageData;
    var length4 = data2.length;
    var input = palette || pixels;
    var i = j = 0;
    if (colors === 1) {
      while (i < length4) {
        k = palette ? pixels[i / 4] * 4 : j;
        var v2 = input[k++];
        data2[i++] = v2;
        data2[i++] = v2;
        data2[i++] = v2;
        data2[i++] = alpha ? input[k++] : 255;
        j = k;
      }
    } else {
      while (i < length4) {
        k = palette ? pixels[i / 4] * 4 : j;
        data2[i++] = input[k++];
        data2[i++] = input[k++];
        data2[i++] = input[k++];
        data2[i++] = alpha ? input[k++] : 255;
        j = k;
      }
    }
  };
  _proto.decode = function decode(fn) {
    var _this2 = this;
    var ret = Buffer$1.alloc(this.width * this.height * 4);
    return this.decodePixels(function(pixels) {
      _this2.copyToImageData(ret, pixels);
      return fn(ret);
    });
  };
  return PNG2;
}();

// ../node_modules/@react-pdf/pdfkit/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends4() {
  _extends4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends4.apply(this, arguments);
}

// ../node_modules/@react-pdf/pdfkit/lib/pdfkit.browser.es.js
var CryptoJS = __toESM(require_core());
var global$12 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup$12 = [];
var revLookup$12 = [];
var Arr$12 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited2 = false;
function init2() {
  inited2 = true;
  var code3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code3.length; i < len; ++i) {
    lookup$12[i] = code3[i];
    revLookup$12[code3.charCodeAt(i)] = i;
  }
  revLookup$12["-".charCodeAt(0)] = 62;
  revLookup$12["_".charCodeAt(0)] = 63;
}
function toByteArray$12(b64) {
  if (!inited2) {
    init2();
  }
  var i, j, l2, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr$12(len * 3 / 4 - placeHolders);
  l2 = placeHolders > 0 ? len - 4 : len;
  var L2 = 0;
  for (i = 0, j = 0; i < l2; i += 4, j += 3) {
    tmp = revLookup$12[b64.charCodeAt(i)] << 18 | revLookup$12[b64.charCodeAt(i + 1)] << 12 | revLookup$12[b64.charCodeAt(i + 2)] << 6 | revLookup$12[b64.charCodeAt(i + 3)];
    arr[L2++] = tmp >> 16 & 255;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup$12[b64.charCodeAt(i)] << 2 | revLookup$12[b64.charCodeAt(i + 1)] >> 4;
    arr[L2++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup$12[b64.charCodeAt(i)] << 10 | revLookup$12[b64.charCodeAt(i + 1)] << 4 | revLookup$12[b64.charCodeAt(i + 2)] >> 2;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64$12(num) {
  return lookup$12[num >> 18 & 63] + lookup$12[num >> 12 & 63] + lookup$12[num >> 6 & 63] + lookup$12[num & 63];
}
function encodeChunk$12(uint82, start3, end3) {
  var tmp;
  var output = [];
  for (var i = start3; i < end3; i += 3) {
    tmp = (uint82[i] << 16) + (uint82[i + 1] << 8) + uint82[i + 2];
    output.push(tripletToBase64$12(tmp));
  }
  return output.join("");
}
function fromByteArray$12(uint82) {
  if (!inited2) {
    init2();
  }
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk$12(uint82, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    output += lookup$12[tmp >> 2];
    output += lookup$12[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    output += lookup$12[tmp >> 10];
    output += lookup$12[tmp >> 4 & 63];
    output += lookup$12[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read2(buffer3, offset3, isLE, mLen, nBytes) {
  var e, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s2 = buffer3[offset3 + i];
  i += d;
  e = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer3[offset3 + i], i += d, nBits -= 8) {
  }
  m2 = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer3[offset3 + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e - mLen);
}
function write3(buffer3, value2, offset3, isLE, mLen, nBytes) {
  var e, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m2 = isNaN(value2) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c2 = Math.pow(2, -e)) < 1) {
      e--;
      c2 *= 2;
    }
    if (e + eBias >= 1) {
      value2 += rt / c2;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c2 >= 2) {
      e++;
      c2 /= 2;
    }
    if (e + eBias >= eMax) {
      m2 = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m2 = (value2 * c2 - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer3[offset3 + i] = m2 & 255, i += d, m2 /= 256, mLen -= 8) {
  }
  e = e << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer3[offset3 + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer3[offset3 + i - d] |= s2 * 128;
}
var toString$12 = {}.toString;
var isArray2 = Array.isArray || function(arr) {
  return toString$12.call(arr) == "[object Array]";
};
var INSPECT_MAX_BYTES2 = 50;
Buffer$4.TYPED_ARRAY_SUPPORT = global$12.TYPED_ARRAY_SUPPORT !== void 0 ? global$12.TYPED_ARRAY_SUPPORT : true;
function kMaxLength2() {
  return Buffer$4.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer2(that, length4) {
  if (kMaxLength2() < length4) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer$4.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length4);
    that.__proto__ = Buffer$4.prototype;
  } else {
    if (that === null) {
      that = new Buffer$4(length4);
    }
    that.length = length4;
  }
  return that;
}
function Buffer$4(arg, encodingOrOffset, length4) {
  if (!Buffer$4.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$4)) {
    return new Buffer$4(arg, encodingOrOffset, length4);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe2(this, arg);
  }
  return from$1(this, arg, encodingOrOffset, length4);
}
Buffer$4.poolSize = 8192;
Buffer$4._augment = function(arr) {
  arr.__proto__ = Buffer$4.prototype;
  return arr;
};
function from$1(that, value2, encodingOrOffset, length4) {
  if (typeof value2 === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
    return fromArrayBuffer2(that, value2, encodingOrOffset, length4);
  }
  if (typeof value2 === "string") {
    return fromString2(that, value2, encodingOrOffset);
  }
  return fromObject2(that, value2);
}
Buffer$4.from = function(value2, encodingOrOffset, length4) {
  return from$1(null, value2, encodingOrOffset, length4);
};
if (Buffer$4.TYPED_ARRAY_SUPPORT) {
  Buffer$4.prototype.__proto__ = Uint8Array.prototype;
  Buffer$4.__proto__ = Uint8Array;
}
function assertSize2(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc2(that, size, fill5, encoding) {
  assertSize2(size);
  if (size <= 0) {
    return createBuffer2(that, size);
  }
  if (fill5 !== void 0) {
    return typeof encoding === "string" ? createBuffer2(that, size).fill(fill5, encoding) : createBuffer2(that, size).fill(fill5);
  }
  return createBuffer2(that, size);
}
Buffer$4.alloc = function(size, fill5, encoding) {
  return alloc2(null, size, fill5, encoding);
};
function allocUnsafe2(that, size) {
  assertSize2(size);
  that = createBuffer2(that, size < 0 ? 0 : checked2(size) | 0);
  if (!Buffer$4.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
Buffer$4.allocUnsafe = function(size) {
  return allocUnsafe2(null, size);
};
Buffer$4.allocUnsafeSlow = function(size) {
  return allocUnsafe2(null, size);
};
function fromString2(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer$4.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length4 = byteLength$12(string, encoding) | 0;
  that = createBuffer2(that, length4);
  var actual = that.write(string, encoding);
  if (actual !== length4) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike2(that, array) {
  var length4 = array.length < 0 ? 0 : checked2(array.length) | 0;
  that = createBuffer2(that, length4);
  for (var i = 0; i < length4; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer2(that, array, byteOffset, length4) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length4 || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length4 === void 0) {
    array = new Uint8Array(array);
  } else if (length4 === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length4);
  }
  if (Buffer$4.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer$4.prototype;
  } else {
    that = fromArrayLike2(that, array);
  }
  return that;
}
function fromObject2(that, obj) {
  if (internalIsBuffer2(obj)) {
    var len = checked2(obj.length) | 0;
    that = createBuffer2(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan2(obj.length)) {
        return createBuffer2(that, 0);
      }
      return fromArrayLike2(that, obj);
    }
    if (obj.type === "Buffer" && isArray2(obj.data)) {
      return fromArrayLike2(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked2(length4) {
  if (length4 >= kMaxLength2()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength2().toString(16) + " bytes");
  }
  return length4 | 0;
}
Buffer$4.isBuffer = isBuffer3;
function internalIsBuffer2(b) {
  return !!(b != null && b._isBuffer);
}
Buffer$4.compare = function compare4(a2, b) {
  if (!internalIsBuffer2(a2) || !internalIsBuffer2(b)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a2 === b)
    return 0;
  var x = a2.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a2[i] !== b[i]) {
      x = a2[i];
      y = b[i];
      break;
    }
  }
  if (x < y)
    return -1;
  if (y < x)
    return 1;
  return 0;
};
Buffer$4.isEncoding = function isEncoding3(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer$4.concat = function concat3(list, length4) {
  if (!isArray2(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer$4.alloc(0);
  }
  var i;
  if (length4 === void 0) {
    length4 = 0;
    for (i = 0; i < list.length; ++i) {
      length4 += list[i].length;
    }
  }
  var buffer3 = Buffer$4.allocUnsafe(length4);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer2(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer3, pos);
    pos += buf.length;
  }
  return buffer3;
};
function byteLength$12(string, encoding) {
  if (internalIsBuffer2(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes2(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes2(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes2(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$4.byteLength = byteLength$12;
function slowToString2(encoding, start3, end3) {
  var loweredCase = false;
  if (start3 === void 0 || start3 < 0) {
    start3 = 0;
  }
  if (start3 > this.length) {
    return "";
  }
  if (end3 === void 0 || end3 > this.length) {
    end3 = this.length;
  }
  if (end3 <= 0) {
    return "";
  }
  end3 >>>= 0;
  start3 >>>= 0;
  if (end3 <= start3) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice2(this, start3, end3);
      case "utf8":
      case "utf-8":
        return utf8Slice2(this, start3, end3);
      case "ascii":
        return asciiSlice2(this, start3, end3);
      case "latin1":
      case "binary":
        return latin1Slice2(this, start3, end3);
      case "base64":
        return base64Slice2(this, start3, end3);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice2(this, start3, end3);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$4.prototype._isBuffer = true;
function swap2(b, n, m2) {
  var i = b[n];
  b[n] = b[m2];
  b[m2] = i;
}
Buffer$4.prototype.swap16 = function swap162() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i = 0; i < len; i += 2) {
    swap2(this, i, i + 1);
  }
  return this;
};
Buffer$4.prototype.swap32 = function swap322() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i = 0; i < len; i += 4) {
    swap2(this, i, i + 3);
    swap2(this, i + 1, i + 2);
  }
  return this;
};
Buffer$4.prototype.swap64 = function swap642() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i = 0; i < len; i += 8) {
    swap2(this, i, i + 7);
    swap2(this, i + 1, i + 6);
    swap2(this, i + 2, i + 5);
    swap2(this, i + 3, i + 4);
  }
  return this;
};
Buffer$4.prototype.toString = function toString3() {
  var length4 = this.length | 0;
  if (length4 === 0)
    return "";
  if (arguments.length === 0)
    return utf8Slice2(this, 0, length4);
  return slowToString2.apply(this, arguments);
};
Buffer$4.prototype.equals = function equals2(b) {
  if (!internalIsBuffer2(b))
    throw new TypeError("Argument must be a Buffer");
  if (this === b)
    return true;
  return Buffer$4.compare(this, b) === 0;
};
Buffer$4.prototype.inspect = function inspect3() {
  var str = "";
  var max3 = INSPECT_MAX_BYTES2;
  if (this.length > 0) {
    str = this.toString("hex", 0, max3).match(/.{2}/g).join(" ");
    if (this.length > max3)
      str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer$4.prototype.compare = function compare5(target, start3, end3, thisStart, thisEnd) {
  if (!internalIsBuffer2(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start3 === void 0) {
    start3 = 0;
  }
  if (end3 === void 0) {
    end3 = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start3 < 0 || end3 > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start3 >= end3) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start3 >= end3) {
    return 1;
  }
  start3 >>>= 0;
  end3 >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target)
    return 0;
  var x = thisEnd - thisStart;
  var y = end3 - start3;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start3, end3);
  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }
  if (x < y)
    return -1;
  if (y < x)
    return 1;
  return 0;
};
function bidirectionalIndexOf2(buffer3, val, byteOffset, encoding, dir) {
  if (buffer3.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer3.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer3.length + byteOffset;
  if (byteOffset >= buffer3.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer3.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer$4.from(val, encoding);
  }
  if (internalIsBuffer2(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf2(buffer3, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer$4.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer3, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer3, val, byteOffset);
      }
    }
    return arrayIndexOf2(buffer3, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf2(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read4(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read4(arr, i) === read4(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read4(arr, i + j) !== read4(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
}
Buffer$4.prototype.includes = function includes3(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer$4.prototype.indexOf = function indexOf4(val, byteOffset, encoding) {
  return bidirectionalIndexOf2(this, val, byteOffset, encoding, true);
};
Buffer$4.prototype.lastIndexOf = function lastIndexOf2(val, byteOffset, encoding) {
  return bidirectionalIndexOf2(this, val, byteOffset, encoding, false);
};
function hexWrite2(buf, string, offset3, length4) {
  offset3 = Number(offset3) || 0;
  var remaining = buf.length - offset3;
  if (!length4) {
    length4 = remaining;
  } else {
    length4 = Number(length4);
    if (length4 > remaining) {
      length4 = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length4 > strLen / 2) {
    length4 = strLen / 2;
  }
  for (var i = 0; i < length4; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset3 + i] = parsed;
  }
  return i;
}
function utf8Write2(buf, string, offset3, length4) {
  return blitBuffer2(utf8ToBytes2(string, buf.length - offset3), buf, offset3, length4);
}
function asciiWrite2(buf, string, offset3, length4) {
  return blitBuffer2(asciiToBytes2(string), buf, offset3, length4);
}
function latin1Write2(buf, string, offset3, length4) {
  return asciiWrite2(buf, string, offset3, length4);
}
function base64Write2(buf, string, offset3, length4) {
  return blitBuffer2(base64ToBytes2(string), buf, offset3, length4);
}
function ucs2Write2(buf, string, offset3, length4) {
  return blitBuffer2(utf16leToBytes2(string, buf.length - offset3), buf, offset3, length4);
}
Buffer$4.prototype.write = function write4(string, offset3, length4, encoding) {
  if (offset3 === void 0) {
    encoding = "utf8";
    length4 = this.length;
    offset3 = 0;
  } else if (length4 === void 0 && typeof offset3 === "string") {
    encoding = offset3;
    length4 = this.length;
    offset3 = 0;
  } else if (isFinite(offset3)) {
    offset3 = offset3 | 0;
    if (isFinite(length4)) {
      length4 = length4 | 0;
      if (encoding === void 0)
        encoding = "utf8";
    } else {
      encoding = length4;
      length4 = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset3;
  if (length4 === void 0 || length4 > remaining)
    length4 = remaining;
  if (string.length > 0 && (length4 < 0 || offset3 < 0) || offset3 > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding)
    encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite2(this, string, offset3, length4);
      case "utf8":
      case "utf-8":
        return utf8Write2(this, string, offset3, length4);
      case "ascii":
        return asciiWrite2(this, string, offset3, length4);
      case "latin1":
      case "binary":
        return latin1Write2(this, string, offset3, length4);
      case "base64":
        return base64Write2(this, string, offset3, length4);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write2(this, string, offset3, length4);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer$4.prototype.toJSON = function toJSON2() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice2(buf, start3, end3) {
  if (start3 === 0 && end3 === buf.length) {
    return fromByteArray$12(buf);
  } else {
    return fromByteArray$12(buf.slice(start3, end3));
  }
}
function utf8Slice2(buf, start3, end3) {
  end3 = Math.min(buf.length, end3);
  var res = [];
  var i = start3;
  while (i < end3) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end3) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray2(res);
}
var MAX_ARGUMENTS_LENGTH2 = 4096;
function decodeCodePointsArray2(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH2) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2)
    );
  }
  return res;
}
function asciiSlice2(buf, start3, end3) {
  var ret = "";
  end3 = Math.min(buf.length, end3);
  for (var i = start3; i < end3; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice2(buf, start3, end3) {
  var ret = "";
  end3 = Math.min(buf.length, end3);
  for (var i = start3; i < end3; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice2(buf, start3, end3) {
  var len = buf.length;
  if (!start3 || start3 < 0)
    start3 = 0;
  if (!end3 || end3 < 0 || end3 > len)
    end3 = len;
  var out = "";
  for (var i = start3; i < end3; ++i) {
    out += toHex$1(buf[i]);
  }
  return out;
}
function utf16leSlice2(buf, start3, end3) {
  var bytes = buf.slice(start3, end3);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
Buffer$4.prototype.slice = function slice3(start3, end3) {
  var len = this.length;
  start3 = ~~start3;
  end3 = end3 === void 0 ? len : ~~end3;
  if (start3 < 0) {
    start3 += len;
    if (start3 < 0)
      start3 = 0;
  } else if (start3 > len) {
    start3 = len;
  }
  if (end3 < 0) {
    end3 += len;
    if (end3 < 0)
      end3 = 0;
  } else if (end3 > len) {
    end3 = len;
  }
  if (end3 < start3)
    end3 = start3;
  var newBuf;
  if (Buffer$4.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start3, end3);
    newBuf.__proto__ = Buffer$4.prototype;
  } else {
    var sliceLen = end3 - start3;
    newBuf = new Buffer$4(sliceLen, void 0);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start3];
    }
  }
  return newBuf;
};
function checkOffset2(offset3, ext, length4) {
  if (offset3 % 1 !== 0 || offset3 < 0)
    throw new RangeError("offset is not uint");
  if (offset3 + ext > length4)
    throw new RangeError("Trying to access beyond buffer length");
}
Buffer$4.prototype.readUIntLE = function readUIntLE2(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert)
    checkOffset2(offset3, byteLength5, this.length);
  var val = this[offset3];
  var mul = 1;
  var i = 0;
  while (++i < byteLength5 && (mul *= 256)) {
    val += this[offset3 + i] * mul;
  }
  return val;
};
Buffer$4.prototype.readUIntBE = function readUIntBE2(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    checkOffset2(offset3, byteLength5, this.length);
  }
  var val = this[offset3 + --byteLength5];
  var mul = 1;
  while (byteLength5 > 0 && (mul *= 256)) {
    val += this[offset3 + --byteLength5] * mul;
  }
  return val;
};
Buffer$4.prototype.readUInt8 = function readUInt82(offset3, noAssert) {
  if (!noAssert)
    checkOffset2(offset3, 1, this.length);
  return this[offset3];
};
Buffer$4.prototype.readUInt16LE = function readUInt16LE2(offset3, noAssert) {
  if (!noAssert)
    checkOffset2(offset3, 2, this.length);
  return this[offset3] | this[offset3 + 1] << 8;
};
Buffer$4.prototype.readUInt16BE = function readUInt16BE2(offset3, noAssert) {
  if (!noAssert)
    checkOffset2(offset3, 2, this.length);
  return this[offset3] << 8 | this[offset3 + 1];
};
Buffer$4.prototype.readUInt32LE = function readUInt32LE2(offset3, noAssert) {
  if (!noAssert)
    checkOffset2(offset3, 4, this.length);
  return (this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16) + this[offset3 + 3] * 16777216;
};
Buffer$4.prototype.readUInt32BE = function readUInt32BE2(offset3, noAssert) {
  if (!noAssert)
    checkOffset2(offset3, 4, this.length);
  return this[offset3] * 16777216 + (this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3]);
};
Buffer$4.prototype.readIntLE = function readIntLE2(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert)
    checkOffset2(offset3, byteLength5, this.length);
  var val = this[offset3];
  var mul = 1;
  var i = 0;
  while (++i < byteLength5 && (mul *= 256)) {
    val += this[offset3 + i] * mul;
  }
  mul *= 128;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer$4.prototype.readIntBE = function readIntBE2(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert)
    checkOffset2(offset3, byteLength5, this.length);
  var i = byteLength5;
  var mul = 1;
  var val = this[offset3 + --i];
  while (i > 0 && (mul *= 256)) {
    val += this[offset3 + --i] * mul;
  }
  mul *= 128;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer$4.prototype.readInt8 = function readInt82(offset3, noAssert) {
  if (!noAssert)
    checkOffset2(offset3, 1, this.length);
  if (!(this[offset3] & 128))
    return this[offset3];
  return (255 - this[offset3] + 1) * -1;
};
Buffer$4.prototype.readInt16LE = function readInt16LE2(offset3, noAssert) {
  if (!noAssert)
    checkOffset2(offset3, 2, this.length);
  var val = this[offset3] | this[offset3 + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$4.prototype.readInt16BE = function readInt16BE2(offset3, noAssert) {
  if (!noAssert)
    checkOffset2(offset3, 2, this.length);
  var val = this[offset3 + 1] | this[offset3] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer$4.prototype.readInt32LE = function readInt32LE2(offset3, noAssert) {
  if (!noAssert)
    checkOffset2(offset3, 4, this.length);
  return this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16 | this[offset3 + 3] << 24;
};
Buffer$4.prototype.readInt32BE = function readInt32BE2(offset3, noAssert) {
  if (!noAssert)
    checkOffset2(offset3, 4, this.length);
  return this[offset3] << 24 | this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3];
};
Buffer$4.prototype.readFloatLE = function readFloatLE2(offset3, noAssert) {
  if (!noAssert)
    checkOffset2(offset3, 4, this.length);
  return read2(this, offset3, true, 23, 4);
};
Buffer$4.prototype.readFloatBE = function readFloatBE2(offset3, noAssert) {
  if (!noAssert)
    checkOffset2(offset3, 4, this.length);
  return read2(this, offset3, false, 23, 4);
};
Buffer$4.prototype.readDoubleLE = function readDoubleLE2(offset3, noAssert) {
  if (!noAssert)
    checkOffset2(offset3, 8, this.length);
  return read2(this, offset3, true, 52, 8);
};
Buffer$4.prototype.readDoubleBE = function readDoubleBE2(offset3, noAssert) {
  if (!noAssert)
    checkOffset2(offset3, 8, this.length);
  return read2(this, offset3, false, 52, 8);
};
function checkInt2(buf, value2, offset3, ext, max3, min3) {
  if (!internalIsBuffer2(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value2 > max3 || value2 < min3)
    throw new RangeError('"value" argument is out of bounds');
  if (offset3 + ext > buf.length)
    throw new RangeError("Index out of range");
}
Buffer$4.prototype.writeUIntLE = function writeUIntLE2(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt2(this, value2, offset3, byteLength5, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset3] = value2 & 255;
  while (++i < byteLength5 && (mul *= 256)) {
    this[offset3 + i] = value2 / mul & 255;
  }
  return offset3 + byteLength5;
};
Buffer$4.prototype.writeUIntBE = function writeUIntBE2(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt2(this, value2, offset3, byteLength5, maxBytes, 0);
  }
  var i = byteLength5 - 1;
  var mul = 1;
  this[offset3 + i] = value2 & 255;
  while (--i >= 0 && (mul *= 256)) {
    this[offset3 + i] = value2 / mul & 255;
  }
  return offset3 + byteLength5;
};
Buffer$4.prototype.writeUInt8 = function writeUInt82(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt2(this, value2, offset3, 1, 255, 0);
  if (!Buffer$4.TYPED_ARRAY_SUPPORT)
    value2 = Math.floor(value2);
  this[offset3] = value2 & 255;
  return offset3 + 1;
};
function objectWriteUInt162(buf, value2, offset3, littleEndian) {
  if (value2 < 0)
    value2 = 65535 + value2 + 1;
  for (var i = 0, j = Math.min(buf.length - offset3, 2); i < j; ++i) {
    buf[offset3 + i] = (value2 & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
Buffer$4.prototype.writeUInt16LE = function writeUInt16LE2(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt2(this, value2, offset3, 2, 65535, 0);
  if (Buffer$4.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt162(this, value2, offset3, true);
  }
  return offset3 + 2;
};
Buffer$4.prototype.writeUInt16BE = function writeUInt16BE2(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt2(this, value2, offset3, 2, 65535, 0);
  if (Buffer$4.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 8;
    this[offset3 + 1] = value2 & 255;
  } else {
    objectWriteUInt162(this, value2, offset3, false);
  }
  return offset3 + 2;
};
function objectWriteUInt322(buf, value2, offset3, littleEndian) {
  if (value2 < 0)
    value2 = 4294967295 + value2 + 1;
  for (var i = 0, j = Math.min(buf.length - offset3, 4); i < j; ++i) {
    buf[offset3 + i] = value2 >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
Buffer$4.prototype.writeUInt32LE = function writeUInt32LE2(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt2(this, value2, offset3, 4, 4294967295, 0);
  if (Buffer$4.TYPED_ARRAY_SUPPORT) {
    this[offset3 + 3] = value2 >>> 24;
    this[offset3 + 2] = value2 >>> 16;
    this[offset3 + 1] = value2 >>> 8;
    this[offset3] = value2 & 255;
  } else {
    objectWriteUInt322(this, value2, offset3, true);
  }
  return offset3 + 4;
};
Buffer$4.prototype.writeUInt32BE = function writeUInt32BE2(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt2(this, value2, offset3, 4, 4294967295, 0);
  if (Buffer$4.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 24;
    this[offset3 + 1] = value2 >>> 16;
    this[offset3 + 2] = value2 >>> 8;
    this[offset3 + 3] = value2 & 255;
  } else {
    objectWriteUInt322(this, value2, offset3, false);
  }
  return offset3 + 4;
};
Buffer$4.prototype.writeIntLE = function writeIntLE2(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt2(this, value2, offset3, byteLength5, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset3] = value2 & 255;
  while (++i < byteLength5 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset3 + i - 1] !== 0) {
      sub = 1;
    }
    this[offset3 + i] = (value2 / mul >> 0) - sub & 255;
  }
  return offset3 + byteLength5;
};
Buffer$4.prototype.writeIntBE = function writeIntBE2(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt2(this, value2, offset3, byteLength5, limit - 1, -limit);
  }
  var i = byteLength5 - 1;
  var mul = 1;
  var sub = 0;
  this[offset3 + i] = value2 & 255;
  while (--i >= 0 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset3 + i + 1] !== 0) {
      sub = 1;
    }
    this[offset3 + i] = (value2 / mul >> 0) - sub & 255;
  }
  return offset3 + byteLength5;
};
Buffer$4.prototype.writeInt8 = function writeInt82(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt2(this, value2, offset3, 1, 127, -128);
  if (!Buffer$4.TYPED_ARRAY_SUPPORT)
    value2 = Math.floor(value2);
  if (value2 < 0)
    value2 = 255 + value2 + 1;
  this[offset3] = value2 & 255;
  return offset3 + 1;
};
Buffer$4.prototype.writeInt16LE = function writeInt16LE2(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt2(this, value2, offset3, 2, 32767, -32768);
  if (Buffer$4.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt162(this, value2, offset3, true);
  }
  return offset3 + 2;
};
Buffer$4.prototype.writeInt16BE = function writeInt16BE2(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt2(this, value2, offset3, 2, 32767, -32768);
  if (Buffer$4.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 8;
    this[offset3 + 1] = value2 & 255;
  } else {
    objectWriteUInt162(this, value2, offset3, false);
  }
  return offset3 + 2;
};
Buffer$4.prototype.writeInt32LE = function writeInt32LE2(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt2(this, value2, offset3, 4, 2147483647, -2147483648);
  if (Buffer$4.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
    this[offset3 + 2] = value2 >>> 16;
    this[offset3 + 3] = value2 >>> 24;
  } else {
    objectWriteUInt322(this, value2, offset3, true);
  }
  return offset3 + 4;
};
Buffer$4.prototype.writeInt32BE = function writeInt32BE2(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt2(this, value2, offset3, 4, 2147483647, -2147483648);
  if (value2 < 0)
    value2 = 4294967295 + value2 + 1;
  if (Buffer$4.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 24;
    this[offset3 + 1] = value2 >>> 16;
    this[offset3 + 2] = value2 >>> 8;
    this[offset3 + 3] = value2 & 255;
  } else {
    objectWriteUInt322(this, value2, offset3, false);
  }
  return offset3 + 4;
};
function checkIEEE7542(buf, value2, offset3, ext, max3, min3) {
  if (offset3 + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset3 < 0)
    throw new RangeError("Index out of range");
}
function writeFloat2(buf, value2, offset3, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7542(buf, value2, offset3, 4);
  }
  write3(buf, value2, offset3, littleEndian, 23, 4);
  return offset3 + 4;
}
Buffer$4.prototype.writeFloatLE = function writeFloatLE2(value2, offset3, noAssert) {
  return writeFloat2(this, value2, offset3, true, noAssert);
};
Buffer$4.prototype.writeFloatBE = function writeFloatBE2(value2, offset3, noAssert) {
  return writeFloat2(this, value2, offset3, false, noAssert);
};
function writeDouble2(buf, value2, offset3, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7542(buf, value2, offset3, 8);
  }
  write3(buf, value2, offset3, littleEndian, 52, 8);
  return offset3 + 8;
}
Buffer$4.prototype.writeDoubleLE = function writeDoubleLE2(value2, offset3, noAssert) {
  return writeDouble2(this, value2, offset3, true, noAssert);
};
Buffer$4.prototype.writeDoubleBE = function writeDoubleBE2(value2, offset3, noAssert) {
  return writeDouble2(this, value2, offset3, false, noAssert);
};
Buffer$4.prototype.copy = function copy2(target, targetStart, start3, end3) {
  if (!start3)
    start3 = 0;
  if (!end3 && end3 !== 0)
    end3 = this.length;
  if (targetStart >= target.length)
    targetStart = target.length;
  if (!targetStart)
    targetStart = 0;
  if (end3 > 0 && end3 < start3)
    end3 = start3;
  if (end3 === start3)
    return 0;
  if (target.length === 0 || this.length === 0)
    return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start3 < 0 || start3 >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (end3 < 0)
    throw new RangeError("sourceEnd out of bounds");
  if (end3 > this.length)
    end3 = this.length;
  if (target.length - targetStart < end3 - start3) {
    end3 = target.length - targetStart + start3;
  }
  var len = end3 - start3;
  var i;
  if (this === target && start3 < targetStart && targetStart < end3) {
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start3];
    }
  } else if (len < 1e3 || !Buffer$4.TYPED_ARRAY_SUPPORT) {
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start3];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start3, start3 + len),
      targetStart
    );
  }
  return len;
};
Buffer$4.prototype.fill = function fill2(val, start3, end3, encoding) {
  if (typeof val === "string") {
    if (typeof start3 === "string") {
      encoding = start3;
      start3 = 0;
      end3 = this.length;
    } else if (typeof end3 === "string") {
      encoding = end3;
      end3 = this.length;
    }
    if (val.length === 1) {
      var code3 = val.charCodeAt(0);
      if (code3 < 256) {
        val = code3;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer$4.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start3 < 0 || this.length < start3 || this.length < end3) {
    throw new RangeError("Out of range index");
  }
  if (end3 <= start3) {
    return this;
  }
  start3 = start3 >>> 0;
  end3 = end3 === void 0 ? this.length : end3 >>> 0;
  if (!val)
    val = 0;
  var i;
  if (typeof val === "number") {
    for (i = start3; i < end3; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer2(val) ? val : utf8ToBytes2(new Buffer$4(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end3 - start3; ++i) {
      this[i + start3] = bytes[i % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE2 = /[^+\/0-9A-Za-z-_]/g;
function base64clean2(str) {
  str = stringtrim2(str).replace(INVALID_BASE64_RE2, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim2(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex$1(n) {
  if (n < 16)
    return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes2(string, units) {
  units = units || Infinity;
  var codePoint;
  var length4 = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length4; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length4) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes2(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes2(str, units) {
  var c2, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0)
      break;
    c2 = str.charCodeAt(i);
    hi = c2 >> 8;
    lo = c2 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes2(str) {
  return toByteArray$12(base64clean2(str));
}
function blitBuffer2(src3, dst, offset3, length4) {
  for (var i = 0; i < length4; ++i) {
    if (i + offset3 >= dst.length || i >= src3.length)
      break;
    dst[i + offset3] = src3[i];
  }
  return i;
}
function isnan2(val) {
  return val !== val;
}
function isBuffer3(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer2(obj) || isSlowBuffer2(obj));
}
function isFastBuffer2(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer2(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer2(obj.slice(0, 0));
}
var commonjsGlobal2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace2(n) {
  if (n.__esModule)
    return n;
  var a2 = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a2, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a2;
}
var readableBrowser = { exports: {} };
var _registry = {};
function defaultSetTimout2() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout2() {
  throw new Error("clearTimeout has not been defined");
}
var cachedSetTimeout2 = defaultSetTimout2;
var cachedClearTimeout2 = defaultClearTimeout2;
if (typeof global$12.setTimeout === "function") {
  cachedSetTimeout2 = setTimeout;
}
if (typeof global$12.clearTimeout === "function") {
  cachedClearTimeout2 = clearTimeout;
}
function runTimeout2(fun) {
  if (cachedSetTimeout2 === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout2 === defaultSetTimout2 || !cachedSetTimeout2) && setTimeout) {
    cachedSetTimeout2 = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout2(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout2.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout2.call(this, fun, 0);
    }
  }
}
function runClearTimeout2(marker) {
  if (cachedClearTimeout2 === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout2 === defaultClearTimeout2 || !cachedClearTimeout2) && clearTimeout) {
    cachedClearTimeout2 = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout2(marker);
  } catch (e) {
    try {
      return cachedClearTimeout2.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout2.call(this, marker);
    }
  }
}
var queue2 = [];
var draining2 = false;
var currentQueue2;
var queueIndex2 = -1;
function cleanUpNextTick2() {
  if (!draining2 || !currentQueue2) {
    return;
  }
  draining2 = false;
  if (currentQueue2.length) {
    queue2 = currentQueue2.concat(queue2);
  } else {
    queueIndex2 = -1;
  }
  if (queue2.length) {
    drainQueue2();
  }
}
function drainQueue2() {
  if (draining2) {
    return;
  }
  var timeout = runTimeout2(cleanUpNextTick2);
  draining2 = true;
  var len = queue2.length;
  while (len) {
    currentQueue2 = queue2;
    queue2 = [];
    while (++queueIndex2 < len) {
      if (currentQueue2) {
        currentQueue2[queueIndex2].run();
      }
    }
    queueIndex2 = -1;
    len = queue2.length;
  }
  currentQueue2 = null;
  draining2 = false;
  runClearTimeout2(timeout);
}
function nextTick2(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue2.push(new Item2(fun, args));
  if (queue2.length === 1 && !draining2) {
    runTimeout2(drainQueue2);
  }
}
function Item2(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item2.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title2 = "browser";
var platform2 = "browser";
var browser$12 = true;
var env2 = {};
var argv2 = [];
var version2 = "";
var versions2 = {};
var release2 = {};
var config$1 = {};
function noop$2() {
}
var on2 = noop$2;
var addListener3 = noop$2;
var once$3 = noop$2;
var off2 = noop$2;
var removeListener3 = noop$2;
var removeAllListeners3 = noop$2;
var emit3 = noop$2;
function binding$12(name) {
  throw new Error("process.binding is not supported");
}
function cwd2() {
  return "/";
}
function chdir2(dir) {
  throw new Error("process.chdir is not supported");
}
function umask2() {
  return 0;
}
var performance2 = global$12.performance || {};
var performanceNow2 = performance2.now || performance2.mozNow || performance2.msNow || performance2.oNow || performance2.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function hrtime2(previousTimestamp) {
  var clocktime = performanceNow2.call(performance2) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
var startTime2 = /* @__PURE__ */ new Date();
function uptime2() {
  var currentTime = /* @__PURE__ */ new Date();
  var dif = currentTime - startTime2;
  return dif / 1e3;
}
var browser$1$12 = {
  nextTick: nextTick2,
  title: title2,
  browser: browser$12,
  env: env2,
  argv: argv2,
  version: version2,
  versions: versions2,
  on: on2,
  addListener: addListener3,
  once: once$3,
  off: off2,
  removeListener: removeListener3,
  removeAllListeners: removeAllListeners3,
  emit: emit3,
  binding: binding$12,
  cwd: cwd2,
  chdir: chdir2,
  umask: umask2,
  hrtime: hrtime2,
  platform: platform2,
  release: release2,
  config: config$1,
  uptime: uptime2
};
var events2 = { exports: {} };
var R2 = typeof Reflect === "object" ? Reflect : null;
var ReflectApply3 = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply4(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys2;
if (R2 && typeof R2.ownKeys === "function") {
  ReflectOwnKeys2 = R2.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys2 = function ReflectOwnKeys3(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys2 = function ReflectOwnKeys3(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning2(warning) {
  if (console && console.warn)
    console.warn(warning);
}
var NumberIsNaN3 = Number.isNaN || function NumberIsNaN4(value2) {
  return value2 !== value2;
};
function EventEmitter2() {
  EventEmitter2.init.call(this);
}
events2.exports = EventEmitter2;
events2.exports.once = once$2;
EventEmitter2.EventEmitter = EventEmitter2;
EventEmitter2.prototype._events = void 0;
EventEmitter2.prototype._eventsCount = 0;
EventEmitter2.prototype._maxListeners = void 0;
var defaultMaxListeners2 = 10;
function checkListener2(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
  enumerable: true,
  get: function get4() {
    return defaultMaxListeners2;
  },
  set: function set2(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN3(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners2 = arg;
  }
});
EventEmitter2.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter2.prototype.setMaxListeners = function setMaxListeners2(n) {
  if (typeof n !== "number" || n < 0 || NumberIsNaN3(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners2(that) {
  if (that._maxListeners === void 0)
    return EventEmitter2.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter2.prototype.getMaxListeners = function getMaxListeners2() {
  return _getMaxListeners2(this);
};
EventEmitter2.prototype.emit = function emit4(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++)
    args.push(arguments[i]);
  var doError = type === "error";
  var events4 = this._events;
  if (events4 !== void 0)
    doError = doError && events4.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er2;
    if (args.length > 0)
      er2 = args[0];
    if (er2 instanceof Error) {
      throw er2;
    }
    var err2 = new Error("Unhandled error." + (er2 ? " (" + er2.message + ")" : ""));
    err2.context = er2;
    throw err2;
  }
  var handler = events4[type];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply3(handler, this, args);
  } else {
    var len = handler.length;
    var listeners3 = arrayClone2(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply3(listeners3[i], this, args);
  }
  return true;
};
function _addListener2(target, type, listener, prepend) {
  var m2;
  var events4;
  var existing;
  checkListener2(listener);
  events4 = target._events;
  if (events4 === void 0) {
    events4 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events4.newListener !== void 0) {
      target.emit("newListener", type, listener.listener ? listener.listener : listener);
      events4 = target._events;
    }
    existing = events4[type];
  }
  if (existing === void 0) {
    existing = events4[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events4[type] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m2 = _getMaxListeners2(target);
    if (m2 > 0 && existing.length > m2 && !existing.warned) {
      existing.warned = true;
      var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w.name = "MaxListenersExceededWarning";
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning2(w);
    }
  }
  return target;
}
EventEmitter2.prototype.addListener = function addListener4(type, listener) {
  return _addListener2(this, type, listener, false);
};
EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
EventEmitter2.prototype.prependListener = function prependListener3(type, listener) {
  return _addListener2(this, type, listener, true);
};
function onceWrapper2() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap2(target, type, listener) {
  var state2 = {
    fired: false,
    wrapFn: void 0,
    target,
    type,
    listener
  };
  var wrapped = onceWrapper2.bind(state2);
  wrapped.listener = listener;
  state2.wrapFn = wrapped;
  return wrapped;
}
EventEmitter2.prototype.once = function once3(type, listener) {
  checkListener2(listener);
  this.on(type, _onceWrap2(this, type, listener));
  return this;
};
EventEmitter2.prototype.prependOnceListener = function prependOnceListener2(type, listener) {
  checkListener2(listener);
  this.prependListener(type, _onceWrap2(this, type, listener));
  return this;
};
EventEmitter2.prototype.removeListener = function removeListener4(type, listener) {
  var list, events4, position, i, originalListener;
  checkListener2(listener);
  events4 = this._events;
  if (events4 === void 0)
    return this;
  list = events4[type];
  if (list === void 0)
    return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events4[type];
      if (events4.removeListener)
        this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0)
      return this;
    if (position === 0)
      list.shift();
    else {
      spliceOne2(list, position);
    }
    if (list.length === 1)
      events4[type] = list[0];
    if (events4.removeListener !== void 0)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
EventEmitter2.prototype.removeAllListeners = function removeAllListeners4(type) {
  var listeners3, events4, i;
  events4 = this._events;
  if (events4 === void 0)
    return this;
  if (events4.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events4[type] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events4[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys5 = Object.keys(events4);
    var key;
    for (i = 0; i < keys5.length; ++i) {
      key = keys5[i];
      if (key === "removeListener")
        continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners3 = events4[type];
  if (typeof listeners3 === "function") {
    this.removeListener(type, listeners3);
  } else if (listeners3 !== void 0) {
    for (i = listeners3.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners3[i]);
    }
  }
  return this;
};
function _listeners2(target, type, unwrap) {
  var events4 = target._events;
  if (events4 === void 0)
    return [];
  var evlistener = events4[type];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners2(evlistener) : arrayClone2(evlistener, evlistener.length);
}
EventEmitter2.prototype.listeners = function listeners2(type) {
  return _listeners2(this, type, true);
};
EventEmitter2.prototype.rawListeners = function rawListeners2(type) {
  return _listeners2(this, type, false);
};
EventEmitter2.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount2.call(emitter, type);
  }
};
EventEmitter2.prototype.listenerCount = listenerCount2;
function listenerCount2(type) {
  var events4 = this._events;
  if (events4 !== void 0) {
    var evlistener = events4[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter2.prototype.eventNames = function eventNames2() {
  return this._eventsCount > 0 ? ReflectOwnKeys2(this._events) : [];
};
function arrayClone2(arr, n) {
  var copy6 = new Array(n);
  for (var i = 0; i < n; ++i)
    copy6[i] = arr[i];
  return copy6;
}
function spliceOne2(list, index3) {
  for (; index3 + 1 < list.length; index3++)
    list[index3] = list[index3 + 1];
  list.pop();
}
function unwrapListeners2(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
function once$2(emitter, name) {
  return new Promise(function(resolve3, reject) {
    function errorListener(err2) {
      emitter.removeListener(name, resolver);
      reject(err2);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve3([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener2(emitter, name, resolver, {
      once: true
    });
    if (name !== "error") {
      addErrorHandlerIfEventEmitter2(emitter, errorListener, {
        once: true
      });
    }
  });
}
function addErrorHandlerIfEventEmitter2(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener2(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener2(emitter, name, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var streamBrowser = events2.exports.EventEmitter;
var buffer2 = {};
var base64Js2 = {};
base64Js2.byteLength = byteLength3;
base64Js2.toByteArray = toByteArray2;
base64Js2.fromByteArray = fromByteArray2;
var lookup2 = [];
var revLookup2 = [];
var Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (i = 0, len = code2.length; i < len; ++i) {
  lookup2[i] = code2[i];
  revLookup2[code2.charCodeAt(i)] = i;
}
var i;
var len;
revLookup2["-".charCodeAt(0)] = 62;
revLookup2["_".charCodeAt(0)] = 63;
function getLens2(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength3(b64) {
  var lens = getLens2(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength2(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray2(b64) {
  var tmp;
  var lens = getLens2(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr2(_byteLength2(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup2[b64.charCodeAt(i)] << 18 | revLookup2[b64.charCodeAt(i + 1)] << 12 | revLookup2[b64.charCodeAt(i + 2)] << 6 | revLookup2[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup2[b64.charCodeAt(i)] << 2 | revLookup2[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup2[b64.charCodeAt(i)] << 10 | revLookup2[b64.charCodeAt(i + 1)] << 4 | revLookup2[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase642(num) {
  return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
}
function encodeChunk2(uint82, start3, end3) {
  var tmp;
  var output = [];
  for (var i = start3; i < end3; i += 3) {
    tmp = (uint82[i] << 16 & 16711680) + (uint82[i + 1] << 8 & 65280) + (uint82[i + 2] & 255);
    output.push(tripletToBase642(tmp));
  }
  return output.join("");
}
function fromByteArray2(uint82) {
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk2(uint82, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    parts.push(lookup2[tmp >> 2] + lookup2[tmp << 4 & 63] + "==");
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    parts.push(lookup2[tmp >> 10] + lookup2[tmp >> 4 & 63] + lookup2[tmp << 2 & 63] + "=");
  }
  return parts.join("");
}
var ieee7542 = {};
ieee7542.read = function(buffer3, offset3, isLE, mLen, nBytes) {
  var e, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s2 = buffer3[offset3 + i];
  i += d;
  e = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer3[offset3 + i], i += d, nBits -= 8) {
  }
  m2 = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer3[offset3 + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e - mLen);
};
ieee7542.write = function(buffer3, value2, offset3, isLE, mLen, nBytes) {
  var e, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m2 = isNaN(value2) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c2 = Math.pow(2, -e)) < 1) {
      e--;
      c2 *= 2;
    }
    if (e + eBias >= 1) {
      value2 += rt / c2;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c2 >= 2) {
      e++;
      c2 /= 2;
    }
    if (e + eBias >= eMax) {
      m2 = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m2 = (value2 * c2 - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer3[offset3 + i] = m2 & 255, i += d, m2 /= 256, mLen -= 8) {
  }
  e = e << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer3[offset3 + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer3[offset3 + i - d] |= s2 * 128;
};
(function(exports) {
  var base64 = base64Js2;
  var ieee754$1 = ieee7542;
  var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer5;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  var K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer5.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer5.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      var arr = new Uint8Array(1);
      var proto = {
        foo: function foo() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer5.prototype, "parent", {
    enumerable: true,
    get: function get18() {
      if (!Buffer5.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer5.prototype, "offset", {
    enumerable: true,
    get: function get18() {
      if (!Buffer5.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer4(length4) {
    if (length4 > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length4 + '" is invalid for option "size"');
    }
    var buf = new Uint8Array(length4);
    Object.setPrototypeOf(buf, Buffer5.prototype);
    return buf;
  }
  function Buffer5(arg, encodingOrOffset, length4) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe4(arg);
    }
    return from4(arg, encodingOrOffset, length4);
  }
  Buffer5.poolSize = 8192;
  function from4(value2, encodingOrOffset, length4) {
    if (typeof value2 === "string") {
      return fromString4(value2, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value2)) {
      return fromArrayView(value2);
    }
    if (value2 == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2);
    }
    if (isInstance(value2, ArrayBuffer) || value2 && isInstance(value2.buffer, ArrayBuffer)) {
      return fromArrayBuffer4(value2, encodingOrOffset, length4);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value2, SharedArrayBuffer) || value2 && isInstance(value2.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer4(value2, encodingOrOffset, length4);
    }
    if (typeof value2 === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    var valueOf = value2.valueOf && value2.valueOf();
    if (valueOf != null && valueOf !== value2) {
      return Buffer5.from(valueOf, encodingOrOffset, length4);
    }
    var b = fromObject4(value2);
    if (b)
      return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value2[Symbol.toPrimitive] === "function") {
      return Buffer5.from(value2[Symbol.toPrimitive]("string"), encodingOrOffset, length4);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2);
  }
  Buffer5.from = function(value2, encodingOrOffset, length4) {
    return from4(value2, encodingOrOffset, length4);
  };
  Object.setPrototypeOf(Buffer5.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer5, Uint8Array);
  function assertSize4(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc4(size, fill5, encoding) {
    assertSize4(size);
    if (size <= 0) {
      return createBuffer4(size);
    }
    if (fill5 !== void 0) {
      return typeof encoding === "string" ? createBuffer4(size).fill(fill5, encoding) : createBuffer4(size).fill(fill5);
    }
    return createBuffer4(size);
  }
  Buffer5.alloc = function(size, fill5, encoding) {
    return alloc4(size, fill5, encoding);
  };
  function allocUnsafe4(size) {
    assertSize4(size);
    return createBuffer4(size < 0 ? 0 : checked4(size) | 0);
  }
  Buffer5.allocUnsafe = function(size) {
    return allocUnsafe4(size);
  };
  Buffer5.allocUnsafeSlow = function(size) {
    return allocUnsafe4(size);
  };
  function fromString4(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer5.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    var length4 = byteLength5(string, encoding) | 0;
    var buf = createBuffer4(length4);
    var actual = buf.write(string, encoding);
    if (actual !== length4) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike4(array) {
    var length4 = array.length < 0 ? 0 : checked4(array.length) | 0;
    var buf = createBuffer4(length4);
    for (var i = 0; i < length4; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      var copy6 = new Uint8Array(arrayView);
      return fromArrayBuffer4(copy6.buffer, copy6.byteOffset, copy6.byteLength);
    }
    return fromArrayLike4(arrayView);
  }
  function fromArrayBuffer4(array, byteOffset, length4) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length4 || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    var buf;
    if (byteOffset === void 0 && length4 === void 0) {
      buf = new Uint8Array(array);
    } else if (length4 === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length4);
    }
    Object.setPrototypeOf(buf, Buffer5.prototype);
    return buf;
  }
  function fromObject4(obj) {
    if (Buffer5.isBuffer(obj)) {
      var len = checked4(obj.length) | 0;
      var buf = createBuffer4(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN5(obj.length)) {
        return createBuffer4(0);
      }
      return fromArrayLike4(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike4(obj.data);
    }
  }
  function checked4(length4) {
    if (length4 >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length4 | 0;
  }
  function SlowBuffer(length4) {
    if (+length4 != length4) {
      length4 = 0;
    }
    return Buffer5.alloc(+length4);
  }
  Buffer5.isBuffer = function isBuffer6(b) {
    return b != null && b._isBuffer === true && b !== Buffer5.prototype;
  };
  Buffer5.compare = function compare9(a2, b) {
    if (isInstance(a2, Uint8Array))
      a2 = Buffer5.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b, Uint8Array))
      b = Buffer5.from(b, b.offset, b.byteLength);
    if (!Buffer5.isBuffer(a2) || !Buffer5.isBuffer(b)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a2 === b)
      return 0;
    var x = a2.length;
    var y = b.length;
    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a2[i] !== b[i]) {
        x = a2[i];
        y = b[i];
        break;
      }
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer5.isEncoding = function isEncoding6(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer5.concat = function concat8(list, length4) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer5.alloc(0);
    }
    var i;
    if (length4 === void 0) {
      length4 = 0;
      for (i = 0; i < list.length; ++i) {
        length4 += list[i].length;
      }
    }
    var buffer3 = Buffer5.allocUnsafe(length4);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer3.length) {
          Buffer5.from(buf).copy(buffer3, pos);
        } else {
          Uint8Array.prototype.set.call(buffer3, buf, pos);
        }
      } else if (!Buffer5.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer3, pos);
      }
      pos += buf.length;
    }
    return buffer3;
  };
  function byteLength5(string, encoding) {
    if (Buffer5.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes4(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes4(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes4(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer5.byteLength = byteLength5;
  function slowToString4(encoding, start3, end3) {
    var loweredCase = false;
    if (start3 === void 0 || start3 < 0) {
      start3 = 0;
    }
    if (start3 > this.length) {
      return "";
    }
    if (end3 === void 0 || end3 > this.length) {
      end3 = this.length;
    }
    if (end3 <= 0) {
      return "";
    }
    end3 >>>= 0;
    start3 >>>= 0;
    if (end3 <= start3) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice4(this, start3, end3);
        case "utf8":
        case "utf-8":
          return utf8Slice4(this, start3, end3);
        case "ascii":
          return asciiSlice4(this, start3, end3);
        case "latin1":
        case "binary":
          return latin1Slice4(this, start3, end3);
        case "base64":
          return base64Slice4(this, start3, end3);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice4(this, start3, end3);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer5.prototype._isBuffer = true;
  function swap4(b, n, m2) {
    var i = b[n];
    b[n] = b[m2];
    b[m2] = i;
  }
  Buffer5.prototype.swap16 = function swap164() {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i = 0; i < len; i += 2) {
      swap4(this, i, i + 1);
    }
    return this;
  };
  Buffer5.prototype.swap32 = function swap324() {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i = 0; i < len; i += 4) {
      swap4(this, i, i + 3);
      swap4(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer5.prototype.swap64 = function swap644() {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i = 0; i < len; i += 8) {
      swap4(this, i, i + 7);
      swap4(this, i + 1, i + 6);
      swap4(this, i + 2, i + 5);
      swap4(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer5.prototype.toString = function toString7() {
    var length4 = this.length;
    if (length4 === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice4(this, 0, length4);
    return slowToString4.apply(this, arguments);
  };
  Buffer5.prototype.toLocaleString = Buffer5.prototype.toString;
  Buffer5.prototype.equals = function equals4(b) {
    if (!Buffer5.isBuffer(b))
      throw new TypeError("Argument must be a Buffer");
    if (this === b)
      return true;
    return Buffer5.compare(this, b) === 0;
  };
  Buffer5.prototype.inspect = function inspect6() {
    var str = "";
    var max3 = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max3).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max3)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer5.prototype[customInspectSymbol] = Buffer5.prototype.inspect;
  }
  Buffer5.prototype.compare = function compare9(target, start3, end3, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer5.from(target, target.offset, target.byteLength);
    }
    if (!Buffer5.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start3 === void 0) {
      start3 = 0;
    }
    if (end3 === void 0) {
      end3 = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start3 < 0 || end3 > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start3 >= end3) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start3 >= end3) {
      return 1;
    }
    start3 >>>= 0;
    end3 >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    var x = thisEnd - thisStart;
    var y = end3 - start3;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start3, end3);
    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf4(buffer3, val, byteOffset, encoding, dir) {
    if (buffer3.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN5(byteOffset)) {
      byteOffset = dir ? 0 : buffer3.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer3.length + byteOffset;
    if (byteOffset >= buffer3.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer3.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer5.from(val, encoding);
    }
    if (Buffer5.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf4(buffer3, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer3, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer3, val, byteOffset);
        }
      }
      return arrayIndexOf4(buffer3, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf4(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read4(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read4(arr, i) === read4(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read4(arr, i + j) !== read4(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i;
      }
    }
    return -1;
  }
  Buffer5.prototype.includes = function includes6(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer5.prototype.indexOf = function indexOf8(val, byteOffset, encoding) {
    return bidirectionalIndexOf4(this, val, byteOffset, encoding, true);
  };
  Buffer5.prototype.lastIndexOf = function lastIndexOf4(val, byteOffset, encoding) {
    return bidirectionalIndexOf4(this, val, byteOffset, encoding, false);
  };
  function hexWrite4(buf, string, offset3, length4) {
    offset3 = Number(offset3) || 0;
    var remaining = buf.length - offset3;
    if (!length4) {
      length4 = remaining;
    } else {
      length4 = Number(length4);
      if (length4 > remaining) {
        length4 = remaining;
      }
    }
    var strLen = string.length;
    if (length4 > strLen / 2) {
      length4 = strLen / 2;
    }
    for (var i = 0; i < length4; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN5(parsed))
        return i;
      buf[offset3 + i] = parsed;
    }
    return i;
  }
  function utf8Write4(buf, string, offset3, length4) {
    return blitBuffer4(utf8ToBytes4(string, buf.length - offset3), buf, offset3, length4);
  }
  function asciiWrite4(buf, string, offset3, length4) {
    return blitBuffer4(asciiToBytes4(string), buf, offset3, length4);
  }
  function base64Write4(buf, string, offset3, length4) {
    return blitBuffer4(base64ToBytes4(string), buf, offset3, length4);
  }
  function ucs2Write4(buf, string, offset3, length4) {
    return blitBuffer4(utf16leToBytes4(string, buf.length - offset3), buf, offset3, length4);
  }
  Buffer5.prototype.write = function write7(string, offset3, length4, encoding) {
    if (offset3 === void 0) {
      encoding = "utf8";
      length4 = this.length;
      offset3 = 0;
    } else if (length4 === void 0 && typeof offset3 === "string") {
      encoding = offset3;
      length4 = this.length;
      offset3 = 0;
    } else if (isFinite(offset3)) {
      offset3 = offset3 >>> 0;
      if (isFinite(length4)) {
        length4 = length4 >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length4;
        length4 = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    var remaining = this.length - offset3;
    if (length4 === void 0 || length4 > remaining)
      length4 = remaining;
    if (string.length > 0 && (length4 < 0 || offset3 < 0) || offset3 > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite4(this, string, offset3, length4);
        case "utf8":
        case "utf-8":
          return utf8Write4(this, string, offset3, length4);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite4(this, string, offset3, length4);
        case "base64":
          return base64Write4(this, string, offset3, length4);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write4(this, string, offset3, length4);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer5.prototype.toJSON = function toJSON4() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice4(buf, start3, end3) {
    if (start3 === 0 && end3 === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start3, end3));
    }
  }
  function utf8Slice4(buf, start3, end3) {
    end3 = Math.min(buf.length, end3);
    var res = [];
    var i = start3;
    while (i < end3) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end3) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray4(res);
  }
  var MAX_ARGUMENTS_LENGTH4 = 4096;
  function decodeCodePointsArray4(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH4) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH4));
    }
    return res;
  }
  function asciiSlice4(buf, start3, end3) {
    var ret = "";
    end3 = Math.min(buf.length, end3);
    for (var i = start3; i < end3; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice4(buf, start3, end3) {
    var ret = "";
    end3 = Math.min(buf.length, end3);
    for (var i = start3; i < end3; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice4(buf, start3, end3) {
    var len = buf.length;
    if (!start3 || start3 < 0)
      start3 = 0;
    if (!end3 || end3 < 0 || end3 > len)
      end3 = len;
    var out = "";
    for (var i = start3; i < end3; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice4(buf, start3, end3) {
    var bytes = buf.slice(start3, end3);
    var res = "";
    for (var i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer5.prototype.slice = function slice10(start3, end3) {
    var len = this.length;
    start3 = ~~start3;
    end3 = end3 === void 0 ? len : ~~end3;
    if (start3 < 0) {
      start3 += len;
      if (start3 < 0)
        start3 = 0;
    } else if (start3 > len) {
      start3 = len;
    }
    if (end3 < 0) {
      end3 += len;
      if (end3 < 0)
        end3 = 0;
    } else if (end3 > len) {
      end3 = len;
    }
    if (end3 < start3)
      end3 = start3;
    var newBuf = this.subarray(start3, end3);
    Object.setPrototypeOf(newBuf, Buffer5.prototype);
    return newBuf;
  };
  function checkOffset4(offset3, ext, length4) {
    if (offset3 % 1 !== 0 || offset3 < 0)
      throw new RangeError("offset is not uint");
    if (offset3 + ext > length4)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer5.prototype.readUintLE = Buffer5.prototype.readUIntLE = function readUIntLE4(offset3, byteLength6, noAssert) {
    offset3 = offset3 >>> 0;
    byteLength6 = byteLength6 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, byteLength6, this.length);
    var val = this[offset3];
    var mul = 1;
    var i = 0;
    while (++i < byteLength6 && (mul *= 256)) {
      val += this[offset3 + i] * mul;
    }
    return val;
  };
  Buffer5.prototype.readUintBE = Buffer5.prototype.readUIntBE = function readUIntBE4(offset3, byteLength6, noAssert) {
    offset3 = offset3 >>> 0;
    byteLength6 = byteLength6 >>> 0;
    if (!noAssert) {
      checkOffset4(offset3, byteLength6, this.length);
    }
    var val = this[offset3 + --byteLength6];
    var mul = 1;
    while (byteLength6 > 0 && (mul *= 256)) {
      val += this[offset3 + --byteLength6] * mul;
    }
    return val;
  };
  Buffer5.prototype.readUint8 = Buffer5.prototype.readUInt8 = function readUInt84(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 1, this.length);
    return this[offset3];
  };
  Buffer5.prototype.readUint16LE = Buffer5.prototype.readUInt16LE = function readUInt16LE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 2, this.length);
    return this[offset3] | this[offset3 + 1] << 8;
  };
  Buffer5.prototype.readUint16BE = Buffer5.prototype.readUInt16BE = function readUInt16BE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 2, this.length);
    return this[offset3] << 8 | this[offset3 + 1];
  };
  Buffer5.prototype.readUint32LE = Buffer5.prototype.readUInt32LE = function readUInt32LE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 4, this.length);
    return (this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16) + this[offset3 + 3] * 16777216;
  };
  Buffer5.prototype.readUint32BE = Buffer5.prototype.readUInt32BE = function readUInt32BE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 4, this.length);
    return this[offset3] * 16777216 + (this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3]);
  };
  Buffer5.prototype.readIntLE = function readIntLE4(offset3, byteLength6, noAssert) {
    offset3 = offset3 >>> 0;
    byteLength6 = byteLength6 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, byteLength6, this.length);
    var val = this[offset3];
    var mul = 1;
    var i = 0;
    while (++i < byteLength6 && (mul *= 256)) {
      val += this[offset3 + i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength6);
    return val;
  };
  Buffer5.prototype.readIntBE = function readIntBE4(offset3, byteLength6, noAssert) {
    offset3 = offset3 >>> 0;
    byteLength6 = byteLength6 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, byteLength6, this.length);
    var i = byteLength6;
    var mul = 1;
    var val = this[offset3 + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset3 + --i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength6);
    return val;
  };
  Buffer5.prototype.readInt8 = function readInt84(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 1, this.length);
    if (!(this[offset3] & 128))
      return this[offset3];
    return (255 - this[offset3] + 1) * -1;
  };
  Buffer5.prototype.readInt16LE = function readInt16LE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 2, this.length);
    var val = this[offset3] | this[offset3 + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer5.prototype.readInt16BE = function readInt16BE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 2, this.length);
    var val = this[offset3 + 1] | this[offset3] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer5.prototype.readInt32LE = function readInt32LE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 4, this.length);
    return this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16 | this[offset3 + 3] << 24;
  };
  Buffer5.prototype.readInt32BE = function readInt32BE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 4, this.length);
    return this[offset3] << 24 | this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3];
  };
  Buffer5.prototype.readFloatLE = function readFloatLE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 4, this.length);
    return ieee754$1.read(this, offset3, true, 23, 4);
  };
  Buffer5.prototype.readFloatBE = function readFloatBE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 4, this.length);
    return ieee754$1.read(this, offset3, false, 23, 4);
  };
  Buffer5.prototype.readDoubleLE = function readDoubleLE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 8, this.length);
    return ieee754$1.read(this, offset3, true, 52, 8);
  };
  Buffer5.prototype.readDoubleBE = function readDoubleBE4(offset3, noAssert) {
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkOffset4(offset3, 8, this.length);
    return ieee754$1.read(this, offset3, false, 52, 8);
  };
  function checkInt4(buf, value2, offset3, ext, max3, min3) {
    if (!Buffer5.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value2 > max3 || value2 < min3)
      throw new RangeError('"value" argument is out of bounds');
    if (offset3 + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer5.prototype.writeUintLE = Buffer5.prototype.writeUIntLE = function writeUIntLE4(value2, offset3, byteLength6, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    byteLength6 = byteLength6 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength6) - 1;
      checkInt4(this, value2, offset3, byteLength6, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset3] = value2 & 255;
    while (++i < byteLength6 && (mul *= 256)) {
      this[offset3 + i] = value2 / mul & 255;
    }
    return offset3 + byteLength6;
  };
  Buffer5.prototype.writeUintBE = Buffer5.prototype.writeUIntBE = function writeUIntBE4(value2, offset3, byteLength6, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    byteLength6 = byteLength6 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength6) - 1;
      checkInt4(this, value2, offset3, byteLength6, maxBytes, 0);
    }
    var i = byteLength6 - 1;
    var mul = 1;
    this[offset3 + i] = value2 & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset3 + i] = value2 / mul & 255;
    }
    return offset3 + byteLength6;
  };
  Buffer5.prototype.writeUint8 = Buffer5.prototype.writeUInt8 = function writeUInt84(value2, offset3, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkInt4(this, value2, offset3, 1, 255, 0);
    this[offset3] = value2 & 255;
    return offset3 + 1;
  };
  Buffer5.prototype.writeUint16LE = Buffer5.prototype.writeUInt16LE = function writeUInt16LE4(value2, offset3, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkInt4(this, value2, offset3, 2, 65535, 0);
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
    return offset3 + 2;
  };
  Buffer5.prototype.writeUint16BE = Buffer5.prototype.writeUInt16BE = function writeUInt16BE4(value2, offset3, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkInt4(this, value2, offset3, 2, 65535, 0);
    this[offset3] = value2 >>> 8;
    this[offset3 + 1] = value2 & 255;
    return offset3 + 2;
  };
  Buffer5.prototype.writeUint32LE = Buffer5.prototype.writeUInt32LE = function writeUInt32LE4(value2, offset3, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkInt4(this, value2, offset3, 4, 4294967295, 0);
    this[offset3 + 3] = value2 >>> 24;
    this[offset3 + 2] = value2 >>> 16;
    this[offset3 + 1] = value2 >>> 8;
    this[offset3] = value2 & 255;
    return offset3 + 4;
  };
  Buffer5.prototype.writeUint32BE = Buffer5.prototype.writeUInt32BE = function writeUInt32BE4(value2, offset3, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkInt4(this, value2, offset3, 4, 4294967295, 0);
    this[offset3] = value2 >>> 24;
    this[offset3 + 1] = value2 >>> 16;
    this[offset3 + 2] = value2 >>> 8;
    this[offset3 + 3] = value2 & 255;
    return offset3 + 4;
  };
  Buffer5.prototype.writeIntLE = function writeIntLE4(value2, offset3, byteLength6, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength6 - 1);
      checkInt4(this, value2, offset3, byteLength6, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset3] = value2 & 255;
    while (++i < byteLength6 && (mul *= 256)) {
      if (value2 < 0 && sub === 0 && this[offset3 + i - 1] !== 0) {
        sub = 1;
      }
      this[offset3 + i] = (value2 / mul >> 0) - sub & 255;
    }
    return offset3 + byteLength6;
  };
  Buffer5.prototype.writeIntBE = function writeIntBE4(value2, offset3, byteLength6, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength6 - 1);
      checkInt4(this, value2, offset3, byteLength6, limit - 1, -limit);
    }
    var i = byteLength6 - 1;
    var mul = 1;
    var sub = 0;
    this[offset3 + i] = value2 & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value2 < 0 && sub === 0 && this[offset3 + i + 1] !== 0) {
        sub = 1;
      }
      this[offset3 + i] = (value2 / mul >> 0) - sub & 255;
    }
    return offset3 + byteLength6;
  };
  Buffer5.prototype.writeInt8 = function writeInt84(value2, offset3, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkInt4(this, value2, offset3, 1, 127, -128);
    if (value2 < 0)
      value2 = 255 + value2 + 1;
    this[offset3] = value2 & 255;
    return offset3 + 1;
  };
  Buffer5.prototype.writeInt16LE = function writeInt16LE4(value2, offset3, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkInt4(this, value2, offset3, 2, 32767, -32768);
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
    return offset3 + 2;
  };
  Buffer5.prototype.writeInt16BE = function writeInt16BE4(value2, offset3, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkInt4(this, value2, offset3, 2, 32767, -32768);
    this[offset3] = value2 >>> 8;
    this[offset3 + 1] = value2 & 255;
    return offset3 + 2;
  };
  Buffer5.prototype.writeInt32LE = function writeInt32LE4(value2, offset3, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkInt4(this, value2, offset3, 4, 2147483647, -2147483648);
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
    this[offset3 + 2] = value2 >>> 16;
    this[offset3 + 3] = value2 >>> 24;
    return offset3 + 4;
  };
  Buffer5.prototype.writeInt32BE = function writeInt32BE4(value2, offset3, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert)
      checkInt4(this, value2, offset3, 4, 2147483647, -2147483648);
    if (value2 < 0)
      value2 = 4294967295 + value2 + 1;
    this[offset3] = value2 >>> 24;
    this[offset3 + 1] = value2 >>> 16;
    this[offset3 + 2] = value2 >>> 8;
    this[offset3 + 3] = value2 & 255;
    return offset3 + 4;
  };
  function checkIEEE7544(buf, value2, offset3, ext, max3, min3) {
    if (offset3 + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset3 < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat4(buf, value2, offset3, littleEndian, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert) {
      checkIEEE7544(buf, value2, offset3, 4);
    }
    ieee754$1.write(buf, value2, offset3, littleEndian, 23, 4);
    return offset3 + 4;
  }
  Buffer5.prototype.writeFloatLE = function writeFloatLE4(value2, offset3, noAssert) {
    return writeFloat4(this, value2, offset3, true, noAssert);
  };
  Buffer5.prototype.writeFloatBE = function writeFloatBE4(value2, offset3, noAssert) {
    return writeFloat4(this, value2, offset3, false, noAssert);
  };
  function writeDouble4(buf, value2, offset3, littleEndian, noAssert) {
    value2 = +value2;
    offset3 = offset3 >>> 0;
    if (!noAssert) {
      checkIEEE7544(buf, value2, offset3, 8);
    }
    ieee754$1.write(buf, value2, offset3, littleEndian, 52, 8);
    return offset3 + 8;
  }
  Buffer5.prototype.writeDoubleLE = function writeDoubleLE4(value2, offset3, noAssert) {
    return writeDouble4(this, value2, offset3, true, noAssert);
  };
  Buffer5.prototype.writeDoubleBE = function writeDoubleBE4(value2, offset3, noAssert) {
    return writeDouble4(this, value2, offset3, false, noAssert);
  };
  Buffer5.prototype.copy = function copy6(target, targetStart, start3, end3) {
    if (!Buffer5.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start3)
      start3 = 0;
    if (!end3 && end3 !== 0)
      end3 = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end3 > 0 && end3 < start3)
      end3 = start3;
    if (end3 === start3)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start3 < 0 || start3 >= this.length)
      throw new RangeError("Index out of range");
    if (end3 < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end3 > this.length)
      end3 = this.length;
    if (target.length - targetStart < end3 - start3) {
      end3 = target.length - targetStart + start3;
    }
    var len = end3 - start3;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start3, end3);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start3, end3), targetStart);
    }
    return len;
  };
  Buffer5.prototype.fill = function fill5(val, start3, end3, encoding) {
    if (typeof val === "string") {
      if (typeof start3 === "string") {
        encoding = start3;
        start3 = 0;
        end3 = this.length;
      } else if (typeof end3 === "string") {
        encoding = end3;
        end3 = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer5.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        var code3 = val.charCodeAt(0);
        if (encoding === "utf8" && code3 < 128 || encoding === "latin1") {
          val = code3;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start3 < 0 || this.length < start3 || this.length < end3) {
      throw new RangeError("Out of range index");
    }
    if (end3 <= start3) {
      return this;
    }
    start3 = start3 >>> 0;
    end3 = end3 === void 0 ? this.length : end3 >>> 0;
    if (!val)
      val = 0;
    var i;
    if (typeof val === "number") {
      for (i = start3; i < end3; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = Buffer5.isBuffer(val) ? val : Buffer5.from(val, encoding);
      var len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end3 - start3; ++i) {
        this[i + start3] = bytes[i % len];
      }
    }
    return this;
  };
  var INVALID_BASE64_RE4 = /[^+/0-9A-Za-z-_]/g;
  function base64clean4(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE4, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes4(string, units) {
    units = units || Infinity;
    var codePoint;
    var length4 = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length4; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length4) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes4(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes4(str, units) {
    var c2, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes4(str) {
    return base64.toByteArray(base64clean4(str));
  }
  function blitBuffer4(src3, dst, offset3, length4) {
    for (var i = 0; i < length4; ++i) {
      if (i + offset3 >= dst.length || i >= src3.length)
        break;
      dst[i + offset3] = src3[i];
    }
    return i;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN5(obj) {
    return obj !== obj;
  }
  var hexSliceLookupTable = function() {
    var alphabet = "0123456789abcdef";
    var table = new Array(256);
    for (var i = 0; i < 16; ++i) {
      var i16 = i * 16;
      for (var j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j];
      }
    }
    return table;
  }();
})(buffer2);
var _nodeResolve_empty = {};
var _nodeResolve_empty$1 = Object.freeze({
  __proto__: null,
  "default": _nodeResolve_empty
});
var require$$4 = getAugmentedNamespace2(_nodeResolve_empty$1);
function ownKeys(object, enumerableOnly) {
  var keys5 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys5.push.apply(keys5, symbols);
  }
  return keys5;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty$2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$2(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  return Constructor;
}
var _require$4 = buffer2;
var Buffer$3 = _require$4.Buffer;
var _require2$2 = require$$4;
var inspect$2 = _require2$2.inspect;
var custom = inspect$2 && inspect$2.custom || "inspect";
function copyBuffer(src3, target, offset3) {
  Buffer$3.prototype.copy.call(src3, target, offset3);
}
var buffer_list = function() {
  function BufferList3() {
    _classCallCheck$3(this, BufferList3);
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  _createClass$1(BufferList3, [{
    key: "push",
    value: function push(v2) {
      var entry = {
        data: v2,
        next: null
      };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v2) {
      var entry = {
        data: v2,
        next: this.head
      };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s2) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s2 + p.data;
      }
      return ret;
    }
  }, {
    key: "concat",
    value: function concat8(n) {
      if (this.length === 0)
        return Buffer$3.alloc(0);
      var ret = Buffer$3.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    }
    // Consumes a specified amount of bytes or characters from the buffered data.
  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;
      if (n < this.head.data.length) {
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        ret = this.shift();
      } else {
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    }
    // Consumes a specified amount of characters from the buffered data.
  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c2 = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret += str;
        else
          ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c2;
            if (p.next)
              this.head = p.next;
            else
              this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c2;
      }
      this.length -= c2;
      return ret;
    }
    // Consumes a specified amount of bytes from the buffered data.
  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer$3.allocUnsafe(n);
      var p = this.head;
      var c2 = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c2;
            if (p.next)
              this.head = p.next;
            else
              this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c2;
      }
      this.length -= c2;
      return ret;
    }
    // Make sure the linked list only shows the minimal necessary information.
  }, {
    key: custom,
    value: function value2(_, options) {
      return inspect$2(this, _objectSpread$1({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);
  return BufferList3;
}();
function destroy(err2, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err2);
    } else if (err2) {
      if (!this._writableState) {
        browser$1$12.nextTick(emitErrorNT, this, err2);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        browser$1$12.nextTick(emitErrorNT, this, err2);
      }
    }
    return this;
  }
  if (this._readableState) {
    this._readableState.destroyed = true;
  }
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err2 || null, function(err3) {
    if (!cb && err3) {
      if (!_this._writableState) {
        browser$1$12.nextTick(emitErrorAndCloseNT, _this, err3);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        browser$1$12.nextTick(emitErrorAndCloseNT, _this, err3);
      } else {
        browser$1$12.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      browser$1$12.nextTick(emitCloseNT, _this);
      cb(err3);
    } else {
      browser$1$12.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self2, err2) {
  emitErrorNT(self2, err2);
  emitCloseNT(self2);
}
function emitCloseNT(self2) {
  if (self2._writableState && !self2._writableState.emitClose)
    return;
  if (self2._readableState && !self2._readableState.emitClose)
    return;
  self2.emit("close");
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self2, err2) {
  self2.emit("error", err2);
}
function errorOrDestroy$2(stream2, err2) {
  var rState = stream2._readableState;
  var wState = stream2._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy)
    stream2.destroy(err2);
  else
    stream2.emit("error", err2);
}
var destroy_1 = {
  destroy,
  undestroy,
  errorOrDestroy: errorOrDestroy$2
};
var errorsBrowser = {};
function _inheritsLoose2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var codes$1 = {};
function createErrorType$1(code3, message, Base2) {
  if (!Base2) {
    Base2 = Error;
  }
  function getMessage(arg1, arg2, arg3) {
    if (typeof message === "string") {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = function(_Base) {
    _inheritsLoose2(NodeError2, _Base);
    function NodeError2(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }
    return NodeError2;
  }(Base2);
  NodeError.prototype.name = Base2.name;
  NodeError.prototype.code = code3;
  codes$1[code3] = NodeError;
}
function oneOf$1(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function(i) {
      return String(i);
    });
    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
}
function startsWith$1(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}
function endsWith$2(str, search, this_len) {
  if (this_len === void 0 || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}
function includes$1(str, search, start3) {
  if (typeof start3 !== "number") {
    start3 = 0;
  }
  if (start3 + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start3) !== -1;
  }
}
createErrorType$1("ERR_INVALID_OPT_VALUE", function(name, value2) {
  return 'The value "' + value2 + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType$1("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
  var determiner;
  if (typeof expected === "string" && startsWith$1(expected, "not ")) {
    determiner = "must not be";
    expected = expected.replace(/^not /, "");
  } else {
    determiner = "must be";
  }
  var msg2;
  if (endsWith$2(name, " argument")) {
    msg2 = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf$1(expected, "type"));
  } else {
    var type = includes$1(name, ".") ? "property" : "argument";
    msg2 = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf$1(expected, "type"));
  }
  msg2 += ". Received type ".concat(typeof actual);
  return msg2;
}, TypeError);
createErrorType$1("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType$1("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
  return "The " + name + " method is not implemented";
});
createErrorType$1("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType$1("ERR_STREAM_DESTROYED", function(name) {
  return "Cannot call " + name + " after a stream was destroyed";
});
createErrorType$1("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType$1("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType$1("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType$1("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType$1("ERR_UNKNOWN_ENCODING", function(arg) {
  return "Unknown encoding: " + arg;
}, TypeError);
createErrorType$1("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser.codes = codes$1;
var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark$2(state2, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }
  return state2.objectMode ? 16 : 16 * 1024;
}
var state = {
  getHighWaterMark: getHighWaterMark$2
};
var inherits_browser2 = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser2.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  inherits_browser2.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function TempCtor2() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
var string_decoder = {};
var safeBuffer2 = { exports: {} };
(function(module, exports) {
  var buffer$1 = buffer2;
  var Buffer5 = buffer$1.Buffer;
  function copyProps(src3, dst) {
    for (var key in src3) {
      dst[key] = src3[key];
    }
  }
  if (Buffer5.from && Buffer5.alloc && Buffer5.allocUnsafe && Buffer5.allocUnsafeSlow) {
    module.exports = buffer$1;
  } else {
    copyProps(buffer$1, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length4) {
    return Buffer5(arg, encodingOrOffset, length4);
  }
  SafeBuffer.prototype = Object.create(Buffer5.prototype);
  copyProps(Buffer5, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length4) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer5(arg, encodingOrOffset, length4);
  };
  SafeBuffer.alloc = function(size, fill5, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer5(size);
    if (fill5 !== void 0) {
      if (typeof encoding === "string") {
        buf.fill(fill5, encoding);
      } else {
        buf.fill(fill5);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer5(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer$1.SlowBuffer(size);
  };
})(safeBuffer2, safeBuffer2.exports);
var Buffer$2 = safeBuffer2.exports.Buffer;
var isEncoding4 = Buffer$2.isEncoding || function(encoding) {
  encoding = "" + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function _normalizeEncoding2(enc) {
  if (!enc)
    return "utf8";
  var retried;
  while (true) {
    switch (enc) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return enc;
      default:
        if (retried)
          return;
        enc = ("" + enc).toLowerCase();
        retried = true;
    }
  }
}
function normalizeEncoding2(enc) {
  var nenc = _normalizeEncoding2(enc);
  if (typeof nenc !== "string" && (Buffer$2.isEncoding === isEncoding4 || !isEncoding4(enc)))
    throw new Error("Unknown encoding: " + enc);
  return nenc || enc;
}
string_decoder.StringDecoder = StringDecoder$1;
function StringDecoder$1(encoding) {
  this.encoding = normalizeEncoding2(encoding);
  var nb;
  switch (this.encoding) {
    case "utf16le":
      this.text = utf16Text2;
      this.end = utf16End2;
      nb = 4;
      break;
    case "utf8":
      this.fillLast = utf8FillLast2;
      nb = 4;
      break;
    case "base64":
      this.text = base64Text2;
      this.end = base64End2;
      nb = 3;
      break;
    default:
      this.write = simpleWrite2;
      this.end = simpleEnd2;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer$2.allocUnsafe(nb);
}
StringDecoder$1.prototype.write = function(buf) {
  if (buf.length === 0)
    return "";
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === void 0)
      return "";
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length)
    return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || "";
};
StringDecoder$1.prototype.end = utf8End2;
StringDecoder$1.prototype.text = utf8Text2;
StringDecoder$1.prototype.fillLast = function(buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};
function utf8CheckByte2(byte) {
  if (byte <= 127)
    return 0;
  else if (byte >> 5 === 6)
    return 2;
  else if (byte >> 4 === 14)
    return 3;
  else if (byte >> 3 === 30)
    return 4;
  return byte >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete2(self2, buf, i) {
  var j = buf.length - 1;
  if (j < i)
    return 0;
  var nb = utf8CheckByte2(buf[j]);
  if (nb >= 0) {
    if (nb > 0)
      self2.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2)
    return 0;
  nb = utf8CheckByte2(buf[j]);
  if (nb >= 0) {
    if (nb > 0)
      self2.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2)
    return 0;
  nb = utf8CheckByte2(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2)
        nb = 0;
      else
        self2.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}
function utf8CheckExtraBytes2(self2, buf, p) {
  if ((buf[0] & 192) !== 128) {
    self2.lastNeed = 0;
    return "�";
  }
  if (self2.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 192) !== 128) {
      self2.lastNeed = 1;
      return "�";
    }
    if (self2.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 192) !== 128) {
        self2.lastNeed = 2;
        return "�";
      }
    }
  }
}
function utf8FillLast2(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes2(this, buf);
  if (r !== void 0)
    return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}
function utf8Text2(buf, i) {
  var total = utf8CheckIncomplete2(this, buf, i);
  if (!this.lastNeed)
    return buf.toString("utf8", i);
  this.lastTotal = total;
  var end3 = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end3);
  return buf.toString("utf8", i, end3);
}
function utf8End2(buf) {
  var r = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed)
    return r + "�";
  return r;
}
function utf16Text2(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString("utf16le", i);
    if (r) {
      var c2 = r.charCodeAt(r.length - 1);
      if (c2 >= 55296 && c2 <= 56319) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString("utf16le", i, buf.length - 1);
}
function utf16End2(buf) {
  var r = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed) {
    var end3 = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString("utf16le", 0, end3);
  }
  return r;
}
function base64Text2(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0)
    return buf.toString("base64", i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString("base64", i, buf.length - n);
}
function base64End2(buf) {
  var r = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed)
    return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
  return r;
}
function simpleWrite2(buf) {
  return buf.toString(this.encoding);
}
function simpleEnd2(buf) {
  return buf && buf.length ? this.write(buf) : "";
}
var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$12(callback) {
  var called = false;
  return function() {
    if (called)
      return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop$12() {
}
function isRequest$1(stream2) {
  return stream2.setHeader && typeof stream2.abort === "function";
}
function eos$1(stream2, opts2, callback) {
  if (typeof opts2 === "function")
    return eos$1(stream2, null, opts2);
  if (!opts2)
    opts2 = {};
  callback = once$12(callback || noop$12);
  var readable = opts2.readable || opts2.readable !== false && stream2.readable;
  var writable = opts2.writable || opts2.writable !== false && stream2.writable;
  var onlegacyfinish = function onlegacyfinish2() {
    if (!stream2.writable)
      onfinish();
  };
  var writableEnded = stream2._writableState && stream2._writableState.finished;
  var onfinish = function onfinish2() {
    writable = false;
    writableEnded = true;
    if (!readable)
      callback.call(stream2);
  };
  var readableEnded = stream2._readableState && stream2._readableState.endEmitted;
  var onend3 = function onend4() {
    readable = false;
    readableEnded = true;
    if (!writable)
      callback.call(stream2);
  };
  var onerror = function onerror2(err2) {
    callback.call(stream2, err2);
  };
  var onclose = function onclose2() {
    var err2;
    if (readable && !readableEnded) {
      if (!stream2._readableState || !stream2._readableState.ended)
        err2 = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream2, err2);
    }
    if (writable && !writableEnded) {
      if (!stream2._writableState || !stream2._writableState.ended)
        err2 = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream2, err2);
    }
  };
  var onrequest = function onrequest2() {
    stream2.req.on("finish", onfinish);
  };
  if (isRequest$1(stream2)) {
    stream2.on("complete", onfinish);
    stream2.on("abort", onclose);
    if (stream2.req)
      onrequest();
    else
      stream2.on("request", onrequest);
  } else if (writable && !stream2._writableState) {
    stream2.on("end", onlegacyfinish);
    stream2.on("close", onlegacyfinish);
  }
  stream2.on("end", onend3);
  stream2.on("finish", onfinish);
  if (opts2.error !== false)
    stream2.on("error", onerror);
  stream2.on("close", onclose);
  return function() {
    stream2.removeListener("complete", onfinish);
    stream2.removeListener("abort", onclose);
    stream2.removeListener("request", onrequest);
    if (stream2.req)
      stream2.req.removeListener("finish", onfinish);
    stream2.removeListener("end", onlegacyfinish);
    stream2.removeListener("close", onlegacyfinish);
    stream2.removeListener("finish", onfinish);
    stream2.removeListener("end", onend3);
    stream2.removeListener("error", onerror);
    stream2.removeListener("close", onclose);
  };
}
var endOfStream = eos$1;
var _Object$setPrototypeO;
function _defineProperty$1(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
var finished = endOfStream;
var kLastResolve = Symbol("lastResolve");
var kLastReject = Symbol("lastReject");
var kError = Symbol("error");
var kEnded = Symbol("ended");
var kLastPromise = Symbol("lastPromise");
var kHandlePromise = Symbol("handlePromise");
var kStream = Symbol("stream");
function createIterResult(value2, done3) {
  return {
    value: value2,
    done: done3
  };
}
function readAndResolve(iter) {
  var resolve3 = iter[kLastResolve];
  if (resolve3 !== null) {
    var data2 = iter[kStream].read();
    if (data2 !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve3(createIterResult(data2, false));
    }
  }
}
function onReadable(iter) {
  browser$1$12.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
  return function(resolve3, reject) {
    lastPromise.then(function() {
      if (iter[kEnded]) {
        resolve3(createIterResult(void 0, true));
        return;
      }
      iter[kHandlePromise](resolve3, reject);
    }, reject);
  };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },
  next: function next() {
    var _this = this;
    var error = this[kError];
    if (error !== null) {
      return Promise.reject(error);
    }
    if (this[kEnded]) {
      return Promise.resolve(createIterResult(void 0, true));
    }
    if (this[kStream].destroyed) {
      return new Promise(function(resolve3, reject) {
        browser$1$12.nextTick(function() {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve3(createIterResult(void 0, true));
          }
        });
      });
    }
    var lastPromise = this[kLastPromise];
    var promise;
    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      var data2 = this[kStream].read();
      if (data2 !== null) {
        return Promise.resolve(createIterResult(data2, false));
      }
      promise = new Promise(this[kHandlePromise]);
    }
    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty$1(_Object$setPrototypeO, Symbol.asyncIterator, function() {
  return this;
}), _defineProperty$1(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;
  return new Promise(function(resolve3, reject) {
    _this2[kStream].destroy(null, function(err2) {
      if (err2) {
        reject(err2);
        return;
      }
      resolve3(createIterResult(void 0, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator$1 = function createReadableStreamAsyncIterator(stream2) {
  var _Object$create;
  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty$1(_Object$create, kStream, {
    value: stream2,
    writable: true
  }), _defineProperty$1(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty$1(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty$1(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty$1(_Object$create, kEnded, {
    value: stream2._readableState.endEmitted,
    writable: true
  }), _defineProperty$1(_Object$create, kHandlePromise, {
    value: function value2(resolve3, reject) {
      var data2 = iterator[kStream].read();
      if (data2) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve3(createIterResult(data2, false));
      } else {
        iterator[kLastResolve] = resolve3;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream2, function(err2) {
    if (err2 && err2.code !== "ERR_STREAM_PREMATURE_CLOSE") {
      var reject = iterator[kLastReject];
      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err2);
      }
      iterator[kError] = err2;
      return;
    }
    var resolve3 = iterator[kLastResolve];
    if (resolve3 !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve3(createIterResult(void 0, true));
    }
    iterator[kEnded] = true;
  });
  stream2.on("readable", onReadable.bind(null, iterator));
  return iterator;
};
var async_iterator = createReadableStreamAsyncIterator$1;
var fromBrowser = function fromBrowser2() {
  throw new Error("Readable.from is not available in the browser");
};
var Registry$4 = _registry;
Registry$4.Readable = Readable2;
Readable2.ReadableState = ReadableState2;
events2.exports.EventEmitter;
var EElistenerCount = function EElistenerCount2(emitter, type) {
  return emitter.listeners(type).length;
};
var Stream$1 = streamBrowser;
var Buffer$12 = buffer2.Buffer;
var OurUint8Array$1 = commonjsGlobal2.Uint8Array || function() {
};
function _uint8ArrayToBuffer$1(chunk) {
  return Buffer$12.from(chunk);
}
function _isUint8Array$1(obj) {
  return Buffer$12.isBuffer(obj) || obj instanceof OurUint8Array$1;
}
var debugUtil = require$$4;
var debug2;
if (debugUtil && debugUtil.debuglog) {
  debug2 = debugUtil.debuglog("stream");
} else {
  debug2 = function debug3() {
  };
}
var BufferList2 = buffer_list;
var destroyImpl$1 = destroy_1;
var _require$3 = state;
var getHighWaterMark$1 = _require$3.getHighWaterMark;
var _require$codes$4 = errorsBrowser.codes;
var ERR_INVALID_ARG_TYPE$3 = _require$codes$4.ERR_INVALID_ARG_TYPE;
var ERR_STREAM_PUSH_AFTER_EOF = _require$codes$4.ERR_STREAM_PUSH_AFTER_EOF;
var ERR_METHOD_NOT_IMPLEMENTED$2 = _require$codes$4.ERR_METHOD_NOT_IMPLEMENTED;
var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes$4.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
var StringDecoder2;
var createReadableStreamAsyncIterator2;
var from2;
inherits_browser2.exports(Readable2, Stream$1);
var errorOrDestroy$1 = destroyImpl$1.errorOrDestroy;
var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
function prependListener4(emitter, event, fn) {
  if (typeof emitter.prependListener === "function")
    return emitter.prependListener(event, fn);
  if (!emitter._events || !emitter._events[event])
    emitter.on(event, fn);
  else if (Array.isArray(emitter._events[event]))
    emitter._events[event].unshift(fn);
  else
    emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState2(options, stream2, isDuplex) {
  options = options || {};
  if (typeof isDuplex !== "boolean")
    isDuplex = stream2 instanceof Registry$4.Duplex;
  this.objectMode = !!options.objectMode;
  if (isDuplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;
  this.highWaterMark = getHighWaterMark$1(this, options, "readableHighWaterMark", isDuplex);
  this.buffer = new BufferList2();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;
  this.emitClose = options.emitClose !== false;
  this.autoDestroy = !!options.autoDestroy;
  this.destroyed = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder2)
      StringDecoder2 = string_decoder.StringDecoder;
    this.decoder = new StringDecoder2(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable2(options) {
  if (!(this instanceof Readable2))
    return new Readable2(options);
  var isDuplex = this instanceof Registry$4.Duplex;
  this._readableState = new ReadableState2(options, this, isDuplex);
  this.readable = true;
  if (options) {
    if (typeof options.read === "function")
      this._read = options.read;
    if (typeof options.destroy === "function")
      this._destroy = options.destroy;
  }
  Stream$1.call(this);
}
Object.defineProperty(Readable2.prototype, "destroyed", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get5() {
    if (this._readableState === void 0) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set3(value2) {
    if (!this._readableState) {
      return;
    }
    this._readableState.destroyed = value2;
  }
});
Readable2.prototype.destroy = destroyImpl$1.destroy;
Readable2.prototype._undestroy = destroyImpl$1.undestroy;
Readable2.prototype._destroy = function(err2, cb) {
  cb(err2);
};
Readable2.prototype.push = function(chunk, encoding) {
  var state2 = this._readableState;
  var skipChunkCheck;
  if (!state2.objectMode) {
    if (typeof chunk === "string") {
      encoding = encoding || state2.defaultEncoding;
      if (encoding !== state2.encoding) {
        chunk = Buffer$12.from(chunk, encoding);
        encoding = "";
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
};
Readable2.prototype.unshift = function(chunk) {
  return readableAddChunk2(this, chunk, null, true, false);
};
function readableAddChunk2(stream2, chunk, encoding, addToFront, skipChunkCheck) {
  debug2("readableAddChunk", chunk);
  var state2 = stream2._readableState;
  if (chunk === null) {
    state2.reading = false;
    onEofChunk2(stream2, state2);
  } else {
    var er2;
    if (!skipChunkCheck)
      er2 = chunkInvalid2(state2, chunk);
    if (er2) {
      errorOrDestroy$1(stream2, er2);
    } else if (state2.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer$12.prototype) {
        chunk = _uint8ArrayToBuffer$1(chunk);
      }
      if (addToFront) {
        if (state2.endEmitted)
          errorOrDestroy$1(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
        else
          addChunk(stream2, state2, chunk, true);
      } else if (state2.ended) {
        errorOrDestroy$1(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state2.destroyed) {
        return false;
      } else {
        state2.reading = false;
        if (state2.decoder && !encoding) {
          chunk = state2.decoder.write(chunk);
          if (state2.objectMode || chunk.length !== 0)
            addChunk(stream2, state2, chunk, false);
          else
            maybeReadMore2(stream2, state2);
        } else {
          addChunk(stream2, state2, chunk, false);
        }
      }
    } else if (!addToFront) {
      state2.reading = false;
      maybeReadMore2(stream2, state2);
    }
  }
  return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
}
function addChunk(stream2, state2, chunk, addToFront) {
  if (state2.flowing && state2.length === 0 && !state2.sync) {
    state2.awaitDrain = 0;
    stream2.emit("data", chunk);
  } else {
    state2.length += state2.objectMode ? 1 : chunk.length;
    if (addToFront)
      state2.buffer.unshift(chunk);
    else
      state2.buffer.push(chunk);
    if (state2.needReadable)
      emitReadable2(stream2);
  }
  maybeReadMore2(stream2, state2);
}
function chunkInvalid2(state2, chunk) {
  var er2;
  if (!_isUint8Array$1(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
    er2 = new ERR_INVALID_ARG_TYPE$3("chunk", ["string", "Buffer", "Uint8Array"], chunk);
  }
  return er2;
}
Readable2.prototype.isPaused = function() {
  return this._readableState.flowing === false;
};
Readable2.prototype.setEncoding = function(enc) {
  if (!StringDecoder2)
    StringDecoder2 = string_decoder.StringDecoder;
  var decoder = new StringDecoder2(enc);
  this._readableState.decoder = decoder;
  this._readableState.encoding = this._readableState.decoder.encoding;
  var p = this._readableState.buffer.head;
  var content = "";
  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }
  this._readableState.buffer.clear();
  if (content !== "")
    this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};
var MAX_HWM2 = 1073741824;
function computeNewHighWaterMark2(n) {
  if (n >= MAX_HWM2) {
    n = MAX_HWM2;
  } else {
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}
function howMuchToRead2(n, state2) {
  if (n <= 0 || state2.length === 0 && state2.ended)
    return 0;
  if (state2.objectMode)
    return 1;
  if (n !== n) {
    if (state2.flowing && state2.length)
      return state2.buffer.head.data.length;
    else
      return state2.length;
  }
  if (n > state2.highWaterMark)
    state2.highWaterMark = computeNewHighWaterMark2(n);
  if (n <= state2.length)
    return n;
  if (!state2.ended) {
    state2.needReadable = true;
    return 0;
  }
  return state2.length;
}
Readable2.prototype.read = function(n) {
  debug2("read", n);
  n = parseInt(n, 10);
  var state2 = this._readableState;
  var nOrig = n;
  if (n !== 0)
    state2.emittedReadable = false;
  if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
    debug2("read: emitReadable", state2.length, state2.ended);
    if (state2.length === 0 && state2.ended)
      endReadable2(this);
    else
      emitReadable2(this);
    return null;
  }
  n = howMuchToRead2(n, state2);
  if (n === 0 && state2.ended) {
    if (state2.length === 0)
      endReadable2(this);
    return null;
  }
  var doRead = state2.needReadable;
  debug2("need readable", doRead);
  if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
    doRead = true;
    debug2("length less than watermark", doRead);
  }
  if (state2.ended || state2.reading) {
    doRead = false;
    debug2("reading or ended", doRead);
  } else if (doRead) {
    debug2("do read");
    state2.reading = true;
    state2.sync = true;
    if (state2.length === 0)
      state2.needReadable = true;
    this._read(state2.highWaterMark);
    state2.sync = false;
    if (!state2.reading)
      n = howMuchToRead2(nOrig, state2);
  }
  var ret;
  if (n > 0)
    ret = fromList2(n, state2);
  else
    ret = null;
  if (ret === null) {
    state2.needReadable = state2.length <= state2.highWaterMark;
    n = 0;
  } else {
    state2.length -= n;
    state2.awaitDrain = 0;
  }
  if (state2.length === 0) {
    if (!state2.ended)
      state2.needReadable = true;
    if (nOrig !== n && state2.ended)
      endReadable2(this);
  }
  if (ret !== null)
    this.emit("data", ret);
  return ret;
};
function onEofChunk2(stream2, state2) {
  debug2("onEofChunk");
  if (state2.ended)
    return;
  if (state2.decoder) {
    var chunk = state2.decoder.end();
    if (chunk && chunk.length) {
      state2.buffer.push(chunk);
      state2.length += state2.objectMode ? 1 : chunk.length;
    }
  }
  state2.ended = true;
  if (state2.sync) {
    emitReadable2(stream2);
  } else {
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      state2.emittedReadable = true;
      emitReadable_2(stream2);
    }
  }
}
function emitReadable2(stream2) {
  var state2 = stream2._readableState;
  debug2("emitReadable", state2.needReadable, state2.emittedReadable);
  state2.needReadable = false;
  if (!state2.emittedReadable) {
    debug2("emitReadable", state2.flowing);
    state2.emittedReadable = true;
    browser$1$12.nextTick(emitReadable_2, stream2);
  }
}
function emitReadable_2(stream2) {
  var state2 = stream2._readableState;
  debug2("emitReadable_", state2.destroyed, state2.length, state2.ended);
  if (!state2.destroyed && (state2.length || state2.ended)) {
    stream2.emit("readable");
    state2.emittedReadable = false;
  }
  state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
  flow2(stream2);
}
function maybeReadMore2(stream2, state2) {
  if (!state2.readingMore) {
    state2.readingMore = true;
    browser$1$12.nextTick(maybeReadMore_2, stream2, state2);
  }
}
function maybeReadMore_2(stream2, state2) {
  while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
    var len = state2.length;
    debug2("maybeReadMore read 0");
    stream2.read(0);
    if (len === state2.length)
      break;
  }
  state2.readingMore = false;
}
Readable2.prototype._read = function(n) {
  errorOrDestroy$1(this, new ERR_METHOD_NOT_IMPLEMENTED$2("_read()"));
};
Readable2.prototype.pipe = function(dest, pipeOpts) {
  var src3 = this;
  var state2 = this._readableState;
  switch (state2.pipesCount) {
    case 0:
      state2.pipes = dest;
      break;
    case 1:
      state2.pipes = [state2.pipes, dest];
      break;
    default:
      state2.pipes.push(dest);
      break;
  }
  state2.pipesCount += 1;
  debug2("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== browser$1$12.stdout && dest !== browser$1$12.stderr;
  var endFn = doEnd ? onend3 : unpipe;
  if (state2.endEmitted)
    browser$1$12.nextTick(endFn);
  else
    src3.once("end", endFn);
  dest.on("unpipe", onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug2("onunpipe");
    if (readable === src3) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend3() {
    debug2("onend");
    dest.end();
  }
  var ondrain = pipeOnDrain2(src3);
  dest.on("drain", ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug2("cleanup");
    dest.removeListener("close", onclose);
    dest.removeListener("finish", onfinish);
    dest.removeListener("drain", ondrain);
    dest.removeListener("error", onerror);
    dest.removeListener("unpipe", onunpipe);
    src3.removeListener("end", onend3);
    src3.removeListener("end", unpipe);
    src3.removeListener("data", ondata);
    cleanedUp = true;
    if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }
  src3.on("data", ondata);
  function ondata(chunk) {
    debug2("ondata");
    var ret = dest.write(chunk);
    debug2("dest.write", ret);
    if (ret === false) {
      if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf5(state2.pipes, dest) !== -1) && !cleanedUp) {
        debug2("false write response, pause", state2.awaitDrain);
        state2.awaitDrain++;
      }
      src3.pause();
    }
  }
  function onerror(er2) {
    debug2("onerror", er2);
    unpipe();
    dest.removeListener("error", onerror);
    if (EElistenerCount(dest, "error") === 0)
      errorOrDestroy$1(dest, er2);
  }
  prependListener4(dest, "error", onerror);
  function onclose() {
    dest.removeListener("finish", onfinish);
    unpipe();
  }
  dest.once("close", onclose);
  function onfinish() {
    debug2("onfinish");
    dest.removeListener("close", onclose);
    unpipe();
  }
  dest.once("finish", onfinish);
  function unpipe() {
    debug2("unpipe");
    src3.unpipe(dest);
  }
  dest.emit("pipe", src3);
  if (!state2.flowing) {
    debug2("pipe resume");
    src3.resume();
  }
  return dest;
};
function pipeOnDrain2(src3) {
  return function pipeOnDrainFunctionResult() {
    var state2 = src3._readableState;
    debug2("pipeOnDrain", state2.awaitDrain);
    if (state2.awaitDrain)
      state2.awaitDrain--;
    if (state2.awaitDrain === 0 && EElistenerCount(src3, "data")) {
      state2.flowing = true;
      flow2(src3);
    }
  };
}
Readable2.prototype.unpipe = function(dest) {
  var state2 = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };
  if (state2.pipesCount === 0)
    return this;
  if (state2.pipesCount === 1) {
    if (dest && dest !== state2.pipes)
      return this;
    if (!dest)
      dest = state2.pipes;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    if (dest)
      dest.emit("unpipe", this, unpipeInfo);
    return this;
  }
  if (!dest) {
    var dests = state2.pipes;
    var len = state2.pipesCount;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    for (var i = 0; i < len; i++) {
      dests[i].emit("unpipe", this, {
        hasUnpiped: false
      });
    }
    return this;
  }
  var index3 = indexOf5(state2.pipes, dest);
  if (index3 === -1)
    return this;
  state2.pipes.splice(index3, 1);
  state2.pipesCount -= 1;
  if (state2.pipesCount === 1)
    state2.pipes = state2.pipes[0];
  dest.emit("unpipe", this, unpipeInfo);
  return this;
};
Readable2.prototype.on = function(ev, fn) {
  var res = Stream$1.prototype.on.call(this, ev, fn);
  var state2 = this._readableState;
  if (ev === "data") {
    state2.readableListening = this.listenerCount("readable") > 0;
    if (state2.flowing !== false)
      this.resume();
  } else if (ev === "readable") {
    if (!state2.endEmitted && !state2.readableListening) {
      state2.readableListening = state2.needReadable = true;
      state2.flowing = false;
      state2.emittedReadable = false;
      debug2("on readable", state2.length, state2.reading);
      if (state2.length) {
        emitReadable2(this);
      } else if (!state2.reading) {
        browser$1$12.nextTick(nReadingNextTick2, this);
      }
    }
  }
  return res;
};
Readable2.prototype.addListener = Readable2.prototype.on;
Readable2.prototype.removeListener = function(ev, fn) {
  var res = Stream$1.prototype.removeListener.call(this, ev, fn);
  if (ev === "readable") {
    browser$1$12.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable2.prototype.removeAllListeners = function(ev) {
  var res = Stream$1.prototype.removeAllListeners.apply(this, arguments);
  if (ev === "readable" || ev === void 0) {
    browser$1$12.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self2) {
  var state2 = self2._readableState;
  state2.readableListening = self2.listenerCount("readable") > 0;
  if (state2.resumeScheduled && !state2.paused) {
    state2.flowing = true;
  } else if (self2.listenerCount("data") > 0) {
    self2.resume();
  }
}
function nReadingNextTick2(self2) {
  debug2("readable nexttick read 0");
  self2.read(0);
}
Readable2.prototype.resume = function() {
  var state2 = this._readableState;
  if (!state2.flowing) {
    debug2("resume");
    state2.flowing = !state2.readableListening;
    resume2(this, state2);
  }
  state2.paused = false;
  return this;
};
function resume2(stream2, state2) {
  if (!state2.resumeScheduled) {
    state2.resumeScheduled = true;
    browser$1$12.nextTick(resume_2, stream2, state2);
  }
}
function resume_2(stream2, state2) {
  debug2("resume", state2.reading);
  if (!state2.reading) {
    stream2.read(0);
  }
  state2.resumeScheduled = false;
  stream2.emit("resume");
  flow2(stream2);
  if (state2.flowing && !state2.reading)
    stream2.read(0);
}
Readable2.prototype.pause = function() {
  debug2("call pause flowing=%j", this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug2("pause");
    this._readableState.flowing = false;
    this.emit("pause");
  }
  this._readableState.paused = true;
  return this;
};
function flow2(stream2) {
  var state2 = stream2._readableState;
  debug2("flow", state2.flowing);
  while (state2.flowing && stream2.read() !== null) {
  }
}
Readable2.prototype.wrap = function(stream2) {
  var _this = this;
  var state2 = this._readableState;
  var paused = false;
  stream2.on("end", function() {
    debug2("wrapped end");
    if (state2.decoder && !state2.ended) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length)
        _this.push(chunk);
    }
    _this.push(null);
  });
  stream2.on("data", function(chunk) {
    debug2("wrapped data");
    if (state2.decoder)
      chunk = state2.decoder.write(chunk);
    if (state2.objectMode && (chunk === null || chunk === void 0))
      return;
    else if (!state2.objectMode && (!chunk || !chunk.length))
      return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream2.pause();
    }
  });
  for (var i in stream2) {
    if (this[i] === void 0 && typeof stream2[i] === "function") {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream2[method].apply(stream2, arguments);
        };
      }(i);
    }
  }
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }
  this._read = function(n2) {
    debug2("wrapped _read", n2);
    if (paused) {
      paused = false;
      stream2.resume();
    }
  };
  return this;
};
if (typeof Symbol === "function") {
  Readable2.prototype[Symbol.asyncIterator] = function() {
    if (createReadableStreamAsyncIterator2 === void 0) {
      createReadableStreamAsyncIterator2 = async_iterator;
    }
    return createReadableStreamAsyncIterator2(this);
  };
}
Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get6() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable2.prototype, "readableBuffer", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get7() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable2.prototype, "readableFlowing", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get8() {
    return this._readableState.flowing;
  },
  set: function set4(state2) {
    if (this._readableState) {
      this._readableState.flowing = state2;
    }
  }
});
Readable2._fromList = fromList2;
Object.defineProperty(Readable2.prototype, "readableLength", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get9() {
    return this._readableState.length;
  }
});
function fromList2(n, state2) {
  if (state2.length === 0)
    return null;
  var ret;
  if (state2.objectMode)
    ret = state2.buffer.shift();
  else if (!n || n >= state2.length) {
    if (state2.decoder)
      ret = state2.buffer.join("");
    else if (state2.buffer.length === 1)
      ret = state2.buffer.first();
    else
      ret = state2.buffer.concat(state2.length);
    state2.buffer.clear();
  } else {
    ret = state2.buffer.consume(n, state2.decoder);
  }
  return ret;
}
function endReadable2(stream2) {
  var state2 = stream2._readableState;
  debug2("endReadable", state2.endEmitted);
  if (!state2.endEmitted) {
    state2.ended = true;
    browser$1$12.nextTick(endReadableNT2, state2, stream2);
  }
}
function endReadableNT2(state2, stream2) {
  debug2("endReadableNT", state2.endEmitted, state2.length);
  if (!state2.endEmitted && state2.length === 0) {
    state2.endEmitted = true;
    stream2.readable = false;
    stream2.emit("end");
    if (state2.autoDestroy) {
      var wState = stream2._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream2.destroy();
      }
    }
  }
}
if (typeof Symbol === "function") {
  Readable2.from = function(iterable, opts2) {
    if (from2 === void 0) {
      from2 = fromBrowser;
    }
    return from2(Readable2, iterable, opts2);
  };
}
function indexOf5(xs, x) {
  for (var i = 0, l2 = xs.length; i < l2; i++) {
    if (xs[i] === x)
      return i;
  }
  return -1;
}
var browser2 = deprecate;
function deprecate(fn, msg2) {
  if (config2("noDeprecation")) {
    return fn;
  }
  var warned3 = false;
  function deprecated() {
    if (!warned3) {
      if (config2("throwDeprecation")) {
        throw new Error(msg2);
      } else if (config2("traceDeprecation")) {
        console.trace(msg2);
      } else {
        console.warn(msg2);
      }
      warned3 = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function config2(name) {
  try {
    if (!commonjsGlobal2.localStorage)
      return false;
  } catch (_) {
    return false;
  }
  var val = commonjsGlobal2.localStorage[name];
  if (null == val)
    return false;
  return String(val).toLowerCase() === "true";
}
var Registry$3 = _registry;
Registry$3.Writable = Writable2;
function CorkedRequest2(state2) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function() {
    onCorkedFinish(_this, state2);
  };
}
Writable2.WritableState = WritableState2;
var internalUtil = {
  deprecate: browser2
};
var Stream2 = streamBrowser;
var Buffer3 = buffer2.Buffer;
var OurUint8Array = commonjsGlobal2.Uint8Array || function() {
};
function _uint8ArrayToBuffer(chunk) {
  return Buffer3.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = destroy_1;
var _require$2 = state;
var getHighWaterMark = _require$2.getHighWaterMark;
var _require$codes$3 = errorsBrowser.codes;
var ERR_INVALID_ARG_TYPE$2 = _require$codes$3.ERR_INVALID_ARG_TYPE;
var ERR_METHOD_NOT_IMPLEMENTED$1 = _require$codes$3.ERR_METHOD_NOT_IMPLEMENTED;
var ERR_MULTIPLE_CALLBACK$1 = _require$codes$3.ERR_MULTIPLE_CALLBACK;
var ERR_STREAM_CANNOT_PIPE = _require$codes$3.ERR_STREAM_CANNOT_PIPE;
var ERR_STREAM_DESTROYED$1 = _require$codes$3.ERR_STREAM_DESTROYED;
var ERR_STREAM_NULL_VALUES = _require$codes$3.ERR_STREAM_NULL_VALUES;
var ERR_STREAM_WRITE_AFTER_END = _require$codes$3.ERR_STREAM_WRITE_AFTER_END;
var ERR_UNKNOWN_ENCODING = _require$codes$3.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
inherits_browser2.exports(Writable2, Stream2);
function nop2() {
}
function WritableState2(options, stream2, isDuplex) {
  options = options || {};
  if (typeof isDuplex !== "boolean")
    isDuplex = stream2 instanceof Registry$3.Duplex;
  this.objectMode = !!options.objectMode;
  if (isDuplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;
  this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
  this.finalCalled = false;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  this.destroyed = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er2) {
    onwrite2(stream2, er2);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.emitClose = options.emitClose !== false;
  this.autoDestroy = !!options.autoDestroy;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest2(this);
}
WritableState2.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function() {
  try {
    Object.defineProperty(WritableState2.prototype, "buffer", {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
    });
  } catch (_) {
  }
})();
var realHasInstance;
if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable2, Symbol.hasInstance, {
    value: function value2(object) {
      if (realHasInstance.call(this, object))
        return true;
      if (this !== Writable2)
        return false;
      return object && object._writableState instanceof WritableState2;
    }
  });
} else {
  realHasInstance = function realHasInstance2(object) {
    return object instanceof this;
  };
}
function Writable2(options) {
  var isDuplex = this instanceof Registry$3.Duplex;
  if (!isDuplex && !realHasInstance.call(Writable2, this))
    return new Writable2(options);
  this._writableState = new WritableState2(options, this, isDuplex);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function")
      this._write = options.write;
    if (typeof options.writev === "function")
      this._writev = options.writev;
    if (typeof options.destroy === "function")
      this._destroy = options.destroy;
    if (typeof options.final === "function")
      this._final = options.final;
  }
  Stream2.call(this);
}
Writable2.prototype.pipe = function() {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd2(stream2, cb) {
  var er2 = new ERR_STREAM_WRITE_AFTER_END();
  errorOrDestroy(stream2, er2);
  browser$1$12.nextTick(cb, er2);
}
function validChunk2(stream2, state2, chunk, cb) {
  var er2;
  if (chunk === null) {
    er2 = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== "string" && !state2.objectMode) {
    er2 = new ERR_INVALID_ARG_TYPE$2("chunk", ["string", "Buffer"], chunk);
  }
  if (er2) {
    errorOrDestroy(stream2, er2);
    browser$1$12.nextTick(cb, er2);
    return false;
  }
  return true;
}
Writable2.prototype.write = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  var ret = false;
  var isBuf = !state2.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer3.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (isBuf)
    encoding = "buffer";
  else if (!encoding)
    encoding = state2.defaultEncoding;
  if (typeof cb !== "function")
    cb = nop2;
  if (state2.ending)
    writeAfterEnd2(this, cb);
  else if (isBuf || validChunk2(this, state2, chunk, cb)) {
    state2.pendingcb++;
    ret = writeOrBuffer2(this, state2, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable2.prototype.cork = function() {
  this._writableState.corked++;
};
Writable2.prototype.uncork = function() {
  var state2 = this._writableState;
  if (state2.corked) {
    state2.corked--;
    if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest)
      clearBuffer2(this, state2);
  }
};
Writable2.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
  if (typeof encoding === "string")
    encoding = encoding.toLowerCase();
  if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
    throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
Object.defineProperty(Writable2.prototype, "writableBuffer", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get10() {
    return this._writableState && this._writableState.getBuffer();
  }
});
function decodeChunk2(state2, chunk, encoding) {
  if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer3.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get11() {
    return this._writableState.highWaterMark;
  }
});
function writeOrBuffer2(stream2, state2, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk2(state2, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = "buffer";
      chunk = newChunk;
    }
  }
  var len = state2.objectMode ? 1 : chunk.length;
  state2.length += len;
  var ret = state2.length < state2.highWaterMark;
  if (!ret)
    state2.needDrain = true;
  if (state2.writing || state2.corked) {
    var last3 = state2.lastBufferedRequest;
    state2.lastBufferedRequest = {
      chunk,
      encoding,
      isBuf,
      callback: cb,
      next: null
    };
    if (last3) {
      last3.next = state2.lastBufferedRequest;
    } else {
      state2.bufferedRequest = state2.lastBufferedRequest;
    }
    state2.bufferedRequestCount += 1;
  } else {
    doWrite2(stream2, state2, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite2(stream2, state2, writev, len, chunk, encoding, cb) {
  state2.writelen = len;
  state2.writecb = cb;
  state2.writing = true;
  state2.sync = true;
  if (state2.destroyed)
    state2.onwrite(new ERR_STREAM_DESTROYED$1("write"));
  else if (writev)
    stream2._writev(chunk, state2.onwrite);
  else
    stream2._write(chunk, encoding, state2.onwrite);
  state2.sync = false;
}
function onwriteError2(stream2, state2, sync, er2, cb) {
  --state2.pendingcb;
  if (sync) {
    browser$1$12.nextTick(cb, er2);
    browser$1$12.nextTick(finishMaybe2, stream2, state2);
    stream2._writableState.errorEmitted = true;
    errorOrDestroy(stream2, er2);
  } else {
    cb(er2);
    stream2._writableState.errorEmitted = true;
    errorOrDestroy(stream2, er2);
    finishMaybe2(stream2, state2);
  }
}
function onwriteStateUpdate2(state2) {
  state2.writing = false;
  state2.writecb = null;
  state2.length -= state2.writelen;
  state2.writelen = 0;
}
function onwrite2(stream2, er2) {
  var state2 = stream2._writableState;
  var sync = state2.sync;
  var cb = state2.writecb;
  if (typeof cb !== "function")
    throw new ERR_MULTIPLE_CALLBACK$1();
  onwriteStateUpdate2(state2);
  if (er2)
    onwriteError2(stream2, state2, sync, er2, cb);
  else {
    var finished2 = needFinish2(state2) || stream2.destroyed;
    if (!finished2 && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
      clearBuffer2(stream2, state2);
    }
    if (sync) {
      browser$1$12.nextTick(afterWrite2, stream2, state2, finished2, cb);
    } else {
      afterWrite2(stream2, state2, finished2, cb);
    }
  }
}
function afterWrite2(stream2, state2, finished2, cb) {
  if (!finished2)
    onwriteDrain2(stream2, state2);
  state2.pendingcb--;
  cb();
  finishMaybe2(stream2, state2);
}
function onwriteDrain2(stream2, state2) {
  if (state2.length === 0 && state2.needDrain) {
    state2.needDrain = false;
    stream2.emit("drain");
  }
}
function clearBuffer2(stream2, state2) {
  state2.bufferProcessing = true;
  var entry = state2.bufferedRequest;
  if (stream2._writev && entry && entry.next) {
    var l2 = state2.bufferedRequestCount;
    var buffer3 = new Array(l2);
    var holder = state2.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer3[count] = entry;
      if (!entry.isBuf)
        allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer3.allBuffers = allBuffers;
    doWrite2(stream2, state2, true, state2.length, buffer3, "", holder.finish);
    state2.pendingcb++;
    state2.lastBufferedRequest = null;
    if (holder.next) {
      state2.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state2.corkedRequestsFree = new CorkedRequest2(state2);
    }
    state2.bufferedRequestCount = 0;
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state2.objectMode ? 1 : chunk.length;
      doWrite2(stream2, state2, false, len, chunk, encoding, cb);
      entry = entry.next;
      state2.bufferedRequestCount--;
      if (state2.writing) {
        break;
      }
    }
    if (entry === null)
      state2.lastBufferedRequest = null;
  }
  state2.bufferedRequest = entry;
  state2.bufferProcessing = false;
}
Writable2.prototype._write = function(chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED$1("_write()"));
};
Writable2.prototype._writev = null;
Writable2.prototype.end = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  if (typeof chunk === "function") {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== void 0)
    this.write(chunk, encoding);
  if (state2.corked) {
    state2.corked = 1;
    this.uncork();
  }
  if (!state2.ending)
    endWritable2(this, state2, cb);
  return this;
};
Object.defineProperty(Writable2.prototype, "writableLength", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get12() {
    return this._writableState.length;
  }
});
function needFinish2(state2) {
  return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
}
function callFinal(stream2, state2) {
  stream2._final(function(err2) {
    state2.pendingcb--;
    if (err2) {
      errorOrDestroy(stream2, err2);
    }
    state2.prefinished = true;
    stream2.emit("prefinish");
    finishMaybe2(stream2, state2);
  });
}
function prefinish$1(stream2, state2) {
  if (!state2.prefinished && !state2.finalCalled) {
    if (typeof stream2._final === "function" && !state2.destroyed) {
      state2.pendingcb++;
      state2.finalCalled = true;
      browser$1$12.nextTick(callFinal, stream2, state2);
    } else {
      state2.prefinished = true;
      stream2.emit("prefinish");
    }
  }
}
function finishMaybe2(stream2, state2) {
  var need = needFinish2(state2);
  if (need) {
    prefinish$1(stream2, state2);
    if (state2.pendingcb === 0) {
      state2.finished = true;
      stream2.emit("finish");
      if (state2.autoDestroy) {
        var rState = stream2._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream2.destroy();
        }
      }
    }
  }
  return need;
}
function endWritable2(stream2, state2, cb) {
  state2.ending = true;
  finishMaybe2(stream2, state2);
  if (cb) {
    if (state2.finished)
      browser$1$12.nextTick(cb);
    else
      stream2.once("finish", cb);
  }
  state2.ended = true;
  stream2.writable = false;
}
function onCorkedFinish(corkReq, state2, err2) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state2.pendingcb--;
    cb(err2);
    entry = entry.next;
  }
  state2.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable2.prototype, "destroyed", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get13() {
    if (this._writableState === void 0) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set5(value2) {
    if (!this._writableState) {
      return;
    }
    this._writableState.destroyed = value2;
  }
});
Writable2.prototype.destroy = destroyImpl.destroy;
Writable2.prototype._undestroy = destroyImpl.undestroy;
Writable2.prototype._destroy = function(err2, cb) {
  cb(err2);
};
var objectKeys$1 = Object.keys || function(obj) {
  var keys5 = [];
  for (var key in obj) {
    keys5.push(key);
  }
  return keys5;
};
var Registry$2 = _registry;
Registry$2.Duplex = Duplex2;
inherits_browser2.exports(Duplex2, Registry$2.Readable);
{
  keys$12 = objectKeys$1(Registry$2.Writable.prototype);
  for (v2 = 0; v2 < keys$12.length; v2++) {
    method = keys$12[v2];
    if (!Duplex2.prototype[method])
      Duplex2.prototype[method] = Registry$2.Writable.prototype[method];
  }
}
var keys$12;
var method;
var v2;
function Duplex2(options) {
  if (!(this instanceof Duplex2))
    return new Duplex2(options);
  Registry$2.Readable.call(this, options);
  Registry$2.Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false)
      this.readable = false;
    if (options.writable === false)
      this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once("end", onend2);
    }
  }
}
Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get14() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex2.prototype, "writableBuffer", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get15() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex2.prototype, "writableLength", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get16() {
    return this._writableState.length;
  }
});
function onend2() {
  if (this._writableState.ended)
    return;
  browser$1$12.nextTick(onEndNT2, this);
}
function onEndNT2(self2) {
  self2.end();
}
Object.defineProperty(Duplex2.prototype, "destroyed", {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get17() {
    if (this._readableState === void 0 || this._writableState === void 0) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set6(value2) {
    if (this._readableState === void 0 || this._writableState === void 0) {
      return;
    }
    this._readableState.destroyed = value2;
    this._writableState.destroyed = value2;
  }
});
var Registry$1 = _registry;
Registry$1.Transform = Transform$1;
var _require$codes$2 = errorsBrowser.codes;
var ERR_METHOD_NOT_IMPLEMENTED = _require$codes$2.ERR_METHOD_NOT_IMPLEMENTED;
var ERR_MULTIPLE_CALLBACK = _require$codes$2.ERR_MULTIPLE_CALLBACK;
var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$2.ERR_TRANSFORM_ALREADY_TRANSFORMING;
var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$2.ERR_TRANSFORM_WITH_LENGTH_0;
inherits_browser2.exports(Transform$1, Registry$1.Duplex);
function afterTransform2(er2, data2) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data2 != null)
    this.push(data2);
  cb(er2);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform$1(options) {
  if (!(this instanceof Transform$1))
    return new Transform$1(options);
  Registry$1.Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform2.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function")
      this._transform = options.transform;
    if (typeof options.flush === "function")
      this._flush = options.flush;
  }
  this.on("prefinish", prefinish2);
}
function prefinish2() {
  var _this = this;
  if (typeof this._flush === "function" && !this._readableState.destroyed) {
    this._flush(function(er2, data2) {
      done2(_this, er2, data2);
    });
  } else {
    done2(this, null, null);
  }
}
Transform$1.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Registry$1.Duplex.prototype.push.call(this, chunk, encoding);
};
Transform$1.prototype._transform = function(chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform$1.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};
Transform$1.prototype._read = function(n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    ts.needTransform = true;
  }
};
Transform$1.prototype._destroy = function(err2, cb) {
  Registry$1.Duplex.prototype._destroy.call(this, err2, function(err22) {
    cb(err22);
  });
};
function done2(stream2, er2, data2) {
  if (er2)
    return stream2.emit("error", er2);
  if (data2 != null)
    stream2.push(data2);
  if (stream2._writableState.length)
    throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream2._transformState.transforming)
    throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream2.push(null);
}
var Registry = _registry;
Registry.PassThrough = PassThrough2;
inherits_browser2.exports(PassThrough2, Registry.Transform);
function PassThrough2(options) {
  if (!(this instanceof PassThrough2))
    return new PassThrough2(options);
  Transform.call(this, options);
}
PassThrough2.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
var eos;
function once4(callback) {
  var called = false;
  return function() {
    if (called)
      return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes$1 = errorsBrowser.codes;
var ERR_MISSING_ARGS$1 = _require$codes$1.ERR_MISSING_ARGS;
var ERR_STREAM_DESTROYED = _require$codes$1.ERR_STREAM_DESTROYED;
function noop4(err2) {
  if (err2)
    throw err2;
}
function isRequest(stream2) {
  return stream2.setHeader && typeof stream2.abort === "function";
}
function destroyer(stream2, reading, writing, callback) {
  callback = once4(callback);
  var closed = false;
  stream2.on("close", function() {
    closed = true;
  });
  if (eos === void 0)
    eos = endOfStream;
  eos(stream2, {
    readable: reading,
    writable: writing
  }, function(err2) {
    if (err2)
      return callback(err2);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function(err2) {
    if (closed)
      return;
    if (destroyed)
      return;
    destroyed = true;
    if (isRequest(stream2))
      return stream2.abort();
    if (typeof stream2.destroy === "function")
      return stream2.destroy();
    callback(err2 || new ERR_STREAM_DESTROYED("pipe"));
  };
}
function call(fn) {
  fn();
}
function pipe(from4, to) {
  return from4.pipe(to);
}
function popCallback(streams) {
  if (!streams.length)
    return noop4;
  if (typeof streams[streams.length - 1] !== "function")
    return noop4;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0]))
    streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS$1("streams");
  }
  var error;
  var destroys = streams.map(function(stream2, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream2, reading, writing, function(err2) {
      if (!error)
        error = err2;
      if (err2)
        destroys.forEach(call);
      if (reading)
        return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
var pipeline_1 = pipeline;
(function(module, exports) {
  var Registry2 = _registry;
  exports = module.exports = Registry2.Readable;
  exports.Stream = Registry2.Readable;
  exports.Readable = Registry2.Readable;
  exports.Writable = Registry2.Writable;
  exports.Duplex = Registry2.Duplex;
  exports.Transform = Registry2.Transform;
  exports.PassThrough = Registry2.PassThrough;
  exports.finished = endOfStream;
  exports.pipeline = pipeline_1;
})(readableBrowser, readableBrowser.exports);
var stream = readableBrowser.exports;
var lib3 = {};
var binding2 = {};
var assert$22 = { exports: {} };
var errors2 = {};
var util$12 = {};
var types2 = {};
var shams$12 = function hasSymbols3() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var origSymbol2 = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham2 = shams$12;
var hasSymbols$32 = function hasNativeSymbols2() {
  if (typeof origSymbol2 !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol2("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham2();
};
var ERROR_MESSAGE2 = "Function.prototype.bind called on incompatible ";
var slice$12 = Array.prototype.slice;
var toStr$42 = Object.prototype.toString;
var funcType2 = "[object Function]";
var implementation$82 = function bind3(that) {
  var target = this;
  if (typeof target !== "function" || toStr$42.call(target) !== funcType2) {
    throw new TypeError(ERROR_MESSAGE2 + target);
  }
  var args = slice$12.call(arguments, 1);
  var bound;
  var binder = function binder2() {
    if (this instanceof bound) {
      var result = target.apply(this, args.concat(slice$12.call(arguments)));
      if (Object(result) === result) {
        return result;
      }
      return this;
    } else {
      return target.apply(that, args.concat(slice$12.call(arguments)));
    }
  };
  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs.push("$" + i);
  }
  bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};
var implementation$72 = implementation$82;
var functionBind2 = Function.prototype.bind || implementation$72;
var bind$12 = functionBind2;
var src2 = bind$12.call(Function.call, Object.prototype.hasOwnProperty);
var undefined$12;
var $SyntaxError2 = SyntaxError;
var $Function2 = Function;
var $TypeError2 = TypeError;
var getEvalledConstructor3 = function getEvalledConstructor4(expressionSyntax) {
  try {
    return $Function2('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e) {
  }
};
var $gOPD$12 = Object.getOwnPropertyDescriptor;
if ($gOPD$12) {
  try {
    $gOPD$12({}, "");
  } catch (e) {
    $gOPD$12 = null;
  }
}
var throwTypeError3 = function throwTypeError4() {
  throw new $TypeError2();
};
var ThrowTypeError2 = $gOPD$12 ? function() {
  try {
    arguments.callee;
    return throwTypeError3;
  } catch (calleeThrows) {
    try {
      return $gOPD$12(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError3;
    }
  }
}() : throwTypeError3;
var hasSymbols$22 = hasSymbols$32();
var getProto$12 = Object.getPrototypeOf || function(x) {
  return x.__proto__;
};
var needsEval2 = {};
var TypedArray2 = typeof Uint8Array === "undefined" ? undefined$12 : getProto$12(Uint8Array);
var INTRINSICS2 = {
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$12 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$12 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols$22 ? getProto$12([][Symbol.iterator]()) : undefined$12,
  "%AsyncFromSyncIteratorPrototype%": undefined$12,
  "%AsyncFunction%": needsEval2,
  "%AsyncGenerator%": needsEval2,
  "%AsyncGeneratorFunction%": needsEval2,
  "%AsyncIteratorPrototype%": needsEval2,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$12 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$12 : BigInt,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$12 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$12 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$12 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$12 : FinalizationRegistry,
  "%Function%": $Function2,
  "%GeneratorFunction%": needsEval2,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$12 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$12 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$12 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols$22 ? getProto$12(getProto$12([][Symbol.iterator]())) : undefined$12,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$12,
  "%Map%": typeof Map === "undefined" ? undefined$12 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols$22 ? undefined$12 : getProto$12((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$12 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$12 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$12 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$12 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols$22 ? undefined$12 : getProto$12((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$12 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols$22 ? getProto$12(""[Symbol.iterator]()) : undefined$12,
  "%Symbol%": hasSymbols$22 ? Symbol : undefined$12,
  "%SyntaxError%": $SyntaxError2,
  "%ThrowTypeError%": ThrowTypeError2,
  "%TypedArray%": TypedArray2,
  "%TypeError%": $TypeError2,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$12 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$12 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$12 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$12 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$12 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$12 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$12 : WeakSet
};
var doEval3 = function doEval4(name) {
  var value2;
  if (name === "%AsyncFunction%") {
    value2 = getEvalledConstructor3("async function () {}");
  } else if (name === "%GeneratorFunction%") {
    value2 = getEvalledConstructor3("function* () {}");
  } else if (name === "%AsyncGeneratorFunction%") {
    value2 = getEvalledConstructor3("async function* () {}");
  } else if (name === "%AsyncGenerator%") {
    var fn = doEval4("%AsyncGeneratorFunction%");
    if (fn) {
      value2 = fn.prototype;
    }
  } else if (name === "%AsyncIteratorPrototype%") {
    var gen = doEval4("%AsyncGenerator%");
    if (gen) {
      value2 = getProto$12(gen.prototype);
    }
  }
  INTRINSICS2[name] = value2;
  return value2;
};
var LEGACY_ALIASES2 = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind4 = functionBind2;
var hasOwn$12 = src2;
var $concat2 = bind4.call(Function.call, Array.prototype.concat);
var $spliceApply2 = bind4.call(Function.apply, Array.prototype.splice);
var $replace2 = bind4.call(Function.call, String.prototype.replace);
var $strSlice2 = bind4.call(Function.call, String.prototype.slice);
var rePropName2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar2 = /\\(\\)?/g;
var stringToPath3 = function stringToPath4(string) {
  var first = $strSlice2(string, 0, 1);
  var last3 = $strSlice2(string, -1);
  if (first === "%" && last3 !== "%") {
    throw new $SyntaxError2("invalid intrinsic syntax, expected closing `%`");
  } else if (last3 === "%" && first !== "%") {
    throw new $SyntaxError2("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace2(string, rePropName2, function(match, number2, quote, subString) {
    result[result.length] = quote ? $replace2(subString, reEscapeChar2, "$1") : number2 || match;
  });
  return result;
};
var getBaseIntrinsic3 = function getBaseIntrinsic4(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn$12(LEGACY_ALIASES2, intrinsicName)) {
    alias = LEGACY_ALIASES2[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$12(INTRINSICS2, intrinsicName)) {
    var value2 = INTRINSICS2[intrinsicName];
    if (value2 === needsEval2) {
      value2 = doEval3(intrinsicName);
    }
    if (typeof value2 === "undefined" && !allowMissing) {
      throw new $TypeError2("intrinsic " + name + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value: value2
    };
  }
  throw new $SyntaxError2("intrinsic " + name + " does not exist!");
};
var getIntrinsic2 = function GetIntrinsic3(name, allowMissing) {
  if (typeof name !== "string" || name.length === 0) {
    throw new $TypeError2("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError2('"allowMissing" argument must be a boolean');
  }
  var parts = stringToPath3(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic3("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value2 = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply2(parts, $concat2([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice2(part, 0, 1);
    var last3 = $strSlice2(part, -1);
    if ((first === '"' || first === "'" || first === "`" || last3 === '"' || last3 === "'" || last3 === "`") && first !== last3) {
      throw new $SyntaxError2("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$12(INTRINSICS2, intrinsicRealName)) {
      value2 = INTRINSICS2[intrinsicRealName];
    } else if (value2 != null) {
      if (!(part in value2)) {
        if (!allowMissing) {
          throw new $TypeError2("base intrinsic for " + name + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD$12 && i + 1 >= parts.length) {
        var desc = $gOPD$12(value2, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value2 = desc.get;
        } else {
          value2 = value2[part];
        }
      } else {
        isOwn = hasOwn$12(value2, part);
        value2 = value2[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS2[intrinsicRealName] = value2;
      }
    }
  }
  return value2;
};
var callBind$32 = { exports: {} };
(function(module) {
  var bind5 = functionBind2;
  var GetIntrinsic5 = getIntrinsic2;
  var $apply = GetIntrinsic5("%Function.prototype.apply%");
  var $call = GetIntrinsic5("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic5("%Reflect.apply%", true) || bind5.call($call, $apply);
  var $gOPD3 = GetIntrinsic5("%Object.getOwnPropertyDescriptor%", true);
  var $defineProperty = GetIntrinsic5("%Object.defineProperty%", true);
  var $max = GetIntrinsic5("%Math.max%");
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", {
        value: 1
      });
    } catch (e) {
      $defineProperty = null;
    }
  }
  module.exports = function callBind3(originalFunction) {
    var func = $reflectApply(bind5, $call, arguments);
    if ($gOPD3 && $defineProperty) {
      var desc = $gOPD3(func, "length");
      if (desc.configurable) {
        $defineProperty(func, "length", {
          value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
        });
      }
    }
    return func;
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind5, $apply, arguments);
  };
  if ($defineProperty) {
    $defineProperty(module.exports, "apply", {
      value: applyBind
    });
  } else {
    module.exports.apply = applyBind;
  }
})(callBind$32);
var GetIntrinsic$12 = getIntrinsic2;
var callBind$22 = callBind$32.exports;
var $indexOf$12 = callBind$22(GetIntrinsic$12("String.prototype.indexOf"));
var callBound$32 = function callBoundIntrinsic2(name, allowMissing) {
  var intrinsic = GetIntrinsic$12(name, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf$12(name, ".prototype.") > -1) {
    return callBind$22(intrinsic);
  }
  return intrinsic;
};
var hasToStringTag$32 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
var callBound$22 = callBound$32;
var $toString$22 = callBound$22("Object.prototype.toString");
var isStandardArguments2 = function isArguments5(value2) {
  if (hasToStringTag$32 && value2 && typeof value2 === "object" && Symbol.toStringTag in value2) {
    return false;
  }
  return $toString$22(value2) === "[object Arguments]";
};
var isLegacyArguments2 = function isArguments6(value2) {
  if (isStandardArguments2(value2)) {
    return true;
  }
  return value2 !== null && typeof value2 === "object" && typeof value2.length === "number" && value2.length >= 0 && $toString$22(value2) !== "[object Array]" && $toString$22(value2.callee) === "[object Function]";
};
var supportsStandardArguments2 = function() {
  return isStandardArguments2(arguments);
}();
isStandardArguments2.isLegacyArguments = isLegacyArguments2;
var isArguments$12 = supportsStandardArguments2 ? isStandardArguments2 : isLegacyArguments2;
var hasSymbols$12 = shams$12;
var shams2 = function hasToStringTagShams2() {
  return hasSymbols$12() && !!Symbol.toStringTag;
};
var toStr$32 = Object.prototype.toString;
var fnToStr2 = Function.prototype.toString;
var isFnRegex2 = /^\s*(?:function)?\*/;
var hasToStringTag$22 = shams2();
var getProto2 = Object.getPrototypeOf;
var getGeneratorFunc3 = function getGeneratorFunc4() {
  if (!hasToStringTag$22) {
    return false;
  }
  try {
    return Function("return function*() {}")();
  } catch (e) {
  }
};
var GeneratorFunction2;
var isGeneratorFunction3 = function isGeneratorFunction4(fn) {
  if (typeof fn !== "function") {
    return false;
  }
  if (isFnRegex2.test(fnToStr2.call(fn))) {
    return true;
  }
  if (!hasToStringTag$22) {
    var str = toStr$32.call(fn);
    return str === "[object GeneratorFunction]";
  }
  if (!getProto2) {
    return false;
  }
  if (typeof GeneratorFunction2 === "undefined") {
    var generatorFunc = getGeneratorFunc3();
    GeneratorFunction2 = generatorFunc ? getProto2(generatorFunc) : false;
  }
  return getProto2(fn) === GeneratorFunction2;
};
var hasOwn2 = Object.prototype.hasOwnProperty;
var toString4 = Object.prototype.toString;
var foreach2 = function forEach3(obj, fn, ctx) {
  if (toString4.call(fn) !== "[object Function]") {
    throw new TypeError("iterator must be a function");
  }
  var l2 = obj.length;
  if (l2 === +l2) {
    for (var i = 0; i < l2; i++) {
      fn.call(ctx, obj[i], i, obj);
    }
  } else {
    for (var k in obj) {
      if (hasOwn2.call(obj, k)) {
        fn.call(ctx, obj[k], k, obj);
      }
    }
  }
};
var possibleNames2 = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"];
var g$22 = typeof globalThis === "undefined" ? commonjsGlobal2 : globalThis;
var availableTypedArrays$22 = function availableTypedArrays3() {
  var out = [];
  for (var i = 0; i < possibleNames2.length; i++) {
    if (typeof g$22[possibleNames2[i]] === "function") {
      out[out.length] = possibleNames2[i];
    }
  }
  return out;
};
var GetIntrinsic4 = getIntrinsic2;
var $gOPD2 = GetIntrinsic4("%Object.getOwnPropertyDescriptor%", true);
if ($gOPD2) {
  try {
    $gOPD2([], "length");
  } catch (e) {
    $gOPD2 = null;
  }
}
var getOwnPropertyDescriptor2 = $gOPD2;
var forEach$12 = foreach2;
var availableTypedArrays$12 = availableTypedArrays$22;
var callBound$12 = callBound$32;
var $toString$12 = callBound$12("Object.prototype.toString");
var hasToStringTag$12 = shams2();
var g$12 = typeof globalThis === "undefined" ? commonjsGlobal2 : globalThis;
var typedArrays$12 = availableTypedArrays$12();
var $indexOf2 = callBound$12("Array.prototype.indexOf", true) || function indexOf6(array, value2) {
  for (var i = 0; i < array.length; i += 1) {
    if (array[i] === value2) {
      return i;
    }
  }
  return -1;
};
var $slice$12 = callBound$12("String.prototype.slice");
var toStrTags$12 = {};
var gOPD$12 = getOwnPropertyDescriptor2;
var getPrototypeOf$12 = Object.getPrototypeOf;
if (hasToStringTag$12 && gOPD$12 && getPrototypeOf$12) {
  forEach$12(typedArrays$12, function(typedArray) {
    var arr = new g$12[typedArray]();
    if (Symbol.toStringTag in arr) {
      var proto = getPrototypeOf$12(arr);
      var descriptor = gOPD$12(proto, Symbol.toStringTag);
      if (!descriptor) {
        var superProto = getPrototypeOf$12(proto);
        descriptor = gOPD$12(superProto, Symbol.toStringTag);
      }
      toStrTags$12[typedArray] = descriptor.get;
    }
  });
}
var tryTypedArrays$12 = function tryAllTypedArrays3(value2) {
  var anyTrue = false;
  forEach$12(toStrTags$12, function(getter, typedArray) {
    if (!anyTrue) {
      try {
        anyTrue = getter.call(value2) === typedArray;
      } catch (e) {
      }
    }
  });
  return anyTrue;
};
var isTypedArray$12 = function isTypedArray3(value2) {
  if (!value2 || typeof value2 !== "object") {
    return false;
  }
  if (!hasToStringTag$12 || !(Symbol.toStringTag in value2)) {
    var tag = $slice$12($toString$12(value2), 8, -1);
    return $indexOf2(typedArrays$12, tag) > -1;
  }
  if (!gOPD$12) {
    return false;
  }
  return tryTypedArrays$12(value2);
};
var forEach4 = foreach2;
var availableTypedArrays4 = availableTypedArrays$22;
var callBound2 = callBound$32;
var $toString2 = callBound2("Object.prototype.toString");
var hasToStringTag2 = shams2();
var g2 = typeof globalThis === "undefined" ? commonjsGlobal2 : globalThis;
var typedArrays2 = availableTypedArrays4();
var $slice2 = callBound2("String.prototype.slice");
var toStrTags2 = {};
var gOPD2 = getOwnPropertyDescriptor2;
var getPrototypeOf2 = Object.getPrototypeOf;
if (hasToStringTag2 && gOPD2 && getPrototypeOf2) {
  forEach4(typedArrays2, function(typedArray) {
    if (typeof g2[typedArray] === "function") {
      var arr = new g2[typedArray]();
      if (Symbol.toStringTag in arr) {
        var proto = getPrototypeOf2(arr);
        var descriptor = gOPD2(proto, Symbol.toStringTag);
        if (!descriptor) {
          var superProto = getPrototypeOf2(proto);
          descriptor = gOPD2(superProto, Symbol.toStringTag);
        }
        toStrTags2[typedArray] = descriptor.get;
      }
    }
  });
}
var tryTypedArrays2 = function tryAllTypedArrays4(value2) {
  var foundName = false;
  forEach4(toStrTags2, function(getter, typedArray) {
    if (!foundName) {
      try {
        var name = getter.call(value2);
        if (name === typedArray) {
          foundName = name;
        }
      } catch (e) {
      }
    }
  });
  return foundName;
};
var isTypedArray4 = isTypedArray$12;
var whichTypedArray3 = function whichTypedArray4(value2) {
  if (!isTypedArray4(value2)) {
    return false;
  }
  if (!hasToStringTag2 || !(Symbol.toStringTag in value2)) {
    return $slice2($toString2(value2), 8, -1);
  }
  return tryTypedArrays2(value2);
};
(function(exports) {
  var isArgumentsObject = isArguments$12;
  var isGeneratorFunction$1 = isGeneratorFunction3;
  var whichTypedArray$1 = whichTypedArray3;
  var isTypedArray5 = isTypedArray$12;
  function uncurryThis3(f) {
    return f.call.bind(f);
  }
  var BigIntSupported = typeof BigInt !== "undefined";
  var SymbolSupported = typeof Symbol !== "undefined";
  var ObjectToString = uncurryThis3(Object.prototype.toString);
  var numberValue = uncurryThis3(Number.prototype.valueOf);
  var stringValue = uncurryThis3(String.prototype.valueOf);
  var booleanValue = uncurryThis3(Boolean.prototype.valueOf);
  if (BigIntSupported) {
    var bigIntValue = uncurryThis3(BigInt.prototype.valueOf);
  }
  if (SymbolSupported) {
    var symbolValue = uncurryThis3(Symbol.prototype.valueOf);
  }
  function checkBoxedPrimitive(value2, prototypeValueOf) {
    if (typeof value2 !== "object") {
      return false;
    }
    try {
      prototypeValueOf(value2);
      return true;
    } catch (e) {
      return false;
    }
  }
  exports.isArgumentsObject = isArgumentsObject;
  exports.isGeneratorFunction = isGeneratorFunction$1;
  exports.isTypedArray = isTypedArray5;
  function isPromise3(input) {
    return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
  }
  exports.isPromise = isPromise3;
  function isArrayBufferView3(value2) {
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      return ArrayBuffer.isView(value2);
    }
    return isTypedArray5(value2) || isDataView(value2);
  }
  exports.isArrayBufferView = isArrayBufferView3;
  function isUint8Array(value2) {
    return whichTypedArray$1(value2) === "Uint8Array";
  }
  exports.isUint8Array = isUint8Array;
  function isUint8ClampedArray(value2) {
    return whichTypedArray$1(value2) === "Uint8ClampedArray";
  }
  exports.isUint8ClampedArray = isUint8ClampedArray;
  function isUint16Array(value2) {
    return whichTypedArray$1(value2) === "Uint16Array";
  }
  exports.isUint16Array = isUint16Array;
  function isUint32Array(value2) {
    return whichTypedArray$1(value2) === "Uint32Array";
  }
  exports.isUint32Array = isUint32Array;
  function isInt8Array(value2) {
    return whichTypedArray$1(value2) === "Int8Array";
  }
  exports.isInt8Array = isInt8Array;
  function isInt16Array(value2) {
    return whichTypedArray$1(value2) === "Int16Array";
  }
  exports.isInt16Array = isInt16Array;
  function isInt32Array(value2) {
    return whichTypedArray$1(value2) === "Int32Array";
  }
  exports.isInt32Array = isInt32Array;
  function isFloat32Array3(value2) {
    return whichTypedArray$1(value2) === "Float32Array";
  }
  exports.isFloat32Array = isFloat32Array3;
  function isFloat64Array3(value2) {
    return whichTypedArray$1(value2) === "Float64Array";
  }
  exports.isFloat64Array = isFloat64Array3;
  function isBigInt64Array(value2) {
    return whichTypedArray$1(value2) === "BigInt64Array";
  }
  exports.isBigInt64Array = isBigInt64Array;
  function isBigUint64Array(value2) {
    return whichTypedArray$1(value2) === "BigUint64Array";
  }
  exports.isBigUint64Array = isBigUint64Array;
  function isMapToString(value2) {
    return ObjectToString(value2) === "[object Map]";
  }
  isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
  function isMap3(value2) {
    if (typeof Map === "undefined") {
      return false;
    }
    return isMapToString.working ? isMapToString(value2) : value2 instanceof Map;
  }
  exports.isMap = isMap3;
  function isSetToString(value2) {
    return ObjectToString(value2) === "[object Set]";
  }
  isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
  function isSet3(value2) {
    if (typeof Set === "undefined") {
      return false;
    }
    return isSetToString.working ? isSetToString(value2) : value2 instanceof Set;
  }
  exports.isSet = isSet3;
  function isWeakMapToString(value2) {
    return ObjectToString(value2) === "[object WeakMap]";
  }
  isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
  function isWeakMap(value2) {
    if (typeof WeakMap === "undefined") {
      return false;
    }
    return isWeakMapToString.working ? isWeakMapToString(value2) : value2 instanceof WeakMap;
  }
  exports.isWeakMap = isWeakMap;
  function isWeakSetToString(value2) {
    return ObjectToString(value2) === "[object WeakSet]";
  }
  isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
  function isWeakSet(value2) {
    return isWeakSetToString(value2);
  }
  exports.isWeakSet = isWeakSet;
  function isArrayBufferToString(value2) {
    return ObjectToString(value2) === "[object ArrayBuffer]";
  }
  isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
  function isArrayBuffer(value2) {
    if (typeof ArrayBuffer === "undefined") {
      return false;
    }
    return isArrayBufferToString.working ? isArrayBufferToString(value2) : value2 instanceof ArrayBuffer;
  }
  exports.isArrayBuffer = isArrayBuffer;
  function isDataViewToString(value2) {
    return ObjectToString(value2) === "[object DataView]";
  }
  isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
  function isDataView(value2) {
    if (typeof DataView === "undefined") {
      return false;
    }
    return isDataViewToString.working ? isDataViewToString(value2) : value2 instanceof DataView;
  }
  exports.isDataView = isDataView;
  var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
  function isSharedArrayBufferToString(value2) {
    return ObjectToString(value2) === "[object SharedArrayBuffer]";
  }
  function isSharedArrayBuffer(value2) {
    if (typeof SharedArrayBufferCopy === "undefined") {
      return false;
    }
    if (typeof isSharedArrayBufferToString.working === "undefined") {
      isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
    }
    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value2) : value2 instanceof SharedArrayBufferCopy;
  }
  exports.isSharedArrayBuffer = isSharedArrayBuffer;
  function isAsyncFunction(value2) {
    return ObjectToString(value2) === "[object AsyncFunction]";
  }
  exports.isAsyncFunction = isAsyncFunction;
  function isMapIterator(value2) {
    return ObjectToString(value2) === "[object Map Iterator]";
  }
  exports.isMapIterator = isMapIterator;
  function isSetIterator(value2) {
    return ObjectToString(value2) === "[object Set Iterator]";
  }
  exports.isSetIterator = isSetIterator;
  function isGeneratorObject(value2) {
    return ObjectToString(value2) === "[object Generator]";
  }
  exports.isGeneratorObject = isGeneratorObject;
  function isWebAssemblyCompiledModule(value2) {
    return ObjectToString(value2) === "[object WebAssembly.Module]";
  }
  exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
  function isNumberObject3(value2) {
    return checkBoxedPrimitive(value2, numberValue);
  }
  exports.isNumberObject = isNumberObject3;
  function isStringObject3(value2) {
    return checkBoxedPrimitive(value2, stringValue);
  }
  exports.isStringObject = isStringObject3;
  function isBooleanObject3(value2) {
    return checkBoxedPrimitive(value2, booleanValue);
  }
  exports.isBooleanObject = isBooleanObject3;
  function isBigIntObject3(value2) {
    return BigIntSupported && checkBoxedPrimitive(value2, bigIntValue);
  }
  exports.isBigIntObject = isBigIntObject3;
  function isSymbolObject3(value2) {
    return SymbolSupported && checkBoxedPrimitive(value2, symbolValue);
  }
  exports.isSymbolObject = isSymbolObject3;
  function isBoxedPrimitive3(value2) {
    return isNumberObject3(value2) || isStringObject3(value2) || isBooleanObject3(value2) || isBigIntObject3(value2) || isSymbolObject3(value2);
  }
  exports.isBoxedPrimitive = isBoxedPrimitive3;
  function isAnyArrayBuffer3(value2) {
    return typeof Uint8Array !== "undefined" && (isArrayBuffer(value2) || isSharedArrayBuffer(value2));
  }
  exports.isAnyArrayBuffer = isAnyArrayBuffer3;
  ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
    Object.defineProperty(exports, method, {
      enumerable: false,
      value: function value2() {
        throw new Error(method + " is not supported in userland");
      }
    });
  });
})(types2);
var isBufferBrowser2 = function isBuffer4(arg) {
  return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
};
(function(exports) {
  var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
    var keys5 = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys5.length; i++) {
      descriptors[keys5[i]] = Object.getOwnPropertyDescriptor(obj, keys5[i]);
    }
    return descriptors;
  };
  var formatRegExp = /%[sdj%]/g;
  exports.format = function(f) {
    if (!isString3(f)) {
      var objects = [];
      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect6(arguments[i]));
      }
      return objects.join(" ");
    }
    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x2) {
      if (x2 === "%%")
        return "%";
      if (i >= len)
        return x2;
      switch (x2) {
        case "%s":
          return String(args[i++]);
        case "%d":
          return Number(args[i++]);
        case "%j":
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return "[Circular]";
          }
        default:
          return x2;
      }
    });
    for (var x = args[i]; i < len; x = args[++i]) {
      if (isNull(x) || !isObject(x)) {
        str += " " + x;
      } else {
        str += " " + inspect6(x);
      }
    }
    return str;
  };
  exports.deprecate = function(fn, msg2) {
    if (typeof browser$1$12 !== "undefined" && browser$1$12.noDeprecation === true) {
      return fn;
    }
    if (typeof browser$1$12 === "undefined") {
      return function() {
        return exports.deprecate(fn, msg2).apply(this, arguments);
      };
    }
    var warned3 = false;
    function deprecated() {
      if (!warned3) {
        {
          console.error(msg2);
        }
        warned3 = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  };
  var debugs = {};
  var debugEnvRegex = /^$/;
  if (browser$1$12.env.NODE_DEBUG) {
    var debugEnv = browser$1$12.env.NODE_DEBUG;
    debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
    debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
  }
  exports.debuglog = function(set7) {
    set7 = set7.toUpperCase();
    if (!debugs[set7]) {
      if (debugEnvRegex.test(set7)) {
        var pid = browser$1$12.pid;
        debugs[set7] = function() {
          var msg2 = exports.format.apply(exports, arguments);
          console.error("%s %d: %s", set7, pid, msg2);
        };
      } else {
        debugs[set7] = function() {
        };
      }
    }
    return debugs[set7];
  };
  function inspect6(obj, opts2) {
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    if (arguments.length >= 3)
      ctx.depth = arguments[2];
    if (arguments.length >= 4)
      ctx.colors = arguments[3];
    if (isBoolean(opts2)) {
      ctx.showHidden = opts2;
    } else if (opts2) {
      exports._extend(ctx, opts2);
    }
    if (isUndefined(ctx.showHidden))
      ctx.showHidden = false;
    if (isUndefined(ctx.depth))
      ctx.depth = 2;
    if (isUndefined(ctx.colors))
      ctx.colors = false;
    if (isUndefined(ctx.customInspect))
      ctx.customInspect = true;
    if (ctx.colors)
      ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }
  exports.inspect = inspect6;
  inspect6.colors = {
    "bold": [1, 22],
    "italic": [3, 23],
    "underline": [4, 24],
    "inverse": [7, 27],
    "white": [37, 39],
    "grey": [90, 39],
    "black": [30, 39],
    "blue": [34, 39],
    "cyan": [36, 39],
    "green": [32, 39],
    "magenta": [35, 39],
    "red": [31, 39],
    "yellow": [33, 39]
  };
  inspect6.styles = {
    "special": "cyan",
    "number": "yellow",
    "boolean": "yellow",
    "undefined": "grey",
    "null": "bold",
    "string": "green",
    "date": "magenta",
    // "name": intentionally not styling
    "regexp": "red"
  };
  function stylizeWithColor(str, styleType) {
    var style = inspect6.styles[styleType];
    if (style) {
      return "\x1B[" + inspect6.colors[style][0] + "m" + str + "\x1B[" + inspect6.colors[style][1] + "m";
    } else {
      return str;
    }
  }
  function stylizeNoColor(str, styleType) {
    return str;
  }
  function arrayToHash(array) {
    var hash = {};
    array.forEach(function(val, idx) {
      hash[val] = true;
    });
    return hash;
  }
  function formatValue(ctx, value2, recurseTimes) {
    if (ctx.customInspect && value2 && isFunction5(value2.inspect) && // Filter out the util module, it's inspect function is special
    value2.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
    !(value2.constructor && value2.constructor.prototype === value2)) {
      var ret = value2.inspect(recurseTimes, ctx);
      if (!isString3(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }
    var primitive = formatPrimitive(ctx, value2);
    if (primitive) {
      return primitive;
    }
    var keys5 = Object.keys(value2);
    var visibleKeys = arrayToHash(keys5);
    if (ctx.showHidden) {
      keys5 = Object.getOwnPropertyNames(value2);
    }
    if (isError(value2) && (keys5.indexOf("message") >= 0 || keys5.indexOf("description") >= 0)) {
      return formatError(value2);
    }
    if (keys5.length === 0) {
      if (isFunction5(value2)) {
        var name = value2.name ? ": " + value2.name : "";
        return ctx.stylize("[Function" + name + "]", "special");
      }
      if (isRegExp3(value2)) {
        return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
      }
      if (isDate3(value2)) {
        return ctx.stylize(Date.prototype.toString.call(value2), "date");
      }
      if (isError(value2)) {
        return formatError(value2);
      }
    }
    var base = "", array = false, braces = ["{", "}"];
    if (isArray4(value2)) {
      array = true;
      braces = ["[", "]"];
    }
    if (isFunction5(value2)) {
      var n = value2.name ? ": " + value2.name : "";
      base = " [Function" + n + "]";
    }
    if (isRegExp3(value2)) {
      base = " " + RegExp.prototype.toString.call(value2);
    }
    if (isDate3(value2)) {
      base = " " + Date.prototype.toUTCString.call(value2);
    }
    if (isError(value2)) {
      base = " " + formatError(value2);
    }
    if (keys5.length === 0 && (!array || value2.length == 0)) {
      return braces[0] + base + braces[1];
    }
    if (recurseTimes < 0) {
      if (isRegExp3(value2)) {
        return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
      } else {
        return ctx.stylize("[Object]", "special");
      }
    }
    ctx.seen.push(value2);
    var output;
    if (array) {
      output = formatArray(ctx, value2, recurseTimes, visibleKeys, keys5);
    } else {
      output = keys5.map(function(key) {
        return formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array);
      });
    }
    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
  }
  function formatPrimitive(ctx, value2) {
    if (isUndefined(value2))
      return ctx.stylize("undefined", "undefined");
    if (isString3(value2)) {
      var simple = "'" + JSON.stringify(value2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return ctx.stylize(simple, "string");
    }
    if (isNumber5(value2))
      return ctx.stylize("" + value2, "number");
    if (isBoolean(value2))
      return ctx.stylize("" + value2, "boolean");
    if (isNull(value2))
      return ctx.stylize("null", "null");
  }
  function formatError(value2) {
    return "[" + Error.prototype.toString.call(value2) + "]";
  }
  function formatArray(ctx, value2, recurseTimes, visibleKeys, keys5) {
    var output = [];
    for (var i = 0, l2 = value2.length; i < l2; ++i) {
      if (hasOwnProperty3(value2, String(i))) {
        output.push(formatProperty(ctx, value2, recurseTimes, visibleKeys, String(i), true));
      } else {
        output.push("");
      }
    }
    keys5.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value2, recurseTimes, visibleKeys, key, true));
      }
    });
    return output;
  }
  function formatProperty(ctx, value2, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value2, key) || {
      value: value2[key]
    };
    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize("[Getter/Setter]", "special");
      } else {
        str = ctx.stylize("[Getter]", "special");
      }
    } else {
      if (desc.set) {
        str = ctx.stylize("[Setter]", "special");
      }
    }
    if (!hasOwnProperty3(visibleKeys, key)) {
      name = "[" + key + "]";
    }
    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str.indexOf("\n") > -1) {
          if (array) {
            str = str.split("\n").map(function(line2) {
              return "  " + line2;
            }).join("\n").substr(2);
          } else {
            str = "\n" + str.split("\n").map(function(line2) {
              return "   " + line2;
            }).join("\n");
          }
        }
      } else {
        str = ctx.stylize("[Circular]", "special");
      }
    }
    if (isUndefined(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }
      name = JSON.stringify("" + key);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, "name");
      } else {
        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, "string");
      }
    }
    return name + ": " + str;
  }
  function reduceToSingleString(output, base, braces) {
    var length4 = output.reduce(function(prev, cur) {
      if (cur.indexOf("\n") >= 0)
        ;
      return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (length4 > 60) {
      return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
    }
    return braces[0] + base + " " + output.join(", ") + " " + braces[1];
  }
  exports.types = types2;
  function isArray4(ar2) {
    return Array.isArray(ar2);
  }
  exports.isArray = isArray4;
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  exports.isBoolean = isBoolean;
  function isNull(arg) {
    return arg === null;
  }
  exports.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports.isNullOrUndefined = isNullOrUndefined;
  function isNumber5(arg) {
    return typeof arg === "number";
  }
  exports.isNumber = isNumber5;
  function isString3(arg) {
    return typeof arg === "string";
  }
  exports.isString = isString3;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  exports.isSymbol = isSymbol;
  function isUndefined(arg) {
    return arg === void 0;
  }
  exports.isUndefined = isUndefined;
  function isRegExp3(re) {
    return isObject(re) && objectToString3(re) === "[object RegExp]";
  }
  exports.isRegExp = isRegExp3;
  exports.types.isRegExp = isRegExp3;
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports.isObject = isObject;
  function isDate3(d) {
    return isObject(d) && objectToString3(d) === "[object Date]";
  }
  exports.isDate = isDate3;
  exports.types.isDate = isDate3;
  function isError(e) {
    return isObject(e) && (objectToString3(e) === "[object Error]" || e instanceof Error);
  }
  exports.isError = isError;
  exports.types.isNativeError = isError;
  function isFunction5(arg) {
    return typeof arg === "function";
  }
  exports.isFunction = isFunction5;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
  }
  exports.isPrimitive = isPrimitive;
  exports.isBuffer = isBufferBrowser2;
  function objectToString3(o) {
    return Object.prototype.toString.call(o);
  }
  function pad3(n) {
    return n < 10 ? "0" + n.toString(10) : n.toString(10);
  }
  var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  function timestamp() {
    var d = /* @__PURE__ */ new Date();
    var time = [pad3(d.getHours()), pad3(d.getMinutes()), pad3(d.getSeconds())].join(":");
    return [d.getDate(), months[d.getMonth()], time].join(" ");
  }
  exports.log = function() {
    console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
  };
  exports.inherits = inherits_browser2.exports;
  exports._extend = function(origin, add3) {
    if (!add3 || !isObject(add3))
      return origin;
    var keys5 = Object.keys(add3);
    var i = keys5.length;
    while (i--) {
      origin[keys5[i]] = add3[keys5[i]];
    }
    return origin;
  };
  function hasOwnProperty3(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
  exports.promisify = function promisify(original) {
    if (typeof original !== "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
      var fn = original[kCustomPromisifiedSymbol];
      if (typeof fn !== "function") {
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      }
      Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return fn;
    }
    function fn() {
      var promiseResolve, promiseReject;
      var promise = new Promise(function(resolve3, reject) {
        promiseResolve = resolve3;
        promiseReject = reject;
      });
      var args = [];
      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }
      args.push(function(err2, value2) {
        if (err2) {
          promiseReject(err2);
        } else {
          promiseResolve(value2);
        }
      });
      try {
        original.apply(this, args);
      } catch (err2) {
        promiseReject(err2);
      }
      return promise;
    }
    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    if (kCustomPromisifiedSymbol)
      Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
  };
  exports.promisify.custom = kCustomPromisifiedSymbol;
  function callbackifyOnRejected(reason, cb) {
    if (!reason) {
      var newReason = new Error("Promise was rejected with a falsy value");
      newReason.reason = reason;
      reason = newReason;
    }
    return cb(reason);
  }
  function callbackify(original) {
    if (typeof original !== "function") {
      throw new TypeError('The "original" argument must be of type Function');
    }
    function callbackified() {
      var args = [];
      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }
      var maybeCb = args.pop();
      if (typeof maybeCb !== "function") {
        throw new TypeError("The last argument must be of type Function");
      }
      var self2 = this;
      var cb = function cb2() {
        return maybeCb.apply(self2, arguments);
      };
      original.apply(this, args).then(function(ret) {
        browser$1$12.nextTick(cb.bind(null, null, ret));
      }, function(rej) {
        browser$1$12.nextTick(callbackifyOnRejected.bind(null, rej, cb));
      });
    }
    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
    return callbackified;
  }
  exports.callbackify = callbackify;
})(util$12);
function _typeof$32(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$32 = function _typeof9(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$32 = function _typeof9(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$32(obj);
}
function _classCallCheck$22(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$12(self2, call2) {
  if (call2 && (_typeof$32(call2) === "object" || typeof call2 === "function")) {
    return call2;
  }
  return _assertThisInitialized$12(self2);
}
function _assertThisInitialized$12(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _getPrototypeOf$12(o) {
  _getPrototypeOf$12 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$12(o);
}
function _inherits$12(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf$12(subClass, superClass);
}
function _setPrototypeOf$12(o, p) {
  _setPrototypeOf$12 = Object.setPrototypeOf || function _setPrototypeOf4(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$12(o, p);
}
var codes2 = {};
var assert$12;
var util2;
function createErrorType2(code3, message, Base2) {
  if (!Base2) {
    Base2 = Error;
  }
  function getMessage(arg1, arg2, arg3) {
    if (typeof message === "string") {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = function(_Base) {
    _inherits$12(NodeError2, _Base);
    function NodeError2(arg1, arg2, arg3) {
      var _this;
      _classCallCheck$22(this, NodeError2);
      _this = _possibleConstructorReturn$12(this, _getPrototypeOf$12(NodeError2).call(this, getMessage(arg1, arg2, arg3)));
      _this.code = code3;
      return _this;
    }
    return NodeError2;
  }(Base2);
  codes2[code3] = NodeError;
}
function oneOf2(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function(i) {
      return String(i);
    });
    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
}
function startsWith2(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}
function endsWith$12(str, search, this_len) {
  if (this_len === void 0 || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}
function includes4(str, search, start3) {
  if (typeof start3 !== "number") {
    start3 = 0;
  }
  if (start3 + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start3) !== -1;
  }
}
createErrorType2("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
createErrorType2("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
  if (assert$12 === void 0)
    assert$12 = assert$22.exports;
  assert$12(typeof name === "string", "'name' must be a string");
  var determiner;
  if (typeof expected === "string" && startsWith2(expected, "not ")) {
    determiner = "must not be";
    expected = expected.replace(/^not /, "");
  } else {
    determiner = "must be";
  }
  var msg2;
  if (endsWith$12(name, " argument")) {
    msg2 = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf2(expected, "type"));
  } else {
    var type = includes4(name, ".") ? "property" : "argument";
    msg2 = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf2(expected, "type"));
  }
  msg2 += ". Received type ".concat(_typeof$32(actual));
  return msg2;
}, TypeError);
createErrorType2("ERR_INVALID_ARG_VALUE", function(name, value2) {
  var reason = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
  if (util2 === void 0)
    util2 = util$12;
  var inspected = util2.inspect(value2);
  if (inspected.length > 128) {
    inspected = "".concat(inspected.slice(0, 128), "...");
  }
  return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
}, TypeError);
createErrorType2("ERR_INVALID_RETURN_VALUE", function(input, name, value2) {
  var type;
  if (value2 && value2.constructor && value2.constructor.name) {
    type = "instance of ".concat(value2.constructor.name);
  } else {
    type = "type ".concat(_typeof$32(value2));
  }
  return "Expected ".concat(input, ' to be returned from the "').concat(name, '"') + " function but got ".concat(type, ".");
}, TypeError);
createErrorType2("ERR_MISSING_ARGS", function() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (assert$12 === void 0)
    assert$12 = assert$22.exports;
  assert$12(args.length > 0, "At least one arg needs to be specified");
  var msg2 = "The ";
  var len = args.length;
  args = args.map(function(a2) {
    return '"'.concat(a2, '"');
  });
  switch (len) {
    case 1:
      msg2 += "".concat(args[0], " argument");
      break;
    case 2:
      msg2 += "".concat(args[0], " and ").concat(args[1], " arguments");
      break;
    default:
      msg2 += args.slice(0, len - 1).join(", ");
      msg2 += ", and ".concat(args[len - 1], " arguments");
      break;
  }
  return "".concat(msg2, " must be specified");
}, TypeError);
errors2.codes = codes2;
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys2 = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys2.forEach(function(key) {
      _defineProperty3(target, key, source[key]);
    });
  }
  return target;
}
function _defineProperty3(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _classCallCheck$12(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties3(Constructor, staticProps);
  return Constructor;
}
function _possibleConstructorReturn2(self2, call2) {
  if (call2 && (_typeof$22(call2) === "object" || typeof call2 === "function")) {
    return call2;
  }
  return _assertThisInitialized3(self2);
}
function _assertThisInitialized3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _inherits2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf3(subClass, superClass);
}
function _wrapNativeSuper2(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper2 = function _wrapNativeSuper3(Class2) {
    if (Class2 === null || !_isNativeFunction2(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct2(Class2, arguments, _getPrototypeOf2(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf3(Wrapper, Class2);
  };
  return _wrapNativeSuper2(Class);
}
function isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct2(Parent, args, Class) {
  if (isNativeReflectConstruct2()) {
    _construct2 = Reflect.construct;
  } else {
    _construct2 = function _construct3(Parent2, args2, Class2) {
      var a2 = [null];
      a2.push.apply(a2, args2);
      var Constructor = Function.bind.apply(Parent2, a2);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf3(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct2.apply(null, arguments);
}
function _isNativeFunction2(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _setPrototypeOf3(o, p) {
  _setPrototypeOf3 = Object.setPrototypeOf || function _setPrototypeOf4(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf3(o, p);
}
function _getPrototypeOf2(o) {
  _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf2(o);
}
function _typeof$22(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$22 = function _typeof9(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$22 = function _typeof9(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$22(obj);
}
var _require$12 = util$12;
var inspect$12 = _require$12.inspect;
var _require2$12 = errors2;
var ERR_INVALID_ARG_TYPE$12 = _require2$12.codes.ERR_INVALID_ARG_TYPE;
function endsWith2(str, search, this_len) {
  if (this_len === void 0 || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
}
function repeat2(str, count) {
  count = Math.floor(count);
  if (str.length == 0 || count == 0)
    return "";
  var maxCount = str.length * count;
  count = Math.floor(Math.log(count) / Math.log(2));
  while (count) {
    str += str;
    count--;
  }
  str += str.substring(0, maxCount - str.length);
  return str;
}
var blue2 = "";
var green2 = "";
var red2 = "";
var white2 = "";
var kReadableOperator2 = {
  deepStrictEqual: "Expected values to be strictly deep-equal:",
  strictEqual: "Expected values to be strictly equal:",
  strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
  deepEqual: "Expected values to be loosely deep-equal:",
  equal: "Expected values to be loosely equal:",
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:',
  notIdentical: "Values identical but not reference-equal:"
};
var kMaxShortLength2 = 10;
function copyError2(source) {
  var keys5 = Object.keys(source);
  var target = Object.create(Object.getPrototypeOf(source));
  keys5.forEach(function(key) {
    target[key] = source[key];
  });
  Object.defineProperty(target, "message", {
    value: source.message
  });
  return target;
}
function inspectValue2(val) {
  return inspect$12(val, {
    compact: false,
    customInspect: false,
    depth: 1e3,
    maxArrayLength: Infinity,
    // Assert compares only enumerable properties (with a few exceptions).
    showHidden: false,
    // Having a long line as error is better than wrapping the line for
    // comparison for now.
    // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
    // have meta information about the inspected properties (i.e., know where
    // in what line the property starts and ends).
    breakLength: Infinity,
    // Assert does not detect proxies currently.
    showProxy: false,
    sorted: true,
    // Inspect getters as we also check them when comparing entries.
    getters: true
  });
}
function createErrDiff2(actual, expected, operator) {
  var other = "";
  var res = "";
  var lastPos = 0;
  var end3 = "";
  var skipped = false;
  var actualInspected = inspectValue2(actual);
  var actualLines = actualInspected.split("\n");
  var expectedLines = inspectValue2(expected).split("\n");
  var i = 0;
  var indicator = "";
  if (operator === "strictEqual" && _typeof$22(actual) === "object" && _typeof$22(expected) === "object" && actual !== null && expected !== null) {
    operator = "strictEqualObject";
  }
  if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
    var inputLength = actualLines[0].length + expectedLines[0].length;
    if (inputLength <= kMaxShortLength2) {
      if ((_typeof$22(actual) !== "object" || actual === null) && (_typeof$22(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
        return "".concat(kReadableOperator2[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
      }
    } else if (operator !== "strictEqualObject") {
      var maxLength = 80;
      if (inputLength < maxLength) {
        while (actualLines[0][i] === expectedLines[0][i]) {
          i++;
        }
        if (i > 2) {
          indicator = "\n  ".concat(repeat2(" ", i), "^");
          i = 0;
        }
      }
    }
  }
  var a2 = actualLines[actualLines.length - 1];
  var b = expectedLines[expectedLines.length - 1];
  while (a2 === b) {
    if (i++ < 2) {
      end3 = "\n  ".concat(a2).concat(end3);
    } else {
      other = a2;
    }
    actualLines.pop();
    expectedLines.pop();
    if (actualLines.length === 0 || expectedLines.length === 0)
      break;
    a2 = actualLines[actualLines.length - 1];
    b = expectedLines[expectedLines.length - 1];
  }
  var maxLines = Math.max(actualLines.length, expectedLines.length);
  if (maxLines === 0) {
    var _actualLines = actualInspected.split("\n");
    if (_actualLines.length > 30) {
      _actualLines[26] = "".concat(blue2, "...").concat(white2);
      while (_actualLines.length > 27) {
        _actualLines.pop();
      }
    }
    return "".concat(kReadableOperator2.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
  }
  if (i > 3) {
    end3 = "\n".concat(blue2, "...").concat(white2).concat(end3);
    skipped = true;
  }
  if (other !== "") {
    end3 = "\n  ".concat(other).concat(end3);
    other = "";
  }
  var printedLines = 0;
  var msg2 = kReadableOperator2[operator] + "\n".concat(green2, "+ actual").concat(white2, " ").concat(red2, "- expected").concat(white2);
  var skippedMsg = " ".concat(blue2, "...").concat(white2, " Lines skipped");
  for (i = 0; i < maxLines; i++) {
    var cur = i - lastPos;
    if (actualLines.length < i + 1) {
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue2, "...").concat(white2);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(expectedLines[i - 2]);
          printedLines++;
        }
        res += "\n  ".concat(expectedLines[i - 1]);
        printedLines++;
      }
      lastPos = i;
      other += "\n".concat(red2, "-").concat(white2, " ").concat(expectedLines[i]);
      printedLines++;
    } else if (expectedLines.length < i + 1) {
      if (cur > 1 && i > 2) {
        if (cur > 4) {
          res += "\n".concat(blue2, "...").concat(white2);
          skipped = true;
        } else if (cur > 3) {
          res += "\n  ".concat(actualLines[i - 2]);
          printedLines++;
        }
        res += "\n  ".concat(actualLines[i - 1]);
        printedLines++;
      }
      lastPos = i;
      res += "\n".concat(green2, "+").concat(white2, " ").concat(actualLines[i]);
      printedLines++;
    } else {
      var expectedLine = expectedLines[i];
      var actualLine = actualLines[i];
      var divergingLines = actualLine !== expectedLine && (!endsWith2(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
      if (divergingLines && endsWith2(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
        divergingLines = false;
        actualLine += ",";
      }
      if (divergingLines) {
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += "\n".concat(blue2, "...").concat(white2);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(actualLines[i - 2]);
            printedLines++;
          }
          res += "\n  ".concat(actualLines[i - 1]);
          printedLines++;
        }
        lastPos = i;
        res += "\n".concat(green2, "+").concat(white2, " ").concat(actualLine);
        other += "\n".concat(red2, "-").concat(white2, " ").concat(expectedLine);
        printedLines += 2;
      } else {
        res += other;
        other = "";
        if (cur === 1 || i === 0) {
          res += "\n  ".concat(actualLine);
          printedLines++;
        }
      }
    }
    if (printedLines > 20 && i < maxLines - 2) {
      return "".concat(msg2).concat(skippedMsg, "\n").concat(res, "\n").concat(blue2, "...").concat(white2).concat(other, "\n") + "".concat(blue2, "...").concat(white2);
    }
  }
  return "".concat(msg2).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end3).concat(indicator);
}
var AssertionError$12 = function(_Error) {
  _inherits2(AssertionError3, _Error);
  function AssertionError3(options) {
    var _this;
    _classCallCheck$12(this, AssertionError3);
    if (_typeof$22(options) !== "object" || options === null) {
      throw new ERR_INVALID_ARG_TYPE$12("options", "Object", options);
    }
    var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
    var actual = options.actual, expected = options.expected;
    var limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    if (message != null) {
      _this = _possibleConstructorReturn2(this, _getPrototypeOf2(AssertionError3).call(this, String(message)));
    } else {
      if (_typeof$22(actual) === "object" && actual !== null && _typeof$22(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
        actual = copyError2(actual);
        expected = copyError2(expected);
      }
      if (operator === "deepStrictEqual" || operator === "strictEqual") {
        _this = _possibleConstructorReturn2(this, _getPrototypeOf2(AssertionError3).call(this, createErrDiff2(actual, expected, operator)));
      } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
        var base = kReadableOperator2[operator];
        var res = inspectValue2(actual).split("\n");
        if (operator === "notStrictEqual" && _typeof$22(actual) === "object" && actual !== null) {
          base = kReadableOperator2.notStrictEqualObject;
        }
        if (res.length > 30) {
          res[26] = "".concat(blue2, "...").concat(white2);
          while (res.length > 27) {
            res.pop();
          }
        }
        if (res.length === 1) {
          _this = _possibleConstructorReturn2(this, _getPrototypeOf2(AssertionError3).call(this, "".concat(base, " ").concat(res[0])));
        } else {
          _this = _possibleConstructorReturn2(this, _getPrototypeOf2(AssertionError3).call(this, "".concat(base, "\n\n").concat(res.join("\n"), "\n")));
        }
      } else {
        var _res = inspectValue2(actual);
        var other = "";
        var knownOperators = kReadableOperator2[operator];
        if (operator === "notDeepEqual" || operator === "notEqual") {
          _res = "".concat(kReadableOperator2[operator], "\n\n").concat(_res);
          if (_res.length > 1024) {
            _res = "".concat(_res.slice(0, 1021), "...");
          }
        } else {
          other = "".concat(inspectValue2(expected));
          if (_res.length > 512) {
            _res = "".concat(_res.slice(0, 509), "...");
          }
          if (other.length > 512) {
            other = "".concat(other.slice(0, 509), "...");
          }
          if (operator === "deepEqual" || operator === "equal") {
            _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
          } else {
            other = " ".concat(operator, " ").concat(other);
          }
        }
        _this = _possibleConstructorReturn2(this, _getPrototypeOf2(AssertionError3).call(this, "".concat(_res).concat(other)));
      }
    }
    Error.stackTraceLimit = limit;
    _this.generatedMessage = !message;
    Object.defineProperty(_assertThisInitialized3(_this), "name", {
      value: "AssertionError [ERR_ASSERTION]",
      enumerable: false,
      writable: true,
      configurable: true
    });
    _this.code = "ERR_ASSERTION";
    _this.actual = actual;
    _this.expected = expected;
    _this.operator = operator;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(_assertThisInitialized3(_this), stackStartFn);
    }
    _this.stack;
    _this.name = "AssertionError";
    return _possibleConstructorReturn2(_this);
  }
  _createClass3(AssertionError3, [{
    key: "toString",
    value: function toString7() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    }
  }, {
    key: inspect$12.custom,
    value: function value2(recurseTimes, ctx) {
      return inspect$12(this, _objectSpread2({}, ctx, {
        customInspect: false,
        depth: 0
      }));
    }
  }]);
  return AssertionError3;
}(_wrapNativeSuper2(Error));
var assertion_error2 = AssertionError$12;
function assign2(target, firstSource) {
  if (target === void 0 || target === null) {
    throw new TypeError("Cannot convert first argument to object");
  }
  var to = Object(target);
  for (var i = 1; i < arguments.length; i++) {
    var nextSource = arguments[i];
    if (nextSource === void 0 || nextSource === null) {
      continue;
    }
    var keysArray = Object.keys(Object(nextSource));
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
      var nextKey = keysArray[nextIndex];
      var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
      if (desc !== void 0 && desc.enumerable) {
        to[nextKey] = nextSource[nextKey];
      }
    }
  }
  return to;
}
function polyfill$42() {
  if (!Object.assign) {
    Object.defineProperty(Object, "assign", {
      enumerable: false,
      configurable: true,
      writable: true,
      value: assign2
    });
  }
}
var es6ObjectAssign2 = {
  assign: assign2,
  polyfill: polyfill$42
};
var toStr$22 = Object.prototype.toString;
var isArguments7 = function isArguments8(value2) {
  var str = toStr$22.call(value2);
  var isArgs3 = str === "[object Arguments]";
  if (!isArgs3) {
    isArgs3 = str !== "[object Array]" && value2 !== null && typeof value2 === "object" && typeof value2.length === "number" && value2.length >= 0 && toStr$22.call(value2.callee) === "[object Function]";
  }
  return isArgs3;
};
var keysShim$12;
if (!Object.keys) {
  has = Object.prototype.hasOwnProperty;
  toStr$1 = Object.prototype.toString;
  isArgs$1 = isArguments7;
  isEnumerable = Object.prototype.propertyIsEnumerable;
  hasDontEnumBug = !isEnumerable.call({
    toString: null
  }, "toString");
  hasProtoEnumBug = isEnumerable.call(function() {
  }, "prototype");
  dontEnums = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"];
  equalsConstructorPrototype = function equalsConstructorPrototype2(o) {
    var ctor = o.constructor;
    return ctor && ctor.prototype === o;
  };
  excludedKeys = {
    $applicationCache: true,
    $console: true,
    $external: true,
    $frame: true,
    $frameElement: true,
    $frames: true,
    $innerHeight: true,
    $innerWidth: true,
    $onmozfullscreenchange: true,
    $onmozfullscreenerror: true,
    $outerHeight: true,
    $outerWidth: true,
    $pageXOffset: true,
    $pageYOffset: true,
    $parent: true,
    $scrollLeft: true,
    $scrollTop: true,
    $scrollX: true,
    $scrollY: true,
    $self: true,
    $webkitIndexedDB: true,
    $webkitStorageInfo: true,
    $window: true
  };
  hasAutomationEqualityBug = function() {
    if (typeof window === "undefined") {
      return false;
    }
    for (var k in window) {
      try {
        if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
          try {
            equalsConstructorPrototype(window[k]);
          } catch (e) {
            return true;
          }
        }
      } catch (e) {
        return true;
      }
    }
    return false;
  }();
  equalsConstructorPrototypeIfNotBuggy = function equalsConstructorPrototypeIfNotBuggy2(o) {
    if (typeof window === "undefined" || !hasAutomationEqualityBug) {
      return equalsConstructorPrototype(o);
    }
    try {
      return equalsConstructorPrototype(o);
    } catch (e) {
      return false;
    }
  };
  keysShim$12 = function keys5(object) {
    var isObject = object !== null && typeof object === "object";
    var isFunction5 = toStr$1.call(object) === "[object Function]";
    var isArguments9 = isArgs$1(object);
    var isString3 = isObject && toStr$1.call(object) === "[object String]";
    var theKeys = [];
    if (!isObject && !isFunction5 && !isArguments9) {
      throw new TypeError("Object.keys called on a non-object");
    }
    var skipProto = hasProtoEnumBug && isFunction5;
    if (isString3 && object.length > 0 && !has.call(object, 0)) {
      for (var i = 0; i < object.length; ++i) {
        theKeys.push(String(i));
      }
    }
    if (isArguments9 && object.length > 0) {
      for (var j = 0; j < object.length; ++j) {
        theKeys.push(String(j));
      }
    } else {
      for (var name in object) {
        if (!(skipProto && name === "prototype") && has.call(object, name)) {
          theKeys.push(String(name));
        }
      }
    }
    if (hasDontEnumBug) {
      var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
      for (var k = 0; k < dontEnums.length; ++k) {
        if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
          theKeys.push(dontEnums[k]);
        }
      }
    }
    return theKeys;
  };
}
var has;
var toStr$1;
var isArgs$1;
var isEnumerable;
var hasDontEnumBug;
var hasProtoEnumBug;
var dontEnums;
var equalsConstructorPrototype;
var excludedKeys;
var hasAutomationEqualityBug;
var equalsConstructorPrototypeIfNotBuggy;
var implementation$62 = keysShim$12;
var slice4 = Array.prototype.slice;
var isArgs2 = isArguments7;
var origKeys2 = Object.keys;
var keysShim2 = origKeys2 ? function keys3(o) {
  return origKeys2(o);
} : implementation$62;
var originalKeys2 = Object.keys;
keysShim2.shim = function shimObjectKeys2() {
  if (Object.keys) {
    var keysWorksWithArguments = function() {
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);
    if (!keysWorksWithArguments) {
      Object.keys = function keys5(object) {
        if (isArgs2(object)) {
          return originalKeys2(slice4.call(object));
        }
        return originalKeys2(object);
      };
    }
  } else {
    Object.keys = keysShim2;
  }
  return Object.keys || keysShim2;
};
var objectKeys2 = keysShim2;
var keys4 = objectKeys2;
var hasSymbols4 = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
var toStr2 = Object.prototype.toString;
var concat4 = Array.prototype.concat;
var origDefineProperty2 = Object.defineProperty;
var isFunction3 = function isFunction4(fn) {
  return typeof fn === "function" && toStr2.call(fn) === "[object Function]";
};
var arePropertyDescriptorsSupported3 = function arePropertyDescriptorsSupported4() {
  var obj = {};
  try {
    origDefineProperty2(obj, "x", {
      enumerable: false,
      value: obj
    });
    for (var _ in obj) {
      return false;
    }
    return obj.x === obj;
  } catch (e) {
    return false;
  }
};
var supportsDescriptors2 = origDefineProperty2 && arePropertyDescriptorsSupported3();
var defineProperty3 = function defineProperty4(object, name, value2, predicate) {
  if (name in object && (!isFunction3(predicate) || !predicate())) {
    return;
  }
  if (supportsDescriptors2) {
    origDefineProperty2(object, name, {
      configurable: true,
      enumerable: false,
      value: value2,
      writable: true
    });
  } else {
    object[name] = value2;
  }
};
var defineProperties3 = function defineProperties4(object, map) {
  var predicates = arguments.length > 2 ? arguments[2] : {};
  var props = keys4(map);
  if (hasSymbols4) {
    props = concat4.call(props, Object.getOwnPropertySymbols(map));
  }
  for (var i = 0; i < props.length; i += 1) {
    defineProperty3(object, props[i], map[props[i]], predicates[props[i]]);
  }
};
defineProperties3.supportsDescriptors = !!supportsDescriptors2;
var defineProperties_12 = defineProperties3;
var numberIsNaN$12 = function numberIsNaN3(value2) {
  return value2 !== value2;
};
var implementation$52 = function is2(a2, b) {
  if (a2 === 0 && b === 0) {
    return 1 / a2 === 1 / b;
  }
  if (a2 === b) {
    return true;
  }
  if (numberIsNaN$12(a2) && numberIsNaN$12(b)) {
    return true;
  }
  return false;
};
var implementation$42 = implementation$52;
var polyfill$32 = function getPolyfill4() {
  return typeof Object.is === "function" ? Object.is : implementation$42;
};
var getPolyfill$32 = polyfill$32;
var define$32 = defineProperties_12;
var shim$32 = function shimObjectIs2() {
  var polyfill3 = getPolyfill$32();
  define$32(Object, {
    is: polyfill3
  }, {
    is: function testObjectIs() {
      return Object.is !== polyfill3;
    }
  });
  return polyfill3;
};
var define$22 = defineProperties_12;
var callBind$12 = callBind$32.exports;
var implementation$32 = implementation$52;
var getPolyfill$22 = polyfill$32;
var shim$22 = shim$32;
var polyfill$22 = callBind$12(getPolyfill$22(), Object);
define$22(polyfill$22, {
  getPolyfill: getPolyfill$22,
  implementation: implementation$32,
  shim: shim$22
});
var objectIs$22 = polyfill$22;
var implementation$22 = function isNaN3(value2) {
  return value2 !== value2;
};
var implementation$12 = implementation$22;
var polyfill$12 = function getPolyfill5() {
  if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")) {
    return Number.isNaN;
  }
  return implementation$12;
};
var define$12 = defineProperties_12;
var getPolyfill$12 = polyfill$12;
var shim$12 = function shimNumberIsNaN2() {
  var polyfill3 = getPolyfill$12();
  define$12(Number, {
    isNaN: polyfill3
  }, {
    isNaN: function testIsNaN() {
      return Number.isNaN !== polyfill3;
    }
  });
  return polyfill3;
};
var callBind2 = callBind$32.exports;
var define3 = defineProperties_12;
var implementation2 = implementation$22;
var getPolyfill6 = polyfill$12;
var shim2 = shim$12;
var polyfill2 = callBind2(getPolyfill6(), Number);
define3(polyfill2, {
  getPolyfill: getPolyfill6,
  implementation: implementation2,
  shim: shim2
});
var isNan2 = polyfill2;
function _slicedToArray3(arr, i) {
  return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _nonIterableRest2();
}
function _nonIterableRest2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function _iterableToArrayLimit2(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err2) {
    _d = true;
    _e = err2;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles2(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _typeof$12(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$12 = function _typeof9(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$12 = function _typeof9(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$12(obj);
}
var regexFlagsSupported2 = /a/g.flags !== void 0;
var arrayFromSet3 = function arrayFromSet4(set7) {
  var array = [];
  set7.forEach(function(value2) {
    return array.push(value2);
  });
  return array;
};
var arrayFromMap3 = function arrayFromMap4(map) {
  var array = [];
  map.forEach(function(value2, key) {
    return array.push([key, value2]);
  });
  return array;
};
var objectIs$12 = Object.is ? Object.is : objectIs$22;
var objectGetOwnPropertySymbols2 = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
  return [];
};
var numberIsNaN4 = Number.isNaN ? Number.isNaN : isNan2;
function uncurryThis2(f) {
  return f.call.bind(f);
}
var hasOwnProperty2 = uncurryThis2(Object.prototype.hasOwnProperty);
var propertyIsEnumerable2 = uncurryThis2(Object.prototype.propertyIsEnumerable);
var objectToString2 = uncurryThis2(Object.prototype.toString);
var _require$types$12 = util$12.types;
var isAnyArrayBuffer2 = _require$types$12.isAnyArrayBuffer;
var isArrayBufferView2 = _require$types$12.isArrayBufferView;
var isDate2 = _require$types$12.isDate;
var isMap2 = _require$types$12.isMap;
var isRegExp$12 = _require$types$12.isRegExp;
var isSet2 = _require$types$12.isSet;
var isNativeError2 = _require$types$12.isNativeError;
var isBoxedPrimitive2 = _require$types$12.isBoxedPrimitive;
var isNumberObject2 = _require$types$12.isNumberObject;
var isStringObject2 = _require$types$12.isStringObject;
var isBooleanObject2 = _require$types$12.isBooleanObject;
var isBigIntObject2 = _require$types$12.isBigIntObject;
var isSymbolObject2 = _require$types$12.isSymbolObject;
var isFloat32Array2 = _require$types$12.isFloat32Array;
var isFloat64Array2 = _require$types$12.isFloat64Array;
function isNonIndex2(key) {
  if (key.length === 0 || key.length > 10)
    return true;
  for (var i = 0; i < key.length; i++) {
    var code3 = key.charCodeAt(i);
    if (code3 < 48 || code3 > 57)
      return true;
  }
  return key.length === 10 && key >= Math.pow(2, 32);
}
function getOwnNonIndexProperties2(value2) {
  return Object.keys(value2).filter(isNonIndex2).concat(objectGetOwnPropertySymbols2(value2).filter(Object.prototype.propertyIsEnumerable.bind(value2)));
}
function compare6(a2, b) {
  if (a2 === b) {
    return 0;
  }
  var x = a2.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a2[i] !== b[i]) {
      x = a2[i];
      y = b[i];
      break;
    }
  }
  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
var kStrict2 = true;
var kLoose2 = false;
var kNoIterator2 = 0;
var kIsArray2 = 1;
var kIsSet2 = 2;
var kIsMap2 = 3;
function areSimilarRegExps2(a2, b) {
  return regexFlagsSupported2 ? a2.source === b.source && a2.flags === b.flags : RegExp.prototype.toString.call(a2) === RegExp.prototype.toString.call(b);
}
function areSimilarFloatArrays2(a2, b) {
  if (a2.byteLength !== b.byteLength) {
    return false;
  }
  for (var offset3 = 0; offset3 < a2.byteLength; offset3++) {
    if (a2[offset3] !== b[offset3]) {
      return false;
    }
  }
  return true;
}
function areSimilarTypedArrays2(a2, b) {
  if (a2.byteLength !== b.byteLength) {
    return false;
  }
  return compare6(new Uint8Array(a2.buffer, a2.byteOffset, a2.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
}
function areEqualArrayBuffers2(buf1, buf2) {
  return buf1.byteLength === buf2.byteLength && compare6(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
}
function isEqualBoxedPrimitive2(val1, val2) {
  if (isNumberObject2(val1)) {
    return isNumberObject2(val2) && objectIs$12(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
  }
  if (isStringObject2(val1)) {
    return isStringObject2(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
  }
  if (isBooleanObject2(val1)) {
    return isBooleanObject2(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
  }
  if (isBigIntObject2(val1)) {
    return isBigIntObject2(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
  }
  return isSymbolObject2(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
}
function innerDeepEqual2(val1, val2, strict3, memos) {
  if (val1 === val2) {
    if (val1 !== 0)
      return true;
    return strict3 ? objectIs$12(val1, val2) : true;
  }
  if (strict3) {
    if (_typeof$12(val1) !== "object") {
      return typeof val1 === "number" && numberIsNaN4(val1) && numberIsNaN4(val2);
    }
    if (_typeof$12(val2) !== "object" || val1 === null || val2 === null) {
      return false;
    }
    if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
      return false;
    }
  } else {
    if (val1 === null || _typeof$12(val1) !== "object") {
      if (val2 === null || _typeof$12(val2) !== "object") {
        return val1 == val2;
      }
      return false;
    }
    if (val2 === null || _typeof$12(val2) !== "object") {
      return false;
    }
  }
  var val1Tag = objectToString2(val1);
  var val2Tag = objectToString2(val2);
  if (val1Tag !== val2Tag) {
    return false;
  }
  if (Array.isArray(val1)) {
    if (val1.length !== val2.length) {
      return false;
    }
    var keys1 = getOwnNonIndexProperties2(val1);
    var keys22 = getOwnNonIndexProperties2(val2);
    if (keys1.length !== keys22.length) {
      return false;
    }
    return keyCheck2(val1, val2, strict3, memos, kIsArray2, keys1);
  }
  if (val1Tag === "[object Object]") {
    if (!isMap2(val1) && isMap2(val2) || !isSet2(val1) && isSet2(val2)) {
      return false;
    }
  }
  if (isDate2(val1)) {
    if (!isDate2(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
      return false;
    }
  } else if (isRegExp$12(val1)) {
    if (!isRegExp$12(val2) || !areSimilarRegExps2(val1, val2)) {
      return false;
    }
  } else if (isNativeError2(val1) || val1 instanceof Error) {
    if (val1.message !== val2.message || val1.name !== val2.name) {
      return false;
    }
  } else if (isArrayBufferView2(val1)) {
    if (!strict3 && (isFloat32Array2(val1) || isFloat64Array2(val1))) {
      if (!areSimilarFloatArrays2(val1, val2)) {
        return false;
      }
    } else if (!areSimilarTypedArrays2(val1, val2)) {
      return false;
    }
    var _keys = getOwnNonIndexProperties2(val1);
    var _keys2 = getOwnNonIndexProperties2(val2);
    if (_keys.length !== _keys2.length) {
      return false;
    }
    return keyCheck2(val1, val2, strict3, memos, kNoIterator2, _keys);
  } else if (isSet2(val1)) {
    if (!isSet2(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck2(val1, val2, strict3, memos, kIsSet2);
  } else if (isMap2(val1)) {
    if (!isMap2(val2) || val1.size !== val2.size) {
      return false;
    }
    return keyCheck2(val1, val2, strict3, memos, kIsMap2);
  } else if (isAnyArrayBuffer2(val1)) {
    if (!areEqualArrayBuffers2(val1, val2)) {
      return false;
    }
  } else if (isBoxedPrimitive2(val1) && !isEqualBoxedPrimitive2(val1, val2)) {
    return false;
  }
  return keyCheck2(val1, val2, strict3, memos, kNoIterator2);
}
function getEnumerables2(val, keys5) {
  return keys5.filter(function(k) {
    return propertyIsEnumerable2(val, k);
  });
}
function keyCheck2(val1, val2, strict3, memos, iterationType, aKeys) {
  if (arguments.length === 5) {
    aKeys = Object.keys(val1);
    var bKeys = Object.keys(val2);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
  }
  var i = 0;
  for (; i < aKeys.length; i++) {
    if (!hasOwnProperty2(val2, aKeys[i])) {
      return false;
    }
  }
  if (strict3 && arguments.length === 5) {
    var symbolKeysA = objectGetOwnPropertySymbols2(val1);
    if (symbolKeysA.length !== 0) {
      var count = 0;
      for (i = 0; i < symbolKeysA.length; i++) {
        var key = symbolKeysA[i];
        if (propertyIsEnumerable2(val1, key)) {
          if (!propertyIsEnumerable2(val2, key)) {
            return false;
          }
          aKeys.push(key);
          count++;
        } else if (propertyIsEnumerable2(val2, key)) {
          return false;
        }
      }
      var symbolKeysB = objectGetOwnPropertySymbols2(val2);
      if (symbolKeysA.length !== symbolKeysB.length && getEnumerables2(val2, symbolKeysB).length !== count) {
        return false;
      }
    } else {
      var _symbolKeysB = objectGetOwnPropertySymbols2(val2);
      if (_symbolKeysB.length !== 0 && getEnumerables2(val2, _symbolKeysB).length !== 0) {
        return false;
      }
    }
  }
  if (aKeys.length === 0 && (iterationType === kNoIterator2 || iterationType === kIsArray2 && val1.length === 0 || val1.size === 0)) {
    return true;
  }
  if (memos === void 0) {
    memos = {
      val1: /* @__PURE__ */ new Map(),
      val2: /* @__PURE__ */ new Map(),
      position: 0
    };
  } else {
    var val2MemoA = memos.val1.get(val1);
    if (val2MemoA !== void 0) {
      var val2MemoB = memos.val2.get(val2);
      if (val2MemoB !== void 0) {
        return val2MemoA === val2MemoB;
      }
    }
    memos.position++;
  }
  memos.val1.set(val1, memos.position);
  memos.val2.set(val2, memos.position);
  var areEq = objEquiv2(val1, val2, strict3, aKeys, memos, iterationType);
  memos.val1.delete(val1);
  memos.val2.delete(val2);
  return areEq;
}
function setHasEqualElement2(set7, val1, strict3, memo) {
  var setValues = arrayFromSet3(set7);
  for (var i = 0; i < setValues.length; i++) {
    var val2 = setValues[i];
    if (innerDeepEqual2(val1, val2, strict3, memo)) {
      set7.delete(val2);
      return true;
    }
  }
  return false;
}
function findLooseMatchingPrimitives2(prim) {
  switch (_typeof$12(prim)) {
    case "undefined":
      return null;
    case "object":
      return void 0;
    case "symbol":
      return false;
    case "string":
      prim = +prim;
    case "number":
      if (numberIsNaN4(prim)) {
        return false;
      }
  }
  return true;
}
function setMightHaveLoosePrim2(a2, b, prim) {
  var altValue = findLooseMatchingPrimitives2(prim);
  if (altValue != null)
    return altValue;
  return b.has(altValue) && !a2.has(altValue);
}
function mapMightHaveLoosePrim2(a2, b, prim, item, memo) {
  var altValue = findLooseMatchingPrimitives2(prim);
  if (altValue != null) {
    return altValue;
  }
  var curB = b.get(altValue);
  if (curB === void 0 && !b.has(altValue) || !innerDeepEqual2(item, curB, false, memo)) {
    return false;
  }
  return !a2.has(altValue) && innerDeepEqual2(item, curB, false, memo);
}
function setEquiv2(a2, b, strict3, memo) {
  var set7 = null;
  var aValues = arrayFromSet3(a2);
  for (var i = 0; i < aValues.length; i++) {
    var val = aValues[i];
    if (_typeof$12(val) === "object" && val !== null) {
      if (set7 === null) {
        set7 = /* @__PURE__ */ new Set();
      }
      set7.add(val);
    } else if (!b.has(val)) {
      if (strict3)
        return false;
      if (!setMightHaveLoosePrim2(a2, b, val)) {
        return false;
      }
      if (set7 === null) {
        set7 = /* @__PURE__ */ new Set();
      }
      set7.add(val);
    }
  }
  if (set7 !== null) {
    var bValues = arrayFromSet3(b);
    for (var _i = 0; _i < bValues.length; _i++) {
      var _val = bValues[_i];
      if (_typeof$12(_val) === "object" && _val !== null) {
        if (!setHasEqualElement2(set7, _val, strict3, memo))
          return false;
      } else if (!strict3 && !a2.has(_val) && !setHasEqualElement2(set7, _val, strict3, memo)) {
        return false;
      }
    }
    return set7.size === 0;
  }
  return true;
}
function mapHasEqualEntry2(set7, map, key1, item1, strict3, memo) {
  var setValues = arrayFromSet3(set7);
  for (var i = 0; i < setValues.length; i++) {
    var key2 = setValues[i];
    if (innerDeepEqual2(key1, key2, strict3, memo) && innerDeepEqual2(item1, map.get(key2), strict3, memo)) {
      set7.delete(key2);
      return true;
    }
  }
  return false;
}
function mapEquiv2(a2, b, strict3, memo) {
  var set7 = null;
  var aEntries = arrayFromMap3(a2);
  for (var i = 0; i < aEntries.length; i++) {
    var _aEntries$i = _slicedToArray3(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
    if (_typeof$12(key) === "object" && key !== null) {
      if (set7 === null) {
        set7 = /* @__PURE__ */ new Set();
      }
      set7.add(key);
    } else {
      var item2 = b.get(key);
      if (item2 === void 0 && !b.has(key) || !innerDeepEqual2(item1, item2, strict3, memo)) {
        if (strict3)
          return false;
        if (!mapMightHaveLoosePrim2(a2, b, key, item1, memo))
          return false;
        if (set7 === null) {
          set7 = /* @__PURE__ */ new Set();
        }
        set7.add(key);
      }
    }
  }
  if (set7 !== null) {
    var bEntries = arrayFromMap3(b);
    for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
      var _bEntries$_i = _slicedToArray3(bEntries[_i2], 2), key = _bEntries$_i[0], item = _bEntries$_i[1];
      if (_typeof$12(key) === "object" && key !== null) {
        if (!mapHasEqualEntry2(set7, a2, key, item, strict3, memo))
          return false;
      } else if (!strict3 && (!a2.has(key) || !innerDeepEqual2(a2.get(key), item, false, memo)) && !mapHasEqualEntry2(set7, a2, key, item, false, memo)) {
        return false;
      }
    }
    return set7.size === 0;
  }
  return true;
}
function objEquiv2(a2, b, strict3, keys5, memos, iterationType) {
  var i = 0;
  if (iterationType === kIsSet2) {
    if (!setEquiv2(a2, b, strict3, memos)) {
      return false;
    }
  } else if (iterationType === kIsMap2) {
    if (!mapEquiv2(a2, b, strict3, memos)) {
      return false;
    }
  } else if (iterationType === kIsArray2) {
    for (; i < a2.length; i++) {
      if (hasOwnProperty2(a2, i)) {
        if (!hasOwnProperty2(b, i) || !innerDeepEqual2(a2[i], b[i], strict3, memos)) {
          return false;
        }
      } else if (hasOwnProperty2(b, i)) {
        return false;
      } else {
        var keysA = Object.keys(a2);
        for (; i < keysA.length; i++) {
          var key = keysA[i];
          if (!hasOwnProperty2(b, key) || !innerDeepEqual2(a2[key], b[key], strict3, memos)) {
            return false;
          }
        }
        if (keysA.length !== Object.keys(b).length) {
          return false;
        }
        return true;
      }
    }
  }
  for (i = 0; i < keys5.length; i++) {
    var _key = keys5[i];
    if (!innerDeepEqual2(a2[_key], b[_key], strict3, memos)) {
      return false;
    }
  }
  return true;
}
function isDeepEqual$12(val1, val2) {
  return innerDeepEqual2(val1, val2, kLoose2);
}
function isDeepStrictEqual$12(val1, val2) {
  return innerDeepEqual2(val1, val2, kStrict2);
}
var comparisons2 = {
  isDeepEqual: isDeepEqual$12,
  isDeepStrictEqual: isDeepStrictEqual$12
};
function _typeof6(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof6 = function _typeof9(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof6 = function _typeof9(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof6(obj);
}
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var _require3 = errors2;
var _require$codes2 = _require3.codes;
var ERR_AMBIGUOUS_ARGUMENT2 = _require$codes2.ERR_AMBIGUOUS_ARGUMENT;
var ERR_INVALID_ARG_TYPE2 = _require$codes2.ERR_INVALID_ARG_TYPE;
var ERR_INVALID_ARG_VALUE2 = _require$codes2.ERR_INVALID_ARG_VALUE;
var ERR_INVALID_RETURN_VALUE2 = _require$codes2.ERR_INVALID_RETURN_VALUE;
var ERR_MISSING_ARGS2 = _require$codes2.ERR_MISSING_ARGS;
var AssertionError2 = assertion_error2;
var _require22 = util$12;
var inspect4 = _require22.inspect;
var _require$types2 = util$12.types;
var isPromise2 = _require$types2.isPromise;
var isRegExp2 = _require$types2.isRegExp;
var objectAssign2 = Object.assign ? Object.assign : es6ObjectAssign2.assign;
var objectIs2 = Object.is ? Object.is : objectIs$22;
var isDeepEqual2;
var isDeepStrictEqual2;
function lazyLoadComparison2() {
  var comparison = comparisons2;
  isDeepEqual2 = comparison.isDeepEqual;
  isDeepStrictEqual2 = comparison.isDeepStrictEqual;
}
var warned2 = false;
var assert2 = assert$22.exports = ok2;
var NO_EXCEPTION_SENTINEL2 = {};
function innerFail2(obj) {
  if (obj.message instanceof Error)
    throw obj.message;
  throw new AssertionError2(obj);
}
function fail2(actual, expected, message, operator, stackStartFn) {
  var argsLen = arguments.length;
  var internalMessage;
  if (argsLen === 0) {
    internalMessage = "Failed";
  } else if (argsLen === 1) {
    message = actual;
    actual = void 0;
  } else {
    if (warned2 === false) {
      warned2 = true;
      var warn = console.warn.bind(console);
      warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
    }
    if (argsLen === 2)
      operator = "!=";
  }
  if (message instanceof Error)
    throw message;
  var errArgs = {
    actual,
    expected,
    operator: operator === void 0 ? "fail" : operator,
    stackStartFn: stackStartFn || fail2
  };
  if (message !== void 0) {
    errArgs.message = message;
  }
  var err2 = new AssertionError2(errArgs);
  if (internalMessage) {
    err2.message = internalMessage;
    err2.generatedMessage = true;
  }
  throw err2;
}
assert2.fail = fail2;
assert2.AssertionError = AssertionError2;
function innerOk2(fn, argLen, value2, message) {
  if (!value2) {
    var generatedMessage = false;
    if (argLen === 0) {
      generatedMessage = true;
      message = "No value argument passed to `assert.ok()`";
    } else if (message instanceof Error) {
      throw message;
    }
    var err2 = new AssertionError2({
      actual: value2,
      expected: true,
      message,
      operator: "==",
      stackStartFn: fn
    });
    err2.generatedMessage = generatedMessage;
    throw err2;
  }
}
function ok2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  innerOk2.apply(void 0, [ok2, args.length].concat(args));
}
assert2.ok = ok2;
assert2.equal = function equal2(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS2("actual", "expected");
  }
  if (actual != expected) {
    innerFail2({
      actual,
      expected,
      message,
      operator: "==",
      stackStartFn: equal2
    });
  }
};
assert2.notEqual = function notEqual2(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS2("actual", "expected");
  }
  if (actual == expected) {
    innerFail2({
      actual,
      expected,
      message,
      operator: "!=",
      stackStartFn: notEqual2
    });
  }
};
assert2.deepEqual = function deepEqual2(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS2("actual", "expected");
  }
  if (isDeepEqual2 === void 0)
    lazyLoadComparison2();
  if (!isDeepEqual2(actual, expected)) {
    innerFail2({
      actual,
      expected,
      message,
      operator: "deepEqual",
      stackStartFn: deepEqual2
    });
  }
};
assert2.notDeepEqual = function notDeepEqual2(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS2("actual", "expected");
  }
  if (isDeepEqual2 === void 0)
    lazyLoadComparison2();
  if (isDeepEqual2(actual, expected)) {
    innerFail2({
      actual,
      expected,
      message,
      operator: "notDeepEqual",
      stackStartFn: notDeepEqual2
    });
  }
};
assert2.deepStrictEqual = function deepStrictEqual2(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS2("actual", "expected");
  }
  if (isDeepEqual2 === void 0)
    lazyLoadComparison2();
  if (!isDeepStrictEqual2(actual, expected)) {
    innerFail2({
      actual,
      expected,
      message,
      operator: "deepStrictEqual",
      stackStartFn: deepStrictEqual2
    });
  }
};
assert2.notDeepStrictEqual = notDeepStrictEqual2;
function notDeepStrictEqual2(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS2("actual", "expected");
  }
  if (isDeepEqual2 === void 0)
    lazyLoadComparison2();
  if (isDeepStrictEqual2(actual, expected)) {
    innerFail2({
      actual,
      expected,
      message,
      operator: "notDeepStrictEqual",
      stackStartFn: notDeepStrictEqual2
    });
  }
}
assert2.strictEqual = function strictEqual2(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS2("actual", "expected");
  }
  if (!objectIs2(actual, expected)) {
    innerFail2({
      actual,
      expected,
      message,
      operator: "strictEqual",
      stackStartFn: strictEqual2
    });
  }
};
assert2.notStrictEqual = function notStrictEqual2(actual, expected, message) {
  if (arguments.length < 2) {
    throw new ERR_MISSING_ARGS2("actual", "expected");
  }
  if (objectIs2(actual, expected)) {
    innerFail2({
      actual,
      expected,
      message,
      operator: "notStrictEqual",
      stackStartFn: notStrictEqual2
    });
  }
};
var Comparison3 = function Comparison4(obj, keys5, actual) {
  var _this = this;
  _classCallCheck2(this, Comparison4);
  keys5.forEach(function(key) {
    if (key in obj) {
      if (actual !== void 0 && typeof actual[key] === "string" && isRegExp2(obj[key]) && obj[key].test(actual[key])) {
        _this[key] = actual[key];
      } else {
        _this[key] = obj[key];
      }
    }
  });
};
function compareExceptionKey2(actual, expected, key, message, keys5, fn) {
  if (!(key in actual) || !isDeepStrictEqual2(actual[key], expected[key])) {
    if (!message) {
      var a2 = new Comparison3(actual, keys5);
      var b = new Comparison3(expected, keys5, actual);
      var err2 = new AssertionError2({
        actual: a2,
        expected: b,
        operator: "deepStrictEqual",
        stackStartFn: fn
      });
      err2.actual = actual;
      err2.expected = expected;
      err2.operator = fn.name;
      throw err2;
    }
    innerFail2({
      actual,
      expected,
      message,
      operator: fn.name,
      stackStartFn: fn
    });
  }
}
function expectedException2(actual, expected, msg2, fn) {
  if (typeof expected !== "function") {
    if (isRegExp2(expected))
      return expected.test(actual);
    if (arguments.length === 2) {
      throw new ERR_INVALID_ARG_TYPE2("expected", ["Function", "RegExp"], expected);
    }
    if (_typeof6(actual) !== "object" || actual === null) {
      var err2 = new AssertionError2({
        actual,
        expected,
        message: msg2,
        operator: "deepStrictEqual",
        stackStartFn: fn
      });
      err2.operator = fn.name;
      throw err2;
    }
    var keys5 = Object.keys(expected);
    if (expected instanceof Error) {
      keys5.push("name", "message");
    } else if (keys5.length === 0) {
      throw new ERR_INVALID_ARG_VALUE2("error", expected, "may not be an empty object");
    }
    if (isDeepEqual2 === void 0)
      lazyLoadComparison2();
    keys5.forEach(function(key) {
      if (typeof actual[key] === "string" && isRegExp2(expected[key]) && expected[key].test(actual[key])) {
        return;
      }
      compareExceptionKey2(actual, expected, key, msg2, keys5, fn);
    });
    return true;
  }
  if (expected.prototype !== void 0 && actual instanceof expected) {
    return true;
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function getActual2(fn) {
  if (typeof fn !== "function") {
    throw new ERR_INVALID_ARG_TYPE2("fn", "Function", fn);
  }
  try {
    fn();
  } catch (e) {
    return e;
  }
  return NO_EXCEPTION_SENTINEL2;
}
function checkIsPromise2(obj) {
  return isPromise2(obj) || obj !== null && _typeof6(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
}
function waitForActual2(promiseFn) {
  return Promise.resolve().then(function() {
    var resultPromise;
    if (typeof promiseFn === "function") {
      resultPromise = promiseFn();
      if (!checkIsPromise2(resultPromise)) {
        throw new ERR_INVALID_RETURN_VALUE2("instance of Promise", "promiseFn", resultPromise);
      }
    } else if (checkIsPromise2(promiseFn)) {
      resultPromise = promiseFn;
    } else {
      throw new ERR_INVALID_ARG_TYPE2("promiseFn", ["Function", "Promise"], promiseFn);
    }
    return Promise.resolve().then(function() {
      return resultPromise;
    }).then(function() {
      return NO_EXCEPTION_SENTINEL2;
    }).catch(function(e) {
      return e;
    });
  });
}
function expectsError2(stackStartFn, actual, error, message) {
  if (typeof error === "string") {
    if (arguments.length === 4) {
      throw new ERR_INVALID_ARG_TYPE2("error", ["Object", "Error", "Function", "RegExp"], error);
    }
    if (_typeof6(actual) === "object" && actual !== null) {
      if (actual.message === error) {
        throw new ERR_AMBIGUOUS_ARGUMENT2("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
      }
    } else if (actual === error) {
      throw new ERR_AMBIGUOUS_ARGUMENT2("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
    }
    message = error;
    error = void 0;
  } else if (error != null && _typeof6(error) !== "object" && typeof error !== "function") {
    throw new ERR_INVALID_ARG_TYPE2("error", ["Object", "Error", "Function", "RegExp"], error);
  }
  if (actual === NO_EXCEPTION_SENTINEL2) {
    var details = "";
    if (error && error.name) {
      details += " (".concat(error.name, ")");
    }
    details += message ? ": ".concat(message) : ".";
    var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
    innerFail2({
      actual: void 0,
      expected: error,
      operator: stackStartFn.name,
      message: "Missing expected ".concat(fnType).concat(details),
      stackStartFn
    });
  }
  if (error && !expectedException2(actual, error, message, stackStartFn)) {
    throw actual;
  }
}
function expectsNoError2(stackStartFn, actual, error, message) {
  if (actual === NO_EXCEPTION_SENTINEL2)
    return;
  if (typeof error === "string") {
    message = error;
    error = void 0;
  }
  if (!error || expectedException2(actual, error)) {
    var details = message ? ": ".concat(message) : ".";
    var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
    innerFail2({
      actual,
      expected: error,
      operator: stackStartFn.name,
      message: "Got unwanted ".concat(fnType).concat(details, "\n") + 'Actual message: "'.concat(actual && actual.message, '"'),
      stackStartFn
    });
  }
  throw actual;
}
assert2.throws = function throws2(promiseFn) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  expectsError2.apply(void 0, [throws2, getActual2(promiseFn)].concat(args));
};
assert2.rejects = function rejects2(promiseFn) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }
  return waitForActual2(promiseFn).then(function(result) {
    return expectsError2.apply(void 0, [rejects2, result].concat(args));
  });
};
assert2.doesNotThrow = function doesNotThrow2(fn) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }
  expectsNoError2.apply(void 0, [doesNotThrow2, getActual2(fn)].concat(args));
};
assert2.doesNotReject = function doesNotReject2(fn) {
  for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }
  return waitForActual2(fn).then(function(result) {
    return expectsNoError2.apply(void 0, [doesNotReject2, result].concat(args));
  });
};
assert2.ifError = function ifError2(err2) {
  if (err2 !== null && err2 !== void 0) {
    var message = "ifError got unwanted exception: ";
    if (_typeof6(err2) === "object" && typeof err2.message === "string") {
      if (err2.message.length === 0 && err2.constructor) {
        message += err2.constructor.name;
      } else {
        message += err2.message;
      }
    } else {
      message += inspect4(err2);
    }
    var newErr = new AssertionError2({
      actual: err2,
      expected: null,
      operator: "ifError",
      message,
      stackStartFn: ifError2
    });
    var origStack = err2.stack;
    if (typeof origStack === "string") {
      var tmp2 = origStack.split("\n");
      tmp2.shift();
      var tmp1 = newErr.stack.split("\n");
      for (var i = 0; i < tmp2.length; i++) {
        var pos = tmp1.indexOf(tmp2[i]);
        if (pos !== -1) {
          tmp1 = tmp1.slice(0, pos);
          break;
        }
      }
      newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
    }
    throw newErr;
  }
};
function strict2() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }
  innerOk2.apply(void 0, [strict2, args.length].concat(args));
}
assert2.strict = objectAssign2(strict2, assert2, {
  equal: assert2.strictEqual,
  deepEqual: assert2.deepStrictEqual,
  notEqual: assert2.notStrictEqual,
  notDeepEqual: assert2.notDeepStrictEqual
});
assert2.strict.strict = assert2.strict;
(function(exports) {
  var assert3 = assert$22.exports;
  var Zstream = import_zstream.default;
  var zlib_deflate = import_deflate.default;
  var zlib_inflate = import_inflate.default;
  var constants2 = import_constants.default;
  for (var key in constants2) {
    exports[key] = constants2[key];
  }
  exports.NONE = 0;
  exports.DEFLATE = 1;
  exports.INFLATE = 2;
  exports.GZIP = 3;
  exports.GUNZIP = 4;
  exports.DEFLATERAW = 5;
  exports.INFLATERAW = 6;
  exports.UNZIP = 7;
  var GZIP_HEADER_ID1 = 31;
  var GZIP_HEADER_ID2 = 139;
  function Zlib(mode) {
    if (typeof mode !== "number" || mode < exports.DEFLATE || mode > exports.UNZIP) {
      throw new TypeError("Bad argument");
    }
    this.dictionary = null;
    this.err = 0;
    this.flush = 0;
    this.init_done = false;
    this.level = 0;
    this.memLevel = 0;
    this.mode = mode;
    this.strategy = 0;
    this.windowBits = 0;
    this.write_in_progress = false;
    this.pending_close = false;
    this.gzip_id_bytes_read = 0;
  }
  Zlib.prototype.close = function() {
    if (this.write_in_progress) {
      this.pending_close = true;
      return;
    }
    this.pending_close = false;
    assert3(this.init_done, "close before init");
    assert3(this.mode <= exports.UNZIP);
    if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
      zlib_deflate.deflateEnd(this.strm);
    } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {
      zlib_inflate.inflateEnd(this.strm);
    }
    this.mode = exports.NONE;
    this.dictionary = null;
  };
  Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
    return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
  };
  Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
    assert3.equal(arguments.length, 8);
    assert3(this.init_done, "write before init");
    assert3(this.mode !== exports.NONE, "already finalized");
    assert3.equal(false, this.write_in_progress, "write already in progress");
    assert3.equal(false, this.pending_close, "close is pending");
    this.write_in_progress = true;
    assert3.equal(false, flush === void 0, "must provide flush value");
    this.write_in_progress = true;
    if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
      throw new Error("Invalid flush value");
    }
    if (input == null) {
      input = Buffer$4.alloc(0);
      in_len = 0;
      in_off = 0;
    }
    this.strm.avail_in = in_len;
    this.strm.input = input;
    this.strm.next_in = in_off;
    this.strm.avail_out = out_len;
    this.strm.output = out;
    this.strm.next_out = out_off;
    this.flush = flush;
    if (!async) {
      this._process();
      if (this._checkError()) {
        return this._afterSync();
      }
      return;
    }
    var self2 = this;
    browser$1$12.nextTick(function() {
      self2._process();
      self2._after();
    });
    return this;
  };
  Zlib.prototype._afterSync = function() {
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    return [avail_in, avail_out];
  };
  Zlib.prototype._process = function() {
    var next_expected_header_byte = null;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.GZIP:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflate(this.strm, this.flush);
        break;
      case exports.UNZIP:
        if (this.strm.avail_in > 0) {
          next_expected_header_byte = this.strm.next_in;
        }
        switch (this.gzip_id_bytes_read) {
          case 0:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
              this.gzip_id_bytes_read = 1;
              next_expected_header_byte++;
              if (this.strm.avail_in === 1) {
                break;
              }
            } else {
              this.mode = exports.INFLATE;
              break;
            }
          case 1:
            if (next_expected_header_byte === null) {
              break;
            }
            if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
              this.gzip_id_bytes_read = 2;
              this.mode = exports.GUNZIP;
            } else {
              this.mode = exports.INFLATE;
            }
            break;
          default:
            throw new Error("invalid number of gzip magic number bytes read");
        }
      case exports.INFLATE:
      case exports.GUNZIP:
      case exports.INFLATERAW:
        this.err = zlib_inflate.inflate(
          this.strm,
          this.flush
          // If data was encoded with dictionary
        );
        if (this.err === exports.Z_NEED_DICT && this.dictionary) {
          this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
          if (this.err === exports.Z_OK) {
            this.err = zlib_inflate.inflate(this.strm, this.flush);
          } else if (this.err === exports.Z_DATA_ERROR) {
            this.err = exports.Z_NEED_DICT;
          }
        }
        while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0) {
          this.reset();
          this.err = zlib_inflate.inflate(this.strm, this.flush);
        }
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
  };
  Zlib.prototype._checkError = function() {
    switch (this.err) {
      case exports.Z_OK:
      case exports.Z_BUF_ERROR:
        if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {
          this._error("unexpected end of file");
          return false;
        }
        break;
      case exports.Z_STREAM_END:
        break;
      case exports.Z_NEED_DICT:
        if (this.dictionary == null) {
          this._error("Missing dictionary");
        } else {
          this._error("Bad dictionary");
        }
        return false;
      default:
        this._error("Zlib error");
        return false;
    }
    return true;
  };
  Zlib.prototype._after = function() {
    if (!this._checkError()) {
      return;
    }
    var avail_out = this.strm.avail_out;
    var avail_in = this.strm.avail_in;
    this.write_in_progress = false;
    this.callback(avail_in, avail_out);
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype._error = function(message) {
    if (this.strm.msg) {
      message = this.strm.msg;
    }
    this.onerror(
      message,
      this.err
      // no hope of rescue.
    );
    this.write_in_progress = false;
    if (this.pending_close) {
      this.close();
    }
  };
  Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
    assert3(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
    assert3(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
    assert3(level >= -1 && level <= 9, "invalid compression level");
    assert3(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
    assert3(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, "invalid strategy");
    this._init(level, windowBits, memLevel, strategy, dictionary);
    this._setDictionary();
  };
  Zlib.prototype.params = function() {
    throw new Error("deflateParams Not supported");
  };
  Zlib.prototype.reset = function() {
    this._reset();
    this._setDictionary();
  };
  Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
    this.level = level;
    this.windowBits = windowBits;
    this.memLevel = memLevel;
    this.strategy = strategy;
    this.flush = exports.Z_NO_FLUSH;
    this.err = exports.Z_OK;
    if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {
      this.windowBits += 16;
    }
    if (this.mode === exports.UNZIP) {
      this.windowBits += 32;
    }
    if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {
      this.windowBits = -1 * this.windowBits;
    }
    this.strm = new Zstream();
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.GZIP:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
        break;
      case exports.INFLATE:
      case exports.GUNZIP:
      case exports.INFLATERAW:
      case exports.UNZIP:
        this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
        break;
      default:
        throw new Error("Unknown mode " + this.mode);
    }
    if (this.err !== exports.Z_OK) {
      this._error("Init error");
    }
    this.dictionary = dictionary;
    this.write_in_progress = false;
    this.init_done = true;
  };
  Zlib.prototype._setDictionary = function() {
    if (this.dictionary == null) {
      return;
    }
    this.err = exports.Z_OK;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.DEFLATERAW:
        this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
        break;
    }
    if (this.err !== exports.Z_OK) {
      this._error("Failed to set dictionary");
    }
  };
  Zlib.prototype._reset = function() {
    this.err = exports.Z_OK;
    switch (this.mode) {
      case exports.DEFLATE:
      case exports.DEFLATERAW:
      case exports.GZIP:
        this.err = zlib_deflate.deflateReset(this.strm);
        break;
      case exports.INFLATE:
      case exports.INFLATERAW:
      case exports.GUNZIP:
        this.err = zlib_inflate.inflateReset(this.strm);
        break;
    }
    if (this.err !== exports.Z_OK) {
      this._error("Failed to reset stream");
    }
  };
  exports.Zlib = Zlib;
})(binding2);
(function(exports) {
  var Buffer5 = buffer2.Buffer;
  var Transform3 = readableBrowser.exports.Transform;
  var binding$13 = binding2;
  var util3 = util$12;
  var assert3 = assert$22.exports.ok;
  var kMaxLength4 = buffer2.kMaxLength;
  var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength4.toString(16) + " bytes";
  binding$13.Z_MIN_WINDOWBITS = 8;
  binding$13.Z_MAX_WINDOWBITS = 15;
  binding$13.Z_DEFAULT_WINDOWBITS = 15;
  binding$13.Z_MIN_CHUNK = 64;
  binding$13.Z_MAX_CHUNK = Infinity;
  binding$13.Z_DEFAULT_CHUNK = 16 * 1024;
  binding$13.Z_MIN_MEMLEVEL = 1;
  binding$13.Z_MAX_MEMLEVEL = 9;
  binding$13.Z_DEFAULT_MEMLEVEL = 8;
  binding$13.Z_MIN_LEVEL = -1;
  binding$13.Z_MAX_LEVEL = 9;
  binding$13.Z_DEFAULT_LEVEL = binding$13.Z_DEFAULT_COMPRESSION;
  var bkeys = Object.keys(binding$13);
  for (var bk = 0; bk < bkeys.length; bk++) {
    var bkey = bkeys[bk];
    if (bkey.match(/^Z/)) {
      Object.defineProperty(exports, bkey, {
        enumerable: true,
        value: binding$13[bkey],
        writable: false
      });
    }
  }
  var codes3 = {
    Z_OK: binding$13.Z_OK,
    Z_STREAM_END: binding$13.Z_STREAM_END,
    Z_NEED_DICT: binding$13.Z_NEED_DICT,
    Z_ERRNO: binding$13.Z_ERRNO,
    Z_STREAM_ERROR: binding$13.Z_STREAM_ERROR,
    Z_DATA_ERROR: binding$13.Z_DATA_ERROR,
    Z_MEM_ERROR: binding$13.Z_MEM_ERROR,
    Z_BUF_ERROR: binding$13.Z_BUF_ERROR,
    Z_VERSION_ERROR: binding$13.Z_VERSION_ERROR
  };
  var ckeys = Object.keys(codes3);
  for (var ck = 0; ck < ckeys.length; ck++) {
    var ckey = ckeys[ck];
    codes3[codes3[ckey]] = ckey;
  }
  Object.defineProperty(exports, "codes", {
    enumerable: true,
    value: Object.freeze(codes3),
    writable: false
  });
  exports.Deflate = Deflate;
  exports.Inflate = Inflate;
  exports.Gzip = Gzip;
  exports.Gunzip = Gunzip;
  exports.DeflateRaw = DeflateRaw;
  exports.InflateRaw = InflateRaw;
  exports.Unzip = Unzip;
  exports.createDeflate = function(o) {
    return new Deflate(o);
  };
  exports.createInflate = function(o) {
    return new Inflate(o);
  };
  exports.createDeflateRaw = function(o) {
    return new DeflateRaw(o);
  };
  exports.createInflateRaw = function(o) {
    return new InflateRaw(o);
  };
  exports.createGzip = function(o) {
    return new Gzip(o);
  };
  exports.createGunzip = function(o) {
    return new Gunzip(o);
  };
  exports.createUnzip = function(o) {
    return new Unzip(o);
  };
  exports.deflate = function(buffer3, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Deflate(opts2), buffer3, callback);
  };
  exports.deflateSync = function(buffer3, opts2) {
    return zlibBufferSync(new Deflate(opts2), buffer3);
  };
  exports.gzip = function(buffer3, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gzip(opts2), buffer3, callback);
  };
  exports.gzipSync = function(buffer3, opts2) {
    return zlibBufferSync(new Gzip(opts2), buffer3);
  };
  exports.deflateRaw = function(buffer3, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new DeflateRaw(opts2), buffer3, callback);
  };
  exports.deflateRawSync = function(buffer3, opts2) {
    return zlibBufferSync(new DeflateRaw(opts2), buffer3);
  };
  exports.unzip = function(buffer3, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Unzip(opts2), buffer3, callback);
  };
  exports.unzipSync = function(buffer3, opts2) {
    return zlibBufferSync(new Unzip(opts2), buffer3);
  };
  exports.inflate = function(buffer3, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Inflate(opts2), buffer3, callback);
  };
  exports.inflateSync = function(buffer3, opts2) {
    return zlibBufferSync(new Inflate(opts2), buffer3);
  };
  exports.gunzip = function(buffer3, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new Gunzip(opts2), buffer3, callback);
  };
  exports.gunzipSync = function(buffer3, opts2) {
    return zlibBufferSync(new Gunzip(opts2), buffer3);
  };
  exports.inflateRaw = function(buffer3, opts2, callback) {
    if (typeof opts2 === "function") {
      callback = opts2;
      opts2 = {};
    }
    return zlibBuffer(new InflateRaw(opts2), buffer3, callback);
  };
  exports.inflateRawSync = function(buffer3, opts2) {
    return zlibBufferSync(new InflateRaw(opts2), buffer3);
  };
  function zlibBuffer(engine2, buffer3, callback) {
    var buffers = [];
    var nread = 0;
    engine2.on("error", onError);
    engine2.on("end", onEnd);
    engine2.end(buffer3);
    flow3();
    function flow3() {
      var chunk;
      while (null !== (chunk = engine2.read())) {
        buffers.push(chunk);
        nread += chunk.length;
      }
      engine2.once("readable", flow3);
    }
    function onError(err2) {
      engine2.removeListener("end", onEnd);
      engine2.removeListener("readable", flow3);
      callback(err2);
    }
    function onEnd() {
      var buf;
      var err2 = null;
      if (nread >= kMaxLength4) {
        err2 = new RangeError(kRangeErrorMessage);
      } else {
        buf = Buffer5.concat(buffers, nread);
      }
      buffers = [];
      engine2.close();
      callback(err2, buf);
    }
  }
  function zlibBufferSync(engine2, buffer3) {
    if (typeof buffer3 === "string")
      buffer3 = Buffer5.from(buffer3);
    if (!Buffer5.isBuffer(buffer3))
      throw new TypeError("Not a string or buffer");
    var flushFlag = engine2._finishFlushFlag;
    return engine2._processChunk(buffer3, flushFlag);
  }
  function Deflate(opts2) {
    if (!(this instanceof Deflate))
      return new Deflate(opts2);
    Zlib.call(this, opts2, binding$13.DEFLATE);
  }
  function Inflate(opts2) {
    if (!(this instanceof Inflate))
      return new Inflate(opts2);
    Zlib.call(this, opts2, binding$13.INFLATE);
  }
  function Gzip(opts2) {
    if (!(this instanceof Gzip))
      return new Gzip(opts2);
    Zlib.call(this, opts2, binding$13.GZIP);
  }
  function Gunzip(opts2) {
    if (!(this instanceof Gunzip))
      return new Gunzip(opts2);
    Zlib.call(this, opts2, binding$13.GUNZIP);
  }
  function DeflateRaw(opts2) {
    if (!(this instanceof DeflateRaw))
      return new DeflateRaw(opts2);
    Zlib.call(this, opts2, binding$13.DEFLATERAW);
  }
  function InflateRaw(opts2) {
    if (!(this instanceof InflateRaw))
      return new InflateRaw(opts2);
    Zlib.call(this, opts2, binding$13.INFLATERAW);
  }
  function Unzip(opts2) {
    if (!(this instanceof Unzip))
      return new Unzip(opts2);
    Zlib.call(this, opts2, binding$13.UNZIP);
  }
  function isValidFlushFlag(flag) {
    return flag === binding$13.Z_NO_FLUSH || flag === binding$13.Z_PARTIAL_FLUSH || flag === binding$13.Z_SYNC_FLUSH || flag === binding$13.Z_FULL_FLUSH || flag === binding$13.Z_FINISH || flag === binding$13.Z_BLOCK;
  }
  function Zlib(opts2, mode) {
    var _this = this;
    this._opts = opts2 = opts2 || {};
    this._chunkSize = opts2.chunkSize || exports.Z_DEFAULT_CHUNK;
    Transform3.call(this, opts2);
    if (opts2.flush && !isValidFlushFlag(opts2.flush)) {
      throw new Error("Invalid flush flag: " + opts2.flush);
    }
    if (opts2.finishFlush && !isValidFlushFlag(opts2.finishFlush)) {
      throw new Error("Invalid flush flag: " + opts2.finishFlush);
    }
    this._flushFlag = opts2.flush || binding$13.Z_NO_FLUSH;
    this._finishFlushFlag = typeof opts2.finishFlush !== "undefined" ? opts2.finishFlush : binding$13.Z_FINISH;
    if (opts2.chunkSize) {
      if (opts2.chunkSize < exports.Z_MIN_CHUNK || opts2.chunkSize > exports.Z_MAX_CHUNK) {
        throw new Error("Invalid chunk size: " + opts2.chunkSize);
      }
    }
    if (opts2.windowBits) {
      if (opts2.windowBits < exports.Z_MIN_WINDOWBITS || opts2.windowBits > exports.Z_MAX_WINDOWBITS) {
        throw new Error("Invalid windowBits: " + opts2.windowBits);
      }
    }
    if (opts2.level) {
      if (opts2.level < exports.Z_MIN_LEVEL || opts2.level > exports.Z_MAX_LEVEL) {
        throw new Error("Invalid compression level: " + opts2.level);
      }
    }
    if (opts2.memLevel) {
      if (opts2.memLevel < exports.Z_MIN_MEMLEVEL || opts2.memLevel > exports.Z_MAX_MEMLEVEL) {
        throw new Error("Invalid memLevel: " + opts2.memLevel);
      }
    }
    if (opts2.strategy) {
      if (opts2.strategy != exports.Z_FILTERED && opts2.strategy != exports.Z_HUFFMAN_ONLY && opts2.strategy != exports.Z_RLE && opts2.strategy != exports.Z_FIXED && opts2.strategy != exports.Z_DEFAULT_STRATEGY) {
        throw new Error("Invalid strategy: " + opts2.strategy);
      }
    }
    if (opts2.dictionary) {
      if (!Buffer5.isBuffer(opts2.dictionary)) {
        throw new Error("Invalid dictionary: it should be a Buffer instance");
      }
    }
    this._handle = new binding$13.Zlib(mode);
    var self2 = this;
    this._hadError = false;
    this._handle.onerror = function(message, errno) {
      _close(self2);
      self2._hadError = true;
      var error = new Error(message);
      error.errno = errno;
      error.code = exports.codes[errno];
      self2.emit("error", error);
    };
    var level = exports.Z_DEFAULT_COMPRESSION;
    if (typeof opts2.level === "number")
      level = opts2.level;
    var strategy = exports.Z_DEFAULT_STRATEGY;
    if (typeof opts2.strategy === "number")
      strategy = opts2.strategy;
    this._handle.init(opts2.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts2.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts2.dictionary);
    this._buffer = Buffer5.allocUnsafe(this._chunkSize);
    this._offset = 0;
    this._level = level;
    this._strategy = strategy;
    this.once("end", this.close);
    Object.defineProperty(this, "_closed", {
      get: function get18() {
        return !_this._handle;
      },
      configurable: true,
      enumerable: true
    });
  }
  util3.inherits(Zlib, Transform3);
  Zlib.prototype.params = function(level, strategy, callback) {
    if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
      throw new RangeError("Invalid compression level: " + level);
    }
    if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new TypeError("Invalid strategy: " + strategy);
    }
    if (this._level !== level || this._strategy !== strategy) {
      var self2 = this;
      this.flush(binding$13.Z_SYNC_FLUSH, function() {
        assert3(self2._handle, "zlib binding closed");
        self2._handle.params(level, strategy);
        if (!self2._hadError) {
          self2._level = level;
          self2._strategy = strategy;
          if (callback)
            callback();
        }
      });
    } else {
      browser$1$12.nextTick(callback);
    }
  };
  Zlib.prototype.reset = function() {
    assert3(this._handle, "zlib binding closed");
    return this._handle.reset();
  };
  Zlib.prototype._flush = function(callback) {
    this._transform(Buffer5.alloc(0), "", callback);
  };
  Zlib.prototype.flush = function(kind, callback) {
    var _this2 = this;
    var ws = this._writableState;
    if (typeof kind === "function" || kind === void 0 && !callback) {
      callback = kind;
      kind = binding$13.Z_FULL_FLUSH;
    }
    if (ws.ended) {
      if (callback)
        browser$1$12.nextTick(callback);
    } else if (ws.ending) {
      if (callback)
        this.once("end", callback);
    } else if (ws.needDrain) {
      if (callback) {
        this.once("drain", function() {
          return _this2.flush(kind, callback);
        });
      }
    } else {
      this._flushFlag = kind;
      this.write(Buffer5.alloc(0), "", callback);
    }
  };
  Zlib.prototype.close = function(callback) {
    _close(this, callback);
    browser$1$12.nextTick(emitCloseNT2, this);
  };
  function _close(engine2, callback) {
    if (callback)
      browser$1$12.nextTick(callback);
    if (!engine2._handle)
      return;
    engine2._handle.close();
    engine2._handle = null;
  }
  function emitCloseNT2(self2) {
    self2.emit("close");
  }
  Zlib.prototype._transform = function(chunk, encoding, cb) {
    var flushFlag;
    var ws = this._writableState;
    var ending = ws.ending || ws.ended;
    var last3 = ending && (!chunk || ws.length === chunk.length);
    if (chunk !== null && !Buffer5.isBuffer(chunk))
      return cb(new Error("invalid input"));
    if (!this._handle)
      return cb(new Error("zlib binding closed"));
    if (last3)
      flushFlag = this._finishFlushFlag;
    else {
      flushFlag = this._flushFlag;
      if (chunk.length >= ws.length) {
        this._flushFlag = this._opts.flush || binding$13.Z_NO_FLUSH;
      }
    }
    this._processChunk(chunk, flushFlag, cb);
  };
  Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
    var availInBefore = chunk && chunk.length;
    var availOutBefore = this._chunkSize - this._offset;
    var inOff = 0;
    var self2 = this;
    var async = typeof cb === "function";
    if (!async) {
      var buffers = [];
      var nread = 0;
      var error;
      this.on("error", function(er2) {
        error = er2;
      });
      assert3(this._handle, "zlib binding closed");
      do {
        var res = this._handle.writeSync(
          flushFlag,
          chunk,
          // in
          inOff,
          // in_off
          availInBefore,
          // in_len
          this._buffer,
          // out
          this._offset,
          //out_off
          availOutBefore
        );
      } while (!this._hadError && callback(res[0], res[1]));
      if (this._hadError) {
        throw error;
      }
      if (nread >= kMaxLength4) {
        _close(this);
        throw new RangeError(kRangeErrorMessage);
      }
      var buf = Buffer5.concat(buffers, nread);
      _close(this);
      return buf;
    }
    assert3(this._handle, "zlib binding closed");
    var req = this._handle.write(
      flushFlag,
      chunk,
      // in
      inOff,
      // in_off
      availInBefore,
      // in_len
      this._buffer,
      // out
      this._offset,
      //out_off
      availOutBefore
    );
    req.buffer = chunk;
    req.callback = callback;
    function callback(availInAfter, availOutAfter) {
      if (this) {
        this.buffer = null;
        this.callback = null;
      }
      if (self2._hadError)
        return;
      var have = availOutBefore - availOutAfter;
      assert3(have >= 0, "have should not go down");
      if (have > 0) {
        var out = self2._buffer.slice(self2._offset, self2._offset + have);
        self2._offset += have;
        if (async) {
          self2.push(out);
        } else {
          buffers.push(out);
          nread += out.length;
        }
      }
      if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
        availOutBefore = self2._chunkSize;
        self2._offset = 0;
        self2._buffer = Buffer5.allocUnsafe(self2._chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        if (!async)
          return true;
        var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
        newReq.callback = callback;
        newReq.buffer = chunk;
        return;
      }
      if (!async)
        return false;
      cb();
    }
  };
  util3.inherits(Deflate, Zlib);
  util3.inherits(Inflate, Zlib);
  util3.inherits(Gzip, Zlib);
  util3.inherits(Gunzip, Zlib);
  util3.inherits(DeflateRaw, Zlib);
  util3.inherits(InflateRaw, Zlib);
  util3.inherits(Unzip, Zlib);
})(lib3);
var PDFReference = function(_stream$Writable) {
  _inheritsLoose(PDFReference2, _stream$Writable);
  function PDFReference2(document2, id, data2) {
    var _this;
    _this = _stream$Writable.call(this, {
      decodeStrings: false
    }) || this;
    _this.finalize = _this.finalize.bind(_assertThisInitialized(_this));
    _this.document = document2;
    _this.id = id;
    if (data2 == null) {
      data2 = {};
    }
    _this.data = data2;
    _this.gen = 0;
    _this.deflate = null;
    _this.compress = _this.document.compress && !_this.data.Filter;
    _this.uncompressedLength = 0;
    _this.chunks = [];
    return _this;
  }
  var _proto = PDFReference2.prototype;
  _proto.initDeflate = function initDeflate() {
    var _this2 = this;
    this.data.Filter = "FlateDecode";
    this.deflate = lib3.createDeflate();
    this.deflate.on("data", function(chunk) {
      _this2.chunks.push(chunk);
      return _this2.data.Length += chunk.length;
    });
    return this.deflate.on("end", this.finalize);
  };
  _proto._write = function _write(chunk, encoding, callback) {
    if (!(chunk instanceof Uint8Array)) {
      chunk = Buffer$4.from(chunk + "\n", "binary");
    }
    this.uncompressedLength += chunk.length;
    if (this.data.Length == null) {
      this.data.Length = 0;
    }
    if (this.compress) {
      if (!this.deflate) {
        this.initDeflate();
      }
      this.deflate.write(chunk);
    } else {
      this.chunks.push(chunk);
      this.data.Length += chunk.length;
    }
    return callback();
  };
  _proto.end = function end3() {
    _stream$Writable.prototype.end.apply(this, arguments);
    if (this.deflate) {
      return this.deflate.end();
    }
    return this.finalize();
  };
  _proto.finalize = function finalize() {
    this.offset = this.document._offset;
    this.document._write(this.id + " " + this.gen + " obj");
    this.document._write(PDFObject$1.convert(this.data));
    if (this.chunks.length) {
      this.document._write("stream");
      for (var _i = 0, _Array$from = Array.from(this.chunks); _i < _Array$from.length; _i++) {
        var chunk = _Array$from[_i];
        this.document._write(chunk);
      }
      this.chunks.length = 0;
      this.document._write("\nendstream");
    }
    this.document._write("endobj");
    return this.document._refEnd(this);
  };
  _proto.toString = function toString7() {
    return this.id + " " + this.gen + " R";
  };
  return PDFReference2;
}(stream.Writable);
var PDFTree = function() {
  function PDFTree2(options) {
    if (options === void 0) {
      options = {};
    }
    this._items = {};
    this.limits = typeof options.limits === "boolean" ? options.limits : true;
  }
  var _proto = PDFTree2.prototype;
  _proto.add = function add3(key, val) {
    return this._items[key] = val;
  };
  _proto.get = function get18(key) {
    return this._items[key];
  };
  _proto.toString = function toString7() {
    var _this = this;
    var sortedKeys = Object.keys(this._items).sort(function(a2, b) {
      return _this._compareKeys(a2, b);
    });
    var out = ["<<"];
    if (this.limits && sortedKeys.length > 1) {
      var first = sortedKeys[0];
      var last3 = sortedKeys[sortedKeys.length - 1];
      out.push("  /Limits " + PDFObject$1.convert([this._dataForKey(first), this._dataForKey(last3)]));
    }
    out.push("  /" + this._keysName() + " [");
    for (var _iterator = _createForOfIteratorHelperLoose(sortedKeys), _step; !(_step = _iterator()).done; ) {
      var key = _step.value;
      out.push("    " + PDFObject$1.convert(this._dataForKey(key)) + " " + PDFObject$1.convert(this._items[key]));
    }
    out.push("]");
    out.push(">>");
    return out.join("\n");
  };
  _proto._compareKeys = function _compareKeys() {
    throw new Error("Must be implemented by subclasses");
  };
  _proto._keysName = function _keysName() {
    throw new Error("Must be implemented by subclasses");
  };
  _proto._dataForKey = function _dataForKey() {
    throw new Error("Must be implemented by subclasses");
  };
  return PDFTree2;
}();
var PDFNameTree = function(_PDFTree) {
  _inheritsLoose(PDFNameTree2, _PDFTree);
  function PDFNameTree2() {
    return _PDFTree.apply(this, arguments) || this;
  }
  var _proto = PDFNameTree2.prototype;
  _proto._compareKeys = function _compareKeys(a2, b) {
    return a2.localeCompare(b);
  };
  _proto._keysName = function _keysName() {
    return "Names";
  };
  _proto._dataForKey = function _dataForKey(k) {
    return new String(k);
  };
  return PDFNameTree2;
}(PDFTree);
var escapableRe = /[\n\r\t\b\f\(\)\\]/g;
var escapable = {
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\b": "\\b",
  "\f": "\\f",
  "\\": "\\\\",
  "(": "\\(",
  ")": "\\)"
};
var pad = function pad2(str, length4) {
  return (Array(length4 + 1).join("0") + str).slice(-length4);
};
var swapBytes = function swapBytes2(buff) {
  var l2 = buff.length;
  if (l2 & 1) {
    throw new Error("Buffer length must be even");
  } else {
    for (var i = 0, end3 = l2 - 1; i < end3; i += 2) {
      var a2 = buff[i];
      buff[i] = buff[i + 1];
      buff[i + 1] = a2;
    }
  }
  return buff;
};
var PDFObject = function() {
  function PDFObject2() {
  }
  PDFObject2.convert = function convert(object) {
    if (typeof object === "string") {
      return "/" + object;
    }
    if (object instanceof String) {
      var string = object;
      var isUnicode = false;
      for (var i = 0, end3 = string.length; i < end3; i++) {
        if (string.charCodeAt(i) > 127) {
          isUnicode = true;
          break;
        }
      }
      if (isUnicode) {
        string = swapBytes(Buffer$4.from("\uFEFF" + string, "utf16le")).toString("binary");
      }
      string = string.replace(escapableRe, function(c2) {
        return escapable[c2];
      });
      return "(" + string + ")";
    }
    if (Buffer$4.isBuffer(object)) {
      return "<" + object.toString("hex") + ">";
    }
    if (object instanceof PDFReference || object instanceof PDFNameTree) {
      return object.toString();
    }
    if (object instanceof Date) {
      return "(D:" + pad(object.getUTCFullYear(), 4) + pad(object.getUTCMonth() + 1, 2) + pad(object.getUTCDate(), 2) + pad(object.getUTCHours(), 2) + pad(object.getUTCMinutes(), 2) + pad(object.getUTCSeconds(), 2) + "Z)";
    }
    if (Array.isArray(object)) {
      var items = Array.from(object).map(function(e) {
        return PDFObject2.convert(e);
      }).join(" ");
      return "[" + items + "]";
    }
    if ({}.toString.call(object) === "[object Object]") {
      var out = ["<<"];
      for (var key in object) {
        var val = object[key];
        out.push("/" + key + " " + PDFObject2.convert(val));
      }
      out.push(">>");
      return out.join("\n");
    }
    if (typeof object === "number") {
      return PDFObject2.number(object);
    }
    return "" + object;
  };
  PDFObject2.number = function number2(n) {
    if (n > -1e21 && n < 1e21) {
      return Math.round(n * 1e6) / 1e6;
    }
    throw new Error("unsupported number: " + n);
  };
  return PDFObject2;
}();
var PDFObject$1 = PDFObject;
var DEFAULT_MARGINS = {
  top: 0,
  left: 0,
  bottom: 0,
  right: 0
};
var SIZES = {
  "4A0": [4767.87, 6740.79],
  "2A0": [3370.39, 4767.87],
  A0: [2383.94, 3370.39],
  A1: [1683.78, 2383.94],
  A2: [1190.55, 1683.78],
  A3: [841.89, 1190.55],
  A4: [595.28, 841.89],
  A5: [419.53, 595.28],
  A6: [297.64, 419.53],
  A7: [209.76, 297.64],
  A8: [147.4, 209.76],
  A9: [104.88, 147.4],
  A10: [73.7, 104.88],
  B0: [2834.65, 4008.19],
  B1: [2004.09, 2834.65],
  B2: [1417.32, 2004.09],
  B3: [1000.63, 1417.32],
  B4: [708.66, 1000.63],
  B5: [498.9, 708.66],
  B6: [354.33, 498.9],
  B7: [249.45, 354.33],
  B8: [175.75, 249.45],
  B9: [124.72, 175.75],
  B10: [87.87, 124.72],
  C0: [2599.37, 3676.54],
  C1: [1836.85, 2599.37],
  C2: [1298.27, 1836.85],
  C3: [918.43, 1298.27],
  C4: [649.13, 918.43],
  C5: [459.21, 649.13],
  C6: [323.15, 459.21],
  C7: [229.61, 323.15],
  C8: [161.57, 229.61],
  C9: [113.39, 161.57],
  C10: [79.37, 113.39],
  RA0: [2437.8, 3458.27],
  RA1: [1729.13, 2437.8],
  RA2: [1218.9, 1729.13],
  RA3: [864.57, 1218.9],
  RA4: [609.45, 864.57],
  SRA0: [2551.18, 3628.35],
  SRA1: [1814.17, 2551.18],
  SRA2: [1275.59, 1814.17],
  SRA3: [907.09, 1275.59],
  SRA4: [637.8, 907.09],
  EXECUTIVE: [521.86, 756],
  FOLIO: [612, 936],
  LEGAL: [612, 1008],
  LETTER: [612, 792],
  TABLOID: [792, 1224]
};
var PDFPage = function() {
  function PDFPage2(document2, options) {
    if (options === void 0) {
      options = {};
    }
    this.document = document2;
    this.size = options.size || "letter";
    this.layout = options.layout || "portrait";
    this.userUnit = options.userUnit || 1;
    this.margins = DEFAULT_MARGINS;
    var dimensions = Array.isArray(this.size) ? this.size : SIZES[this.size.toUpperCase()];
    this.width = dimensions[this.layout === "portrait" ? 0 : 1];
    this.height = dimensions[this.layout === "portrait" ? 1 : 0];
    this.content = this.document.ref();
    this.resources = this.document.ref({
      ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"]
    });
    this.dictionary = this.document.ref({
      Type: "Page",
      Parent: this.document._root.data.Pages,
      MediaBox: [0, 0, this.width, this.height],
      Contents: this.content,
      Resources: this.resources,
      UserUnit: this.userUnit
    });
  }
  var _proto = PDFPage2.prototype;
  _proto.maxY = function maxY() {
    return this.height;
  };
  _proto.write = function write7(chunk) {
    return this.content.write(chunk);
  };
  _proto.end = function end3() {
    this.dictionary.end();
    this.resources.end();
    return this.content.end();
  };
  _createClass(PDFPage2, [{
    key: "fonts",
    get: function get18() {
      var data2 = this.resources.data;
      return data2.Font != null ? data2.Font : data2.Font = {};
    }
  }, {
    key: "xobjects",
    get: function get18() {
      var data2 = this.resources.data;
      return data2.XObject != null ? data2.XObject : data2.XObject = {};
    }
  }, {
    key: "ext_gstates",
    get: function get18() {
      var data2 = this.resources.data;
      return data2.ExtGState != null ? data2.ExtGState : data2.ExtGState = {};
    }
  }, {
    key: "patterns",
    get: function get18() {
      var data2 = this.resources.data;
      return data2.Pattern != null ? data2.Pattern : data2.Pattern = {};
    }
  }, {
    key: "colorSpaces",
    get: function get18() {
      var data2 = this.resources.data;
      return data2.ColorSpace || (data2.ColorSpace = {});
    }
  }, {
    key: "annotations",
    get: function get18() {
      var data2 = this.dictionary.data;
      return data2.Annots != null ? data2.Annots : data2.Annots = [];
    }
  }, {
    key: "structParentTreeKey",
    get: function get18() {
      var data2 = this.dictionary.data;
      return data2.StructParents != null ? data2.StructParents : data2.StructParents = this.document.createStructParentTreeNextKey();
    }
  }]);
  return PDFPage2;
}();
var wordArrayToBuffer = function wordArrayToBuffer2(wordArray) {
  var byteArray = [];
  for (var i = 0; i < wordArray.sigBytes; i++) {
    byteArray.push(wordArray.words[Math.floor(i / 4)] >> 8 * (3 - i % 4) & 255);
  }
  return Buffer$4.from(byteArray);
};
var PDFSecurity = function() {
  function PDFSecurity2() {
  }
  PDFSecurity2.generateFileID = function generateFileID(info) {
    if (info === void 0) {
      info = {};
    }
    var infoStr = info.CreationDate.getTime() + "\n";
    for (var key in info) {
      if (!info.hasOwnProperty(key))
        continue;
      infoStr += key + ": " + info[key].valueOf() + "\n";
    }
    return wordArrayToBuffer((0, import_md5.default)(infoStr));
  };
  return PDFSecurity2;
}();
var number$2 = PDFObject$1.number;
var PDFGradient$1 = function() {
  function PDFGradient2(doc) {
    this.doc = doc;
    this.stops = [];
    this.embedded = false;
    this.transform = [1, 0, 0, 1, 0, 0];
  }
  var _proto = PDFGradient2.prototype;
  _proto.stop = function stop(pos, color, opacity2) {
    if (opacity2 == null) {
      opacity2 = 1;
    }
    color = this.doc._normalizeColor(color);
    if (this.stops.length === 0) {
      if (color.length === 3) {
        this._colorSpace = "DeviceRGB";
      } else if (color.length === 4) {
        this._colorSpace = "DeviceCMYK";
      } else if (color.length === 1) {
        this._colorSpace = "DeviceGray";
      } else {
        throw new Error("Unknown color space");
      }
    } else if (this._colorSpace === "DeviceRGB" && color.length !== 3 || this._colorSpace === "DeviceCMYK" && color.length !== 4 || this._colorSpace === "DeviceGray" && color.length !== 1) {
      throw new Error("All gradient stops must use the same color space");
    }
    opacity2 = Math.max(0, Math.min(1, opacity2));
    this.stops.push([pos, color, opacity2]);
    return this;
  };
  _proto.setTransform = function setTransform(m11, m12, m21, m22, dx, dy) {
    this.transform = [m11, m12, m21, m22, dx, dy];
    return this;
  };
  _proto.embed = function embed(m2) {
    var fn;
    var stopsLength = this.stops.length;
    if (stopsLength === 0) {
      return;
    }
    this.embedded = true;
    this.matrix = m2;
    var last3 = this.stops[stopsLength - 1];
    if (last3[0] < 1) {
      this.stops.push([1, last3[1], last3[2]]);
    }
    var bounds = [];
    var encode = [];
    var stops = [];
    for (var i = 0; i < stopsLength - 1; i++) {
      encode.push(0, 1);
      if (i + 2 !== stopsLength) {
        bounds.push(this.stops[i + 1][0]);
      }
      fn = this.doc.ref({
        FunctionType: 2,
        Domain: [0, 1],
        C0: this.stops[i + 0][1],
        C1: this.stops[i + 1][1],
        N: 1
      });
      stops.push(fn);
      fn.end();
    }
    if (stopsLength === 1) {
      fn = stops[0];
    } else {
      fn = this.doc.ref({
        FunctionType: 3,
        // stitching function
        Domain: [0, 1],
        Functions: stops,
        Bounds: bounds,
        Encode: encode
      });
      fn.end();
    }
    this.id = "Sh" + ++this.doc._gradCount;
    var shader = this.shader(fn);
    shader.end();
    var pattern2 = this.doc.ref({
      Type: "Pattern",
      PatternType: 2,
      Shading: shader,
      Matrix: this.matrix.map(number$2)
    });
    pattern2.end();
    if (this.stops.some(function(stop2) {
      return stop2[2] < 1;
    })) {
      var grad = this.opacityGradient();
      grad._colorSpace = "DeviceGray";
      for (var _iterator = _createForOfIteratorHelperLoose(this.stops), _step; !(_step = _iterator()).done; ) {
        var stop = _step.value;
        grad.stop(stop[0], [stop[2]]);
      }
      grad = grad.embed(this.matrix);
      var pageBBox = [0, 0, this.doc.page.width, this.doc.page.height];
      var form = this.doc.ref({
        Type: "XObject",
        Subtype: "Form",
        FormType: 1,
        BBox: pageBBox,
        Group: {
          Type: "Group",
          S: "Transparency",
          CS: "DeviceGray"
        },
        Resources: {
          ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"],
          Pattern: {
            Sh1: grad
          }
        }
      });
      form.write("/Pattern cs /Sh1 scn");
      form.end(pageBBox.join(" ") + " re f");
      var gstate = this.doc.ref({
        Type: "ExtGState",
        SMask: {
          Type: "Mask",
          S: "Luminosity",
          G: form
        }
      });
      gstate.end();
      var opacityPattern = this.doc.ref({
        Type: "Pattern",
        PatternType: 1,
        PaintType: 1,
        TilingType: 2,
        BBox: pageBBox,
        XStep: pageBBox[2],
        YStep: pageBBox[3],
        Resources: {
          ProcSet: ["PDF", "Text", "ImageB", "ImageC", "ImageI"],
          Pattern: {
            Sh1: pattern2
          },
          ExtGState: {
            Gs1: gstate
          }
        }
      });
      opacityPattern.write("/Gs1 gs /Pattern cs /Sh1 scn");
      opacityPattern.end(pageBBox.join(" ") + " re f");
      this.doc.page.patterns[this.id] = opacityPattern;
    } else {
      this.doc.page.patterns[this.id] = pattern2;
    }
    return pattern2;
  };
  _proto.apply = function apply2(op) {
    var _this$doc$_ctm = this.doc._ctm, m0 = _this$doc$_ctm[0], m1 = _this$doc$_ctm[1], m2 = _this$doc$_ctm[2], m3 = _this$doc$_ctm[3], m4 = _this$doc$_ctm[4], m5 = _this$doc$_ctm[5];
    var _this$transform = this.transform, m11 = _this$transform[0], m12 = _this$transform[1], m21 = _this$transform[2], m22 = _this$transform[3], dx = _this$transform[4], dy = _this$transform[5];
    var m6 = [m0 * m11 + m2 * m12, m1 * m11 + m3 * m12, m0 * m21 + m2 * m22, m1 * m21 + m3 * m22, m0 * dx + m2 * dy + m4, m1 * dx + m3 * dy + m5];
    if (!this.embedded || m6.join(" ") !== this.matrix.join(" ")) {
      this.embed(m6);
    }
    return this.doc.addContent("/" + this.id + " " + op);
  };
  return PDFGradient2;
}();
var PDFLinearGradient$1 = function(_PDFGradient) {
  _inheritsLoose(PDFLinearGradient2, _PDFGradient);
  function PDFLinearGradient2(doc, x1, y1, x2, y2) {
    var _this;
    _this = _PDFGradient.call(this, doc) || this;
    _this.x1 = x1;
    _this.y1 = y1;
    _this.x2 = x2;
    _this.y2 = y2;
    return _this;
  }
  var _proto2 = PDFLinearGradient2.prototype;
  _proto2.shader = function shader(fn) {
    return this.doc.ref({
      ShadingType: 2,
      ColorSpace: this._colorSpace,
      Coords: [this.x1, this.y1, this.x2, this.y2],
      Function: fn,
      Extend: [true, true]
    });
  };
  _proto2.opacityGradient = function opacityGradient() {
    return new PDFLinearGradient2(this.doc, this.x1, this.y1, this.x2, this.y2);
  };
  return PDFLinearGradient2;
}(PDFGradient$1);
var PDFRadialGradient$1 = function(_PDFGradient2) {
  _inheritsLoose(PDFRadialGradient2, _PDFGradient2);
  function PDFRadialGradient2(doc, x1, y1, r1, x2, y2, r2) {
    var _this2;
    _this2 = _PDFGradient2.call(this, doc) || this;
    _this2.doc = doc;
    _this2.x1 = x1;
    _this2.y1 = y1;
    _this2.r1 = r1;
    _this2.x2 = x2;
    _this2.y2 = y2;
    _this2.r2 = r2;
    return _this2;
  }
  var _proto3 = PDFRadialGradient2.prototype;
  _proto3.shader = function shader(fn) {
    return this.doc.ref({
      ShadingType: 3,
      ColorSpace: this._colorSpace,
      Coords: [this.x1, this.y1, this.r1, this.x2, this.y2, this.r2],
      Function: fn,
      Extend: [true, true]
    });
  };
  _proto3.opacityGradient = function opacityGradient() {
    return new PDFRadialGradient2(this.doc, this.x1, this.y1, this.r1, this.x2, this.y2, this.r2);
  };
  return PDFRadialGradient2;
}(PDFGradient$1);
var Gradient = {
  PDFGradient: PDFGradient$1,
  PDFLinearGradient: PDFLinearGradient$1,
  PDFRadialGradient: PDFRadialGradient$1
};
var PDFGradient = Gradient.PDFGradient;
var PDFLinearGradient = Gradient.PDFLinearGradient;
var PDFRadialGradient = Gradient.PDFRadialGradient;
var ColorMixin = {
  initColor: function initColor() {
    this._opacityRegistry = {};
    this._opacityCount = 0;
    return this._gradCount = 0;
  },
  _normalizeColor: function _normalizeColor(color) {
    if (color instanceof PDFGradient) {
      return color;
    }
    var part;
    if (typeof color === "string") {
      if (color.charAt(0) === "#") {
        if (color.length === 4) {
          color = color.replace(/#([0-9A-F])([0-9A-F])([0-9A-F])/i, "#$1$1$2$2$3$3");
        }
        var hex = parseInt(color.slice(1), 16);
        color = [hex >> 16, hex >> 8 & 255, hex & 255];
      } else if (namedColors[color]) {
        color = namedColors[color];
      }
    }
    if (Array.isArray(color)) {
      if (color.length === 3) {
        color = function() {
          var result = [];
          for (var _i = 0, _Array$from = Array.from(color); _i < _Array$from.length; _i++) {
            part = _Array$from[_i];
            result.push(part / 255);
          }
          return result;
        }();
      } else if (color.length === 4) {
        color = function() {
          var result1 = [];
          for (var _i2 = 0, _Array$from2 = Array.from(color); _i2 < _Array$from2.length; _i2++) {
            part = _Array$from2[_i2];
            result1.push(part / 100);
          }
          return result1;
        }();
      }
      return color;
    }
    return null;
  },
  _setColor: function _setColor(color, stroke2) {
    color = this._normalizeColor(color);
    if (!color) {
      return false;
    }
    var op = stroke2 ? "SCN" : "scn";
    if (color instanceof PDFGradient) {
      this._setColorSpace("Pattern", stroke2);
      color.apply(op);
    } else {
      var space = color.length === 4 ? "DeviceCMYK" : "DeviceRGB";
      this._setColorSpace(space, stroke2);
      color = color.join(" ");
      this.addContent(color + " " + op);
    }
    return true;
  },
  _setColorSpace: function _setColorSpace(space, stroke2) {
    var op = stroke2 ? "CS" : "cs";
    return this.addContent("/" + space + " " + op);
  },
  fillColor: function fillColor(color, opacity2) {
    var set7 = this._setColor(color, false);
    if (set7) {
      this.fillOpacity(opacity2);
    }
    this._fillColor = [color, opacity2];
    return this;
  },
  strokeColor: function strokeColor(color, opacity2) {
    var set7 = this._setColor(color, true);
    if (set7) {
      this.strokeOpacity(opacity2);
    }
    return this;
  },
  opacity: function opacity(_opacity) {
    this._doOpacity(_opacity, _opacity);
    return this;
  },
  fillOpacity: function fillOpacity(opacity2) {
    this._doOpacity(opacity2, null);
    return this;
  },
  strokeOpacity: function strokeOpacity(opacity2) {
    this._doOpacity(null, opacity2);
    return this;
  },
  _doOpacity: function _doOpacity(fillOpacity2, strokeOpacity2) {
    var dictionary, name;
    if (fillOpacity2 == null && strokeOpacity2 == null) {
      return;
    }
    if (fillOpacity2 != null) {
      fillOpacity2 = Math.max(0, Math.min(1, fillOpacity2));
    }
    if (strokeOpacity2 != null) {
      strokeOpacity2 = Math.max(0, Math.min(1, strokeOpacity2));
    }
    var key = fillOpacity2 + "_" + strokeOpacity2;
    if (this._opacityRegistry[key]) {
      var _Array$from3 = Array.from(this._opacityRegistry[key]);
      dictionary = _Array$from3[0];
      name = _Array$from3[1];
    } else {
      dictionary = {
        Type: "ExtGState"
      };
      if (fillOpacity2 != null) {
        dictionary.ca = fillOpacity2;
      }
      if (strokeOpacity2 != null) {
        dictionary.CA = strokeOpacity2;
      }
      dictionary = this.ref(dictionary);
      dictionary.end();
      var id = ++this._opacityCount;
      name = "Gs" + id;
      this._opacityRegistry[key] = [dictionary, name];
    }
    this.page.ext_gstates[name] = dictionary;
    return this.addContent("/" + name + " gs");
  },
  linearGradient: function linearGradient(x1, y1, x2, y2) {
    return new PDFLinearGradient(this, x1, y1, x2, y2);
  },
  radialGradient: function radialGradient(x1, y1, r1, x2, y2, r2) {
    return new PDFRadialGradient(this, x1, y1, r1, x2, y2, r2);
  }
};
var namedColors = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  grey: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
var cx;
var cy;
var px;
var py;
var sx;
var sy;
cx = cy = px = py = sx = sy = 0;
var argsCountPerCommand = {
  M: 2,
  m: 2,
  Z: 0,
  z: 0,
  L: 2,
  l: 2,
  H: 1,
  h: 1,
  V: 1,
  v: 1,
  C: 6,
  c: 6,
  S: 4,
  s: 4,
  Q: 4,
  q: 4,
  T: 2,
  t: 2,
  A: 7,
  a: 7
};
var isCommand = function isCommand2(c2) {
  return c2 in argsCountPerCommand;
};
var isWsp = function isWsp2(c2) {
  var codePoint = c2.codePointAt(0);
  return codePoint === 32 || codePoint === 9 || codePoint === 13 || codePoint === 10;
};
var isDigit = function isDigit2(c2) {
  var codePoint = c2.codePointAt(0);
  if (codePoint == null) {
    return false;
  }
  return 48 <= codePoint && codePoint <= 57;
};
var readNumber = function readNumber2(string, cursor) {
  var i = cursor;
  var value2 = "";
  var state2 = (
    /** @type {ReadNumberState} */
    "none"
  );
  for (; i < string.length; i += 1) {
    var c2 = string[i];
    if (c2 === "+" || c2 === "-") {
      if (state2 === "none") {
        state2 = "sign";
        value2 += c2;
        continue;
      }
      if (state2 === "e") {
        state2 = "exponent_sign";
        value2 += c2;
        continue;
      }
    }
    if (isDigit(c2)) {
      if (state2 === "none" || state2 === "sign" || state2 === "whole") {
        state2 = "whole";
        value2 += c2;
        continue;
      }
      if (state2 === "decimal_point" || state2 === "decimal") {
        state2 = "decimal";
        value2 += c2;
        continue;
      }
      if (state2 === "e" || state2 === "exponent_sign" || state2 === "exponent") {
        state2 = "exponent";
        value2 += c2;
        continue;
      }
    }
    if (c2 === ".") {
      if (state2 === "none" || state2 === "sign" || state2 === "whole") {
        state2 = "decimal_point";
        value2 += c2;
        continue;
      }
    }
    if (c2 === "E" || c2 === "e") {
      if (state2 === "whole" || state2 === "decimal_point" || state2 === "decimal") {
        state2 = "e";
        value2 += c2;
        continue;
      }
    }
    break;
  }
  var number2 = Number.parseFloat(value2);
  if (Number.isNaN(number2)) {
    return [cursor, null];
  } else {
    return [i - 1, number2];
  }
};
var parsePathData = function parsePathData2(string) {
  var pathData = [];
  var command = null;
  var args = (
    /** @type {number[]} */
    []
  );
  var argsCount = 0;
  var canHaveComma = false;
  var hadComma = false;
  for (var i = 0; i < string.length; i += 1) {
    var c2 = string.charAt(i);
    if (isWsp(c2)) {
      continue;
    }
    if (canHaveComma && c2 === ",") {
      if (hadComma) {
        break;
      }
      hadComma = true;
      continue;
    }
    if (isCommand(c2)) {
      if (hadComma) {
        return pathData;
      }
      if (command == null) {
        if (c2 !== "M" && c2 !== "m") {
          return pathData;
        }
      } else {
        if (args.length !== 0) {
          return pathData;
        }
      }
      command = c2;
      args = [];
      argsCount = argsCountPerCommand[command];
      canHaveComma = false;
      if (argsCount === 0) {
        pathData.push({
          command,
          args
        });
      }
      continue;
    }
    if (command == null) {
      return pathData;
    }
    var newCursor = i;
    var number2 = null;
    if (command === "A" || command === "a") {
      var position = args.length;
      if (position === 0 || position === 1) {
        if (c2 !== "+" && c2 !== "-") {
          var _readNumber = readNumber(string, i);
          newCursor = _readNumber[0];
          number2 = _readNumber[1];
        }
      }
      if (position === 2 || position === 5 || position === 6) {
        var _readNumber2 = readNumber(string, i);
        newCursor = _readNumber2[0];
        number2 = _readNumber2[1];
      }
      if (position === 3 || position === 4) {
        if (c2 === "0") {
          number2 = 0;
        }
        if (c2 === "1") {
          number2 = 1;
        }
      }
    } else {
      var _readNumber3 = readNumber(string, i);
      newCursor = _readNumber3[0];
      number2 = _readNumber3[1];
    }
    if (number2 == null) {
      return pathData;
    }
    args.push(number2);
    canHaveComma = true;
    hadComma = false;
    i = newCursor;
    if (args.length === argsCount) {
      pathData.push({
        command,
        args
      });
      if (command === "M") {
        command = "L";
      }
      if (command === "m") {
        command = "l";
      }
      args = [];
    }
  }
  return pathData;
};
var _apply = function apply(commands, doc) {
  cx = cy = px = py = sx = sy = 0;
  for (var i = 0; i < commands.length; i++) {
    var _commands$i = commands[i], command = _commands$i.command, args = _commands$i.args;
    if (typeof runners[command] === "function") {
      runners[command](doc, args);
    }
  }
};
var runners = {
  M: function M(doc, a2) {
    cx = a2[0];
    cy = a2[1];
    px = py = null;
    sx = cx;
    sy = cy;
    return doc.moveTo(cx, cy);
  },
  m: function m(doc, a2) {
    cx += a2[0];
    cy += a2[1];
    px = py = null;
    sx = cx;
    sy = cy;
    return doc.moveTo(cx, cy);
  },
  C: function C(doc, a2) {
    cx = a2[4];
    cy = a2[5];
    px = a2[2];
    py = a2[3];
    return doc.bezierCurveTo.apply(doc, a2);
  },
  c: function c(doc, a2) {
    doc.bezierCurveTo(a2[0] + cx, a2[1] + cy, a2[2] + cx, a2[3] + cy, a2[4] + cx, a2[5] + cy);
    px = cx + a2[2];
    py = cy + a2[3];
    cx += a2[4];
    return cy += a2[5];
  },
  S: function S(doc, a2) {
    if (px === null) {
      px = cx;
      py = cy;
    }
    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), a2[0], a2[1], a2[2], a2[3]);
    px = a2[0];
    py = a2[1];
    cx = a2[2];
    return cy = a2[3];
  },
  s: function s(doc, a2) {
    if (px === null) {
      px = cx;
      py = cy;
    }
    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), cx + a2[0], cy + a2[1], cx + a2[2], cy + a2[3]);
    px = cx + a2[0];
    py = cy + a2[1];
    cx += a2[2];
    return cy += a2[3];
  },
  Q: function Q(doc, a2) {
    px = a2[0];
    py = a2[1];
    cx = a2[2];
    cy = a2[3];
    return doc.quadraticCurveTo(a2[0], a2[1], cx, cy);
  },
  q: function q(doc, a2) {
    doc.quadraticCurveTo(a2[0] + cx, a2[1] + cy, a2[2] + cx, a2[3] + cy);
    px = cx + a2[0];
    py = cy + a2[1];
    cx += a2[2];
    return cy += a2[3];
  },
  T: function T(doc, a2) {
    if (px === null) {
      px = cx;
      py = cy;
    } else {
      px = cx - (px - cx);
      py = cy - (py - cy);
    }
    doc.quadraticCurveTo(px, py, a2[0], a2[1]);
    px = cx - (px - cx);
    py = cy - (py - cy);
    cx = a2[0];
    return cy = a2[1];
  },
  t: function t(doc, a2) {
    if (px === null) {
      px = cx;
      py = cy;
    } else {
      px = cx - (px - cx);
      py = cy - (py - cy);
    }
    doc.quadraticCurveTo(px, py, cx + a2[0], cy + a2[1]);
    cx += a2[0];
    return cy += a2[1];
  },
  A: function A(doc, a2) {
    solveArc(doc, cx, cy, a2);
    cx = a2[5];
    return cy = a2[6];
  },
  a: function a(doc, _a) {
    _a[5] += cx;
    _a[6] += cy;
    solveArc(doc, cx, cy, _a);
    cx = _a[5];
    return cy = _a[6];
  },
  L: function L(doc, a2) {
    cx = a2[0];
    cy = a2[1];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  l: function l(doc, a2) {
    cx += a2[0];
    cy += a2[1];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  H: function H(doc, a2) {
    cx = a2[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  h: function h(doc, a2) {
    cx += a2[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  V: function V(doc, a2) {
    cy = a2[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  v: function v(doc, a2) {
    cy += a2[0];
    px = py = null;
    return doc.lineTo(cx, cy);
  },
  Z: function Z(doc) {
    doc.closePath();
    cx = sx;
    return cy = sy;
  },
  z: function z(doc) {
    doc.closePath();
    cx = sx;
    return cy = sy;
  }
};
var solveArc = function solveArc2(doc, x, y, coords) {
  var rx = coords[0], ry = coords[1], rot = coords[2], large = coords[3], sweep = coords[4], ex = coords[5], ey = coords[6];
  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);
  for (var _iterator = _createForOfIteratorHelperLoose(segs), _step; !(_step = _iterator()).done; ) {
    var seg = _step.value;
    var bez = segmentToBezier.apply(void 0, seg);
    doc.bezierCurveTo.apply(doc, bez);
  }
};
var arcToSegments = function arcToSegments2(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
  var th = rotateX * (Math.PI / 180);
  var sin_th = Math.sin(th);
  var cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;
  py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
  var pl = px * px / (rx * rx) + py * py / (ry * ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }
  var a00 = cos_th / rx;
  var a01 = sin_th / rx;
  var a10 = -sin_th / ry;
  var a11 = cos_th / ry;
  var x0 = a00 * ox + a01 * oy;
  var y0 = a10 * ox + a11 * oy;
  var x1 = a00 * x + a01 * y;
  var y1 = a10 * x + a11 * y;
  var d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
  var sfactor_sq = 1 / d - 0.25;
  if (sfactor_sq < 0) {
    sfactor_sq = 0;
  }
  var sfactor = Math.sqrt(sfactor_sq);
  if (sweep === large) {
    sfactor = -sfactor;
  }
  var xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
  var yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
  var th0 = Math.atan2(y0 - yc, x0 - xc);
  var th1 = Math.atan2(y1 - yc, x1 - xc);
  var th_arc = th1 - th0;
  if (th_arc < 0 && sweep === 1) {
    th_arc += 2 * Math.PI;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= 2 * Math.PI;
  }
  var segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 1e-3)));
  var result = [];
  for (var i = 0; i < segments; i++) {
    var th2 = th0 + i * th_arc / segments;
    var th3 = th0 + (i + 1) * th_arc / segments;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return result;
};
var segmentToBezier = function segmentToBezier2(cx2, cy2, th0, th1, rx, ry, sin_th, cos_th) {
  var a00 = cos_th * rx;
  var a01 = -sin_th * ry;
  var a10 = sin_th * rx;
  var a11 = cos_th * ry;
  var th_half = 0.5 * (th1 - th0);
  var t2 = 8 / 3 * Math.sin(th_half * 0.5) * Math.sin(th_half * 0.5) / Math.sin(th_half);
  var x1 = cx2 + Math.cos(th0) - t2 * Math.sin(th0);
  var y1 = cy2 + Math.sin(th0) + t2 * Math.cos(th0);
  var x3 = cx2 + Math.cos(th1);
  var y3 = cy2 + Math.sin(th1);
  var x2 = x3 + t2 * Math.sin(th1);
  var y2 = y3 - t2 * Math.cos(th1);
  return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
};
var SVGPath = function() {
  function SVGPath2() {
  }
  SVGPath2.apply = function apply2(doc, path2) {
    var commands = parsePathData(path2);
    _apply(commands, doc);
  };
  return SVGPath2;
}();
var number$1 = PDFObject$1.number;
var KAPPA2 = 4 * ((Math.sqrt(2) - 1) / 3);
var VectorMixin = {
  initVector: function initVector() {
    this._ctm = [1, 0, 0, 1, 0, 0];
    return this._ctmStack = [];
  },
  save: function save() {
    this._ctmStack.push(this._ctm.slice());
    return this.addContent("q");
  },
  restore: function restore() {
    this._ctm = this._ctmStack.pop() || [1, 0, 0, 1, 0, 0];
    return this.addContent("Q");
  },
  closePath: function closePath() {
    return this.addContent("h");
  },
  lineWidth: function lineWidth(w) {
    return this.addContent(number$1(w) + " w");
  },
  _CAP_STYLES: {
    BUTT: 0,
    ROUND: 1,
    SQUARE: 2
  },
  lineCap: function lineCap(c2) {
    if (typeof c2 === "string") {
      c2 = this._CAP_STYLES[c2.toUpperCase()];
    }
    return this.addContent(c2 + " J");
  },
  _JOIN_STYLES: {
    MITER: 0,
    ROUND: 1,
    BEVEL: 2
  },
  lineJoin: function lineJoin(j) {
    if (typeof j === "string") {
      j = this._JOIN_STYLES[j.toUpperCase()];
    }
    return this.addContent(j + " j");
  },
  miterLimit: function miterLimit(m2) {
    return this.addContent(number$1(m2) + " M");
  },
  dash: function dash(length4, options) {
    var phase;
    if (options == null) {
      options = {};
    }
    if (length4 == null) {
      return this;
    }
    if (Array.isArray(length4)) {
      length4 = Array.from(length4).map(function(v2) {
        return PDFObject$1.number(v2);
      }).join(" ");
      phase = options.phase || 0;
      return this.addContent("[" + length4 + "] " + PDFObject$1.number(phase) + " d");
    }
    var space = options.space != null ? options.space : length4;
    phase = options.phase || 0;
    return this.addContent("[" + PDFObject$1.number(length4) + " " + PDFObject$1.number(space) + "] " + PDFObject$1.number(phase) + " d");
  },
  undash: function undash() {
    return this.addContent("[] 0 d");
  },
  moveTo: function moveTo(x, y) {
    return this.addContent(number$1(x) + " " + number$1(y) + " m");
  },
  lineTo: function lineTo(x, y) {
    return this.addContent(number$1(x) + " " + number$1(y) + " l");
  },
  bezierCurveTo: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    return this.addContent(number$1(cp1x) + " " + number$1(cp1y) + " " + number$1(cp2x) + " " + number$1(cp2y) + " " + number$1(x) + " " + number$1(y) + " c");
  },
  quadraticCurveTo: function quadraticCurveTo(cpx, cpy, x, y) {
    return this.addContent(number$1(cpx) + " " + number$1(cpy) + " " + number$1(x) + " " + number$1(y) + " v");
  },
  rect: function rect(x, y, w, h2) {
    return this.addContent(number$1(x) + " " + number$1(y) + " " + number$1(w) + " " + number$1(h2) + " re");
  },
  roundedRect: function roundedRect(x, y, w, h2, r) {
    if (r == null) {
      r = 0;
    }
    r = Math.min(r, 0.5 * w, 0.5 * h2);
    var c2 = r * (1 - KAPPA2);
    this.moveTo(x + r, y);
    this.lineTo(x + w - r, y);
    this.bezierCurveTo(x + w - c2, y, x + w, y + c2, x + w, y + r);
    this.lineTo(x + w, y + h2 - r);
    this.bezierCurveTo(x + w, y + h2 - c2, x + w - c2, y + h2, x + w - r, y + h2);
    this.lineTo(x + r, y + h2);
    this.bezierCurveTo(x + c2, y + h2, x, y + h2 - c2, x, y + h2 - r);
    this.lineTo(x, y + r);
    this.bezierCurveTo(x, y + c2, x + c2, y, x + r, y);
    return this.closePath();
  },
  ellipse: function ellipse(x, y, r1, r2) {
    if (r2 == null) {
      r2 = r1;
    }
    x -= r1;
    y -= r2;
    var ox = r1 * KAPPA2;
    var oy = r2 * KAPPA2;
    var xe = x + r1 * 2;
    var ye = y + r2 * 2;
    var xm = x + r1;
    var ym = y + r2;
    this.moveTo(x, ym);
    this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
    this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
    this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
    this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
    return this.closePath();
  },
  circle: function circle(x, y, radius) {
    return this.ellipse(x, y, radius);
  },
  arc: function arc(x, y, radius, startAngle, endAngle, anticlockwise) {
    if (anticlockwise == null) {
      anticlockwise = false;
    }
    var TWO_PI = 2 * Math.PI;
    var HALF_PI = 0.5 * Math.PI;
    var deltaAng = endAngle - startAngle;
    if (Math.abs(deltaAng) > TWO_PI) {
      deltaAng = TWO_PI;
    } else if (deltaAng !== 0 && anticlockwise !== deltaAng < 0) {
      var dir = anticlockwise ? -1 : 1;
      deltaAng = dir * TWO_PI + deltaAng;
    }
    var numSegs = Math.ceil(Math.abs(deltaAng) / HALF_PI);
    var segAng = deltaAng / numSegs;
    var handleLen = segAng / HALF_PI * KAPPA2 * radius;
    var curAng = startAngle;
    var deltaCx = -Math.sin(curAng) * handleLen;
    var deltaCy = Math.cos(curAng) * handleLen;
    var ax = x + Math.cos(curAng) * radius;
    var ay = y + Math.sin(curAng) * radius;
    this.moveTo(ax, ay);
    for (var segIdx = 0, end3 = numSegs, asc = 0 <= end3; asc ? segIdx < end3 : segIdx > end3; asc ? segIdx++ : segIdx--) {
      var cp1x = ax + deltaCx;
      var cp1y = ay + deltaCy;
      curAng += segAng;
      ax = x + Math.cos(curAng) * radius;
      ay = y + Math.sin(curAng) * radius;
      deltaCx = -Math.sin(curAng) * handleLen;
      deltaCy = Math.cos(curAng) * handleLen;
      var cp2x = ax - deltaCx;
      var cp2y = ay - deltaCy;
      this.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ax, ay);
    }
    return this;
  },
  polygon: function polygon() {
    for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {
      points[_key] = arguments[_key];
    }
    this.moveTo.apply(this, Array.from(points.shift() || []));
    for (var _i = 0, _Array$from = Array.from(points); _i < _Array$from.length; _i++) {
      var point = _Array$from[_i];
      this.lineTo.apply(this, Array.from(point || []));
    }
    return this.closePath();
  },
  path: function path(_path) {
    SVGPath.apply(this, _path);
    return this;
  },
  _windingRule: function _windingRule(rule) {
    if (/even-?odd/.test(rule)) {
      return "*";
    }
    return "";
  },
  fill: function fill3(color, rule) {
    if (/(even-?odd)|(non-?zero)/.test(color)) {
      rule = color;
      color = null;
    }
    if (color) {
      this.fillColor(color);
    }
    return this.addContent("f" + this._windingRule(rule));
  },
  stroke: function stroke(color) {
    if (color) {
      this.strokeColor(color);
    }
    return this.addContent("S");
  },
  fillAndStroke: function fillAndStroke(fillColor2, strokeColor2, rule) {
    if (strokeColor2 == null) {
      strokeColor2 = fillColor2;
    }
    var isFillRule = /(even-?odd)|(non-?zero)/;
    if (isFillRule.test(fillColor2)) {
      rule = fillColor2;
      fillColor2 = null;
    }
    if (isFillRule.test(strokeColor2)) {
      rule = strokeColor2;
      strokeColor2 = fillColor2;
    }
    if (fillColor2) {
      this.fillColor(fillColor2);
      this.strokeColor(strokeColor2);
    }
    return this.addContent("B" + this._windingRule(rule));
  },
  clip: function clip(rule) {
    return this.addContent("W" + this._windingRule(rule) + " n");
  },
  transform: function transform(m11, m12, m21, m22, dx, dy) {
    var m2 = this._ctm;
    var _Array$from2 = Array.from(m2), m0 = _Array$from2[0], m1 = _Array$from2[1], m23 = _Array$from2[2], m3 = _Array$from2[3], m4 = _Array$from2[4], m5 = _Array$from2[5];
    m2[0] = m0 * m11 + m23 * m12;
    m2[1] = m1 * m11 + m3 * m12;
    m2[2] = m0 * m21 + m23 * m22;
    m2[3] = m1 * m21 + m3 * m22;
    m2[4] = m0 * dx + m23 * dy + m4;
    m2[5] = m1 * dx + m3 * dy + m5;
    var values = [m11, m12, m21, m22, dx, dy].map(function(v2) {
      return PDFObject$1.number(v2);
    }).join(" ");
    return this.addContent(values + " cm");
  },
  translate: function translate(x, y) {
    return this.transform(1, 0, 0, 1, x, y);
  },
  rotate: function rotate(angle, options) {
    if (options === void 0) {
      options = {};
    }
    var rad = angle * Math.PI / 180;
    var cos = Math.cos(rad);
    var sin = Math.sin(rad);
    var x = 0;
    var y = 0;
    if (options.origin != null) {
      var _Array$from3 = Array.from(options.origin);
      x = _Array$from3[0];
      y = _Array$from3[1];
      var x1 = x * cos - y * sin;
      var y1 = x * sin + y * cos;
      x -= x1;
      y -= y1;
    }
    return this.transform(cos, sin, -sin, cos, x, y);
  },
  scale: function scale(xFactor, yFactor, options) {
    if (options === void 0) {
      options = {};
    }
    if (yFactor == null) {
      yFactor = xFactor;
    }
    if (typeof yFactor === "object") {
      options = yFactor;
      yFactor = xFactor;
    }
    var x = 0;
    var y = 0;
    if (options.origin != null) {
      var _Array$from4 = Array.from(options.origin);
      x = _Array$from4[0];
      y = _Array$from4[1];
      x -= xFactor * x;
      y -= yFactor * y;
    }
    return this.transform(xFactor, 0, 0, yFactor, x, y);
  },
  skew: function skew(xAngle, yAngle, options) {
    if (xAngle === void 0) {
      xAngle = 0;
    }
    if (yAngle === void 0) {
      yAngle = 0;
    }
    var radx = xAngle * Math.PI / 180;
    var rady = yAngle * Math.PI / 180;
    var tanx = Math.tan(radx);
    var tany = Math.tan(rady);
    var x = 0;
    var y = 0;
    if (options.origin != null) {
      var _Array$from5 = Array.from(options.origin);
      x = _Array$from5[0];
      y = _Array$from5[1];
      var x1 = x + tanx * y;
      var y1 = y + tany * x;
      x -= x1;
      y -= y1;
    }
    return this.transform(1, tany, tanx, 1, x, y);
  }
};
var range = function range2(left, right, inclusive) {
  var range3 = [];
  var ascending = left < right;
  var end3 = !inclusive ? right : ascending ? right + 1 : right - 1;
  for (var i = left; ascending ? i < end3 : i > end3; ascending ? i++ : i--) {
    range3.push(i);
  }
  return range3;
};
var WIN_ANSI_MAP = {
  402: 131,
  8211: 150,
  8212: 151,
  8216: 145,
  8217: 146,
  8218: 130,
  8220: 147,
  8221: 148,
  8222: 132,
  8224: 134,
  8225: 135,
  8226: 149,
  8230: 133,
  8364: 128,
  8240: 137,
  8249: 139,
  8250: 155,
  710: 136,
  8482: 153,
  338: 140,
  339: 156,
  732: 152,
  352: 138,
  353: 154,
  376: 159,
  381: 142,
  382: 158
};
var characters = ".notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n.notdef       .notdef        .notdef        .notdef\n\nspace         exclam         quotedbl       numbersign\ndollar        percent        ampersand      quotesingle\nparenleft     parenright     asterisk       plus\ncomma         hyphen         period         slash\nzero          one            two            three\nfour          five           six            seven\neight         nine           colon          semicolon\nless          equal          greater        question\n\nat            A              B              C\nD             E              F              G\nH             I              J              K\nL             M              N              O\nP             Q              R              S\nT             U              V              W\nX             Y              Z              bracketleft\nbackslash     bracketright   asciicircum    underscore\n\ngrave         a              b              c\nd             e              f              g\nh             i              j              k\nl             m              n              o\np             q              r              s\nt             u              v              w\nx             y              z              braceleft\nbar           braceright     asciitilde     .notdef\n\nEuro          .notdef        quotesinglbase florin\nquotedblbase  ellipsis       dagger         daggerdbl\ncircumflex    perthousand    Scaron         guilsinglleft\nOE            .notdef        Zcaron         .notdef\n.notdef       quoteleft      quoteright     quotedblleft\nquotedblright bullet         endash         emdash\ntilde         trademark      scaron         guilsinglright\noe            .notdef        zcaron         ydieresis\n\nspace         exclamdown     cent           sterling\ncurrency      yen            brokenbar      section\ndieresis      copyright      ordfeminine    guillemotleft\nlogicalnot    hyphen         registered     macron\ndegree        plusminus      twosuperior    threesuperior\nacute         mu             paragraph      periodcentered\ncedilla       onesuperior    ordmasculine   guillemotright\nonequarter    onehalf        threequarters  questiondown\n\nAgrave        Aacute         Acircumflex    Atilde\nAdieresis     Aring          AE             Ccedilla\nEgrave        Eacute         Ecircumflex    Edieresis\nIgrave        Iacute         Icircumflex    Idieresis\nEth           Ntilde         Ograve         Oacute\nOcircumflex   Otilde         Odieresis      multiply\nOslash        Ugrave         Uacute         Ucircumflex\nUdieresis     Yacute         Thorn          germandbls\n\nagrave        aacute         acircumflex    atilde\nadieresis     aring          ae             ccedilla\negrave        eacute         ecircumflex    edieresis\nigrave        iacute         icircumflex    idieresis\neth           ntilde         ograve         oacute\nocircumflex   otilde         odieresis      divide\noslash        ugrave         uacute         ucircumflex\nudieresis     yacute         thorn          ydieresis".split(/\s+/);
function _parse(contents) {
  var obj = {
    attributes: {},
    glyphWidths: {},
    kernPairs: {}
  };
  var section = "";
  for (var _iterator = _createForOfIteratorHelperLoose(contents.split("\n")), _step; !(_step = _iterator()).done; ) {
    var line2 = _step.value;
    var match;
    var a2;
    if (match = line2.match(/^Start(\w+)/)) {
      section = match[1];
      continue;
    } else if (match = line2.match(/^End(\w+)/)) {
      section = "";
      continue;
    }
    switch (section) {
      case "FontMetrics":
        match = line2.match(/(^\w+)\s+(.*)/);
        var key = match[1];
        var value2 = match[2];
        if (a2 = obj.attributes[key]) {
          if (!Array.isArray(a2)) {
            a2 = obj.attributes[key] = [a2];
          }
          a2.push(value2);
        } else {
          obj.attributes[key] = value2;
        }
        break;
      case "CharMetrics":
        if (!/^CH?\s/.test(line2)) {
          continue;
        }
        var name = line2.match(/\bN\s+(\.?\w+)\s*;/)[1];
        obj.glyphWidths[name] = +line2.match(/\bWX\s+(\d+)\s*;/)[1];
        break;
      case "KernPairs":
        match = line2.match(/^KPX\s+(\.?\w+)\s+(\.?\w+)\s+(-?\d+)/);
        if (match) {
          obj.kernPairs[match[1] + match[2]] = parseInt(match[3]);
        }
        break;
    }
  }
  return obj;
}
var AFMFont = function() {
  AFMFont2.open = function open(filename) {
    {
      throw new Error("AFMFont.open not available on browser build");
    }
  };
  AFMFont2.fromJson = function fromJson(json) {
    return new AFMFont2(json);
  };
  function AFMFont2(contents) {
    var _this = this;
    if (typeof contents === "string") {
      this.contents = contents;
      this.parse();
    } else {
      this.attributes = contents.attributes;
      this.glyphWidths = contents.glyphWidths;
      this.kernPairs = contents.kernPairs;
    }
    this.charWidths = range(0, 255, true).map(function(i) {
      return _this.glyphWidths[characters[i]];
    });
    this.bbox = Array.from(this.attributes.FontBBox.split(/\s+/)).map(function(e) {
      return +e;
    });
    this.ascender = +(this.attributes.Ascender || 0);
    this.descender = +(this.attributes.Descender || 0);
    this.xHeight = +(this.attributes.XHeight || 0);
    this.capHeight = +(this.attributes.CapHeight || 0);
    this.lineGap = this.bbox[3] - this.bbox[1] - (this.ascender - this.descender);
  }
  var _proto = AFMFont2.prototype;
  _proto.parse = function parse3() {
    var parsed = _parse(this.contents);
    this.attributes = parsed.attributes;
    this.glyphWidths = parsed.glyphWidths;
    this.kernPairs = parsed.kernPairs;
  };
  _proto.encodeText = function encodeText(text2) {
    var res = [];
    for (var i = 0, end3 = text2.length, asc = 0 <= end3; asc ? i < end3 : i > end3; asc ? i++ : i--) {
      var char = text2.charCodeAt(i);
      char = WIN_ANSI_MAP[char] || char;
      res.push(char.toString(16));
    }
    return res;
  };
  _proto.glyphsForString = function glyphsForString(string) {
    var glyphs = [];
    for (var i = 0, end3 = string.length, asc = 0 <= end3; asc ? i < end3 : i > end3; asc ? i++ : i--) {
      var charCode = string.charCodeAt(i);
      glyphs.push(this.characterToGlyph(charCode));
    }
    return glyphs;
  };
  _proto.characterToGlyph = function characterToGlyph(character) {
    return characters[WIN_ANSI_MAP[character] || character] || ".notdef";
  };
  _proto.widthOfGlyph = function widthOfGlyph(glyph) {
    return this.glyphWidths[glyph] || 0;
  };
  _proto.getKernPair = function getKernPair(left, right) {
    return this.kernPairs[left + right] || 0;
  };
  _proto.advancesForGlyphs = function advancesForGlyphs(glyphs) {
    var advances = [];
    for (var index3 = 0; index3 < glyphs.length; index3++) {
      var left = glyphs[index3];
      var right = glyphs[index3 + 1];
      advances.push(this.widthOfGlyph(left) + this.getKernPair(left, right));
    }
    return advances;
  };
  return AFMFont2;
}();
var attributes = [
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:43:52 1997",
      "UniqueID 43052",
      "VMusage 37169 48194"
    ],
    FontName: "Helvetica-Bold",
    FullName: "Helvetica Bold",
    FamilyName: "Helvetica",
    Weight: "Bold",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-170 -228 1003 962 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "532",
    Ascender: "718",
    Descender: "-207",
    StdHW: "118",
    StdVW: "140"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:45:12 1997",
      "UniqueID 43053",
      "VMusage 14482 68586"
    ],
    FontName: "Helvetica-BoldOblique",
    FullName: "Helvetica Bold Oblique",
    FamilyName: "Helvetica",
    Weight: "Bold",
    ItalicAngle: "-12",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-174 -228 1114 962",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "532",
    Ascender: "718",
    Descender: "-207",
    StdHW: "118",
    StdVW: "140"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:44:31 1997",
      "UniqueID 43055",
      "VMusage 14960 69346"
    ],
    FontName: "Helvetica-Oblique",
    FullName: "Helvetica Oblique",
    FamilyName: "Helvetica",
    Weight: "Medium",
    ItalicAngle: "-12",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-170 -225 1116 931 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "523",
    Ascender: "718",
    Descender: "-207",
    StdHW: "76",
    StdVW: "88"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:38:23 1997",
      "UniqueID 43054",
      "VMusage 37069 48094"
    ],
    FontName: "Helvetica",
    FullName: "Helvetica",
    FamilyName: "Helvetica",
    Weight: "Medium",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-166 -225 1000 931 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1997 Adobe Systems Incorporated.  All Rights Reserved.Helvetica is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "718",
    XHeight: "523",
    Ascender: "718",
    Descender: "-207",
    StdHW: "76",
    StdVW: "88"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:52:56 1997",
      "UniqueID 43065",
      "VMusage 41636 52661"
    ],
    FontName: "Times-Bold",
    FullName: "Times Bold",
    FamilyName: "Times",
    Weight: "Bold",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-168 -218 1000 935 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "676",
    XHeight: "461",
    Ascender: "683",
    Descender: "-217",
    StdHW: "44",
    StdVW: "139"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 13:04:06 1997",
      "UniqueID 43066",
      "VMusage 45874 56899"
    ],
    FontName: "Times-BoldItalic",
    FullName: "Times Bold Italic",
    FamilyName: "Times",
    Weight: "Bold",
    ItalicAngle: "-15",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-200 -218 996 921",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "669",
    XHeight: "462",
    Ascender: "683",
    Descender: "-217",
    StdHW: "42",
    StdVW: "121"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:56:55 1997",
      "UniqueID 43067",
      "VMusage 47727 58752"
    ],
    FontName: "Times-Italic",
    FullName: "Times Italic",
    FamilyName: "Times",
    Weight: "Medium",
    ItalicAngle: "-15.5",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-169 -217 1010 883 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "653",
    XHeight: "441",
    Ascender: "683",
    Descender: "-217",
    StdHW: "32",
    StdVW: "76"
  },
  {
    Comment: [
      "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 12:49:17 1997",
      "UniqueID 43068",
      "VMusage 43909 54934"
    ],
    FontName: "Times-Roman",
    FullName: "Times Roman",
    FamilyName: "Times",
    Weight: "Roman",
    ItalicAngle: "0",
    IsFixedPitch: "false",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-168 -218 1000 898 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "002.000",
    Notice: "Copyright (c) 1985, 1987, 1989, 1990, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.Times is a trademark of Linotype-Hell AG and/or its subsidiaries.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "662",
    XHeight: "450",
    Ascender: "683",
    Descender: "-217",
    StdHW: "28",
    StdVW: "84"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Mon Jun 23 16:28:00 1997",
      "UniqueID 43048",
      "VMusage 41139 52164"
    ],
    FontName: "Courier-Bold",
    FullName: "Courier Bold",
    FamilyName: "Courier",
    Weight: "Bold",
    ItalicAngle: "0",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-113 -250 749 801 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "439",
    Ascender: "629",
    Descender: "-157",
    StdHW: "84",
    StdVW: "106"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Mon Jun 23 16:28:46 1997",
      "UniqueID 43049",
      "VMusage 17529 79244"
    ],
    FontName: "Courier-BoldOblique",
    FullName: "Courier Bold Oblique",
    FamilyName: "Courier",
    Weight: "Bold",
    ItalicAngle: "-12",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-57 -250 869 801",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "439",
    Ascender: "629",
    Descender: "-157",
    StdHW: "84",
    StdVW: "106"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 17:37:52 1997",
      "UniqueID 43051",
      "VMusage 16248 75829"
    ],
    FontName: "Courier-Oblique",
    FullName: "Courier Oblique",
    FamilyName: "Courier",
    Weight: "Medium",
    ItalicAngle: "-12",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-27 -250 849 805 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "426",
    Ascender: "629",
    Descender: "-157",
    StdHW: "51",
    StdVW: "51"
  },
  {
    Comment: [
      "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
      "Creation Date: Thu May  1 17:27:09 1997",
      "UniqueID 43050",
      "VMusage 39754 50779"
    ],
    FontName: "Courier",
    FullName: "Courier",
    FamilyName: "Courier",
    Weight: "Medium",
    ItalicAngle: "0",
    IsFixedPitch: "true",
    CharacterSet: "ExtendedRoman",
    FontBBox: "-23 -250 715 805 ",
    UnderlinePosition: "-100",
    UnderlineThickness: "50",
    Version: "003.000",
    Notice: "Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated.  All Rights Reserved.",
    EncodingScheme: "AdobeStandardEncoding",
    CapHeight: "562",
    XHeight: "426",
    Ascender: "629",
    Descender: "-157",
    StdHW: "51",
    StdVW: "51"
  }
];
var glyphWidths = {
  space: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  exclam: [
    333,
    333,
    278,
    278,
    333,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  quotedbl: [
    474,
    474,
    355,
    355,
    555,
    555,
    420,
    408,
    600,
    600,
    600,
    600
  ],
  numbersign: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  dollar: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  percent: [
    889,
    889,
    889,
    889,
    1e3,
    833,
    833,
    833,
    600,
    600,
    600,
    600
  ],
  ampersand: [
    722,
    722,
    667,
    667,
    833,
    778,
    778,
    778,
    600,
    600,
    600,
    600
  ],
  quoteright: [
    278,
    278,
    222,
    222,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  parenleft: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  parenright: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  asterisk: [
    389,
    389,
    389,
    389,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  plus: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  comma: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  hyphen: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  period: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  slash: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  zero: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  one: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  two: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  three: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  four: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  five: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  six: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  seven: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  eight: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  nine: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  colon: [
    333,
    333,
    278,
    278,
    333,
    333,
    333,
    278,
    600,
    600,
    600,
    600
  ],
  semicolon: [
    333,
    333,
    278,
    278,
    333,
    333,
    333,
    278,
    600,
    600,
    600,
    600
  ],
  less: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  equal: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  greater: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  question: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  at: [
    975,
    975,
    1015,
    1015,
    930,
    832,
    920,
    921,
    600,
    600,
    600,
    600
  ],
  A: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  B: [
    722,
    722,
    667,
    667,
    667,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  C: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  D: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  E: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  F: [
    611,
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    600,
    600,
    600,
    600
  ],
  G: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  H: [
    722,
    722,
    722,
    722,
    778,
    778,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  I: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  J: [
    556,
    556,
    500,
    500,
    500,
    500,
    444,
    389,
    600,
    600,
    600,
    600
  ],
  K: [
    722,
    722,
    667,
    667,
    778,
    667,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  L: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  M: [
    833,
    833,
    833,
    833,
    944,
    889,
    833,
    889,
    600,
    600,
    600,
    600
  ],
  N: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  O: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  P: [
    667,
    667,
    667,
    667,
    611,
    611,
    611,
    556,
    600,
    600,
    600,
    600
  ],
  Q: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  R: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  S: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  T: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  U: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  V: [
    667,
    667,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  W: [
    944,
    944,
    944,
    944,
    1e3,
    889,
    833,
    944,
    600,
    600,
    600,
    600
  ],
  X: [
    667,
    667,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Y: [
    667,
    667,
    667,
    667,
    722,
    611,
    556,
    722,
    600,
    600,
    600,
    600
  ],
  Z: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  bracketleft: [
    333,
    333,
    278,
    278,
    333,
    333,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  backslash: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  bracketright: [
    333,
    333,
    278,
    278,
    333,
    333,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  asciicircum: [
    584,
    584,
    469,
    469,
    581,
    570,
    422,
    469,
    600,
    600,
    600,
    600
  ],
  underscore: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  quoteleft: [
    278,
    278,
    222,
    222,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  a: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  b: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  c: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  d: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  e: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  f: [
    333,
    333,
    278,
    278,
    333,
    333,
    278,
    333,
    600,
    600,
    600,
    600
  ],
  g: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  h: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  i: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  j: [
    278,
    278,
    222,
    222,
    333,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  k: [
    556,
    556,
    500,
    500,
    556,
    500,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  l: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  m: [
    889,
    889,
    833,
    833,
    833,
    778,
    722,
    778,
    600,
    600,
    600,
    600
  ],
  n: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  o: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  p: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  q: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  r: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  s: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  t: [
    333,
    333,
    278,
    278,
    333,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  u: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  v: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  w: [
    778,
    778,
    722,
    722,
    722,
    667,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  x: [
    556,
    556,
    500,
    500,
    500,
    500,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  y: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  z: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  braceleft: [
    389,
    389,
    334,
    334,
    394,
    348,
    400,
    480,
    600,
    600,
    600,
    600
  ],
  bar: [
    280,
    280,
    260,
    260,
    220,
    220,
    275,
    200,
    600,
    600,
    600,
    600
  ],
  braceright: [
    389,
    389,
    334,
    334,
    394,
    348,
    400,
    480,
    600,
    600,
    600,
    600
  ],
  asciitilde: [
    584,
    584,
    584,
    584,
    520,
    570,
    541,
    541,
    600,
    600,
    600,
    600
  ],
  exclamdown: [
    333,
    333,
    333,
    333,
    333,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  cent: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  sterling: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  fraction: [
    167,
    167,
    167,
    167,
    167,
    167,
    167,
    167,
    600,
    600,
    600,
    600
  ],
  yen: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  florin: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  section: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  currency: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  quotesingle: [
    238,
    238,
    191,
    191,
    278,
    278,
    214,
    180,
    600,
    600,
    600,
    600
  ],
  quotedblleft: [
    500,
    500,
    333,
    333,
    500,
    500,
    556,
    444,
    600,
    600,
    600,
    600
  ],
  guillemotleft: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  guilsinglleft: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  guilsinglright: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  fi: [
    611,
    611,
    500,
    500,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  fl: [
    611,
    611,
    500,
    500,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  endash: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  dagger: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  daggerdbl: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  periodcentered: [
    278,
    278,
    278,
    278,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  paragraph: [
    556,
    556,
    537,
    537,
    540,
    500,
    523,
    453,
    600,
    600,
    600,
    600
  ],
  bullet: [
    350,
    350,
    350,
    350,
    350,
    350,
    350,
    350,
    600,
    600,
    600,
    600
  ],
  quotesinglbase: [
    278,
    278,
    222,
    222,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  quotedblbase: [
    500,
    500,
    333,
    333,
    500,
    500,
    556,
    444,
    600,
    600,
    600,
    600
  ],
  quotedblright: [
    500,
    500,
    333,
    333,
    500,
    500,
    556,
    444,
    600,
    600,
    600,
    600
  ],
  guillemotright: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  ellipsis: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    889,
    1e3,
    600,
    600,
    600,
    600
  ],
  perthousand: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    600,
    600,
    600,
    600
  ],
  questiondown: [
    611,
    611,
    611,
    611,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  grave: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  acute: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  circumflex: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  tilde: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  macron: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  breve: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  dotaccent: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  dieresis: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  ring: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  cedilla: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  hungarumlaut: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  ogonek: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  caron: [
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  emdash: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    889,
    1e3,
    600,
    600,
    600,
    600
  ],
  AE: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    944,
    889,
    889,
    600,
    600,
    600,
    600
  ],
  ordfeminine: [
    370,
    370,
    370,
    370,
    300,
    266,
    276,
    276,
    600,
    600,
    600,
    600
  ],
  Lslash: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Oslash: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  OE: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    944,
    944,
    889,
    600,
    600,
    600,
    600
  ],
  ordmasculine: [
    365,
    365,
    365,
    365,
    330,
    300,
    310,
    310,
    600,
    600,
    600,
    600
  ],
  ae: [
    889,
    889,
    889,
    889,
    722,
    722,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  dotlessi: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  lslash: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  oslash: [
    611,
    611,
    611,
    611,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  oe: [
    944,
    944,
    944,
    944,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  germandbls: [
    611,
    611,
    611,
    611,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Idieresis: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  eacute: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  abreve: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  uhungarumlaut: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  ecaron: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Ydieresis: [
    667,
    667,
    667,
    667,
    722,
    611,
    556,
    722,
    600,
    600,
    600,
    600
  ],
  divide: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  Yacute: [
    667,
    667,
    667,
    667,
    722,
    611,
    556,
    722,
    600,
    600,
    600,
    600
  ],
  Acircumflex: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  aacute: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Ucircumflex: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  yacute: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  scommaaccent: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  ecircumflex: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Uring: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Udieresis: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  aogonek: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Uacute: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  uogonek: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Edieresis: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  Dcroat: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  commaaccent: [
    250,
    250,
    250,
    250,
    250,
    250,
    250,
    250,
    600,
    600,
    600,
    600
  ],
  copyright: [
    737,
    737,
    737,
    737,
    747,
    747,
    760,
    760,
    600,
    600,
    600,
    600
  ],
  Emacron: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  ccaron: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  aring: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Ncommaaccent: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  lacute: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  agrave: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Tcommaaccent: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Cacute: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  atilde: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Edotaccent: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  scaron: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  scedilla: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  iacute: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  lozenge: [
    494,
    494,
    471,
    471,
    494,
    494,
    471,
    471,
    600,
    600,
    600,
    600
  ],
  Rcaron: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  Gcommaaccent: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  ucircumflex: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  acircumflex: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  Amacron: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  rcaron: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  ccedilla: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Zdotaccent: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Thorn: [
    667,
    667,
    667,
    667,
    611,
    611,
    611,
    556,
    600,
    600,
    600,
    600
  ],
  Omacron: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Racute: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  Sacute: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  dcaron: [
    743,
    743,
    643,
    643,
    672,
    608,
    544,
    588,
    600,
    600,
    600,
    600
  ],
  Umacron: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  uring: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  threesuperior: [
    333,
    333,
    333,
    333,
    300,
    300,
    300,
    300,
    600,
    600,
    600,
    600
  ],
  Ograve: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Agrave: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Abreve: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  multiply: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  uacute: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Tcaron: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  partialdiff: [
    494,
    494,
    476,
    476,
    494,
    494,
    476,
    476,
    600,
    600,
    600,
    600
  ],
  ydieresis: [
    556,
    556,
    500,
    500,
    500,
    444,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  Nacute: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  icircumflex: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Ecircumflex: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  adieresis: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  edieresis: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  cacute: [
    556,
    556,
    500,
    500,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  nacute: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  umacron: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Ncaron: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  Iacute: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  plusminus: [
    584,
    584,
    584,
    584,
    570,
    570,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  brokenbar: [
    280,
    280,
    260,
    260,
    220,
    220,
    275,
    200,
    600,
    600,
    600,
    600
  ],
  registered: [
    737,
    737,
    737,
    737,
    747,
    747,
    760,
    760,
    600,
    600,
    600,
    600
  ],
  Gbreve: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Idotaccent: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  summation: [
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600,
    600
  ],
  Egrave: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  racute: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  omacron: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Zacute: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Zcaron: [
    611,
    611,
    611,
    611,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  greaterequal: [
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    600,
    600,
    600,
    600
  ],
  Eth: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Ccedilla: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  lcommaaccent: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  tcaron: [
    389,
    389,
    317,
    317,
    416,
    366,
    300,
    326,
    600,
    600,
    600,
    600
  ],
  eogonek: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Uogonek: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Aacute: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Adieresis: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  egrave: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  zacute: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  iogonek: [
    278,
    278,
    222,
    222,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Oacute: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  oacute: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  amacron: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    444,
    600,
    600,
    600,
    600
  ],
  sacute: [
    556,
    556,
    500,
    500,
    389,
    389,
    389,
    389,
    600,
    600,
    600,
    600
  ],
  idieresis: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Ocircumflex: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Ugrave: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Delta: [
    612,
    612,
    612,
    612,
    612,
    612,
    612,
    612,
    600,
    600,
    600,
    600
  ],
  thorn: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  twosuperior: [
    333,
    333,
    333,
    333,
    300,
    300,
    300,
    300,
    600,
    600,
    600,
    600
  ],
  Odieresis: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  mu: [
    611,
    611,
    556,
    556,
    556,
    576,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  igrave: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  ohungarumlaut: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Eogonek: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  dcroat: [
    611,
    611,
    556,
    556,
    556,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  threequarters: [
    834,
    834,
    834,
    834,
    750,
    750,
    750,
    750,
    600,
    600,
    600,
    600
  ],
  Scedilla: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  lcaron: [
    400,
    400,
    299,
    299,
    394,
    382,
    300,
    344,
    600,
    600,
    600,
    600
  ],
  Kcommaaccent: [
    722,
    722,
    667,
    667,
    778,
    667,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  Lacute: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  trademark: [
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    1e3,
    980,
    980,
    600,
    600,
    600,
    600
  ],
  edotaccent: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  Igrave: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  Imacron: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  Lcaron: [
    611,
    611,
    556,
    556,
    667,
    611,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  onehalf: [
    834,
    834,
    834,
    834,
    750,
    750,
    750,
    750,
    600,
    600,
    600,
    600
  ],
  lessequal: [
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    600,
    600,
    600,
    600
  ],
  ocircumflex: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  ntilde: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Uhungarumlaut: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  Eacute: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  emacron: [
    556,
    556,
    556,
    556,
    444,
    444,
    444,
    444,
    600,
    600,
    600,
    600
  ],
  gbreve: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  onequarter: [
    834,
    834,
    834,
    834,
    750,
    750,
    750,
    750,
    600,
    600,
    600,
    600
  ],
  Scaron: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  Scommaaccent: [
    667,
    667,
    667,
    667,
    556,
    556,
    500,
    556,
    600,
    600,
    600,
    600
  ],
  Ohungarumlaut: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  degree: [
    400,
    400,
    400,
    400,
    400,
    400,
    400,
    400,
    600,
    600,
    600,
    600
  ],
  ograve: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Ccaron: [
    722,
    722,
    722,
    722,
    722,
    667,
    667,
    667,
    600,
    600,
    600,
    600
  ],
  ugrave: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  radical: [
    549,
    549,
    453,
    453,
    549,
    549,
    453,
    453,
    600,
    600,
    600,
    600
  ],
  Dcaron: [
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  rcommaaccent: [
    389,
    389,
    333,
    333,
    444,
    389,
    389,
    333,
    600,
    600,
    600,
    600
  ],
  Ntilde: [
    722,
    722,
    722,
    722,
    722,
    722,
    667,
    722,
    600,
    600,
    600,
    600
  ],
  otilde: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  Rcommaaccent: [
    722,
    722,
    722,
    722,
    722,
    667,
    611,
    667,
    600,
    600,
    600,
    600
  ],
  Lcommaaccent: [
    611,
    611,
    556,
    556,
    667,
    611,
    556,
    611,
    600,
    600,
    600,
    600
  ],
  Atilde: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Aogonek: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Aring: [
    722,
    722,
    667,
    667,
    722,
    667,
    611,
    722,
    600,
    600,
    600,
    600
  ],
  Otilde: [
    778,
    778,
    778,
    778,
    778,
    722,
    722,
    722,
    600,
    600,
    600,
    600
  ],
  zdotaccent: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  Ecaron: [
    667,
    667,
    667,
    667,
    667,
    667,
    611,
    611,
    600,
    600,
    600,
    600
  ],
  Iogonek: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  kcommaaccent: [
    556,
    556,
    500,
    500,
    556,
    500,
    444,
    500,
    600,
    600,
    600,
    600
  ],
  minus: [
    584,
    584,
    584,
    584,
    570,
    606,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  Icircumflex: [
    278,
    278,
    278,
    278,
    389,
    389,
    333,
    333,
    600,
    600,
    600,
    600
  ],
  ncaron: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  tcommaaccent: [
    333,
    333,
    278,
    278,
    333,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  logicalnot: [
    584,
    584,
    584,
    584,
    570,
    606,
    675,
    564,
    600,
    600,
    600,
    600
  ],
  odieresis: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  udieresis: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  notequal: [
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    549,
    600,
    600,
    600,
    600
  ],
  gcommaaccent: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  eth: [
    611,
    611,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  zcaron: [
    500,
    500,
    500,
    500,
    444,
    389,
    389,
    444,
    600,
    600,
    600,
    600
  ],
  ncommaaccent: [
    611,
    611,
    556,
    556,
    556,
    556,
    500,
    500,
    600,
    600,
    600,
    600
  ],
  onesuperior: [
    333,
    333,
    333,
    333,
    300,
    300,
    300,
    300,
    600,
    600,
    600,
    600
  ],
  imacron: [
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    278,
    600,
    600,
    600,
    600
  ],
  Euro: [
    556,
    556,
    556,
    556,
    500,
    500,
    500,
    500,
    600,
    600,
    600,
    600
  ]
};
var kernPairs = {
  AC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  ACacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  ACcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  ACcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  ATcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  ATcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Au: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Audieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Augrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Auring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Av: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Ay: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Ayacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AacuteC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AacuteG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AacuteGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AacuteGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AacuteO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AacuteQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AacuteT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AacuteTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AacuteTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AacuteU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AacuteV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AacuteW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AacuteY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AacuteYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AacuteYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Aacuteu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacuteuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aacutev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aacutew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Aacutey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aacuteyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aacuteydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AbreveC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AbreveG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AbreveGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AbreveGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AbreveO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AbreveQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AbreveT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AbreveTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AbreveTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AbreveU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AbreveV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AbreveW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AbreveY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AbreveYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AbreveYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Abreveu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abreveuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Abrevev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Abrevew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Abrevey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Abreveyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Abreveydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AcircumflexC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AcircumflexG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AcircumflexGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AcircumflexGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AcircumflexO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AcircumflexQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AcircumflexT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AcircumflexTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AcircumflexTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AcircumflexU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AcircumflexV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AcircumflexW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AcircumflexY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AcircumflexYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AcircumflexYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Acircumflexu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Acircumflexv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Acircumflexw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Acircumflexy: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Acircumflexyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Acircumflexydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AdieresisC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AdieresisG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AdieresisGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AdieresisGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AdieresisO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AdieresisQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AdieresisT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AdieresisTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AdieresisTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AdieresisU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AdieresisV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AdieresisW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AdieresisY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AdieresisYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AdieresisYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Adieresisu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Adieresisv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Adieresisw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Adieresisy: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Adieresisyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Adieresisydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AgraveC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AgraveG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AgraveGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AgraveGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AgraveO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AgraveQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AgraveT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AgraveTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AgraveTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AgraveU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AgraveV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AgraveW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AgraveY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AgraveYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AgraveYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Agraveu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agraveuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Agravev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Agravew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Agravey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Agraveyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Agraveydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AmacronC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AmacronG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AmacronGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AmacronGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AmacronO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AmacronQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AmacronT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AmacronTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AmacronTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AmacronU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AmacronV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AmacronW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AmacronY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AmacronYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AmacronYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Amacronu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Amacronv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Amacronw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Amacrony: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Amacronyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Amacronydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AogonekC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AogonekG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AogonekGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AogonekGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AogonekO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AogonekQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AogonekT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AogonekTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AogonekTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AogonekU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AogonekV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AogonekW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AogonekY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AogonekYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AogonekYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Aogoneku: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aogonekv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aogonekw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -52
  ],
  Aogoneky: [
    -30,
    -30,
    -40,
    -40,
    -34,
    -34,
    -55,
    -52
  ],
  Aogonekyacute: [
    -30,
    -30,
    -40,
    -40,
    -34,
    -34,
    -55,
    -52
  ],
  Aogonekydieresis: [
    -30,
    -30,
    -40,
    -40,
    -34,
    -34,
    -55,
    -52
  ],
  AringC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AringG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AringGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AringGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AringO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AringQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AringT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AringTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AringTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AringU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AringV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AringW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AringY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AringYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AringYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Aringu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Aringv: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Aringw: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Aringy: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aringyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Aringydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  AtildeC: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeCacute: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeCcaron: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeCcedilla: [
    -40,
    -40,
    -30,
    -30,
    -55,
    -65,
    -30,
    -40
  ],
  AtildeG: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AtildeGbreve: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AtildeGcommaaccent: [
    -50,
    -50,
    -30,
    -30,
    -55,
    -60,
    -35,
    -40
  ],
  AtildeO: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOacute: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOcircumflex: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOdieresis: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOgrave: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOhungarumlaut: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOmacron: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOslash: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeOtilde: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -50,
    -40,
    -55
  ],
  AtildeQ: [
    -40,
    -40,
    -30,
    -30,
    -45,
    -55,
    -40,
    -55
  ],
  AtildeT: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AtildeTcaron: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AtildeTcommaaccent: [
    -90,
    -90,
    -120,
    -120,
    -95,
    -55,
    -37,
    -111
  ],
  AtildeU: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUacute: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUcircumflex: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUdieresis: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUgrave: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUhungarumlaut: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUmacron: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUogonek: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeUring: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -55
  ],
  AtildeV: [
    -80,
    -80,
    -70,
    -70,
    -145,
    -95,
    -105,
    -135
  ],
  AtildeW: [
    -60,
    -60,
    -50,
    -50,
    -130,
    -100,
    -95,
    -90
  ],
  AtildeY: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AtildeYacute: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  AtildeYdieresis: [
    -110,
    -110,
    -100,
    -100,
    -100,
    -70,
    -55,
    -105
  ],
  Atildeu: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuacute: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeudieresis: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeugrave: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeumacron: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuogonek: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildeuring: [
    -30,
    -30,
    -30,
    -30,
    -50,
    -30,
    -20
  ],
  Atildev: [
    -40,
    -40,
    -40,
    -40,
    -100,
    -74,
    -55,
    -74
  ],
  Atildew: [
    -30,
    -30,
    -40,
    -40,
    -90,
    -74,
    -55,
    -92
  ],
  Atildey: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Atildeyacute: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  Atildeydieresis: [
    -30,
    -30,
    -40,
    -40,
    -74,
    -74,
    -55,
    -92
  ],
  BA: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAacute: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAbreve: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAcircumflex: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAdieresis: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAgrave: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAmacron: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAogonek: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAring: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BAtilde: [
    -30,
    -30,
    0,
    0,
    -30,
    -25,
    -25,
    -35
  ],
  BU: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUacute: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUcircumflex: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUdieresis: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUgrave: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUhungarumlaut: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUmacron: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUogonek: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  BUring: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  DA: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAacute: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAbreve: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAdieresis: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAgrave: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAmacron: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAogonek: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAring: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DAtilde: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DV: [
    -40,
    -40,
    -70,
    -70,
    -40,
    -50,
    -40,
    -40
  ],
  DW: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -30
  ],
  DY: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DYacute: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DYdieresis: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  Dcomma: [
    -30,
    -30,
    -70,
    -70
  ],
  Dperiod: [
    -30,
    -30,
    -70,
    -70,
    -20
  ],
  DcaronA: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAacute: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAbreve: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAdieresis: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAgrave: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAmacron: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAogonek: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAring: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronAtilde: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcaronV: [
    -40,
    -40,
    -70,
    -70,
    -40,
    -50,
    -40,
    -40
  ],
  DcaronW: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -30
  ],
  DcaronY: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcaronYacute: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcaronYdieresis: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  Dcaroncomma: [
    -30,
    -30,
    -70,
    -70
  ],
  Dcaronperiod: [
    -30,
    -30,
    -70,
    -70,
    -20
  ],
  DcroatA: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAacute: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAbreve: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAdieresis: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAgrave: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAmacron: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAogonek: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAring: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatAtilde: [
    -40,
    -40,
    -40,
    -40,
    -35,
    -25,
    -35,
    -40
  ],
  DcroatV: [
    -40,
    -40,
    -70,
    -70,
    -40,
    -50,
    -40,
    -40
  ],
  DcroatW: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -30
  ],
  DcroatY: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcroatYacute: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  DcroatYdieresis: [
    -70,
    -70,
    -90,
    -90,
    -40,
    -50,
    -40,
    -55
  ],
  Dcroatcomma: [
    -30,
    -30,
    -70,
    -70
  ],
  Dcroatperiod: [
    -30,
    -30,
    -70,
    -70,
    -20
  ],
  FA: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAacute: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAbreve: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAcircumflex: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAdieresis: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAgrave: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAmacron: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAogonek: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAring: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  FAtilde: [
    -80,
    -80,
    -80,
    -80,
    -90,
    -100,
    -115,
    -74
  ],
  Fa: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Faacute: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fabreve: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Facircumflex: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fadieresis: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fagrave: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Famacron: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Faogonek: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Faring: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fatilde: [
    -20,
    -20,
    -50,
    -50,
    -25,
    -95,
    -75,
    -15
  ],
  Fcomma: [
    -100,
    -100,
    -150,
    -150,
    -92,
    -129,
    -135,
    -80
  ],
  Fperiod: [
    -100,
    -100,
    -150,
    -150,
    -110,
    -129,
    -135,
    -80
  ],
  JA: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAbreve: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAogonek: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAring: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  JAtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -25,
    -40,
    -60
  ],
  Jcomma: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    -25
  ],
  Jperiod: [
    -20,
    -20,
    -30,
    -30,
    -20,
    -10,
    -25
  ],
  Ju: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juacute: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jucircumflex: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Judieresis: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jugrave: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jumacron: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juogonek: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Juring: [
    -20,
    -20,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  KO: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOacute: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOcircumflex: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOdieresis: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOgrave: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOhungarumlaut: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOmacron: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOslash: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KOtilde: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  Ke: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Keacute: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kecaron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kecircumflex: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kedieresis: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kedotaccent: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kegrave: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kemacron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Keogonek: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Ko: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Koacute: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kocircumflex: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kodieresis: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kograve: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kohungarumlaut: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Komacron: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Koslash: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kotilde: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Ku: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuacute: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kudieresis: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kugrave: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kumacron: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuogonek: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kuring: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Ky: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kyacute: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kydieresis: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  KcommaaccentO: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOacute: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOcircumflex: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOdieresis: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOgrave: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOhungarumlaut: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOmacron: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOslash: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  KcommaaccentOtilde: [
    -30,
    -30,
    -50,
    -50,
    -30,
    -30,
    -50,
    -30
  ],
  Kcommaaccente: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccenteacute: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentecaron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentecircumflex: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentedieresis: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentedotaccent: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentegrave: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccentemacron: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccenteogonek: [
    -15,
    -15,
    -40,
    -40,
    -25,
    -25,
    -35,
    -25
  ],
  Kcommaaccento: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentoacute: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentocircumflex: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentodieresis: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentograve: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentohungarumlaut: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentomacron: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentoslash: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentotilde: [
    -35,
    -35,
    -40,
    -40,
    -25,
    -25,
    -40,
    -35
  ],
  Kcommaaccentu: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentuacute: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentucircumflex: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentudieresis: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentugrave: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentuhungarumlaut: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentumacron: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccentuogonek: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccenturing: [
    -30,
    -30,
    -30,
    -30,
    -15,
    -20,
    -40,
    -15
  ],
  Kcommaaccenty: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kcommaaccentyacute: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  Kcommaaccentydieresis: [
    -40,
    -40,
    -50,
    -50,
    -45,
    -20,
    -40,
    -25
  ],
  LT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lquotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lquoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Ly: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  LacuteT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LacuteTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LacuteTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LacuteV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LacuteW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LacuteY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LacuteYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LacuteYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lacutequotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lacutequoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Lacutey: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lacuteyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lacuteydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  LcommaaccentT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LcommaaccentTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LcommaaccentTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LcommaaccentV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LcommaaccentW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LcommaaccentY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LcommaaccentYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LcommaaccentYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lcommaaccentquotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lcommaaccentquoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Lcommaaccenty: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lcommaaccentyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lcommaaccentydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  LslashT: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LslashTcaron: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LslashTcommaaccent: [
    -90,
    -90,
    -110,
    -110,
    -92,
    -18,
    -20,
    -92
  ],
  LslashV: [
    -110,
    -110,
    -110,
    -110,
    -92,
    -37,
    -55,
    -100
  ],
  LslashW: [
    -80,
    -80,
    -70,
    -70,
    -92,
    -37,
    -55,
    -74
  ],
  LslashY: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LslashYacute: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  LslashYdieresis: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -37,
    -20,
    -100
  ],
  Lslashquotedblright: [
    -140,
    -140,
    -140,
    -140,
    -20
  ],
  Lslashquoteright: [
    -140,
    -140,
    -160,
    -160,
    -110,
    -55,
    -37,
    -92
  ],
  Lslashy: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lslashyacute: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  Lslashydieresis: [
    -30,
    -30,
    -30,
    -30,
    -55,
    -37,
    -30,
    -55
  ],
  OA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ocomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Operiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OacuteA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OacuteT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OacuteW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OacuteX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OacuteY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OacuteYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OacuteYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Oacutecomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Oacuteperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OcircumflexT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OcircumflexW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OcircumflexX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OcircumflexY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OcircumflexYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OcircumflexYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ocircumflexcomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Ocircumflexperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OdieresisT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OdieresisW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OdieresisX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OdieresisY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OdieresisYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OdieresisYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Odieresiscomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Odieresisperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OgraveA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OgraveT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OgraveW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OgraveX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OgraveY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OgraveYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OgraveYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ogravecomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Ograveperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OhungarumlautT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OhungarumlautW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OhungarumlautX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OhungarumlautY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OhungarumlautYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OhungarumlautYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Ohungarumlautcomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Ohungarumlautperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OmacronA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OmacronT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OmacronW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OmacronX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OmacronY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OmacronYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OmacronYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Omacroncomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Omacronperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OslashA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OslashT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OslashTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OslashTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OslashV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OslashW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OslashX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OslashY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OslashYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OslashYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Oslashcomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Oslashperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  OtildeA: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAacute: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAbreve: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAcircumflex: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAdieresis: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAgrave: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAmacron: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAogonek: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAring: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeAtilde: [
    -50,
    -50,
    -20,
    -20,
    -40,
    -40,
    -55,
    -35
  ],
  OtildeT: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeTcaron: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeTcommaaccent: [
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeV: [
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50,
    -50
  ],
  OtildeW: [
    -50,
    -50,
    -30,
    -30,
    -50,
    -50,
    -50,
    -35
  ],
  OtildeX: [
    -50,
    -50,
    -60,
    -60,
    -40,
    -40,
    -40,
    -40
  ],
  OtildeY: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OtildeYacute: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  OtildeYdieresis: [
    -70,
    -70,
    -70,
    -70,
    -50,
    -50,
    -50,
    -50
  ],
  Otildecomma: [
    -40,
    -40,
    -40,
    -40
  ],
  Otildeperiod: [
    -40,
    -40,
    -40,
    -40
  ],
  PA: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAacute: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAbreve: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAcircumflex: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAdieresis: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAgrave: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAmacron: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAogonek: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAring: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  PAtilde: [
    -100,
    -100,
    -120,
    -120,
    -74,
    -85,
    -90,
    -92
  ],
  Pa: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Paacute: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pabreve: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pacircumflex: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Padieresis: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pagrave: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pamacron: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Paogonek: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Paring: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Patilde: [
    -30,
    -30,
    -40,
    -40,
    -10,
    -40,
    -80,
    -15
  ],
  Pcomma: [
    -120,
    -120,
    -180,
    -180,
    -92,
    -129,
    -135,
    -111
  ],
  Pe: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Peacute: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pecaron: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pecircumflex: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pedieresis: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pedotaccent: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pegrave: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Pemacron: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Peogonek: [
    -30,
    -30,
    -50,
    -50,
    -20,
    -50,
    -80
  ],
  Po: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Poacute: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pocircumflex: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Podieresis: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pograve: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pohungarumlaut: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pomacron: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Poslash: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Potilde: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -55,
    -80
  ],
  Pperiod: [
    -120,
    -120,
    -180,
    -180,
    -110,
    -129,
    -135,
    -111
  ],
  QU: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUacute: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUcircumflex: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUdieresis: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUgrave: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUhungarumlaut: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUmacron: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUogonek: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  QUring: [
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10,
    -10
  ],
  Qcomma: [
    20,
    20
  ],
  Qperiod: [
    20,
    20,
    0,
    0,
    -20
  ],
  RO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  ROtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RacuteO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteOtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RacuteTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RacuteTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RacuteU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RacuteV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RacuteW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RacuteY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RacuteYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RacuteYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcaronO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronOtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcaronTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcaronTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcaronU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcaronV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RcaronW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RcaronY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcaronYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcaronYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcommaaccentO: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOacute: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOgrave: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOmacron: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOslash: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentOtilde: [
    -20,
    -20,
    -20,
    -20,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentT: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcommaaccentTcaron: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcommaaccentTcommaaccent: [
    -20,
    -20,
    -30,
    -30,
    -40,
    -30,
    0,
    -60
  ],
  RcommaaccentU: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUacute: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUcircumflex: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUdieresis: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUgrave: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUhungarumlaut: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUmacron: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUogonek: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentUring: [
    -20,
    -20,
    -40,
    -40,
    -30,
    -40,
    -40,
    -40
  ],
  RcommaaccentV: [
    -50,
    -50,
    -50,
    -50,
    -55,
    -18,
    -18,
    -80
  ],
  RcommaaccentW: [
    -40,
    -40,
    -30,
    -30,
    -35,
    -18,
    -18,
    -55
  ],
  RcommaaccentY: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcommaaccentYacute: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  RcommaaccentYdieresis: [
    -50,
    -50,
    -50,
    -50,
    -35,
    -18,
    -18,
    -65
  ],
  TA: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAacute: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAbreve: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAcircumflex: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAdieresis: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAgrave: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAmacron: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAogonek: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAring: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TAtilde: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TO: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOacute: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOdieresis: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOgrave: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOhungarumlaut: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOmacron: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOslash: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TOtilde: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  Ta: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Taacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tabreve: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -80
  ],
  Tacircumflex: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -80
  ],
  Tadieresis: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tagrave: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tamacron: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Taogonek: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Taring: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tatilde: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -55,
    -50
  ],
  Tcomma: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -92,
    -74,
    -74
  ],
  Te: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Teacute: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tecaron: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tecircumflex: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -52,
    -70
  ],
  Tedieresis: [
    -60,
    -60,
    -120,
    -120,
    -52,
    -52,
    -52,
    -30
  ],
  Tedotaccent: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tegrave: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -70
  ],
  Temacron: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -30
  ],
  Teogonek: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Thyphen: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -92,
    -74,
    -92
  ],
  To: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Toacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tocircumflex: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Todieresis: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tograve: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tohungarumlaut: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tomacron: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Toslash: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Totilde: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tperiod: [
    -80,
    -80,
    -120,
    -120,
    -90,
    -92,
    -74,
    -74
  ],
  Tr: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tracute: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Trcommaaccent: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tsemicolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -65,
    -55
  ],
  Tu: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tuacute: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tucircumflex: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tudieresis: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tugrave: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tuhungarumlaut: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tumacron: [
    -90,
    -90,
    -60,
    -60,
    -92,
    -37,
    -55,
    -45
  ],
  Tuogonek: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Turing: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tw: [
    -60,
    -60,
    -120,
    -120,
    -74,
    -37,
    -74,
    -80
  ],
  Ty: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tyacute: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tydieresis: [
    -60,
    -60,
    -60,
    -60,
    -34,
    -37,
    -34,
    -80
  ],
  TcaronA: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAacute: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAbreve: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAcircumflex: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAdieresis: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAgrave: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAmacron: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAogonek: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAring: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronAtilde: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcaronO: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOacute: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOdieresis: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOgrave: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOhungarumlaut: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOmacron: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOslash: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcaronOtilde: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  Tcarona: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronaacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronabreve: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -80
  ],
  Tcaronacircumflex: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -80
  ],
  Tcaronadieresis: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaronagrave: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaronamacron: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaronaogonek: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronaring: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcaronatilde: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcaroncolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -55,
    -50
  ],
  Tcaroncomma: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -92,
    -74,
    -74
  ],
  Tcarone: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaroneacute: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronecaron: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronecircumflex: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -52,
    -30
  ],
  Tcaronedieresis: [
    -60,
    -60,
    -120,
    -120,
    -52,
    -52,
    -52,
    -30
  ],
  Tcaronedotaccent: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronegrave: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -70
  ],
  Tcaronemacron: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -30
  ],
  Tcaroneogonek: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcaronhyphen: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -92,
    -74,
    -92
  ],
  Tcarono: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronoacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronocircumflex: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronodieresis: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronograve: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronohungarumlaut: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronomacron: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronoslash: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronotilde: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcaronperiod: [
    -80,
    -80,
    -120,
    -120,
    -90,
    -92,
    -74,
    -74
  ],
  Tcaronr: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronracute: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronrcommaaccent: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronsemicolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -65,
    -55
  ],
  Tcaronu: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuacute: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronucircumflex: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronudieresis: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronugrave: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuhungarumlaut: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronumacron: [
    -90,
    -90,
    -60,
    -60,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuogonek: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronuring: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcaronw: [
    -60,
    -60,
    -120,
    -120,
    -74,
    -37,
    -74,
    -80
  ],
  Tcarony: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcaronyacute: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcaronydieresis: [
    -60,
    -60,
    -60,
    -60,
    -34,
    -37,
    -34,
    -80
  ],
  TcommaaccentA: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAacute: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAbreve: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAcircumflex: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAdieresis: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAgrave: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAmacron: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAogonek: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAring: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentAtilde: [
    -90,
    -90,
    -120,
    -120,
    -90,
    -55,
    -50,
    -93
  ],
  TcommaaccentO: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOacute: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOcircumflex: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOdieresis: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOgrave: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOhungarumlaut: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOmacron: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOslash: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  TcommaaccentOtilde: [
    -40,
    -40,
    -40,
    -40,
    -18,
    -18,
    -18,
    -18
  ],
  Tcommaaccenta: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentaacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentabreve: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -80
  ],
  Tcommaaccentacircumflex: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -80
  ],
  Tcommaaccentadieresis: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentagrave: [
    -80,
    -80,
    -120,
    -120,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentamacron: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentaogonek: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentaring: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -92,
    -92,
    -80
  ],
  Tcommaaccentatilde: [
    -80,
    -80,
    -60,
    -60,
    -52,
    -92,
    -92,
    -40
  ],
  Tcommaaccentcolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -55,
    -50
  ],
  Tcommaaccentcomma: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -92,
    -74,
    -74
  ],
  Tcommaaccente: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccenteacute: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccentecaron: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccentecircumflex: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -52,
    -30
  ],
  Tcommaaccentedieresis: [
    -60,
    -60,
    -120,
    -120,
    -52,
    -52,
    -52,
    -30
  ],
  Tcommaaccentedotaccent: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccentegrave: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -30
  ],
  Tcommaaccentemacron: [
    -60,
    -60,
    -60,
    -60,
    -52,
    -52,
    -52,
    -70
  ],
  Tcommaaccenteogonek: [
    -60,
    -60,
    -120,
    -120,
    -92,
    -92,
    -92,
    -70
  ],
  Tcommaaccenthyphen: [
    -120,
    -120,
    -140,
    -140,
    -92,
    -92,
    -74,
    -92
  ],
  Tcommaaccento: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentoacute: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentocircumflex: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentodieresis: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentograve: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentohungarumlaut: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentomacron: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentoslash: [
    -80,
    -80,
    -120,
    -120,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentotilde: [
    -80,
    -80,
    -60,
    -60,
    -92,
    -95,
    -92,
    -80
  ],
  Tcommaaccentperiod: [
    -80,
    -80,
    -120,
    -120,
    -90,
    -92,
    -74,
    -74
  ],
  Tcommaaccentr: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentracute: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentrcommaaccent: [
    -80,
    -80,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentsemicolon: [
    -40,
    -40,
    -20,
    -20,
    -74,
    -74,
    -65,
    -55
  ],
  Tcommaaccentu: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentuacute: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentucircumflex: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentudieresis: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentugrave: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentuhungarumlaut: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentumacron: [
    -90,
    -90,
    -60,
    -60,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentuogonek: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccenturing: [
    -90,
    -90,
    -120,
    -120,
    -92,
    -37,
    -55,
    -45
  ],
  Tcommaaccentw: [
    -60,
    -60,
    -120,
    -120,
    -74,
    -37,
    -74,
    -80
  ],
  Tcommaaccenty: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcommaaccentyacute: [
    -60,
    -60,
    -120,
    -120,
    -34,
    -37,
    -74,
    -80
  ],
  Tcommaaccentydieresis: [
    -60,
    -60,
    -60,
    -60,
    -34,
    -37,
    -34,
    -80
  ],
  UA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Ucomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UacuteA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UacuteAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uacutecomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uacuteperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UcircumflexA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UcircumflexAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Ucircumflexcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Ucircumflexperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UdieresisA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UdieresisAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Udieresiscomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Udieresisperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UgraveA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UgraveAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Ugravecomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Ugraveperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UhungarumlautA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UhungarumlautAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uhungarumlautcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uhungarumlautperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UmacronA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UmacronAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Umacroncomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Umacronperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UogonekA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UogonekAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uogonekcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uogonekperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  UringA: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAacute: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAbreve: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAdieresis: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAgrave: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAmacron: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAogonek: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAring: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  UringAtilde: [
    -50,
    -50,
    -40,
    -40,
    -60,
    -45,
    -40,
    -40
  ],
  Uringcomma: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  Uringperiod: [
    -30,
    -30,
    -40,
    -40,
    -50,
    0,
    -25
  ],
  VA: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAacute: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAbreve: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAcircumflex: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAdieresis: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAgrave: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAmacron: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAogonek: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAring: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VAtilde: [
    -80,
    -80,
    -80,
    -80,
    -135,
    -85,
    -60,
    -135
  ],
  VG: [
    -50,
    -50,
    -40,
    -40,
    -30,
    -10,
    0,
    -15
  ],
  VGbreve: [
    -50,
    -50,
    -40,
    -40,
    -30,
    -10,
    0,
    -15
  ],
  VGcommaaccent: [
    -50,
    -50,
    -40,
    -40,
    -30,
    -10,
    0,
    -15
  ],
  VO: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOacute: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOcircumflex: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOdieresis: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOgrave: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOhungarumlaut: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOmacron: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOslash: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  VOtilde: [
    -50,
    -50,
    -40,
    -40,
    -45,
    -30,
    -30,
    -40
  ],
  Va: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vaacute: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vabreve: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vacircumflex: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vadieresis: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vagrave: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vamacron: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vaogonek: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Varing: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -111
  ],
  Vatilde: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -111,
    -111,
    -71
  ],
  Vcolon: [
    -40,
    -40,
    -40,
    -40,
    -92,
    -74,
    -65,
    -74
  ],
  Vcomma: [
    -120,
    -120,
    -125,
    -125,
    -129,
    -129,
    -129,
    -129
  ],
  Ve: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Veacute: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Vecaron: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -71
  ],
  Vecircumflex: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -71
  ],
  Vedieresis: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -71,
    -71,
    -71
  ],
  Vedotaccent: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Vegrave: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -71,
    -71,
    -71
  ],
  Vemacron: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -71,
    -71,
    -71
  ],
  Veogonek: [
    -50,
    -50,
    -80,
    -80,
    -100,
    -111,
    -111,
    -111
  ],
  Vhyphen: [
    -80,
    -80,
    -80,
    -80,
    -74,
    -70,
    -55,
    -100
  ],
  Vo: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Voacute: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Vocircumflex: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Vodieresis: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Vograve: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Vohungarumlaut: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Vomacron: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Voslash: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -129
  ],
  Votilde: [
    -90,
    -90,
    -80,
    -80,
    -100,
    -111,
    -111,
    -89
  ],
  Vperiod: [
    -120,
    -120,
    -125,
    -125,
    -145,
    -129,
    -129,
    -129
  ],
  Vsemicolon: [
    -40,
    -40,
    -40,
    -40,
    -92,
    -74,
    -74,
    -74
  ],
  Vu: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuacute: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vucircumflex: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vudieresis: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vugrave: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuhungarumlaut: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vumacron: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuogonek: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  Vuring: [
    -60,
    -60,
    -70,
    -70,
    -92,
    -55,
    -74,
    -75
  ],
  WA: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAacute: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAbreve: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAcircumflex: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAdieresis: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAgrave: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAmacron: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAogonek: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAring: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WAtilde: [
    -60,
    -60,
    -50,
    -50,
    -120,
    -74,
    -60,
    -120
  ],
  WO: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOacute: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOcircumflex: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOdieresis: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOgrave: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOmacron: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOslash: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  WOtilde: [
    -20,
    -20,
    -20,
    -20,
    -10,
    -15,
    -25,
    -10
  ],
  Wa: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Waacute: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wabreve: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wacircumflex: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wadieresis: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wagrave: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wamacron: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Waogonek: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Waring: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Watilde: [
    -40,
    -40,
    -40,
    -40,
    -65,
    -85,
    -92,
    -80
  ],
  Wcolon: [
    -10,
    -10,
    0,
    0,
    -55,
    -55,
    -65,
    -37
  ],
  Wcomma: [
    -80,
    -80,
    -80,
    -80,
    -92,
    -74,
    -92,
    -92
  ],
  We: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Weacute: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wecaron: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wecircumflex: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wedieresis: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -50,
    -52,
    -40
  ],
  Wedotaccent: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Wegrave: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -50,
    -52,
    -40
  ],
  Wemacron: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -50,
    -52,
    -40
  ],
  Weogonek: [
    -35,
    -35,
    -30,
    -30,
    -65,
    -90,
    -92,
    -80
  ],
  Whyphen: [
    -40,
    -40,
    -40,
    -40,
    -37,
    -50,
    -37,
    -65
  ],
  Wo: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Woacute: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wocircumflex: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wodieresis: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wograve: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wohungarumlaut: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Womacron: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Woslash: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wotilde: [
    -60,
    -60,
    -30,
    -30,
    -75,
    -80,
    -92,
    -80
  ],
  Wperiod: [
    -80,
    -80,
    -80,
    -80,
    -92,
    -74,
    -92,
    -92
  ],
  Wsemicolon: [
    -10,
    -10,
    0,
    0,
    -55,
    -55,
    -65,
    -37
  ],
  Wu: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuacute: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wucircumflex: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wudieresis: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wugrave: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuhungarumlaut: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wumacron: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuogonek: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wuring: [
    -45,
    -45,
    -30,
    -30,
    -50,
    -55,
    -55,
    -50
  ],
  Wy: [
    -20,
    -20,
    -20,
    -20,
    -60,
    -55,
    -70,
    -73
  ],
  Wyacute: [
    -20,
    -20,
    -20,
    -20,
    -60,
    -55,
    -70,
    -73
  ],
  Wydieresis: [
    -20,
    -20,
    -20,
    -20,
    -60,
    -55,
    -70,
    -73
  ],
  YA: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAacute: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAbreve: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAcircumflex: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAdieresis: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAgrave: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAmacron: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAogonek: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAring: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YAtilde: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YO: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOacute: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOcircumflex: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOdieresis: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOgrave: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOhungarumlaut: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOmacron: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOslash: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YOtilde: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  Ya: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yaacute: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yabreve: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Yacircumflex: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yadieresis: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yagrave: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yamacron: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Yaogonek: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yaring: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yatilde: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Ycolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Ycomma: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -92,
    -92,
    -129
  ],
  Ye: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yeacute: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yecaron: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yecircumflex: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -71,
    -92,
    -100
  ],
  Yedieresis: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yedotaccent: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yegrave: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yemacron: [
    -80,
    -80,
    -70,
    -70,
    -71,
    -71,
    -52,
    -60
  ],
  Yeogonek: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yo: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yoacute: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yocircumflex: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yodieresis: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yograve: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yohungarumlaut: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yomacron: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yoslash: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yotilde: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yperiod: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -74,
    -92,
    -129
  ],
  Ysemicolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Yu: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yuacute: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yucircumflex: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yudieresis: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yugrave: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yuhungarumlaut: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yumacron: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yuogonek: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yuring: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  YacuteA: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAacute: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAbreve: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAcircumflex: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAdieresis: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAgrave: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAmacron: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAogonek: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAring: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteAtilde: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YacuteO: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOacute: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOcircumflex: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOdieresis: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOgrave: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOhungarumlaut: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOmacron: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOslash: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YacuteOtilde: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  Yacutea: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteaacute: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteabreve: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteacircumflex: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteadieresis: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yacuteagrave: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Yacuteamacron: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Yacuteaogonek: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacutearing: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Yacuteatilde: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Yacutecolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Yacutecomma: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -92,
    -92,
    -129
  ],
  Yacutee: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteeacute: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteecaron: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteecircumflex: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -71,
    -92,
    -100
  ],
  Yacuteedieresis: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yacuteedotaccent: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteegrave: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Yacuteemacron: [
    -80,
    -80,
    -70,
    -70,
    -71,
    -71,
    -52,
    -60
  ],
  Yacuteeogonek: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Yacuteo: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteoacute: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteocircumflex: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteodieresis: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteograve: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteohungarumlaut: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteomacron: [
    -100,
    -100,
    -70,
    -70,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteoslash: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Yacuteotilde: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Yacuteperiod: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -74,
    -92,
    -129
  ],
  Yacutesemicolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Yacuteu: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteuacute: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteucircumflex: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteudieresis: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yacuteugrave: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yacuteuhungarumlaut: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteumacron: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Yacuteuogonek: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Yacuteuring: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  YdieresisA: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAacute: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAbreve: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAcircumflex: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAdieresis: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAgrave: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAmacron: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAogonek: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAring: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisAtilde: [
    -110,
    -110,
    -110,
    -110,
    -110,
    -74,
    -50,
    -120
  ],
  YdieresisO: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOacute: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOcircumflex: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOdieresis: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOgrave: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOhungarumlaut: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOmacron: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOslash: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  YdieresisOtilde: [
    -70,
    -70,
    -85,
    -85,
    -35,
    -25,
    -15,
    -30
  ],
  Ydieresisa: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisaacute: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisabreve: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisacircumflex: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisadieresis: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Ydieresisagrave: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -60
  ],
  Ydieresisamacron: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -60
  ],
  Ydieresisaogonek: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisaring: [
    -90,
    -90,
    -140,
    -140,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresisatilde: [
    -90,
    -90,
    -70,
    -70,
    -85,
    -92,
    -92,
    -100
  ],
  Ydieresiscolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Ydieresiscomma: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -92,
    -92,
    -129
  ],
  Ydieresise: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresiseacute: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresisecaron: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresisecircumflex: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -71,
    -92,
    -100
  ],
  Ydieresisedieresis: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Ydieresisedotaccent: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresisegrave: [
    -80,
    -80,
    -140,
    -140,
    -71,
    -71,
    -52,
    -60
  ],
  Ydieresisemacron: [
    -80,
    -80,
    -70,
    -70,
    -71,
    -71,
    -52,
    -60
  ],
  Ydieresiseogonek: [
    -80,
    -80,
    -140,
    -140,
    -111,
    -111,
    -92,
    -100
  ],
  Ydieresiso: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisoacute: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisocircumflex: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisodieresis: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisograve: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisohungarumlaut: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisomacron: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisoslash: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -110
  ],
  Ydieresisotilde: [
    -100,
    -100,
    -140,
    -140,
    -111,
    -111,
    -92,
    -70
  ],
  Ydieresisperiod: [
    -100,
    -100,
    -140,
    -140,
    -92,
    -74,
    -92,
    -129
  ],
  Ydieresissemicolon: [
    -50,
    -50,
    -60,
    -60,
    -92,
    -92,
    -65,
    -92
  ],
  Ydieresisu: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisuacute: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisucircumflex: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisudieresis: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Ydieresisugrave: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Ydieresisuhungarumlaut: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisumacron: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -71
  ],
  Ydieresisuogonek: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  Ydieresisuring: [
    -100,
    -100,
    -110,
    -110,
    -92,
    -92,
    -92,
    -111
  ],
  ag: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  av: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  ay: [
    -20,
    -20,
    -30,
    -30
  ],
  ayacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  aacuteg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aacutegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aacutegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aacutev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aacutew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  aacutey: [
    -20,
    -20,
    -30,
    -30
  ],
  aacuteyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aacuteydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  abreveg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  abrevegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  abrevegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  abrevev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  abrevew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  abrevey: [
    -20,
    -20,
    -30,
    -30
  ],
  abreveyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  abreveydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  acircumflexg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  acircumflexgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  acircumflexgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  acircumflexv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  acircumflexw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  acircumflexy: [
    -20,
    -20,
    -30,
    -30
  ],
  acircumflexyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  acircumflexydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  adieresisg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  adieresisgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  adieresisgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  adieresisv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  adieresisw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  adieresisy: [
    -20,
    -20,
    -30,
    -30
  ],
  adieresisyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  adieresisydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  agraveg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agravegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agravegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  agravev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  agravew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  agravey: [
    -20,
    -20,
    -30,
    -30
  ],
  agraveyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  agraveydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  amacrong: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  amacrongbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  amacrongcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  amacronv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  amacronw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  amacrony: [
    -20,
    -20,
    -30,
    -30
  ],
  amacronyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  amacronydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  aogonekg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aogonekgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aogonekgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aogonekv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aogonekw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  aogoneky: [
    -20,
    -20,
    -30,
    -30
  ],
  aogonekyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aogonekydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  aringg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aringgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aringgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  aringv: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  aringw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  aringy: [
    -20,
    -20,
    -30,
    -30
  ],
  aringyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  aringydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  atildeg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  atildegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  atildegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  atildev: [
    -15,
    -15,
    -20,
    -20,
    -25,
    0,
    0,
    -20
  ],
  atildew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    0,
    -15
  ],
  atildey: [
    -20,
    -20,
    -30,
    -30
  ],
  atildeyacute: [
    -20,
    -20,
    -30,
    -30
  ],
  atildeydieresis: [
    -20,
    -20,
    -30,
    -30
  ],
  bl: [
    -10,
    -10,
    -20,
    -20
  ],
  blacute: [
    -10,
    -10,
    -20,
    -20
  ],
  blcommaaccent: [
    -10,
    -10,
    -20,
    -20
  ],
  blslash: [
    -10,
    -10,
    -20,
    -20
  ],
  bu: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buacute: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bucircumflex: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  budieresis: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bugrave: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buhungarumlaut: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bumacron: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buogonek: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  buring: [
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20,
    -20
  ],
  bv: [
    -20,
    -20,
    -20,
    -20,
    -15,
    0,
    0,
    -15
  ],
  by: [
    -20,
    -20,
    -20,
    -20
  ],
  byacute: [
    -20,
    -20,
    -20,
    -20
  ],
  bydieresis: [
    -20,
    -20,
    -20,
    -20
  ],
  ch: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  ck: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ckcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  cl: [
    -20,
    -20
  ],
  clacute: [
    -20,
    -20
  ],
  clcommaaccent: [
    -20,
    -20
  ],
  clslash: [
    -20,
    -20
  ],
  cy: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cyacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cacuteh: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  cacutek: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  cacutekcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  cacutel: [
    -20,
    -20
  ],
  cacutelacute: [
    -20,
    -20
  ],
  cacutelcommaaccent: [
    -20,
    -20
  ],
  cacutelslash: [
    -20,
    -20
  ],
  cacutey: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cacuteyacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  cacuteydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccaronh: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  ccaronk: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccaronkcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccaronl: [
    -20,
    -20
  ],
  ccaronlacute: [
    -20,
    -20
  ],
  ccaronlcommaaccent: [
    -20,
    -20
  ],
  ccaronlslash: [
    -20,
    -20
  ],
  ccarony: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccaronyacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccaronydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccedillah: [
    -10,
    -10,
    0,
    0,
    0,
    -10,
    -15
  ],
  ccedillak: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccedillakcommaaccent: [
    -20,
    -20,
    -20,
    -20,
    0,
    -10,
    -20
  ],
  ccedillal: [
    -20,
    -20
  ],
  ccedillalacute: [
    -20,
    -20
  ],
  ccedillalcommaaccent: [
    -20,
    -20
  ],
  ccedillalslash: [
    -20,
    -20
  ],
  ccedillay: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccedillayacute: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  ccedillaydieresis: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    0,
    -15
  ],
  colonspace: [
    -40,
    -40,
    -50,
    -50
  ],
  commaquotedblright: [
    -120,
    -120,
    -100,
    -100,
    -45,
    -95,
    -140,
    -70
  ],
  commaquoteright: [
    -120,
    -120,
    -100,
    -100,
    -55,
    -95,
    -140,
    -70
  ],
  commaspace: [
    -40,
    -40
  ],
  dd: [
    -10,
    -10
  ],
  ddcroat: [
    -10,
    -10
  ],
  dv: [
    -15,
    -15
  ],
  dw: [
    -15,
    -15,
    0,
    0,
    -15
  ],
  dy: [
    -15,
    -15
  ],
  dyacute: [
    -15,
    -15
  ],
  dydieresis: [
    -15,
    -15
  ],
  dcroatd: [
    -10,
    -10
  ],
  dcroatdcroat: [
    -10,
    -10
  ],
  dcroatv: [
    -15,
    -15
  ],
  dcroatw: [
    -15,
    -15,
    0,
    0,
    -15
  ],
  dcroaty: [
    -15,
    -15
  ],
  dcroatyacute: [
    -15,
    -15
  ],
  dcroatydieresis: [
    -15,
    -15
  ],
  ecomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  eperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  ev: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  ew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  ex: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  ey: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eacutecomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  eacuteperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  eacutev: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  eacutew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  eacutex: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  eacutey: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eacuteyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eacuteydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecaroncomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  ecaronperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  ecaronv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  ecaronw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  ecaronx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  ecarony: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecaronyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecaronydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecircumflexcomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  ecircumflexperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  ecircumflexv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  ecircumflexw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  ecircumflexx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  ecircumflexy: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecircumflexyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  ecircumflexydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edieresiscomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  edieresisperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  edieresisv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  edieresisw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  edieresisx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  edieresisy: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edieresisyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edieresisydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edotaccentcomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  edotaccentperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  edotaccentv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  edotaccentw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  edotaccentx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  edotaccenty: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edotaccentyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  edotaccentydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  egravecomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  egraveperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  egravev: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  egravew: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  egravex: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  egravey: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  egraveyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  egraveydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  emacroncomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  emacronperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  emacronv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  emacronw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  emacronx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  emacrony: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  emacronyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  emacronydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eogonekcomma: [
    10,
    10,
    -15,
    -15,
    0,
    0,
    -10
  ],
  eogonekperiod: [
    20,
    20,
    -15,
    -15,
    0,
    0,
    -15
  ],
  eogonekv: [
    -15,
    -15,
    -30,
    -30,
    -15,
    0,
    -15,
    -25
  ],
  eogonekw: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -15,
    -25
  ],
  eogonekx: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    -20,
    -15
  ],
  eogoneky: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eogonekyacute: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  eogonekydieresis: [
    -15,
    -15,
    -20,
    -20,
    0,
    0,
    -30,
    -15
  ],
  fcomma: [
    -10,
    -10,
    -30,
    -30,
    -15,
    -10,
    -10
  ],
  fe: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  feacute: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  fecaron: [
    -10,
    -10,
    -30,
    -30
  ],
  fecircumflex: [
    -10,
    -10,
    -30,
    -30
  ],
  fedieresis: [
    -10,
    -10,
    -30,
    -30
  ],
  fedotaccent: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  fegrave: [
    -10,
    -10,
    -30,
    -30
  ],
  femacron: [
    -10,
    -10,
    -30,
    -30
  ],
  feogonek: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10
  ],
  fo: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  foacute: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  focircumflex: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fodieresis: [
    -20,
    -20,
    -30,
    -30,
    -25
  ],
  fograve: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fohungarumlaut: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fomacron: [
    -20,
    -20,
    -30,
    -30,
    -25
  ],
  foslash: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fotilde: [
    -20,
    -20,
    -30,
    -30,
    -25,
    -10
  ],
  fperiod: [
    -10,
    -10,
    -30,
    -30,
    -15,
    -10,
    -15
  ],
  fquotedblright: [
    30,
    30,
    60,
    60,
    50
  ],
  fquoteright: [
    30,
    30,
    50,
    50,
    55,
    55,
    92,
    55
  ],
  ge: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  geacute: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gecaron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gecircumflex: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gedieresis: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gedotaccent: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gegrave: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gemacron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  geogonek: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  ggbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  ggcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevee: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveeacute: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveecaron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveecircumflex: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveedieresis: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveedotaccent: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveegrave: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveemacron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveeogonek: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbreveg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevegbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevegcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccente: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccenteacute: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentecaron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentecircumflex: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentedieresis: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentedotaccent: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentegrave: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentemacron: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccenteogonek: [
    10,
    10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentg: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentgbreve: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentgcommaaccent: [
    -10,
    -10,
    0,
    0,
    0,
    0,
    -10
  ],
  hy: [
    -20,
    -20,
    -30,
    -30,
    -15,
    0,
    0,
    -5
  ],
  hyacute: [
    -20,
    -20,
    -30,
    -30,
    -15,
    0,
    0,
    -5
  ],
  hydieresis: [
    -20,
    -20,
    -30,
    -30,
    -15,
    0,
    0,
    -5
  ],
  ko: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  koacute: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kocircumflex: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kodieresis: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kograve: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kohungarumlaut: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  komacron: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  koslash: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kotilde: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccento: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentoacute: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentocircumflex: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentodieresis: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentograve: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentohungarumlaut: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentomacron: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentoslash: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  kcommaaccentotilde: [
    -15,
    -15,
    -20,
    -20,
    -15,
    -10,
    -10,
    -10
  ],
  lw: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ly: [
    -15,
    -15
  ],
  lyacute: [
    -15,
    -15
  ],
  lydieresis: [
    -15,
    -15
  ],
  lacutew: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  lacutey: [
    -15,
    -15
  ],
  lacuteyacute: [
    -15,
    -15
  ],
  lacuteydieresis: [
    -15,
    -15
  ],
  lcommaaccentw: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  lcommaaccenty: [
    -15,
    -15
  ],
  lcommaaccentyacute: [
    -15,
    -15
  ],
  lcommaaccentydieresis: [
    -15,
    -15
  ],
  lslashw: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  lslashy: [
    -15,
    -15
  ],
  lslashyacute: [
    -15,
    -15
  ],
  lslashydieresis: [
    -15,
    -15
  ],
  mu: [
    -20,
    -20,
    -10,
    -10
  ],
  muacute: [
    -20,
    -20,
    -10,
    -10
  ],
  mucircumflex: [
    -20,
    -20,
    -10,
    -10
  ],
  mudieresis: [
    -20,
    -20,
    -10,
    -10
  ],
  mugrave: [
    -20,
    -20,
    -10,
    -10
  ],
  muhungarumlaut: [
    -20,
    -20,
    -10,
    -10
  ],
  mumacron: [
    -20,
    -20,
    -10,
    -10
  ],
  muogonek: [
    -20,
    -20,
    -10,
    -10
  ],
  muring: [
    -20,
    -20,
    -10,
    -10
  ],
  my: [
    -30,
    -30,
    -15,
    -15
  ],
  myacute: [
    -30,
    -30,
    -15,
    -15
  ],
  mydieresis: [
    -30,
    -30,
    -15,
    -15
  ],
  nu: [
    -10,
    -10,
    -10,
    -10
  ],
  nuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  nucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  nudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  nugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  nuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  numacron: [
    -10,
    -10,
    -10,
    -10
  ],
  nuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  nuring: [
    -10,
    -10,
    -10,
    -10
  ],
  nv: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ny: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nacuteu: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  nacuteuring: [
    -10,
    -10,
    -10,
    -10
  ],
  nacutev: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  nacutey: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nacuteyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  nacuteydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncaronu: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronuring: [
    -10,
    -10,
    -10,
    -10
  ],
  ncaronv: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ncarony: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncaronyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncaronydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncommaaccentu: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccenturing: [
    -10,
    -10,
    -10,
    -10
  ],
  ncommaaccentv: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ncommaaccenty: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncommaaccentyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ncommaaccentydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ntildeu: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuacute: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeucircumflex: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeudieresis: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeugrave: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuhungarumlaut: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeumacron: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuogonek: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildeuring: [
    -10,
    -10,
    -10,
    -10
  ],
  ntildev: [
    -40,
    -40,
    -20,
    -20,
    -40,
    -40,
    -40,
    -40
  ],
  ntildey: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ntildeyacute: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ntildeydieresis: [
    -20,
    -20,
    -15,
    -15,
    0,
    0,
    0,
    -15
  ],
  ov: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ow: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ox: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  oy: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oacutev: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  oacutew: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  oacutex: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  oacutey: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oacuteyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oacuteydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ocircumflexv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ocircumflexw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ocircumflexx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  ocircumflexy: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ocircumflexyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ocircumflexydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  odieresisv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  odieresisw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  odieresisx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  odieresisy: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  odieresisyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  odieresisydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ogravev: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ogravew: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ogravex: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  ogravey: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ograveyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ograveydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ohungarumlautv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  ohungarumlautw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  ohungarumlautx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  ohungarumlauty: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ohungarumlautyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  ohungarumlautydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  omacronv: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  omacronw: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  omacronx: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  omacrony: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  omacronyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  omacronydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  oslashv: [
    -20,
    -20,
    -70,
    -70,
    -10,
    -15,
    -10,
    -15
  ],
  oslashw: [
    -15,
    -15,
    -70,
    -70,
    -10,
    -25,
    0,
    -25
  ],
  oslashx: [
    -30,
    -30,
    -85,
    -85,
    0,
    -10
  ],
  oslashy: [
    -20,
    -20,
    -70,
    -70,
    0,
    -10,
    0,
    -10
  ],
  oslashyacute: [
    -20,
    -20,
    -70,
    -70,
    0,
    -10,
    0,
    -10
  ],
  oslashydieresis: [
    -20,
    -20,
    -70,
    -70,
    0,
    -10,
    0,
    -10
  ],
  otildev: [
    -20,
    -20,
    -15,
    -15,
    -10,
    -15,
    -10,
    -15
  ],
  otildew: [
    -15,
    -15,
    -15,
    -15,
    -10,
    -25,
    0,
    -25
  ],
  otildex: [
    -30,
    -30,
    -30,
    -30,
    0,
    -10
  ],
  otildey: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  otildeyacute: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  otildeydieresis: [
    -20,
    -20,
    -30,
    -30,
    0,
    -10,
    0,
    -10
  ],
  py: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  pyacute: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  pydieresis: [
    -15,
    -15,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  periodquotedblright: [
    -120,
    -120,
    -100,
    -100,
    -55,
    -95,
    -140,
    -70
  ],
  periodquoteright: [
    -120,
    -120,
    -100,
    -100,
    -55,
    -95,
    -140,
    -70
  ],
  periodspace: [
    -40,
    -40,
    -60,
    -60
  ],
  quotedblrightspace: [
    -80,
    -80,
    -40,
    -40
  ],
  quoteleftquoteleft: [
    -46,
    -46,
    -57,
    -57,
    -63,
    -74,
    -111,
    -74
  ],
  quoterightd: [
    -80,
    -80,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightdcroat: [
    -80,
    -80,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightl: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightlacute: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightlcommaaccent: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightlslash: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  quoterightquoteright: [
    -46,
    -46,
    -57,
    -57,
    -63,
    -74,
    -111,
    -74
  ],
  quoterightr: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightracute: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightrcaron: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterightrcommaaccent: [
    -40,
    -40,
    -50,
    -50,
    -20,
    -15,
    -25,
    -50
  ],
  quoterights: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightsacute: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightscaron: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightscedilla: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightscommaaccent: [
    -60,
    -60,
    -50,
    -50,
    -37,
    -74,
    -40,
    -55
  ],
  quoterightspace: [
    -80,
    -80,
    -70,
    -70,
    -74,
    -74,
    -111,
    -74
  ],
  quoterightv: [
    -20,
    -20,
    0,
    0,
    -20,
    -15,
    -10,
    -50
  ],
  rc: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  rd: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rdcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rg: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rgbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rgcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rhyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  ro: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  roacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  romacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  roslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  rq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rs: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rsacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rscaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rscedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rscommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rt: [
    20,
    20,
    40,
    40
  ],
  rtcommaaccent: [
    20,
    20,
    40,
    40
  ],
  rv: [
    10,
    10,
    30,
    30,
    -10
  ],
  ry: [
    10,
    10,
    30,
    30
  ],
  ryacute: [
    10,
    10,
    30,
    30
  ],
  rydieresis: [
    10,
    10,
    30,
    30
  ],
  racutec: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutecacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutecomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  racuted: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  racutedcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  racuteg: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  racutegbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  racutegcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  racutehyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  racuteo: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteoacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteomacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteoslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  racuteperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  racuteq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutes: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutesacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutescaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutescedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutescommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  racutet: [
    20,
    20,
    40,
    40
  ],
  racutetcommaaccent: [
    20,
    20,
    40,
    40
  ],
  racutev: [
    10,
    10,
    30,
    30,
    -10
  ],
  racutey: [
    10,
    10,
    30,
    30
  ],
  racuteyacute: [
    10,
    10,
    30,
    30
  ],
  racuteydieresis: [
    10,
    10,
    30,
    30
  ],
  rcaronc: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroncacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroncomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  rcarond: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcarondcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcarong: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcarongbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcarongcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcaronhyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  rcarono: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronoacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronomacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronoslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcaronperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  rcaronq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcarons: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronsacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronscaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronscedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaronscommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcaront: [
    20,
    20,
    40,
    40
  ],
  rcarontcommaaccent: [
    20,
    20,
    40,
    40
  ],
  rcaronv: [
    10,
    10,
    30,
    30,
    -10
  ],
  rcarony: [
    10,
    10,
    30,
    30
  ],
  rcaronyacute: [
    10,
    10,
    30,
    30
  ],
  rcaronydieresis: [
    10,
    10,
    30,
    30
  ],
  rcommaaccentc: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentcacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentccaron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentccedilla: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentcomma: [
    -60,
    -60,
    -50,
    -50,
    -92,
    -65,
    -111,
    -40
  ],
  rcommaaccentd: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcommaaccentdcroat: [
    -20,
    -20,
    0,
    0,
    0,
    0,
    -37
  ],
  rcommaaccentg: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcommaaccentgbreve: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcommaaccentgcommaaccent: [
    -15,
    -15,
    0,
    0,
    -10,
    0,
    -37,
    -18
  ],
  rcommaaccenthyphen: [
    -20,
    -20,
    0,
    0,
    -37,
    0,
    -20,
    -20
  ],
  rcommaaccento: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentoacute: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentocircumflex: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentodieresis: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentograve: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentohungarumlaut: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentomacron: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentoslash: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentotilde: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -45
  ],
  rcommaaccentperiod: [
    -60,
    -60,
    -50,
    -50,
    -100,
    -65,
    -111,
    -55
  ],
  rcommaaccentq: [
    -20,
    -20,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccents: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentsacute: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentscaron: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentscedilla: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentscommaaccent: [
    -15,
    -15,
    0,
    0,
    0,
    0,
    -10
  ],
  rcommaaccentt: [
    20,
    20,
    40,
    40
  ],
  rcommaaccenttcommaaccent: [
    20,
    20,
    40,
    40
  ],
  rcommaaccentv: [
    10,
    10,
    30,
    30,
    -10
  ],
  rcommaaccenty: [
    10,
    10,
    30,
    30
  ],
  rcommaaccentyacute: [
    10,
    10,
    30,
    30
  ],
  rcommaaccentydieresis: [
    10,
    10,
    30,
    30
  ],
  sw: [
    -15,
    -15,
    -30,
    -30
  ],
  sacutew: [
    -15,
    -15,
    -30,
    -30
  ],
  scaronw: [
    -15,
    -15,
    -30,
    -30
  ],
  scedillaw: [
    -15,
    -15,
    -30,
    -30
  ],
  scommaaccentw: [
    -15,
    -15,
    -30,
    -30
  ],
  semicolonspace: [
    -40,
    -40,
    -50,
    -50
  ],
  spaceT: [
    -100,
    -100,
    -50,
    -50,
    -30,
    0,
    -18,
    -18
  ],
  spaceTcaron: [
    -100,
    -100,
    -50,
    -50,
    -30,
    0,
    -18,
    -18
  ],
  spaceTcommaaccent: [
    -100,
    -100,
    -50,
    -50,
    -30,
    0,
    -18,
    -18
  ],
  spaceV: [
    -80,
    -80,
    -50,
    -50,
    -45,
    -70,
    -35,
    -50
  ],
  spaceW: [
    -80,
    -80,
    -40,
    -40,
    -30,
    -70,
    -40,
    -30
  ],
  spaceY: [
    -120,
    -120,
    -90,
    -90,
    -55,
    -70,
    -75,
    -90
  ],
  spaceYacute: [
    -120,
    -120,
    -90,
    -90,
    -55,
    -70,
    -75,
    -90
  ],
  spaceYdieresis: [
    -120,
    -120,
    -90,
    -90,
    -55,
    -70,
    -75,
    -90
  ],
  spacequotedblleft: [
    -80,
    -80,
    -30,
    -30
  ],
  spacequoteleft: [
    -60,
    -60,
    -60,
    -60
  ],
  va: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vaacute: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vabreve: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vacircumflex: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vadieresis: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vagrave: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vamacron: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vaogonek: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  varing: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vatilde: [
    -20,
    -20,
    -25,
    -25,
    -10,
    0,
    0,
    -25
  ],
  vcomma: [
    -80,
    -80,
    -80,
    -80,
    -55,
    -37,
    -74,
    -65
  ],
  vo: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  voacute: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vocircumflex: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vodieresis: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vograve: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vohungarumlaut: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vomacron: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  voslash: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  votilde: [
    -30,
    -30,
    -25,
    -25,
    -10,
    -15,
    0,
    -20
  ],
  vperiod: [
    -80,
    -80,
    -80,
    -80,
    -70,
    -37,
    -74,
    -65
  ],
  wcomma: [
    -40,
    -40,
    -60,
    -60,
    -55,
    -37,
    -74,
    -65
  ],
  wo: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  woacute: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wocircumflex: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wodieresis: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wograve: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wohungarumlaut: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  womacron: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  woslash: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wotilde: [
    -20,
    -20,
    -10,
    -10,
    -10,
    -15,
    0,
    -10
  ],
  wperiod: [
    -40,
    -40,
    -60,
    -60,
    -70,
    -37,
    -74,
    -65
  ],
  xe: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xeacute: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xecaron: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xecircumflex: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xedieresis: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xedotaccent: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xegrave: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xemacron: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  xeogonek: [
    -10,
    -10,
    -30,
    -30,
    0,
    -10,
    0,
    -15
  ],
  ya: [
    -30,
    -30,
    -20,
    -20
  ],
  yaacute: [
    -30,
    -30,
    -20,
    -20
  ],
  yabreve: [
    -30,
    -30,
    -20,
    -20
  ],
  yacircumflex: [
    -30,
    -30,
    -20,
    -20
  ],
  yadieresis: [
    -30,
    -30,
    -20,
    -20
  ],
  yagrave: [
    -30,
    -30,
    -20,
    -20
  ],
  yamacron: [
    -30,
    -30,
    -20,
    -20
  ],
  yaogonek: [
    -30,
    -30,
    -20,
    -20
  ],
  yaring: [
    -30,
    -30,
    -20,
    -20
  ],
  yatilde: [
    -30,
    -30,
    -20,
    -20
  ],
  ycomma: [
    -80,
    -80,
    -100,
    -100,
    -55,
    -37,
    -55,
    -65
  ],
  ye: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yeacute: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yecaron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yecircumflex: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yedieresis: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yedotaccent: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yegrave: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yemacron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yeogonek: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yo: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yoacute: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yocircumflex: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yodieresis: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yograve: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yohungarumlaut: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yomacron: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yoslash: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yotilde: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yperiod: [
    -80,
    -80,
    -100,
    -100,
    -70,
    -37,
    -55,
    -65
  ],
  yacutea: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteaacute: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteabreve: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteacircumflex: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteadieresis: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteagrave: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteamacron: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteaogonek: [
    -30,
    -30,
    -20,
    -20
  ],
  yacutearing: [
    -30,
    -30,
    -20,
    -20
  ],
  yacuteatilde: [
    -30,
    -30,
    -20,
    -20
  ],
  yacutecomma: [
    -80,
    -80,
    -100,
    -100,
    -55,
    -37,
    -55,
    -65
  ],
  yacutee: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteeacute: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteecaron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteecircumflex: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteedieresis: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteedotaccent: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteegrave: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteemacron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteeogonek: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  yacuteo: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteoacute: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteocircumflex: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteodieresis: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteograve: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteohungarumlaut: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteomacron: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteoslash: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteotilde: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  yacuteperiod: [
    -80,
    -80,
    -100,
    -100,
    -70,
    -37,
    -55,
    -65
  ],
  ydieresisa: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisaacute: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisabreve: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisacircumflex: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisadieresis: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisagrave: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisamacron: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisaogonek: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisaring: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresisatilde: [
    -30,
    -30,
    -20,
    -20
  ],
  ydieresiscomma: [
    -80,
    -80,
    -100,
    -100,
    -55,
    -37,
    -55,
    -65
  ],
  ydieresise: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresiseacute: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisecaron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisecircumflex: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisedieresis: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisedotaccent: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisegrave: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresisemacron: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresiseogonek: [
    -10,
    -10,
    -20,
    -20,
    -10
  ],
  ydieresiso: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisoacute: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisocircumflex: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisodieresis: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisograve: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisohungarumlaut: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisomacron: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisoslash: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisotilde: [
    -25,
    -25,
    -20,
    -20,
    -25
  ],
  ydieresisperiod: [
    -80,
    -80,
    -100,
    -100,
    -70,
    -37,
    -55,
    -65
  ],
  ze: [
    10,
    10,
    -15,
    -15
  ],
  zeacute: [
    10,
    10,
    -15,
    -15
  ],
  zecaron: [
    10,
    10,
    -15,
    -15
  ],
  zecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zegrave: [
    10,
    10,
    -15,
    -15
  ],
  zemacron: [
    10,
    10,
    -15,
    -15
  ],
  zeogonek: [
    10,
    10,
    -15,
    -15
  ],
  zacutee: [
    10,
    10,
    -15,
    -15
  ],
  zacuteeacute: [
    10,
    10,
    -15,
    -15
  ],
  zacuteecaron: [
    10,
    10,
    -15,
    -15
  ],
  zacuteecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zacuteedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zacuteedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zacuteegrave: [
    10,
    10,
    -15,
    -15
  ],
  zacuteemacron: [
    10,
    10,
    -15,
    -15
  ],
  zacuteeogonek: [
    10,
    10,
    -15,
    -15
  ],
  zcarone: [
    10,
    10,
    -15,
    -15
  ],
  zcaroneacute: [
    10,
    10,
    -15,
    -15
  ],
  zcaronecaron: [
    10,
    10,
    -15,
    -15
  ],
  zcaronecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zcaronedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zcaronedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zcaronegrave: [
    10,
    10,
    -15,
    -15
  ],
  zcaronemacron: [
    10,
    10,
    -15,
    -15
  ],
  zcaroneogonek: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccente: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccenteacute: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentecaron: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentecircumflex: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentedieresis: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentedotaccent: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentegrave: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccentemacron: [
    10,
    10,
    -15,
    -15
  ],
  zdotaccenteogonek: [
    10,
    10,
    -15,
    -15
  ],
  Bcomma: [
    0,
    0,
    -20,
    -20
  ],
  Bperiod: [
    0,
    0,
    -20,
    -20
  ],
  Ccomma: [
    0,
    0,
    -30,
    -30
  ],
  Cperiod: [
    0,
    0,
    -30,
    -30
  ],
  Cacutecomma: [
    0,
    0,
    -30,
    -30
  ],
  Cacuteperiod: [
    0,
    0,
    -30,
    -30
  ],
  Ccaroncomma: [
    0,
    0,
    -30,
    -30
  ],
  Ccaronperiod: [
    0,
    0,
    -30,
    -30
  ],
  Ccedillacomma: [
    0,
    0,
    -30,
    -30
  ],
  Ccedillaperiod: [
    0,
    0,
    -30,
    -30
  ],
  Fe: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Feacute: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fecaron: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fecircumflex: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fedieresis: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fedotaccent: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fegrave: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Femacron: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Feogonek: [
    0,
    0,
    -30,
    -30,
    -25,
    -100,
    -75
  ],
  Fo: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Foacute: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Focircumflex: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fodieresis: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fograve: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fohungarumlaut: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fomacron: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Foslash: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fotilde: [
    0,
    0,
    -30,
    -30,
    -25,
    -70,
    -105,
    -15
  ],
  Fr: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Fracute: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Frcaron: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Frcommaaccent: [
    0,
    0,
    -45,
    -45,
    0,
    -50,
    -55
  ],
  Ja: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jaacute: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jabreve: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jacircumflex: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jadieresis: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jagrave: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jamacron: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jaogonek: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jaring: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  Jatilde: [
    0,
    0,
    -20,
    -20,
    -15,
    -40,
    -35
  ],
  LcaronT: [
    0,
    0,
    -110,
    -110
  ],
  LcaronTcaron: [
    0,
    0,
    -110,
    -110
  ],
  LcaronTcommaaccent: [
    0,
    0,
    -110,
    -110
  ],
  LcaronV: [
    0,
    0,
    -110,
    -110
  ],
  LcaronW: [
    0,
    0,
    -70,
    -70
  ],
  LcaronY: [
    0,
    0,
    -140,
    -140
  ],
  LcaronYacute: [
    0,
    0,
    -140,
    -140
  ],
  LcaronYdieresis: [
    0,
    0,
    -140,
    -140
  ],
  Lcaronquotedblright: [
    0,
    0,
    -140,
    -140
  ],
  Lcaronquoteright: [
    0,
    0,
    -160,
    -160,
    0,
    0,
    0,
    -92
  ],
  Lcarony: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -55
  ],
  Lcaronyacute: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -55
  ],
  Lcaronydieresis: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -55
  ],
  Scomma: [
    0,
    0,
    -20,
    -20
  ],
  Speriod: [
    0,
    0,
    -20,
    -20
  ],
  Sacutecomma: [
    0,
    0,
    -20,
    -20
  ],
  Sacuteperiod: [
    0,
    0,
    -20,
    -20
  ],
  Scaroncomma: [
    0,
    0,
    -20,
    -20
  ],
  Scaronperiod: [
    0,
    0,
    -20,
    -20
  ],
  Scedillacomma: [
    0,
    0,
    -20,
    -20
  ],
  Scedillaperiod: [
    0,
    0,
    -20,
    -20
  ],
  Scommaaccentcomma: [
    0,
    0,
    -20,
    -20
  ],
  Scommaaccentperiod: [
    0,
    0,
    -20,
    -20
  ],
  Trcaron: [
    0,
    0,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcaronrcaron: [
    0,
    0,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Tcommaaccentrcaron: [
    0,
    0,
    -120,
    -120,
    -74,
    -37,
    -55,
    -35
  ],
  Yhyphen: [
    0,
    0,
    -140,
    -140,
    -92,
    -92,
    -74,
    -111
  ],
  Yi: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yiacute: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yiogonek: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yacutehyphen: [
    0,
    0,
    -140,
    -140,
    -92,
    -92,
    -74,
    -111
  ],
  Yacutei: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yacuteiacute: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Yacuteiogonek: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Ydieresishyphen: [
    0,
    0,
    -140,
    -140,
    -92,
    -92,
    -74,
    -111
  ],
  Ydieresisi: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Ydieresisiacute: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  Ydieresisiogonek: [
    0,
    0,
    -20,
    -20,
    -37,
    -55,
    -74,
    -55
  ],
  bb: [
    0,
    0,
    -10,
    -10,
    -10,
    -10
  ],
  bcomma: [
    0,
    0,
    -40,
    -40
  ],
  bperiod: [
    0,
    0,
    -40,
    -40,
    -40,
    -40,
    -40,
    -40
  ],
  ccomma: [
    0,
    0,
    -15,
    -15
  ],
  cacutecomma: [
    0,
    0,
    -15,
    -15
  ],
  ccaroncomma: [
    0,
    0,
    -15,
    -15
  ],
  ccedillacomma: [
    0,
    0,
    -15,
    -15
  ],
  fa: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  faacute: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fabreve: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  facircumflex: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fadieresis: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fagrave: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  famacron: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  faogonek: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  faring: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fatilde: [
    0,
    0,
    -30,
    -30,
    0,
    0,
    0,
    -10
  ],
  fdotlessi: [
    0,
    0,
    -28,
    -28,
    -35,
    -30,
    -60,
    -50
  ],
  gr: [
    0,
    0,
    -10,
    -10
  ],
  gracute: [
    0,
    0,
    -10,
    -10
  ],
  grcaron: [
    0,
    0,
    -10,
    -10
  ],
  grcommaaccent: [
    0,
    0,
    -10,
    -10
  ],
  gbrever: [
    0,
    0,
    -10,
    -10
  ],
  gbreveracute: [
    0,
    0,
    -10,
    -10
  ],
  gbrevercaron: [
    0,
    0,
    -10,
    -10
  ],
  gbrevercommaaccent: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentr: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentracute: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentrcaron: [
    0,
    0,
    -10,
    -10
  ],
  gcommaaccentrcommaaccent: [
    0,
    0,
    -10,
    -10
  ],
  ke: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  keacute: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kecaron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kecircumflex: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kedieresis: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kedotaccent: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kegrave: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kemacron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  keogonek: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccente: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccenteacute: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentecaron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentecircumflex: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentedieresis: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentedotaccent: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentegrave: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccentemacron: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  kcommaaccenteogonek: [
    0,
    0,
    -20,
    -20,
    -10,
    -30,
    -10,
    -10
  ],
  ocomma: [
    0,
    0,
    -40,
    -40
  ],
  operiod: [
    0,
    0,
    -40,
    -40
  ],
  oacutecomma: [
    0,
    0,
    -40,
    -40
  ],
  oacuteperiod: [
    0,
    0,
    -40,
    -40
  ],
  ocircumflexcomma: [
    0,
    0,
    -40,
    -40
  ],
  ocircumflexperiod: [
    0,
    0,
    -40,
    -40
  ],
  odieresiscomma: [
    0,
    0,
    -40,
    -40
  ],
  odieresisperiod: [
    0,
    0,
    -40,
    -40
  ],
  ogravecomma: [
    0,
    0,
    -40,
    -40
  ],
  ograveperiod: [
    0,
    0,
    -40,
    -40
  ],
  ohungarumlautcomma: [
    0,
    0,
    -40,
    -40
  ],
  ohungarumlautperiod: [
    0,
    0,
    -40,
    -40
  ],
  omacroncomma: [
    0,
    0,
    -40,
    -40
  ],
  omacronperiod: [
    0,
    0,
    -40,
    -40
  ],
  oslasha: [
    0,
    0,
    -55,
    -55
  ],
  oslashaacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashabreve: [
    0,
    0,
    -55,
    -55
  ],
  oslashacircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashadieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashagrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashamacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashaogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslasharing: [
    0,
    0,
    -55,
    -55
  ],
  oslashatilde: [
    0,
    0,
    -55,
    -55
  ],
  oslashb: [
    0,
    0,
    -55,
    -55
  ],
  oslashc: [
    0,
    0,
    -55,
    -55
  ],
  oslashcacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashccaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashccedilla: [
    0,
    0,
    -55,
    -55
  ],
  oslashcomma: [
    0,
    0,
    -95,
    -95
  ],
  oslashd: [
    0,
    0,
    -55,
    -55
  ],
  oslashdcroat: [
    0,
    0,
    -55,
    -55
  ],
  oslashe: [
    0,
    0,
    -55,
    -55
  ],
  oslasheacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashecaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashecircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashedieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashedotaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashegrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashemacron: [
    0,
    0,
    -55,
    -55
  ],
  oslasheogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslashf: [
    0,
    0,
    -55,
    -55
  ],
  oslashg: [
    0,
    0,
    -55,
    -55,
    0,
    0,
    -10
  ],
  oslashgbreve: [
    0,
    0,
    -55,
    -55,
    0,
    0,
    -10
  ],
  oslashgcommaaccent: [
    0,
    0,
    -55,
    -55,
    0,
    0,
    -10
  ],
  oslashh: [
    0,
    0,
    -55,
    -55
  ],
  oslashi: [
    0,
    0,
    -55,
    -55
  ],
  oslashiacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashicircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashidieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashigrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashimacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashiogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslashj: [
    0,
    0,
    -55,
    -55
  ],
  oslashk: [
    0,
    0,
    -55,
    -55
  ],
  oslashkcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashl: [
    0,
    0,
    -55,
    -55
  ],
  oslashlacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashlcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashlslash: [
    0,
    0,
    -55,
    -55
  ],
  oslashm: [
    0,
    0,
    -55,
    -55
  ],
  oslashn: [
    0,
    0,
    -55,
    -55
  ],
  oslashnacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashncaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashncommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashntilde: [
    0,
    0,
    -55,
    -55
  ],
  oslasho: [
    0,
    0,
    -55,
    -55
  ],
  oslashoacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashocircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashodieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashograve: [
    0,
    0,
    -55,
    -55
  ],
  oslashohungarumlaut: [
    0,
    0,
    -55,
    -55
  ],
  oslashomacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashoslash: [
    0,
    0,
    -55,
    -55
  ],
  oslashotilde: [
    0,
    0,
    -55,
    -55
  ],
  oslashp: [
    0,
    0,
    -55,
    -55
  ],
  oslashperiod: [
    0,
    0,
    -95,
    -95
  ],
  oslashq: [
    0,
    0,
    -55,
    -55
  ],
  oslashr: [
    0,
    0,
    -55,
    -55
  ],
  oslashracute: [
    0,
    0,
    -55,
    -55
  ],
  oslashrcaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashrcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashs: [
    0,
    0,
    -55,
    -55
  ],
  oslashsacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashscaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashscedilla: [
    0,
    0,
    -55,
    -55
  ],
  oslashscommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslasht: [
    0,
    0,
    -55,
    -55
  ],
  oslashtcommaaccent: [
    0,
    0,
    -55,
    -55
  ],
  oslashu: [
    0,
    0,
    -55,
    -55
  ],
  oslashuacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashucircumflex: [
    0,
    0,
    -55,
    -55
  ],
  oslashudieresis: [
    0,
    0,
    -55,
    -55
  ],
  oslashugrave: [
    0,
    0,
    -55,
    -55
  ],
  oslashuhungarumlaut: [
    0,
    0,
    -55,
    -55
  ],
  oslashumacron: [
    0,
    0,
    -55,
    -55
  ],
  oslashuogonek: [
    0,
    0,
    -55,
    -55
  ],
  oslashuring: [
    0,
    0,
    -55,
    -55
  ],
  oslashz: [
    0,
    0,
    -55,
    -55
  ],
  oslashzacute: [
    0,
    0,
    -55,
    -55
  ],
  oslashzcaron: [
    0,
    0,
    -55,
    -55
  ],
  oslashzdotaccent: [
    0,
    0,
    -55,
    -55
  ],
  otildecomma: [
    0,
    0,
    -40,
    -40
  ],
  otildeperiod: [
    0,
    0,
    -40,
    -40
  ],
  pcomma: [
    0,
    0,
    -35,
    -35
  ],
  pperiod: [
    0,
    0,
    -35,
    -35
  ],
  ra: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  raacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  radieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  ragrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  ramacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  raogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  raring: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  ratilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcolon: [
    0,
    0,
    30,
    30
  ],
  ri: [
    0,
    0,
    15,
    15
  ],
  riacute: [
    0,
    0,
    15,
    15
  ],
  ricircumflex: [
    0,
    0,
    15,
    15
  ],
  ridieresis: [
    0,
    0,
    15,
    15
  ],
  rigrave: [
    0,
    0,
    15,
    15
  ],
  rimacron: [
    0,
    0,
    15,
    15
  ],
  riogonek: [
    0,
    0,
    15,
    15
  ],
  rk: [
    0,
    0,
    15,
    15
  ],
  rkcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rl: [
    0,
    0,
    15,
    15
  ],
  rlacute: [
    0,
    0,
    15,
    15
  ],
  rlcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rlslash: [
    0,
    0,
    15,
    15
  ],
  rm: [
    0,
    0,
    25,
    25
  ],
  rn: [
    0,
    0,
    25,
    25,
    -15
  ],
  rnacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  rncaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  rncommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  rntilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  rp: [
    0,
    0,
    30,
    30,
    -10
  ],
  rsemicolon: [
    0,
    0,
    30,
    30
  ],
  ru: [
    0,
    0,
    15,
    15
  ],
  ruacute: [
    0,
    0,
    15,
    15
  ],
  rucircumflex: [
    0,
    0,
    15,
    15
  ],
  rudieresis: [
    0,
    0,
    15,
    15
  ],
  rugrave: [
    0,
    0,
    15,
    15
  ],
  ruhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  rumacron: [
    0,
    0,
    15,
    15
  ],
  ruogonek: [
    0,
    0,
    15,
    15
  ],
  ruring: [
    0,
    0,
    15,
    15
  ],
  racutea: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteaacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteacircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteadieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteagrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteamacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteaogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racutearing: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racuteatilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  racutecolon: [
    0,
    0,
    30,
    30
  ],
  racutei: [
    0,
    0,
    15,
    15
  ],
  racuteiacute: [
    0,
    0,
    15,
    15
  ],
  racuteicircumflex: [
    0,
    0,
    15,
    15
  ],
  racuteidieresis: [
    0,
    0,
    15,
    15
  ],
  racuteigrave: [
    0,
    0,
    15,
    15
  ],
  racuteimacron: [
    0,
    0,
    15,
    15
  ],
  racuteiogonek: [
    0,
    0,
    15,
    15
  ],
  racutek: [
    0,
    0,
    15,
    15
  ],
  racutekcommaaccent: [
    0,
    0,
    15,
    15
  ],
  racutel: [
    0,
    0,
    15,
    15
  ],
  racutelacute: [
    0,
    0,
    15,
    15
  ],
  racutelcommaaccent: [
    0,
    0,
    15,
    15
  ],
  racutelslash: [
    0,
    0,
    15,
    15
  ],
  racutem: [
    0,
    0,
    25,
    25
  ],
  racuten: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutenacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutencaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutencommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutentilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  racutep: [
    0,
    0,
    30,
    30,
    -10
  ],
  racutesemicolon: [
    0,
    0,
    30,
    30
  ],
  racuteu: [
    0,
    0,
    15,
    15
  ],
  racuteuacute: [
    0,
    0,
    15,
    15
  ],
  racuteucircumflex: [
    0,
    0,
    15,
    15
  ],
  racuteudieresis: [
    0,
    0,
    15,
    15
  ],
  racuteugrave: [
    0,
    0,
    15,
    15
  ],
  racuteuhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  racuteumacron: [
    0,
    0,
    15,
    15
  ],
  racuteuogonek: [
    0,
    0,
    15,
    15
  ],
  racuteuring: [
    0,
    0,
    15,
    15
  ],
  rcarona: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronaacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronacircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronadieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronagrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronamacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronaogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronaring: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaronatilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcaroncolon: [
    0,
    0,
    30,
    30
  ],
  rcaroni: [
    0,
    0,
    15,
    15
  ],
  rcaroniacute: [
    0,
    0,
    15,
    15
  ],
  rcaronicircumflex: [
    0,
    0,
    15,
    15
  ],
  rcaronidieresis: [
    0,
    0,
    15,
    15
  ],
  rcaronigrave: [
    0,
    0,
    15,
    15
  ],
  rcaronimacron: [
    0,
    0,
    15,
    15
  ],
  rcaroniogonek: [
    0,
    0,
    15,
    15
  ],
  rcaronk: [
    0,
    0,
    15,
    15
  ],
  rcaronkcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcaronl: [
    0,
    0,
    15,
    15
  ],
  rcaronlacute: [
    0,
    0,
    15,
    15
  ],
  rcaronlcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcaronlslash: [
    0,
    0,
    15,
    15
  ],
  rcaronm: [
    0,
    0,
    25,
    25
  ],
  rcaronn: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronnacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronncaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronncommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronntilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcaronp: [
    0,
    0,
    30,
    30,
    -10
  ],
  rcaronsemicolon: [
    0,
    0,
    30,
    30
  ],
  rcaronu: [
    0,
    0,
    15,
    15
  ],
  rcaronuacute: [
    0,
    0,
    15,
    15
  ],
  rcaronucircumflex: [
    0,
    0,
    15,
    15
  ],
  rcaronudieresis: [
    0,
    0,
    15,
    15
  ],
  rcaronugrave: [
    0,
    0,
    15,
    15
  ],
  rcaronuhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  rcaronumacron: [
    0,
    0,
    15,
    15
  ],
  rcaronuogonek: [
    0,
    0,
    15,
    15
  ],
  rcaronuring: [
    0,
    0,
    15,
    15
  ],
  rcommaaccenta: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentaacute: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentabreve: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentacircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentadieresis: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentagrave: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentamacron: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentaogonek: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentaring: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentatilde: [
    0,
    0,
    -10,
    -10,
    0,
    0,
    -15
  ],
  rcommaaccentcolon: [
    0,
    0,
    30,
    30
  ],
  rcommaaccenti: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentiacute: [
    0,
    0,
    15,
    15
  ],
  rcommaaccenticircumflex: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentidieresis: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentigrave: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentimacron: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentiogonek: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentk: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentkcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentl: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentlacute: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentlcommaaccent: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentlslash: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentm: [
    0,
    0,
    25,
    25
  ],
  rcommaaccentn: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentnacute: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentncaron: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentncommaaccent: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentntilde: [
    0,
    0,
    25,
    25,
    -15
  ],
  rcommaaccentp: [
    0,
    0,
    30,
    30,
    -10
  ],
  rcommaaccentsemicolon: [
    0,
    0,
    30,
    30
  ],
  rcommaaccentu: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentuacute: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentucircumflex: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentudieresis: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentugrave: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentuhungarumlaut: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentumacron: [
    0,
    0,
    15,
    15
  ],
  rcommaaccentuogonek: [
    0,
    0,
    15,
    15
  ],
  rcommaaccenturing: [
    0,
    0,
    15,
    15
  ],
  scomma: [
    0,
    0,
    -15,
    -15
  ],
  speriod: [
    0,
    0,
    -15,
    -15
  ],
  sacutecomma: [
    0,
    0,
    -15,
    -15
  ],
  sacuteperiod: [
    0,
    0,
    -15,
    -15
  ],
  scaroncomma: [
    0,
    0,
    -15,
    -15
  ],
  scaronperiod: [
    0,
    0,
    -15,
    -15
  ],
  scedillacomma: [
    0,
    0,
    -15,
    -15
  ],
  scedillaperiod: [
    0,
    0,
    -15,
    -15
  ],
  scommaaccentcomma: [
    0,
    0,
    -15,
    -15
  ],
  scommaaccentperiod: [
    0,
    0,
    -15,
    -15
  ],
  ve: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  veacute: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vecaron: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vecircumflex: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vedieresis: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vedotaccent: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vegrave: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  vemacron: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  veogonek: [
    0,
    0,
    -25,
    -25,
    -10,
    -15,
    0,
    -15
  ],
  wa: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  waacute: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wabreve: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wacircumflex: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wadieresis: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wagrave: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  wamacron: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  waogonek: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  waring: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  watilde: [
    0,
    0,
    -15,
    -15,
    0,
    -10,
    0,
    -10
  ],
  we: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  weacute: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wecaron: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wecircumflex: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wedieresis: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wedotaccent: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wegrave: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  wemacron: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  weogonek: [
    0,
    0,
    -10,
    -10,
    0,
    -10
  ],
  zo: [
    0,
    0,
    -15,
    -15
  ],
  zoacute: [
    0,
    0,
    -15,
    -15
  ],
  zocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zograve: [
    0,
    0,
    -15,
    -15
  ],
  zohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zomacron: [
    0,
    0,
    -15,
    -15
  ],
  zoslash: [
    0,
    0,
    -15,
    -15
  ],
  zotilde: [
    0,
    0,
    -15,
    -15
  ],
  zacuteo: [
    0,
    0,
    -15,
    -15
  ],
  zacuteoacute: [
    0,
    0,
    -15,
    -15
  ],
  zacuteocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zacuteodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zacuteograve: [
    0,
    0,
    -15,
    -15
  ],
  zacuteohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zacuteomacron: [
    0,
    0,
    -15,
    -15
  ],
  zacuteoslash: [
    0,
    0,
    -15,
    -15
  ],
  zacuteotilde: [
    0,
    0,
    -15,
    -15
  ],
  zcarono: [
    0,
    0,
    -15,
    -15
  ],
  zcaronoacute: [
    0,
    0,
    -15,
    -15
  ],
  zcaronocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zcaronodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zcaronograve: [
    0,
    0,
    -15,
    -15
  ],
  zcaronohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zcaronomacron: [
    0,
    0,
    -15,
    -15
  ],
  zcaronoslash: [
    0,
    0,
    -15,
    -15
  ],
  zcaronotilde: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccento: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentoacute: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentocircumflex: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentodieresis: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentograve: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentohungarumlaut: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentomacron: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentoslash: [
    0,
    0,
    -15,
    -15
  ],
  zdotaccentotilde: [
    0,
    0,
    -15,
    -15
  ],
  Ap: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Aacutep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aacutequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Abrevep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Abrevequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Acircumflexp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Acircumflexquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Adieresisp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Adieresisquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Agravep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Agravequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Amacronp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Amacronquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Aogonekp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aogonekquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Aringp: [
    0,
    0,
    0,
    0,
    -25
  ],
  Aringquoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Atildep: [
    0,
    0,
    0,
    0,
    -25
  ],
  Atildequoteright: [
    0,
    0,
    0,
    0,
    -74,
    -74,
    -37,
    -111
  ],
  Je: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jeacute: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jecaron: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jecircumflex: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jedieresis: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jedotaccent: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jegrave: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jemacron: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jeogonek: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jo: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Joacute: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jocircumflex: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jodieresis: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jograve: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Johungarumlaut: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jomacron: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Joslash: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  Jotilde: [
    0,
    0,
    0,
    0,
    -15,
    -40,
    -25
  ],
  NA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NacuteAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcaronAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NcommaaccentAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeA: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAacute: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAbreve: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAcircumflex: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAdieresis: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAgrave: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAmacron: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAogonek: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAring: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  NtildeAtilde: [
    0,
    0,
    0,
    0,
    -20,
    -30,
    -27,
    -35
  ],
  Ti: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tiacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tiogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcaroni: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcaroniacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcaroniogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcommaaccenti: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcommaaccentiacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Tcommaaccentiogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -35
  ],
  Vi: [
    0,
    0,
    0,
    0,
    -37,
    -55,
    -74,
    -60
  ],
  Viacute: [
    0,
    0,
    0,
    0,
    -37,
    -55,
    -74,
    -60
  ],
  Vicircumflex: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Vidieresis: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Vigrave: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Vimacron: [
    0,
    0,
    0,
    0,
    -37,
    0,
    -34,
    -20
  ],
  Viogonek: [
    0,
    0,
    0,
    0,
    -37,
    -55,
    -74,
    -60
  ],
  Wi: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -40
  ],
  Wiacute: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -40
  ],
  Wiogonek: [
    0,
    0,
    0,
    0,
    -18,
    -37,
    -55,
    -40
  ],
  fi: [
    0,
    0,
    0,
    0,
    -25,
    0,
    -20,
    -20
  ],
  gperiod: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -15
  ],
  gbreveperiod: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -15
  ],
  gcommaaccentperiod: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -15
  ],
  iv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  iacutev: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  icircumflexv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  idieresisv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  igravev: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  imacronv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  iogonekv: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -25
  ],
  ky: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kyacute: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kydieresis: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kcommaaccenty: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kcommaaccentyacute: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  kcommaaccentydieresis: [
    0,
    0,
    0,
    0,
    -15,
    0,
    -10,
    -15
  ],
  quotedblleftA: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAacute: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAbreve: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAcircumflex: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAdieresis: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAgrave: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAmacron: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAogonek: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAring: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quotedblleftAtilde: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftA: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAacute: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAbreve: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAcircumflex: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAdieresis: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAgrave: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAmacron: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAogonek: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAring: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  quoteleftAtilde: [
    0,
    0,
    0,
    0,
    -10,
    0,
    0,
    -80
  ],
  re: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  reacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  recaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  recircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  redieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  redotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  regrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  remacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  reogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racutee: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteeacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteecaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteecircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteedieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteedotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteegrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteemacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  racuteeogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcarone: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroneacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronecaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronecircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronedieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronedotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronegrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaronemacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcaroneogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccente: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccenteacute: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentecaron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentecircumflex: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentedieresis: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentedotaccent: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentegrave: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccentemacron: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  rcommaaccenteogonek: [
    0,
    0,
    0,
    0,
    -18,
    0,
    -37
  ],
  spaceA: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAacute: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAbreve: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAcircumflex: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAdieresis: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAgrave: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAmacron: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAogonek: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAring: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  spaceAtilde: [
    0,
    0,
    0,
    0,
    -55,
    -37,
    -18,
    -55
  ],
  Fi: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fiacute: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Ficircumflex: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fidieresis: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Figrave: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fimacron: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  Fiogonek: [
    0,
    0,
    0,
    0,
    0,
    -40,
    -45
  ],
  eb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  eacuteb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ecaronb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ecircumflexb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  edieresisb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  edotaccentb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  egraveb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  emacronb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  eogonekb: [
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ff: [
    0,
    0,
    0,
    0,
    0,
    -18,
    -18,
    -25
  ],
  quoterightt: [
    0,
    0,
    0,
    0,
    0,
    -37,
    -30,
    -18
  ],
  quoterighttcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    -37,
    -30,
    -18
  ],
  Yicircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yidieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yigrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yimacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteicircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteidieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteigrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Yacuteimacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisicircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisidieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisigrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  Ydieresisimacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    -34
  ],
  eg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eacuteg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eacutegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eacutegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecarong: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecarongbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecarongcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecircumflexg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecircumflexgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  ecircumflexgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edieresisg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edieresisgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edieresisgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edotaccentg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edotaccentgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  edotaccentgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egraveg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egravegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  egravegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  emacrong: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  emacrongbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  emacrongcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eogonekg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eogonekgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  eogonekgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -40,
    -15
  ],
  fiogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    -20
  ],
  gcomma: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  gbrevecomma: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  gcommaaccentcomma: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  og: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  oacuteg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  oacutegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  oacutegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ocircumflexg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ocircumflexgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ocircumflexgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  odieresisg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  odieresisgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  odieresisgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ograveg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogravegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ogravegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ohungarumlautg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ohungarumlautgbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  ohungarumlautgcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  omacrong: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  omacrongbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  omacrongcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  otildeg: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  otildegbreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  otildegcommaaccent: [
    0,
    0,
    0,
    0,
    0,
    0,
    -10
  ],
  fiacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -20
  ],
  ga: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gaacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gabreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gacircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gadieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gagrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gamacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gaogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  garing: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gatilde: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbrevea: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveaacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveabreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveacircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveadieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveagrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveamacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveaogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbrevearing: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gbreveatilde: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccenta: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentaacute: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentabreve: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentacircumflex: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentadieresis: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentagrave: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentamacron: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentaogonek: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentaring: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ],
  gcommaaccentatilde: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    -5
  ]
};
var data = {
  attributes,
  glyphWidths,
  kernPairs
};
var initFont = function initFont2(font2) {
  return [font2.FontName, {
    attributes: font2,
    glyphWidths: {},
    kernPairs: {}
  }];
};
var expandData = function expandData2(data2) {
  var attributes2 = data2.attributes, glyphWidths2 = data2.glyphWidths, kernPairs2 = data2.kernPairs;
  var fonts = attributes2.map(initFont);
  Object.keys(glyphWidths2).forEach(function(key) {
    glyphWidths2[key].forEach(function(value2, index3) {
      if (value2)
        fonts[index3][1].glyphWidths[key] = value2;
    });
  });
  Object.keys(kernPairs2).forEach(function(key) {
    kernPairs2[key].forEach(function(value2, index3) {
      if (value2)
        fonts[index3][1].kernPairs[key] = value2;
    });
  });
  return Object.fromEntries(fonts);
};
var STANDARD_FONTS = expandData(data);
var createStandardFont = function createStandardFont2(PDFFont2) {
  return function(_PDFFont) {
    _inheritsLoose(StandardFont3, _PDFFont);
    function StandardFont3(document2, name, id) {
      var _this;
      _this = _PDFFont.call(this) || this;
      _this.document = document2;
      _this.name = name;
      _this.id = id;
      _this.font = AFMFont.fromJson(STANDARD_FONTS[_this.name]);
      _this.ascender = _this.font.ascender;
      _this.descender = _this.font.descender;
      _this.bbox = _this.font.bbox;
      _this.lineGap = _this.font.lineGap;
      return _this;
    }
    var _proto = StandardFont3.prototype;
    _proto.embed = function embed() {
      this.dictionary.data = {
        Type: "Font",
        BaseFont: this.name,
        Subtype: "Type1",
        Encoding: "WinAnsiEncoding"
      };
      return this.dictionary.end();
    };
    _proto.encode = function encode(text2) {
      var encoded = this.font.encodeText(text2);
      var glyphs = this.font.glyphsForString("" + text2);
      var advances = this.font.advancesForGlyphs(glyphs);
      var positions = [];
      for (var i = 0; i < glyphs.length; i++) {
        var glyph = glyphs[i];
        positions.push({
          xAdvance: advances[i],
          yAdvance: 0,
          xOffset: 0,
          yOffset: 0,
          advanceWidth: this.font.widthOfGlyph(glyph)
        });
      }
      return [encoded, positions];
    };
    _proto.encodeGlyphs = function encodeGlyphs(glyphs) {
      var res = [];
      for (var _i = 0, _Array$from = Array.from(glyphs); _i < _Array$from.length; _i++) {
        var glyph = _Array$from[_i];
        res.push(("00" + glyph.id.toString(16)).slice(-2));
      }
      return res;
    };
    _proto.widthOfString = function widthOfString2(string, size) {
      var glyphs = this.font.glyphsForString("" + string);
      var advances = this.font.advancesForGlyphs(glyphs);
      var width = 0;
      for (var _i2 = 0, _Array$from2 = Array.from(advances); _i2 < _Array$from2.length; _i2++) {
        var advance = _Array$from2[_i2];
        width += advance;
      }
      var scale4 = size / 1e3;
      return width * scale4;
    };
    StandardFont3.isStandardFont = function isStandardFont(name) {
      return name in STANDARD_FONTS;
    };
    return StandardFont3;
  }(PDFFont2);
};
var toHex2 = function toHex3() {
  for (var _len = arguments.length, codePoints = new Array(_len), _key = 0; _key < _len; _key++) {
    codePoints[_key] = arguments[_key];
  }
  var codes3 = Array.from(codePoints).map(function(code3) {
    return ("0000" + code3.toString(16)).slice(-4);
  });
  return codes3.join("");
};
var createEmbeddedFont = function createEmbeddedFont2(PDFFont2) {
  return function(_PDFFont) {
    _inheritsLoose(EmbeddedFont2, _PDFFont);
    function EmbeddedFont2(document2, font2, id) {
      var _this;
      _this = _PDFFont.call(this) || this;
      _this.document = document2;
      _this.font = font2;
      _this.id = id;
      _this.subset = _this.font.createSubset();
      _this.unicode = [[0]];
      _this.widths = [_this.font.getGlyph(0).advanceWidth];
      _this.name = _this.font.postscriptName;
      _this.scale = 1e3 / _this.font.unitsPerEm;
      _this.ascender = _this.font.ascent * _this.scale;
      _this.descender = _this.font.descent * _this.scale;
      _this.xHeight = _this.font.xHeight * _this.scale;
      _this.capHeight = _this.font.capHeight * _this.scale;
      _this.lineGap = _this.font.lineGap * _this.scale;
      _this.bbox = _this.font.bbox;
      _this.layoutCache = /* @__PURE__ */ Object.create(null);
      return _this;
    }
    var _proto = EmbeddedFont2.prototype;
    _proto.layoutRun = function layoutRun3(text2, features) {
      var run = this.font.layout(text2, features);
      for (var i = 0; i < run.positions.length; i++) {
        var position = run.positions[i];
        for (var key in position) {
          position[key] *= this.scale;
        }
        position.advanceWidth = run.glyphs[i].advanceWidth * this.scale;
      }
      return run;
    };
    _proto.layoutCached = function layoutCached(text2) {
      var cached;
      if (cached = this.layoutCache[text2]) {
        return cached;
      }
      var run = this.layoutRun(text2);
      this.layoutCache[text2] = run;
      return run;
    };
    _proto.layout = function layout2(text2, features, onlyWidth) {
      if (onlyWidth == null) {
        onlyWidth = false;
      }
      if (features) {
        return this.layoutRun(text2, features);
      }
      var glyphs = onlyWidth ? null : [];
      var positions = onlyWidth ? null : [];
      var advanceWidth5 = 0;
      var last3 = 0;
      var index3 = 0;
      while (index3 <= text2.length) {
        var needle;
        if (index3 === text2.length && last3 < index3 || (needle = text2.charAt(index3), [" ", "	"].includes(needle))) {
          var run = this.layoutCached(text2.slice(last3, ++index3));
          if (!onlyWidth) {
            glyphs.push.apply(glyphs, Array.from(run.glyphs || []));
            positions.push.apply(positions, Array.from(run.positions || []));
          }
          advanceWidth5 += run.advanceWidth;
          last3 = index3;
        } else {
          index3++;
        }
      }
      return {
        glyphs,
        positions,
        advanceWidth: advanceWidth5
      };
    };
    _proto.encode = function encode(text2, features) {
      var _this$layout = this.layout(text2, features), glyphs = _this$layout.glyphs, positions = _this$layout.positions;
      var res = [];
      for (var i = 0; i < glyphs.length; i++) {
        var glyph = glyphs[i];
        var gid = this.subset.includeGlyph(glyph.id);
        res.push(("0000" + gid.toString(16)).slice(-4));
        if (this.widths[gid] == null) {
          this.widths[gid] = glyph.advanceWidth * this.scale;
        }
        if (this.unicode[gid] == null) {
          this.unicode[gid] = this.font._cmapProcessor.codePointsForGlyph(glyph.id);
        }
      }
      return [res, positions];
    };
    _proto.encodeGlyphs = function encodeGlyphs(glyphs) {
      var res = [];
      for (var i = 0; i < glyphs.length; i++) {
        var glyph = glyphs[i];
        var gid = this.subset.includeGlyph(glyph.id);
        res.push(("0000" + gid.toString(16)).slice(-4));
        if (this.widths[gid] == null) {
          this.widths[gid] = glyph.advanceWidth * this.scale;
        }
        if (this.unicode[gid] == null) {
          this.unicode[gid] = this.font._cmapProcessor.codePointsForGlyph(glyph.id);
        }
      }
      return res;
    };
    _proto.widthOfString = function widthOfString2(string, size, features) {
      var width = this.layout(string, features, true).advanceWidth;
      var scale4 = size / 1e3;
      return width * scale4;
    };
    _proto.embed = function embed() {
      var isCFF = this.subset.cff != null;
      var fontFile = this.document.ref();
      if (isCFF) {
        fontFile.data.Subtype = "CIDFontType0C";
      }
      fontFile.end(this.subset.encode());
      var familyClass = ((this.font["OS/2"] != null ? this.font["OS/2"].sFamilyClass : void 0) || 0) >> 8;
      var flags = 0;
      if (this.font.post.isFixedPitch) {
        flags |= 1 << 0;
      }
      if (1 <= familyClass && familyClass <= 7) {
        flags |= 1 << 1;
      }
      flags |= 1 << 2;
      if (familyClass === 10) {
        flags |= 1 << 3;
      }
      if (this.font.head.macStyle.italic) {
        flags |= 1 << 6;
      }
      var tag = [0, 1, 2, 3, 4, 5].map(function(i) {
        return String.fromCharCode(Math.random() * 26 + 65);
      }).join("");
      var name = tag + "+" + this.font.postscriptName;
      var bbox = this.font.bbox;
      var descriptor = this.document.ref({
        Type: "FontDescriptor",
        FontName: name,
        Flags: flags,
        FontBBox: [bbox.minX * this.scale, bbox.minY * this.scale, bbox.maxX * this.scale, bbox.maxY * this.scale],
        ItalicAngle: this.font.italicAngle,
        Ascent: this.ascender,
        Descent: this.descender,
        CapHeight: (this.font.capHeight || this.font.ascent) * this.scale,
        XHeight: (this.font.xHeight || 0) * this.scale,
        StemV: 0
      });
      if (isCFF) {
        descriptor.data.FontFile3 = fontFile;
      } else {
        descriptor.data.FontFile2 = fontFile;
      }
      descriptor.end();
      var descendantFont = this.document.ref({
        Type: "Font",
        Subtype: isCFF ? "CIDFontType0" : "CIDFontType2",
        BaseFont: name,
        CIDSystemInfo: {
          Registry: new String("Adobe"),
          Ordering: new String("Identity"),
          Supplement: 0
        },
        FontDescriptor: descriptor,
        W: [0, this.widths]
      });
      descendantFont.end();
      this.dictionary.data = {
        Type: "Font",
        Subtype: "Type0",
        BaseFont: name,
        Encoding: "Identity-H",
        DescendantFonts: [descendantFont],
        ToUnicode: this.toUnicodeCmap()
      };
      return this.dictionary.end();
    };
    _proto.toUnicodeCmap = function toUnicodeCmap() {
      var cmap = this.document.ref();
      var entries = [];
      for (var _i = 0, _Array$from = Array.from(this.unicode); _i < _Array$from.length; _i++) {
        var codePoints = _Array$from[_i];
        var encoded = [];
        for (var _i2 = 0, _Array$from2 = Array.from(codePoints); _i2 < _Array$from2.length; _i2++) {
          var value2 = _Array$from2[_i2];
          if (value2 > 65535) {
            value2 -= 65536;
            encoded.push(toHex2(value2 >>> 10 & 1023 | 55296));
            value2 = 56320 | value2 & 1023;
          }
          encoded.push(toHex2(value2));
          entries.push("<" + encoded.join(" ") + ">");
        }
      }
      cmap.end("  /CIDInit /ProcSet findresource begin\n  12 dict begin\n  begincmap\n  /CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n  >> def\n  /CMapName /Adobe-Identity-UCS def\n  /CMapType 2 def\n  1 begincodespacerange\n  <0000><ffff>\n  endcodespacerange\n  1 beginbfrange\n  <0000> <" + toHex2(entries.length - 1) + "> [" + entries.join(" ") + "]\n  endbfrange\n  endcmap\n  CMapName currentdict /CMap defineresource pop\n  end\n  end  ");
      return cmap;
    };
    return EmbeddedFont2;
  }(PDFFont2);
};
var PDFFont = function() {
  function PDFFont2() {
  }
  PDFFont2.open = function open(document2, src3, family, id) {
    var font2;
    if (typeof src3 === "string") {
      if (StandardFont.isStandardFont(src3)) {
        return new StandardFont(document2, src3, id);
      }
      {
        throw new Error("Can't open " + src3 + " in browser build");
      }
    } else if (src3 instanceof Uint8Array) {
      font2 = $d636bc798e7178db$export$185802fd694ee1f5(src3, family);
    } else if (src3 instanceof ArrayBuffer) {
      font2 = $d636bc798e7178db$export$185802fd694ee1f5(new Uint8Array(src3), family);
    } else if (typeof src3 === "object") {
      font2 = src3;
    }
    if (font2 == null) {
      throw new Error("Not a supported font format or standard PDF font.");
    }
    return new EmbeddedFont(document2, font2, id);
  };
  var _proto = PDFFont2.prototype;
  _proto.encode = function encode() {
    throw new Error("Must be implemented by subclasses");
  };
  _proto.widthOfString = function widthOfString2() {
    throw new Error("Must be implemented by subclasses");
  };
  _proto.ref = function ref() {
    return this.dictionary != null ? this.dictionary : this.dictionary = this.document.ref();
  };
  _proto.finalize = function finalize() {
    if (this.embedded || this.dictionary == null) {
      return;
    }
    this.embed();
    return this.embedded = true;
  };
  _proto.embed = function embed() {
    throw new Error("Must be implemented by subclasses");
  };
  _proto.lineHeight = function lineHeight(size, includeGap) {
    if (includeGap == null) {
      includeGap = false;
    }
    var gap = includeGap ? this.lineGap : 0;
    return (this.ascender + gap - this.descender) / 1e3 * size;
  };
  return PDFFont2;
}();
var StandardFont = createStandardFont(PDFFont);
var EmbeddedFont = createEmbeddedFont(PDFFont);
var FontsMixin = {
  initFonts: function initFonts() {
    this._fontFamilies = {};
    this._fontCount = 0;
    this._fontSize = 12;
    this._font = null;
    this._registeredFonts = {};
    return this.font("Helvetica");
  },
  font: function font(src3, family, size) {
    var cacheKey, font2;
    if (typeof family === "number") {
      size = family;
      family = null;
    }
    if (typeof src3 === "string" && this._registeredFonts[src3]) {
      cacheKey = src3;
      var _this$_registeredFont = this._registeredFonts[src3];
      src3 = _this$_registeredFont.src;
      family = _this$_registeredFont.family;
    } else {
      cacheKey = family || src3;
      if (typeof cacheKey !== "string") {
        cacheKey = null;
      }
    }
    if (size != null) {
      this.fontSize(size);
    }
    if (font2 = this._fontFamilies[cacheKey]) {
      this._font = font2;
      return this;
    }
    var id = "F" + ++this._fontCount;
    this._font = PDFFont.open(this, src3, family, id);
    if (font2 = this._fontFamilies[this._font.name]) {
      this._font = font2;
      return this;
    }
    if (cacheKey) {
      this._fontFamilies[cacheKey] = this._font;
    }
    if (this._font.name) {
      this._fontFamilies[this._font.name] = this._font;
    }
    return this;
  },
  fontSize: function fontSize(_fontSize) {
    this._fontSize = _fontSize;
    return this;
  },
  currentLineHeight: function currentLineHeight(includeGap) {
    if (includeGap == null) {
      includeGap = false;
    }
    return this._font.lineHeight(this._fontSize, includeGap);
  },
  registerFont: function registerFont(name, src3, family) {
    this._registeredFonts[name] = {
      src: src3,
      family
    };
    return this;
  }
};
var number = PDFObject$1.number;
var TextMixin = {
  initText: function initText() {
    this._line = this._line.bind(this);
    this.x = 0;
    this.y = 0;
    return this._lineGap = 0;
  },
  _text: function _text(text2, x, y, options, lineCallback) {
    var _this = this;
    options = this._initOptions(x, y, options);
    text2 = text2 == null ? "" : "" + text2;
    if (options.wordSpacing) {
      text2 = text2.replace(/\s{2,}/g, " ");
    }
    var addStructure = function addStructure2() {
      if (options.structParent) {
        options.structParent.add(_this.struct(options.structType || "P", [_this.markStructureContent(options.structType || "P")]));
      }
    };
    for (var _iterator = _createForOfIteratorHelperLoose(text2.split("\n")), _step; !(_step = _iterator()).done; ) {
      var line2 = _step.value;
      addStructure();
      lineCallback(line2, options);
    }
    return this;
  },
  text: function text(_text2, x, y, options) {
    return this._text(_text2, x, y, options, this._line);
  },
  widthOfString: function widthOfString(string, options) {
    if (options === void 0) {
      options = {};
    }
    return this._font.widthOfString(string, this._fontSize, options.features) + (options.characterSpacing || 0) * (string.length - 1);
  },
  _initOptions: function _initOptions(x, y, options) {
    if (x === void 0) {
      x = {};
    }
    if (options === void 0) {
      options = {};
    }
    if (typeof x === "object") {
      options = x;
      x = null;
    }
    var result = Object.assign({}, options);
    if (this._textOptions) {
      for (var key in this._textOptions) {
        var val = this._textOptions[key];
        if (key !== "continued") {
          if (result[key] === void 0) {
            result[key] = val;
          }
        }
      }
    }
    if (x != null) {
      this.x = x;
    }
    if (y != null) {
      this.y = y;
    }
    if (result.lineBreak !== false) {
      if (result.width == null) {
        result.width = this.page.width - this.x - this.page.margins.right;
      }
      result.width = Math.max(result.width, 0);
    }
    if (!result.columns) {
      result.columns = 0;
    }
    if (result.columnGap == null) {
      result.columnGap = 18;
    }
    return result;
  },
  _line: function _line(text2, options) {
    if (options === void 0) {
      options = {};
    }
    this._fragment(text2, this.x, this.y, options);
    return this.x += this.widthOfString(text2);
  },
  _fragment: function _fragment(text2, x, y, options) {
    text2 = ("" + text2).replace(/\n/g, "");
    if (text2.length === 0)
      return;
    var _this$_font$encode = this._font.encode(text2, options.features), encoded = _this$_font$encode[0], positions = _this$_font$encode[1];
    var dy = this._font.ascender / 1e3 * this._fontSize;
    this._glyphs(encoded, positions, x, y + dy, options);
  },
  _glyphs: function _glyphs(encoded, positions, x, y, options) {
    var _this2 = this;
    var commands = [];
    var scale4 = this._fontSize / 1e3;
    var i;
    var last3 = 0;
    var hadOffset = false;
    this.save();
    this.transform(1, 0, 0, -1, 0, this.page.height);
    y = this.page.height - y;
    if (this.page.fonts[this._font.id] == null) {
      this.page.fonts[this._font.id] = this._font.ref();
    }
    this.addContent("BT");
    this.addContent("1 0 0 1 " + number(x) + " " + number(y) + " Tm");
    this.addContent("/" + this._font.id + " " + number(this._fontSize) + " Tf");
    var mode = options.fill && options.stroke ? 2 : options.stroke ? 1 : 0;
    if (mode) {
      this.addContent(mode + " Tr");
    }
    var addSegment = function addSegment2(cur) {
      if (last3 < cur) {
        var hex = encoded.slice(last3, cur).join("");
        var advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;
        commands.push("<" + hex + "> " + number(-advance));
      }
      return last3 = cur;
    };
    var flush = function flush2(i2) {
      addSegment(i2);
      if (commands.length > 0) {
        _this2.addContent("[" + commands.join(" ") + "] TJ");
        return commands.length = 0;
      }
    };
    for (i = 0; i < positions.length; i++) {
      var pos = positions[i];
      if (pos.xOffset || pos.yOffset) {
        flush(i);
        this.addContent("1 0 0 1 " + number(x + pos.xOffset * scale4) + " " + number(y + pos.yOffset * scale4) + " Tm");
        flush(i + 1);
        hadOffset = true;
      } else {
        if (hadOffset) {
          this.addContent("1 0 0 1 " + number(x) + " " + number(y) + " Tm");
          hadOffset = false;
        }
        if (pos.xAdvance - pos.advanceWidth !== 0) {
          addSegment(i + 1);
        }
      }
      x += pos.xAdvance * scale4;
    }
    flush(i);
    this.addContent("ET");
    return this.restore();
  }
};
var MARKERS = [65472, 65473, 65474, 65475, 65477, 65478, 65479, 65480, 65481, 65482, 65483, 65484, 65485, 65486, 65487];
var JPEG = function() {
  function JPEG4(data2, label) {
    var marker;
    this.data = data2;
    this.label = label;
    if (this.data.readUInt16BE(0) !== 65496) {
      throw "SOI not found in JPEG";
    }
    var pos = 2;
    while (pos < this.data.length) {
      marker = this.data.readUInt16BE(pos);
      pos += 2;
      if (Array.from(MARKERS).includes(marker)) {
        break;
      }
      pos += this.data.readUInt16BE(pos);
    }
    if (!Array.from(MARKERS).includes(marker)) {
      throw "Invalid JPEG.";
    }
    pos += 2;
    this.bits = this.data[pos++];
    this.height = this.data.readUInt16BE(pos);
    pos += 2;
    this.width = this.data.readUInt16BE(pos);
    pos += 2;
    var channels = this.data[pos++];
    this.colorSpace = function() {
      switch (channels) {
        case 1:
          return "DeviceGray";
        case 3:
          return "DeviceRGB";
        case 4:
          return "DeviceCMYK";
      }
    }();
    this.obj = null;
  }
  var _proto = JPEG4.prototype;
  _proto.embed = function embed(document2) {
    if (this.obj) {
      return;
    }
    this.obj = document2.ref({
      Type: "XObject",
      Subtype: "Image",
      BitsPerComponent: this.bits,
      Width: this.width,
      Height: this.height,
      ColorSpace: this.colorSpace,
      Filter: "DCTDecode"
    });
    if (this.colorSpace === "DeviceCMYK") {
      this.obj.data["Decode"] = [1, 0, 1, 0, 1, 0, 1, 0];
    }
    this.obj.end(this.data);
    this.data = null;
  };
  return JPEG4;
}();
var PNGImage = function() {
  function PNGImage2(data2, label) {
    this.label = label;
    this.image = new PNG(data2);
    this.width = this.image.width;
    this.height = this.image.height;
    this.imgData = this.image.imgData;
    this.obj = null;
  }
  var _proto = PNGImage2.prototype;
  _proto.embed = function embed(document2) {
    var dataDecoded = false;
    this.document = document2;
    if (this.obj)
      return;
    var hasAlphaChannel = this.image.hasAlphaChannel;
    var isInterlaced = this.image.interlaceMethod === 1;
    this.obj = this.document.ref({
      Type: "XObject",
      Subtype: "Image",
      BitsPerComponent: hasAlphaChannel ? 8 : this.image.bits,
      Width: this.width,
      Height: this.height,
      Filter: "FlateDecode"
    });
    if (!hasAlphaChannel) {
      var params = this.document.ref({
        Predictor: isInterlaced ? 1 : 15,
        Colors: this.image.colors,
        BitsPerComponent: this.image.bits,
        Columns: this.width
      });
      this.obj.data["DecodeParms"] = params;
      params.end();
    }
    if (this.image.palette.length === 0) {
      this.obj.data["ColorSpace"] = this.image.colorSpace;
    } else {
      var palette = this.document.ref();
      palette.end(Buffer$4.from(this.image.palette));
      this.obj.data["ColorSpace"] = ["Indexed", "DeviceRGB", this.image.palette.length / 3 - 1, palette];
    }
    if (this.image.transparency.grayscale != null) {
      var val = this.image.transparency.grayscale;
      this.obj.data["Mask"] = [val, val];
    } else if (this.image.transparency.rgb) {
      var rgb = this.image.transparency.rgb;
      var mask = [];
      for (var _iterator = _createForOfIteratorHelperLoose(rgb), _step; !(_step = _iterator()).done; ) {
        var x = _step.value;
        mask.push(x, x);
      }
      this.obj.data["Mask"] = mask;
    } else if (this.image.transparency.indexed) {
      dataDecoded = true;
      return this.loadIndexedAlphaChannel();
    } else if (hasAlphaChannel) {
      dataDecoded = true;
      return this.splitAlphaChannel();
    }
    if (isInterlaced && !dataDecoded) {
      return this.decodeData();
    }
    this.finalize();
  };
  _proto.finalize = function finalize() {
    if (this.alphaChannel) {
      var sMask = this.document.ref({
        Type: "XObject",
        Subtype: "Image",
        Height: this.height,
        Width: this.width,
        BitsPerComponent: 8,
        Filter: "FlateDecode",
        ColorSpace: "DeviceGray",
        Decode: [0, 1]
      });
      sMask.end(this.alphaChannel);
      this.obj.data["SMask"] = sMask;
    }
    this.obj.end(this.imgData);
    this.image = null;
    this.imgData = null;
  };
  _proto.splitAlphaChannel = function splitAlphaChannel() {
    var _this = this;
    return this.image.decodePixels(function(pixels) {
      var a2;
      var p;
      var colorCount = _this.image.colors;
      var pixelCount = _this.width * _this.height;
      var imgData = Buffer$4.alloc(pixelCount * colorCount);
      var alphaChannel = Buffer$4.alloc(pixelCount);
      var i = p = a2 = 0;
      var len = pixels.length;
      var skipByteCount = _this.image.bits === 16 ? 1 : 0;
      while (i < len) {
        for (var colorIndex = 0; colorIndex < colorCount; colorIndex++) {
          imgData[p++] = pixels[i++];
          i += skipByteCount;
        }
        alphaChannel[a2++] = pixels[i++];
        i += skipByteCount;
      }
      _this.imgData = lib3.deflateSync(imgData);
      _this.alphaChannel = lib3.deflateSync(alphaChannel);
      return _this.finalize();
    });
  };
  _proto.loadIndexedAlphaChannel = function loadIndexedAlphaChannel() {
    var _this2 = this;
    var transparency = this.image.transparency.indexed;
    return this.image.decodePixels(function(pixels) {
      var alphaChannel = Buffer$4.alloc(_this2.width * _this2.height);
      var i = 0;
      for (var j = 0, end3 = pixels.length; j < end3; j++) {
        alphaChannel[i++] = transparency[pixels[j]];
      }
      _this2.alphaChannel = lib3.deflateSync(alphaChannel);
      return _this2.finalize();
    });
  };
  _proto.decodeData = function decodeData() {
    var _this3 = this;
    this.image.decodePixels(function(pixels) {
      _this3.imgData = lib3.deflateSync(pixels);
      _this3.finalize();
    });
  };
  return PNGImage2;
}();
var PDFImage = function() {
  function PDFImage2() {
  }
  PDFImage2.open = function open(src3, label) {
    var data2;
    if (Buffer$4.isBuffer(src3)) {
      data2 = src3;
    } else if (src3 instanceof ArrayBuffer) {
      data2 = Buffer$4.from(new Uint8Array(src3));
    } else {
      var match = /^data:.+;base64,(.*)$/.exec(src3);
      if (match) {
        data2 = Buffer$4.from(match[1], "base64");
      }
    }
    if (data2[0] === 255 && data2[1] === 216) {
      return new JPEG(data2, label);
    }
    if (data2[0] === 137 && data2.toString("ascii", 1, 4) === "PNG") {
      return new PNGImage(data2, label);
    }
    throw new Error("Unknown image format.");
  };
  return PDFImage2;
}();
var ImagesMixin = {
  initImages: function initImages() {
    this._imageRegistry = {};
    this._imageCount = 0;
  },
  embedImage: function embedImage(src3) {
    var image2;
    if (typeof src3 === "string") {
      image2 = this._imageRegistry[src3];
    }
    if (!image2) {
      if (src3.width && src3.height) {
        image2 = src3;
      } else {
        image2 = this.openImage(src3);
      }
    }
    if (!image2.obj) {
      image2.embed(this);
    }
    return image2;
  },
  image: function image(src3, x, y, options) {
    if (options === void 0) {
      options = {};
    }
    var bh;
    var bp;
    var bw;
    var ip;
    var left;
    var left1;
    if (typeof x === "object") {
      options = x;
      x = null;
    }
    var image2 = src3 instanceof PDFImage ? src3 : this.embedImage(src3);
    x = (left = x != null ? x : options.x) != null ? left : this.x;
    y = (left1 = y != null ? y : options.y) != null ? left1 : this.y;
    if (this.page.xobjects[image2.label] == null) {
      this.page.xobjects[image2.label] = image2.obj;
    }
    var w = options.width || image2.width;
    var h2 = options.height || image2.height;
    if (options.width && !options.height) {
      var wp = w / image2.width;
      w = image2.width * wp;
      h2 = image2.height * wp;
    } else if (options.height && !options.width) {
      var hp = h2 / image2.height;
      w = image2.width * hp;
      h2 = image2.height * hp;
    } else if (options.scale) {
      w = image2.width * options.scale;
      h2 = image2.height * options.scale;
    } else if (options.fit) {
      var _Array$from = Array.from(options.fit);
      bw = _Array$from[0];
      bh = _Array$from[1];
      bp = bw / bh;
      ip = image2.width / image2.height;
      if (ip > bp) {
        w = bw;
        h2 = bw / ip;
      } else {
        h2 = bh;
        w = bh * ip;
      }
    }
    if (this.y === y) {
      this.y += h2;
    }
    this.save();
    this.transform(w, 0, 0, -h2, x, y + h2);
    this.addContent("/" + image2.label + " Do");
    this.restore();
    return this;
  },
  openImage: function openImage(src3) {
    var image2;
    if (typeof src3 === "string") {
      image2 = this._imageRegistry[src3];
    }
    if (!image2) {
      image2 = PDFImage.open(src3, "I" + ++this._imageCount);
      if (typeof src3 === "string") {
        this._imageRegistry[src3] = image2;
      }
    }
    return image2;
  }
};
var AnnotationsMixin = {
  annotate: function annotate(x, y, w, h2, options) {
    options.Type = "Annot";
    options.Rect = this._convertRect(x, y, w, h2);
    options.Border = [0, 0, 0];
    if (options.Subtype === "Link" && typeof options.F === "undefined") {
      options.F = 1 << 2;
    }
    if (options.Subtype !== "Link") {
      if (options.C == null) {
        options.C = this._normalizeColor(options.color || [0, 0, 0]);
      }
    }
    delete options.color;
    if (typeof options.Dest === "string") {
      options.Dest = new String(options.Dest);
    }
    for (var key in options) {
      var val = options[key];
      options[key[0].toUpperCase() + key.slice(1)] = val;
    }
    var ref = this.ref(options);
    this.page.annotations.push(ref);
    ref.end();
    return this;
  },
  note: function note(x, y, w, h2, contents, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Text";
    options.Contents = new String(contents);
    options.Name = "Comment";
    if (options.color == null) {
      options.color = [243, 223, 92];
    }
    options.Border = [0, 0, options.borderWidth || 0];
    delete options.borderWidth;
    return this.annotate(x, y, w, h2, options);
  },
  goTo: function goTo(x, y, w, h2, name, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Link";
    options.A = this.ref({
      S: "GoTo",
      D: new String(name)
    });
    options.A.end();
    return this.annotate(x, y, w, h2, options);
  },
  link: function link(x, y, w, h2, url, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Link";
    if (typeof url === "number") {
      var pages = this._root.data.Pages.data;
      if (url >= 0 && url < pages.Kids.length) {
        options.A = this.ref({
          S: "GoTo",
          D: [pages.Kids[url], "XYZ", null, null, null]
        });
        options.A.end();
      } else {
        throw new Error("The document has no page " + url);
      }
    } else {
      options.A = this.ref({
        S: "URI",
        URI: new String(url)
      });
      options.A.end();
    }
    return this.annotate(x, y, w, h2, options);
  },
  _markup: function _markup(x, y, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    var _this$_convertRect = this._convertRect(x, y, w, h2), x1 = _this$_convertRect[0], y1 = _this$_convertRect[1], x2 = _this$_convertRect[2], y2 = _this$_convertRect[3];
    options.QuadPoints = [x1, y2, x2, y2, x1, y1, x2, y1];
    options.Contents = new String();
    return this.annotate(x, y, w, h2, options);
  },
  highlight: function highlight(x, y, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    options.Subtype = "Highlight";
    if (options.color == null) {
      options.color = [241, 238, 148];
    }
    return this._markup(x, y, w, h2, options);
  },
  fileAnnotation: function fileAnnotation(x, y, w, h2, file2, options) {
    if (file2 === void 0) {
      file2 = {};
    }
    if (options === void 0) {
      options = {};
    }
    var filespec = this.file(file2.src, Object.assign({
      hidden: true
    }, file2));
    options.Subtype = "FileAttachment";
    options.FS = filespec;
    if (options.Contents) {
      options.Contents = new String(options.Contents);
    } else if (filespec.data.Desc) {
      options.Contents = filespec.data.Desc;
    }
    return this.annotate(x, y, w, h2, options);
  },
  _convertRect: function _convertRect(x1, y1, w, h2) {
    var y2 = y1;
    y1 += h2;
    var x2 = x1 + w;
    var _this$_ctm = this._ctm, m0 = _this$_ctm[0], m1 = _this$_ctm[1], m2 = _this$_ctm[2], m3 = _this$_ctm[3], m4 = _this$_ctm[4], m5 = _this$_ctm[5];
    x1 = m0 * x1 + m2 * y1 + m4;
    y1 = m1 * x1 + m3 * y1 + m5;
    x2 = m0 * x2 + m2 * y2 + m4;
    y2 = m1 * x2 + m3 * y2 + m5;
    return [x1, y1, x2, y2];
  }
};
var DEFAULT_OPTIONS = {
  top: 0,
  left: 0,
  zoom: 0,
  fit: false,
  pageNumber: null,
  expanded: false
};
var PDFOutline = function() {
  function PDFOutline2(document2, parent, title3, dest, options) {
    if (options === void 0) {
      options = DEFAULT_OPTIONS;
    }
    this.document = document2;
    this.options = options;
    this.outlineData = {};
    if (dest !== null) {
      var destWidth = dest.data.MediaBox[2];
      var destHeight = dest.data.MediaBox[3];
      var top = destHeight - (options.top || 0);
      var left = destWidth - (options.left || 0);
      var zoom = options.zoom || 0;
      this.outlineData.Dest = options.fit ? [dest, "Fit"] : [dest, "XYZ", left, top, zoom];
    }
    if (parent !== null) {
      this.outlineData.Parent = parent;
    }
    if (title3 !== null) {
      this.outlineData.Title = new String(title3);
    }
    this.dictionary = this.document.ref(this.outlineData);
    this.children = [];
  }
  var _proto = PDFOutline2.prototype;
  _proto.addItem = function addItem(title3, options) {
    if (options === void 0) {
      options = DEFAULT_OPTIONS;
    }
    var pages = this.document._root.data.Pages.data.Kids;
    var dest = options.pageNumber !== null ? pages[options.pageNumber] : this.document.page.dictionary;
    var result = new PDFOutline2(this.document, this.dictionary, title3, dest, options);
    this.children.push(result);
    return result;
  };
  _proto.endOutline = function endOutline2() {
    if (this.children.length > 0) {
      if (this.options.expanded) {
        this.outlineData.Count = this.children.length;
      }
      var first = this.children[0];
      var last3 = this.children[this.children.length - 1];
      this.outlineData.First = first.dictionary;
      this.outlineData.Last = last3.dictionary;
      for (var i = 0, len = this.children.length; i < len; i++) {
        var child = this.children[i];
        if (i > 0) {
          child.outlineData.Prev = this.children[i - 1].dictionary;
        }
        if (i < this.children.length - 1) {
          child.outlineData.Next = this.children[i + 1].dictionary;
        }
        child.endOutline();
      }
    }
    return this.dictionary.end();
  };
  return PDFOutline2;
}();
var OutlineMixin = {
  initOutline: function initOutline() {
    this.outline = new PDFOutline(this, null, null, null);
  },
  endOutline: function endOutline() {
    this.outline.endOutline();
    if (this.outline.children.length > 0) {
      this._root.data.Outlines = this.outline.dictionary;
      this._root.data.PageMode = this._root.data.PageMode || "UseOutlines";
    }
  }
};
var FIELD_FLAGS = {
  readOnly: 1,
  required: 2,
  noExport: 4,
  multiline: 4096,
  password: 8192,
  toggleToOffButton: 16384,
  radioButton: 32768,
  pushButton: 65536,
  combo: 131072,
  edit: 262144,
  sort: 524288,
  multiSelect: 2097152,
  noSpell: 4194304
};
var FIELD_JUSTIFY = {
  left: 0,
  center: 1,
  right: 2
};
var VALUE_MAP = {
  value: "V",
  defaultValue: "DV"
};
var FORMAT_SPECIAL = {
  zip: "0",
  zipPlus4: "1",
  zip4: "1",
  phone: "2",
  ssn: "3"
};
var FORMAT_DEFAULT = {
  number: {
    nDec: 0,
    sepComma: false,
    negStyle: "MinusBlack",
    currency: "",
    currencyPrepend: true
  },
  percent: {
    nDec: 0,
    sepComma: false
  }
};
var AcroFormMixin = {
  /**
   * Must call if adding AcroForms to a document. Must also call font() before
   * this method to set the default font.
   */
  initForm: function initForm() {
    if (!this._font) {
      throw new Error("Must set a font before calling initForm method");
    }
    this._acroform = {
      fonts: {},
      defaultFont: this._font.name
    };
    this._acroform.fonts[this._font.id] = this._font.ref();
    var data2 = {
      Fields: [],
      NeedAppearances: true,
      DA: new String("/" + this._font.id + " 0 Tf 0 g"),
      DR: {
        Font: {}
      }
    };
    data2.DR.Font[this._font.id] = this._font.ref();
    var AcroForm = this.ref(data2);
    this._root.data.AcroForm = AcroForm;
    return this;
  },
  /**
   * Called automatically by document.js
   */
  endAcroForm: function endAcroForm() {
    var _this = this;
    if (this._root.data.AcroForm) {
      if (!Object.keys(this._acroform.fonts).length && !this._acroform.defaultFont) {
        throw new Error("No fonts specified for PDF form");
      }
      var fontDict = this._root.data.AcroForm.data.DR.Font;
      Object.keys(this._acroform.fonts).forEach(function(name) {
        fontDict[name] = _this._acroform.fonts[name];
      });
      this._root.data.AcroForm.data.Fields.forEach(function(fieldRef) {
        _this._endChild(fieldRef);
      });
      this._root.data.AcroForm.end();
    }
    return this;
  },
  _endChild: function _endChild(ref) {
    var _this2 = this;
    if (Array.isArray(ref.data.Kids)) {
      ref.data.Kids.forEach(function(childRef) {
        _this2._endChild(childRef);
      });
      ref.end();
    }
    return this;
  },
  /**
   * Creates and adds a form field to the document. Form fields are intermediate
   * nodes in a PDF form that are used to specify form name heirarchy and form
   * value defaults.
   * @param {string} name - field name (T attribute in field dictionary)
   * @param {object} options  - other attributes to include in field dictionary
   */
  formField: function formField(name, options) {
    if (options === void 0) {
      options = {};
    }
    var fieldDict = this._fieldDict(name, null, options);
    var fieldRef = this.ref(fieldDict);
    this._addToParent(fieldRef);
    return fieldRef;
  },
  /**
   * Creates and adds a Form Annotation to the document. Form annotations are
   * called Widget annotations internally within a PDF file.
   * @param {string} name - form field name (T attribute of widget annotation
   * dictionary)
   * @param {number} x
   * @param {number} y
   * @param {number} w
   * @param {number} h
   * @param {object} options
   */
  formAnnotation: function formAnnotation(name, type, x, y, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    var fieldDict = this._fieldDict(name, type, options);
    fieldDict.Subtype = "Widget";
    if (fieldDict.F === void 0) {
      fieldDict.F = 4;
    }
    this.annotate(x, y, w, h2, fieldDict);
    var annotRef = this.page.annotations[this.page.annotations.length - 1];
    return this._addToParent(annotRef);
  },
  formText: function formText(name, x, y, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "text", x, y, w, h2, options);
  },
  formPushButton: function formPushButton(name, x, y, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "pushButton", x, y, w, h2, options);
  },
  formCombo: function formCombo(name, x, y, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "combo", x, y, w, h2, options);
  },
  formList: function formList(name, x, y, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "list", x, y, w, h2, options);
  },
  formRadioButton: function formRadioButton(name, x, y, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "radioButton", x, y, w, h2, options);
  },
  formCheckbox: function formCheckbox(name, x, y, w, h2, options) {
    if (options === void 0) {
      options = {};
    }
    return this.formAnnotation(name, "checkbox", x, y, w, h2, options);
  },
  _addToParent: function _addToParent(fieldRef) {
    var parent = fieldRef.data.Parent;
    if (parent) {
      if (!parent.data.Kids) {
        parent.data.Kids = [];
      }
      parent.data.Kids.push(fieldRef);
    } else {
      this._root.data.AcroForm.data.Fields.push(fieldRef);
    }
    return this;
  },
  _fieldDict: function _fieldDict(name, type, options) {
    if (options === void 0) {
      options = {};
    }
    if (!this._acroform) {
      throw new Error("Call document.initForms() method before adding form elements to document");
    }
    var opts2 = Object.assign({}, options);
    if (type !== null) {
      opts2 = this._resolveType(type, options);
    }
    opts2 = this._resolveFlags(opts2);
    opts2 = this._resolveJustify(opts2);
    opts2 = this._resolveFont(opts2);
    opts2 = this._resolveStrings(opts2);
    opts2 = this._resolveColors(opts2);
    opts2 = this._resolveFormat(opts2);
    opts2.T = new String(name);
    if (opts2.parent) {
      opts2.Parent = opts2.parent;
      delete opts2.parent;
    }
    return opts2;
  },
  _resolveType: function _resolveType(type, opts2) {
    if (type === "text") {
      opts2.FT = "Tx";
    } else if (type === "pushButton") {
      opts2.FT = "Btn";
      opts2.pushButton = true;
    } else if (type === "radioButton") {
      opts2.FT = "Btn";
      opts2.radioButton = true;
    } else if (type === "checkbox") {
      opts2.FT = "Btn";
    } else if (type === "combo") {
      opts2.FT = "Ch";
      opts2.combo = true;
    } else if (type === "list") {
      opts2.FT = "Ch";
    } else {
      throw new Error("Invalid form annotation type '" + type + "'");
    }
    return opts2;
  },
  _resolveFormat: function _resolveFormat(opts2) {
    var f = opts2.format;
    if (f && f.type) {
      var fnKeystroke;
      var fnFormat;
      var params = "";
      if (FORMAT_SPECIAL[f.type] !== void 0) {
        fnKeystroke = "AFSpecial_Keystroke";
        fnFormat = "AFSpecial_Format";
        params = FORMAT_SPECIAL[f.type];
      } else {
        var format = f.type.charAt(0).toUpperCase() + f.type.slice(1);
        fnKeystroke = "AF" + format + "_Keystroke";
        fnFormat = "AF" + format + "_Format";
        if (f.type === "date") {
          fnKeystroke += "Ex";
          params = String(f.param);
        } else if (f.type === "time") {
          params = String(f.param);
        } else if (f.type === "number") {
          var p = Object.assign({}, FORMAT_DEFAULT.number, f);
          params = String([String(p.nDec), p.sepComma ? "0" : "1", '"' + p.negStyle + '"', "null", '"' + p.currency + '"', String(p.currencyPrepend)].join(","));
        } else if (f.type === "percent") {
          var _p = Object.assign({}, FORMAT_DEFAULT.percent, f);
          params = String([String(_p.nDec), _p.sepComma ? "0" : "1"].join(","));
        }
      }
      opts2.AA = opts2.AA ? opts2.AA : {};
      opts2.AA.K = {
        S: "JavaScript",
        JS: new String(fnKeystroke + "(" + params + ");")
      };
      opts2.AA.F = {
        S: "JavaScript",
        JS: new String(fnFormat + "(" + params + ");")
      };
    }
    delete opts2.format;
    return opts2;
  },
  _resolveColors: function _resolveColors(opts2) {
    var color = this._normalizeColor(opts2.backgroundColor);
    if (color) {
      if (!opts2.MK) {
        opts2.MK = {};
      }
      opts2.MK.BG = color;
    }
    color = this._normalizeColor(opts2.borderColor);
    if (color) {
      if (!opts2.MK) {
        opts2.MK = {};
      }
      opts2.MK.BC = color;
    }
    delete opts2.backgroundColor;
    delete opts2.borderColor;
    return opts2;
  },
  _resolveFlags: function _resolveFlags(options) {
    var result = 0;
    Object.keys(options).forEach(function(key) {
      if (FIELD_FLAGS[key]) {
        result |= FIELD_FLAGS[key];
        delete options[key];
      }
    });
    if (result !== 0) {
      options.Ff = options.Ff ? options.Ff : 0;
      options.Ff |= result;
    }
    return options;
  },
  _resolveJustify: function _resolveJustify(options) {
    var result = 0;
    if (options.align !== void 0) {
      if (typeof FIELD_JUSTIFY[options.align] === "number") {
        result = FIELD_JUSTIFY[options.align];
      }
      delete options.align;
    }
    if (result !== 0) {
      options.Q = result;
    }
    return options;
  },
  _resolveFont: function _resolveFont(options) {
    if (this._acroform.fonts[this._font.id] === null) {
      this._acroform.fonts[this._font.id] = this._font.ref();
    }
    if (this._acroform.defaultFont !== this._font.name) {
      options.DR = {
        Font: {}
      };
      var fontSize2 = options.fontSize || 0;
      options.DR.Font[this._font.id] = this._font.ref();
      options.DA = new String("/" + this._font.id + " " + fontSize2 + " Tf 0 g");
    }
    return options;
  },
  _resolveStrings: function _resolveStrings(options) {
    var select = [];
    function appendChoices(a2) {
      if (Array.isArray(a2)) {
        for (var idx = 0; idx < a2.length; idx++) {
          if (typeof a2[idx] === "string") {
            select.push(new String(a2[idx]));
          } else {
            select.push(a2[idx]);
          }
        }
      }
    }
    appendChoices(options.Opt);
    if (options.select) {
      appendChoices(options.select);
      delete options.select;
    }
    if (select.length) {
      options.Opt = select;
    }
    Object.keys(VALUE_MAP).forEach(function(key) {
      if (options[key] !== void 0) {
        options[VALUE_MAP[key]] = options[key];
        delete options[key];
      }
    });
    ["V", "DV"].forEach(function(key) {
      if (typeof options[key] === "string") {
        options[key] = new String(options[key]);
      }
    });
    if (options.MK && options.MK.CA) {
      options.MK.CA = new String(options.MK.CA);
    }
    if (options.label) {
      options.MK = options.MK ? options.MK : {};
      options.MK.CA = new String(options.label);
      delete options.label;
    }
    return options;
  }
};
var AttachmentsMixin = {
  /**
   * Embed contents of `src` in PDF
   * @param {Buffer | ArrayBuffer | string} src input Buffer, ArrayBuffer, base64 encoded string or path to file
   * @param {object} options
   *  * options.name: filename to be shown in PDF, will use `src` if none set
   *  * options.type: filetype to be shown in PDF
   *  * options.description: description to be shown in PDF
   *  * options.hidden: if true, do not add attachment to EmbeddedFiles dictionary. Useful for file attachment annotations
   *  * options.creationDate: override creation date
   *  * options.modifiedDate: override modified date
   * @returns filespec reference
   */
  file: function file(src3, options) {
    if (options === void 0) {
      options = {};
    }
    options.name = options.name || src3;
    var refBody = {
      Type: "EmbeddedFile",
      Params: {}
    };
    var data2;
    if (!src3) {
      throw new Error("No src specified");
    }
    if (Buffer$4.isBuffer(src3)) {
      data2 = src3;
    } else if (src3 instanceof ArrayBuffer) {
      data2 = Buffer$4.from(new Uint8Array(src3));
    } else {
      var match;
      if (match = /^data:(.*);base64,(.*)$/.exec(src3)) {
        if (match[1]) {
          refBody.Subtype = match[1].replace("/", "#2F");
        }
        data2 = Buffer$4.from(match[2], "base64");
      } else {
        throw new Error("Could not find file " + src3);
      }
    }
    if (options.creationDate instanceof Date) {
      refBody.Params.CreationDate = options.creationDate;
    }
    if (options.modifiedDate instanceof Date) {
      refBody.Params.ModDate = options.modifiedDate;
    }
    if (options.type) {
      refBody.Subtype = options.type.replace("/", "#2F");
    }
    var checksum = (0, import_md5.default)(CryptoJS.lib.WordArray.create(new Uint8Array(data2)));
    refBody.Params.CheckSum = new String(checksum);
    refBody.Params.Size = data2.byteLength;
    var ref;
    if (!this._fileRegistry)
      this._fileRegistry = {};
    var file2 = this._fileRegistry[options.name];
    if (file2 && isEqual(refBody, file2)) {
      ref = file2.ref;
    } else {
      ref = this.ref(refBody);
      ref.end(data2);
      this._fileRegistry[options.name] = _extends4({}, refBody, {
        ref
      });
    }
    var fileSpecBody = {
      Type: "Filespec",
      F: new String(options.name),
      EF: {
        F: ref
      },
      UF: new String(options.name)
    };
    if (options.description) {
      fileSpecBody.Desc = new String(options.description);
    }
    var filespec = this.ref(fileSpecBody);
    filespec.end();
    if (!options.hidden) {
      this.addNamedEmbeddedFile(options.name, filespec);
    }
    return filespec;
  }
};
function isEqual(a2, b) {
  return a2.Subtype === b.Subtype && a2.Params.CheckSum.toString() === b.Params.CheckSum.toString() && a2.Params.Size === b.Params.Size && a2.Params.CreationDate === b.Params.CreationDate && a2.Params.ModDate === b.Params.ModDate;
}
var capitalize3 = function capitalize4(v2) {
  return v2[0].toUpperCase() + v2.slice(1);
};
var PDFDocument = function(_stream$Readable) {
  _inheritsLoose(PDFDocument2, _stream$Readable);
  function PDFDocument2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _stream$Readable.call(this) || this;
    _this.options = options;
    switch (options.pdfVersion) {
      case "1.4":
        _this.version = 1.4;
        break;
      case "1.5":
        _this.version = 1.5;
        break;
      case "1.6":
        _this.version = 1.6;
        break;
      case "1.7":
      case "1.7ext3":
        _this.version = 1.7;
        break;
      default:
        _this.version = 1.3;
        break;
    }
    _this.compress = _this.options.compress != null ? _this.options.compress : true;
    _this._pageBuffer = [];
    _this._pageBufferStart = 0;
    _this._offsets = [];
    _this._waiting = 0;
    _this._ended = false;
    _this._offset = 0;
    var Pages = _this.ref({
      Type: "Pages",
      Count: 0,
      Kids: []
    });
    var Names = _this.ref({
      Dests: new PDFNameTree()
    });
    _this._root = _this.ref({
      Type: "Catalog",
      Pages,
      Names
    });
    if (_this.options.lang) {
      _this._root.data.Lang = new String(_this.options.lang);
    }
    if (_this.options.pageLayout) {
      _this._root.data.PageLayout = capitalize3(_this.options.pageLayout);
    }
    if (_this.options.pageMode) {
      _this._root.data.PageMode = capitalize3(_this.options.pageMode);
    }
    _this.page = null;
    _this.initColor();
    _this.initVector();
    _this.initFonts();
    _this.initText();
    _this.initImages();
    _this.initOutline();
    _this.info = {
      Producer: "PDFKit",
      Creator: "PDFKit",
      CreationDate: /* @__PURE__ */ new Date()
    };
    if (_this.options.info) {
      for (var key in _this.options.info) {
        var val = _this.options.info[key];
        _this.info[key] = val;
      }
    }
    if (_this.options.displayTitle) {
      _this._root.data.ViewerPreferences = _this.ref({
        DisplayDocTitle: true
      });
    }
    _this._id = PDFSecurity.generateFileID(_this.info);
    _this._write("%PDF-" + _this.version);
    _this._write("%ÿÿÿÿ");
    if (_this.options.autoFirstPage !== false) {
      _this.addPage();
    }
    return _this;
  }
  var _proto = PDFDocument2.prototype;
  _proto.addPage = function addPage(options) {
    if (options == null) {
      options = this.options;
    }
    if (!this.options.bufferPages) {
      this.flushPages();
    }
    this.page = new PDFPage(this, options);
    this._pageBuffer.push(this.page);
    var pages = this._root.data.Pages.data;
    pages.Kids.push(this.page.dictionary);
    pages.Count++;
    this._ctm = [1, 0, 0, 1, 0, 0];
    this.transform(1, 0, 0, -1, 0, this.page.height);
    return this;
  };
  _proto.flushPages = function flushPages() {
    var pages = this._pageBuffer;
    this._pageBuffer = [];
    this._pageBufferStart += pages.length;
    for (var _i = 0, _Array$from = Array.from(pages); _i < _Array$from.length; _i++) {
      var page = _Array$from[_i];
      page.end();
    }
  };
  _proto.addNamedDestination = function addNamedDestination(name) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (args.length === 0) {
      args = ["XYZ", null, null, null];
    }
    if (args[0] === "XYZ" && args[2] !== null) {
      args[2] = this.page.height - args[2];
    }
    args.unshift(this.page.dictionary);
    this._root.data.Names.data.Dests.add(name, args);
  };
  _proto.addNamedEmbeddedFile = function addNamedEmbeddedFile(name, ref) {
    if (!this._root.data.Names.data.EmbeddedFiles) {
      this._root.data.Names.data.EmbeddedFiles = new PDFNameTree({
        limits: false
      });
    }
    this._root.data.Names.data.EmbeddedFiles.add(name, ref);
  };
  _proto.addNamedJavaScript = function addNamedJavaScript(name, js) {
    if (!this._root.data.Names.data.JavaScript) {
      this._root.data.Names.data.JavaScript = new PDFNameTree();
    }
    var data2 = {
      JS: new String(js),
      S: "JavaScript"
    };
    this._root.data.Names.data.JavaScript.add(name, data2);
  };
  _proto.ref = function ref(data2) {
    var ref2 = new PDFReference(this, this._offsets.length + 1, data2);
    this._offsets.push(null);
    this._waiting++;
    return ref2;
  };
  _proto._read = function _read() {
  };
  _proto._write = function _write(data2) {
    if (!Buffer$4.isBuffer(data2)) {
      data2 = Buffer$4.from(data2 + "\n", "binary");
    }
    this.push(data2);
    return this._offset += data2.length;
  };
  _proto.addContent = function addContent(data2) {
    this.page.write(data2);
    return this;
  };
  _proto._refEnd = function _refEnd(ref) {
    this._offsets[ref.id - 1] = ref.offset;
    if (--this._waiting === 0 && this._ended) {
      this._finalize();
      return this._ended = false;
    }
  };
  _proto.end = function end3() {
    this.flushPages();
    this._info = this.ref();
    for (var key in this.info) {
      var val = this.info[key];
      if (typeof val === "string") {
        val = new String(val);
      }
      var entry = this.ref(val);
      entry.end();
      this._info.data[key] = entry;
    }
    this._info.end();
    for (var name in this._fontFamilies) {
      var font2 = this._fontFamilies[name];
      font2.finalize();
    }
    this.endOutline();
    this._root.end();
    this._root.data.Pages.end();
    this._root.data.Names.end();
    this.endAcroForm();
    if (this._root.data.ViewerPreferences) {
      this._root.data.ViewerPreferences.end();
    }
    if (this._waiting === 0) {
      return this._finalize();
    }
    this._ended = true;
  };
  _proto._finalize = function _finalize() {
    var xRefOffset = this._offset;
    this._write("xref");
    this._write("0 " + (this._offsets.length + 1));
    this._write("0000000000 65535 f ");
    for (var _i2 = 0, _Array$from2 = Array.from(this._offsets); _i2 < _Array$from2.length; _i2++) {
      var offset3 = _Array$from2[_i2];
      offset3 = ("0000000000" + offset3).slice(-10);
      this._write(offset3 + " 00000 n ");
    }
    var trailer = {
      Size: this._offsets.length + 1,
      Root: this._root,
      Info: this._info,
      ID: [this._id, this._id]
    };
    this._write("trailer");
    this._write(PDFObject$1.convert(trailer));
    this._write("startxref");
    this._write("" + xRefOffset);
    this._write("%%EOF");
    return this.push(null);
  };
  _proto.toString = function toString7() {
    return "[object PDFDocument]";
  };
  return PDFDocument2;
}(stream.Readable);
var mixin = function mixin2(methods) {
  Object.assign(PDFDocument.prototype, methods);
};
mixin(ColorMixin);
mixin(VectorMixin);
mixin(FontsMixin);
mixin(TextMixin);
mixin(ImagesMixin);
mixin(AnnotationsMixin);
mixin(OutlineMixin);
mixin(AcroFormMixin);
mixin(AttachmentsMixin);

// ../node_modules/@react-pdf/stylesheet/lib/index.es.js
var import_parse = __toESM(require_parse());
var import_unit = __toESM(require_unit());
var import_hsl_to_hex = __toESM(require_hsl_to_hex());
var import_color_string2 = __toESM(require_color_string());

// ../node_modules/@react-pdf/stylesheet/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends5() {
  _extends5 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends5.apply(this, arguments);
}

// ../node_modules/@react-pdf/stylesheet/lib/index.es.js
var import_media_engine = __toESM(require_src());
var flexDefaults = [1, 1, 0];
var flexAuto = [1, 1, "auto"];
var expandFlex = function expandFlex2(key, value2) {
  var defaults = flexDefaults;
  var matches = [];
  if (value2 === "auto") {
    defaults = flexAuto;
  } else {
    matches = ("" + value2).split(" ");
  }
  var flexGrow = matches[0] || defaults[0];
  var flexShrink = matches[1] || defaults[1];
  var flexBasis = matches[2] || defaults[2];
  return {
    flexGrow,
    flexShrink,
    flexBasis
  };
};
var BOX_MODEL_UNITS = "px,in,mm,cm,pt,%,vw,vh";
var logError = function logError2(style, value2) {
  console.error("\n    @react-pdf/stylesheet parsing error:\n\n    " + style + ": " + value2 + ",\n    " + " ".repeat(style.length + 2) + "^\n    Unsupported " + style + " value format\n  ");
};
var expandBoxModel = function expandBoxModel2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, expandsTo7 = _ref.expandsTo, _ref$maxValues = _ref.maxValues, maxValues = _ref$maxValues === void 0 ? 1 : _ref$maxValues, _ref$autoSupported = _ref.autoSupported, autoSupported = _ref$autoSupported === void 0 ? false : _ref$autoSupported;
  return function(model, value2) {
    var _ref2;
    var nodes = (0, import_parse.default)("" + value2);
    var parts = [];
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (node.type === "function" || node.type === "string" || node.type === "div") {
        logError(model, value2);
        return {};
      }
      if (node.type === "word") {
        if (node.value === "auto" && autoSupported) {
          parts.push(node.value);
        } else {
          var result = (0, import_unit.default)(node.value);
          if (result && BOX_MODEL_UNITS.includes(result.unit)) {
            parts.push(node.value);
          } else {
            logError(model, value2);
            return {};
          }
        }
      }
    }
    if (parts.length > maxValues) {
      logError(model, value2);
      return {};
    }
    var first = parts[0];
    if (expandsTo7) {
      var second = parts[1] || parts[0];
      var third = parts[2] || parts[0];
      var fourth = parts[3] || parts[1] || parts[0];
      return expandsTo7({
        first,
        second,
        third,
        fourth
      });
    }
    return _ref2 = {}, _ref2[model] = first, _ref2;
  };
};
var processMargin = expandBoxModel({
  expandsTo: function expandsTo(_ref) {
    var first = _ref.first, second = _ref.second, third = _ref.third, fourth = _ref.fourth;
    return {
      marginTop: first,
      marginRight: second,
      marginBottom: third,
      marginLeft: fourth
    };
  },
  maxValues: 4,
  autoSupported: true
});
var processMarginVertical = expandBoxModel({
  expandsTo: function expandsTo2(_ref2) {
    var first = _ref2.first, second = _ref2.second;
    return {
      marginTop: first,
      marginBottom: second
    };
  },
  maxValues: 2,
  autoSupported: true
});
var processMarginHorizontal = expandBoxModel({
  expandsTo: function expandsTo3(_ref3) {
    var first = _ref3.first, second = _ref3.second;
    return {
      marginRight: first,
      marginLeft: second
    };
  },
  maxValues: 2,
  autoSupported: true
});
var processMarginSingle = expandBoxModel({
  autoSupported: true
});
var BORDER_SHORTHAND_REGEX = /(-?\d+(\.\d+)?(px|in|mm|cm|pt|vw|vh|px)?)\s(\S+)\s(.+)/;
var matchBorderShorthand = function matchBorderShorthand2(value2) {
  return value2.match(BORDER_SHORTHAND_REGEX) || [];
};
var expandBorders = function expandBorders2(key, value2) {
  var match = matchBorderShorthand("" + value2);
  if (match) {
    var color = match[5] || value2;
    var style = match[4] || value2;
    var width = match[1] || value2;
    if (key.match(/(Top|Right|Bottom|Left)$/)) {
      var _ref;
      return _ref = {}, _ref[key + "Color"] = color, _ref[key + "Style"] = style, _ref[key + "Width"] = width, _ref;
    }
    if (key.match(/Color$/)) {
      return {
        borderTopColor: color,
        borderRightColor: color,
        borderBottomColor: color,
        borderLeftColor: color
      };
    }
    if (key.match(/Style$/)) {
      return {
        borderTopStyle: style,
        borderRightStyle: style,
        borderBottomStyle: style,
        borderLeftStyle: style
      };
    }
    if (key.match(/Width$/)) {
      return {
        borderTopWidth: width,
        borderRightWidth: width,
        borderBottomWidth: width,
        borderLeftWidth: width
      };
    }
    if (key.match(/Radius$/)) {
      return {
        borderTopLeftRadius: value2,
        borderTopRightRadius: value2,
        borderBottomRightRadius: value2,
        borderBottomLeftRadius: value2
      };
    }
    return {
      borderTopColor: color,
      borderTopStyle: style,
      borderTopWidth: width,
      borderRightColor: color,
      borderRightStyle: style,
      borderRightWidth: width,
      borderBottomColor: color,
      borderBottomStyle: style,
      borderBottomWidth: width,
      borderLeftColor: color,
      borderLeftStyle: style,
      borderLeftWidth: width
    };
  }
  return value2;
};
var processPadding = expandBoxModel({
  expandsTo: function expandsTo4(_ref) {
    var first = _ref.first, second = _ref.second, third = _ref.third, fourth = _ref.fourth;
    return {
      paddingTop: first,
      paddingRight: second,
      paddingBottom: third,
      paddingLeft: fourth
    };
  },
  maxValues: 4
});
var processPaddingVertical = expandBoxModel({
  expandsTo: function expandsTo5(_ref2) {
    var first = _ref2.first, second = _ref2.second;
    return {
      paddingTop: first,
      paddingBottom: second
    };
  },
  maxValues: 2
});
var processPaddingHorizontal = expandBoxModel({
  expandsTo: function expandsTo6(_ref3) {
    var first = _ref3.first, second = _ref3.second;
    return {
      paddingRight: first,
      paddingLeft: second
    };
  },
  maxValues: 2
});
var processPaddingSingle = expandBoxModel();
var expandObjectPosition = function expandObjectPosition2(key, value2) {
  var match = ("" + value2).split(" ");
  return {
    objectPositionX: (match === null || match === void 0 ? void 0 : match[0]) || value2,
    objectPositionY: (match === null || match === void 0 ? void 0 : match[1]) || value2
  };
};
var Y_AXIS_SHORTHANDS = {
  top: true,
  bottom: true
};
var sortTransformOriginPair = function sortTransformOriginPair2(a2, b) {
  if (Y_AXIS_SHORTHANDS[a2])
    return 1;
  if (Y_AXIS_SHORTHANDS[b])
    return -1;
  return 0;
};
var getTransformOriginPair = function getTransformOriginPair2(values) {
  if (!values || values.length === 0)
    return ["center", "center"];
  var pair = values.length === 1 ? [values[0], "center"] : values;
  return pair.sort(sortTransformOriginPair);
};
var expandTransformOrigin = function expandTransformOrigin2(key, value2) {
  var match = ("" + value2).split(" ");
  var pair = getTransformOriginPair(match);
  return {
    transformOriginX: pair[0],
    transformOriginY: pair[1]
  };
};
var expandGap = function expandGap2(key, value2) {
  var match = ("" + value2).split(" ");
  return {
    rowGap: (match === null || match === void 0 ? void 0 : match[0]) || value2,
    columnGap: (match === null || match === void 0 ? void 0 : match[1]) || value2
  };
};
var shorthands = {
  flex: expandFlex,
  gap: expandGap,
  margin: processMargin,
  marginHorizontal: processMarginHorizontal,
  marginVertical: processMarginVertical,
  marginTop: processMarginSingle,
  marginRight: processMarginSingle,
  marginBottom: processMarginSingle,
  marginLeft: processMarginSingle,
  padding: processPadding,
  paddingHorizontal: processPaddingHorizontal,
  paddingVertical: processPaddingVertical,
  paddingTop: processPaddingSingle,
  paddingRight: processPaddingSingle,
  paddingBottom: processPaddingSingle,
  paddingLeft: processPaddingSingle,
  border: expandBorders,
  borderTop: expandBorders,
  borderRight: expandBorders,
  borderBottom: expandBorders,
  borderLeft: expandBorders,
  borderColor: expandBorders,
  borderRadius: expandBorders,
  borderStyle: expandBorders,
  borderWidth: expandBorders,
  objectPosition: expandObjectPosition,
  transformOrigin: expandTransformOrigin
};
var expandStyle = function expandStyle2(key, value2) {
  var _ref;
  return shorthands[key] ? shorthands[key](key, value2) : (_ref = {}, _ref[key] = value2, _ref);
};
var expand = function expand2(style) {
  if (!style)
    return style;
  var propsArray = Object.keys(style);
  var resolvedStyle = {};
  for (var i = 0; i < propsArray.length; i += 1) {
    var key = propsArray[i];
    var value2 = style[key];
    var extended = expandStyle(key, value2);
    var keys5 = Object.keys(extended);
    for (var j = 0; j < keys5.length; j += 1) {
      var propName = keys5[j];
      var propValue = extended[propName];
      resolvedStyle[propName] = propValue;
    }
  }
  return resolvedStyle;
};
var compact = function compact2(array) {
  return array.filter(Boolean);
};
var mergeStyles = function mergeStyles2(styles) {
  return styles.reduce(function(acc, style) {
    var s2 = Array.isArray(style) ? flatten(style) : style;
    Object.keys(s2).forEach(function(key) {
      if (s2[key] !== null && s2[key] !== void 0) {
        acc[key] = s2[key];
      }
    });
    return acc;
  }, {});
};
var flatten = compose(mergeStyles, compact, castArray);
var parseValue = function parseValue2(value2) {
  var match = /^(-?\d*\.?\d+)(in|mm|cm|pt|vh|vw|px)?$/g.exec(value2);
  return match ? {
    value: parseFloat(match[1], 10),
    unit: match[2] || "pt"
  } : {
    value: value2,
    unit: void 0
  };
};
var transformUnit = function transformUnit2(container, value2) {
  var scalar = parseValue(value2);
  var dpi = container.dpi || 72;
  var mmFactor = 1 / 25.4 * dpi;
  var cmFactor = 1 / 2.54 * dpi;
  switch (scalar.unit) {
    case "in":
      return scalar.value * dpi;
    case "mm":
      return scalar.value * mmFactor;
    case "cm":
      return scalar.value * cmFactor;
    case "vh":
      return scalar.value * (container.height / 100);
    case "vw":
      return scalar.value * (container.width / 100);
    default:
      return scalar.value;
  }
};
var isRgb = function isRgb2(value2) {
  return /rgba?/g.test(value2);
};
var isHsl = function isHsl2(value2) {
  return /hsla?/g.test(value2);
};
var parseRgb = function parseRgb2(value2) {
  var rgb = import_color_string2.default.get.rgb(value2);
  return import_color_string2.default.to.hex(rgb);
};
var parseHsl = function parseHsl2(value2) {
  var hsl = import_color_string2.default.get.hsl(value2).map(Math.round);
  var hex = import_hsl_to_hex.default.apply(void 0, hsl);
  return hex.toUpperCase();
};
var transformColor = function transformColor2(value2) {
  if (isRgb(value2))
    return parseRgb(value2);
  if (isHsl(value2))
    return parseHsl(value2);
  return value2;
};
var parse = function parse2(transformString) {
  var transforms = transformString.trim().split(/\) |\)/);
  if (transforms.length === 1) {
    return [[transforms[0], true]];
  }
  var parsed = [];
  for (var i = 0; i < transforms.length; i += 1) {
    var transform4 = transforms[i];
    if (transform4) {
      var _transform$split = transform4.split("("), name = _transform$split[0], rawValue = _transform$split[1];
      var splitChar = rawValue.indexOf(",") >= 0 ? "," : " ";
      var value2 = rawValue.split(splitChar).map(function(val) {
        return val.trim();
      });
      parsed.push({
        operation: name,
        value: value2
      });
    }
  }
  return parsed;
};
var parseAngle = function parseAngle2(value2) {
  var unitsRegexp = /(-?\d*\.?\d*)(\w*)?/i;
  var _unitsRegexp$exec = unitsRegexp.exec(value2), angle = _unitsRegexp$exec[1], unit = _unitsRegexp$exec[2];
  var number2 = Number.parseFloat(angle);
  return unit === "rad" ? number2 * 180 / Math.PI : number2;
};
var normalizeTransformOperation = function normalizeTransformOperation2(_ref) {
  var operation = _ref.operation, value2 = _ref.value;
  switch (operation) {
    case "scale": {
      var _value$map = value2.map(function(num) {
        return Number.parseFloat(num);
      }), scaleX = _value$map[0], _value$map$ = _value$map[1], scaleY = _value$map$ === void 0 ? scaleX : _value$map$;
      return {
        operation: "scale",
        value: [scaleX, scaleY]
      };
    }
    case "scaleX": {
      return {
        operation: "scale",
        value: [Number.parseFloat(value2), 1]
      };
    }
    case "scaleY": {
      return {
        operation: "scale",
        value: [1, Number.parseFloat(value2)]
      };
    }
    case "rotate": {
      return {
        operation: "rotate",
        value: [parseAngle(value2)]
      };
    }
    case "translate": {
      return {
        operation: "translate",
        value: value2.map(function(num) {
          return Number.parseFloat(num);
        })
      };
    }
    case "translateX": {
      return {
        operation: "translate",
        value: [Number.parseFloat(value2), 0]
      };
    }
    case "translateY": {
      return {
        operation: "translate",
        value: [0, Number.parseFloat(value2)]
      };
    }
    case "skew": {
      return {
        operation: "skew",
        value: value2.map(parseAngle)
      };
    }
    case "skewX": {
      return {
        operation: "skew",
        value: [parseAngle(value2), 0]
      };
    }
    case "skewY": {
      return {
        operation: "skew",
        value: [0, parseAngle(value2)]
      };
    }
    default: {
      return {
        operation,
        value: value2.map(function(num) {
          return Number.parseFloat(num);
        })
      };
    }
  }
};
var normalize2 = function normalize3(operations) {
  return operations.map(function(operation) {
    return normalizeTransformOperation(operation);
  });
};
var processTransform = function processTransform2(value2) {
  if (typeof value2 !== "string")
    return value2;
  return normalize2(parse(value2));
};
var FONT_WEIGHTS2 = {
  thin: 100,
  hairline: 100,
  ultralight: 200,
  extralight: 200,
  light: 300,
  normal: 400,
  medium: 500,
  semibold: 600,
  demibold: 600,
  bold: 700,
  ultrabold: 800,
  extrabold: 800,
  heavy: 900,
  black: 900
};
var processFontWeight = function processFontWeight2(value2) {
  if (!value2)
    return FONT_WEIGHTS2.normal;
  if (typeof value2 === "number")
    return value2;
  var lv = value2.toLowerCase();
  if (FONT_WEIGHTS2[lv])
    return FONT_WEIGHTS2[lv];
  return value2;
};
var matchNumber = function matchNumber2(value2) {
  return typeof value2 === "string" && /^-?\d*\.?\d*$/.test(value2);
};
var castFloat = function castFloat2(value2) {
  if (typeof value2 !== "string")
    return value2;
  if (matchNumber(value2))
    return parseFloat(value2, 10);
  return value2;
};
var offsetKeyword = function offsetKeyword2(value2) {
  switch (value2) {
    case "top":
    case "left":
      return "0%";
    case "right":
    case "bottom":
      return "100%";
    case "center":
      return "50%";
    default:
      return null;
  }
};
var transformObjectPosition = function transformObjectPosition2(value2) {
  return offsetKeyword(value2) || castFloat(value2);
};
var transformTransformOrigin = function transformTransformOrigin2(value2) {
  return offsetKeyword(value2) || castFloat(value2);
};
var handlers = {
  transform: processTransform,
  fontWeight: processFontWeight,
  objectPositionX: transformObjectPosition,
  objectPositionY: transformObjectPosition,
  transformOriginX: transformTransformOrigin,
  transformOriginY: transformTransformOrigin
};
var transformStyle = function transformStyle2(key, value2, container) {
  var result = handlers[key] ? handlers[key](value2) : value2;
  return transformColor(transformUnit(container, castFloat(result)));
};
var transform2 = function transform3(container) {
  return function(style) {
    if (!style)
      return style;
    var propsArray = Object.keys(style);
    var resolvedStyle = {};
    for (var i = 0; i < propsArray.length; i += 1) {
      var key = propsArray[i];
      var value2 = style[key];
      var transformed = transformStyle(key, value2, container);
      resolvedStyle[key] = transformed;
    }
    return resolvedStyle;
  };
};
var resolveMediaQueries = function resolveMediaQueries2(container, styles) {
  return Object.keys(styles).reduce(function(acc, key) {
    var _extends22;
    if (/@media/.test(key)) {
      var _matchMedia;
      return _extends5({}, acc, (0, import_media_engine.default)((_matchMedia = {}, _matchMedia[key] = styles[key], _matchMedia), container));
    }
    return _extends5({}, acc, (_extends22 = {}, _extends22[key] = styles[key], _extends22));
  }, {});
};
var resolveStyles = function resolveStyles2(container, style) {
  var computeMediaQueries = function computeMediaQueries2(value2) {
    return resolveMediaQueries(container, value2);
  };
  return compose(transform2(container), expand, computeMediaQueries, flatten)(style);
};

// ../node_modules/@react-pdf/textkit/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends6() {
  _extends6 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends6.apply(this, arguments);
}

// ../node_modules/@react-pdf/textkit/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}

// ../node_modules/@react-pdf/textkit/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}

// ../node_modules/@react-pdf/textkit/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray2(o, minLen);
}

// ../node_modules/@react-pdf/textkit/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelperLoose.js
function _createForOfIteratorHelperLoose2(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return {
          done: true
        };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// ../node_modules/@react-pdf/textkit/lib/textkit.es.js
var import_hyphen = __toESM(require_hyphen2());
var import_en_us = __toESM(require_en_us());
var fromFragments = function fromFragments2(fragments) {
  var offset3 = 0;
  var string = "";
  var runs = [];
  fragments.forEach(function(fragment) {
    string += fragment.string;
    runs.push({
      start: offset3,
      end: offset3 + fragment.string.length,
      attributes: fragment.attributes || {}
    });
    offset3 += fragment.string.length;
  });
  return {
    string,
    runs
  };
};
var defaultHyphenationEngine = function defaultHyphenationEngine2(word) {
  return [word];
};
var wrapWords = function wrapWords2(engines2, options) {
  if (engines2 === void 0) {
    engines2 = {};
  }
  if (options === void 0) {
    options = {};
  }
  return function(attributedString) {
    var _engines$wordHyphenat, _engines;
    var syllables = [];
    var fragments = [];
    var hyphenateWord = options.hyphenationCallback || ((_engines$wordHyphenat = (_engines = engines2).wordHyphenation) === null || _engines$wordHyphenat === void 0 ? void 0 : _engines$wordHyphenat.call(_engines, options)) || defaultHyphenationEngine;
    for (var i = 0; i < attributedString.runs.length; i += 1) {
      var string = "";
      var run = attributedString.runs[i];
      var words = attributedString.string.slice(run.start, run.end).split(/([ ]+)/g).filter(Boolean);
      for (var j = 0; j < words.length; j += 1) {
        var word = words[j];
        var parts = hyphenateWord(word);
        syllables.push.apply(syllables, parts);
        string += parts.join("");
      }
      fragments.push({
        string,
        attributes: run.attributes
      });
    }
    return _extends6({}, fromFragments(fragments), {
      syllables
    });
  };
};
var copy3 = function copy4(rect2) {
  return Object.assign({}, rect2);
};
var partition = function partition2(rect2, height5) {
  var a2 = Object.assign({}, rect2, {
    height: height5
  });
  var b = Object.assign({}, rect2, {
    y: rect2.y + height5,
    height: rect2.height - height5
  });
  return [a2, b];
};
var crop = function crop2(height5, rect2) {
  var _partition = partition(rect2, height5), result = _partition[1];
  return result;
};
var height$2 = function height(paragraph) {
  return paragraph.reduce(function(acc, block) {
    return acc + block.box.height;
  }, 0);
};
var calculateScale = function calculateScale2(run) {
  var _attributes$font;
  var attributes2 = run.attributes || {};
  var fontSize2 = attributes2.fontSize || 12;
  var unitsPerEm = (_attributes$font = attributes2.font) === null || _attributes$font === void 0 ? void 0 : _attributes$font.unitsPerEm;
  return unitsPerEm ? fontSize2 / unitsPerEm : 0;
};
var scale2 = function scale3(run) {
  var _run$attributes;
  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.scale) || calculateScale(run);
};
var offset = function offset2(index3, run) {
  if (!run)
    return 0;
  var glyphIndices = run.glyphIndices || [];
  var value2 = glyphIndices[index3];
  return glyphIndices.slice(0, index3).filter(function(i) {
    return i === value2;
  }).length;
};
var getFont = function getFont2(run) {
  var _run$attributes;
  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.font) || null;
};
var slice$2 = function slice5(start3, end3, font2, glyph) {
  if (!glyph)
    return [];
  if (start3 === end3)
    return [];
  if (start3 === 0 && end3 === glyph.codePoints.length)
    return [glyph];
  var codePoints = glyph.codePoints.slice(start3, end3);
  var string = String.fromCodePoint.apply(String, codePoints);
  return font2 ? font2.layout(string).glyphs : [glyph];
};
var glyphIndexAt = function glyphIndexAt2(index3, run) {
  var _run$glyphIndices;
  var result = run === null || run === void 0 ? void 0 : (_run$glyphIndices = run.glyphIndices) === null || _run$glyphIndices === void 0 ? void 0 : _run$glyphIndices[index3];
  return isNil(result) ? index3 : result;
};
var normalize4 = function normalize5(array) {
  var head = array[0];
  return array.map(function(value2) {
    return value2 - head;
  });
};
var slice$13 = function slice6(start3, end3, run) {
  var _run$glyphs, _run$glyphs2;
  var runScale = scale2(run);
  var font2 = getFont(run);
  var startIndex = glyphIndexAt(start3, run);
  var endIndex = glyphIndexAt(end3, run);
  var startGlyph = (_run$glyphs = run.glyphs) === null || _run$glyphs === void 0 ? void 0 : _run$glyphs[startIndex];
  var endGlyph = (_run$glyphs2 = run.glyphs) === null || _run$glyphs2 === void 0 ? void 0 : _run$glyphs2[endIndex];
  var startOffset = offset(start3, run);
  var startGlyphs = startOffset > 0 ? slice$2(startOffset, Infinity, font2, startGlyph) : [];
  var endOffset = offset(end3, run);
  var endGlyphs = slice$2(0, endOffset, font2, endGlyph);
  var sliceStart = startIndex + Math.min(1, startOffset);
  var glyphs = (run.glyphs || []).slice(sliceStart, endIndex);
  var glyphPosition = function glyphPosition2(g3) {
    return {
      xAdvance: g3.advanceWidth * runScale
    };
  };
  var startPositions = startGlyphs.map(glyphPosition);
  var positions = (run.positions || []).slice(sliceStart, endIndex);
  var endPositions = endGlyphs.map(glyphPosition);
  return Object.assign({}, run, {
    start: run.start + start3,
    end: Math.min(run.end, run.start + end3),
    glyphIndices: normalize4((run.glyphIndices || []).slice(start3, end3)),
    glyphs: [startGlyphs, glyphs, endGlyphs].flat(),
    positions: [startPositions, positions, endPositions].flat()
  });
};
var runIndexAt$1 = function runIndexAt(n, runs) {
  if (!runs)
    return -1;
  return runs.findIndex(function(run) {
    return run.start <= n && n < run.end;
  });
};
var filter = function filter2(start3, end3, runs) {
  var startIndex = runIndexAt$1(start3, runs);
  var endIndex = Math.max(runIndexAt$1(end3 - 1, runs), startIndex);
  return runs.slice(startIndex, endIndex + 1);
};
var subtract = function subtract2(n, run) {
  var start3 = run.start - n;
  var end3 = run.end - n;
  return Object.assign({}, run, {
    start: start3,
    end: end3
  });
};
var sliceRuns = function sliceRuns2(start3, end3, runs) {
  var sliceFirstRun = function sliceFirstRun2(a2) {
    return slice$13(start3 - a2.start, end3 - a2.start, a2);
  };
  var sliceLastRun = function sliceLastRun2(a2) {
    return slice$13(0, end3 - a2.start, a2);
  };
  return runs.map(function(run, i) {
    var result = run;
    var isFirst = i === 0;
    var isLast = !isFirst && i === runs.length - 1;
    if (isFirst)
      result = sliceFirstRun(run);
    if (isLast)
      result = sliceLastRun(run);
    return subtract(start3, result);
  });
};
var slice7 = function slice8(start3, end3, attributedString) {
  if (attributedString.string.length === 0)
    return attributedString;
  var string = attributedString.string.slice(start3, end3);
  var filteredRuns = filter(start3, end3, attributedString.runs);
  var slicedRuns = sliceRuns(start3, end3, filteredRuns);
  return Object.assign({}, attributedString, {
    string,
    runs: slicedRuns
  });
};
var findCharIndex = function findCharIndex2(string) {
  return string.search(/\S/g);
};
var findLastCharIndex = function findLastCharIndex2(string) {
  var match = string.match(/\S/g);
  return match ? string.lastIndexOf(match[match.length - 1]) : -1;
};
var trim = function trim2(attributedString) {
  var start3 = findCharIndex(attributedString.string);
  var end3 = findLastCharIndex(attributedString.string);
  return slice7(start3, end3 + 1, attributedString);
};
var empty$1 = function empty() {
  return {
    start: 0,
    end: 0,
    glyphIndices: [],
    glyphs: [],
    positions: [],
    attributes: {}
  };
};
var isNumber = function isNumber2(value2) {
  return typeof value2 === "number";
};
var appendIndices = function appendIndices2(length4, indices) {
  var lastIndex = last(indices);
  var value2 = isNil(lastIndex) ? 0 : lastIndex + 1;
  var newIndices = Array(length4).fill(value2);
  return indices.concat(newIndices);
};
var fromCodePoint = function fromCodePoint2(value2, font2) {
  return font2 && value2 ? font2.glyphForCodePoint(value2) : null;
};
var appendGlyph = function appendGlyph2(glyph, run) {
  var _glyph$codePoints;
  var glyphLength = ((_glyph$codePoints = glyph.codePoints) === null || _glyph$codePoints === void 0 ? void 0 : _glyph$codePoints.length) || 0;
  var end3 = run.end + glyphLength;
  var glyphs = run.glyphs.concat(glyph);
  var glyphIndices = appendIndices(glyphLength, run.glyphIndices);
  if (!run.positions)
    return Object.assign({}, run, {
      end: end3,
      glyphs,
      glyphIndices
    });
  var positions = run.positions.concat({
    xAdvance: glyph.advanceWidth * scale2(run)
  });
  return Object.assign({}, run, {
    end: end3,
    glyphs,
    glyphIndices,
    positions
  });
};
var append$1 = function append(value2, run) {
  if (!value2)
    return run;
  var font2 = getFont(run);
  var glyph = isNumber(value2) ? fromCodePoint(value2, font2) : value2;
  return appendGlyph(glyph, run);
};
var stringFromCodePoints = function stringFromCodePoints2(codePoints) {
  return String.fromCodePoint.apply(String, codePoints);
};
var append2 = function append3(glyph, attributedString) {
  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];
  var codePointsString = stringFromCodePoints(codePoints);
  var string = attributedString.string + codePointsString;
  var firstRuns = attributedString.runs.slice(0, -1);
  var lastRun = last(attributedString.runs) || empty$1();
  var runs = firstRuns.concat(append$1(glyph, lastRun));
  return Object.assign({}, attributedString, {
    string,
    runs
  });
};
var ELLIPSIS_UNICODE = 8230;
var ELLIPSIS_STRING = String.fromCharCode(ELLIPSIS_UNICODE);
var getEllipsisCodePoint = function getEllipsisCodePoint2(font2) {
  if (!font2.encode)
    return ELLIPSIS_UNICODE;
  var _font$encode = font2.encode(ELLIPSIS_STRING), codePoints = _font$encode[0];
  return parseInt(codePoints[0], 16);
};
var truncate = function truncate2(block) {
  var _last, _last2, _last2$attributes;
  var runs = ((_last = last(block)) === null || _last === void 0 ? void 0 : _last.runs) || [];
  var font2 = (_last2 = last(runs)) === null || _last2 === void 0 ? void 0 : (_last2$attributes = _last2.attributes) === null || _last2$attributes === void 0 ? void 0 : _last2$attributes.font;
  if (font2) {
    var _Object$assign;
    var index3 = block.length - 1;
    var codePoint = getEllipsisCodePoint(font2);
    var glyph = font2.glyphForCodePoint(codePoint);
    var lastBlock = append2(glyph, trim(block[index3]));
    return Object.assign([], block, (_Object$assign = {}, _Object$assign[index3] = lastBlock, _Object$assign));
  }
  return block;
};
var omit3 = function omit4(value2, run) {
  var attributes2 = Object.assign({}, run.attributes);
  delete attributes2[value2];
  return Object.assign({}, run, {
    attributes: attributes2
  });
};
var ascent$1 = function ascent(run) {
  var _run$attributes, _run$attributes$attac, _run$attributes2, _run$attributes2$font;
  var attachmentHeight = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$attac = _run$attributes.attachment) === null || _run$attributes$attac === void 0 ? void 0 : _run$attributes$attac.height) || 0;
  var fontAscent = ((_run$attributes2 = run.attributes) === null || _run$attributes2 === void 0 ? void 0 : (_run$attributes2$font = _run$attributes2.font) === null || _run$attributes2$font === void 0 ? void 0 : _run$attributes2$font.ascent) || 0;
  return Math.max(attachmentHeight, fontAscent * scale2(run));
};
var descent = function descent2(run) {
  var _run$attributes, _run$attributes$font;
  var fontDescent = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.descent) || 0;
  return scale2(run) * fontDescent;
};
var lineGap = function lineGap2(run) {
  var _run$attributes, _run$attributes$font;
  return (((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.lineGap) || 0) * scale2(run);
};
var height$1 = function height2(run) {
  var _run$attributes;
  var lineHeight = (_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.lineHeight;
  return lineHeight || lineGap(run) + ascent$1(run) - descent(run);
};
var height3 = function height4(attributeString) {
  var reducer = function reducer2(acc, run) {
    return Math.max(acc, height$1(run));
  };
  return attributeString.runs.reduce(reducer, 0);
};
var intersects = function intersects2(a2, b) {
  var x = Math.max(a2.x, b.x);
  var num1 = Math.min(a2.x + a2.width, b.x + b.width);
  var y = Math.max(a2.y, b.y);
  var num2 = Math.min(a2.y + a2.height, b.y + b.height);
  return num1 >= x && num2 >= y;
};
var _excluded2 = ["excludeRects"];
var getLineFragment = function getLineFragment2(lineRect, excludeRect) {
  if (!intersects(excludeRect, lineRect))
    return [lineRect];
  var eStart = excludeRect.x;
  var eEnd = excludeRect.x + excludeRect.width;
  var lStart = lineRect.x;
  var lEnd = lineRect.x + lineRect.width;
  var a2 = Object.assign({}, lineRect, {
    width: eStart - lStart
  });
  var b = Object.assign({}, lineRect, {
    x: eEnd,
    width: lEnd - eEnd
  });
  return [a2, b].filter(function(r) {
    return r.width > 0;
  });
};
var getLineFragments = function getLineFragments2(rect2, excludeRects) {
  var fragments = [rect2];
  var _loop = function _loop2() {
    var excludeRect = excludeRects[i];
    fragments = fragments.reduce(function(acc, fragment) {
      var pieces = getLineFragment(fragment, excludeRect);
      return acc.concat(pieces);
    }, []);
  };
  for (var i = 0; i < excludeRects.length; i += 1) {
    _loop();
  }
  return fragments;
};
var generateLineRects = function generateLineRects2(container, height5) {
  var excludeRects = container.excludeRects, rect2 = _objectWithoutPropertiesLoose2(container, _excluded2);
  if (!excludeRects)
    return [rect2];
  var lineRects = [];
  var maxY = Math.max.apply(Math, excludeRects.map(function(r) {
    return r.y + r.height;
  }));
  var currentRect = rect2;
  while (currentRect.y < maxY) {
    var _partition = partition(currentRect, height5), lineRect = _partition[0], rest = _partition[1];
    var lineRectFragments = getLineFragments(lineRect, excludeRects);
    currentRect = rest;
    lineRects.push.apply(lineRects, lineRectFragments);
  }
  return [].concat(lineRects, [currentRect]);
};
var ATTACHMENT_CODE$1 = "￼";
var purgeAttachments = function purgeAttachments2(attributedString) {
  var shouldPurge = !attributedString.string.includes(ATTACHMENT_CODE$1);
  if (!shouldPurge)
    return attributedString;
  var runs = attributedString.runs.map(function(run) {
    return omit3("attachment", run);
  });
  return Object.assign({}, attributedString, {
    runs
  });
};
var layoutLines = function layoutLines2(rects, lines, indent) {
  var rect2 = rects.shift();
  var currentY = rect2.y;
  return lines.map(function(line2, i) {
    var _line$runs, _line$runs$;
    var lineIndent = i === 0 ? indent : 0;
    var style = ((_line$runs = line2.runs) === null || _line$runs === void 0 ? void 0 : (_line$runs$ = _line$runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes) || {};
    var height$12 = Math.max(height3(line2), style.lineHeight);
    if (currentY + height$12 > rect2.y + rect2.height && rects.length > 0) {
      rect2 = rects.shift();
      currentY = rect2.y;
    }
    var newLine = Object.assign({}, line2);
    delete newLine.syllables;
    newLine.box = {
      x: rect2.x + lineIndent,
      y: currentY,
      width: rect2.width - lineIndent,
      height: height$12
    };
    currentY += height$12;
    return purgeAttachments(newLine);
  });
};
var layoutParagraph = function layoutParagraph2(engines2, options) {
  return function(container, paragraph) {
    var _paragraph$runs, _paragraph$runs$, _paragraph$runs$$attr;
    var height$12 = height3(paragraph);
    var indent = ((_paragraph$runs = paragraph.runs) === null || _paragraph$runs === void 0 ? void 0 : (_paragraph$runs$ = _paragraph$runs[0]) === null || _paragraph$runs$ === void 0 ? void 0 : (_paragraph$runs$$attr = _paragraph$runs$.attributes) === null || _paragraph$runs$$attr === void 0 ? void 0 : _paragraph$runs$$attr.indent) || 0;
    var rects = generateLineRects(container, height$12);
    var availableWidths = rects.map(function(r) {
      return r.width;
    });
    availableWidths[0] -= indent;
    var lines = engines2.linebreaker(options)(paragraph, availableWidths);
    return layoutLines(rects, lines, indent);
  };
};
var sliceAtHeight = function sliceAtHeight2(height5, block) {
  var newBlock = [];
  var counter = 0;
  for (var i = 0; i < block.length; i += 1) {
    var line2 = block[i];
    counter += line2.box.height;
    if (counter < height5) {
      newBlock.push(line2);
    } else {
      break;
    }
  }
  return newBlock;
};
var typesetter = function typesetter2(engines2, options, container) {
  return function(attributedStrings) {
    var blocks = [];
    var paragraphs = [].concat(attributedStrings);
    var layoutBlock = layoutParagraph(engines2, options);
    var maxLines = isNil(container.maxLines) ? Infinity : container.maxLines;
    var truncateEllipsis = container.truncateMode === "ellipsis";
    var linesCount = maxLines;
    var paragraphRect = copy3(container);
    var nextParagraph = paragraphs.shift();
    while (linesCount > 0 && nextParagraph) {
      var block = layoutBlock(paragraphRect, nextParagraph);
      var slicedBlock = block.slice(0, linesCount);
      var linesHeight3 = height$2(slicedBlock);
      var shouldTruncate = truncateEllipsis && block.length !== slicedBlock.length;
      linesCount -= slicedBlock.length;
      if (paragraphRect.height >= linesHeight3) {
        blocks.push(shouldTruncate ? truncate(slicedBlock) : slicedBlock);
        paragraphRect = crop(linesHeight3, paragraphRect);
        nextParagraph = paragraphs.shift();
      } else {
        blocks.push(truncate(sliceAtHeight(paragraphRect.height, slicedBlock)));
        break;
      }
    }
    return blocks;
  };
};
var DUMMY_CODEPOINT = 123;
var resolve = function resolve2(glyphs) {
  if (glyphs === void 0) {
    glyphs = [];
  }
  return glyphs.reduce(function(acc, glyph) {
    var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [DUMMY_CODEPOINT];
    if (acc.length === 0)
      return codePoints.map(function() {
        return 0;
      });
    var last3 = acc[acc.length - 1];
    var next2 = codePoints.map(function() {
      return last3 + 1;
    });
    return [].concat(acc, next2);
  }, []);
};
var getCharacterSpacing = function getCharacterSpacing2(run) {
  var _run$attributes;
  return ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.characterSpacing) || 0;
};
var scalePositions = function scalePositions2(run, positions) {
  var runScale = scale2(run);
  var characterSpacing = getCharacterSpacing(run);
  return positions.map(function(position, i) {
    var isLast = i === positions.length;
    var xSpacing = isLast ? 0 : characterSpacing;
    return Object.assign({}, position, {
      xAdvance: position.xAdvance * runScale + xSpacing,
      yAdvance: position.yAdvance * runScale,
      xOffset: position.xOffset * runScale,
      yOffset: position.yOffset * runScale
    });
  });
};
var layoutRun = function layoutRun2(string) {
  return function(run) {
    var start3 = run.start, end3 = run.end, _run$attributes2 = run.attributes, attributes2 = _run$attributes2 === void 0 ? {} : _run$attributes2;
    var font2 = attributes2.font;
    if (!font2)
      return _extends6({}, run, {
        glyphs: [],
        glyphIndices: [],
        positions: []
      });
    var runString = string.slice(start3, end3);
    var glyphRun = font2.layout(runString);
    var positions = scalePositions(run, glyphRun.positions);
    var glyphIndices = resolve(glyphRun.glyphs);
    return _extends6({}, run, {
      positions,
      glyphIndices,
      glyphs: glyphRun.glyphs
    });
  };
};
var generateGlyphs = function generateGlyphs2() {
  return function(attributedString) {
    var runs = attributedString.runs.map(layoutRun(attributedString.string));
    return Object.assign({}, attributedString, {
      runs
    });
  };
};
var resolveRunYOffset = function resolveRunYOffset2(run) {
  var _run$attributes, _run$attributes$font, _run$attributes2;
  if (!run.positions)
    return run;
  var unitsPerEm = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : (_run$attributes$font = _run$attributes.font) === null || _run$attributes$font === void 0 ? void 0 : _run$attributes$font.unitsPerEm) || 0;
  var yOffset = (((_run$attributes2 = run.attributes) === null || _run$attributes2 === void 0 ? void 0 : _run$attributes2.yOffset) || 0) * unitsPerEm;
  var positions = run.positions.map(function(p) {
    return Object.assign({}, p, {
      yOffset
    });
  });
  return Object.assign({}, run, {
    positions
  });
};
var resolveYOffset = function resolveYOffset2() {
  return function(attributedString) {
    var runs = attributedString.runs.map(resolveRunYOffset);
    return Object.assign({}, attributedString, {
      runs
    });
  };
};
var sort = function sort2(runs) {
  return runs.sort(function(a2, b) {
    return a2.start - b.start || a2.end - b.end;
  });
};
var isEmpty = function isEmpty2(run) {
  return run.start === run.end;
};
var sortPoints = function sortPoints2(a2, b) {
  return a2[1] - b[1] || a2[3] - b[3];
};
var generatePoints = function generatePoints2(runs) {
  var result = runs.reduce(function(acc, run, i) {
    return acc.concat([["start", run.start, run.attributes, i], ["end", run.end, run.attributes, i]]);
  }, []);
  return result.sort(sortPoints);
};
var mergeRuns = function mergeRuns2(runs) {
  return runs.reduce(function(acc, run) {
    var attributes2 = Object.assign({}, acc.attributes, run.attributes);
    return Object.assign({}, run, {
      attributes: attributes2
    });
  }, {});
};
var groupEmptyRuns = function groupEmptyRuns2(runs) {
  var groups = runs.reduce(function(acc, run) {
    if (!acc[run.start])
      acc[run.start] = [];
    acc[run.start].push(run);
    return acc;
  }, {});
  return Object.values(groups);
};
var flattenEmptyRuns = function flattenEmptyRuns2(runs) {
  return groupEmptyRuns(runs).map(mergeRuns);
};
var flattenRegularRuns = function flattenRegularRuns2(runs) {
  var res = [];
  var points = generatePoints(runs);
  var start3 = -1;
  var attrs = {};
  var stack = [];
  for (var i = 0; i < points.length; i += 1) {
    var _points$i = points[i], type = _points$i[0], offset3 = _points$i[1], attributes2 = _points$i[2];
    if (start3 !== -1 && start3 < offset3) {
      res.push({
        start: start3,
        end: offset3,
        attributes: attrs
      });
    }
    if (type === "start") {
      stack.push(attributes2);
      attrs = Object.assign({}, attrs, attributes2);
    } else {
      attrs = {};
      for (var j = 0; j < stack.length; j += 1) {
        if (stack[j] === attributes2) {
          stack.splice(j--, 1);
        } else {
          attrs = Object.assign({}, attrs, stack[j]);
        }
      }
    }
    start3 = offset3;
  }
  return res;
};
var flatten2 = function flatten3(runs) {
  if (runs === void 0) {
    runs = [];
  }
  var emptyRuns = flattenEmptyRuns(runs.filter(function(run) {
    return isEmpty(run);
  }));
  var regularRuns = flattenRegularRuns(runs.filter(function(run) {
    return !isEmpty(run);
  }));
  return sort(emptyRuns.concat(regularRuns));
};
var empty2 = function empty3() {
  return {
    string: "",
    runs: []
  };
};
var omitFont = function omitFont2(attributedString) {
  var runs = attributedString.runs.map(function(run) {
    return omit3("font", run);
  });
  return Object.assign({}, attributedString, {
    runs
  });
};
var preprocessRuns = function preprocessRuns2(engines2, options) {
  return function(attributedString) {
    if (isNil(attributedString))
      return empty2();
    var string = attributedString.string;
    var fontSubstitution3 = engines2.fontSubstitution, scriptItemizer3 = engines2.scriptItemizer;
    var _omitFont = omitFont(attributedString), omittedFontRuns = _omitFont.runs;
    var _fontSubstitution = fontSubstitution3(options)(attributedString), substitutedRuns = _fontSubstitution.runs;
    var _scriptItemizer = scriptItemizer3(options)(attributedString), itemizationRuns = _scriptItemizer.runs;
    var runs = substitutedRuns.concat(itemizationRuns).concat(omittedFontRuns);
    return {
      string,
      runs: flatten2(runs)
    };
  };
};
var start = function start2(attributedString) {
  var runs = attributedString.runs;
  return runs.length === 0 ? 0 : runs[0].start;
};
var end = function end2(attributedString) {
  var runs = attributedString.runs;
  return runs.length === 0 ? 0 : last(runs).end;
};
var length$1 = function length(attributedString) {
  return end(attributedString) - start(attributedString);
};
var splitParagraphs = function splitParagraphs2() {
  return function(attributedString) {
    var res = [];
    var start3 = 0;
    var breakPoint = attributedString.string.indexOf("\n") + 1;
    while (breakPoint > 0) {
      res.push(slice7(start3, breakPoint, attributedString));
      start3 = breakPoint;
      breakPoint = attributedString.string.indexOf("\n", breakPoint) + 1;
    }
    if (start3 === 0) {
      res.push(attributedString);
    } else if (start3 < attributedString.string.length) {
      res.push(slice7(start3, length$1(attributedString), attributedString));
    }
    return res;
  };
};
var advanceWidth$2 = function advanceWidth(positions) {
  return positions.reduce(function(acc, pos) {
    return acc + (pos.xAdvance || 0);
  }, 0);
};
var advanceWidth$1 = function advanceWidth2(run) {
  return advanceWidth$2(run.positions || []);
};
var advanceWidth3 = function advanceWidth4(attributeString) {
  var reducer = function reducer2(acc, run) {
    return acc + advanceWidth$1(run);
  };
  return attributeString.runs.reduce(reducer, 0);
};
var WHITE_SPACES_CODE = 32;
var isWhiteSpace = function isWhiteSpace2(glyph) {
  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];
  return codePoints.includes(WHITE_SPACES_CODE);
};
var leadingPositions = function leadingPositions2(run) {
  var glyphs = run.glyphs || [];
  var positions = run.positions || [];
  var leadingWhitespaces = glyphs.findIndex(function(g3) {
    return !isWhiteSpace(g3);
  });
  return positions.slice(0, leadingWhitespaces);
};
var leadingOffset$1 = function leadingOffset(run) {
  var positions = leadingPositions(run);
  return positions.reduce(function(acc, pos) {
    return acc + (pos.xAdvance || 0);
  }, 0);
};
var leadingOffset2 = function leadingOffset3(attributedString) {
  var runs = attributedString.runs || [];
  return leadingOffset$1(runs[0]);
};
var reverse3 = function reverse4(array) {
  return [].concat(array).reverse();
};
var trailingPositions = function trailingPositions2(run) {
  var glyphs = reverse3(run.glyphs || []);
  var positions = reverse3(run.positions || []);
  var leadingWhitespaces = glyphs.findIndex(function(g3) {
    return !isWhiteSpace(g3);
  });
  return positions.slice(0, leadingWhitespaces);
};
var trailingOffset$1 = function trailingOffset(run) {
  var positions = trailingPositions(run);
  return positions.reduce(function(acc, pos) {
    return acc + (pos.xAdvance || 0);
  }, 0);
};
var trailingOffset2 = function trailingOffset3(attributedString) {
  var runs = attributedString.runs || [];
  return trailingOffset$1(last(runs));
};
var dropLast$1 = function dropLast3(run) {
  return slice$13(0, run.end - run.start - 1, run);
};
var dropLast4 = function dropLast5(attributeString) {
  var string = dropLast(attributeString.string);
  var runs = adjust(-1, dropLast$1, attributeString.runs);
  return Object.assign({}, attributeString, {
    string,
    runs
  });
};
var ALIGNMENT_FACTORS = {
  center: 0.5,
  right: 1
};
var removeNewLine = function removeNewLine2(line2) {
  return last(line2.string) === "\n" ? dropLast4(line2) : line2;
};
var getOverflowLeft = function getOverflowLeft2(line2) {
  return leadingOffset2(line2) + (line2.overflowLeft || 0);
};
var getOverflowRight = function getOverflowRight2(line2) {
  return trailingOffset2(line2) + (line2.overflowRight || 0);
};
var adjustOverflow = function adjustOverflow2(line2) {
  var overflowLeft = getOverflowLeft(line2);
  var overflowRight = getOverflowRight(line2);
  var x = line2.box.x - overflowLeft;
  var width = line2.box.width + overflowLeft + overflowRight;
  var box = Object.assign({}, line2.box, {
    x,
    width
  });
  return Object.assign({}, line2, {
    box,
    overflowLeft,
    overflowRight
  });
};
var justifyLine$1 = function justifyLine(engines2, options, align) {
  return function(line2) {
    var lineWidth2 = advanceWidth3(line2);
    var alignFactor = ALIGNMENT_FACTORS[align] || 0;
    var remainingWidth = Math.max(0, line2.box.width - lineWidth2);
    var shouldJustify = align === "justify" || lineWidth2 > line2.box.width;
    var x = line2.box.x + remainingWidth * alignFactor;
    var box = Object.assign({}, line2.box, {
      x
    });
    var newLine = Object.assign({}, line2, {
      box
    });
    return shouldJustify ? engines2.justification(options)(newLine) : newLine;
  };
};
var finalizeLine = function finalizeLine2(line2) {
  var lineAscent = 0;
  var lineDescent = 0;
  var lineHeight = 0;
  var lineXAdvance = 0;
  var runs = line2.runs.map(function(run) {
    var height5 = height$1(run);
    var ascent4 = ascent$1(run);
    var descent$1 = descent(run);
    var xAdvance = advanceWidth$1(run);
    lineHeight = Math.max(lineHeight, height5);
    lineAscent = Math.max(lineAscent, ascent4);
    lineDescent = Math.max(lineDescent, descent$1);
    lineXAdvance += xAdvance;
    return Object.assign({}, run, {
      height: height5,
      ascent: ascent4,
      descent: descent$1,
      xAdvance
    });
  });
  return Object.assign({}, line2, {
    runs,
    height: lineHeight,
    ascent: lineAscent,
    descent: lineDescent,
    xAdvance: lineXAdvance
  });
};
var finalizeBlock = function finalizeBlock2(engines2, options) {
  if (engines2 === void 0) {
    engines2 = {};
  }
  return function(line2, i, lines) {
    var _line$runs, _line$runs$;
    var isLastFragment = i === lines.length - 1;
    var style = ((_line$runs = line2.runs) === null || _line$runs === void 0 ? void 0 : (_line$runs$ = _line$runs[0]) === null || _line$runs$ === void 0 ? void 0 : _line$runs$.attributes) || {};
    var align = isLastFragment ? style.alignLastLine : style.align;
    return compose(finalizeLine, engines2.textDecoration(options), justifyLine$1(engines2, options, align), adjustOverflow, removeNewLine)(line2);
  };
};
var finalizeFragments = function finalizeFragments2(engines2, options) {
  return function(blocks) {
    var blockFinalizer = finalizeBlock(engines2, options);
    return blocks.map(function(block) {
      return block.map(blockFinalizer);
    });
  };
};
var ATTACHMENT_CODE = 65532;
var isReplaceGlyph = function isReplaceGlyph2(glyph) {
  return glyph.codePoints.includes(ATTACHMENT_CODE);
};
var resolveRunAttachments = function resolveRunAttachments2(run) {
  var _run$attributes;
  if (!run.positions)
    return run;
  var glyphs = run.glyphs || [];
  var attachment = ((_run$attributes = run.attributes) === null || _run$attributes === void 0 ? void 0 : _run$attributes.attachment) || {};
  var positions = run.positions.map(function(position, i) {
    var glyph = glyphs[i];
    if (attachment && attachment.width && isReplaceGlyph(glyph)) {
      return Object.assign({}, position, {
        xAdvance: attachment.width
      });
    }
    return Object.assign({}, position);
  });
  return Object.assign({}, run, {
    positions
  });
};
var resolveAttachments = function resolveAttachments2() {
  return function(attributedString) {
    var runs = attributedString.runs.map(resolveRunAttachments);
    return Object.assign({}, attributedString, {
      runs
    });
  };
};
var applyAttributes = function applyAttributes2(a2) {
  return {
    align: a2.align || "left",
    alignLastLine: a2.alignLastLine || (a2.align === "justify" ? "left" : a2.align || "left"),
    attachment: a2.attachment || null,
    backgroundColor: a2.backgroundColor || null,
    bidiLevel: a2.bidiLevel || null,
    bullet: a2.bullet || null,
    characterSpacing: a2.characterSpacing || 0,
    color: a2.color || "black",
    features: a2.features || [],
    fill: a2.fill !== false,
    font: a2.font || null,
    fontSize: a2.fontSize || 12,
    hangingPunctuation: a2.hangingPunctuation || false,
    hyphenationFactor: a2.hyphenationFactor || 0,
    indent: a2.indent || 0,
    justificationFactor: a2.justificationFactor || 1,
    lineHeight: a2.lineHeight || null,
    lineSpacing: a2.lineSpacing || 0,
    link: a2.link || null,
    marginLeft: a2.marginLeft || a2.margin || 0,
    marginRight: a2.marginRight || a2.margin || 0,
    opacity: a2.opacity,
    paddingTop: a2.paddingTop || a2.padding || 0,
    paragraphSpacing: a2.paragraphSpacing || 0,
    underline: a2.underline || false,
    underlineColor: a2.underlineColor || a2.color || "black",
    underlineStyle: a2.underlineStyle || "solid",
    script: a2.script || null,
    shrinkFactor: a2.shrinkFactor || 0,
    strike: a2.strike || false,
    strikeColor: a2.strikeColor || a2.color || "black",
    strikeStyle: a2.strikeStyle || "solid",
    stroke: a2.stroke || false,
    verticalAlign: a2.verticalAlign || null,
    wordSpacing: a2.wordSpacing || 0,
    yOffset: a2.yOffset || 0
  };
};
var applyRunStyles = function applyRunStyles2(run) {
  var attributes2 = applyAttributes(run.attributes);
  return Object.assign({}, run, {
    attributes: attributes2
  });
};
var applyDefaultStyles = function applyDefaultStyles2() {
  return function(attributedString) {
    var string = attributedString.string || "";
    var runs = (attributedString.runs || []).map(applyRunStyles);
    return {
      string,
      runs
    };
  };
};
var verticalAlignment = function verticalAlignment2() {
  return function(attributedString) {
    attributedString.runs.forEach(function(run) {
      var attributes2 = run.attributes;
      var verticalAlign = attributes2.verticalAlign;
      if (verticalAlign === "sub") {
        attributes2.yOffset = -0.2;
      } else if (verticalAlign === "super") {
        attributes2.yOffset = 0.4;
      }
    });
    return attributedString;
  };
};
var layoutEngine = function layoutEngine2(engines2) {
  return function(attributedString, container, options) {
    if (options === void 0) {
      options = {};
    }
    var processParagraph = compose(resolveYOffset(), resolveAttachments(), generateGlyphs(), verticalAlignment(), wrapWords(engines2, options));
    var processParagraphs = function processParagraphs2(paragraphs) {
      return paragraphs.map(processParagraph);
    };
    return compose(finalizeFragments(engines2, options), typesetter(engines2, options, container), processParagraphs, splitParagraphs(), preprocessRuns(engines2, options), applyDefaultStyles())(attributedString);
  };
};
var INFINITY = 1e4;
var getNextBreakpoint = function getNextBreakpoint2(subnodes, widths, lineNumber) {
  var position = null;
  var minimumBadness = Infinity;
  var sum = {
    width: 0,
    stretch: 0,
    shrink: 0
  };
  var lineLength = widths[Math.min(lineNumber, widths.length - 1)];
  var calculateRatio = function calculateRatio2(node2) {
    if (sum.width < lineLength) {
      return sum.stretch - node2.stretch > 0 ? (lineLength - sum.width) / sum.stretch : INFINITY;
    }
    if (sum.width > lineLength) {
      return sum.shrink - node2.shrink > 0 ? (lineLength - sum.width) / sum.shrink : INFINITY;
    }
    return 0;
  };
  for (var i = 0; i < subnodes.length; i += 1) {
    var node = subnodes[i];
    if (node.type === "box") {
      sum.width += node.width;
    } else if (node.type === "glue") {
      sum.width += node.width;
      sum.stretch += node.stretch;
      sum.shrink += node.shrink;
    }
    if (sum.width - sum.shrink > lineLength) {
      if (position === null) {
        var j = i === 0 ? i + 1 : i;
        while (j < subnodes.length && (subnodes[j].type === "glue" || subnodes[j].type === "penalty")) {
          j++;
        }
        position = j - 1;
      }
      break;
    }
    if (node.type === "penalty" || node.type === "glue") {
      var ratio = calculateRatio(node);
      var penalty = node.type === "penalty" ? node.penalty : 0;
      var badness = 100 * Math.pow(Math.abs(ratio), 3) + penalty;
      if (minimumBadness >= badness) {
        position = i;
        minimumBadness = badness;
      }
    }
  }
  return sum.width - sum.shrink > lineLength ? position : null;
};
var applyBestFit = function applyBestFit2(nodes, widths) {
  var count = 0;
  var lineNumber = 0;
  var subnodes = nodes;
  var breakpoints = [{
    position: 0
  }];
  while (subnodes.length > 0) {
    var breakpoint = getNextBreakpoint(subnodes, widths, lineNumber);
    if (breakpoint !== null) {
      count += breakpoint;
      breakpoints.push({
        position: count
      });
      subnodes = subnodes.slice(breakpoint + 1, subnodes.length);
      count++;
      lineNumber++;
    } else {
      subnodes = [];
    }
  }
  return breakpoints;
};
var Node = function() {
  function Node2(data2) {
    this.prev = null;
    this.next = null;
    this.data = data2;
  }
  var _proto = Node2.prototype;
  _proto.toString = function toString7() {
    return this.data.toString();
  };
  return Node2;
}();
var LinkedList = function() {
  function LinkedList2() {
    this.head = null;
    this.tail = null;
    this.listSize = 0;
  }
  var _proto2 = LinkedList2.prototype;
  _proto2.isLinked = function isLinked(node) {
    return !(node && node.prev === null && node.next === null && this.tail !== node && this.head !== node || this.isEmpty());
  };
  _proto2.size = function size() {
    return this.listSize;
  };
  _proto2.isEmpty = function isEmpty3() {
    return this.listSize === 0;
  };
  _proto2.first = function first() {
    return this.head;
  };
  _proto2.last = function last3() {
    return this.last;
  };
  _proto2.toString = function toString7() {
    return this.toArray().toString();
  };
  _proto2.toArray = function toArray() {
    var node = this.head;
    var result = [];
    while (node !== null) {
      result.push(node);
      node = node.next;
    }
    return result;
  };
  _proto2.forEach = function forEach5(fun) {
    var node = this.head;
    while (node !== null) {
      fun(node);
      node = node.next;
    }
  };
  _proto2.contains = function contains(n) {
    var node = this.head;
    if (!this.isLinked(n)) {
      return false;
    }
    while (node !== null) {
      if (node === n) {
        return true;
      }
      node = node.next;
    }
    return false;
  };
  _proto2.at = function at(i) {
    var node = this.head;
    var index3 = 0;
    if (i >= this.listLength || i < 0) {
      return null;
    }
    while (node !== null) {
      if (i === index3) {
        return node;
      }
      node = node.next;
      index3 += 1;
    }
    return null;
  };
  _proto2.insertAfter = function insertAfter(node, newNode) {
    if (!this.isLinked(node)) {
      return this;
    }
    newNode.prev = node;
    newNode.next = node.next;
    if (node.next === null) {
      this.tail = newNode;
    } else {
      node.next.prev = newNode;
    }
    node.next = newNode;
    this.listSize += 1;
    return this;
  };
  _proto2.insertBefore = function insertBefore(node, newNode) {
    if (!this.isLinked(node)) {
      return this;
    }
    newNode.prev = node.prev;
    newNode.next = node;
    if (node.prev === null) {
      this.head = newNode;
    } else {
      node.prev.next = newNode;
    }
    node.prev = newNode;
    this.listSize += 1;
    return this;
  };
  _proto2.push = function push(node) {
    if (this.head === null) {
      this.unshift(node);
    } else {
      this.insertAfter(this.tail, node);
    }
    return this;
  };
  _proto2.unshift = function unshift(node) {
    if (this.head === null) {
      this.head = node;
      this.tail = node;
      node.prev = null;
      node.next = null;
      this.listSize += 1;
    } else {
      this.insertBefore(this.head, node);
    }
    return this;
  };
  _proto2.remove = function remove(node) {
    if (!this.isLinked(node)) {
      return this;
    }
    if (node.prev === null) {
      this.head = node.next;
    } else {
      node.prev.next = node.next;
    }
    if (node.next === null) {
      this.tail = node.prev;
    } else {
      node.next.prev = node.prev;
    }
    this.listSize -= 1;
    return this;
  };
  _proto2.pop = function pop() {
    var node = this.tail;
    this.tail.prev.next = null;
    this.tail = this.tail.prev;
    this.listSize -= 1;
    node.prev = null;
    node.next = null;
    return node;
  };
  _proto2.shift = function shift() {
    var node = this.head;
    this.head.next.prev = null;
    this.head = this.head.next;
    this.listSize -= 1;
    node.prev = null;
    node.next = null;
    return node;
  };
  return LinkedList2;
}();
LinkedList.Node = Node;
var linebreak = function linebreak2(nodes, lines, settings) {
  var options = {
    demerits: {
      line: settings && settings.demerits && settings.demerits.line || 10,
      flagged: settings && settings.demerits && settings.demerits.flagged || 100,
      fitness: settings && settings.demerits && settings.demerits.fitness || 3e3
    },
    tolerance: settings && settings.tolerance || 3
  };
  var activeNodes = new LinkedList();
  var sum = {
    width: 0,
    stretch: 0,
    shrink: 0
  };
  var lineLengths = lines;
  var breaks = [];
  var tmp = {
    data: {
      demerits: Infinity
    }
  };
  function breakpoint(position, demerits, ratio, line2, fitnessClass, totals, previous) {
    return {
      position,
      demerits,
      ratio,
      line: line2,
      fitnessClass,
      totals: totals || {
        width: 0,
        stretch: 0,
        shrink: 0
      },
      previous
    };
  }
  function computeCost(start3, end3, active, currentLine) {
    var width = sum.width - active.totals.width;
    var stretch = 0;
    var shrink = 0;
    var lineLength = currentLine < lineLengths.length ? lineLengths[currentLine - 1] : lineLengths[lineLengths.length - 1];
    if (nodes[end3].type === "penalty") {
      width += nodes[end3].width;
    }
    if (width < lineLength) {
      stretch = sum.stretch - active.totals.stretch;
      if (stretch > 0) {
        return (lineLength - width) / stretch;
      }
      return linebreak2.infinity;
    }
    if (width > lineLength) {
      shrink = sum.shrink - active.totals.shrink;
      if (shrink > 0) {
        return (lineLength - width) / shrink;
      }
      return linebreak2.infinity;
    }
    return 0;
  }
  function computeSum(breakPointIndex) {
    var result = {
      width: sum.width,
      stretch: sum.stretch,
      shrink: sum.shrink
    };
    for (var i = breakPointIndex; i < nodes.length; i += 1) {
      if (nodes[i].type === "glue") {
        result.width += nodes[i].width;
        result.stretch += nodes[i].stretch;
        result.shrink += nodes[i].shrink;
      } else if (nodes[i].type === "box" || nodes[i].type === "penalty" && nodes[i].penalty === -linebreak2.infinity && i > breakPointIndex) {
        break;
      }
    }
    return result;
  }
  function mainLoop(node, index3, nodes2) {
    var active = activeNodes.first();
    var next2 = null;
    var ratio = 0;
    var demerits = 0;
    var candidates = [];
    var badness;
    var currentLine = 0;
    var tmpSum;
    var currentClass = 0;
    var fitnessClass;
    var candidate;
    var newNode;
    while (active !== null) {
      candidates = [{
        demerits: Infinity
      }, {
        demerits: Infinity
      }, {
        demerits: Infinity
      }, {
        demerits: Infinity
      }];
      while (active !== null) {
        next2 = active.next;
        currentLine = active.data.line + 1;
        ratio = computeCost(active.data.position, index3, active.data, currentLine);
        if (ratio < -1 || node.type === "penalty" && node.penalty === -linebreak2.infinity) {
          activeNodes.remove(active);
        }
        if (ratio >= -1 && ratio <= options.tolerance) {
          badness = 100 * Math.pow(Math.abs(ratio), 3);
          if (node.type === "penalty" && node.penalty >= 0) {
            demerits = Math.pow(options.demerits.line + badness, 2) + Math.pow(node.penalty, 2);
          } else if (node.type === "penalty" && node.penalty !== -linebreak2.infinity) {
            demerits = Math.pow(options.demerits.line + badness, 2) - Math.pow(node.penalty, 2);
          } else {
            demerits = Math.pow(options.demerits.line + badness, 2);
          }
          if (node.type === "penalty" && nodes2[active.data.position].type === "penalty") {
            demerits += options.demerits.flagged * node.flagged * nodes2[active.data.position].flagged;
          }
          if (ratio < -0.5) {
            currentClass = 0;
          } else if (ratio <= 0.5) {
            currentClass = 1;
          } else if (ratio <= 1) {
            currentClass = 2;
          } else {
            currentClass = 3;
          }
          if (Math.abs(currentClass - active.data.fitnessClass) > 1) {
            demerits += options.demerits.fitness;
          }
          demerits += active.data.demerits;
          if (demerits < candidates[currentClass].demerits) {
            candidates[currentClass] = {
              active,
              demerits,
              ratio
            };
          }
        }
        active = next2;
        if (active !== null && active.data.line >= currentLine) {
          break;
        }
      }
      tmpSum = computeSum(index3);
      for (fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {
        candidate = candidates[fitnessClass];
        if (candidate.demerits < Infinity) {
          newNode = new LinkedList.Node(breakpoint(index3, candidate.demerits, candidate.ratio, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));
          if (active !== null) {
            activeNodes.insertBefore(active, newNode);
          } else {
            activeNodes.push(newNode);
          }
        }
      }
    }
  }
  activeNodes.push(new LinkedList.Node(breakpoint(0, 0, 0, 0, 0, void 0, null)));
  nodes.forEach(function(node, index3, nodes2) {
    if (node.type === "box") {
      sum.width += node.width;
    } else if (node.type === "glue") {
      if (index3 > 0 && nodes2[index3 - 1].type === "box") {
        mainLoop(node, index3, nodes2);
      }
      sum.width += node.width;
      sum.stretch += node.stretch;
      sum.shrink += node.shrink;
    } else if (node.type === "penalty" && node.penalty !== linebreak2.infinity) {
      mainLoop(node, index3, nodes2);
    }
  });
  if (activeNodes.size() !== 0) {
    activeNodes.forEach(function(node) {
      if (node.data.demerits < tmp.data.demerits) {
        tmp = node;
      }
    });
    while (tmp !== null) {
      breaks.push({
        position: tmp.data.position,
        ratio: tmp.data.ratio
      });
      tmp = tmp.data.previous;
    }
    return breaks.reverse();
  }
  return [];
};
linebreak.infinity = 1e4;
linebreak.glue = function(width, value2, stretch, shrink) {
  return {
    type: "glue",
    value: value2,
    width,
    stretch,
    shrink
  };
};
linebreak.box = function(width, value2, hyphenated) {
  if (hyphenated === void 0) {
    hyphenated = false;
  }
  return {
    type: "box",
    width,
    value: value2,
    hyphenated
  };
};
linebreak.penalty = function(width, penalty, flagged) {
  return {
    type: "penalty",
    width,
    penalty,
    flagged
  };
};
var add = function add2(n, run) {
  var start3 = run.start + n;
  var end3 = run.end + n;
  return Object.assign({}, run, {
    start: start3,
    end: end3
  });
};
var length2 = function length3(run) {
  return run.end - run.start;
};
var concat5 = function concat6(runA, runB) {
  var end3 = runA.end + length2(runB);
  var glyphs = (runA.glyphs || []).concat(runB.glyphs || []);
  var positions = (runA.positions || []).concat(runB.positions || []);
  var attributes2 = Object.assign({}, runA.attributes, runB.attributes);
  var runAIndices = runA.glyphIndices || [];
  var runALastIndex = last(runAIndices) || 0;
  var runBIndices = (runB.glyphIndices || []).map(function(i) {
    return i + runALastIndex + 1;
  });
  var glyphIndices = normalize4(runAIndices.concat(runBIndices));
  return Object.assign({}, runA, {
    end: end3,
    glyphs,
    positions,
    attributes: attributes2,
    glyphIndices
  });
};
var insertGlyph$1 = function insertGlyph(index3, glyph, run) {
  if (!glyph)
    return run;
  var leadingRun = slice$13(0, index3, run);
  var trailingRun = slice$13(index3, Infinity, run);
  return concat5(append$1(glyph, leadingRun), trailingRun);
};
var insert = function insert2(index3, value2, run) {
  var font2 = getFont(run);
  var glyph = isNumber(value2) ? fromCodePoint(value2, font2) : value2;
  return insertGlyph$1(index3, glyph, run);
};
var runIndexAt2 = function runIndexAt3(n, string) {
  return runIndexAt$1(n, string.runs);
};
var insertGlyph2 = function insertGlyph3(index3, glyph, attributedString) {
  var runIndex = runIndexAt2(index3, attributedString);
  if (runIndex === -1)
    return append2(glyph, attributedString);
  var codePoints = (glyph === null || glyph === void 0 ? void 0 : glyph.codePoints) || [];
  var string = attributedString.string.slice(0, index3) + stringFromCodePoints(codePoints) + attributedString.string.slice(index3);
  var runs = attributedString.runs.map(function(run, i) {
    if (i === runIndex)
      return insert(index3 - run.start, glyph, run);
    if (i > runIndex)
      return add(codePoints.length, run);
    return run;
  });
  return Object.assign({}, attributedString, {
    string,
    runs
  });
};
var advanceWidthBetween$1 = function advanceWidthBetween(start3, end3, run) {
  var runStart = run.start || 0;
  var glyphStartIndex = Math.max(0, glyphIndexAt(start3 - runStart, run));
  var glyphEndIndex = Math.max(0, glyphIndexAt(end3 - runStart, run));
  var positions = (run.positions || []).slice(glyphStartIndex, glyphEndIndex);
  return advanceWidth$2(positions);
};
var advanceWidthBetween2 = function advanceWidthBetween3(start3, end3, attributedString) {
  var runs = filter(start3, end3, attributedString.runs);
  return runs.reduce(function(acc, run) {
    return acc + advanceWidthBetween$1(start3, end3, run);
  }, 0);
};
var HYPHEN = 45;
var TOLERANCE_STEPS = 5;
var TOLERANCE_LIMIT = 50;
var opts = {
  width: 3,
  stretch: 6,
  shrink: 9
};
var breakLines = function breakLines2(string, nodes, breaks) {
  var start3 = 0;
  var end3 = null;
  var lines = breaks.reduce(function(acc, breakPoint) {
    var node = nodes[breakPoint.position];
    var prevNode = nodes[breakPoint.position - 1];
    if (breakPoint.position === nodes.length - 1)
      return acc;
    var line2;
    if (node.type === "penalty") {
      end3 = prevNode.value.end;
      line2 = slice7(start3, end3, string);
      line2 = insertGlyph2(line2.length, HYPHEN, line2);
    } else {
      end3 = node.value.end;
      line2 = slice7(start3, end3, string);
    }
    start3 = end3;
    return [].concat(acc, [line2]);
  }, []);
  lines.push(slice7(start3, string.string.length, string));
  return lines;
};
var getNodes = function getNodes2(attributedString, _ref, options) {
  var align = _ref.align;
  var start3 = 0;
  var hyphenWidth = 5;
  var syllables = attributedString.syllables;
  var hyphenPenalty = options.hyphenationPenalty || (align === "justify" ? 100 : 600);
  var result = syllables.reduce(function(acc, s2, index3) {
    var width = advanceWidthBetween2(start3, start3 + s2.length, attributedString);
    if (s2.trim() === "") {
      var stretch = width * opts.width / opts.stretch;
      var shrink = width * opts.width / opts.shrink;
      var value2 = {
        start: start3,
        end: start3 + s2.length
      };
      acc.push(linebreak.glue(width, value2, stretch, shrink));
    } else {
      var hyphenated = syllables[index3 + 1] !== " ";
      var _value = {
        start: start3,
        end: start3 + s2.length
      };
      acc.push(linebreak.box(width, _value, hyphenated));
      if (syllables[index3 + 1] && hyphenated) {
        acc.push(linebreak.penalty(hyphenWidth, hyphenPenalty, 1));
      }
    }
    start3 += s2.length;
    return acc;
  }, []);
  result.push(linebreak.glue(0, null, linebreak.infinity, 0));
  result.push(linebreak.penalty(0, -linebreak.infinity, 1));
  return result;
};
var getStyles = function getStyles2(attributedString) {
  var _attributedString$run, _attributedString$run2;
  return ((_attributedString$run = attributedString.runs) === null || _attributedString$run === void 0 ? void 0 : (_attributedString$run2 = _attributedString$run[0]) === null || _attributedString$run2 === void 0 ? void 0 : _attributedString$run2.attributes) || {};
};
var linebreaker = function linebreaker2(options) {
  return function(attributedString, availableWidths) {
    var tolerance = options.tolerance || 4;
    var style = getStyles(attributedString);
    var nodes = getNodes(attributedString, style, options);
    var breaks = linebreak(nodes, availableWidths, {
      tolerance
    });
    while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {
      tolerance += TOLERANCE_STEPS;
      breaks = linebreak(nodes, availableWidths, {
        tolerance
      });
    }
    if (breaks.length === 0 || breaks.length === 1 && breaks[0].position === 0) {
      breaks = applyBestFit(nodes, availableWidths);
    }
    return breakLines(attributedString, nodes, breaks.slice(1));
  };
};
var WHITESPACE_PRIORITY = 1;
var LETTER_PRIORITY = 2;
var EXPAND_WHITESPACE_FACTOR = {
  before: 0.5,
  after: 0.5,
  priority: WHITESPACE_PRIORITY,
  unconstrained: false
};
var EXPAND_CHAR_FACTOR = {
  before: 0.14453125,
  // 37/256
  after: 0.14453125,
  priority: LETTER_PRIORITY,
  unconstrained: false
};
var SHRINK_WHITESPACE_FACTOR = {
  before: -0.04296875,
  // -11/256
  after: -0.04296875,
  priority: WHITESPACE_PRIORITY,
  unconstrained: false
};
var SHRINK_CHAR_FACTOR = {
  before: -0.04296875,
  after: -0.04296875,
  priority: LETTER_PRIORITY,
  unconstrained: false
};
var getCharFactor = function getCharFactor2(direction, options) {
  var expandCharFactor = options.expandCharFactor || {};
  var shrinkCharFactor = options.shrinkCharFactor || {};
  return direction === "GROW" ? Object.assign({}, EXPAND_CHAR_FACTOR, expandCharFactor) : Object.assign({}, SHRINK_CHAR_FACTOR, shrinkCharFactor);
};
var getWhitespaceFactor = function getWhitespaceFactor2(direction, options) {
  var expandWhitespaceFactor = options.expandWhitespaceFactor || {};
  var shrinkWhitespaceFactor2 = options.shrinkWhitespaceFactor || {};
  return direction === "GROW" ? Object.assign({}, EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor) : Object.assign({}, SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor2);
};
var factor = function factor2(direction, options) {
  return function(glyphs) {
    var charFactor = getCharFactor(direction, options);
    var whitespaceFactor = getWhitespaceFactor(direction, options);
    var factors = [];
    for (var index3 = 0; index3 < glyphs.length; index3 += 1) {
      var f = void 0;
      var glyph = glyphs[index3];
      if (isWhiteSpace(glyph)) {
        f = Object.assign({}, whitespaceFactor);
        if (index3 === glyphs.length - 1) {
          f.before = 0;
          if (index3 > 0) {
            factors[index3 - 1].after = 0;
          }
        }
      } else if (glyph.isMark && index3 > 0) {
        f = Object.assign({}, factors[index3 - 1]);
        f.before = 0;
        factors[index3 - 1].after = 0;
      } else {
        f = Object.assign({}, charFactor);
      }
      factors.push(f);
    }
    return factors;
  };
};
var getFactors = function getFactors2(gap, line2, options) {
  var direction = gap > 0 ? "GROW" : "SHRINK";
  var getFactor = factor(direction, options);
  var factors = line2.runs.reduce(function(acc, run) {
    return acc.concat(getFactor(run.glyphs));
  }, []);
  factors[0].before = 0;
  factors[factors.length - 1].after = 0;
  return factors;
};
var KASHIDA_PRIORITY = 0;
var NULL_PRIORITY = 3;
var getDistances = function getDistances2(gap, factors) {
  var total = 0;
  var priorities = [];
  var unconstrained = [];
  for (var _priority = KASHIDA_PRIORITY; _priority <= NULL_PRIORITY; _priority += 1) {
    priorities[_priority] = unconstrained[_priority] = 0;
  }
  for (var j = 0; j < factors.length; j += 1) {
    var f = factors[j];
    var sum = f.before + f.after;
    total += sum;
    priorities[f.priority] += sum;
    if (f.unconstrained) {
      unconstrained[f.priority] += sum;
    }
  }
  var highestPriority = -1;
  var highestPrioritySum = 0;
  var remainingGap = gap;
  var priority;
  for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {
    var prioritySum = priorities[priority];
    if (prioritySum !== 0) {
      if (highestPriority === -1) {
        highestPriority = priority;
        highestPrioritySum = prioritySum;
      }
      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {
        priorities[priority] = remainingGap / prioritySum;
        unconstrained[priority] = 0;
        remainingGap = 0;
        break;
      }
      priorities[priority] = 1;
      remainingGap -= prioritySum;
      if (unconstrained[priority] !== 0) {
        unconstrained[priority] = remainingGap / unconstrained[priority];
        remainingGap = 0;
        break;
      }
    }
  }
  for (var p = priority + 1; p <= NULL_PRIORITY; p += 1) {
    priorities[p] = 0;
    unconstrained[p] = 0;
  }
  if (remainingGap > 0 && highestPriority > -1) {
    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;
  }
  var distances = [];
  for (var index3 = 0; index3 < factors.length; index3 += 1) {
    var _f = factors[index3];
    var next2 = factors[index3 + 1];
    var dist = _f.after * priorities[_f.priority];
    if (next2) {
      dist += next2.before * priorities[next2.priority];
    }
    if (_f.unconstrained) {
      dist += _f.after * unconstrained[_f.priority];
      if (next2) {
        dist += next2.before * unconstrained[next2.priority];
      }
    }
    distances.push(dist);
  }
  return distances;
};
var justifyLine2 = function justifyLine3(distances, line2) {
  var index3 = 0;
  for (var _iterator = _createForOfIteratorHelperLoose2(line2.runs), _step; !(_step = _iterator()).done; ) {
    var run = _step.value;
    for (var _iterator2 = _createForOfIteratorHelperLoose2(run.positions), _step2; !(_step2 = _iterator2()).done; ) {
      var position = _step2.value;
      position.xAdvance += distances[index3++];
    }
  }
  return line2;
};
var justification = function justification2(options) {
  return function(line2) {
    var gap = line2.box.width - advanceWidth3(line2);
    if (gap === 0)
      return;
    var factors = getFactors(gap, line2, options);
    var distances = getDistances(gap, factors);
    return justifyLine2(distances, line2);
  };
};
var ascent2 = function ascent3(attributeString) {
  var reducer = function reducer2(acc, run) {
    return Math.max(acc, ascent$1(run));
  };
  return attributeString.runs.reduce(reducer, 0);
};
var BASE_FONT_SIZE = 12;
var textDecoration = function textDecoration2() {
  return function(lineFragment) {
    var x = lineFragment.overflowLeft || 0;
    var overflowRight = lineFragment.overflowRight || 0;
    var maxX = advanceWidth3(lineFragment) - overflowRight;
    lineFragment.decorationLines = [];
    for (var i = 0; i < lineFragment.runs.length; i += 1) {
      var run = lineFragment.runs[i];
      var width = Math.min(maxX - x, advanceWidth$1(run));
      var thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));
      if (run.attributes.underline) {
        var rect2 = {
          x,
          y: ascent2(lineFragment) + thickness * 2,
          width,
          height: thickness
        };
        var line2 = {
          rect: rect2,
          opacity: run.attributes.opacity,
          color: run.attributes.underlineColor || "black",
          style: run.attributes.underlineStyle || "solid"
        };
        lineFragment.decorationLines.push(line2);
      }
      if (run.attributes.strike) {
        var y = ascent2(lineFragment) - ascent$1(run) / 3;
        var _rect = {
          x,
          y,
          width,
          height: thickness
        };
        var _line2 = {
          rect: _rect,
          opacity: run.attributes.opacity,
          color: run.attributes.strikeColor || "black",
          style: run.attributes.strikeStyle || "solid"
        };
        lineFragment.decorationLines.push(_line2);
      }
      x += width;
    }
    return lineFragment;
  };
};
var ignoredScripts = ["Common", "Inherited", "Unknown"];
var scriptItemizer = function scriptItemizer2() {
  return function(attributedString) {
    var string = attributedString.string;
    var lastScript = "Unknown";
    var lastIndex = 0;
    var index3 = 0;
    var res = [];
    if (!string)
      return empty2();
    for (var i = 0; i < string.length; i += 1) {
      var char = string[i];
      var codePoint = char.codePointAt();
      var script = $747425b437e121da$export$2e2bcd8739ae039.getScript(codePoint);
      if (script !== lastScript && !ignoredScripts.includes(script)) {
        if (lastScript !== "Unknown") {
          res.push({
            start: lastIndex,
            end: index3,
            attributes: {
              script: lastScript
            }
          });
        }
        lastIndex = index3;
        lastScript = script;
      }
      index3 += char.length;
    }
    if (lastIndex < string.length) {
      res.push({
        start: lastIndex,
        end: string.length,
        attributes: {
          script: lastScript
        }
      });
    }
    return {
      string,
      runs: res
    };
  };
};
var SOFT_HYPHEN = "­";
var hyphenator = (0, import_hyphen.default)(import_en_us.default);
var splitHyphen = function splitHyphen2(word) {
  return word.split(SOFT_HYPHEN);
};
var cache = {};
var getParts = function getParts2(word) {
  var base = word.includes(SOFT_HYPHEN) ? word : hyphenator(word);
  return splitHyphen(base);
};
var wordHyphenation = function wordHyphenation2() {
  return function(word) {
    var cacheKey = "_" + word;
    if (isNil(word))
      return [];
    if (cache[cacheKey])
      return cache[cacheKey];
    cache[cacheKey] = getParts(word);
    return cache[cacheKey];
  };
};

// ../node_modules/@react-pdf/layout/node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof7(obj) {
  "@babel/helpers - typeof";
  return _typeof7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof7(obj);
}

// ../node_modules/@react-pdf/layout/node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function _toPrimitive2(input, hint) {
  if (_typeof7(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof7(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

// ../node_modules/@react-pdf/layout/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function _toPropertyKey2(arg) {
  var key = _toPrimitive2(arg, "string");
  return _typeof7(key) === "symbol" ? key : String(key);
}

// ../node_modules/@react-pdf/layout/node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties4(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey2(descriptor.key), descriptor);
  }
}
function _createClass4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties4(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

// ../node_modules/@react-pdf/layout/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js
function _regeneratorRuntime4() {
  "use strict";
  _regeneratorRuntime4 = function _regeneratorRuntime6() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn3 = Op.hasOwnProperty, defineProperty5 = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define4(obj, key, value2) {
    return Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define4({}, "");
  } catch (err2) {
    define4 = function define5(obj, key, value2) {
      return obj[key] = value2;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty5(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err2) {
      return {
        type: "throw",
        arg: err2
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction3() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define4(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto3 = Object.getPrototypeOf, NativeIteratorPrototype = getProto3 && getProto3(getProto3(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn3.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define4(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve3, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value2 = result.value;
        return value2 && "object" == _typeof7(value2) && hasOwn3.call(value2, "__await") ? PromiseImpl.resolve(value2.__await).then(function(value3) {
          invoke("next", value3, resolve3, reject);
        }, function(err2) {
          invoke("throw", err2, resolve3, reject);
        }) : PromiseImpl.resolve(value2).then(function(unwrapped) {
          result.value = unwrapped, resolve3(result);
        }, function(error) {
          return invoke("throw", error, resolve3, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty5(this, "_invoke", {
      value: function value2(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve3, reject) {
            invoke(method, arg, resolve3, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state2 = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state2)
        throw new Error("Generator is already running");
      if ("completed" === state2) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state2)
            throw state2 = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state2 = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state2 = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state2 = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next2 = function next3() {
          for (; ++i < iterable.length; )
            if (hasOwn3.call(iterable, i))
              return next3.value = iterable[i], next3.done = false, next3;
          return next3.value = void 0, next3.done = true, next3;
        };
        return next2.next = next2;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction3.prototype = GeneratorFunctionPrototype, defineProperty5(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty5(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction3,
    configurable: true
  }), GeneratorFunction3.displayName = define4(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction3 || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define4(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define4(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define4(Gp, toStringTagSymbol, "Generator"), define4(Gp, iteratorSymbol, function() {
    return this;
  }), define4(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys5 = [];
    for (var key in object)
      keys5.push(key);
    return keys5.reverse(), function next2() {
      for (; keys5.length; ) {
        var key2 = keys5.pop();
        if (key2 in object)
          return next2.value = key2, next2.done = false, next2;
      }
      return next2.done = true, next2;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn3.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function stop() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn3.call(entry, "catchLoc"), hasFinally = hasOwn3.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn3.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}

// ../node_modules/@react-pdf/layout/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep4(gen, resolve3, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value2 = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve3(value2);
  } else {
    Promise.resolve(value2).then(_next, _throw);
  }
}
function _asyncToGenerator4(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve3, reject) {
      var gen = fn.apply(self2, args);
      function _next(value2) {
        asyncGeneratorStep4(gen, resolve3, reject, _next, _throw, "next", value2);
      }
      function _throw(err2) {
        asyncGeneratorStep4(gen, resolve3, reject, _next, _throw, "throw", err2);
      }
      _next(void 0);
    });
  };
}

// ../node_modules/@react-pdf/layout/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends7() {
  _extends7 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends7.apply(this, arguments);
}

// ../node_modules/@react-pdf/layout/node_modules/emoji-regex/index.mjs
var emoji_regex_default = () => {
  return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC08\uDC26](?:\u200D\u2B1B)?|[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
};

// ../node_modules/@react-pdf/image/node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof8(obj) {
  "@babel/helpers - typeof";
  return _typeof8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof8(obj);
}

// ../node_modules/@react-pdf/image/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js
function _regeneratorRuntime5() {
  "use strict";
  _regeneratorRuntime5 = function _regeneratorRuntime6() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn3 = Op.hasOwnProperty, defineProperty5 = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define4(obj, key, value2) {
    return Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define4({}, "");
  } catch (err2) {
    define4 = function define5(obj, key, value2) {
      return obj[key] = value2;
    };
  }
  function wrap(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
    return defineProperty5(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err2) {
      return {
        type: "throw",
        arg: err2
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction3() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define4(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto3 = Object.getPrototypeOf, NativeIteratorPrototype = getProto3 && getProto3(getProto3(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn3.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define4(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve3, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value2 = result.value;
        return value2 && "object" == _typeof8(value2) && hasOwn3.call(value2, "__await") ? PromiseImpl.resolve(value2.__await).then(function(value3) {
          invoke("next", value3, resolve3, reject);
        }, function(err2) {
          invoke("throw", err2, resolve3, reject);
        }) : PromiseImpl.resolve(value2).then(function(unwrapped) {
          result.value = unwrapped, resolve3(result);
        }, function(error) {
          return invoke("throw", error, resolve3, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty5(this, "_invoke", {
      value: function value2(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve3, reject) {
            invoke(method, arg, resolve3, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state2 = "suspendedStart";
    return function(method, arg) {
      if ("executing" === state2)
        throw new Error("Generator is already running");
      if ("completed" === state2) {
        if ("throw" === method)
          throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state2)
            throw state2 = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state2 = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state2 = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state2 = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method = delegate.iterator[methodName];
    if (void 0 === method)
      return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next2 = function next3() {
          for (; ++i < iterable.length; )
            if (hasOwn3.call(iterable, i))
              return next3.value = iterable[i], next3.done = false, next3;
          return next3.value = void 0, next3.done = true, next3;
        };
        return next2.next = next2;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction3.prototype = GeneratorFunctionPrototype, defineProperty5(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty5(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction3,
    configurable: true
  }), GeneratorFunction3.displayName = define4(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction3 || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define4(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define4(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define4(Gp, toStringTagSymbol, "Generator"), define4(Gp, iteratorSymbol, function() {
    return this;
  }), define4(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object = Object(val), keys5 = [];
    for (var key in object)
      keys5.push(key);
    return keys5.reverse(), function next2() {
      for (; keys5.length; ) {
        var key2 = keys5.pop();
        if (key2 in object)
          return next2.value = key2, next2.done = false, next2;
      }
      return next2.done = true, next2;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name in this)
          "t" === name.charAt(0) && hasOwn3.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
    },
    stop: function stop() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn3.call(entry, "catchLoc"), hasFinally = hasOwn3.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn3.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}

// ../node_modules/@react-pdf/image/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep5(gen, resolve3, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value2 = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve3(value2);
  } else {
    Promise.resolve(value2).then(_next, _throw);
  }
}
function _asyncToGenerator5(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve3, reject) {
      var gen = fn.apply(self2, args);
      function _next(value2) {
        asyncGeneratorStep5(gen, resolve3, reject, _next, _throw, "next", value2);
      }
      function _throw(err2) {
        asyncGeneratorStep5(gen, resolve3, reject, _next, _throw, "throw", err2);
      }
      _next(void 0);
    });
  };
}

// ../node_modules/@react-pdf/image/lib/index.browser.es.js
var import_cross_fetch2 = __toESM(require_browser_ponyfill());
var global$13 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup3 = [];
var revLookup3 = [];
var Arr3 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited3 = false;
function init3() {
  inited3 = true;
  var code3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code3.length; i < len; ++i) {
    lookup3[i] = code3[i];
    revLookup3[code3.charCodeAt(i)] = i;
  }
  revLookup3["-".charCodeAt(0)] = 62;
  revLookup3["_".charCodeAt(0)] = 63;
}
function toByteArray3(b64) {
  if (!inited3) {
    init3();
  }
  var i, j, l2, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr3(len * 3 / 4 - placeHolders);
  l2 = placeHolders > 0 ? len - 4 : len;
  var L2 = 0;
  for (i = 0, j = 0; i < l2; i += 4, j += 3) {
    tmp = revLookup3[b64.charCodeAt(i)] << 18 | revLookup3[b64.charCodeAt(i + 1)] << 12 | revLookup3[b64.charCodeAt(i + 2)] << 6 | revLookup3[b64.charCodeAt(i + 3)];
    arr[L2++] = tmp >> 16 & 255;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup3[b64.charCodeAt(i)] << 2 | revLookup3[b64.charCodeAt(i + 1)] >> 4;
    arr[L2++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup3[b64.charCodeAt(i)] << 10 | revLookup3[b64.charCodeAt(i + 1)] << 4 | revLookup3[b64.charCodeAt(i + 2)] >> 2;
    arr[L2++] = tmp >> 8 & 255;
    arr[L2++] = tmp & 255;
  }
  return arr;
}
function tripletToBase643(num) {
  return lookup3[num >> 18 & 63] + lookup3[num >> 12 & 63] + lookup3[num >> 6 & 63] + lookup3[num & 63];
}
function encodeChunk3(uint82, start3, end3) {
  var tmp;
  var output = [];
  for (var i = start3; i < end3; i += 3) {
    tmp = (uint82[i] << 16) + (uint82[i + 1] << 8) + uint82[i + 2];
    output.push(tripletToBase643(tmp));
  }
  return output.join("");
}
function fromByteArray3(uint82) {
  if (!inited3) {
    init3();
  }
  var tmp;
  var len = uint82.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk3(uint82, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint82[len - 1];
    output += lookup3[tmp >> 2];
    output += lookup3[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint82[len - 2] << 8) + uint82[len - 1];
    output += lookup3[tmp >> 10];
    output += lookup3[tmp >> 4 & 63];
    output += lookup3[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read3(buffer3, offset3, isLE, mLen, nBytes) {
  var e, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s2 = buffer3[offset3 + i];
  i += d;
  e = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer3[offset3 + i], i += d, nBits -= 8) {
  }
  m2 = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer3[offset3 + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e - mLen);
}
function write5(buffer3, value2, offset3, isLE, mLen, nBytes) {
  var e, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m2 = isNaN(value2) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c2 = Math.pow(2, -e)) < 1) {
      e--;
      c2 *= 2;
    }
    if (e + eBias >= 1) {
      value2 += rt / c2;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c2 >= 2) {
      e++;
      c2 /= 2;
    }
    if (e + eBias >= eMax) {
      m2 = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m2 = (value2 * c2 - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer3[offset3 + i] = m2 & 255, i += d, m2 /= 256, mLen -= 8) {
  }
  e = e << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer3[offset3 + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer3[offset3 + i - d] |= s2 * 128;
}
var toString5 = {}.toString;
var isArray3 = Array.isArray || function(arr) {
  return toString5.call(arr) == "[object Array]";
};
var INSPECT_MAX_BYTES3 = 50;
Buffer4.TYPED_ARRAY_SUPPORT = global$13.TYPED_ARRAY_SUPPORT !== void 0 ? global$13.TYPED_ARRAY_SUPPORT : true;
function kMaxLength3() {
  return Buffer4.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer3(that, length4) {
  if (kMaxLength3() < length4) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length4);
    that.__proto__ = Buffer4.prototype;
  } else {
    if (that === null) {
      that = new Buffer4(length4);
    }
    that.length = length4;
  }
  return that;
}
function Buffer4(arg, encodingOrOffset, length4) {
  if (!Buffer4.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer4)) {
    return new Buffer4(arg, encodingOrOffset, length4);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe3(this, arg);
  }
  return from3(this, arg, encodingOrOffset, length4);
}
Buffer4.poolSize = 8192;
Buffer4._augment = function(arr) {
  arr.__proto__ = Buffer4.prototype;
  return arr;
};
function from3(that, value2, encodingOrOffset, length4) {
  if (typeof value2 === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
    return fromArrayBuffer3(that, value2, encodingOrOffset, length4);
  }
  if (typeof value2 === "string") {
    return fromString3(that, value2, encodingOrOffset);
  }
  return fromObject3(that, value2);
}
Buffer4.from = function(value2, encodingOrOffset, length4) {
  return from3(null, value2, encodingOrOffset, length4);
};
if (Buffer4.TYPED_ARRAY_SUPPORT) {
  Buffer4.prototype.__proto__ = Uint8Array.prototype;
  Buffer4.__proto__ = Uint8Array;
}
function assertSize3(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc3(that, size, fill5, encoding) {
  assertSize3(size);
  if (size <= 0) {
    return createBuffer3(that, size);
  }
  if (fill5 !== void 0) {
    return typeof encoding === "string" ? createBuffer3(that, size).fill(fill5, encoding) : createBuffer3(that, size).fill(fill5);
  }
  return createBuffer3(that, size);
}
Buffer4.alloc = function(size, fill5, encoding) {
  return alloc3(null, size, fill5, encoding);
};
function allocUnsafe3(that, size) {
  assertSize3(size);
  that = createBuffer3(that, size < 0 ? 0 : checked3(size) | 0);
  if (!Buffer4.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
Buffer4.allocUnsafe = function(size) {
  return allocUnsafe3(null, size);
};
Buffer4.allocUnsafeSlow = function(size) {
  return allocUnsafe3(null, size);
};
function fromString3(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer4.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length4 = byteLength4(string, encoding) | 0;
  that = createBuffer3(that, length4);
  var actual = that.write(string, encoding);
  if (actual !== length4) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike3(that, array) {
  var length4 = array.length < 0 ? 0 : checked3(array.length) | 0;
  that = createBuffer3(that, length4);
  for (var i = 0; i < length4; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer3(that, array, byteOffset, length4) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length4 || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length4 === void 0) {
    array = new Uint8Array(array);
  } else if (length4 === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length4);
  }
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer4.prototype;
  } else {
    that = fromArrayLike3(that, array);
  }
  return that;
}
function fromObject3(that, obj) {
  if (internalIsBuffer3(obj)) {
    var len = checked3(obj.length) | 0;
    that = createBuffer3(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan3(obj.length)) {
        return createBuffer3(that, 0);
      }
      return fromArrayLike3(that, obj);
    }
    if (obj.type === "Buffer" && isArray3(obj.data)) {
      return fromArrayLike3(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked3(length4) {
  if (length4 >= kMaxLength3()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength3().toString(16) + " bytes");
  }
  return length4 | 0;
}
Buffer4.isBuffer = isBuffer5;
function internalIsBuffer3(b) {
  return !!(b != null && b._isBuffer);
}
Buffer4.compare = function compare7(a2, b) {
  if (!internalIsBuffer3(a2) || !internalIsBuffer3(b)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a2 === b)
    return 0;
  var x = a2.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a2[i] !== b[i]) {
      x = a2[i];
      y = b[i];
      break;
    }
  }
  if (x < y)
    return -1;
  if (y < x)
    return 1;
  return 0;
};
Buffer4.isEncoding = function isEncoding5(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer4.concat = function concat7(list, length4) {
  if (!isArray3(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer4.alloc(0);
  }
  var i;
  if (length4 === void 0) {
    length4 = 0;
    for (i = 0; i < list.length; ++i) {
      length4 += list[i].length;
    }
  }
  var buffer3 = Buffer4.allocUnsafe(length4);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer3(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer3, pos);
    pos += buf.length;
  }
  return buffer3;
};
function byteLength4(string, encoding) {
  if (internalIsBuffer3(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes3(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes3(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes3(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer4.byteLength = byteLength4;
function slowToString3(encoding, start3, end3) {
  var loweredCase = false;
  if (start3 === void 0 || start3 < 0) {
    start3 = 0;
  }
  if (start3 > this.length) {
    return "";
  }
  if (end3 === void 0 || end3 > this.length) {
    end3 = this.length;
  }
  if (end3 <= 0) {
    return "";
  }
  end3 >>>= 0;
  start3 >>>= 0;
  if (end3 <= start3) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice3(this, start3, end3);
      case "utf8":
      case "utf-8":
        return utf8Slice3(this, start3, end3);
      case "ascii":
        return asciiSlice3(this, start3, end3);
      case "latin1":
      case "binary":
        return latin1Slice3(this, start3, end3);
      case "base64":
        return base64Slice3(this, start3, end3);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice3(this, start3, end3);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer4.prototype._isBuffer = true;
function swap3(b, n, m2) {
  var i = b[n];
  b[n] = b[m2];
  b[m2] = i;
}
Buffer4.prototype.swap16 = function swap163() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i = 0; i < len; i += 2) {
    swap3(this, i, i + 1);
  }
  return this;
};
Buffer4.prototype.swap32 = function swap323() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i = 0; i < len; i += 4) {
    swap3(this, i, i + 3);
    swap3(this, i + 1, i + 2);
  }
  return this;
};
Buffer4.prototype.swap64 = function swap643() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i = 0; i < len; i += 8) {
    swap3(this, i, i + 7);
    swap3(this, i + 1, i + 6);
    swap3(this, i + 2, i + 5);
    swap3(this, i + 3, i + 4);
  }
  return this;
};
Buffer4.prototype.toString = function toString6() {
  var length4 = this.length | 0;
  if (length4 === 0)
    return "";
  if (arguments.length === 0)
    return utf8Slice3(this, 0, length4);
  return slowToString3.apply(this, arguments);
};
Buffer4.prototype.equals = function equals3(b) {
  if (!internalIsBuffer3(b))
    throw new TypeError("Argument must be a Buffer");
  if (this === b)
    return true;
  return Buffer4.compare(this, b) === 0;
};
Buffer4.prototype.inspect = function inspect5() {
  var str = "";
  var max3 = INSPECT_MAX_BYTES3;
  if (this.length > 0) {
    str = this.toString("hex", 0, max3).match(/.{2}/g).join(" ");
    if (this.length > max3)
      str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer4.prototype.compare = function compare8(target, start3, end3, thisStart, thisEnd) {
  if (!internalIsBuffer3(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start3 === void 0) {
    start3 = 0;
  }
  if (end3 === void 0) {
    end3 = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start3 < 0 || end3 > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start3 >= end3) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start3 >= end3) {
    return 1;
  }
  start3 >>>= 0;
  end3 >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target)
    return 0;
  var x = thisEnd - thisStart;
  var y = end3 - start3;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start3, end3);
  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }
  if (x < y)
    return -1;
  if (y < x)
    return 1;
  return 0;
};
function bidirectionalIndexOf3(buffer3, val, byteOffset, encoding, dir) {
  if (buffer3.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer3.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer3.length + byteOffset;
  if (byteOffset >= buffer3.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer3.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer4.from(val, encoding);
  }
  if (internalIsBuffer3(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf3(buffer3, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer4.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer3, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer3, val, byteOffset);
      }
    }
    return arrayIndexOf3(buffer3, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf3(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read4(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read4(arr, i) === read4(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read4(arr, i + j) !== read4(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
}
Buffer4.prototype.includes = function includes5(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer4.prototype.indexOf = function indexOf7(val, byteOffset, encoding) {
  return bidirectionalIndexOf3(this, val, byteOffset, encoding, true);
};
Buffer4.prototype.lastIndexOf = function lastIndexOf3(val, byteOffset, encoding) {
  return bidirectionalIndexOf3(this, val, byteOffset, encoding, false);
};
function hexWrite3(buf, string, offset3, length4) {
  offset3 = Number(offset3) || 0;
  var remaining = buf.length - offset3;
  if (!length4) {
    length4 = remaining;
  } else {
    length4 = Number(length4);
    if (length4 > remaining) {
      length4 = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length4 > strLen / 2) {
    length4 = strLen / 2;
  }
  for (var i = 0; i < length4; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset3 + i] = parsed;
  }
  return i;
}
function utf8Write3(buf, string, offset3, length4) {
  return blitBuffer3(utf8ToBytes3(string, buf.length - offset3), buf, offset3, length4);
}
function asciiWrite3(buf, string, offset3, length4) {
  return blitBuffer3(asciiToBytes3(string), buf, offset3, length4);
}
function latin1Write3(buf, string, offset3, length4) {
  return asciiWrite3(buf, string, offset3, length4);
}
function base64Write3(buf, string, offset3, length4) {
  return blitBuffer3(base64ToBytes3(string), buf, offset3, length4);
}
function ucs2Write3(buf, string, offset3, length4) {
  return blitBuffer3(utf16leToBytes3(string, buf.length - offset3), buf, offset3, length4);
}
Buffer4.prototype.write = function write6(string, offset3, length4, encoding) {
  if (offset3 === void 0) {
    encoding = "utf8";
    length4 = this.length;
    offset3 = 0;
  } else if (length4 === void 0 && typeof offset3 === "string") {
    encoding = offset3;
    length4 = this.length;
    offset3 = 0;
  } else if (isFinite(offset3)) {
    offset3 = offset3 | 0;
    if (isFinite(length4)) {
      length4 = length4 | 0;
      if (encoding === void 0)
        encoding = "utf8";
    } else {
      encoding = length4;
      length4 = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset3;
  if (length4 === void 0 || length4 > remaining)
    length4 = remaining;
  if (string.length > 0 && (length4 < 0 || offset3 < 0) || offset3 > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding)
    encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite3(this, string, offset3, length4);
      case "utf8":
      case "utf-8":
        return utf8Write3(this, string, offset3, length4);
      case "ascii":
        return asciiWrite3(this, string, offset3, length4);
      case "latin1":
      case "binary":
        return latin1Write3(this, string, offset3, length4);
      case "base64":
        return base64Write3(this, string, offset3, length4);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write3(this, string, offset3, length4);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer4.prototype.toJSON = function toJSON3() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice3(buf, start3, end3) {
  if (start3 === 0 && end3 === buf.length) {
    return fromByteArray3(buf);
  } else {
    return fromByteArray3(buf.slice(start3, end3));
  }
}
function utf8Slice3(buf, start3, end3) {
  end3 = Math.min(buf.length, end3);
  var res = [];
  var i = start3;
  while (i < end3) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end3) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray3(res);
}
var MAX_ARGUMENTS_LENGTH3 = 4096;
function decodeCodePointsArray3(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH3) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH3)
    );
  }
  return res;
}
function asciiSlice3(buf, start3, end3) {
  var ret = "";
  end3 = Math.min(buf.length, end3);
  for (var i = start3; i < end3; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice3(buf, start3, end3) {
  var ret = "";
  end3 = Math.min(buf.length, end3);
  for (var i = start3; i < end3; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice3(buf, start3, end3) {
  var len = buf.length;
  if (!start3 || start3 < 0)
    start3 = 0;
  if (!end3 || end3 < 0 || end3 > len)
    end3 = len;
  var out = "";
  for (var i = start3; i < end3; ++i) {
    out += toHex4(buf[i]);
  }
  return out;
}
function utf16leSlice3(buf, start3, end3) {
  var bytes = buf.slice(start3, end3);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
Buffer4.prototype.slice = function slice9(start3, end3) {
  var len = this.length;
  start3 = ~~start3;
  end3 = end3 === void 0 ? len : ~~end3;
  if (start3 < 0) {
    start3 += len;
    if (start3 < 0)
      start3 = 0;
  } else if (start3 > len) {
    start3 = len;
  }
  if (end3 < 0) {
    end3 += len;
    if (end3 < 0)
      end3 = 0;
  } else if (end3 > len) {
    end3 = len;
  }
  if (end3 < start3)
    end3 = start3;
  var newBuf;
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start3, end3);
    newBuf.__proto__ = Buffer4.prototype;
  } else {
    var sliceLen = end3 - start3;
    newBuf = new Buffer4(sliceLen, void 0);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start3];
    }
  }
  return newBuf;
};
function checkOffset3(offset3, ext, length4) {
  if (offset3 % 1 !== 0 || offset3 < 0)
    throw new RangeError("offset is not uint");
  if (offset3 + ext > length4)
    throw new RangeError("Trying to access beyond buffer length");
}
Buffer4.prototype.readUIntLE = function readUIntLE3(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert)
    checkOffset3(offset3, byteLength5, this.length);
  var val = this[offset3];
  var mul = 1;
  var i = 0;
  while (++i < byteLength5 && (mul *= 256)) {
    val += this[offset3 + i] * mul;
  }
  return val;
};
Buffer4.prototype.readUIntBE = function readUIntBE3(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    checkOffset3(offset3, byteLength5, this.length);
  }
  var val = this[offset3 + --byteLength5];
  var mul = 1;
  while (byteLength5 > 0 && (mul *= 256)) {
    val += this[offset3 + --byteLength5] * mul;
  }
  return val;
};
Buffer4.prototype.readUInt8 = function readUInt83(offset3, noAssert) {
  if (!noAssert)
    checkOffset3(offset3, 1, this.length);
  return this[offset3];
};
Buffer4.prototype.readUInt16LE = function readUInt16LE3(offset3, noAssert) {
  if (!noAssert)
    checkOffset3(offset3, 2, this.length);
  return this[offset3] | this[offset3 + 1] << 8;
};
Buffer4.prototype.readUInt16BE = function readUInt16BE3(offset3, noAssert) {
  if (!noAssert)
    checkOffset3(offset3, 2, this.length);
  return this[offset3] << 8 | this[offset3 + 1];
};
Buffer4.prototype.readUInt32LE = function readUInt32LE3(offset3, noAssert) {
  if (!noAssert)
    checkOffset3(offset3, 4, this.length);
  return (this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16) + this[offset3 + 3] * 16777216;
};
Buffer4.prototype.readUInt32BE = function readUInt32BE3(offset3, noAssert) {
  if (!noAssert)
    checkOffset3(offset3, 4, this.length);
  return this[offset3] * 16777216 + (this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3]);
};
Buffer4.prototype.readIntLE = function readIntLE3(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert)
    checkOffset3(offset3, byteLength5, this.length);
  var val = this[offset3];
  var mul = 1;
  var i = 0;
  while (++i < byteLength5 && (mul *= 256)) {
    val += this[offset3 + i] * mul;
  }
  mul *= 128;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer4.prototype.readIntBE = function readIntBE3(offset3, byteLength5, noAssert) {
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert)
    checkOffset3(offset3, byteLength5, this.length);
  var i = byteLength5;
  var mul = 1;
  var val = this[offset3 + --i];
  while (i > 0 && (mul *= 256)) {
    val += this[offset3 + --i] * mul;
  }
  mul *= 128;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength5);
  return val;
};
Buffer4.prototype.readInt8 = function readInt83(offset3, noAssert) {
  if (!noAssert)
    checkOffset3(offset3, 1, this.length);
  if (!(this[offset3] & 128))
    return this[offset3];
  return (255 - this[offset3] + 1) * -1;
};
Buffer4.prototype.readInt16LE = function readInt16LE3(offset3, noAssert) {
  if (!noAssert)
    checkOffset3(offset3, 2, this.length);
  var val = this[offset3] | this[offset3 + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer4.prototype.readInt16BE = function readInt16BE3(offset3, noAssert) {
  if (!noAssert)
    checkOffset3(offset3, 2, this.length);
  var val = this[offset3 + 1] | this[offset3] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer4.prototype.readInt32LE = function readInt32LE3(offset3, noAssert) {
  if (!noAssert)
    checkOffset3(offset3, 4, this.length);
  return this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16 | this[offset3 + 3] << 24;
};
Buffer4.prototype.readInt32BE = function readInt32BE3(offset3, noAssert) {
  if (!noAssert)
    checkOffset3(offset3, 4, this.length);
  return this[offset3] << 24 | this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3];
};
Buffer4.prototype.readFloatLE = function readFloatLE3(offset3, noAssert) {
  if (!noAssert)
    checkOffset3(offset3, 4, this.length);
  return read3(this, offset3, true, 23, 4);
};
Buffer4.prototype.readFloatBE = function readFloatBE3(offset3, noAssert) {
  if (!noAssert)
    checkOffset3(offset3, 4, this.length);
  return read3(this, offset3, false, 23, 4);
};
Buffer4.prototype.readDoubleLE = function readDoubleLE3(offset3, noAssert) {
  if (!noAssert)
    checkOffset3(offset3, 8, this.length);
  return read3(this, offset3, true, 52, 8);
};
Buffer4.prototype.readDoubleBE = function readDoubleBE3(offset3, noAssert) {
  if (!noAssert)
    checkOffset3(offset3, 8, this.length);
  return read3(this, offset3, false, 52, 8);
};
function checkInt3(buf, value2, offset3, ext, max3, min3) {
  if (!internalIsBuffer3(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value2 > max3 || value2 < min3)
    throw new RangeError('"value" argument is out of bounds');
  if (offset3 + ext > buf.length)
    throw new RangeError("Index out of range");
}
Buffer4.prototype.writeUIntLE = function writeUIntLE3(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt3(this, value2, offset3, byteLength5, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset3] = value2 & 255;
  while (++i < byteLength5 && (mul *= 256)) {
    this[offset3 + i] = value2 / mul & 255;
  }
  return offset3 + byteLength5;
};
Buffer4.prototype.writeUIntBE = function writeUIntBE3(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  byteLength5 = byteLength5 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength5) - 1;
    checkInt3(this, value2, offset3, byteLength5, maxBytes, 0);
  }
  var i = byteLength5 - 1;
  var mul = 1;
  this[offset3 + i] = value2 & 255;
  while (--i >= 0 && (mul *= 256)) {
    this[offset3 + i] = value2 / mul & 255;
  }
  return offset3 + byteLength5;
};
Buffer4.prototype.writeUInt8 = function writeUInt83(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt3(this, value2, offset3, 1, 255, 0);
  if (!Buffer4.TYPED_ARRAY_SUPPORT)
    value2 = Math.floor(value2);
  this[offset3] = value2 & 255;
  return offset3 + 1;
};
function objectWriteUInt163(buf, value2, offset3, littleEndian) {
  if (value2 < 0)
    value2 = 65535 + value2 + 1;
  for (var i = 0, j = Math.min(buf.length - offset3, 2); i < j; ++i) {
    buf[offset3 + i] = (value2 & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
Buffer4.prototype.writeUInt16LE = function writeUInt16LE3(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt3(this, value2, offset3, 2, 65535, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt163(this, value2, offset3, true);
  }
  return offset3 + 2;
};
Buffer4.prototype.writeUInt16BE = function writeUInt16BE3(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt3(this, value2, offset3, 2, 65535, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 8;
    this[offset3 + 1] = value2 & 255;
  } else {
    objectWriteUInt163(this, value2, offset3, false);
  }
  return offset3 + 2;
};
function objectWriteUInt323(buf, value2, offset3, littleEndian) {
  if (value2 < 0)
    value2 = 4294967295 + value2 + 1;
  for (var i = 0, j = Math.min(buf.length - offset3, 4); i < j; ++i) {
    buf[offset3 + i] = value2 >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
Buffer4.prototype.writeUInt32LE = function writeUInt32LE3(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt3(this, value2, offset3, 4, 4294967295, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset3 + 3] = value2 >>> 24;
    this[offset3 + 2] = value2 >>> 16;
    this[offset3 + 1] = value2 >>> 8;
    this[offset3] = value2 & 255;
  } else {
    objectWriteUInt323(this, value2, offset3, true);
  }
  return offset3 + 4;
};
Buffer4.prototype.writeUInt32BE = function writeUInt32BE3(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt3(this, value2, offset3, 4, 4294967295, 0);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 24;
    this[offset3 + 1] = value2 >>> 16;
    this[offset3 + 2] = value2 >>> 8;
    this[offset3 + 3] = value2 & 255;
  } else {
    objectWriteUInt323(this, value2, offset3, false);
  }
  return offset3 + 4;
};
Buffer4.prototype.writeIntLE = function writeIntLE3(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt3(this, value2, offset3, byteLength5, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset3] = value2 & 255;
  while (++i < byteLength5 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset3 + i - 1] !== 0) {
      sub = 1;
    }
    this[offset3 + i] = (value2 / mul >> 0) - sub & 255;
  }
  return offset3 + byteLength5;
};
Buffer4.prototype.writeIntBE = function writeIntBE3(value2, offset3, byteLength5, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength5 - 1);
    checkInt3(this, value2, offset3, byteLength5, limit - 1, -limit);
  }
  var i = byteLength5 - 1;
  var mul = 1;
  var sub = 0;
  this[offset3 + i] = value2 & 255;
  while (--i >= 0 && (mul *= 256)) {
    if (value2 < 0 && sub === 0 && this[offset3 + i + 1] !== 0) {
      sub = 1;
    }
    this[offset3 + i] = (value2 / mul >> 0) - sub & 255;
  }
  return offset3 + byteLength5;
};
Buffer4.prototype.writeInt8 = function writeInt83(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt3(this, value2, offset3, 1, 127, -128);
  if (!Buffer4.TYPED_ARRAY_SUPPORT)
    value2 = Math.floor(value2);
  if (value2 < 0)
    value2 = 255 + value2 + 1;
  this[offset3] = value2 & 255;
  return offset3 + 1;
};
Buffer4.prototype.writeInt16LE = function writeInt16LE3(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt3(this, value2, offset3, 2, 32767, -32768);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
  } else {
    objectWriteUInt163(this, value2, offset3, true);
  }
  return offset3 + 2;
};
Buffer4.prototype.writeInt16BE = function writeInt16BE3(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt3(this, value2, offset3, 2, 32767, -32768);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 8;
    this[offset3 + 1] = value2 & 255;
  } else {
    objectWriteUInt163(this, value2, offset3, false);
  }
  return offset3 + 2;
};
Buffer4.prototype.writeInt32LE = function writeInt32LE3(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt3(this, value2, offset3, 4, 2147483647, -2147483648);
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 & 255;
    this[offset3 + 1] = value2 >>> 8;
    this[offset3 + 2] = value2 >>> 16;
    this[offset3 + 3] = value2 >>> 24;
  } else {
    objectWriteUInt323(this, value2, offset3, true);
  }
  return offset3 + 4;
};
Buffer4.prototype.writeInt32BE = function writeInt32BE3(value2, offset3, noAssert) {
  value2 = +value2;
  offset3 = offset3 | 0;
  if (!noAssert)
    checkInt3(this, value2, offset3, 4, 2147483647, -2147483648);
  if (value2 < 0)
    value2 = 4294967295 + value2 + 1;
  if (Buffer4.TYPED_ARRAY_SUPPORT) {
    this[offset3] = value2 >>> 24;
    this[offset3 + 1] = value2 >>> 16;
    this[offset3 + 2] = value2 >>> 8;
    this[offset3 + 3] = value2 & 255;
  } else {
    objectWriteUInt323(this, value2, offset3, false);
  }
  return offset3 + 4;
};
function checkIEEE7543(buf, value2, offset3, ext, max3, min3) {
  if (offset3 + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset3 < 0)
    throw new RangeError("Index out of range");
}
function writeFloat3(buf, value2, offset3, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7543(buf, value2, offset3, 4);
  }
  write5(buf, value2, offset3, littleEndian, 23, 4);
  return offset3 + 4;
}
Buffer4.prototype.writeFloatLE = function writeFloatLE3(value2, offset3, noAssert) {
  return writeFloat3(this, value2, offset3, true, noAssert);
};
Buffer4.prototype.writeFloatBE = function writeFloatBE3(value2, offset3, noAssert) {
  return writeFloat3(this, value2, offset3, false, noAssert);
};
function writeDouble3(buf, value2, offset3, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE7543(buf, value2, offset3, 8);
  }
  write5(buf, value2, offset3, littleEndian, 52, 8);
  return offset3 + 8;
}
Buffer4.prototype.writeDoubleLE = function writeDoubleLE3(value2, offset3, noAssert) {
  return writeDouble3(this, value2, offset3, true, noAssert);
};
Buffer4.prototype.writeDoubleBE = function writeDoubleBE3(value2, offset3, noAssert) {
  return writeDouble3(this, value2, offset3, false, noAssert);
};
Buffer4.prototype.copy = function copy5(target, targetStart, start3, end3) {
  if (!start3)
    start3 = 0;
  if (!end3 && end3 !== 0)
    end3 = this.length;
  if (targetStart >= target.length)
    targetStart = target.length;
  if (!targetStart)
    targetStart = 0;
  if (end3 > 0 && end3 < start3)
    end3 = start3;
  if (end3 === start3)
    return 0;
  if (target.length === 0 || this.length === 0)
    return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start3 < 0 || start3 >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (end3 < 0)
    throw new RangeError("sourceEnd out of bounds");
  if (end3 > this.length)
    end3 = this.length;
  if (target.length - targetStart < end3 - start3) {
    end3 = target.length - targetStart + start3;
  }
  var len = end3 - start3;
  var i;
  if (this === target && start3 < targetStart && targetStart < end3) {
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start3];
    }
  } else if (len < 1e3 || !Buffer4.TYPED_ARRAY_SUPPORT) {
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start3];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start3, start3 + len),
      targetStart
    );
  }
  return len;
};
Buffer4.prototype.fill = function fill4(val, start3, end3, encoding) {
  if (typeof val === "string") {
    if (typeof start3 === "string") {
      encoding = start3;
      start3 = 0;
      end3 = this.length;
    } else if (typeof end3 === "string") {
      encoding = end3;
      end3 = this.length;
    }
    if (val.length === 1) {
      var code3 = val.charCodeAt(0);
      if (code3 < 256) {
        val = code3;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start3 < 0 || this.length < start3 || this.length < end3) {
    throw new RangeError("Out of range index");
  }
  if (end3 <= start3) {
    return this;
  }
  start3 = start3 >>> 0;
  end3 = end3 === void 0 ? this.length : end3 >>> 0;
  if (!val)
    val = 0;
  var i;
  if (typeof val === "number") {
    for (i = start3; i < end3; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer3(val) ? val : utf8ToBytes3(new Buffer4(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end3 - start3; ++i) {
      this[i + start3] = bytes[i % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE3 = /[^+\/0-9A-Za-z-_]/g;
function base64clean3(str) {
  str = stringtrim3(str).replace(INVALID_BASE64_RE3, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim3(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex4(n) {
  if (n < 16)
    return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes3(string, units) {
  units = units || Infinity;
  var codePoint;
  var length4 = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length4; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length4) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes3(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes3(str, units) {
  var c2, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0)
      break;
    c2 = str.charCodeAt(i);
    hi = c2 >> 8;
    lo = c2 % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes3(str) {
  return toByteArray3(base64clean3(str));
}
function blitBuffer3(src3, dst, offset3, length4) {
  for (var i = 0; i < length4; ++i) {
    if (i + offset3 >= dst.length || i >= src3.length)
      break;
    dst[i + offset3] = src3[i];
  }
  return i;
}
function isnan3(val) {
  return val !== val;
}
function isBuffer5(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer3(obj) || isSlowBuffer3(obj));
}
function isFastBuffer3(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer3(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer3(obj.slice(0, 0));
}
PNG.isValid = function(data2) {
  try {
    return !!new PNG(data2);
  } catch (e) {
    return false;
  }
};
var MARKERS2 = [65472, 65473, 65474, 65475, 65477, 65478, 65479, 65480, 65481, 65482, 65483, 65484, 65485, 65486, 65487];
var JPEG2 = function JPEG3(data2) {
  this.data = null;
  this.width = null;
  this.height = null;
  this.data = data2;
  if (data2.readUInt16BE(0) !== 65496) {
    throw new Error("SOI not found in JPEG");
  }
  var marker;
  var pos = 2;
  while (pos < data2.length) {
    marker = data2.readUInt16BE(pos);
    pos += 2;
    if (MARKERS2.includes(marker)) {
      break;
    }
    pos += data2.readUInt16BE(pos);
  }
  if (!MARKERS2.includes(marker)) {
    throw new Error("Invalid JPEG.");
  }
  pos += 3;
  this.height = data2.readUInt16BE(pos);
  pos += 2;
  this.width = data2.readUInt16BE(pos);
};
JPEG2.isValid = function(data2) {
  if (!data2 || !Buffer4.isBuffer(data2) || data2.readUInt16BE(0) !== 65496) {
    return false;
  }
  var marker;
  var pos = 2;
  while (pos < data2.length) {
    marker = data2.readUInt16BE(pos);
    pos += 2;
    if (MARKERS2.includes(marker)) {
      break;
    }
    pos += data2.readUInt16BE(pos);
  }
  if (!MARKERS2.includes(marker)) {
    return false;
  }
  return true;
};
var createCache = function createCache2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$limit = _ref.limit, limit = _ref$limit === void 0 ? 100 : _ref$limit;
  var cache2 = {};
  var keys5 = [];
  return {
    get: function get18(key) {
      return cache2[key];
    },
    set: function set7(key, value2) {
      keys5.push(key);
      if (keys5.length > limit) {
        delete cache2[keys5.shift()];
      }
      cache2[key] = value2;
    },
    reset: function reset() {
      cache2 = {};
      keys5 = [];
    },
    length: function length4() {
      return keys5.length;
    }
  };
};
var IMAGE_CACHE = createCache({
  limit: 30
});
var fetchRemoteFile = function() {
  var _ref = _asyncToGenerator5(_regeneratorRuntime5().mark(function _callee(uri, options) {
    var response, buffer3;
    return _regeneratorRuntime5().wrap(function _callee$(_context) {
      while (1)
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return (0, import_cross_fetch2.default)(uri, options);
          case 2:
            response = _context.sent;
            _context.next = 5;
            return response.buffer ? response.buffer() : response.arrayBuffer();
          case 5:
            buffer3 = _context.sent;
            return _context.abrupt("return", buffer3.constructor.name === "Buffer" ? buffer3 : Buffer4.from(buffer3));
          case 7:
          case "end":
            return _context.stop();
        }
    }, _callee);
  }));
  return function fetchRemoteFile2(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
var isValidFormat = function isValidFormat2(format) {
  var lower = format.toLowerCase();
  return lower === "jpg" || lower === "jpeg" || lower === "png";
};
var guessFormat = function guessFormat2(buffer3) {
  var format;
  if (JPEG2.isValid(buffer3)) {
    format = "jpg";
  } else if (PNG.isValid(buffer3)) {
    format = "png";
  }
  return format;
};
var isCompatibleBase64 = function isCompatibleBase642(_ref2) {
  var uri = _ref2.uri;
  return /^data:image\/[a-zA-Z]*;base64,[^"]*/g.test(uri);
};
function getImage(body, extension) {
  switch (extension.toLowerCase()) {
    case "jpg":
    case "jpeg":
      return new JPEG2(body);
    case "png":
      return new PNG(body);
    default:
      return null;
  }
}
var resolveBase64Image = function resolveBase64Image2(_ref3) {
  var uri = _ref3.uri;
  var match = /^data:image\/([a-zA-Z]*);base64,([^"]*)/g.exec(uri);
  var format = match[1];
  var data2 = match[2];
  if (!isValidFormat(format)) {
    throw new Error("Base64 image invalid format: " + format);
  }
  return new Promise(function(resolve3) {
    return resolve3(getImage(Buffer4.from(data2, "base64"), format));
  });
};
var resolveImageFromData = function resolveImageFromData2(src3) {
  if (src3.data && src3.format) {
    return new Promise(function(resolve3) {
      return resolve3(getImage(src3.data, src3.format));
    });
  }
  throw new Error("Invalid data given for local file: " + JSON.stringify(src3));
};
var resolveBufferImage = function resolveBufferImage2(buffer3) {
  var format = guessFormat(buffer3);
  if (format) {
    return new Promise(function(resolve3) {
      return resolve3(getImage(buffer3, format));
    });
  }
  return Promise.resolve();
};
var getImageFormat = function getImageFormat2(body) {
  var isPng = body[0] === 137 && body[1] === 80 && body[2] === 78 && body[3] === 71 && body[4] === 13 && body[5] === 10 && body[6] === 26 && body[7] === 10;
  var isJpg = body[0] === 255 && body[1] === 216 && body[2] === 255;
  var extension = "";
  if (isPng) {
    extension = "png";
  } else if (isJpg) {
    extension = "jpg";
  } else {
    throw new Error("Not valid image extension");
  }
  return extension;
};
var resolveImageFromUrl = function() {
  var _ref4 = _asyncToGenerator5(_regeneratorRuntime5().mark(function _callee2(src3) {
    var uri, body, headers, _src$method, method, data2, extension;
    return _regeneratorRuntime5().wrap(function _callee2$(_context2) {
      while (1)
        switch (_context2.prev = _context2.next) {
          case 0:
            uri = src3.uri, body = src3.body, headers = src3.headers, _src$method = src3.method, method = _src$method === void 0 ? "GET" : _src$method;
            {
              _context2.next = 7;
              break;
            }
          case 4:
            _context2.t0 = _context2.sent;
            _context2.next = 10;
            break;
          case 7:
            _context2.next = 9;
            return fetchRemoteFile(uri, {
              body,
              headers,
              method
            });
          case 9:
            _context2.t0 = _context2.sent;
          case 10:
            data2 = _context2.t0;
            extension = getImageFormat(data2);
            return _context2.abrupt("return", getImage(data2, extension));
          case 13:
          case "end":
            return _context2.stop();
        }
    }, _callee2);
  }));
  return function resolveImageFromUrl2(_x3) {
    return _ref4.apply(this, arguments);
  };
}();
var resolveImage = function resolveImage2(src3, _temp) {
  var _ref5 = _temp === void 0 ? {} : _temp, _ref5$cache = _ref5.cache, cache2 = _ref5$cache === void 0 ? true : _ref5$cache;
  var image2;
  var cacheKey = src3.data ? src3.data.toString() : src3.uri;
  if (Buffer4.isBuffer(src3)) {
    image2 = resolveBufferImage(src3);
  } else if (cache2 && IMAGE_CACHE.get(cacheKey)) {
    return IMAGE_CACHE.get(cacheKey);
  } else if (isCompatibleBase64(src3)) {
    image2 = resolveBase64Image(src3);
  } else if (typeof src3 === "object" && src3.data) {
    image2 = resolveImageFromData(src3);
  } else {
    image2 = resolveImageFromUrl(src3);
  }
  if (!image2) {
    throw new Error("Cannot resolve image");
  }
  if (cache2) {
    IMAGE_CACHE.set(cacheKey, image2);
  }
  return image2;
};

// ../node_modules/@react-pdf/yoga/node_modules/@babel/runtime/helpers/esm/extends.js
function _extends8() {
  _extends8 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends8.apply(this, arguments);
}

// ../node_modules/@react-pdf/yoga/dist/index.esm.js
var E = {};
E.ALIGN_AUTO = 0;
E.ALIGN_FLEX_START = 1;
E.ALIGN_CENTER = 2;
E.ALIGN_FLEX_END = 3;
E.ALIGN_STRETCH = 4;
E.ALIGN_BASELINE = 5;
E.ALIGN_SPACE_BETWEEN = 6;
E.ALIGN_SPACE_AROUND = 7;
E.DIMENSION_WIDTH = 0;
E.DIMENSION_HEIGHT = 1;
E.DIRECTION_INHERIT = 0;
E.DIRECTION_LTR = 1;
E.DIRECTION_RTL = 2;
E.DISPLAY_FLEX = 0;
E.DISPLAY_NONE = 1;
E.EDGE_LEFT = 0;
E.EDGE_TOP = 1;
E.EDGE_RIGHT = 2;
E.EDGE_BOTTOM = 3;
E.EDGE_START = 4;
E.EDGE_END = 5;
E.EDGE_HORIZONTAL = 6;
E.EDGE_VERTICAL = 7;
E.EDGE_ALL = 8;
E.EXPERIMENTAL_FEATURE_WEB_FLEX_BASIS = 0;
E.EXPERIMENTAL_FEATURE_ABSOLUTE_PERCENTAGE_AGAINST_PADDING_EDGE = 1;
E.EXPERIMENTAL_FEATURE_FIX_ABSOLUTE_TRAILING_COLUMN_MARGIN = 2;
E.FLEX_DIRECTION_COLUMN = 0;
E.FLEX_DIRECTION_COLUMN_REVERSE = 1;
E.FLEX_DIRECTION_ROW = 2;
E.FLEX_DIRECTION_ROW_REVERSE = 3;
E.GUTTER_COLUMN = 0;
E.GUTTER_ROW = 1;
E.GUTTER_ALL = 2;
E.JUSTIFY_FLEX_START = 0;
E.JUSTIFY_CENTER = 1;
E.JUSTIFY_FLEX_END = 2;
E.JUSTIFY_SPACE_BETWEEN = 3;
E.JUSTIFY_SPACE_AROUND = 4;
E.JUSTIFY_SPACE_EVENLY = 5;
E.LOG_LEVEL_ERROR = 0;
E.LOG_LEVEL_WARN = 1;
E.LOG_LEVEL_INFO = 2;
E.LOG_LEVEL_DEBUG = 3;
E.LOG_LEVEL_VERBOSE = 4;
E.LOG_LEVEL_FATAL = 5;
E.MEASURE_MODE_UNDEFINED = 0;
E.MEASURE_MODE_EXACTLY = 1;
E.MEASURE_MODE_AT_MOST = 2;
E.NODE_TYPE_DEFAULT = 0;
E.NODE_TYPE_TEXT = 1;
E.OVERFLOW_VISIBLE = 0;
E.OVERFLOW_HIDDEN = 1;
E.OVERFLOW_SCROLL = 2;
E.POSITION_TYPE_STATIC = 0;
E.POSITION_TYPE_RELATIVE = 1;
E.POSITION_TYPE_ABSOLUTE = 2;
E.PRINT_OPTIONS_LAYOUT = 1;
E.PRINT_OPTIONS_STYLE = 2;
E.PRINT_OPTIONS_CHILDREN = 4;
E.UNIT_UNDEFINED = 0;
E.UNIT_POINT = 1;
E.UNIT_PERCENT = 2;
E.UNIT_AUTO = 3;
E.WRAP_NO_WRAP = 0;
E.WRAP_WRAP = 1;
E.WRAP_WRAP_REVERSE = 2;
var rE = E;
var AE = function AE2(E2) {
  function a2(E3, a3, _) {
    var s2 = E3[a3];
    E3[a3] = function() {
      for (var _len = arguments.length, E4 = new Array(_len), _key = 0; _key < _len; _key++) {
        E4[_key] = arguments[_key];
      }
      return _.call.apply(_, [this, s2].concat(E4));
    };
  }
  var _loop = function _loop2() {
    var _s;
    var _ = _arr[_i];
    var s2 = (_s = {}, _s[rE.UNIT_POINT] = E2.Node.prototype[_], _s[rE.UNIT_PERCENT] = E2.Node.prototype[_ + "Percent"], _s[rE.UNIT_AUTO] = E2.Node.prototype[_ + "Auto"], _s);
    a2(E2.Node.prototype, _, function(E3) {
      var _s$t, _s$t2;
      for (var _len2 = arguments.length, a3 = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        a3[_key2 - 1] = arguments[_key2];
      }
      var e = a3.pop();
      var t2, N;
      if ("auto" === e)
        t2 = rE.UNIT_AUTO, N = void 0;
      else if ("object" == typeof e)
        t2 = e.unit, N = e.valueOf();
      else if (t2 = "string" == typeof e && e.endsWith("%") ? rE.UNIT_PERCENT : rE.UNIT_POINT, N = parseFloat(e), !Number.isNaN(e) && Number.isNaN(N))
        throw new Error("Invalid value " + e + " for " + _);
      if (!s2[t2])
        throw new Error('Failed to execute "' + _ + `": Unsupported unit '` + e + "'");
      return void 0 !== N ? (_s$t = s2[t2]).call.apply(_s$t, [this].concat(a3, [N])) : (_s$t2 = s2[t2]).call.apply(_s$t2, [this].concat(a3));
    });
  };
  for (var _i = 0, _arr = ["setPosition", "setMargin", "setFlexBasis", "setWidth", "setHeight", "setMinWidth", "setMinHeight", "setMaxWidth", "setMaxHeight", "setPadding"]; _i < _arr.length; _i++) {
    _loop();
  }
  return a2(E2.Node.prototype, "setMeasureFunc", function(a3, _) {
    return _ ? a3.call(this, (s2 = _, E2.MeasureCallback.implement({
      measure: function measure() {
        var _s2 = s2.apply(void 0, arguments), a4 = _s2.width, _2 = _s2.height;
        return {
          width: a4 != null ? a4 : NaN,
          height: _2 != null ? _2 : NaN
        };
      }
    }))) : this.unsetMeasureFunc();
    var s2;
  }), a2(E2.Node.prototype, "setDirtiedFunc", function(a3, _) {
    var s2;
    a3.call(this, (s2 = _, E2.DirtiedCallback.implement({
      dirtied: s2
    })));
  }), a2(E2.Config.prototype, "free", function() {
    E2.Config.destroy(this);
  }), a2(E2.Node, "create", function(a3, _) {
    return _ ? E2.Node.createWithConfig(_) : E2.Node.createDefault();
  }), a2(E2.Node.prototype, "free", function() {
    E2.Node.destroy(this);
  }), a2(E2.Node.prototype, "freeRecursive", function() {
    for (var _E2 = 0, _a = this.getChildCount(); _E2 < _a; ++_E2)
      this.getChild(0).freeRecursive();
    this.free();
  }), a2(E2.Node.prototype, "calculateLayout", function(E3, a3, _, s2) {
    if (a3 === void 0) {
      a3 = NaN;
    }
    if (_ === void 0) {
      _ = NaN;
    }
    if (s2 === void 0) {
      s2 = rE.DIRECTION_LTR;
    }
    return E3.call(this, a3, _, s2);
  }), _extends8({
    Config: E2.Config,
    Node: E2.Node
  }, rE);
};
var rr;
var er = (rr = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0, function(r) {
  if (r === void 0) {
    r = {};
  }
  var e, a2, i;
  e || (e = void 0 !== r ? r : {}), e.ready = new Promise(function(r2, e2) {
    a2 = r2, i = e2;
  });
  var n = Object.assign({}, e), t2 = "";
  "undefined" != typeof document && document.currentScript && (t2 = document.currentScript.src), rr && (t2 = rr), t2 = 0 !== t2.indexOf("blob:") ? t2.substr(0, t2.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "";
  var f, o = e.print || console.log.bind(console), c2 = e.printErr || console.warn.bind(console);
  function u() {
  }
  function b(r2) {
    this.exports = function(r3) {
      for (var e2, a3 = new Uint8Array(123), i2 = 25; i2 >= 0; --i2)
        a3[48 + i2] = 52 + i2, a3[65 + i2] = i2, a3[97 + i2] = 26 + i2;
      function n2(r4, e3, i3) {
        for (var n3, t4, f3 = 0, o3 = e3, c4 = i3.length, u3 = e3 + (3 * c4 >> 2) - ("=" == i3[c4 - 2]) - ("=" == i3[c4 - 1]); f3 < c4; f3 += 4)
          n3 = a3[i3.charCodeAt(f3 + 1)], t4 = a3[i3.charCodeAt(f3 + 2)], r4[o3++] = a3[i3.charCodeAt(f3)] << 2 | n3 >> 4, o3 < u3 && (r4[o3++] = n3 << 4 | t4 >> 2), o3 < u3 && (r4[o3++] = t4 << 6 | a3[i3.charCodeAt(f3 + 3)]);
      }
      a3[43] = 62, a3[47] = 63;
      var t3 = new ArrayBuffer(16), f2 = new Int32Array(t3), o2 = new Float32Array(t3), c3 = new Float64Array(t3);
      function u2(r4) {
        return f2[r4];
      }
      function b2(r4, e3) {
        f2[r4] = e3;
      }
      function s3() {
        return c3[0];
      }
      function A3(r4) {
        c3[0] = r4;
      }
      function k2() {
        throw new Error("abort");
      }
      function l3(r4) {
        o2[2] = r4;
      }
      function d2() {
        return o2[2];
      }
      return function(r4) {
        var a4 = r4.a, i3 = a4.a, t4 = i3.buffer;
        i3.grow = function(r5) {
          r5 |= 0;
          var a5 = 0 | ia(), n3 = a5 + r5 | 0;
          if (a5 < n3 && n3 < 65536) {
            var u3 = new ArrayBuffer(w2(n3, 65536));
            new Int8Array(u3).set(f3), f3 = new Int8Array(u3), o3 = new Int16Array(u3), c4 = new Int32Array(u3), v3 = new Uint8Array(u3), h3 = new Uint16Array(u3), p2 = new Uint32Array(u3), m3 = new Float32Array(u3), N2 = new Float64Array(u3), t4 = u3, i3.buffer = t4, e2 = v3;
          }
          return a5;
        };
        var f3 = new Int8Array(t4), o3 = new Int16Array(t4), c4 = new Int32Array(t4), v3 = new Uint8Array(t4), h3 = new Uint16Array(t4), p2 = new Uint32Array(t4), m3 = new Float32Array(t4), N2 = new Float64Array(t4), w2 = Math.imul, y2 = Math.fround, E3 = Math.abs, G3 = Math.clz32, R4 = Math.min, g4 = Math.max, Z3 = a4.b, W2 = a4.c, V3 = a4.d, B2 = a4.e, T3 = a4.f, I2 = a4.g, X2 = a4.h, O2 = a4.i, L3 = a4.j, _2 = a4.k, F2 = a4.l, C3 = a4.m, S3 = a4.n, P2 = a4.o, Y2 = a4.p, U2 = a4.q, M3 = a4.r, H3 = a4.s, Q3 = a4.t, z3 = a4.u, j2 = a4.v, D = a4.w, x2 = a4.x, J2 = a4.y, K2 = a4.z, q2 = a4.A, $2 = a4.B, rr2 = a4.C, er3 = a4.D, ar3 = 73632, ir2 = 0;
        function nr2(r5, e3, a5, i4, n3, t5, o4, u3, s4, A4, l4, h4, p3, N3) {
          var w3, G4 = y2(0), R5 = y2(0), g5 = 0, Z4 = 0, W3 = 0, V4 = y2(0), B3 = y2(0), T4 = y2(0), X3 = 0, O3 = 0, L4 = 0, _3 = y2(0), F3 = y2(0), C4 = y2(0), S4 = 0, P3 = y2(0), Y3 = 0, U3 = y2(0), M4 = y2(0), H4 = 0, Q4 = 0, z4 = 0, j3 = 0, D2 = 0, x3 = y2(0), J3 = 0, K3 = y2(0), q3 = 0, $3 = 0, rr3 = 0, er4 = 0, ir3 = y2(0), nr3 = 0, tr3 = 0, fr3 = 0, cr3 = 0, br3 = y2(0), lr3 = 0, dr3 = 0, vr3 = 0, hr3 = y2(0), Nr3 = y2(0), yr3 = 0, Er3 = y2(0), Gr3 = y2(0), Zr3 = y2(0), _r3 = 0, Cr3 = 0, Sr3 = y2(0), Pr3 = 0, Yr3 = y2(0), Hr3 = y2(0), jr3 = y2(0), xr3 = y2(0), Kr3 = 0, qr3 = 0, $r3 = 0, re3 = 0, ee3 = 0, ae3 = 0, ie3 = 0, ne3 = 0, te3 = 0, fe2 = y2(0), oe2 = y2(0);
          ar3 = w3 = ar3 - 384 | 0;
          r: {
            e: {
              a: {
                if (!n3 || e3 == e3) {
                  if (!t5 || a5 == a5) {
                    if (c4[(g5 = (s4 ? 0 : 4) + l4 | 0) >> 2] = c4[g5 >> 2] + 1, Pr3 = (0 | i4) <= 1 ? 1 : i4, J3 = (g5 = 3 & c4[r5 + 24 >> 2]) || Pr3, f3[r5 + 300 | 0] = 252 & v3[r5 + 300 | 0] | 3 & J3, g5 = r5 + 252 | 0, i4 = (1 != (0 | J3)) << 3, B3 = Mr2(r5, lr3 = 2 == (0 | J3) ? 3 : 2, o4), m3[g5 + i4 >> 2] = B3, Z4 = g5, g5 = (1 == (0 | J3)) << 3, F3 = Ur2(r5, lr3, o4), m3[Z4 + g5 >> 2] = F3, _3 = Mr2(r5, 0, o4), m3[r5 + 256 >> 2] = _3, V4 = Ur2(r5, 0, o4), m3[r5 + 264 >> 2] = V4, te3 = (W3 = r5 + 268 | 0) + i4 | 0, fe2 = zr2(r5, lr3), m3[te3 >> 2] = fe2, te3 = g5 + W3 | 0, fe2 = Qr2(r5, lr3), m3[te3 >> 2] = fe2, G4 = zr2(r5, 0), m3[r5 + 272 >> 2] = G4, T4 = Qr2(r5, 0), m3[r5 + 280 >> 2] = T4, te3 = (Z4 = i4) + (i4 = r5 + 284 | 0) | 0, fe2 = Br2(r5, lr3, o4), m3[te3 >> 2] = fe2, te3 = i4 + g5 | 0, fe2 = Tr2(r5, lr3, o4), m3[te3 >> 2] = fe2, R5 = Br2(r5, 0, o4), m3[r5 + 288 >> 2] = R5, P3 = Tr2(r5, 0, o4), m3[r5 + 296 >> 2] = P3, B3 = y2(B3 + F3), F3 = y2(_3 + V4), i4 = c4[r5 + 8 >> 2]) {
                      if (_3 = y2(y2(y2(m3[r5 + 284 >> 2] + m3[r5 + 292 >> 2]) + m3[r5 + 268 >> 2]) + m3[r5 + 276 >> 2]), a5 = y2(t5 ? a5 - F3 : NaN), G4 = y2(y2(R5 + P3) + G4), (e3 = R5 = y2(n3 ? e3 - B3 : NaN)) == e3 && (e3 = (e3 = y2(R5 - _3)) == e3 ? Re(e3, y2(0)) : y2(0)), B3 = y2(G4 + T4), G4 = a5, a5 == a5 && (G4 = (G4 = y2(a5 - B3)) == G4 ? Re(G4, y2(0)) : y2(0)), !(1 != (0 | n3) | 1 != (0 | t5))) {
                        e3 = (i4 = (e3 = ur2(r5, 2, R5, o4)) != e3) | (G4 = y2(y2(Br2(r5, 2, o4) + zr2(r5, 2)) + y2(Tr2(r5, 2, o4) + Qr2(r5, 2)))) != G4 ? i4 ? G4 : e3 : Re(e3, G4), m3[r5 + 516 >> 2] = e3, e3 = (i4 = (e3 = ur2(r5, 0, a5, u3)) != e3) | (a5 = y2(y2(Br2(r5, 0, o4) + zr2(r5, 0)) + y2(Tr2(r5, 0, o4) + Qr2(r5, 0)))) != a5 ? i4 ? a5 : e3 : Re(e3, a5), m3[r5 + 520 >> 2] = e3;
                        break r;
                      }
                      16 & v3[r5 + 4 | 0] ? aa[0 | i4](w3 + 24 | 0, r5, e3, n3, G4, t5, 0) : aa[0 | i4](w3 + 24 | 0, r5, e3, n3, G4, t5), c4[l4 + 20 >> 2] = c4[l4 + 20 >> 2] + 1, c4[24 + (i4 = (N3 << 2) + l4 | 0) >> 2] = c4[i4 + 24 >> 2] + 1, e3 = y2(_3 + m3[w3 + 24 >> 2]), e3 = (i4 = (e3 = ur2(r5, 2, n3 ? 2 == (0 | n3) ? e3 : R5 : e3, o4)) != e3) | (G4 = y2(y2(Br2(r5, 2, o4) + zr2(r5, 2)) + y2(Tr2(r5, 2, o4) + Qr2(r5, 2)))) != G4 ? i4 ? G4 : e3 : Re(e3, G4), m3[r5 + 516 >> 2] = e3, e3 = y2(B3 + m3[w3 + 28 >> 2]), e3 = (i4 = (e3 = ur2(r5, 0, t5 ? 2 == (0 | t5) ? e3 : a5 : e3, u3)) != e3) | (a5 = y2(y2(Br2(r5, 0, o4) + zr2(r5, 0)) + y2(Tr2(r5, 0, o4) + Qr2(r5, 0)))) != a5 ? i4 ? a5 : e3 : Re(e3, a5), m3[r5 + 520 >> 2] = e3;
                      break r;
                    }
                    if ((0 | (i4 = c4[r5 + 556 >> 2])) == (0 | (N3 = c4[r5 + 560 >> 2]))) {
                      F3 = y2(a5 - F3), e3 = (i4 = (e3 = ur2(r5, 2, y2(-3 & n3 ? e3 - B3 : y2(y2(m3[r5 + 284 >> 2] + m3[r5 + 292 >> 2]) + m3[r5 + 268 >> 2]) + m3[r5 + 276 >> 2]), o4)) != e3) | (a5 = y2(y2(Br2(r5, 2, o4) + zr2(r5, 2)) + y2(Tr2(r5, 2, o4) + Qr2(r5, 2)))) != a5 ? i4 ? a5 : e3 : Re(e3, a5), m3[r5 + 516 >> 2] = e3, e3 = (i4 = (e3 = ur2(r5, 0, -3 & t5 ? F3 : y2(y2(y2(R5 + P3) + G4) + T4), u3)) != e3) | (a5 = y2(y2(Br2(r5, 0, o4) + zr2(r5, 0)) + y2(Tr2(r5, 0, o4) + Qr2(r5, 0)))) != a5 ? i4 ? a5 : e3 : Re(e3, a5), m3[r5 + 520 >> 2] = e3;
                      break r;
                    }
                    if (!(s4 || (R5 = y2(e3 - B3), G4 = y2(a5 - F3), !(2 == (0 | n3) & R5 <= y2(0) | !(!(G4 <= y2(0)) | 2 != (0 | t5)) & G4 == G4) & (1 != (0 | n3) | 1 != (0 | t5))))) {
                      e3 = (i4 = (e3 = ur2(r5, 2, R5 == R5 ? 2 == (0 | n3) && R5 < y2(0) ? y2(0) : R5 : y2(0), o4)) != e3) | (a5 = y2(y2(Br2(r5, 2, o4) + zr2(r5, 2)) + y2(Tr2(r5, 2, o4) + Qr2(r5, 2)))) != a5 ? i4 ? a5 : e3 : Re(e3, a5), m3[r5 + 516 >> 2] = e3, e3 = (i4 = (e3 = ur2(r5, 0, G4 != G4 || 2 == (0 | t5) && G4 < y2(0) ? y2(0) : G4, u3)) != e3) | (a5 = y2(y2(Br2(r5, 0, o4) + zr2(r5, 0)) + y2(Tr2(r5, 0, o4) + Qr2(r5, 0)))) != a5 ? i4 ? a5 : e3 : Re(e3, a5), m3[r5 + 520 >> 2] = e3;
                      break r;
                    }
                    for (er4 = (z4 = N3 - i4 | 0) >> 2; g5 = c4[i4 >> 2], c4[g5 + 552 >> 2] != (0 | r5) && (W3 = c4[r5 + 568 >> 2], g5 = Ir2(c4[W3 >> 2], v3[W3 + 8 | 0], g5, r5, O3, 0), c4[i4 >> 2] = g5, c4[g5 + 552 >> 2] = r5), O3 = O3 + 1 | 0, (0 | N3) != (0 | (i4 = i4 + 4 | 0)); )
                      ;
                    f3[r5 + 300 | 0] = 251 & v3[r5 + 300 | 0], O3 = 3, i4 = (yr3 = c4[r5 + 24 >> 2]) >>> 2 & 3;
                    i: {
                      n: {
                        t: {
                          if (2 == (0 | J3)) {
                            N3 = 0;
                            f:
                              switch (i4 - 2 | 0) {
                                case 0:
                                  break i;
                                case 1:
                                  break f;
                                default:
                                  break t;
                              }
                            O3 = 2;
                            break i;
                          }
                          if (O3 = 2, N3 = 0, i4 >>> 0 > 1)
                            break n;
                        }
                        N3 = O3;
                      }
                      O3 = i4;
                    }
                    Yr3 = y2(e3 - B3), ir3 = y2(y2(Br2(r5, O3, o4) + zr2(r5, O3)) + y2(Tr2(r5, O3, o4) + Qr2(r5, O3))), P3 = y2(Br2(r5, N3, o4) + zr2(r5, N3)), K3 = y2(P3 + y2(Tr2(r5, N3, o4) + Qr2(r5, N3))), V4 = kr2(r5, 0, Yr3, (q3 = O3 >>> 0 > 1) ? ir3 : K3, o4), U3 = kr2(r5, 1, Hr3 = y2(a5 - F3), q3 ? K3 : ir3, u3), M4 = q3 ? U3 : V4, F3 = q3 ? V4 : U3, nr3 = c4[r5 + 560 >> 2], g5 = c4[r5 + 556 >> 2];
                    i:
                      if (1 == (0 | (Y3 = q3 ? n3 : t5))) {
                        if ((0 | g5) == (0 | nr3))
                          break a;
                        for (i4 = 0, W3 = g5; ; ) {
                          Z4 = i4;
                          n:
                            if (Dr2(i4 = c4[W3 >> 2])) {
                              if (X3 = 0, Z4)
                                break i;
                              if (!(Z4 = c4[i4 + 552 >> 2]))
                                break i;
                              t: {
                                if (!((a5 = m3[i4 + 32 >> 2]) == a5 || (G4 = y2(0), (a5 = m3[i4 + 28 >> 2]) > y2(0))) || (G4 = a5, a5 == a5)) {
                                  if (y2(E3(G4)) < y2(9999999747378752e-20))
                                    break i;
                                  if (!Z4) {
                                    a5 = y2(0);
                                    break t;
                                  }
                                }
                                if ((a5 = m3[i4 + 36 >> 2]) != a5) {
                                  if (f3[i4 + 4 | 0] < 0) {
                                    a5 = y2(1);
                                    break t;
                                  }
                                  if (a5 = y2(0), !((e3 = m3[i4 + 28 >> 2]) < y2(0)))
                                    break t;
                                  a5 = y2(-e3);
                                }
                                if (a5 != a5)
                                  break n;
                              }
                              if (y2(E3(a5)) < y2(9999999747378752e-20))
                                break i;
                            } else
                              i4 = Z4;
                          if (X3 = i4, (0 | nr3) == (0 | (W3 = W3 + 4 | 0)))
                            break;
                        }
                      }
                    if ((0 | g5) == (0 | nr3))
                      break a;
                    for (j3 = (0 | J3) <= 1 ? 1 : J3, tr3 = (fr3 = V4 != V4) | 1 != (0 | n3), cr3 = U3 == U3, dr3 = V4 == V4, G4 = y2(0); ; ) {
                      sr2(L4 = c4[g5 >> 2]);
                      i:
                        if (4194304 & (W3 = c4[L4 + 24 >> 2])) {
                          if (mr2(L4, 0), W3 = 1 | (i4 = v3[L4 + 4 | 0]), f3[L4 + 4 | 0] = W3, !(4 & i4))
                            break i;
                          f3[L4 + 4 | 0] = 251 & W3;
                        } else if (s4 && (Fr2(L4, (i4 = 3 & W3) || j3, F3, M4, V4), W3 = c4[L4 + 24 >> 2]), 131072 != (196608 & W3)) {
                          if ((0 | X3) != (0 | L4)) {
                            Z4 = (vr3 = c4[r5 + 24 >> 2]) >>> 2 & 3;
                            n: {
                              t:
                                if (2 == (0 | J3)) {
                                  i4 = 3;
                                  f:
                                    switch (Z4 - 2 | 0) {
                                      case 0:
                                        break n;
                                      case 1:
                                        break f;
                                      default:
                                        break t;
                                    }
                                  i4 = 2;
                                  break n;
                                }
                              i4 = Z4;
                            }
                            R5 = ($3 = i4 >>> 0 > 1) ? V4 : U3, a5 = y2(0), e3 = m3[L4 + 40 >> 2];
                            n: {
                              t: {
                                f:
                                  if (2139156720 != (0 | (Z4 = c4[L4 + 40 >> 2]))) {
                                    if (2140081935 == (0 | Z4))
                                      break t;
                                    S4 = 4276;
                                    o: {
                                      if (2141891242 != (0 | Z4)) {
                                        if (e3 == e3)
                                          break o;
                                        S4 = 4268;
                                      }
                                      a5 = m3[S4 >> 2];
                                      c: {
                                        u:
                                          switch (0 | (Z4 = c4[S4 + 4 >> 2])) {
                                            case 0:
                                            case 3:
                                              break u;
                                            default:
                                              break c;
                                          }
                                        if (e3 = y2(NaN), !(m3[L4 + 28 >> 2] > y2(0)))
                                          break n;
                                        Z4 = (S4 = f3[L4 + 4 | 0] < 0) ? 3 : 1, b2(2, D2 = S4 ? 2143289344 : 0), a5 = d2();
                                      }
                                      switch (e3 = y2(NaN), Z4 - 1 | 0) {
                                        case 0:
                                          break t;
                                        case 1:
                                          break f;
                                        default:
                                          break n;
                                      }
                                    }
                                    if (b2(2, 536870912 + (-1073741825 & Z4) | 0), a5 = d2(), !(1073741824 & Z4))
                                      break t;
                                  }
                                e3 = y2(y2(R5 * a5) * y2(0.009999999776482582));
                                break n;
                              }
                              e3 = a5;
                            }
                            a5 = m3[L4 + 572 >> 2], Z4 = 0;
                            n: {
                              switch (0 | (Q4 = c4[L4 + 576 >> 2])) {
                                case 0:
                                case 3:
                                  break n;
                              }
                              if (1 != (0 | Q4) | (B3 = m3[L4 + 572 >> 2]) != B3)
                                Z4 = 1, 2 != (0 | Q4) | B3 != B3 || (Z4 = 0, a5 < y2(0) || (Z4 = dr3));
                              else {
                                if (a5 < y2(0))
                                  break n;
                                Z4 = 1;
                              }
                            }
                            B3 = m3[L4 + 580 >> 2], S4 = 0;
                            n: {
                              switch (0 | (H4 = c4[L4 + 584 >> 2])) {
                                case 0:
                                case 3:
                                  break n;
                              }
                              if (1 != (0 | H4) | (T4 = m3[L4 + 580 >> 2]) != T4)
                                S4 = 1, 2 != (0 | H4) | T4 != T4 || (S4 = 0, B3 < y2(0) || (S4 = cr3));
                              else {
                                if (B3 < y2(0))
                                  break n;
                                S4 = 1;
                              }
                            }
                            n: {
                              t:
                                if (e3 != e3 | R5 != R5) {
                                  if (Z4 & $3) {
                                    switch (R5 = y2(y2(Br2(L4, 2, V4) + zr2(L4, 2)) + y2(Tr2(L4, 2, V4) + Qr2(L4, 2))), e3 = y2(NaN), Q4 - 1 | 0) {
                                      case 1:
                                        a5 = y2(y2(V4 * a5) * y2(0.009999999776482582));
                                      case 0:
                                        if (R5 <= (e3 = a5))
                                          break t;
                                    }
                                    if (!(e3 == e3 | R5 == R5)) {
                                      a5 = e3;
                                      break t;
                                    }
                                    if (e3 < R5) {
                                      a5 = R5;
                                      break t;
                                    }
                                    a5 = e3 != e3 ? R5 : e3;
                                  } else if ($3 | 1 ^ S4) {
                                    if (c4[w3 + 360 >> 2] = 2143289344, c4[w3 + 24 >> 2] = 2143289344, D2 = 0, c4[w3 + 356 >> 2] = 0, c4[w3 + 352 >> 2] = 0, T4 = y2(Mr2(L4, 2, V4) + Ur2(L4, 2, V4)), _3 = Mr2(L4, 0, V4), C4 = Ur2(L4, 0, V4), R5 = y2(NaN), rr3 = 0, e3 = y2(NaN), Z4) {
                                      f: {
                                        o:
                                          switch (Q4 - 1 | 0) {
                                            case 0:
                                              e3 = a5;
                                              break f;
                                            case 1:
                                              break o;
                                            default:
                                              break f;
                                          }
                                        e3 = y2(y2(V4 * a5) * y2(0.009999999776482582));
                                      }
                                      c4[w3 + 356 >> 2] = 1, e3 = y2(T4 + e3), m3[w3 + 24 >> 2] = e3, rr3 = 1;
                                    }
                                    if (_3 = y2(_3 + C4), S4) {
                                      a5 = y2(NaN);
                                      f: {
                                        o:
                                          switch (H4 - 1 | 0) {
                                            case 0:
                                              a5 = B3;
                                              break f;
                                            case 1:
                                              break o;
                                            default:
                                              break f;
                                          }
                                        a5 = y2(y2(U3 * B3) * y2(0.009999999776482582));
                                      }
                                      c4[w3 + 352 >> 2] = 1, R5 = y2(_3 + a5), m3[w3 + 360 >> 2] = R5, D2 = 1;
                                    }
                                    Q4 = i4 >>> 0 < 2;
                                    f: {
                                      o: {
                                        c: {
                                          if (!(!$3 & 2097152 == (0 | (H4 = 3145728 & vr3)))) {
                                            if (fr3 | 2097152 == (0 | H4))
                                              break o;
                                            if (e3 != e3)
                                              break c;
                                            break o;
                                          }
                                          if (fr3 | e3 == e3)
                                            break f;
                                        }
                                        rr3 = 2, c4[w3 + 356 >> 2] = 2, m3[w3 + 24 >> 2] = V4, e3 = V4;
                                      }
                                      o: {
                                        if (!(!Q4 & 2097152 == (0 | H4))) {
                                          if (2097152 == (0 | H4) | U3 != U3)
                                            break f;
                                          if (R5 != R5)
                                            break o;
                                          break f;
                                        }
                                        if (R5 == R5 | U3 != U3)
                                          break f;
                                      }
                                      D2 = 2, c4[w3 + 352 >> 2] = 2, m3[w3 + 360 >> 2] = U3, R5 = U3;
                                    }
                                    f:
                                      if (!(H4 = (a5 = m3[L4 + 224 >> 2]) != a5)) {
                                        if ($3 | 1 != (0 | rr3)) {
                                          if (Q4 | 1 != (0 | D2))
                                            break f;
                                          c4[w3 + 356 >> 2] = 1, m3[w3 + 24 >> 2] = y2(y2(R5 - _3) * a5) + T4;
                                        } else
                                          c4[w3 + 352 >> 2] = 1, m3[w3 + 360 >> 2] = _3 + y2(y2(e3 - T4) / a5);
                                        D2 = 1, rr3 = 1;
                                      }
                                    5 == (0 | (W3 = (W3 = W3 >>> 13 & 7) || vr3 >>> 10 & 7)) | 1 == (0 | rr3) | $3 | Z4 | tr3 | 4 != (0 | W3) || (c4[w3 + 356 >> 2] = 1, m3[w3 + 24 >> 2] = V4, H4 || (D2 = 1, c4[w3 + 352 >> 2] = 1, m3[w3 + 360 >> 2] = y2(V4 - T4) / a5)), Q4 | 1 != (0 | t5) | U3 != U3 | S4 | 4 != (0 | W3) | 1 == (0 | D2) || (c4[w3 + 352 >> 2] = 1, m3[w3 + 360 >> 2] = U3, H4 || (c4[w3 + 356 >> 2] = 1, m3[w3 + 24 >> 2] = y2(U3 - _3) * a5)), Vr2(L4, 2, V4, V4, w3 + 356 | 0, w3 + 24 | 0), Vr2(L4, 0, U3, V4, w3 + 352 | 0, w3 + 360 | 0), or2(L4, m3[w3 + 24 >> 2], m3[w3 + 360 >> 2], J3, c4[w3 + 356 >> 2], c4[w3 + 352 >> 2], V4, U3, 0, 5, A4, l4, h4, p3), a5 = (W3 = (e3 = m3[516 + (L4 + (c4[4252 + (i4 << 2) >> 2] << 2) | 0) >> 2]) != e3) | (a5 = y2(y2(Br2(L4, i4, V4) + zr2(L4, i4)) + y2(Tr2(L4, i4, V4) + Qr2(L4, i4)))) != a5 ? W3 ? a5 : e3 : Re(e3, a5);
                                  } else {
                                    switch (e3 = y2(y2(Br2(L4, 0, V4) + zr2(L4, 0)) + y2(Tr2(L4, 0, V4) + Qr2(L4, 0))), a5 = y2(NaN), H4 - 1 | 0) {
                                      case 1:
                                        B3 = y2(y2(U3 * B3) * y2(0.009999999776482582));
                                      case 0:
                                        if (e3 <= (a5 = B3))
                                          break t;
                                    }
                                    if (a5 != a5 & e3 != e3)
                                      break t;
                                    if (e3 > a5) {
                                      a5 = e3;
                                      break t;
                                    }
                                    a5 = a5 != a5 ? e3 : a5;
                                  }
                                } else {
                                  if (a5 = m3[L4 + 308 >> 2], (!v3[c4[L4 + 568 >> 2] + 20 | 0] | c4[L4 + 304 >> 2] == (0 | p3)) & a5 == a5)
                                    break n;
                                  if (!((a5 = y2(y2(Br2(L4, i4, V4) + zr2(L4, i4)) + y2(Tr2(L4, i4, V4) + Qr2(L4, i4)))) <= e3) & e3 < a5)
                                    break t;
                                  a5 = e3;
                                }
                              m3[L4 + 308 >> 2] = a5;
                            }
                            c4[L4 + 304 >> 2] = p3;
                          } else
                            c4[X3 + 308 >> 2] = 0, c4[X3 + 304 >> 2] = p3, a5 = y2(0);
                          G4 = y2(G4 + y2(a5 + y2(Mr2(L4, O3, V4) + Ur2(L4, O3, V4))));
                        }
                      if ((0 | nr3) == (0 | (g5 = g5 + 4 | 0)))
                        break;
                    }
                    break e;
                  }
                  c4[w3 >> 2] = 3023, Xr2(r5, w3), De(), k2();
                }
                c4[w3 + 16 >> 2] = 3105, Xr2(r5, w3 + 16 | 0), De(), k2();
              }
              G4 = y2(0);
            }
            e3 = y2(G4 + y2(0)), Er3 = q3 ? u3 : o4, hr3 = q3 ? o4 : u3, z4 >>> 0 >= 5 && (e3 = y2(y2(pr2(r5, O3, M4) * y2(er4 - 1 >>> 0)) + e3)), i4 = e3 > F3, nr3 = 786432 & yr3, cr3 = 2 == (0 | Y3) && nr3 && i4 ? 1 : Y3, qr3 = (fr3 = 1 == (0 | (L4 = q3 ? t5 : n3))) & (1 ^ s4), q3 = O3 >>> 0 < 2, $r3 = -3 & L4, vr3 = r5 + 208 | 0, H4 = 4220 + (t5 = N3 << 2) | 0, re3 = fr3 & !nr3, ee3 = 1 != (0 | L4) | s4, $3 = 4220 + (g5 = O3 << 2) | 0, dr3 = g5 + 4252 | 0, ae3 = (rr3 = M4 == M4) << 1, Q4 = t5 + 4252 | 0, ie3 = !Y3 | !i4, yr3 = w3 + 52 | 0, jr3 = pr2(r5, N3, M4), W3 = 0, i4 = 0, D2 = 0;
            e: {
              for (; ; ) {
                if (S4 = i4, Rr2(w3 + 24 | 0, 0, 44), (0 | (i4 = c4[r5 + 560 >> 2])) != (0 | (t5 = c4[r5 + 556 >> 2]))) {
                  if ((0 | (i4 = i4 - t5 | 0)) < 0)
                    break e;
                  g5 = pe(w3 + 360 | 0, i4 >> 2, 0, yr3), i4 = c4[w3 + 44 >> 2], t5 = c4[w3 + 48 >> 2] - i4 | 0, t5 = wr2(c4[w3 + 364 >> 2] - t5 | 0, i4, t5), i4 = c4[w3 + 44 >> 2], c4[w3 + 364 >> 2] = i4, c4[w3 + 44 >> 2] = t5, Z4 = c4[w3 + 368 >> 2], X3 = c4[w3 + 372 >> 2], t5 = c4[w3 + 48 >> 2], c4[w3 + 368 >> 2] = t5, Y3 = c4[w3 + 52 >> 2], c4[w3 + 48 >> 2] = Z4, c4[w3 + 52 >> 2] = X3, c4[w3 + 372 >> 2] = Y3, c4[g5 >> 2] = i4, (0 | i4) != (0 | t5) && (c4[w3 + 368 >> 2] = t5 + (3 + (i4 - t5 | 0) & -4)), i4 && gr2(i4);
                }
                t5 = (X3 = c4[r5 + 24 >> 2]) >>> 2 & 3;
                a: {
                  i:
                    if (2 == (0 | ((i4 = 3 & X3) || Pr3))) {
                      i4 = 3;
                      n:
                        switch (t5 - 2 | 0) {
                          case 0:
                            break a;
                          case 1:
                            break n;
                          default:
                            break i;
                        }
                      i4 = 2;
                      break a;
                    }
                  i4 = t5;
                }
                G4 = pr2(r5, i4, V4);
                a:
                  if (!((g5 = W3) >>> 0 >= (Z4 = c4[r5 + 560 >> 2]) - (t5 = c4[r5 + 556 >> 2]) >> 2 >>> 0))
                    for (Y3 = 786432 & X3, a5 = y2(0); ; ) {
                      if (Z4 - t5 >> 2 >>> 0 <= g5 >>> 0)
                        break e;
                      if (X3 = c4[(g5 << 2) + t5 >> 2], !(4194304 & (z4 = c4[X3 + 24 >> 2]) | 131072 == (196608 & z4))) {
                        if (c4[X3 + 548 >> 2] = S4, e3 = Mr2(X3, i4, V4), R5 = Ur2(X3, i4, V4), t5 = c4[w3 + 24 >> 2], B3 = (0 | g5) == (0 | W3) ? y2(0) : G4, e3 = y2(e3 + R5), T4 = ur2(X3, i4, R5 = m3[X3 + 308 >> 2], hr3), t5 && !(!(y2(B3 + y2(e3 + y2(a5 + T4))) > F3) | !Y3))
                          break a;
                        if (c4[w3 + 24 >> 2] = t5 + 1, B3 = y2(B3 + y2(e3 + T4)), m3[w3 + 28 >> 2] = B3 + m3[w3 + 28 >> 2], Dr2(X3)) {
                          i:
                            if (c4[X3 + 552 >> 2]) {
                              if ((e3 = m3[X3 + 32 >> 2]) != e3 && (e3 = (e3 = m3[X3 + 28 >> 2]) > y2(0) ? e3 : y2(0)), m3[w3 + 32 >> 2] = e3 + m3[w3 + 32 >> 2], (e3 = m3[X3 + 36 >> 2]) == e3)
                                break i;
                              if (f3[X3 + 4 | 0] < 0) {
                                e3 = y2(1);
                                break i;
                              }
                              if (e3 = y2(0), !((T4 = m3[X3 + 28 >> 2]) < y2(0)))
                                break i;
                              e3 = y2(-T4);
                            } else
                              e3 = y2(0), m3[w3 + 32 >> 2] = m3[w3 + 32 >> 2] + y2(0);
                          m3[w3 + 36 >> 2] = m3[w3 + 36 >> 2] - y2(e3 * R5);
                        }
                        if ((0 | (t5 = c4[w3 + 48 >> 2])) == c4[w3 + 52 >> 2]) {
                          if ((Z4 = 1 + (z4 = (t5 = t5 - c4[w3 + 44 >> 2] | 0) >> 2) | 0) >>> 0 >= 1073741824)
                            break e;
                          j3 = t5 >>> 1 | 0, z4 = pe(w3 + 360 | 0, t5 >>> 0 >= 2147483644 ? 1073741823 : Z4 >>> 0 < j3 >>> 0 ? j3 : Z4, z4, yr3), c4[c4[w3 + 368 >> 2] >> 2] = X3, c4[w3 + 368 >> 2] = c4[w3 + 368 >> 2] + 4, t5 = c4[w3 + 44 >> 2], Z4 = c4[w3 + 48 >> 2] - t5 | 0, Z4 = wr2(c4[w3 + 364 >> 2] - Z4 | 0, t5, Z4), t5 = c4[w3 + 44 >> 2], c4[w3 + 364 >> 2] = t5, c4[w3 + 44 >> 2] = Z4, X3 = c4[w3 + 368 >> 2], j3 = c4[w3 + 372 >> 2], Z4 = c4[w3 + 48 >> 2], c4[w3 + 368 >> 2] = Z4, tr3 = c4[w3 + 52 >> 2], c4[w3 + 48 >> 2] = X3, c4[w3 + 52 >> 2] = j3, c4[w3 + 372 >> 2] = tr3, c4[z4 >> 2] = t5, (0 | t5) != (0 | Z4) && (c4[w3 + 368 >> 2] = Z4 + (3 + (t5 - Z4 | 0) & -4)), t5 && gr2(t5);
                        } else
                          c4[t5 >> 2] = X3, c4[w3 + 48 >> 2] = t5 + 4;
                        t5 = c4[r5 + 556 >> 2], Z4 = c4[r5 + 560 >> 2], a5 = y2(a5 + B3);
                      }
                      if (!((g5 = g5 + 1 | 0) >>> 0 < Z4 - t5 >> 2 >>> 0))
                        break;
                    }
                !((C4 = m3[w3 + 32 >> 2]) > y2(0)) | !(C4 < y2(1)) || (c4[w3 + 32 >> 2] = 1065353216, C4 = y2(1)), !((x3 = m3[w3 + 36 >> 2]) > y2(0)) | !(x3 < y2(1)) || (c4[w3 + 36 >> 2] = 1065353216, x3 = y2(1)), c4[w3 + 40 >> 2] = g5, _3 = m3[w3 + 28 >> 2], Y3 = c4[w3 + 24 >> 2], D2 && gr2(D2), B3 = m3[w3 + 56 >> 2], z4 = c4[w3 + 48 >> 2], D2 = c4[w3 + 44 >> 2];
                a: {
                  i: {
                    n: {
                      if (1 != (0 | cr3)) {
                        a5 = y2(0), e3 = m3[vr3 >> 2];
                        t: {
                          f: {
                            o:
                              if (2139156720 != (0 | (i4 = c4[vr3 >> 2]))) {
                                if (2140081935 == (0 | i4))
                                  break f;
                                t5 = 4276;
                                c: {
                                  if (2141891242 != (0 | i4)) {
                                    if (e3 == e3)
                                      break c;
                                    t5 = 4268;
                                  }
                                  switch (a5 = m3[t5 >> 2], e3 = y2(NaN), c4[t5 + 4 >> 2] - 1 | 0) {
                                    case 0:
                                      break f;
                                    case 1:
                                      break o;
                                    default:
                                      break t;
                                  }
                                }
                                if (b2(2, 536870912 + (-1073741825 & i4) | 0), a5 = d2(), !(1073741824 & i4))
                                  break f;
                              }
                            e3 = y2(y2(a5 * o4) * y2(0.009999999776482582));
                            break t;
                          }
                          e3 = a5;
                        }
                        a5 = y2(0), G4 = m3[r5 + 216 >> 2];
                        t: {
                          f: {
                            o:
                              if (2139156720 != (0 | (i4 = c4[r5 + 216 >> 2]))) {
                                if (2140081935 == (0 | i4))
                                  break f;
                                t5 = 4276;
                                c: {
                                  if (2141891242 != (0 | i4)) {
                                    if (G4 == G4)
                                      break c;
                                    t5 = 4268;
                                  }
                                  switch (a5 = m3[t5 >> 2], G4 = y2(NaN), c4[t5 + 4 >> 2] - 1 | 0) {
                                    case 0:
                                      break f;
                                    case 1:
                                      break o;
                                    default:
                                      break t;
                                  }
                                }
                                if (b2(2, 536870912 + (-1073741825 & i4) | 0), a5 = d2(), !(1073741824 & i4))
                                  break f;
                              }
                            G4 = y2(y2(a5 * o4) * y2(0.009999999776482582));
                            break t;
                          }
                          G4 = a5;
                        }
                        a5 = y2(0), R5 = m3[r5 + 212 >> 2];
                        t: {
                          f: {
                            o:
                              if (2139156720 != (0 | (i4 = c4[r5 + 212 >> 2]))) {
                                if (2140081935 == (0 | i4))
                                  break f;
                                t5 = 4276;
                                c: {
                                  if (2141891242 != (0 | i4)) {
                                    if (R5 == R5)
                                      break c;
                                    t5 = 4268;
                                  }
                                  switch (a5 = m3[t5 >> 2], T4 = y2(NaN), c4[t5 + 4 >> 2] - 1 | 0) {
                                    case 0:
                                      break f;
                                    case 1:
                                      break o;
                                    default:
                                      break t;
                                  }
                                }
                                if (b2(2, 536870912 + (-1073741825 & i4) | 0), a5 = d2(), !(1073741824 & i4))
                                  break f;
                              }
                            T4 = y2(y2(a5 * u3) * y2(0.009999999776482582));
                            break t;
                          }
                          T4 = a5;
                        }
                        a5 = y2(0), R5 = m3[r5 + 220 >> 2];
                        t: {
                          f: {
                            o:
                              if (2139156720 != (0 | (i4 = c4[r5 + 220 >> 2]))) {
                                if (2140081935 == (0 | i4))
                                  break f;
                                t5 = 4276;
                                c: {
                                  if (2141891242 != (0 | i4)) {
                                    if (R5 == R5)
                                      break c;
                                    t5 = 4268;
                                  }
                                  switch (a5 = m3[t5 >> 2], R5 = y2(NaN), c4[t5 + 4 >> 2] - 1 | 0) {
                                    case 0:
                                      break f;
                                    case 1:
                                      break o;
                                    default:
                                      break t;
                                  }
                                }
                                if (b2(2, 536870912 + (-1073741825 & i4) | 0), a5 = d2(), !(1073741824 & i4))
                                  break f;
                              }
                            R5 = y2(y2(a5 * u3) * y2(0.009999999776482582));
                            break t;
                          }
                          R5 = a5;
                        }
                        if ((a5 = y2(((i4 = O3 >>> 0 > 1) ? e3 : T4) - ir3)) == a5 & a5 > _3)
                          break n;
                        if ((a5 = y2((i4 ? G4 : R5) - ir3)) == a5 & a5 < _3)
                          break n;
                        if (!v3[c4[r5 + 568 >> 2] + 11 | 0]) {
                          if (a5 = _3, !c4[r5 + 552 >> 2] | C4 == y2(0))
                            break i;
                          t: {
                            if ((e3 = m3[r5 + 32 >> 2]) != e3) {
                              if (!((a5 = m3[r5 + 28 >> 2]) > y2(0)))
                                break t;
                            } else
                              a5 = e3;
                            if (a5 != a5) {
                              a5 = F3;
                              break i;
                            }
                            e3 = m3[r5 + 32 >> 2];
                          }
                          if (e3 != e3 && (a5 = _3, !((e3 = m3[r5 + 28 >> 2]) > y2(0))))
                            break i;
                          if (a5 = F3, e3 != y2(0))
                            break i;
                          a5 = _3;
                          break i;
                        }
                      }
                      a5 = F3;
                    }
                    if (a5 == a5) {
                      B3 = y2(a5 - _3);
                      break a;
                    }
                  }
                  _3 < y2(0) && (B3 = y2(-_3));
                }
                if (F3 = a5, !qr3) {
                  if ((0 | D2) != (0 | z4)) {
                    for (R5 = y2(0), t5 = D2; ; ) {
                      a5 = ur2(i4 = c4[t5 >> 2], O3, _3 = m3[i4 + 308 >> 2], hr3);
                      a:
                        if (B3 < y2(0)) {
                          if ((X3 = c4[i4 + 552 >> 2]) ? (G4 = m3[i4 + 36 >> 2]) != G4 && (f3[i4 + 4 | 0] < 0 ? G4 = y2(1) : (G4 = y2(0), (e3 = m3[i4 + 28 >> 2]) < y2(0) && (G4 = y2(-e3)))) : G4 = y2(0), !((e3 = y2(a5 * y2(-G4))) > y2(0) | e3 < y2(0)))
                            break a;
                          if ((G4 = y2(y2(y2(B3 / x3) * e3) + a5)) != G4 | (e3 = (Z4 = (e3 = ur2(i4, O3, G4, F3)) != e3) | (T4 = y2(y2(Br2(i4, O3, V4) + zr2(i4, O3)) + y2(Tr2(i4, O3, V4) + Qr2(i4, O3)))) != T4 ? Z4 ? T4 : e3 : Re(e3, T4)) != e3 | e3 == G4)
                            break a;
                          e3 = y2(e3 - a5), X3 ? (a5 = m3[i4 + 36 >> 2]) != a5 && (f3[i4 + 4 | 0] < 0 ? a5 = y2(1) : (a5 = y2(0), (G4 = m3[i4 + 28 >> 2]) < y2(0) && (a5 = y2(-G4)))) : a5 = y2(0), R5 = y2(R5 + e3), x3 = y2(y2(a5 * _3) + x3);
                        } else
                          !(B3 > y2(0)) | !c4[i4 + 552 >> 2] || ((G4 = m3[i4 + 32 >> 2]) == G4 || (G4 = m3[i4 + 28 >> 2]) > y2(0)) && G4 < y2(0) | G4 > y2(0) && ((T4 = y2(y2(y2(B3 / C4) * G4) + a5)) != T4 | (e3 = (Z4 = (e3 = ur2(i4, O3, T4, F3)) != e3) | (_3 = y2(y2(Br2(i4, O3, V4) + zr2(i4, O3)) + y2(Tr2(i4, O3, V4) + Qr2(i4, O3)))) != _3 ? Z4 ? _3 : e3 : Re(e3, _3)) != e3 | e3 == T4 || (C4 = y2(C4 - G4), R5 = y2(R5 + y2(e3 - a5))));
                      if ((0 | z4) == (0 | (t5 = t5 + 4 | 0)))
                        break;
                    }
                    for (_3 = y2(B3 - R5), Gr3 = y2(_3 / x3), Zr3 = y2(_3 / C4), Cr3 = !(j3 = fr3 & (!(12 & v3[r5 + 26 | 0]) | ie3)), tr3 = c4[Q4 >> 2], T4 = y2(0), Z4 = D2; ; ) {
                      a5 = ur2(t5 = c4[Z4 >> 2], O3, m3[t5 + 308 >> 2], hr3);
                      a: {
                        if (_3 < y2(0)) {
                          if (c4[t5 + 552 >> 2] ? (e3 = m3[t5 + 36 >> 2]) != e3 && (f3[t5 + 4 | 0] < 0 ? e3 = y2(1) : (e3 = y2(0), (G4 = m3[t5 + 28 >> 2]) < y2(0) && (e3 = y2(-G4)))) : e3 = y2(0), G4 = a5, (e3 = y2(a5 * y2(-e3))) == y2(0))
                            break a;
                          e3 = x3 == y2(0) ? y2(a5 + e3) : y2(y2(Gr3 * e3) + a5);
                        } else {
                          if (G4 = a5, !(_3 > y2(0)) | !c4[t5 + 552 >> 2])
                            break a;
                          if ((e3 = m3[t5 + 32 >> 2]) != e3 && !((e3 = m3[t5 + 28 >> 2]) > y2(0)))
                            break a;
                          if (!(e3 < y2(0) | e3 > y2(0)))
                            break a;
                          e3 = y2(y2(Zr3 * e3) + a5);
                        }
                        G4 = (i4 = (e3 = ur2(t5, O3, e3, F3)) != e3) | (G4 = y2(y2(Br2(t5, O3, V4) + zr2(t5, O3)) + y2(Tr2(t5, O3, V4) + Qr2(t5, O3)))) != G4 ? i4 ? G4 : e3 : Re(e3, G4);
                      }
                      if (e3 = Mr2(t5, O3, V4), R5 = Ur2(t5, O3, V4), C4 = Mr2(t5, N3, V4), Sr3 = Ur2(t5, N3, V4), R5 = y2(e3 + R5), xr3 = y2(G4 + R5), m3[w3 + 352 >> 2] = xr3, c4[w3 + 344 >> 2] = 1, C4 = y2(C4 + Sr3), (e3 = m3[t5 + 224 >> 2]) != e3) {
                        e3 = m3[572 + (X3 = t5 + (tr3 << 3) | 0) >> 2];
                        a: {
                          i: {
                            n: {
                              t: {
                                f: {
                                  o: {
                                    c: {
                                      u: {
                                        if (rr3) {
                                          R5 = m3[X3 + 572 >> 2];
                                          b: {
                                            s: {
                                              A: {
                                                switch (0 | (i4 = c4[X3 + 576 >> 2])) {
                                                  case 0:
                                                  case 3:
                                                    break A;
                                                }
                                                if (!(1 != (0 | i4) | e3 != e3)) {
                                                  if (!(j3 & R5 < y2(0)))
                                                    break b;
                                                  break s;
                                                }
                                                if (!(Cr3 | !(R5 < y2(0)) | 2 != (0 | i4) | e3 != e3))
                                                  break s;
                                                break b;
                                              }
                                              if (!j3)
                                                break b;
                                            }
                                            if ((X3 = c4[t5 + 24 >> 2] >>> 13 & 7) || (X3 = c4[r5 + 24 >> 2] >>> 10 & 7), 4 == (0 | X3) && (ve(w3 + 24 | 0, t5, N3), 3 != c4[w3 + 28 >> 2] && (de(w3 + 360 | 0, t5, N3), 3 != c4[w3 + 364 >> 2])))
                                              break u;
                                          }
                                          e3 = R5;
                                        } else
                                          R5 = m3[X3 + 572 >> 2], i4 = c4[X3 + 576 >> 2];
                                        switch (0 | i4) {
                                          case 0:
                                          case 3:
                                            break o;
                                          default:
                                            break c;
                                        }
                                      }
                                      c4[w3 + 348 >> 2] = 1;
                                      break i;
                                    }
                                    if (!(1 != (0 | i4) | e3 != e3)) {
                                      if ((e3 = R5) < y2(0))
                                        break o;
                                      break n;
                                    }
                                    if (2 != (0 | i4) | e3 != e3)
                                      break f;
                                    if (M4 == M4 && !(R5 < y2(0)))
                                      break t;
                                  }
                                  c4[w3 + 348 >> 2] = ae3;
                                  break i;
                                }
                                e3 = y2(NaN);
                                f:
                                  switch (i4 - 1 | 0) {
                                    case 1:
                                      break t;
                                    case 0:
                                      break f;
                                    default:
                                      break n;
                                  }
                                e3 = R5;
                                break n;
                              }
                              e3 = y2(y2(M4 * R5) * y2(0.009999999776482582));
                            }
                            e3 = y2(C4 + e3), m3[w3 + 356 >> 2] = e3, c4[w3 + 348 >> 2] = (fr3 | 2 != (0 | i4)) & e3 == e3;
                            break a;
                          }
                          m3[w3 + 356 >> 2] = M4;
                        }
                        e3 = R5;
                      } else
                        c4[w3 + 348 >> 2] = 1, R5 = y2(xr3 - R5), m3[w3 + 356 >> 2] = C4 + y2(q3 ? R5 * e3 : R5 / e3), R5 = m3[572 + (X3 = t5 + (tr3 << 3) | 0) >> 2], i4 = c4[X3 + 576 >> 2], e3 = m3[X3 + 572 >> 2];
                      Vr2(t5, O3, F3, V4, w3 + 344 | 0, w3 + 352 | 0), Vr2(t5, N3, M4, V4, w3 + 348 | 0, w3 + 356 | 0);
                      a: {
                        i: {
                          n: {
                            switch (0 | i4) {
                              case 0:
                              case 3:
                                break n;
                            }
                            if (!(1 != (0 | i4) | e3 != e3)) {
                              if (R5 < y2(0))
                                break n;
                              break i;
                            }
                            if (2 != (0 | i4) | e3 != e3)
                              break i;
                            if (!(R5 < y2(0)) && (X3 = 0, rr3))
                              break a;
                          }
                          if (X3 = 0, (i4 = c4[t5 + 24 >> 2] >>> 13 & 7) || (i4 = c4[r5 + 24 >> 2] >>> 10 & 7), 4 != (0 | i4))
                            break a;
                          if (ve(w3 + 24 | 0, t5, N3), 3 == c4[w3 + 28 >> 2])
                            break a;
                          de(w3 + 360 | 0, t5, N3), X3 = 3 != c4[w3 + 364 >> 2];
                          break a;
                        }
                        X3 = 0;
                      }
                      e3 = m3[w3 + 352 >> 2], R5 = m3[w3 + 356 >> 2], C4 = (i4 = O3 >>> 0 > 1) ? e3 : R5, e3 = i4 ? R5 : e3, _r3 = c4[w3 + 344 >> 2], Kr3 = c4[w3 + 348 >> 2], ne3 = i4 ? _r3 : Kr3, _r3 = i4 ? Kr3 : _r3, i4 = (1 ^ X3) & s4, or2(t5, C4, e3, 3 & v3[r5 + 300 | 0], ne3, _r3, V4, U3, i4, i4 ? 4 : 7, A4, l4, h4, p3), T4 = y2(T4 + y2(G4 - a5));
                      a: {
                        if (4 & (i4 = v3[r5 + 300 | 0]))
                          X3 = 251 & i4;
                        else if (X3 = 251 & i4, i4 = 0, !(4 & v3[t5 + 300 | 0]))
                          break a;
                        i4 = 4;
                      }
                      if (f3[r5 + 300 | 0] = i4 | X3, (0 | z4) == (0 | (Z4 = Z4 + 4 | 0)))
                        break;
                    }
                  } else
                    T4 = y2(0);
                  B3 = y2(B3 - T4);
                }
                i4 = v3[r5 + 300 | 0], f3[r5 + 300 | 0] = 251 & i4 | (B3 < y2(0) ? 4 : 4 & i4), R5 = y2(Br2(r5, O3, o4) + zr2(r5, O3)), Gr3 = y2(Tr2(r5, O3, o4) + Qr2(r5, O3)), _3 = pr2(r5, O3, o4);
                a:
                  if (!(B3 > y2(0)) | 2 != (0 | cr3))
                    T4 = B3;
                  else {
                    T4 = y2(0), a5 = y2(0);
                    i: {
                      n: {
                        i4 = vr3 + (c4[dr3 >> 2] << 2) | 0, e3 = m3[i4 >> 2];
                        t: {
                          if (!(t5 = 2139156720 == (0 | (i4 = c4[i4 >> 2])))) {
                            if (Z4 = 2140081935 == (0 | i4))
                              break n;
                            if ((X3 = 2141891242 == (0 | i4)) | e3 != e3)
                              break a;
                            if (Z4)
                              break n;
                            if (X3)
                              break a;
                            if (b2(2, 536870912 + (-1073741825 & i4) | 0), a5 = d2(), !(1073741824 & i4))
                              break t;
                          }
                          a5 = y2(y2(hr3 * a5) * y2(0.009999999776482582));
                        }
                        if (a5 != a5)
                          break a;
                        a5 = y2(0);
                        t:
                          if (!t5) {
                            if (2140081935 == (0 | i4))
                              break n;
                            t5 = 4276;
                            f: {
                              if (2141891242 != (0 | i4)) {
                                if (e3 == e3)
                                  break f;
                                t5 = 4268;
                              }
                              switch (a5 = m3[t5 >> 2], G4 = y2(NaN), c4[t5 + 4 >> 2] - 1 | 0) {
                                case 0:
                                  break n;
                                case 1:
                                  break t;
                                default:
                                  break i;
                              }
                            }
                            if (b2(2, 536870912 + (-1073741825 & i4) | 0), a5 = d2(), !(1073741824 & i4))
                              break n;
                          }
                        G4 = y2(y2(hr3 * a5) * y2(0.009999999776482582));
                        break i;
                      }
                      G4 = a5;
                    }
                    if ((e3 = y2(y2(y2(G4 - R5) - Gr3) - y2(F3 - B3))) != e3)
                      break a;
                    T4 = Re(e3, y2(0));
                  }
                a: {
                  if (!(X3 = g5 >>> 0 <= W3 >>> 0)) {
                    for (z4 = c4[r5 + 556 >> 2], j3 = (i4 = c4[r5 + 560 >> 2] - z4 >> 2) >>> 0 < W3 >>> 0 ? W3 : i4, Z4 = 0, i4 = W3; ; ) {
                      if ((0 | i4) == (0 | j3))
                        break e;
                      if (t5 = c4[z4 + (i4 << 2) >> 2], 131072 != (196608 & c4[t5 + 24 >> 2]) && (ve(tr3 = w3 + 24 | 0, t5, O3), Cr3 = c4[w3 + 28 >> 2], de(tr3, t5, O3), Z4 = ((3 == (0 | Cr3)) + Z4 | 0) + (3 == c4[w3 + 28 >> 2]) | 0), (0 | g5) == (0 | (i4 = i4 + 1 | 0)))
                        break;
                    }
                    if (C4 = y2(0), a5 = _3, Z4)
                      break a;
                  }
                  C4 = y2(0), Z4 = 0, a5 = _3;
                  i:
                    switch ((c4[r5 + 24 >> 2] >>> 4 & 7) - 1 | 0) {
                      case 0:
                        C4 = y2(T4 * y2(0.5));
                        break a;
                      case 1:
                        C4 = T4;
                        break a;
                      case 2:
                        if (Y3 >>> 0 < 2)
                          break a;
                        a5 = y2(_3 + y2((fe2 = y2(0), oe2 = Re(T4, y2(0)), ((te3 = T4 != T4) ? fe2 : oe2) / y2(Y3 - 1 >>> 0))));
                        break a;
                      case 4:
                        C4 = y2(T4 / y2(Y3 + 1 >>> 0)), a5 = y2(_3 + C4);
                        break a;
                      case 3:
                        break i;
                      default:
                        break a;
                    }
                  C4 = y2(y2(T4 * y2(0.5)) / y2(Y3 >>> 0)), a5 = y2(y2(C4 + C4) + _3);
                }
                if (e3 = y2(R5 + C4), B3 = y2(0), Y3 = Jr2(r5), X3)
                  a5 = y2(0);
                else {
                  for (z4 = g5 - 1 | 0, Zr3 = y2(T4 / y2(0 | Z4)), R5 = y2(0), G4 = y2(0), i4 = W3; ; ) {
                    if (t5 = c4[r5 + 556 >> 2], c4[r5 + 560 >> 2] - t5 >> 2 >>> 0 <= i4 >>> 0)
                      break e;
                    Ar2(w3 + 24 | 0, Z4 = (t5 = c4[t5 + (i4 << 2) >> 2]) + 228 | 0, 320), a5 = y2(a5 - ((0 | i4) == (0 | z4) ? _3 : y2(0)));
                    a:
                      if (!(4194304 & (j3 = c4[t5 + 24 >> 2]))) {
                        i: {
                          if (131072 == (196608 & j3)) {
                            if (!se(t5, O3))
                              break i;
                            if (!s4)
                              break a;
                            T4 = Lr2(t5, O3, F3), x3 = zr2(r5, O3), Sr3 = Mr2(t5, O3, V4), m3[Z4 + (c4[$3 >> 2] << 2) >> 2] = Sr3 + y2(T4 + x3);
                            break a;
                          }
                          if (ve(w3 + 360 | 0, t5, O3), e3 = y2(e3 + (3 == c4[w3 + 364 >> 2] ? Zr3 : y2(-0))), s4 && (j3 = Z4, Z4 = c4[$3 >> 2] << 2, m3[j3 + Z4 >> 2] = e3 + m3[Z4 + (w3 + 24 | 0) >> 2]), de(w3 + 360 | 0, t5, O3), e3 = y2(e3 + (3 == c4[w3 + 364 >> 2] ? Zr3 : y2(-0))), !ee3) {
                            e3 = y2(e3 + y2(y2(a5 + y2(Mr2(t5, O3, V4) + Ur2(t5, O3, V4))) + m3[w3 + 104 >> 2])), B3 = M4;
                            break a;
                          }
                          if (e3 = y2(e3 + y2(a5 + y2(m3[(Z4 = t5 + 516 | 0) + (c4[dr3 >> 2] << 2) >> 2] + y2(Mr2(t5, O3, V4) + Ur2(t5, O3, V4))))), Y3) {
                            if (T4 = Wr2(t5), x3 = Mr2(t5, 0, V4), T4 = y2(T4 + x3), x3 = y2(y2(m3[t5 + 520 >> 2] + y2(Mr2(t5, 0, V4) + Ur2(t5, 0, V4))) - T4), R5 = (t5 = R5 != R5) | T4 != T4 ? t5 ? T4 : R5 : Re(R5, T4), !((t5 = G4 != G4) | x3 != x3)) {
                              G4 = Re(G4, x3);
                              break a;
                            }
                            G4 = t5 ? x3 : G4;
                            break a;
                          }
                          if (!((T4 = y2(m3[Z4 + (c4[Q4 >> 2] << 2) >> 2] + y2(Mr2(t5, N3, V4) + Ur2(t5, N3, V4)))) != T4 | (t5 = B3 != B3))) {
                            B3 = Re(B3, T4);
                            break a;
                          }
                          B3 = t5 ? T4 : B3;
                          break a;
                        }
                        s4 && (t5 = c4[$3 >> 2] << 2, T4 = m3[t5 + (w3 + 24 | 0) >> 2], te3 = t5 + Z4 | 0, fe2 = y2(C4 + y2(T4 + zr2(r5, O3))), m3[te3 >> 2] = fe2);
                      }
                    if ((0 | g5) == (0 | (i4 = i4 + 1 | 0)))
                      break;
                  }
                  a5 = y2(G4 + R5);
                }
                if (R5 = Y3 ? a5 : B3, T4 = M4, $r3 || (a5 = (i4 = (a5 = ur2(r5, N3, y2(K3 + R5), Er3)) != a5) | (G4 = y2(y2(Br2(r5, N3, o4) + zr2(r5, N3)) + y2(Tr2(r5, N3, o4) + Qr2(r5, N3)))) != G4 ? i4 ? G4 : a5 : Re(a5, G4), T4 = y2(a5 - K3)), a5 = (i4 = (a5 = ur2(r5, N3, y2(K3 + (re3 ? M4 : R5)), Er3)) != a5) | (G4 = y2(y2(Br2(r5, N3, o4) + zr2(r5, N3)) + y2(Tr2(r5, N3, o4) + Qr2(r5, N3)))) != G4 ? i4 ? G4 : a5 : Re(a5, G4), G4 = y2(a5 - K3), !(X3 | !s4))
                  for (; ; ) {
                    if (i4 = c4[r5 + 556 >> 2], c4[r5 + 560 >> 2] - i4 >> 2 >>> 0 <= W3 >>> 0)
                      break e;
                    i4 = c4[i4 + (W3 << 2) >> 2];
                    a:
                      if (!(4194304 & (t5 = c4[i4 + 24 >> 2])))
                        if (131072 != (196608 & t5)) {
                          (t5 = t5 >>> 13 & 7) || (t5 = c4[r5 + 24 >> 2] >>> 10 & 7);
                          i: {
                            n: {
                              if (5 != (0 | t5)) {
                                if (4 == (0 | t5) && (ve(w3 + 24 | 0, i4, N3), t5 = 4, 3 != c4[w3 + 28 >> 2])) {
                                  if (de(w3 + 360 | 0, i4, N3), Z4 = c4[Q4 >> 2], 3 == c4[w3 + 364 >> 2])
                                    break n;
                                  R5 = m3[572 + (Z4 = i4 + (Z4 << 3) | 0) >> 2];
                                  t: {
                                    switch (0 | (t5 = c4[Z4 + 576 >> 2])) {
                                      case 0:
                                      case 3:
                                        break t;
                                    }
                                    if (!(1 != (0 | t5) | (B3 = m3[Z4 + 572 >> 2]) != B3)) {
                                      if (a5 = P3, R5 < y2(0))
                                        break t;
                                      break i;
                                    }
                                    if (a5 = P3, rr3 & !(R5 < y2(0)) | 2 != (0 | t5) | B3 != B3)
                                      break i;
                                  }
                                  R5 = m3[516 + (i4 + (c4[dr3 >> 2] << 2) | 0) >> 2], a5 = (a5 = m3[i4 + 224 >> 2]) == a5 ? y2(y2(Mr2(i4, N3, V4) + Ur2(i4, N3, V4)) + y2(q3 ? R5 * a5 : R5 / a5)) : G4, m3[w3 + 360 >> 2] = a5, te3 = w3, fe2 = y2(R5 + y2(Mr2(i4, O3, V4) + Ur2(i4, O3, V4))), m3[te3 + 24 >> 2] = fe2, c4[w3 + 356 >> 2] = 1, c4[w3 + 352 >> 2] = 1, Vr2(i4, O3, F3, V4, w3 + 356 | 0, w3 + 24 | 0), Vr2(i4, N3, M4, V4, w3 + 352 | 0, w3 + 360 | 0), R5 = m3[w3 + 360 >> 2], B3 = m3[w3 + 24 >> 2], a5 = (t5 = O3 >>> 0 > 1) ? R5 : B3, or2(i4, R5 = t5 ? B3 : R5, a5, J3, !((t5 = 0 != (0 | nr3) & 512 != (896 & c4[r5 + 24 >> 2])) & q3 | R5 != R5), (q3 | !t5) & a5 == a5, V4, U3, 1, 2, A4, l4, h4, p3), a5 = P3;
                                  break i;
                                }
                              } else
                                t5 = 8 & c4[r5 + 24 >> 2] ? 5 : 1;
                              Z4 = c4[Q4 >> 2];
                            }
                            if (a5 = m3[516 + ((Z4 << 2) + i4 | 0) >> 2], R5 = Mr2(i4, N3, V4), B3 = Ur2(i4, N3, V4), ve(w3 + 24 | 0, i4, N3), R5 = y2(T4 - y2(a5 + y2(R5 + B3))), 3 != c4[w3 + 28 >> 2] || (de(w3 + 360 | 0, i4, N3), 3 != c4[w3 + 364 >> 2])) {
                              if (de(w3 + 24 | 0, i4, N3), a5 = P3, 3 != c4[w3 + 28 >> 2])
                                if (ve(w3 + 24 | 0, i4, N3), 3 != c4[w3 + 28 >> 2]) {
                                  switch (t5 - 1 | 0) {
                                    case 1:
                                      a5 = y2(P3 + y2(R5 * y2(0.5)));
                                      break i;
                                    case 0:
                                      break i;
                                  }
                                  a5 = y2(P3 + R5);
                                } else
                                  a5 = y2(P3 + (fe2 = y2(0), oe2 = Re(R5, y2(0)), (te3 = R5 != R5) ? fe2 : oe2));
                            } else
                              a5 = y2(R5 * y2(0.5)), a5 = y2(P3 + (fe2 = y2(0), oe2 = Re(a5, y2(0)), (te3 = a5 != a5) ? fe2 : oe2));
                          }
                          i4 = i4 + (c4[H4 >> 2] << 2) | 0, m3[i4 + 228 >> 2] = a5 + y2(br3 + m3[i4 + 228 >> 2]);
                        } else {
                          if (t5 = c4[H4 >> 2], se(i4, N3) && (a5 = y2(y2(Lr2(i4, N3, M4) + zr2(r5, N3)) + Mr2(i4, N3, V4)), m3[228 + (i4 + (t5 << 2) | 0) >> 2] = a5, a5 == a5))
                            break a;
                          te3 = i4 + (t5 << 2) | 0, fe2 = y2(zr2(r5, N3) + Mr2(i4, N3, V4)), m3[te3 + 228 >> 2] = fe2;
                        }
                    if ((0 | (W3 = W3 + 1 | 0)) == (0 | g5))
                      break;
                  }
                if (a5 = y2((S4 ? jr3 : y2(0)) + G4), Nr3 = (i4 = Nr3 != Nr3) | (e3 = y2(Gr3 + e3)) != e3 ? i4 ? e3 : Nr3 : Re(Nr3, e3), br3 = y2(br3 + a5), i4 = S4 + 1 | 0, W3 = g5, !(g5 >>> 0 < er4 >>> 0))
                  break;
              }
              a:
                if (s4 && (nr3 || Jr2(r5))) {
                  R5 = y2(0);
                  i: {
                    n:
                      if (M4 == M4) {
                        e3 = y2(M4 - br3);
                        t:
                          switch ((c4[r5 + 24 >> 2] >>> 7 & 7) - 2 | 0) {
                            case 0:
                              P3 = y2(P3 + y2(e3 * y2(0.5)));
                              break n;
                            case 2:
                              if (!(M4 > br3))
                                break n;
                              R5 = y2(e3 / y2(i4 >>> 0));
                              break n;
                            case 5:
                              if (M4 > br3) {
                                if (P3 = y2(P3 + y2(e3 / y2(i4 << 1 >>> 0))), i4 >>> 0 < 2)
                                  break n;
                                R5 = y2(e3 / y2(i4 >>> 0));
                                break i;
                              }
                              P3 = y2(P3 + y2(e3 * y2(0.5)));
                              break n;
                            case 4:
                              if (!(M4 > br3) | i4 >>> 0 < 2)
                                break n;
                              R5 = y2(e3 / y2(S4 >>> 0));
                              break i;
                            case 1:
                              break t;
                            default:
                              break n;
                          }
                        P3 = y2(P3 + e3);
                      }
                    if (!i4)
                      break a;
                  }
                  for (Z4 = 0, i4 = 0, t5 = 0; ; ) {
                    if (B3 = y2(0), a5 = y2(0), e3 = y2(0), G4 = y2(0), g5 = i4, i4 >>> 0 < er4 >>> 0) {
                      i: {
                        for (; ; ) {
                          if (t5 = c4[r5 + 556 >> 2], c4[r5 + 560 >> 2] - t5 >> 2 >>> 0 <= g5 >>> 0)
                            break e;
                          if (W3 = c4[t5 + (g5 << 2) >> 2], !(4194304 & (X3 = c4[W3 + 24 >> 2]) | 131072 == (196608 & X3))) {
                            if (t5 = g5, c4[W3 + 548 >> 2] != (0 | Z4))
                              break i;
                            (e3 = m3[516 + (W3 + (c4[Q4 >> 2] << 2) | 0) >> 2]) >= y2(0) && (a5 = (t5 = a5 != a5) | (e3 = y2(e3 + y2(Mr2(W3, N3, V4) + Ur2(W3, N3, V4)))) != e3 ? t5 ? e3 : a5 : Re(a5, e3)), (t5 = X3 >>> 13 & 7) || (t5 = c4[r5 + 24 >> 2] >>> 10 & 7), !(8 & v3[r5 + 24 | 0]) | 5 != (0 | t5) || (e3 = Wr2(W3), T4 = Mr2(W3, 0, V4), e3 = y2(e3 + T4), T4 = y2(y2(m3[W3 + 520 >> 2] + y2(Mr2(W3, 0, V4) + Ur2(W3, 0, V4))) - e3), t5 = a5 != a5, G4 = (W3 = G4 != G4) | e3 != e3 ? W3 ? e3 : G4 : Re(G4, e3), B3 = (W3 = B3 != B3) | T4 != T4 ? W3 ? T4 : B3 : Re(B3, T4), a5 = t5 | (e3 = y2(G4 + B3)) != e3 ? t5 ? e3 : a5 : Re(a5, e3));
                          }
                          if ((0 | er4) == (0 | (g5 = g5 + 1 | 0)))
                            break;
                        }
                        t5 = er4;
                      }
                      e3 = a5;
                    }
                    if (T4 = y2(P3 + (Z4 ? jr3 : y2(0))), a5 = y2(R5 + e3), P3 = y2(T4 + a5), i4 >>> 0 < t5 >>> 0)
                      for (_3 = y2(T4 + G4); ; ) {
                        if (g5 = c4[r5 + 556 >> 2], c4[r5 + 560 >> 2] - g5 >> 2 >>> 0 <= i4 >>> 0)
                          break e;
                        W3 = c4[g5 + (i4 << 2) >> 2];
                        i:
                          if (!(4194304 & (g5 = c4[W3 + 24 >> 2]) | 131072 == (196608 & g5))) {
                            (g5 = g5 >>> 13 & 7) || (g5 = c4[r5 + 24 >> 2] >>> 10 & 7);
                            n: {
                              t:
                                switch (g5 - 1 | 0) {
                                  case 4:
                                    if (8 & v3[r5 + 24 | 0])
                                      break n;
                                  case 0:
                                    e3 = Mr2(W3, N3, V4), m3[228 + (W3 + (c4[H4 >> 2] << 2) | 0) >> 2] = T4 + e3;
                                    break i;
                                  case 2:
                                    e3 = Ur2(W3, N3, V4), m3[(g5 = W3 + 228 | 0) + (c4[H4 >> 2] << 2) >> 2] = y2(P3 - e3) - m3[288 + (g5 + (c4[Q4 >> 2] << 2) | 0) >> 2];
                                    break i;
                                  case 1:
                                    m3[(g5 = W3 + 228 | 0) + (c4[H4 >> 2] << 2) >> 2] = T4 + y2(y2(a5 - m3[288 + (g5 + (c4[Q4 >> 2] << 2) | 0) >> 2]) * y2(0.5));
                                    break i;
                                  case 3:
                                    break t;
                                  default:
                                    break i;
                                }
                              e3 = Mr2(W3, N3, V4), m3[228 + (W3 + (c4[H4 >> 2] << 2) | 0) >> 2] = T4 + e3, X3 = W3 + (c4[Q4 >> 2] << 3) | 0, e3 = m3[(g5 = X3) + 572 >> 2];
                              t: {
                                switch (0 | (g5 = c4[g5 + 576 >> 2])) {
                                  case 0:
                                  case 3:
                                    break t;
                                }
                                if (!(1 != (0 | g5) | (G4 = m3[X3 + 572 >> 2]) != G4)) {
                                  if (e3 < y2(0))
                                    break t;
                                  break i;
                                }
                                if (rr3 & !(e3 < y2(0)) | 2 != (0 | g5) | G4 != G4)
                                  break i;
                              }
                              O3 >>> 0 >= 2 ? (B3 = a5, e3 = m3[W3 + 516 >> 2], G4 = y2(e3 + y2(Mr2(W3, O3, V4) + Ur2(W3, O3, V4)))) : (B3 = y2(m3[W3 + 520 >> 2] + y2(Mr2(W3, N3, V4) + Ur2(W3, N3, V4))), e3 = m3[W3 + 516 >> 2], G4 = a5);
                              t: {
                                f: {
                                  if (!(G4 != G4 | e3 != e3)) {
                                    if (y2(E3(y2(G4 - e3))) < y2(9999999747378752e-20))
                                      break f;
                                    break t;
                                  }
                                  if (G4 == G4 | e3 == e3)
                                    break t;
                                }
                                if (!((g5 = (e3 = m3[W3 + 520 >> 2]) != e3) | B3 != B3)) {
                                  if (!(y2(E3(y2(B3 - e3))) < y2(9999999747378752e-20)))
                                    break t;
                                  break i;
                                }
                                if (B3 != B3 && g5)
                                  break i;
                              }
                              or2(W3, G4, B3, J3, 1, 1, V4, U3, 1, 3, A4, l4, h4, p3);
                              break i;
                            }
                            te3 = W3, fe2 = y2(y2(_3 - Wr2(W3)) + Lr2(W3, 0, M4)), m3[te3 + 232 >> 2] = fe2;
                          }
                        if ((0 | t5) == (0 | (i4 = i4 + 1 | 0)))
                          break;
                      }
                    if (g5 = (0 | Z4) != (0 | S4), Z4 = Z4 + 1 | 0, i4 = t5, !g5)
                      break;
                  }
                }
              Z4 = r5 + 516 | 0, e3 = (i4 = (e3 = ur2(r5, 2, Yr3, o4)) != e3) | (a5 = y2(y2(Br2(r5, 2, o4) + zr2(r5, 2)) + y2(Tr2(r5, 2, o4) + Qr2(r5, 2)))) != a5 ? i4 ? a5 : e3 : Re(e3, a5), m3[Z4 >> 2] = e3, e3 = (i4 = (e3 = ur2(r5, 0, Hr3, u3)) != e3) | (a5 = y2(y2(Br2(r5, 0, o4) + zr2(r5, 0)) + y2(Tr2(r5, 0, o4) + Qr2(r5, 0)))) != a5 ? i4 ? a5 : e3 : Re(e3, a5), m3[r5 + 520 >> 2] = e3;
              a: {
                i:
                  if (cr3 && 2 == (0 | (i4 = c4[r5 + 24 >> 2] >>> 20 & 3)) | 2 != (0 | cr3)) {
                    if (2 != (0 | cr3) | 2 != (0 | i4))
                      break a;
                    e3 = (i4 = (e3 = (i4 = (a5 = y2(ir3 + F3)) != a5) | (e3 = ur2(r5, O3, Nr3, hr3)) != e3 ? i4 ? e3 : a5 : ge(a5, e3)) != e3) | ir3 != ir3 ? i4 ? ir3 : e3 : Re(e3, ir3);
                  } else {
                    if (!((i4 = (e3 = ur2(r5, O3, Nr3, hr3)) != e3) | (a5 = y2(y2(Br2(r5, O3, o4) + zr2(r5, O3)) + y2(Tr2(r5, O3, o4) + Qr2(r5, O3)))) != a5)) {
                      e3 = Re(e3, a5);
                      break i;
                    }
                    e3 = i4 ? a5 : e3;
                  }
                m3[Z4 + (c4[dr3 >> 2] << 2) >> 2] = e3;
              }
              a: {
                i:
                  if (L4 && (t5 = 2 != (0 | L4)) | 2 == (0 | (i4 = c4[r5 + 24 >> 2] >>> 20 & 3))) {
                    if (t5 | 2 != (0 | i4))
                      break a;
                    e3 = (i4 = (e3 = (i4 = (a5 = y2(K3 + M4)) != a5) | (e3 = ur2(r5, N3, y2(K3 + br3), Er3)) != e3 ? i4 ? e3 : a5 : ge(a5, e3)) != e3) | K3 != K3 ? i4 ? K3 : e3 : Re(e3, K3);
                  } else {
                    if (!((i4 = (e3 = ur2(r5, N3, y2(K3 + br3), Er3)) != e3) | (a5 = y2(y2(Br2(r5, N3, o4) + zr2(r5, N3)) + y2(Tr2(r5, N3, o4) + Qr2(r5, N3)))) != a5)) {
                      e3 = Re(e3, a5);
                      break i;
                    }
                    e3 = i4 ? a5 : e3;
                  }
                m3[Z4 + (c4[Q4 >> 2] << 2) >> 2] = e3;
              }
              if (s4) {
                if (i4 = c4[r5 + 560 >> 2], W3 = c4[r5 + 556 >> 2], 524288 == (786432 & c4[r5 + 24 >> 2])) {
                  for (t5 = er4 >>> 0 <= 1 ? 1 : er4, s4 = i4 - W3 >> 2, i4 = 0; g5 = 0, g5 = i4 >>> 0 < s4 >>> 0 ? c4[(i4 << 2) + W3 >> 2] : g5, 131072 != (196608 & c4[g5 + 24 >> 2]) && (X3 = (g5 = g5 + 228 | 0) + (c4[H4 >> 2] << 2) | 0, S4 = c4[Q4 >> 2] << 2, m3[X3 >> 2] = y2(m3[S4 + Z4 >> 2] - m3[X3 >> 2]) - m3[288 + (g5 + S4 | 0) >> 2]), (0 | t5) != (0 | (i4 = i4 + 1 | 0)); )
                    ;
                  W3 = c4[r5 + 556 >> 2], i4 = c4[r5 + 560 >> 2];
                }
                if ((0 | i4) != (0 | W3))
                  for (S4 = 0 != (0 | (O3 >>> 0 > 1 ? cr3 : n3)); ; ) {
                    s4 = c4[W3 >> 2];
                    a:
                      if (131072 == (4390912 & c4[s4 + 24 >> 2])) {
                        a5 = V4, F3 = U3, v3[c4[r5 + 568 >> 2] + 21 | 0] && (F3 = m3[r5 + 520 >> 2], a5 = m3[r5 + 516 >> 2]), n3 = c4[r5 + 24 >> 2] >>> 2 & 3;
                        i: {
                          n: {
                            if (2 == (0 | J3)) {
                              t5 = 0, g5 = 3;
                              t:
                                switch (n3 - 2 | 0) {
                                  case 0:
                                    break i;
                                  case 1:
                                    break t;
                                  default:
                                    break n;
                                }
                              g5 = 2;
                              break i;
                            }
                            if (t5 = 0, !(n3 >>> 0 <= 1)) {
                              g5 = n3;
                              break i;
                            }
                          }
                          g5 = n3, t5 = lr3;
                        }
                        u3 = y2(Mr2(s4, 2, a5) + Ur2(s4, 2, a5)), R5 = Mr2(s4, 0, a5), B3 = Ur2(s4, 0, a5), e3 = m3[s4 + 572 >> 2];
                        i: {
                          n: {
                            switch (0 | (n3 = c4[s4 + 576 >> 2])) {
                              case 0:
                              case 3:
                                break n;
                            }
                            t: {
                              if (!(1 != (0 | n3) | (o4 = m3[s4 + 572 >> 2]) != o4)) {
                                if (G4 = e3, !(e3 < y2(0)))
                                  break t;
                                break n;
                              }
                              f: {
                                if (2 != (0 | n3) | o4 != o4) {
                                  G4 = y2(NaN);
                                  o:
                                    switch (n3 - 1 | 0) {
                                      case 1:
                                        break f;
                                      case 0:
                                        break o;
                                      default:
                                        break t;
                                    }
                                  G4 = e3;
                                  break t;
                                }
                                if (a5 != a5 | e3 < y2(0))
                                  break n;
                              }
                              G4 = y2(y2(a5 * e3) * y2(0.009999999776482582));
                            }
                            G4 = y2(u3 + G4);
                            break i;
                          }
                          G4 = y2(NaN), se(s4, 2) && be(s4, 2) && (G4 = (n3 = (e3 = ur2(s4, 2, y2(y2(m3[r5 + 516 >> 2] - y2(zr2(r5, 2) + Qr2(r5, 2))) - y2(Lr2(s4, 2, a5) + Or2(s4, 2, a5))), a5)) != e3) | (o4 = y2(y2(Br2(s4, 2, a5) + zr2(s4, 2)) + y2(Tr2(s4, 2, a5) + Qr2(s4, 2)))) != o4 ? n3 ? o4 : e3 : Re(e3, o4));
                        }
                        B3 = y2(R5 + B3);
                        i: {
                          n: {
                            t: {
                              f: {
                                o: {
                                  c: {
                                    u: {
                                      X3 = G4 != G4, o4 = m3[s4 + 580 >> 2];
                                      b: {
                                        s: {
                                          switch (0 | (n3 = c4[s4 + 584 >> 2])) {
                                            case 0:
                                            case 3:
                                              break s;
                                          }
                                          A: {
                                            if (!(1 != (0 | n3) | (e3 = m3[s4 + 580 >> 2]) != e3)) {
                                              if (!((e3 = o4) < y2(0)))
                                                break A;
                                              break s;
                                            }
                                            k: {
                                              if (2 != (0 | n3) | e3 != e3) {
                                                e3 = y2(NaN);
                                                l:
                                                  switch (n3 - 1 | 0) {
                                                    case 1:
                                                      break k;
                                                    case 0:
                                                      break l;
                                                    default:
                                                      break A;
                                                  }
                                                e3 = o4;
                                                break A;
                                              }
                                              if (F3 != F3 | o4 < y2(0))
                                                break s;
                                            }
                                            e3 = y2(y2(F3 * o4) * y2(0.009999999776482582));
                                          }
                                          e3 = y2(B3 + e3);
                                          break b;
                                        }
                                        if (!se(s4, 0) || !be(s4, 0)) {
                                          if (e3 = y2(NaN), G4 == G4)
                                            break u;
                                          break t;
                                        }
                                        e3 = (n3 = (e3 = ur2(s4, 0, y2(y2(m3[r5 + 520 >> 2] - y2(zr2(r5, 0) + Qr2(r5, 0))) - y2(Lr2(s4, 0, F3) + Or2(s4, 0, F3))), F3)) != e3) | (o4 = y2(y2(Br2(s4, 0, a5) + zr2(s4, 0)) + y2(Tr2(s4, 0, a5) + Qr2(s4, 0)))) != o4 ? n3 ? o4 : e3 : Re(e3, o4);
                                      }
                                      if ((0 | X3) == (e3 != e3 | 0))
                                        break o;
                                      if ((R5 = m3[s4 + 224 >> 2]) != R5)
                                        break o;
                                      if (G4 != G4) {
                                        G4 = y2(y2(y2(e3 - B3) * R5) + u3);
                                        break o;
                                      }
                                      if (e3 == e3)
                                        break o;
                                      break c;
                                    }
                                    if ((R5 = m3[s4 + 224 >> 2]) != R5)
                                      break f;
                                  }
                                  e3 = y2(B3 + y2(y2(G4 - u3) / R5));
                                }
                                if (G4 != G4)
                                  break t;
                                if (e3 == e3)
                                  break i;
                              }
                              n3 = 0;
                              break n;
                            }
                            n3 = 1;
                          }
                          X3 = a5 > y2(0), Y3 = n3 & S4 & g5 >>> 0 < 2, n3 ^= 1, or2(s4, o4 = Y3 && X3 ? a5 : G4, e3, J3, Y3 && X3 ? 2 : n3, e3 == e3, o4, e3, 0, 6, A4, l4, h4, p3), G4 = y2(m3[s4 + 516 >> 2] + Ue(s4, 2, a5)), e3 = y2(m3[s4 + 520 >> 2] + Ue(s4, 0, a5));
                        }
                        or2(s4, G4, e3, J3, 1, 1, G4, e3, 1, 1, A4, l4, h4, p3), u3 = (n3 = g5 >>> 0 < 2) ? a5 : F3, X3 = c4[r5 + 568 >> 2], o4 = v3[X3 + 22 | 0] ? u3 : a5;
                        i: {
                          if (!be(s4, g5) || se(s4, g5)) {
                            if (se(s4, g5) | 16 != (112 & c4[r5 + 24 >> 2])) {
                              if (se(s4, g5) | 32 != (112 & c4[r5 + 24 >> 2])) {
                                if (!v3[X3 + 21 | 0])
                                  break i;
                                if (!se(s4, g5))
                                  break i;
                                e3 = m3[Z4 + (c4[4252 + (g5 << 2) >> 2] << 2) >> 2], e3 = y2(y2(Lr2(s4, g5, e3) + zr2(r5, g5)) + Mr2(s4, g5, e3));
                              } else
                                n3 = c4[4252 + (g5 << 2) >> 2] << 2, e3 = y2(m3[n3 + Z4 >> 2] - m3[516 + (n3 + s4 | 0) >> 2]);
                            } else
                              n3 = c4[4252 + (g5 << 2) >> 2] << 2, e3 = y2(y2(m3[n3 + Z4 >> 2] - m3[516 + (n3 + s4 | 0) >> 2]) * y2(0.5));
                          } else
                            Y3 = c4[4252 + (g5 << 2) >> 2] << 2, e3 = y2(y2(y2(y2(m3[Y3 + Z4 >> 2] - m3[516 + (s4 + Y3 | 0) >> 2]) - Qr2(r5, g5)) - Ur2(s4, g5, o4)) - Or2(s4, g5, n3 ? F3 : a5));
                          m3[228 + (s4 + (c4[4220 + (g5 << 2) >> 2] << 2) | 0) >> 2] = e3;
                        }
                        i:
                          if (!be(s4, t5) || se(s4, t5)) {
                            if (se(s4, t5) || ((n3 = c4[s4 + 24 >> 2] >>> 13 & 7) || (n3 = c4[r5 + 24 >> 2] >>> 10 & 7), 2 != (0 | n3))) {
                              n:
                                if (!se(s4, t5)) {
                                  g5 = c4[s4 + 24 >> 2] >>> 13 & 7, n3 = c4[r5 + 24 >> 2];
                                  t: {
                                    if (!(5 != (0 | (g5 = g5 || n3 >>> 10 & 7)) | 8 & n3)) {
                                      if (524288 == (786432 & n3))
                                        break t;
                                      break n;
                                    }
                                    if ((524288 == (786432 & n3) | 0) == (3 == (0 | g5) | 0))
                                      break n;
                                  }
                                  n3 = c4[4252 + (t5 << 2) >> 2] << 2, e3 = y2(m3[n3 + Z4 >> 2] - m3[516 + (n3 + s4 | 0) >> 2]);
                                  break i;
                                }
                              if (!v3[X3 + 21 | 0])
                                break a;
                              if (!se(s4, t5))
                                break a;
                              e3 = m3[Z4 + (c4[4252 + (t5 << 2) >> 2] << 2) >> 2], e3 = y2(y2(Lr2(s4, t5, e3) + zr2(r5, t5)) + Mr2(s4, t5, e3));
                            } else
                              n3 = c4[4252 + (t5 << 2) >> 2] << 2, e3 = y2(y2(m3[n3 + Z4 >> 2] - m3[516 + (n3 + s4 | 0) >> 2]) * y2(0.5));
                          } else
                            n3 = c4[4252 + (t5 << 2) >> 2] << 2, e3 = y2(y2(y2(y2(m3[n3 + Z4 >> 2] - m3[516 + (n3 + s4 | 0) >> 2]) - Qr2(r5, t5)) - Ur2(s4, t5, o4)) - Or2(s4, t5, u3));
                        m3[228 + (s4 + (c4[4220 + (t5 << 2) >> 2] << 2) | 0) >> 2] = e3;
                      }
                    if ((0 | (W3 = W3 + 4 | 0)) == (0 | i4))
                      break;
                  }
                if (1 & (N3 | O3))
                  for (t5 = 1 & N3, s4 = 1 & O3, A4 = er4 >>> 0 <= 1 ? 1 : er4, l4 = 4236 + (N3 << 2) | 0, h4 = 4236 + (O3 << 2) | 0, p3 = c4[r5 + 556 >> 2], N3 = c4[r5 + 560 >> 2] - p3 >> 2, i4 = 0; ; ) {
                    if ((0 | i4) == (0 | N3))
                      break e;
                    if (r5 = c4[p3 + (i4 << 2) >> 2], 64 & v3[r5 + 26 | 0] || (s4 && (n3 = r5 + 228 | 0, g5 = c4[dr3 >> 2] << 2, m3[n3 + (c4[h4 >> 2] << 2) >> 2] = y2(m3[g5 + Z4 >> 2] - m3[288 + (n3 + g5 | 0) >> 2]) - m3[n3 + (c4[$3 >> 2] << 2) >> 2]), t5 && (r5 = r5 + 228 | 0, n3 = c4[Q4 >> 2] << 2, m3[r5 + (c4[l4 >> 2] << 2) >> 2] = y2(m3[n3 + Z4 >> 2] - m3[288 + (r5 + n3 | 0) >> 2]) - m3[r5 + (c4[H4 >> 2] << 2) >> 2])), (0 | A4) == (0 | (i4 = i4 + 1 | 0)))
                      break;
                  }
              }
              if (!D2)
                break r;
              gr2(D2);
              break r;
            }
            I2(), k2();
          }
          ar3 = w3 + 384 | 0;
        }
        function tr2() {
          var r5 = 0, e3 = 0;
          T3(6952, 6953, 6954, 0, 4284, 17, 4287, 0, 4287, 0, 2528, 4289, 18), r5 = ye(8), c4[r5 >> 2] = 8, c4[r5 + 4 >> 2] = 1, Z3(6952, 2873, 6, 4304, 4328, 19, 0 | r5, 1), T3(6956, 6957, 6958, 6952, 4284, 20, 4284, 21, 4284, 22, 2e3, 4289, 23), r5 = ye(4), c4[r5 >> 2] = 24, Z3(6956, 2358, 2, 4336, 4344, 25, 0 | r5, 0), V3(6952, 1397, 2, 4348, 4356, 26, 27), V3(6952, 2978, 3, 4436, 4448, 28, 29), T3(6976, 6977, 6978, 0, 4284, 30, 4287, 0, 4287, 0, 2544, 4289, 31), r5 = ye(8), c4[r5 >> 2] = 8, c4[r5 + 4 >> 2] = 1, Z3(6976, 3244, 2, 4456, 4344, 32, 0 | r5, 1), T3(6979, 6980, 6981, 6976, 4284, 33, 4284, 34, 4284, 35, 2023, 4289, 36), r5 = ye(4), c4[r5 >> 2] = 37, Z3(6979, 2358, 2, 4464, 4344, 38, 0 | r5, 0), V3(6976, 1397, 2, 4472, 4356, 39, 40), V3(6976, 2978, 3, 4436, 4448, 28, 41), T3(6982, 6983, 6984, 0, 4284, 42, 4287, 0, 4287, 0, 2812, 4289, 43), Y2(6982, 1, 4520, 4284, 44, 45), V3(6982, 2866, 1, 4520, 4284, 44, 45), V3(6982, 1128, 2, 4524, 4344, 46, 47), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 48, Z3(6982, 3185, 4, 4544, 4560, 49, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 50, Z3(6982, 1980, 3, 4568, 4580, 51, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 52, Z3(6982, 1951, 3, 4588, 4600, 53, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 54, Z3(6982, 1799, 3, 4588, 4600, 53, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 55, Z3(6982, 3215, 3, 4608, 4448, 56, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 57, Z3(6982, 1925, 2, 4620, 4356, 58, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 59, Z3(6982, 1784, 2, 4620, 4356, 58, 0 | r5, 0), F2(6985, 1270, 4628, 60, 4289, 61), Be(1731, 0), Be(1611, 8), Be(2144, 16), Be(2454, 24), Be(2560, 32), Be(1617, 40), _2(6985), F2(6955, 2849, 4628, 62, 4289, 63), Ve(2560, 0), Ve(1617, 8), _2(6955), F2(6986, 2860, 4628, 64, 4289, 65), r5 = ye(4), c4[r5 >> 2] = 8, e3 = ye(4), c4[e3 >> 2] = 8, O2(6986, 2854, 7018, 4630, 66, 0 | r5, 7018, 4634, 67, 0 | e3), r5 = ye(4), c4[r5 >> 2] = 0, e3 = ye(4), c4[e3 >> 2] = 0, O2(6986, 1606, 7011, 4356, 68, 0 | r5, 7011, 4600, 69, 0 | e3), _2(6986), T3(6987, 6988, 6989, 0, 4284, 70, 4287, 0, 4287, 0, 2973, 4289, 71), Y2(6987, 1, 4640, 4284, 72, 73), V3(6987, 1592, 1, 4640, 4284, 72, 73), V3(6987, 2802, 2, 4644, 4356, 74, 75), V3(6987, 1128, 2, 4652, 4344, 76, 77), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 78, Z3(6987, 1752, 2, 4652, 4344, 79, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 80, Z3(6987, 2956, 3, 4660, 4600, 81, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 82, Z3(6987, 2881, 3, 4672, 4600, 83, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 84, Z3(6987, 2334, 4, 4688, 4704, 85, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 86, Z3(6987, 1484, 4, 4688, 4704, 85, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 87, Z3(6987, 1355, 3, 4672, 4600, 83, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 88, Z3(6987, 1817, 3, 4672, 4600, 83, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 89, Z3(6987, 2823, 3, 4672, 4600, 83, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 90, Z3(6987, 2378, 3, 4672, 4600, 83, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 91, Z3(6987, 2163, 3, 4672, 4600, 83, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 92, Z3(6987, 1319, 3, 4672, 4600, 83, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 93, Z3(6987, 2412, 4, 4688, 4704, 85, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 94, Z3(6987, 1503, 4, 4688, 4704, 85, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 95, Z3(6987, 2235, 3, 4672, 4600, 83, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 96, Z3(6987, 1219, 3, 4672, 4600, 83, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 97, Z3(6987, 1136, 3, 4672, 4600, 83, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 98, Z3(6987, 1158, 3, 4712, 4634, 99, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 100, Z3(6987, 1845, 3, 4712, 4634, 99, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 101, Z3(6987, 1464, 3, 4712, 4634, 99, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 102, Z3(6987, 2218, 2, 4652, 4344, 79, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 103, Z3(6987, 1195, 3, 4712, 4634, 99, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 104, Z3(6987, 2500, 3, 4712, 4634, 99, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 105, Z3(6987, 2590, 3, 4712, 4634, 99, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 106, Z3(6987, 1539, 3, 4712, 4634, 99, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 107, Z3(6987, 2249, 2, 4652, 4344, 79, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 108, Z3(6987, 1650, 3, 4712, 4634, 99, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 109, Z3(6987, 1427, 3, 4712, 4634, 99, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 110, Z3(6987, 2204, 2, 4652, 4344, 79, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 111, Z3(6987, 2608, 3, 4712, 4634, 99, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 112, Z3(6987, 1555, 3, 4712, 4634, 99, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 113, Z3(6987, 1670, 3, 4712, 4634, 99, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 114, Z3(6987, 1444, 3, 4712, 4634, 99, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 115, Z3(6987, 2566, 3, 4712, 4634, 99, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 116, Z3(6987, 1520, 3, 4712, 4634, 99, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 117, Z3(6987, 1624, 3, 4712, 4634, 99, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 118, Z3(6987, 1407, 3, 4712, 4634, 99, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 119, Z3(6987, 2304, 3, 4712, 4634, 99, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 120, Z3(6987, 2092, 4, 4688, 4704, 85, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 121, Z3(6987, 2718, 4, 4688, 4704, 85, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 122, Z3(6987, 1574, 4, 4688, 4704, 85, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 123, Z3(6987, 2187, 4, 4688, 4704, 85, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 124, Z3(6987, 2897, 2, 4724, 4356, 125, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 126, Z3(6987, 2346, 3, 4732, 4448, 127, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 128, Z3(6987, 1371, 2, 4724, 4356, 125, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 129, Z3(6987, 1831, 2, 4724, 4356, 125, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 130, Z3(6987, 2836, 2, 4724, 4356, 125, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 131, Z3(6987, 2395, 2, 4724, 4356, 125, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 132, Z3(6987, 2175, 2, 4724, 4356, 125, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 133, Z3(6987, 1337, 2, 4724, 4356, 125, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 134, Z3(6987, 2422, 3, 4732, 4448, 127, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 135, Z3(6987, 1858, 2, 4744, 4356, 136, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 137, Z3(6987, 1207, 2, 4752, 4630, 138, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 139, Z3(6987, 2514, 2, 4752, 4630, 138, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 140, Z3(6987, 2599, 2, 4744, 4356, 136, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 141, Z3(6987, 1660, 2, 4744, 4356, 136, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 142, Z3(6987, 2620, 2, 4744, 4356, 136, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 143, Z3(6987, 1683, 2, 4744, 4356, 136, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 144, Z3(6987, 2578, 2, 4744, 4356, 136, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 145, Z3(6987, 1637, 2, 4744, 4356, 136, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 146, Z3(6987, 2319, 2, 4752, 4630, 138, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 147, Z3(6987, 2102, 3, 4760, 4772, 148, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 149, Z3(6987, 1231, 2, 4724, 4356, 125, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 150, Z3(6987, 1147, 2, 4724, 4356, 125, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 151, Z3(6987, 2729, 3, 4732, 4448, 127, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 152, Z3(6987, 2194, 3, 4780, 4792, 153, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 154, Z3(6987, 2985, 4, 4800, 4560, 155, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 156, Z3(6987, 3006, 3, 4816, 4600, 157, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 158, Z3(6987, 1292, 2, 4828, 4356, 159, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 160, Z3(6987, 1387, 2, 4836, 4356, 161, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 162, Z3(6987, 2997, 3, 4844, 4448, 163, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 164, Z3(6987, 2913, 2, 4856, 4356, 165, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 166, Z3(6987, 2933, 3, 4864, 4600, 167, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 168, Z3(6987, 3308, 3, 4876, 4600, 169, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 170, Z3(6987, 3306, 2, 4652, 4344, 79, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 171, Z3(6987, 3325, 3, 4888, 4600, 172, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 173, Z3(6987, 3323, 2, 4652, 4344, 79, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 174, Z3(6987, 1118, 2, 4652, 4344, 79, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 175, Z3(6987, 1110, 2, 4900, 4356, 176, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 177, Z3(6987, 1243, 5, 4912, 4932, 178, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 179, Z3(6987, 1736, 2, 4752, 4630, 138, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 180, Z3(6987, 1714, 2, 4752, 4630, 138, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 181, Z3(6987, 2148, 2, 4752, 4630, 138, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 182, Z3(6987, 2461, 2, 4752, 4630, 138, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 183, Z3(6987, 2632, 2, 4752, 4630, 138, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 184, Z3(6987, 1696, 2, 4752, 4630, 138, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 185, Z3(6987, 1259, 2, 4940, 4356, 186, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 187, Z3(6987, 2432, 3, 4760, 4772, 148, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 188, Z3(6987, 2112, 3, 4760, 4772, 148, 0 | r5, 0), r5 = ye(8), c4[r5 + 4 >> 2] = 0, c4[r5 >> 2] = 189, Z3(6987, 2740, 3, 4760, 4772, 148, 0 | r5, 0);
        }
        function fr2(r5, e3, a5, i4, n3, t5, u3) {
          var b3, s4, A4, k3 = 0, l4 = 0, d3 = 0, h4 = 0, p3 = 0, m4 = 0, y3 = 0, E4 = 0, G4 = 0, R5 = 0, g5 = 0, Z4 = 0, W3 = 0, V4 = 0, B3 = 0, T4 = 0, I3 = 0;
          ar3 = b3 = ar3 - 80 | 0, c4[b3 + 76 >> 2] = e3, A4 = b3 + 55 | 0, s4 = b3 + 56 | 0;
          r: {
            e: {
              a: {
                i: {
                  n:
                    for (; ; ) {
                      if (d3 = e3, (2147483647 ^ E4) < (0 | k3))
                        break i;
                      E4 = k3 + E4 | 0;
                      t: {
                        f: {
                          o: {
                            if (l4 = v3[0 | (k3 = d3)])
                              for (; ; ) {
                                c: {
                                  u:
                                    if (e3 = 255 & l4) {
                                      if (37 != (0 | e3))
                                        break c;
                                      for (l4 = k3; ; ) {
                                        if (37 != v3[l4 + 1 | 0]) {
                                          e3 = l4;
                                          break u;
                                        }
                                        if (k3 = k3 + 1 | 0, h4 = v3[l4 + 2 | 0], l4 = e3 = l4 + 2 | 0, 37 != (0 | h4))
                                          break;
                                      }
                                    } else
                                      e3 = k3;
                                  if ((0 | (k3 = k3 - d3 | 0)) > (0 | (B3 = 2147483647 ^ E4)))
                                    break i;
                                  if (r5 && Pr2(r5, d3, k3), k3)
                                    continue n;
                                  c4[b3 + 76 >> 2] = e3, k3 = e3 + 1 | 0, R5 = -1, !xe(l4 = f3[e3 + 1 | 0]) | 36 != v3[e3 + 2 | 0] || (R5 = l4 - 48 | 0, Z4 = 1, k3 = e3 + 3 | 0), c4[b3 + 76 >> 2] = k3, y3 = 0;
                                  u:
                                    if ((e3 = (l4 = f3[0 | k3]) - 32 | 0) >>> 0 > 31)
                                      h4 = k3;
                                    else if (h4 = k3, 75913 & (e3 = 1 << e3))
                                      for (; ; ) {
                                        if (h4 = k3 + 1 | 0, c4[b3 + 76 >> 2] = h4, y3 |= e3, (e3 = (l4 = f3[k3 + 1 | 0]) - 32 | 0) >>> 0 >= 32)
                                          break u;
                                        if (k3 = h4, !(75913 & (e3 = 1 << e3)))
                                          break;
                                      }
                                  u:
                                    if (42 != (0 | l4)) {
                                      if ((0 | (G4 = he(b3 + 76 | 0))) < 0)
                                        break i;
                                      l4 = c4[b3 + 76 >> 2];
                                    } else {
                                      if (!xe(e3 = f3[h4 + 1 | 0]) | 36 != v3[h4 + 2 | 0]) {
                                        if (Z4)
                                          break o;
                                        if (l4 = h4 + 1 | 0, !r5) {
                                          c4[b3 + 76 >> 2] = l4, Z4 = 0, G4 = 0;
                                          break u;
                                        }
                                        e3 = c4[a5 >> 2], c4[a5 >> 2] = e3 + 4, Z4 = 0, G4 = c4[e3 >> 2];
                                      } else
                                        c4[((e3 << 2) + n3 | 0) - 192 >> 2] = 10, l4 = h4 + 3 | 0, Z4 = 1, G4 = c4[((f3[h4 + 1 | 0] << 3) + i4 | 0) - 384 >> 2];
                                      if (c4[b3 + 76 >> 2] = l4, (0 | G4) >= 0)
                                        break u;
                                      G4 = 0 - G4 | 0, y3 |= 8192;
                                    }
                                  if (k3 = 0, m4 = -1, 46 == v3[0 | l4]) {
                                    if (42 != v3[l4 + 1 | 0])
                                      c4[b3 + 76 >> 2] = l4 + 1, m4 = he(b3 + 76 | 0), e3 = c4[b3 + 76 >> 2], g5 = 1;
                                    else {
                                      if (!xe(e3 = f3[l4 + 2 | 0]) | 36 != v3[l4 + 3 | 0]) {
                                        if (Z4)
                                          break o;
                                        e3 = l4 + 2 | 0, m4 = 0, r5 && (l4 = c4[a5 >> 2], c4[a5 >> 2] = l4 + 4, m4 = c4[l4 >> 2]);
                                      } else
                                        c4[((e3 << 2) + n3 | 0) - 192 >> 2] = 10, e3 = l4 + 4 | 0, m4 = c4[((f3[l4 + 2 | 0] << 3) + i4 | 0) - 384 >> 2];
                                      c4[b3 + 76 >> 2] = e3, g5 = (-1 ^ m4) >>> 31 | 0;
                                    }
                                  } else
                                    e3 = l4, g5 = 0;
                                  for (; ; ) {
                                    if (p3 = k3, h4 = 28, W3 = e3, (k3 = f3[0 | e3]) - 123 >>> 0 < 4294967238)
                                      break a;
                                    if (e3 = W3 + 1 | 0, !((k3 = v3[4895 + (k3 + w2(p3, 58) | 0) | 0]) - 1 >>> 0 < 8))
                                      break;
                                  }
                                  c4[b3 + 76 >> 2] = e3;
                                  u: {
                                    b: {
                                      if (27 != (0 | k3)) {
                                        if (!k3)
                                          break a;
                                        if ((0 | R5) >= 0) {
                                          c4[(R5 << 2) + n3 >> 2] = k3, l4 = c4[4 + (k3 = (R5 << 3) + i4 | 0) >> 2], c4[b3 + 64 >> 2] = c4[k3 >> 2], c4[b3 + 68 >> 2] = l4;
                                          break b;
                                        }
                                        if (!r5)
                                          break t;
                                        yr2(b3 - -64 | 0, k3, a5, u3);
                                        break u;
                                      }
                                      if ((0 | R5) >= 0)
                                        break a;
                                    }
                                    if (k3 = 0, !r5)
                                      continue n;
                                  }
                                  l4 = -65537 & y3, y3 = 8192 & y3 ? l4 : y3, R5 = 0, V4 = 1166, h4 = s4;
                                  u: {
                                    b: {
                                      s: {
                                        A: {
                                          k: {
                                            l: {
                                              d: {
                                                v: {
                                                  h: {
                                                    p: {
                                                      m: {
                                                        N: {
                                                          w: {
                                                            y: {
                                                              E: {
                                                                switch (k3 = f3[0 | W3], (k3 = p3 && 3 == (15 & k3) ? -33 & k3 : k3) - 88 | 0) {
                                                                  case 11:
                                                                    break u;
                                                                  case 9:
                                                                  case 13:
                                                                  case 14:
                                                                  case 15:
                                                                    break b;
                                                                  case 27:
                                                                    break d;
                                                                  case 12:
                                                                  case 17:
                                                                    break p;
                                                                  case 23:
                                                                    break m;
                                                                  case 0:
                                                                  case 32:
                                                                    break N;
                                                                  case 24:
                                                                    break w;
                                                                  case 22:
                                                                    break y;
                                                                  case 29:
                                                                    break E;
                                                                  case 1:
                                                                  case 2:
                                                                  case 3:
                                                                  case 4:
                                                                  case 5:
                                                                  case 6:
                                                                  case 7:
                                                                  case 8:
                                                                  case 10:
                                                                  case 16:
                                                                  case 18:
                                                                  case 19:
                                                                  case 20:
                                                                  case 21:
                                                                  case 25:
                                                                  case 26:
                                                                  case 28:
                                                                  case 30:
                                                                  case 31:
                                                                    break f;
                                                                }
                                                                switch (k3 - 65 | 0) {
                                                                  case 0:
                                                                  case 4:
                                                                  case 5:
                                                                  case 6:
                                                                    break b;
                                                                  case 2:
                                                                    break k;
                                                                  case 1:
                                                                  case 3:
                                                                    break f;
                                                                }
                                                                if (83 == (0 | k3))
                                                                  break l;
                                                                break f;
                                                              }
                                                              l4 = c4[b3 + 64 >> 2], p3 = c4[b3 + 68 >> 2], k3 = 1166;
                                                              break h;
                                                            }
                                                            k3 = 0;
                                                            y:
                                                              switch (255 & p3) {
                                                                case 0:
                                                                case 1:
                                                                case 6:
                                                                  c4[c4[b3 + 64 >> 2] >> 2] = E4;
                                                                  continue n;
                                                                case 2:
                                                                  d3 = c4[b3 + 64 >> 2], c4[d3 >> 2] = E4, c4[d3 + 4 >> 2] = E4 >> 31;
                                                                  continue n;
                                                                case 3:
                                                                  o3[c4[b3 + 64 >> 2] >> 1] = E4;
                                                                  continue n;
                                                                case 4:
                                                                  f3[c4[b3 + 64 >> 2]] = E4;
                                                                  continue n;
                                                                case 7:
                                                                  break y;
                                                                default:
                                                                  continue n;
                                                              }
                                                            d3 = c4[b3 + 64 >> 2], c4[d3 >> 2] = E4, c4[d3 + 4 >> 2] = E4 >> 31;
                                                            continue n;
                                                          }
                                                          m4 = m4 >>> 0 <= 8 ? 8 : m4, y3 |= 8, k3 = 120;
                                                        }
                                                        if (d3 = s4, (l4 = c4[b3 + 64 >> 2]) | (p3 = c4[b3 + 68 >> 2]))
                                                          for (T4 = 32 & k3; f3[0 | (d3 = d3 - 1 | 0)] = T4 | v3[5424 + (15 & l4) | 0], I3 = !p3 & l4 >>> 0 > 15 | 0 != (0 | p3), W3 = p3, p3 = p3 >>> 4 | 0, l4 = (15 & W3) << 28 | l4 >>> 4, I3; )
                                                            ;
                                                        if (!(8 & y3) | !(c4[b3 + 64 >> 2] | c4[b3 + 68 >> 2]))
                                                          break v;
                                                        V4 = 1166 + (k3 >>> 4 | 0) | 0, R5 = 2;
                                                        break v;
                                                      }
                                                      if (k3 = s4, p3 = d3 = c4[b3 + 68 >> 2], d3 | (l4 = c4[b3 + 64 >> 2]))
                                                        for (; f3[0 | (k3 = k3 - 1 | 0)] = 7 & l4 | 48, W3 = !p3 & l4 >>> 0 > 7 | 0 != (0 | p3), p3 = (d3 = p3) >>> 3 | 0, l4 = (7 & d3) << 29 | l4 >>> 3, W3; )
                                                          ;
                                                      if (d3 = k3, !(8 & y3))
                                                        break v;
                                                      m4 = (0 | (k3 = s4 - d3 | 0)) < (0 | m4) ? m4 : k3 + 1 | 0;
                                                      break v;
                                                    }
                                                    l4 = c4[b3 + 64 >> 2], p3 = k3 = c4[b3 + 68 >> 2], (0 | k3) < 0 ? (p3 = d3 = 0 - (p3 + (0 != (0 | l4)) | 0) | 0, l4 = 0 - l4 | 0, c4[b3 + 64 >> 2] = l4, c4[b3 + 68 >> 2] = d3, R5 = 1, k3 = 1166) : 2048 & y3 ? (R5 = 1, k3 = 1167) : k3 = (R5 = 1 & y3) ? 1168 : 1166;
                                                  }
                                                  V4 = k3, d3 = re2(l4, p3, s4);
                                                }
                                                if ((0 | m4) < 0 && g5)
                                                  break i;
                                                if (y3 = g5 ? -65537 & y3 : y3, !(0 != ((k3 = c4[b3 + 64 >> 2]) | (l4 = c4[b3 + 68 >> 2])) | m4)) {
                                                  d3 = s4, m4 = 0;
                                                  break f;
                                                }
                                                m4 = (0 | (k3 = !(k3 | l4) + (s4 - d3 | 0) | 0)) < (0 | m4) ? m4 : k3;
                                                break f;
                                              }
                                              y3 = 0, h4 = 0 != (0 | (p3 = g5 = m4 >>> 0 >= 2147483647 ? 2147483647 : m4));
                                              d: {
                                                v: {
                                                  h: {
                                                    p: {
                                                      m:
                                                        if (!(!(3 & (k3 = d3 = (k3 = c4[b3 + 64 >> 2]) || 4208)) | !p3))
                                                          for (; ; ) {
                                                            if (!(y3 = v3[0 | k3]))
                                                              break p;
                                                            if (h4 = 0 != (0 | (p3 = p3 - 1 | 0)), !(3 & (k3 = k3 + 1 | 0)))
                                                              break m;
                                                            if (!p3)
                                                              break;
                                                          }
                                                      if (!h4)
                                                        break v;
                                                      m: {
                                                        if (!(!v3[0 | k3] | p3 >>> 0 < 4))
                                                          for (; ; ) {
                                                            if ((-1 ^ (h4 = c4[k3 >> 2])) & h4 - 16843009 & -2139062144)
                                                              break m;
                                                            if (k3 = k3 + 4 | 0, !((p3 = p3 - 4 | 0) >>> 0 > 3))
                                                              break;
                                                          }
                                                        if (!p3)
                                                          break v;
                                                      }
                                                      h4 = 0;
                                                      break h;
                                                    }
                                                    h4 = 1;
                                                  }
                                                  for (; ; )
                                                    if (h4) {
                                                      if (!y3)
                                                        break d;
                                                      if (k3 = k3 + 1 | 0, !(p3 = p3 - 1 | 0))
                                                        break v;
                                                      h4 = 0;
                                                    } else
                                                      y3 = v3[0 | k3], h4 = 1;
                                                }
                                                k3 = 0;
                                              }
                                              if (h4 = (k3 = k3 ? k3 - d3 | 0 : g5) + d3 | 0, (0 | m4) >= 0) {
                                                y3 = l4, m4 = k3;
                                                break f;
                                              }
                                              if (y3 = l4, m4 = k3, v3[0 | h4])
                                                break i;
                                              break f;
                                            }
                                            if (m4) {
                                              l4 = c4[b3 + 64 >> 2];
                                              break A;
                                            }
                                            k3 = 0, le(r5, 32, G4, 0, y3);
                                            break s;
                                          }
                                          c4[b3 + 12 >> 2] = 0, c4[b3 + 8 >> 2] = c4[b3 + 64 >> 2], l4 = b3 + 8 | 0, c4[b3 + 64 >> 2] = l4, m4 = -1;
                                        }
                                        k3 = 0;
                                        A: {
                                          for (; ; ) {
                                            if (!(d3 = c4[l4 >> 2]))
                                              break A;
                                            if (!((h4 = (0 | (d3 = We(b3 + 4 | 0, d3))) < 0) | d3 >>> 0 > m4 - k3 >>> 0)) {
                                              if (l4 = l4 + 4 | 0, m4 >>> 0 > (k3 = k3 + d3 | 0) >>> 0)
                                                continue;
                                              break A;
                                            }
                                            break;
                                          }
                                          if (h4)
                                            break e;
                                        }
                                        if (h4 = 61, (0 | k3) < 0)
                                          break a;
                                        if (le(r5, 32, G4, k3, y3), k3)
                                          for (h4 = 0, l4 = c4[b3 + 64 >> 2]; ; ) {
                                            if (!(d3 = c4[l4 >> 2]))
                                              break s;
                                            if ((h4 = (d3 = We(b3 + 4 | 0, d3)) + h4 | 0) >>> 0 > k3 >>> 0)
                                              break s;
                                            if (Pr2(r5, b3 + 4 | 0, d3), l4 = l4 + 4 | 0, !(k3 >>> 0 > h4 >>> 0))
                                              break;
                                          }
                                        else
                                          k3 = 0;
                                      }
                                      le(r5, 32, G4, k3, 8192 ^ y3), k3 = (0 | k3) < (0 | G4) ? G4 : k3;
                                      continue n;
                                    }
                                    if ((0 | m4) < 0 && g5)
                                      break i;
                                    if (h4 = 61, (0 | (k3 = 0 | aa[0 | t5](r5, N2[b3 + 64 >> 3], G4, m4, y3, k3))) >= 0)
                                      continue n;
                                    break a;
                                  }
                                  f3[b3 + 55 | 0] = c4[b3 + 64 >> 2], m4 = 1, d3 = A4, y3 = l4;
                                  break f;
                                }
                                l4 = v3[k3 + 1 | 0], k3 = k3 + 1 | 0;
                              }
                            if (r5)
                              break r;
                            if (!Z4)
                              break t;
                            for (k3 = 1; ; ) {
                              if (r5 = c4[(k3 << 2) + n3 >> 2]) {
                                if (yr2((k3 << 3) + i4 | 0, r5, a5, u3), E4 = 1, 10 != (0 | (k3 = k3 + 1 | 0)))
                                  continue;
                                break r;
                              }
                              break;
                            }
                            if (E4 = 1, k3 >>> 0 >= 10)
                              break r;
                            for (; ; ) {
                              if (c4[(k3 << 2) + n3 >> 2])
                                break o;
                              if (10 == (0 | (k3 = k3 + 1 | 0)))
                                break;
                            }
                            break r;
                          }
                          h4 = 28;
                          break a;
                        }
                        if ((0 | (m4 = (0 | m4) > (0 | (p3 = h4 - d3 | 0)) ? m4 : p3)) > (2147483647 ^ R5))
                          break i;
                        if (h4 = 61, (0 | B3) < (0 | (k3 = (0 | (l4 = m4 + R5 | 0)) < (0 | G4) ? G4 : l4)))
                          break a;
                        le(r5, 32, k3, l4, y3), Pr2(r5, V4, R5), le(r5, 48, k3, l4, 65536 ^ y3), le(r5, 48, m4, p3, 0), Pr2(r5, d3, p3), le(r5, 32, k3, l4, 8192 ^ y3);
                        continue;
                      }
                      break;
                    }
                  E4 = 0;
                  break r;
                }
                h4 = 61;
              }
              c4[1761] = h4;
            }
            E4 = -1;
          }
          return ar3 = b3 + 80 | 0, E4;
        }
        function or2(r5, e3, a5, i4, n3, t5, o4, u3, b3, s4, A4, k3, l4, d3) {
          var h4, N3 = y2(0), G4 = 0, R5 = 0, g5 = 0, Z4 = y2(0), W3 = 0, V4 = 0, B3 = y2(0);
          (c4[r5 + 312 >> 2] != (0 | d3) && 4 & v3[r5 + 4 | 0] || (W3 = 0, c4[r5 + 316 >> 2] != (0 | i4))) && (c4[r5 + 540 >> 2] = -1082130432, c4[r5 + 544 >> 2] = -1082130432, c4[r5 + 532 >> 2] = 0, c4[r5 + 536 >> 2] = 0, c4[r5 + 524 >> 2] = -1082130432, c4[r5 + 528 >> 2] = -1082130432, c4[r5 + 320 >> 2] = 0, W3 = 1), h4 = l4 + 1 | 0;
          r: {
            e: {
              a: {
                i:
                  if (c4[r5 + 8 >> 2]) {
                    if (Z4 = Mr2(r5, 2, o4), B3 = Ur2(r5, 2, o4), N3 = y2(Mr2(r5, 0, o4) + Ur2(r5, 0, o4)), l4 = r5 + 524 | 0, Z4 = y2(Z4 + B3), lr2(n3, e3, t5, a5, c4[r5 + 532 >> 2], m3[l4 >> 2], c4[r5 + 536 >> 2], m3[r5 + 528 >> 2], m3[r5 + 540 >> 2], m3[r5 + 544 >> 2], Z4, N3, A4))
                      break a;
                    if (!(R5 = c4[r5 + 320 >> 2]))
                      break i;
                    for (G4 = r5 + 324 | 0; ; ) {
                      if (l4 = G4 + w2(g5, 24) | 0, lr2(n3, e3, t5, a5, c4[l4 + 8 >> 2], m3[l4 >> 2], c4[l4 + 12 >> 2], m3[l4 + 4 >> 2], m3[l4 + 16 >> 2], m3[l4 + 20 >> 2], Z4, N3, A4))
                        break a;
                      if ((0 | R5) == (0 | (g5 = g5 + 1 | 0)))
                        break;
                    }
                  } else {
                    if (b3) {
                      n: {
                        if (!((N3 = m3[(l4 = r5 + 524 | 0) >> 2]) != N3 | e3 != e3)) {
                          if (y2(E3(y2(N3 - e3))) < y2(9999999747378752e-20))
                            break n;
                          break i;
                        }
                        if (N3 == N3 | e3 == e3)
                          break i;
                      }
                      G4 = c4[r5 + 532 >> 2] == (0 | n3) && c4[r5 + 536 >> 2] == (0 | t5) ? l4 : 0, (l4 = (N3 = m3[r5 + 528 >> 2]) != N3) | (R5 = a5 != a5) ? l4 &= R5 : l4 = y2(E3(y2(N3 - a5))) < y2(9999999747378752e-20), l4 = l4 ? G4 : 0;
                      break a;
                    }
                    if (!(V4 = c4[r5 + 320 >> 2]))
                      break i;
                    for (R5 = r5 + 324 | 0; ; ) {
                      G4 = w2(g5, 24);
                      n: {
                        t: {
                          if (!((N3 = m3[(l4 = G4 + R5 | 0) >> 2]) != N3 | e3 != e3)) {
                            if (y2(E3(y2(N3 - e3))) < y2(9999999747378752e-20))
                              break t;
                            break n;
                          }
                          if (N3 == N3 | e3 == e3)
                            break n;
                        }
                        t: {
                          if (!((N3 = m3[4 + (G4 = R5 + G4 | 0) >> 2]) != N3 | a5 != a5)) {
                            if (y2(E3(y2(N3 - a5))) < y2(9999999747378752e-20))
                              break t;
                            break n;
                          }
                          if (N3 == N3 | a5 == a5)
                            break n;
                        }
                        if (c4[G4 + 8 >> 2] == (0 | n3) && c4[G4 + 12 >> 2] == (0 | t5))
                          break a;
                      }
                      if ((0 | V4) == (0 | (g5 = g5 + 1 | 0)))
                        break;
                    }
                  }
                nr2(r5, e3, a5, i4, n3, t5, o4, u3, b3, A4, k3, h4, d3, s4), c4[r5 + 316 >> 2] = i4;
                break e;
              }
              if (!(!l4 | W3)) {
                m3[r5 + 516 >> 2] = m3[l4 + 16 >> 2], m3[r5 + 520 >> 2] = m3[l4 + 20 >> 2], c4[(i4 = (b3 ? 12 : 16) + k3 | 0) >> 2] = c4[i4 >> 2] + 1, i4 = 0;
                break r;
              }
              if (nr2(r5, e3, a5, i4, n3, t5, o4, u3, b3, A4, k3, h4, d3, s4), c4[r5 + 316 >> 2] = i4, i4 = 1, l4)
                break r;
            }
            (i4 = (l4 = c4[r5 + 320 >> 2]) + 1 | 0) >>> 0 > p2[k3 + 8 >> 2] && (c4[k3 + 8 >> 2] = i4), 8 == (0 | l4) && (c4[r5 + 320 >> 2] = 0, l4 = 0), b3 ? i4 = r5 + 524 | 0 : (c4[r5 + 320 >> 2] = l4 + 1, i4 = 324 + (w2(l4, 24) + r5 | 0) | 0), c4[i4 + 12 >> 2] = t5, c4[i4 + 8 >> 2] = n3, m3[i4 + 4 >> 2] = a5, m3[i4 >> 2] = e3, m3[i4 + 16 >> 2] = m3[r5 + 516 >> 2], m3[i4 + 20 >> 2] = m3[r5 + 520 >> 2], i4 = 1;
          }
          return b3 && (n3 = c4[r5 + 520 >> 2], c4[r5 + 244 >> 2] = c4[r5 + 516 >> 2], c4[r5 + 248 >> 2] = n3, t5 = 1 | (n3 = v3[r5 + 4 | 0]), f3[r5 + 4 | 0] = t5, 4 & n3 && (f3[r5 + 4 | 0] = 251 & t5)), c4[r5 + 312 >> 2] = d3, i4;
        }
        function cr2(r5) {
          var e3 = 0, a5 = 0, i4 = 0, n3 = 0, t5 = 0, f4 = 0, o4 = 0, u3 = 0, b3 = 0, s4 = 0, A4 = 0;
          o4 = 8;
          r:
            if (!((r5 |= 0) >>> 0 > 4294967239)) {
              e: {
                for (; ; ) {
                  if (o4 = o4 >>> 0 <= 8 ? 8 : o4, t5 = e3 = c4[1731], n3 = c4[1730], (r5 = r5 >>> 0 <= 8 ? 8 : r5 + 3 & -4) >>> 0 <= 127 ? f4 = (r5 >>> 3 | 0) - 1 | 0 : (f4 = 110 + ((r5 >>> 29 - (i4 = G3(r5)) ^ 4) - (i4 << 2) | 0) | 0, r5 >>> 0 <= 4095 || (f4 = (i4 = 71 + ((r5 >>> 30 - i4 ^ 2) - (i4 << 1) | 0) | 0) >>> 0 >= 63 ? 63 : i4)), a5 = 31 & f4, (63 & f4) >>> 0 >= 32 ? (i4 = 0, e3 = e3 >>> a5 | 0) : (i4 = e3 >>> a5 | 0, e3 = ((1 << a5) - 1 & e3) << 32 - a5 | n3 >>> a5), e3 | i4) {
                    for (; ; ) {
                      if (n3 = i4, e3 | i4 ? (u3 = 1 + (a5 = i4 - 1 | 0) | 0, t5 = a5, a5 = 63 - (i4 = 32 == (0 | (i4 = G3(i4 ^ (t5 = -1 != (0 | (a5 = e3 - 1 | 0)) ? u3 : t5)))) ? G3(e3 ^ a5) + 32 | 0 : i4) | 0, ir2 = 0 - (i4 >>> 0 > 63) | 0) : (ir2 = 0, a5 = 64), a5 = 31 & (t5 = a5), (63 & t5) >>> 0 >= 32 ? (i4 = 0, e3 = n3 >>> a5 | 0) : (i4 = n3 >>> a5 | 0, e3 = ((1 << a5) - 1 & n3) << 32 - a5 | e3 >>> a5), u3 = e3, (0 | (e3 = c4[5896 + (a5 = (f4 = t5 + f4 | 0) << 4) >> 2])) == (0 | (t5 = a5 + 5888 | 0)))
                        b3 = c4[1731], n3 = 31 & (e3 = t5 = 63 & f4), e3 >>> 0 >= 32 ? (e3 = 0, a5 = -1 >>> n3 | 0) : a5 = (e3 = -1 >>> n3 | 0) | (1 << n3) - 1 << 32 - n3, a5 &= -2, n3 = 31 & t5, t5 >>> 0 >= 32 ? (e3 = a5 << n3, a5 = 0) : (e3 = (1 << n3) - 1 & a5 >>> 32 - n3 | e3 << n3, a5 <<= n3), s4 = a5, n3 = e3, e3 = 31 & (a5 = t5 = 0 - f4 & 63), a5 >>> 0 >= 32 ? (e3 = -1 << e3, a5 = 0) : e3 = (a5 = -1 << e3) | (1 << e3) - 1 & -1 >>> 32 - e3, A4 = -2 & a5, a5 = 31 & t5, t5 >>> 0 >= 32 ? (t5 = 0, e3 = e3 >>> a5 | 0) : (t5 = e3 >>> a5 | 0, e3 = ((1 << a5) - 1 & e3) << 32 - a5 | A4 >>> a5), e3 |= s4, ir2 = n3 | t5, c4[1730] = c4[1730] & e3, c4[1731] = ir2 & b3, e3 = 1 ^ u3;
                      else {
                        if (n3 = Nr2(e3, o4, r5))
                          break r;
                        n3 = c4[e3 + 4 >> 2], c4[n3 + 8 >> 2] = c4[e3 + 8 >> 2], c4[c4[e3 + 8 >> 2] + 4 >> 2] = n3, c4[e3 + 8 >> 2] = t5, n3 = a5 + 5892 | 0, c4[e3 + 4 >> 2] = c4[n3 >> 2], c4[n3 >> 2] = e3, c4[c4[e3 + 4 >> 2] + 8 >> 2] = e3, f4 = f4 + 1 | 0, e3 = (1 & i4) << 31 | u3 >>> 1, i4 = i4 >>> 1 | 0;
                      }
                      if (!(e3 | i4))
                        break;
                    }
                    t5 = c4[1731], n3 = c4[1730];
                  }
                  a: {
                    if (n3 | t5) {
                      a5 = 63 - (32 == (0 | (i4 = G3(t5))) ? G3(n3) + 32 | 0 : i4) | 0, i4 = c4[5896 + (e3 = a5 << 4) >> 2];
                      i:
                        if (!(!t5 & n3 >>> 0 < 1073741824) && (f4 = 99, (0 | (e3 = e3 + 5888 | 0)) != (0 | i4))) {
                          for (; ; ) {
                            if (!f4)
                              break i;
                            if (n3 = Nr2(i4, o4, r5))
                              break r;
                            if (f4 = f4 - 1 | 0, (0 | e3) == (0 | (i4 = c4[i4 + 8 >> 2])))
                              break;
                          }
                          i4 = e3;
                        }
                      if (vr2(r5 + 48 | 0))
                        break a;
                      if (!i4)
                        break e;
                      if ((0 | (e3 = 5888 + (a5 << 4) | 0)) == (0 | i4))
                        break e;
                      for (; ; ) {
                        if (n3 = Nr2(i4, o4, r5))
                          break r;
                        if ((0 | e3) == (0 | (i4 = c4[i4 + 8 >> 2])))
                          break;
                      }
                      break e;
                    }
                    if (!vr2(r5 + 48 | 0))
                      break e;
                  }
                  if (n3 = 0, o4 - 1 & o4)
                    break r;
                  if (!(r5 >>> 0 <= 4294967239))
                    break;
                }
                break r;
              }
              n3 = 0;
            }
          return 0 | n3;
        }
        function ur2(r5, e3, a5, i4) {
          var n3 = y2(0), t5 = y2(0), f4 = 0, o4 = y2(0);
          r: {
            e: {
              a: {
                i: {
                  n: {
                    t: {
                      if (e3 >>> 0 <= 1) {
                        t5 = m3[r5 + 212 >> 2];
                        f:
                          if (2139156720 != (0 | (e3 = c4[r5 + 212 >> 2]))) {
                            if (2140081935 == (0 | e3))
                              break t;
                            f4 = 4276;
                            o: {
                              if (2141891242 != (0 | e3)) {
                                if (t5 == t5)
                                  break o;
                                f4 = 4268;
                              }
                              switch (n3 = m3[f4 >> 2], t5 = y2(NaN), c4[f4 + 4 >> 2] - 1 | 0) {
                                case 0:
                                  break t;
                                case 1:
                                  break f;
                                default:
                                  break n;
                              }
                            }
                            if (b2(2, 536870912 + (-1073741825 & e3) | 0), n3 = d2(), !(1073741824 & e3))
                              break t;
                          }
                        t5 = y2(y2(n3 * i4) * y2(0.009999999776482582));
                        break n;
                      }
                      t5 = m3[r5 + 208 >> 2];
                      f: {
                        o: {
                          c:
                            if (2139156720 != (0 | (e3 = c4[r5 + 208 >> 2]))) {
                              if (2140081935 == (0 | e3))
                                break o;
                              f4 = 4276;
                              u: {
                                if (2141891242 != (0 | e3)) {
                                  if (t5 == t5)
                                    break u;
                                  f4 = 4268;
                                }
                                switch (n3 = m3[f4 >> 2], t5 = y2(NaN), c4[f4 + 4 >> 2] - 1 | 0) {
                                  case 0:
                                    break o;
                                  case 1:
                                    break c;
                                  default:
                                    break f;
                                }
                              }
                              if (b2(2, 536870912 + (-1073741825 & e3) | 0), n3 = d2(), !(1073741824 & e3))
                                break o;
                            }
                          t5 = y2(y2(n3 * i4) * y2(0.009999999776482582));
                          break f;
                        }
                        t5 = n3;
                      }
                      n3 = y2(0), o4 = m3[r5 + 216 >> 2];
                      f:
                        if (2139156720 != (0 | (r5 = c4[r5 + 216 >> 2]))) {
                          if (2140081935 == (0 | r5))
                            break a;
                          e3 = 4276;
                          o: {
                            if (2141891242 != (0 | r5)) {
                              if (o4 == o4)
                                break o;
                              e3 = 4268;
                            }
                            switch (n3 = m3[e3 >> 2], c4[e3 + 4 >> 2] - 1 | 0) {
                              case 1:
                                break f;
                              case 0:
                                break i;
                              default:
                                break e;
                            }
                          }
                          if (b2(2, 536870912 + (-1073741825 & r5) | 0), n3 = d2(), !(1073741824 & r5))
                            break i;
                        }
                      n3 = y2(y2(n3 * i4) * y2(0.009999999776482582));
                      break i;
                    }
                    t5 = n3;
                  }
                  n3 = y2(0), o4 = m3[r5 + 220 >> 2];
                  n:
                    if (2139156720 != (0 | (r5 = c4[r5 + 220 >> 2]))) {
                      if (2140081935 == (0 | r5))
                        break a;
                      e3 = 4276;
                      t: {
                        if (2141891242 != (0 | r5)) {
                          if (o4 == o4)
                            break t;
                          e3 = 4268;
                        }
                        switch (n3 = m3[e3 >> 2], c4[e3 + 4 >> 2] - 1 | 0) {
                          case 1:
                            break n;
                          case 0:
                            break i;
                          default:
                            break e;
                        }
                      }
                      if (b2(2, 536870912 + (-1073741825 & r5) | 0), n3 = d2(), !(1073741824 & r5))
                        break i;
                    }
                  n3 = y2(y2(n3 * i4) * y2(0.009999999776482582));
                }
                if (!(n3 >= y2(0)))
                  break e;
              }
              if (a5 > n3)
                break r;
            }
            if (!(t5 >= y2(0)))
              return a5;
            n3 = a5 < t5 ? t5 : a5;
          }
          return n3;
        }
        function br2(r5, e3) {
          var a5 = 0, i4 = 0;
          for (c4[r5 + 8 >> 2] = 0, c4[r5 + 12 >> 2] = 0, o3[r5 + 4 >> 1] = 1, c4[r5 >> 2] = 0, c4[r5 + 16 >> 2] = 0, c4[r5 + 20 >> 2] = 0, c4[r5 + 24 >> 2] = 0, c4[r5 + 36 >> 2] = 2143289344, c4[r5 + 40 >> 2] = 2141891242, c4[r5 + 28 >> 2] = 2143289344, c4[r5 + 32 >> 2] = 2143289344, i4 = Rr2(r5 + 44 | 0, 0, 36); c4[i4 + (a5 << 2) >> 2] = 2143289344, 9 != (0 | (a5 = a5 + 1 | 0)); )
            ;
          for (a5 = 0, i4 = Rr2(r5 + 80 | 0, 0, 36); c4[i4 + (a5 << 2) >> 2] = 2143289344, 9 != (0 | (a5 = a5 + 1 | 0)); )
            ;
          for (a5 = 0, i4 = Rr2(r5 + 116 | 0, 0, 36); c4[i4 + (a5 << 2) >> 2] = 2143289344, 9 != (0 | (a5 = a5 + 1 | 0)); )
            ;
          for (a5 = 0, i4 = Rr2(r5 + 152 | 0, 0, 36); c4[i4 + (a5 << 2) >> 2] = 2143289344, 9 != (0 | (a5 = a5 + 1 | 0)); )
            ;
          for (a5 = 0, c4[r5 + 196 >> 2] = 0, c4[(i4 = r5 + 188 | 0) >> 2] = 0, c4[i4 + 4 >> 2] = 0; c4[i4 + (a5 << 2) >> 2] = 2143289344, 3 != (0 | (a5 = a5 + 1 | 0)); )
            ;
          for (c4[r5 + 24 >> 2] = 4224, c4[r5 + 224 >> 2] = 2143289344, c4[r5 + 216 >> 2] = 2143289344, c4[r5 + 220 >> 2] = 2143289344, c4[r5 + 208 >> 2] = 2143289344, c4[r5 + 212 >> 2] = 2143289344, c4[r5 + 200 >> 2] = 2141891242, c4[r5 + 204 >> 2] = 2141891242, Rr2(r5 + 228 | 0, 0, 288), c4[r5 + 244 >> 2] = 2143289344, c4[r5 + 248 >> 2] = 2143289344, Rr2(r5 + 252 | 0, 0, 49), c4[r5 + 308 >> 2] = 2143289344, i4 = r5 + 516 | 0, a5 = r5 + 324 | 0; c4[a5 + 16 >> 2] = -1082130432, c4[a5 + 20 >> 2] = -1082130432, c4[a5 + 8 >> 2] = 0, c4[a5 + 12 >> 2] = 0, c4[a5 >> 2] = -1082130432, c4[a5 + 4 >> 2] = -1082130432, (0 | i4) != (0 | (a5 = a5 + 24 | 0)); )
            ;
          return c4[r5 + 548 >> 2] = 0, c4[r5 + 552 >> 2] = 0, c4[r5 + 516 >> 2] = 2143289344, c4[r5 + 520 >> 2] = 2143289344, c4[r5 + 572 >> 2] = 2143289344, c4[r5 + 576 >> 2] = 0, c4[r5 + 568 >> 2] = e3, c4[r5 + 540 >> 2] = -1082130432, c4[r5 + 544 >> 2] = -1082130432, c4[r5 + 532 >> 2] = 0, c4[r5 + 536 >> 2] = 0, c4[r5 + 524 >> 2] = -1082130432, c4[r5 + 528 >> 2] = -1082130432, c4[r5 + 556 >> 2] = 0, c4[r5 + 560 >> 2] = 0, c4[r5 + 564 >> 2] = 0, c4[r5 + 580 >> 2] = 2143289344, c4[r5 + 584 >> 2] = 0, v3[e3 + 10 | 0] && (c4[r5 + 24 >> 2] = 4616, f3[r5 + 4 | 0] = 128 | v3[r5 + 4 | 0]), r5;
        }
        function sr2(r5) {
          var e3, a5, i4, n3, t5, f4 = 0, o4 = 0, u3 = y2(0), s4 = y2(0), A4 = y2(0), k3 = 0, l4 = 0, v4 = 0, h4 = 0;
          for (c4[8 + (e3 = ar3 - 16 | 0) >> 2] = 0, c4[e3 + 12 >> 2] = 1, a5 = r5 + 200 | 0, i4 = r5 + 572 | 0, n3 = r5 + 208 | 0, t5 = r5 + 216 | 0, r5 = 0; ; ) {
            h4 = r5, v4 = c4[(e3 + 8 | 0) + (r5 << 2) >> 2], u3 = m3[(r5 = t5 + (k3 = v4 << 2) | 0) >> 2];
            r: {
              e: {
                a: {
                  i: {
                    n: {
                      if (!(!((l4 = 2139156720 == (0 | (f4 = c4[r5 >> 2]))) | 2140081935 == (0 | f4) | 2141891242 == (0 | f4)) & u3 != u3)) {
                        s4 = m3[(r5 = k3 + n3 | 0) >> 2];
                        t: {
                          f: {
                            if (2139156720 != (0 | (o4 = c4[r5 >> 2]))) {
                              if (A4 = y2(NaN), r5 = 3, 2141891242 == (0 | o4))
                                break t;
                              if (2140081935 != (0 | o4))
                                break f;
                              A4 = y2(0), r5 = 1;
                              break t;
                            }
                            A4 = y2(0), r5 = 2;
                            break t;
                          }
                          r5 = 0, s4 == s4 && (b2(2, 536870912 + (-1073741825 & o4) | 0), A4 = d2(), r5 = 1073741824 & o4 ? 2 : 1);
                        }
                        o4 = r5;
                        t: {
                          f: {
                            if (!l4) {
                              if (s4 = y2(NaN), r5 = 3, 2141891242 == (0 | f4))
                                break t;
                              if (2140081935 != (0 | f4))
                                break f;
                              s4 = y2(0), r5 = 1;
                              break t;
                            }
                            s4 = y2(0), r5 = 2;
                            break t;
                          }
                          r5 = 0, u3 == u3 && (b2(2, 536870912 + (-1073741825 & f4) | 0), s4 = d2(), r5 = 1073741824 & f4 ? 2 : 1);
                        }
                        if (!((0 | o4) != (0 | r5) | !(!r5 | s4 != s4 & A4 != A4 | y2(E3(y2(s4 - A4))) < y2(9999999747378752e-20)))) {
                          if (r5 = 0, l4)
                            break n;
                          if (2140081935 == (0 | f4))
                            break e;
                          if (2141891242 == (0 | f4))
                            break a;
                          if (u3 != u3)
                            break i;
                          r5 = 536870912 + (-1073741825 & f4) | 0, f4 = 1073741824 & f4 ? 2 : 1;
                          break r;
                        }
                      }
                      if (r5 = 0, u3 = m3[(f4 = k3 + a5 | 0) >> 2], 2139156720 != (0 | (f4 = c4[f4 >> 2]))) {
                        if (2140081935 == (0 | f4))
                          break e;
                        if (2141891242 == (0 | f4))
                          break a;
                        if (u3 != u3)
                          break i;
                        r5 = 536870912 + (-1073741825 & f4) | 0, f4 = 1073741824 & f4 ? 2 : 1;
                        break r;
                      }
                    }
                    f4 = 2;
                    break r;
                  }
                  r5 = 2143289344, f4 = 0;
                  break r;
                }
                r5 = 2143289344, f4 = 3;
                break r;
              }
              f4 = 1;
            }
            if (c4[4 + (o4 = (v4 << 3) + i4 | 0) >> 2] = f4, c4[o4 >> 2] = r5, r5 = 1, 1 & h4)
              break;
          }
        }
        function Ar2(r5, e3, a5) {
          var i4, n3 = 0, t5 = 0;
          if (a5 >>> 0 >= 512)
            return J2(0 | r5, 0 | e3, 0 | a5), r5;
          i4 = r5 + a5 | 0;
          r:
            if (3 & (r5 ^ e3)) {
              if (i4 >>> 0 < 4)
                a5 = r5;
              else if ((n3 = i4 - 4 | 0) >>> 0 < r5 >>> 0)
                a5 = r5;
              else
                for (a5 = r5; f3[0 | a5] = v3[0 | e3], f3[a5 + 1 | 0] = v3[e3 + 1 | 0], f3[a5 + 2 | 0] = v3[e3 + 2 | 0], f3[a5 + 3 | 0] = v3[e3 + 3 | 0], e3 = e3 + 4 | 0, n3 >>> 0 >= (a5 = a5 + 4 | 0) >>> 0; )
                  ;
            } else {
              e:
                if (3 & r5) {
                  if (a5)
                    for (a5 = r5; ; ) {
                      if (f3[0 | a5] = v3[0 | e3], e3 = e3 + 1 | 0, !(3 & (a5 = a5 + 1 | 0)))
                        break e;
                      if (!(a5 >>> 0 < i4 >>> 0))
                        break;
                    }
                  else
                    a5 = r5;
                } else
                  a5 = r5;
              if (!((n3 = -4 & i4) >>> 0 < 64 || (t5 = n3 + -64 | 0) >>> 0 < a5 >>> 0))
                for (; c4[a5 >> 2] = c4[e3 >> 2], c4[a5 + 4 >> 2] = c4[e3 + 4 >> 2], c4[a5 + 8 >> 2] = c4[e3 + 8 >> 2], c4[a5 + 12 >> 2] = c4[e3 + 12 >> 2], c4[a5 + 16 >> 2] = c4[e3 + 16 >> 2], c4[a5 + 20 >> 2] = c4[e3 + 20 >> 2], c4[a5 + 24 >> 2] = c4[e3 + 24 >> 2], c4[a5 + 28 >> 2] = c4[e3 + 28 >> 2], c4[a5 + 32 >> 2] = c4[e3 + 32 >> 2], c4[a5 + 36 >> 2] = c4[e3 + 36 >> 2], c4[a5 + 40 >> 2] = c4[e3 + 40 >> 2], c4[a5 + 44 >> 2] = c4[e3 + 44 >> 2], c4[a5 + 48 >> 2] = c4[e3 + 48 >> 2], c4[a5 + 52 >> 2] = c4[e3 + 52 >> 2], c4[a5 + 56 >> 2] = c4[e3 + 56 >> 2], c4[a5 + 60 >> 2] = c4[e3 + 60 >> 2], e3 = e3 - -64 | 0, t5 >>> 0 >= (a5 = a5 - -64 | 0) >>> 0; )
                  ;
              if (a5 >>> 0 >= n3 >>> 0)
                break r;
              for (; c4[a5 >> 2] = c4[e3 >> 2], e3 = e3 + 4 | 0, n3 >>> 0 > (a5 = a5 + 4 | 0) >>> 0; )
                ;
            }
          if (a5 >>> 0 < i4 >>> 0)
            for (; f3[0 | a5] = v3[0 | e3], e3 = e3 + 1 | 0, (0 | i4) != (0 | (a5 = a5 + 1 | 0)); )
              ;
          return r5;
        }
        function kr2(r5, e3, a5, i4, n3) {
          var t5, f4 = y2(0), o4 = 0, u3 = y2(0), s4 = y2(0), A4 = 0, k3 = y2(0), l4 = y2(0);
          if (!(t5 = (u3 = y2(a5 - i4)) != u3)) {
            a5 = y2(0), f4 = m3[208 + (o4 = (e3 << 2) + r5 | 0) >> 2];
            r: {
              e: {
                a: {
                  i:
                    if (2139156720 != (0 | (o4 = c4[o4 + 208 >> 2]))) {
                      if (2140081935 == (0 | o4))
                        break e;
                      A4 = 4276;
                      n: {
                        if (2141891242 != (0 | o4)) {
                          if (f4 == f4)
                            break n;
                          A4 = 4268;
                        }
                        switch (a5 = m3[A4 >> 2], c4[A4 + 4 >> 2] - 1 | 0) {
                          case 0:
                            break a;
                          case 1:
                            break i;
                          default:
                            break r;
                        }
                      }
                      if (b2(2, 536870912 + (-1073741825 & o4) | 0), a5 = d2(), !(1073741824 & o4))
                        break a;
                    }
                  a5 = y2(y2(a5 * n3) * y2(0.009999999776482582));
                }
                if (a5 != a5)
                  break r;
              }
              s4 = y2(a5 - i4);
            }
            a5 = y2(0), f4 = m3[216 + (r5 = (e3 << 2) + r5 | 0) >> 2];
            r: {
              e: {
                a: {
                  i:
                    if (2139156720 != (0 | (e3 = c4[r5 + 216 >> 2]))) {
                      if (2140081935 == (0 | e3))
                        break e;
                      r5 = 4276;
                      n: {
                        if (2141891242 != (0 | e3)) {
                          if (f4 == f4)
                            break n;
                          r5 = 4268;
                        }
                        switch (a5 = m3[r5 >> 2], f4 = y2(34028234663852886e22), c4[r5 + 4 >> 2] - 1 | 0) {
                          case 0:
                            break a;
                          case 1:
                            break i;
                          default:
                            break r;
                        }
                      }
                      if (b2(2, 536870912 + (-1073741825 & e3) | 0), a5 = d2(), !(1073741824 & e3))
                        break a;
                    }
                  a5 = y2(y2(a5 * n3) * y2(0.009999999776482582));
                }
                if (a5 != a5) {
                  f4 = y2(34028234663852886e22);
                  break r;
                }
              }
              f4 = y2(a5 - i4);
            }
            if (k3 = u3, l4 = ge(u3, f4), !((r5 = (a5 = f4 != f4 | t5 ? k3 : l4) != a5) | s4 != s4))
              return Re(a5, s4);
            u3 = r5 ? s4 : a5;
          }
          return u3;
        }
        function lr2(r5, e3, a5, i4, n3, t5, f4, o4, c5, u3, b3, s4, A4) {
          var k3 = y2(0), l4 = y2(0), d3 = 0, v4 = 0, h4 = y2(0), p3 = y2(0), N3 = y2(0), w3 = 0, G4 = 0;
          if (c5 < y2(0) | u3 < y2(0))
            r5 = 0;
          else {
            h4 = t5, p3 = e3, N3 = i4, l4 = o4, A4 && (l4 = o4, (k3 = m3[A4 + 16 >> 2]) != y2(0) && (p3 = jr2(+e3, w3 = +k3, 0, 0), N3 = jr2(+i4, w3, 0, 0), h4 = jr2(+t5, w3, 0, 0), l4 = jr2(+o4, w3, 0, 0))), k3 = l4, A4 = 0, (0 | r5) == (0 | n3) && ((G4 = h4 != h4) | (A4 = p3 != p3) ? A4 &= G4 : A4 = y2(E3(y2(h4 - p3))) < y2(9999999747378752e-20)), G4 = A4, (0 | a5) == (0 | f4) && ((d3 = k3 != k3) | (A4 = N3 != N3) ? d3 &= A4 : d3 = y2(E3(y2(k3 - N3))) < y2(9999999747378752e-20)), v4 = 1, A4 = 1;
            r:
              if (!G4) {
                e3 = y2(e3 - b3);
                e:
                  if (1 != (0 | r5)) {
                    if (!((r5 = 2 != (0 | r5)) | n3)) {
                      if (!(e3 >= c5))
                        break e;
                      break r;
                    }
                    if (A4 = 0, !(e3 < t5) | r5 | 2 != (0 | n3) | e3 != e3 | t5 != t5 | c5 != c5)
                      break r;
                    if (A4 = 1, e3 >= c5)
                      break r;
                  }
                A4 = (n3 = e3 != e3) | (r5 = c5 != c5) ? r5 & n3 : y2(E3(y2(e3 - c5))) < y2(9999999747378752e-20);
              }
            r:
              if (!d3) {
                e3 = y2(i4 - s4);
                e:
                  if (1 != (0 | a5)) {
                    if (!((r5 = 2 != (0 | a5)) | f4)) {
                      if (!(e3 >= u3))
                        break e;
                      break r;
                    }
                    if (v4 = 0, !(e3 < o4) | r5 | 2 != (0 | f4) | e3 != e3 | o4 != o4 | u3 != u3)
                      break r;
                    if (v4 = 1, e3 >= u3)
                      break r;
                  }
                v4 = (a5 = e3 != e3) | (r5 = u3 != u3) ? r5 & a5 : y2(E3(y2(e3 - u3))) < y2(9999999747378752e-20);
              }
            r5 = A4 & v4;
          }
          return r5;
        }
        function dr2(r5) {
          var e3, a5, i4 = 0, n3 = 0, t5 = 0, f4 = 0, o4 = 0, c5 = 0;
          if (A3(+r5), o4 = 0 | u2(1), t5 = 0 | u2(0), 2047 == (0 | (f4 = o4 >>> 20 & 2047)))
            return (r5 *= 1) / r5;
          if (!(i4 = t5 << 1) & 2145386496 == (0 | (c5 = o4 << 1 | t5 >>> 31)) | c5 >>> 0 < 2145386496)
            return !i4 & 2145386496 == (0 | c5) ? 0 * r5 : r5;
          if (f4)
            i4 = 1048575 & o4 | 1048576;
          else {
            if (f4 = 0, n3 = t5 << 12, (0 | (i4 = o4 << 12 | t5 >>> 20)) > 0 | (0 | i4) >= 0)
              for (; f4 = f4 - 1 | 0, i4 = i4 << 1 | n3 >>> 31, n3 <<= 1, (0 | i4) > 0 | (0 | i4) >= 0; )
                ;
            n3 = 31 & (i4 = 1 - f4 | 0), (63 & i4) >>> 0 >= 32 ? (i4 = t5 << n3, t5 = 0) : (i4 = (1 << n3) - 1 & t5 >>> 32 - n3 | o4 << n3, t5 <<= n3);
          }
          if (n3 = t5, (0 | f4) > 1023) {
            for (; ; ) {
              if (!((0 | (t5 = i4 + -1048576 | 0)) < 0 || (i4 = t5) | n3))
                return 0 * r5;
              if (i4 = i4 << 1 | n3 >>> 31, n3 <<= 1, !((0 | (f4 = f4 - 1 | 0)) > 1023))
                break;
            }
            f4 = 1023;
          }
          if (!((0 | (t5 = i4 + -1048576 | 0)) < 0 || (i4 = t5) | n3))
            return 0 * r5;
          if (1048575 == (0 | i4) | i4 >>> 0 < 1048575)
            for (; f4 = f4 - 1 | 0, t5 = i4 >>> 0 < 524288, c5 = i4 << 1 | n3 >>> 31, n3 <<= 1, i4 = c5, t5; )
              ;
          return a5 = -2147483648 & o4, c5 = i4 + -1048576 | f4 << 20, o4 = i4, e3 = n3, n3 = 31 & (t5 = 1 - f4 | 0), (63 & t5) >>> 0 >= 32 ? (i4 = 0, t5 = o4 >>> n3 | 0) : (i4 = o4 >>> n3 | 0, t5 = ((1 << n3) - 1 & o4) << 32 - n3 | e3 >>> n3), b2(0, 0 | ((n3 = (0 | f4) > 0) ? e3 : t5)), b2(1, (n3 ? c5 : i4) | a5), +s3();
        }
        function vr2(r5) {
          var e3 = 0, a5 = 0, i4 = 0, n3 = 0, t5 = 0;
          if ((a5 = (i4 = c4[1396]) + (e3 = r5 + 7 & -8) | 0) >>> 0 <= i4 >>> 0 && e3 || a5 >>> 0 > ia() << 16 >>> 0 && !(0 | x2(0 | a5)) ? (c4[1761] = 48, i4 = -1) : c4[1396] = a5, -1 != (0 | i4)) {
            c4[12 + (a5 = (e3 = r5 + i4 | 0) - 16 | 0) >> 2] = 16, c4[a5 >> 2] = 16;
            r: {
              e: {
                if ((0 | (t5 = (r5 = c4[1728]) ? c4[r5 + 8 >> 2] : 0)) == (0 | i4)) {
                  if (n3 = i4 - (-2 & c4[i4 - 4 >> 2]) | 0, t5 = c4[n3 - 4 >> 2], c4[r5 + 8 >> 2] = e3, e3 = -16, !(1 & f3[((r5 = n3 - (-2 & t5) | 0) + c4[r5 >> 2] | 0) - 4 | 0]))
                    break e;
                  e3 = c4[r5 + 4 >> 2], c4[e3 + 8 >> 2] = c4[r5 + 8 >> 2], c4[c4[r5 + 8 >> 2] + 4 >> 2] = e3, a5 = a5 - r5 | 0, c4[r5 >> 2] = a5;
                  break r;
                }
                c4[i4 + 12 >> 2] = 16, c4[i4 >> 2] = 16, c4[i4 + 8 >> 2] = e3, c4[i4 + 4 >> 2] = r5, c4[1728] = i4, e3 = 16;
              }
              a5 = a5 - (r5 = e3 + i4 | 0) | 0, c4[r5 >> 2] = a5;
            }
            c4[((-4 & a5) + r5 | 0) - 4 >> 2] = 1 | a5, (e3 = c4[r5 >> 2] - 8 | 0) >>> 0 <= 127 ? a5 = (e3 >>> 3 | 0) - 1 | 0 : (a5 = 110 + ((e3 >>> 29 - (n3 = G3(e3)) ^ 4) - (n3 << 2) | 0) | 0, e3 >>> 0 <= 4095 || (a5 = (a5 = 71 + ((e3 >>> 30 - n3 ^ 2) - (n3 << 1) | 0) | 0) >>> 0 >= 63 ? 63 : a5)), e3 = a5 << 4, c4[r5 + 4 >> 2] = e3 + 5888, e3 = e3 + 5896 | 0, c4[r5 + 8 >> 2] = c4[e3 >> 2], c4[e3 >> 2] = r5, c4[c4[r5 + 8 >> 2] + 4 >> 2] = r5, e3 = c4[1730], n3 = c4[1731], r5 = 31 & a5, (63 & a5) >>> 0 >= 32 ? (a5 = 1 << r5, t5 = 0) : a5 = (t5 = 1 << r5) - 1 & 1 >>> 32 - r5, c4[1730] = t5 | e3, c4[1731] = a5 | n3;
          }
          return -1 != (0 | i4);
        }
        function hr2(r5, e3, a5) {
          var i4 = 0, n3 = 0, t5 = 0, f4 = 0, o4 = 0, c5 = 0, u3 = 0, b3 = 0, s4 = 0;
          r: {
            e: {
              a: {
                i: {
                  n: {
                    t: {
                      f: {
                        o: {
                          c: {
                            u: {
                              if (e3) {
                                if (!a5)
                                  break u;
                                break c;
                              }
                              ir2 = 0, r5 = (r5 >>> 0) / (a5 >>> 0) | 0;
                              break r;
                            }
                            if (!r5)
                              break o;
                            break f;
                          }
                          if (!(a5 - 1 & a5))
                            break t;
                          f4 = 0 - (t5 = (G3(a5) + 33 | 0) - G3(e3) | 0) | 0;
                          break i;
                        }
                        ir2 = 0, r5 = (e3 >>> 0) / 0 | 0;
                        break r;
                      }
                      if ((i4 = 32 - G3(e3) | 0) >>> 0 < 31)
                        break n;
                      break a;
                    }
                    if (1 == (0 | a5))
                      break e;
                    a5 = 31 & (t5 = a5 ? 31 - G3(a5 - 1 ^ a5) | 0 : 32), (63 & t5) >>> 0 >= 32 ? r5 = e3 >>> a5 | 0 : (i4 = e3 >>> a5 | 0, r5 = ((1 << a5) - 1 & e3) << 32 - a5 | r5 >>> a5), ir2 = i4;
                    break r;
                  }
                  t5 = i4 + 1 | 0, f4 = 63 - i4 | 0;
                }
                if (n3 = 31 & (i4 = 63 & t5), i4 >>> 0 >= 32 ? (i4 = 0, o4 = e3 >>> n3 | 0) : (i4 = e3 >>> n3 | 0, o4 = ((1 << n3) - 1 & e3) << 32 - n3 | r5 >>> n3), n3 = 31 & (f4 &= 63), f4 >>> 0 >= 32 ? (e3 = r5 << n3, r5 = 0) : (e3 = (1 << n3) - 1 & r5 >>> 32 - n3 | e3 << n3, r5 <<= n3), t5)
                  for (s4 = -1 == (0 | (f4 = a5 - 1 | 0)) ? -1 : 0; c5 = i4 << 1 | o4 >>> 31, o4 = (i4 = o4 << 1 | e3 >>> 31) - (u3 = a5 & (n3 = s4 - (c5 + (i4 >>> 0 > f4 >>> 0) | 0) >> 31)) | 0, i4 = c5 - (i4 >>> 0 < u3 >>> 0) | 0, e3 = e3 << 1 | r5 >>> 31, r5 = b3 | r5 << 1, b3 = 1 & n3, t5 = t5 - 1 | 0; )
                    ;
                ir2 = e3 << 1 | r5 >>> 31, r5 = b3 | r5 << 1;
                break r;
              }
              r5 = 0, e3 = 0;
            }
            ir2 = e3;
          }
          return r5;
        }
        function pr2(r5, e3, a5) {
          var i4 = y2(0), n3 = y2(0);
          r: {
            e: {
              a: {
                if (2 == (-2 & e3)) {
                  if (2139156720 == (0 | (e3 = c4[r5 + 188 >> 2])) | 2140081935 == (0 | e3) | 2141891242 == (0 | e3) | (i4 = m3[r5 + 188 >> 2]) == i4)
                    break a;
                  if (2139156720 == (0 | (e3 = c4[r5 + 196 >> 2])) | 2140081935 == (0 | e3) | 2141891242 == (0 | e3) | (i4 = m3[r5 + 196 >> 2]) == i4)
                    break a;
                  break e;
                }
                if (!(2139156720 == (0 | (e3 = c4[r5 + 192 >> 2])) | 2140081935 == (0 | e3) | 2141891242 == (0 | e3) | (i4 = m3[r5 + 192 >> 2]) == i4 || (i4 = m3[r5 + 196 >> 2], 2139156720 == (0 | (e3 = c4[r5 + 196 >> 2])) | 2140081935 == (0 | e3) | 2141891242 == (0 | e3) || i4 == i4)))
                  break e;
              }
              i4 = y2(0);
              a: {
                i:
                  if (2139156720 != (0 | e3)) {
                    if (2140081935 == (0 | e3))
                      break r;
                    r5 = 4276;
                    n: {
                      if (2141891242 != (0 | e3)) {
                        if (b2(2, e3), (i4 = d2()) == i4)
                          break n;
                        r5 = 4268;
                      }
                      switch (i4 = m3[r5 >> 2], n3 = y2(NaN), c4[r5 + 4 >> 2] - 1 | 0) {
                        case 0:
                          break r;
                        case 1:
                          break i;
                        default:
                          break a;
                      }
                    }
                    if (b2(2, 536870912 + (-1073741825 & e3) | 0), i4 = d2(), !(1073741824 & e3))
                      break r;
                  }
                n3 = y2(y2(i4 * a5) * y2(0.009999999776482582));
              }
              return n3;
            }
            i4 = y2(0);
          }
          return i4;
        }
        function mr2(r5, e3) {
          var a5, i4, n3 = 0, t5 = 0, o4 = 0, u3 = 0;
          for (ar3 = n3 = ar3 - 320 | 0, a5 = Rr2(n3, 0, 288), c4[(n3 = a5) + 16 >> 2] = 2143289344, c4[n3 + 20 >> 2] = 2143289344, Rr2(n3 + 24 | 0, 0, 49), c4[n3 + 80 >> 2] = 2143289344, o4 = n3 + 288 | 0, t5 = n3 + 96 | 0; c4[(n3 = t5) + 16 >> 2] = -1082130432, c4[n3 + 20 >> 2] = -1082130432, c4[n3 + 8 >> 2] = 0, c4[n3 + 12 >> 2] = 0, c4[n3 >> 2] = -1082130432, c4[n3 + 4 >> 2] = -1082130432, (0 | o4) != (0 | (t5 = n3 + 24 | 0)); )
            ;
          if (c4[a5 + 312 >> 2] = -1082130432, c4[a5 + 316 >> 2] = -1082130432, c4[a5 + 304 >> 2] = 0, c4[a5 + 308 >> 2] = 0, c4[a5 + 296 >> 2] = -1082130432, c4[a5 + 300 >> 2] = -1082130432, c4[a5 + 288 >> 2] = 2143289344, c4[a5 + 292 >> 2] = 2143289344, Ar2(r5 + 228 | 0, a5, 320), c4[r5 + 244 >> 2] = 0, c4[r5 + 248 >> 2] = 0, f3[r5 + 4 | 0] = 1 | v3[r5 + 4 | 0], (0 | (t5 = c4[r5 + 556 >> 2])) != (0 | (i4 = c4[r5 + 560 >> 2])))
            for (; n3 = c4[t5 >> 2], c4[n3 + 552 >> 2] != (0 | r5) && (o4 = c4[r5 + 568 >> 2], n3 = Ir2(c4[o4 >> 2], v3[o4 + 8 | 0], n3, r5, u3, e3), c4[t5 >> 2] = n3, c4[n3 + 552 >> 2] = r5, n3 = c4[t5 >> 2]), mr2(n3, e3), u3 = u3 + 1 | 0, (0 | i4) != (0 | (t5 = t5 + 4 | 0)); )
              ;
          ar3 = a5 + 320 | 0;
        }
        function Nr2(r5, e3, a5) {
          var i4 = 0, n3 = 0, t5 = 0, f4 = 0;
          return (n3 = ((i4 = r5 + 4 | 0) + e3 | 0) - 1 & 0 - e3) + a5 >>> 0 <= ((e3 = c4[r5 >> 2]) + r5 | 0) - 4 >>> 0 ? (t5 = c4[r5 + 4 >> 2], c4[t5 + 8 >> 2] = c4[r5 + 8 >> 2], c4[c4[r5 + 8 >> 2] + 4 >> 2] = t5, (0 | i4) != (0 | n3) && (n3 = n3 - i4 | 0, t5 = r5 - (-2 & c4[r5 - 4 >> 2]) | 0, i4 = n3 + c4[t5 >> 2] | 0, c4[t5 >> 2] = i4, c4[(t5 + (-4 & i4) | 0) - 4 >> 2] = i4, e3 = e3 - n3 | 0, c4[(r5 = r5 + n3 | 0) >> 2] = e3), a5 + 24 >>> 0 <= e3 >>> 0 ? (e3 = (e3 - a5 | 0) - 8 | 0, c4[(i4 = 8 + (r5 + a5 | 0) | 0) >> 2] = e3, c4[(i4 + (-4 & e3) | 0) - 4 >> 2] = 1 | e3, (n3 = c4[i4 >> 2] - 8 | 0) >>> 0 <= 127 ? e3 = (n3 >>> 3 | 0) - 1 | 0 : (e3 = 110 + ((n3 >>> 29 - (t5 = G3(n3)) ^ 4) - (t5 << 2) | 0) | 0, n3 >>> 0 <= 4095 || (e3 = (e3 = 71 + ((n3 >>> 30 - t5 ^ 2) - (t5 << 1) | 0) | 0) >>> 0 >= 63 ? 63 : e3)), n3 = e3 << 4, c4[i4 + 4 >> 2] = n3 + 5888, n3 = n3 + 5896 | 0, c4[i4 + 8 >> 2] = c4[n3 >> 2], c4[n3 >> 2] = i4, c4[c4[i4 + 8 >> 2] + 4 >> 2] = i4, n3 = c4[1730], t5 = c4[1731], i4 = 31 & e3, (63 & e3) >>> 0 >= 32 ? (e3 = 1 << i4, i4 = 0) : (e3 = (f4 = 1 << i4) - 1 & 1 >>> 32 - i4, i4 = f4), c4[1730] = i4 | n3, c4[1731] = e3 | t5, e3 = a5 + 8 | 0, c4[r5 >> 2] = e3, c4[((-4 & e3) + r5 | 0) - 4 >> 2] = e3) : c4[(r5 + e3 | 0) - 4 >> 2] = e3, r5 = r5 + 4 | 0) : r5 = 0, r5;
        }
        function wr2(r5, e3, a5) {
          var i4 = 0, n3 = 0;
          r:
            if ((0 | r5) != (0 | e3)) {
              if (e3 - (n3 = r5 + a5 | 0) >>> 0 <= 0 - (a5 << 1) >>> 0)
                return Ar2(r5, e3, a5);
              if (i4 = 3 & (r5 ^ e3), r5 >>> 0 < e3 >>> 0) {
                if (i4)
                  i4 = r5;
                else {
                  if (3 & r5)
                    for (i4 = r5; ; ) {
                      if (!a5)
                        break r;
                      if (f3[0 | i4] = v3[0 | e3], e3 = e3 + 1 | 0, a5 = a5 - 1 | 0, !(3 & (i4 = i4 + 1 | 0)))
                        break;
                    }
                  else
                    i4 = r5;
                  if (!(a5 >>> 0 <= 3))
                    for (; c4[i4 >> 2] = c4[e3 >> 2], e3 = e3 + 4 | 0, i4 = i4 + 4 | 0, (a5 = a5 - 4 | 0) >>> 0 > 3; )
                      ;
                }
                if (a5)
                  for (; f3[0 | i4] = v3[0 | e3], i4 = i4 + 1 | 0, e3 = e3 + 1 | 0, a5 = a5 - 1 | 0; )
                    ;
              } else {
                if (!i4) {
                  if (3 & n3)
                    for (; ; ) {
                      if (!a5)
                        break r;
                      if (f3[0 | (i4 = (a5 = a5 - 1 | 0) + r5 | 0)] = v3[e3 + a5 | 0], !(3 & i4))
                        break;
                    }
                  if (!(a5 >>> 0 <= 3))
                    for (; c4[(a5 = a5 - 4 | 0) + r5 >> 2] = c4[e3 + a5 >> 2], a5 >>> 0 > 3; )
                      ;
                }
                if (!a5)
                  break r;
                for (; f3[(a5 = a5 - 1 | 0) + r5 | 0] = v3[e3 + a5 | 0], a5; )
                  ;
              }
            }
          return r5;
        }
        function yr2(r5, e3, a5, i4) {
          switch (e3 - 9 | 0) {
            case 0:
              return e3 = c4[a5 >> 2], c4[a5 >> 2] = e3 + 4, void (c4[r5 >> 2] = c4[e3 >> 2]);
            case 6:
              return e3 = c4[a5 >> 2], c4[a5 >> 2] = e3 + 4, e3 = o3[e3 >> 1], c4[r5 >> 2] = e3, void (c4[r5 + 4 >> 2] = e3 >> 31);
            case 7:
              return e3 = c4[a5 >> 2], c4[a5 >> 2] = e3 + 4, c4[r5 >> 2] = h3[e3 >> 1], void (c4[r5 + 4 >> 2] = 0);
            case 8:
              return e3 = c4[a5 >> 2], c4[a5 >> 2] = e3 + 4, e3 = f3[0 | e3], c4[r5 >> 2] = e3, void (c4[r5 + 4 >> 2] = e3 >> 31);
            case 9:
              return e3 = c4[a5 >> 2], c4[a5 >> 2] = e3 + 4, c4[r5 >> 2] = v3[0 | e3], void (c4[r5 + 4 >> 2] = 0);
            case 16:
              return e3 = c4[a5 >> 2] + 7 & -8, c4[a5 >> 2] = e3 + 8, void (N2[r5 >> 3] = N2[e3 >> 3]);
            case 17:
              aa[0 | i4](r5, a5);
            default:
              return;
            case 1:
            case 4:
            case 14:
              return e3 = c4[a5 >> 2], c4[a5 >> 2] = e3 + 4, e3 = c4[e3 >> 2], c4[r5 >> 2] = e3, void (c4[r5 + 4 >> 2] = e3 >> 31);
            case 2:
            case 5:
            case 11:
            case 15:
              return e3 = c4[a5 >> 2], c4[a5 >> 2] = e3 + 4, c4[r5 >> 2] = c4[e3 >> 2], void (c4[r5 + 4 >> 2] = 0);
            case 3:
            case 10:
            case 12:
            case 13:
          }
          e3 = c4[a5 >> 2] + 7 & -8, c4[a5 >> 2] = e3 + 8, a5 = c4[e3 + 4 >> 2], c4[r5 >> 2] = c4[e3 >> 2], c4[r5 + 4 >> 2] = a5;
        }
        function Er2(r5, e3, a5, i4) {
          var n3 = 0, t5 = 0, f4 = 0, o4 = 0, u3 = 0, b3 = 0, s4 = 0, A4 = 0, k3 = 0, l4 = 0, d3 = 0, h4 = y2(0), p3 = y2(0), N3 = y2(0), w3 = 0, G4 = y2(0);
          if (0 != e3 && (h4 = m3[r5 + 248 >> 2], p3 = m3[r5 + 244 >> 2], N3 = m3[r5 + 232 >> 2], w3 = r5, G4 = jr2(A4 = +m3[r5 + 228 >> 2], e3, 0, n3 = (f4 = 8 & v3[r5 + 4 | 0]) >>> 3 | 0), m3[w3 + 228 >> 2] = G4, w3 = r5, G4 = jr2(k3 = +N3, e3, 0, n3), m3[w3 + 232 >> 2] = G4, n3 = (u3 = dr2((l4 = +p3) * e3)) != u3, t5 = (b3 = dr2((d3 = +h4) * e3)) != b3, a5 = A4 + a5, o4 = n3 | (o4 = E3(u3) < 1e-4) ? n3 | !o4 : !(E3(u3 + -1) < 1e-4), w3 = r5, G4 = y2(jr2(a5 + l4, e3, o4 & (n3 = 0 != (0 | f4)), n3 & !o4) - jr2(a5, e3, 0, n3)), m3[w3 + 244 >> 2] = G4, i4 = k3 + i4, t5 = t5 | (f4 = E3(b3) < 1e-4) ? t5 | !f4 : !(E3(b3 + -1) < 1e-4), w3 = r5, G4 = y2(jr2(i4 + d3, e3, n3 & t5, n3 & !t5) - jr2(i4, e3, 0, n3)), m3[w3 + 248 >> 2] = G4, (0 | (n3 = c4[r5 + 560 >> 2])) != (0 | (t5 = c4[r5 + 556 >> 2]))))
            for (t5 = (n3 = n3 - t5 >> 2) >>> 0 <= 1 ? 1 : n3; n3 = c4[r5 + 556 >> 2], Er2(n3 = c4[r5 + 560 >> 2] - n3 >> 2 >>> 0 > s4 >>> 0 ? c4[n3 + (s4 << 2) >> 2] : 0, e3, a5, i4), (0 | t5) != (0 | (s4 = s4 + 1 | 0)); )
              ;
        }
        function Gr2() {
          er3(7004, 3018), rr2(7005, 2479, 1, 1, 0), B2(7006, 2139, 1, -128, 127), B2(7007, 2132, 1, -128, 127), B2(7008, 2130, 1, 0, 255), B2(7009, 1286, 2, -32768, 32767), B2(7010, 1277, 2, 0, 65535), B2(7011, 1315, 4, -2147483648, 2147483647), B2(7012, 1306, 4, 0, -1), B2(7013, 2658, 4, -2147483648, 2147483647), B2(7014, 2649, 4, 0, -1), Me(7015, 1776, -2147483648, 2147483647), Me(7016, 1775, 0, -1), S3(7017, 1769, 4), S3(7018, 2966, 8), P2(7019, 2676), P2(7020, 3835), L3(7021, 4, 2663), L3(7022, 2, 2688), L3(7023, 4, 2703), $2(7024, 2484), W2(7025, 0, 3766), W2(7026, 0, 3868), W2(7027, 1, 3796), W2(7028, 2, 3398), W2(7029, 3, 3429), W2(7030, 4, 3469), W2(7031, 5, 3498), W2(7032, 4, 3905), W2(7033, 5, 3935), W2(7026, 0, 3600), W2(7027, 1, 3567), W2(7028, 2, 3666), W2(7029, 3, 3632), W2(7030, 4, 3733), W2(7031, 5, 3699), W2(7034, 6, 3536), W2(7035, 7, 3974);
        }
        function Rr2(r5, e3, a5) {
          var i4 = 0, n3 = 0, t5 = 0, o4 = 0;
          if (a5 && (f3[0 | r5] = e3, f3[(i4 = r5 + a5 | 0) - 1 | 0] = e3, !(a5 >>> 0 < 3 || (f3[r5 + 2 | 0] = e3, f3[r5 + 1 | 0] = e3, f3[i4 - 3 | 0] = e3, f3[i4 - 2 | 0] = e3, a5 >>> 0 < 7 || (f3[r5 + 3 | 0] = e3, f3[i4 - 4 | 0] = e3, a5 >>> 0 < 9 || (n3 = (i4 = 0 - r5 & 3) + r5 | 0, e3 = w2(255 & e3, 16843009), c4[n3 >> 2] = e3, c4[(a5 = (i4 = a5 - i4 & -4) + n3 | 0) - 4 >> 2] = e3, i4 >>> 0 < 9 || (c4[n3 + 8 >> 2] = e3, c4[n3 + 4 >> 2] = e3, c4[a5 - 8 >> 2] = e3, c4[a5 - 12 >> 2] = e3, i4 >>> 0 < 25 || (c4[n3 + 24 >> 2] = e3, c4[n3 + 20 >> 2] = e3, c4[n3 + 16 >> 2] = e3, c4[n3 + 12 >> 2] = e3, c4[a5 - 16 >> 2] = e3, c4[a5 - 20 >> 2] = e3, c4[a5 - 24 >> 2] = e3, c4[a5 - 28 >> 2] = e3, (a5 = i4 - (o4 = 4 & n3 | 24) | 0) >>> 0 < 32))))))))
            for (i4 = Ae(e3, 0, 1, 1), t5 = ir2, e3 = n3 + o4 | 0; c4[e3 + 24 >> 2] = i4, c4[e3 + 28 >> 2] = t5, c4[e3 + 16 >> 2] = i4, c4[e3 + 20 >> 2] = t5, c4[e3 + 8 >> 2] = i4, c4[e3 + 12 >> 2] = t5, c4[e3 >> 2] = i4, c4[e3 + 4 >> 2] = t5, e3 = e3 + 32 | 0, (a5 = a5 - 32 | 0) >>> 0 > 31; )
              ;
          return r5;
        }
        function gr2(r5) {
          var e3 = 0, a5 = 0, i4 = 0, n3 = 0, t5 = 0;
          (r5 |= 0) && (a5 = n3 = c4[(e3 = r5 - 4 | 0) >> 2], i4 = e3, (0 | (r5 = -2 & (t5 = c4[r5 - 8 >> 2]))) != (0 | t5) && (a5 = c4[4 + (i4 = e3 - r5 | 0) >> 2], c4[a5 + 8 >> 2] = c4[i4 + 8 >> 2], c4[c4[i4 + 8 >> 2] + 4 >> 2] = a5, a5 = r5 + n3 | 0), (0 | (e3 = c4[(r5 = e3 + n3 | 0) >> 2])) != c4[(r5 + e3 | 0) - 4 >> 2] && (n3 = c4[r5 + 4 >> 2], c4[n3 + 8 >> 2] = c4[r5 + 8 >> 2], c4[c4[r5 + 8 >> 2] + 4 >> 2] = n3, a5 = e3 + a5 | 0), c4[i4 >> 2] = a5, c4[((-4 & a5) + i4 | 0) - 4 >> 2] = 1 | a5, (e3 = c4[i4 >> 2] - 8 | 0) >>> 0 <= 127 ? r5 = (e3 >>> 3 | 0) - 1 | 0 : (r5 = 110 + ((e3 >>> 29 - (a5 = G3(e3)) ^ 4) - (a5 << 2) | 0) | 0, e3 >>> 0 <= 4095 || (r5 = (r5 = 71 + ((e3 >>> 30 - a5 ^ 2) - (a5 << 1) | 0) | 0) >>> 0 >= 63 ? 63 : r5)), e3 = r5 << 4, c4[i4 + 4 >> 2] = e3 + 5888, e3 = e3 + 5896 | 0, c4[i4 + 8 >> 2] = c4[e3 >> 2], c4[e3 >> 2] = i4, c4[c4[i4 + 8 >> 2] + 4 >> 2] = i4, e3 = c4[1730], a5 = c4[1731], i4 = 31 & r5, (63 & r5) >>> 0 >= 32 ? (r5 = 1 << i4, n3 = 0) : r5 = (n3 = 1 << i4) - 1 & 1 >>> 32 - i4, c4[1730] = n3 | e3, c4[1731] = r5 | a5);
        }
        function Zr2(r5, e3, a5, i4, n3) {
          var t5, f4 = 0, o4 = 0;
          if (ar3 = t5 = ar3 - 208 | 0, c4[t5 + 204 >> 2] = a5, Rr2(a5 = t5 + 160 | 0, 0, 40), c4[t5 + 200 >> 2] = c4[t5 + 204 >> 2], (0 | fr2(0, e3, t5 + 200 | 0, t5 + 80 | 0, a5, i4, n3)) < 0)
            n3 = -1;
          else {
            c4[r5 + 76 >> 2], f4 = c4[r5 >> 2], c4[r5 + 72 >> 2] <= 0 && (c4[r5 >> 2] = -33 & f4);
            r: {
              e: {
                if (c4[r5 + 48 >> 2]) {
                  if (c4[r5 + 16 >> 2])
                    break e;
                } else
                  c4[r5 + 48 >> 2] = 80, c4[r5 + 28 >> 2] = 0, c4[r5 + 16 >> 2] = 0, c4[r5 + 20 >> 2] = 0, o4 = c4[r5 + 44 >> 2], c4[r5 + 44 >> 2] = t5;
                if (a5 = -1, me(r5))
                  break r;
              }
              a5 = fr2(r5, e3, t5 + 200 | 0, t5 + 80 | 0, t5 + 160 | 0, i4, n3);
            }
            o4 && (aa[c4[r5 + 36 >> 2]](r5, 0, 0), c4[r5 + 48 >> 2] = 0, c4[r5 + 44 >> 2] = o4, c4[r5 + 28 >> 2] = 0, e3 = c4[r5 + 20 >> 2], c4[r5 + 16 >> 2] = 0, c4[r5 + 20 >> 2] = 0, a5 = e3 ? a5 : -1), e3 = r5, r5 = c4[r5 >> 2], c4[e3 >> 2] = r5 | 32 & f4, n3 = 32 & r5 ? -1 : a5;
          }
          return ar3 = t5 + 208 | 0, n3;
        }
        function Wr2(r5) {
          var e3, a5 = 0, i4 = y2(0), n3 = 0, t5 = 0, f4 = 0, o4 = 0, u3 = y2(0), b3 = 0;
          ar3 = e3 = ar3 - 16 | 0;
          r: {
            if (a5 = c4[r5 + 12 >> 2]) {
              if (u3 = m3[r5 + 520 >> 2], i4 = m3[r5 + 516 >> 2], (i4 = 32 & v3[r5 + 4 | 0] ? y2(aa[0 | a5](r5, i4, u3, 0)) : y2(aa[0 | a5](r5, i4, u3))) == i4)
                break r;
              c4[e3 >> 2] = 3340, Xr2(r5, e3), De(), k2();
            }
            e: {
              a: {
                if ((0 | (f4 = c4[r5 + 556 >> 2])) != (0 | (a5 = c4[r5 + 560 >> 2]))) {
                  for (b3 = (a5 = a5 - f4 >> 2) >>> 0 <= 1 ? 1 : a5; ; ) {
                    if (t5 = c4[(o4 << 2) + f4 >> 2], !c4[t5 + 548 >> 2]) {
                      if (131072 != (196608 & (a5 = c4[t5 + 24 >> 2]))) {
                        if ((a5 = a5 >>> 13 & 7) || (a5 = c4[r5 + 24 >> 2] >>> 10 & 7), 2 & v3[t5 + 4 | 0] | (8 & v3[r5 + 24 | 0] ? 5 == (0 | a5) : 0))
                          break a;
                        n3 = n3 || t5;
                      }
                      if ((0 | b3) != (0 | (o4 = o4 + 1 | 0)))
                        continue;
                    }
                    break;
                  }
                  if (n3)
                    break e;
                }
                i4 = m3[r5 + 520 >> 2];
                break r;
              }
              n3 = t5;
            }
            i4 = y2(Wr2(n3) + m3[n3 + 232 >> 2]);
          }
          return ar3 = e3 + 16 | 0, i4;
        }
        function Vr2(r5, e3, a5, i4, n3, t5) {
          var f4 = 0, o4 = y2(0), u3 = 0, s4 = y2(0);
          f4 = (c4[4252 + (e3 << 2) >> 2] << 2) + r5 | 0, o4 = m3[f4 + 216 >> 2];
          r: {
            e: {
              a:
                if (2139156720 != (0 | (f4 = c4[f4 + 216 >> 2]))) {
                  if (2140081935 == (0 | f4))
                    break e;
                  u3 = 4276;
                  i: {
                    if (2141891242 != (0 | f4)) {
                      if (o4 == o4)
                        break i;
                      u3 = 4268;
                    }
                    switch (s4 = m3[u3 >> 2], o4 = y2(NaN), c4[u3 + 4 >> 2] - 1 | 0) {
                      case 0:
                        break e;
                      case 1:
                        break a;
                      default:
                        break r;
                    }
                  }
                  if (b2(2, 536870912 + (-1073741825 & f4) | 0), s4 = d2(), !(1073741824 & f4))
                    break e;
                }
              o4 = y2(y2(s4 * a5) * y2(0.009999999776482582));
              break r;
            }
            o4 = s4;
          }
          i4 = y2(o4 + y2(Mr2(r5, e3, i4) + Ur2(r5, e3, i4)));
          r: {
            e: {
              a:
                switch (c4[n3 >> 2]) {
                  case 1:
                  case 2:
                    a5 = m3[t5 >> 2], i4 = i4 != i4 || a5 < i4 ? a5 : i4;
                    break e;
                  case 0:
                    break a;
                  default:
                    break r;
                }
              if (i4 != i4)
                break r;
              c4[n3 >> 2] = 2;
            }
            m3[t5 >> 2] = i4;
          }
        }
        function Br2(r5, e3, a5) {
          var i4, n3 = y2(0), t5 = y2(0), f4 = y2(0);
          r5 = r5 + 116 | 0, i4 = c4[4220 + (e3 << 2) >> 2];
          r: {
            e: {
              a: {
                i:
                  if (2139156720 != (0 | (e3 = 2 != (-2 & e3) ? Hr2(r5, i4, 2140081935) : _r2(r5, 4, i4, 2140081935)))) {
                    if (2140081935 == (0 | e3))
                      break r;
                    r5 = 4276;
                    n: {
                      if (2141891242 != (0 | e3)) {
                        if (b2(2, e3), (n3 = d2()) == n3)
                          break n;
                        r5 = 4268;
                      }
                      switch (n3 = m3[r5 >> 2], t5 = y2(NaN), c4[r5 + 4 >> 2] - 1 | 0) {
                        case 0:
                          break a;
                        case 1:
                          break i;
                        default:
                          break e;
                      }
                    }
                    if (b2(2, 536870912 + (-1073741825 & e3) | 0), n3 = d2(), !(1073741824 & e3))
                      break a;
                  }
                n3 = y2(y2(n3 * a5) * y2(0.009999999776482582));
              }
              if (n3 >= y2(0))
                return n3;
              if (t5 = n3, n3 < y2(0))
                break r;
            }
            f4 = t5 == t5 ? t5 : y2(0);
          }
          return f4;
        }
        function Tr2(r5, e3, a5) {
          var i4, n3 = y2(0), t5 = y2(0), f4 = y2(0);
          r5 = r5 + 116 | 0, i4 = c4[4236 + (e3 << 2) >> 2];
          r: {
            e: {
              a: {
                i:
                  if (2139156720 != (0 | (e3 = 2 != (-2 & e3) ? Hr2(r5, i4, 2140081935) : _r2(r5, 5, i4, 2140081935)))) {
                    if (2140081935 == (0 | e3))
                      break r;
                    r5 = 4276;
                    n: {
                      if (2141891242 != (0 | e3)) {
                        if (b2(2, e3), (n3 = d2()) == n3)
                          break n;
                        r5 = 4268;
                      }
                      switch (n3 = m3[r5 >> 2], t5 = y2(NaN), c4[r5 + 4 >> 2] - 1 | 0) {
                        case 0:
                          break a;
                        case 1:
                          break i;
                        default:
                          break e;
                      }
                    }
                    if (b2(2, 536870912 + (-1073741825 & e3) | 0), n3 = d2(), !(1073741824 & e3))
                      break a;
                  }
                n3 = y2(y2(n3 * a5) * y2(0.009999999776482582));
              }
              if (n3 >= y2(0))
                return n3;
              if (t5 = n3, n3 < y2(0))
                break r;
            }
            f4 = t5 == t5 ? t5 : y2(0);
          }
          return f4;
        }
        function Ir2(r5, e3, a5, i4, n3, t5) {
          var f4 = 0;
          r: {
            if (!r5 || !(t5 = 255 & e3 ? 0 | aa[0 | r5](a5, i4, n3, t5) : 0 | aa[0 | r5](a5, i4, n3))) {
              if (e3 = Ar2(t5 = ye(588), a5, 552), c4[e3 + 564 >> 2] = 0, c4[e3 + 556 >> 2] = 0, c4[e3 + 560 >> 2] = 0, (0 | (n3 = c4[a5 + 556 >> 2])) != (0 | (i4 = c4[a5 + 560 >> 2]))) {
                if ((0 | (f4 = i4 - n3 | 0)) < 0)
                  break r;
                for (r5 = ye(f4), c4[e3 + 556 >> 2] = r5, c4[e3 + 564 >> 2] = r5 + f4; c4[r5 >> 2] = c4[n3 >> 2], r5 = r5 + 4 | 0, (0 | i4) != (0 | (n3 = n3 + 4 | 0)); )
                  ;
                c4[e3 + 560 >> 2] = r5;
              }
              r5 = c4[a5 + 572 >> 2], c4[e3 + 568 >> 2] = c4[a5 + 568 >> 2], c4[e3 + 572 >> 2] = r5, c4[e3 + 584 >> 2] = c4[a5 + 584 >> 2], r5 = c4[a5 + 580 >> 2], c4[e3 + 576 >> 2] = c4[a5 + 576 >> 2], c4[e3 + 580 >> 2] = r5, c4[e3 + 552 >> 2] = 0;
            }
            return t5;
          }
          I2(), k2();
        }
        function Xr2(r5, e3) {
          var a5, i4 = 0, n3 = 0;
          ar3 = a5 = ar3 - 16 | 0, c4[a5 + 12 >> 2] = e3;
          r: {
            if (r5) {
              if (e3 = c4[a5 + 12 >> 2], i4 = c4[r5 + 568 >> 2]) {
                if (n3 = c4[i4 + 4 >> 2], v3[i4 + 9 | 0]) {
                  aa[0 | n3](i4, r5, 5, 0, 4215, e3);
                  break r;
                }
                aa[0 | n3](i4, r5, 5, 4215, e3);
                break r;
              }
            } else
              e3 = c4[a5 + 12 >> 2];
            if (v3[6936]) {
              if (i4 = c4[1733], n3 = c4[i4 + 4 >> 2], v3[i4 + 9 | 0]) {
                aa[0 | n3](i4, r5, 5, 0, 4215, e3);
                break r;
              }
            } else
              i4 = ye(28), o3[i4 + 20 >> 1] = 0, c4[i4 + 16 >> 2] = 1065353216, o3[i4 + 10 >> 1] = 0, o3[i4 + 12 >> 1] = 0, c4[i4 >> 2] = 0, c4[i4 + 24 >> 2] = 0, f3[i4 + 9 | 0] = 0, n3 = 1, c4[i4 + 4 >> 2] = 1, f3[i4 + 22 | 0] = 0, c4[1733] = i4, f3[6936] = 1, c4[1732] = c4[1732] + 1;
            aa[0 | n3](i4, r5, 5, 4215, e3);
          }
          ar3 = a5 + 16 | 0;
        }
        function Or2(r5, e3, a5) {
          var i4, n3 = y2(0), t5 = y2(0);
          r5 = r5 + 80 | 0, i4 = c4[4236 + (e3 << 2) >> 2];
          r: {
            e: {
              a:
                if (2139156720 != (0 | (e3 = 2 != (-2 & e3) ? Hr2(r5, i4, 2140081935) : _r2(r5, 5, i4, 2140081935)))) {
                  if (2140081935 == (0 | e3))
                    break r;
                  r5 = 4276;
                  i: {
                    if (2141891242 != (0 | e3)) {
                      if (b2(2, e3), (n3 = d2()) == n3)
                        break i;
                      r5 = 4268;
                    }
                    switch (n3 = m3[r5 >> 2], t5 = y2(NaN), c4[r5 + 4 >> 2] - 1 | 0) {
                      case 0:
                        break r;
                      case 1:
                        break a;
                      default:
                        break e;
                    }
                  }
                  if (b2(2, 536870912 + (-1073741825 & e3) | 0), n3 = d2(), !(1073741824 & e3))
                    break r;
                }
              t5 = y2(y2(n3 * a5) * y2(0.009999999776482582));
            }
            return t5;
          }
          return n3;
        }
        function Lr2(r5, e3, a5) {
          var i4, n3 = y2(0), t5 = y2(0);
          r5 = r5 + 80 | 0, i4 = c4[4220 + (e3 << 2) >> 2];
          r: {
            e: {
              a:
                if (2139156720 != (0 | (e3 = 2 != (-2 & e3) ? Hr2(r5, i4, 2140081935) : _r2(r5, 4, i4, 2140081935)))) {
                  if (2140081935 == (0 | e3))
                    break r;
                  r5 = 4276;
                  i: {
                    if (2141891242 != (0 | e3)) {
                      if (b2(2, e3), (n3 = d2()) == n3)
                        break i;
                      r5 = 4268;
                    }
                    switch (n3 = m3[r5 >> 2], t5 = y2(NaN), c4[r5 + 4 >> 2] - 1 | 0) {
                      case 0:
                        break r;
                      case 1:
                        break a;
                      default:
                        break e;
                    }
                  }
                  if (b2(2, 536870912 + (-1073741825 & e3) | 0), n3 = d2(), !(1073741824 & e3))
                    break r;
                }
              t5 = y2(y2(n3 * a5) * y2(0.009999999776482582));
            }
            return t5;
          }
          return n3;
        }
        function _r2(r5, e3, a5, i4) {
          var n3 = y2(0);
          return n3 = m3[(e3 = (e3 << 2) + r5 | 0) >> 2], 2139156720 == (0 | (e3 = c4[e3 >> 2])) | 2140081935 == (0 | e3) | 2141891242 == (0 | e3) | n3 == n3 || (n3 = m3[(e3 = (a5 << 2) + r5 | 0) >> 2], 2139156720 == (0 | (e3 = c4[e3 >> 2])) | 2140081935 == (0 | e3) | 2141891242 == (0 | e3) | n3 == n3 || 2139156720 == (0 | (e3 = c4[r5 + 24 >> 2])) | 2140081935 == (0 | e3) | 2141891242 == (0 | e3) | (n3 = m3[r5 + 24 >> 2]) == n3 || (n3 = m3[r5 + 32 >> 2], (2139156720 == (0 | (r5 = c4[r5 + 32 >> 2])) | 2140081935 == (0 | r5) | 2141891242 == (0 | r5) || (e3 = i4, n3 == n3)) && (e3 = r5))), e3;
        }
        function Fr2(r5, e3, a5, i4, n3) {
          var t5, f4 = 0, o4 = 0, u3 = y2(0);
          f4 = 2, o4 = c4[r5 + 24 >> 2] >>> 2 & 3;
          r: {
            e: {
              a: {
                if (!(!c4[r5 + 552 >> 2] | 2 != (0 | e3))) {
                  e3 = 0, f4 = 3;
                  i:
                    switch (o4 - 2 | 0) {
                      case 0:
                        break r;
                      case 1:
                        break i;
                      default:
                        break a;
                    }
                  f4 = 2;
                  break r;
                }
                if (e3 = 0, o4 >>> 0 > 1)
                  break e;
              }
              e3 = f4;
            }
            f4 = o4;
          }
          a5 = _e(r5, f4, a5), i4 = _e(r5, e3, i4), u3 = Mr2(r5, f4, n3), m3[(o4 = r5 + 228 | 0) + (c4[4220 + (t5 = f4 << 2) >> 2] << 2) >> 2] = a5 + u3, u3 = Ur2(r5, f4, n3), m3[o4 + (c4[t5 + 4236 >> 2] << 2) >> 2] = a5 + u3, a5 = Mr2(r5, e3, n3), m3[o4 + (c4[4220 + (f4 = e3 << 2) >> 2] << 2) >> 2] = i4 + a5, a5 = Ur2(r5, e3, n3), m3[o4 + (c4[f4 + 4236 >> 2] << 2) >> 2] = i4 + a5;
        }
        function Cr2(r5) {
          var e3 = 0, a5 = 0, i4 = 0, n3 = 0;
          if (r5 |= 0) {
            if (e3 = c4[r5 >> 2], (a5 = c4[e3 + 552 >> 2]) && (ee2(a5, e3), c4[e3 + 552 >> 2] = 0), (0 | (i4 = c4[e3 + 560 >> 2])) != (0 | (a5 = c4[e3 + 556 >> 2])))
              for (n3 = (i4 = i4 - a5 >> 2) >>> 0 <= 1 ? 1 : i4, i4 = 0; c4[c4[a5 + (i4 << 2) >> 2] + 552 >> 2] = 0, (0 | n3) != (0 | (i4 = i4 + 1 | 0)); )
                ;
            c4[e3 + 560 >> 2] = a5, Sr2(e3 + 556 | 0), (a5 = c4[e3 + 556 >> 2]) && (c4[e3 + 560 >> 2] = a5, gr2(a5)), gr2(e3), e3 = c4[r5 + 8 >> 2], c4[r5 + 8 >> 2] = 0, e3 && aa[c4[c4[e3 >> 2] + 4 >> 2]](e3), e3 = c4[r5 + 4 >> 2], c4[r5 + 4 >> 2] = 0, e3 && aa[c4[c4[e3 >> 2] + 4 >> 2]](e3), gr2(r5);
          }
        }
        function Sr2(r5) {
          var e3, a5 = 0, i4 = 0, n3 = 0, t5 = 0;
          ar3 = e3 = ar3 - 32 | 0, a5 = c4[r5 >> 2], (i4 = c4[r5 + 4 >> 2] - a5 >> 2) >>> 0 >= c4[r5 + 8 >> 2] - a5 >> 2 >>> 0 || (i4 = pe(e3 + 8 | 0, i4, i4, r5 + 8 | 0), a5 = c4[r5 >> 2], n3 = c4[r5 + 4 >> 2] - a5 | 0, n3 = wr2(c4[i4 + 4 >> 2] - n3 | 0, a5, n3), a5 = c4[r5 >> 2], c4[r5 >> 2] = n3, c4[i4 + 4 >> 2] = a5, n3 = c4[r5 + 4 >> 2], c4[r5 + 4 >> 2] = c4[i4 + 8 >> 2], c4[i4 + 8 >> 2] = n3, t5 = c4[r5 + 8 >> 2], c4[r5 + 8 >> 2] = c4[i4 + 12 >> 2], c4[i4 >> 2] = a5, c4[i4 + 12 >> 2] = t5, (0 | a5) != (0 | n3) && (c4[i4 + 8 >> 2] = n3 + (3 + (a5 - n3 | 0) & -4)), a5 && gr2(a5)), ar3 = e3 + 32 | 0;
        }
        function Pr2(r5, e3, a5) {
          var i4 = 0, n3 = 0, t5 = 0;
          if (!(32 & v3[0 | r5]))
            r: {
              i4 = e3;
              e: {
                if (!(r5 = c4[(e3 = r5) + 16 >> 2])) {
                  if (me(e3))
                    break e;
                  r5 = c4[e3 + 16 >> 2];
                }
                if (r5 - (t5 = c4[e3 + 20 >> 2]) >>> 0 < a5 >>> 0) {
                  aa[c4[e3 + 36 >> 2]](e3, i4, a5);
                  break r;
                }
                a:
                  if (!(c4[e3 + 80 >> 2] < 0)) {
                    for (r5 = a5; ; ) {
                      if (n3 = r5, !r5)
                        break a;
                      if (10 == v3[i4 + (r5 = n3 - 1 | 0) | 0])
                        break;
                    }
                    if (aa[c4[e3 + 36 >> 2]](e3, i4, n3) >>> 0 < n3 >>> 0)
                      break e;
                    i4 = i4 + n3 | 0, a5 = a5 - n3 | 0, t5 = c4[e3 + 20 >> 2];
                  }
                Ar2(t5, i4, a5), c4[e3 + 20 >> 2] = c4[e3 + 20 >> 2] + a5;
              }
            }
        }
        function Yr2(r5, e3, a5) {
          var i4, n3 = 0, t5 = 0;
          ar3 = i4 = ar3 - 16 | 0, n3 = r5 + 24 | 0, aa[0 | e3](i4 + 8 | 0, n3), t5 = c4[i4 + 12 >> 2];
          r:
            if ((c4[c4[i4 + 8 >> 2] >> 2] & 7 << t5) >> t5 != (0 | a5))
              for (aa[0 | e3](i4 + 8 | 0, n3), n3 = e3 = c4[i4 + 8 >> 2], t5 = c4[e3 >> 2], e3 = c4[i4 + 12 >> 2], c4[n3 >> 2] = t5 & (7 << e3 ^ -1) | (7 & a5) << e3; ; ) {
                if (4 & (e3 = v3[r5 + 4 | 0]))
                  break r;
                if (f3[r5 + 4 | 0] = 4 | e3, (e3 = c4[r5 + 20 >> 2]) && aa[0 | e3](r5), c4[r5 + 308 >> 2] = 2143289344, !(r5 = c4[r5 + 552 >> 2]))
                  break;
              }
          ar3 = i4 + 16 | 0;
        }
        function Ur2(r5, e3, a5) {
          var i4, n3 = y2(0);
          r5 = r5 + 44 | 0, i4 = c4[4236 + (e3 << 2) >> 2];
          r: {
            if (2139156720 != (0 | (r5 = 2 != (-2 & e3) ? Hr2(r5, i4, 2140081935) : _r2(r5, 5, i4, 2140081935)))) {
              if (2140081935 == (0 | r5) | 2141891242 == (0 | r5))
                break r;
              if (b2(2, r5), (n3 = d2()) != n3)
                return y2(NaN);
              if (b2(2, 536870912 + (-1073741825 & r5) | 0), n3 = d2(), !(1073741824 & r5))
                break r;
            }
            n3 = y2(y2(n3 * a5) * y2(0.009999999776482582));
          }
          return n3;
        }
        function Mr2(r5, e3, a5) {
          var i4, n3 = y2(0);
          r5 = r5 + 44 | 0, i4 = c4[4220 + (e3 << 2) >> 2];
          r: {
            if (2139156720 != (0 | (r5 = 2 != (-2 & e3) ? Hr2(r5, i4, 2140081935) : _r2(r5, 4, i4, 2140081935)))) {
              if (2140081935 == (0 | r5) | 2141891242 == (0 | r5))
                break r;
              if (b2(2, r5), (n3 = d2()) != n3)
                return y2(NaN);
              if (b2(2, 536870912 + (-1073741825 & r5) | 0), n3 = d2(), !(1073741824 & r5))
                break r;
            }
            n3 = y2(y2(n3 * a5) * y2(0.009999999776482582));
          }
          return n3;
        }
        function Hr2(r5, e3, a5) {
          var i4 = y2(0);
          return i4 = m3[(e3 = (e3 << 2) + r5 | 0) >> 2], 2139156720 == (0 | (e3 = c4[e3 >> 2])) | 2140081935 == (0 | e3) | 2141891242 == (0 | e3) | i4 == i4 || 2139156720 == (0 | (e3 = c4[r5 + 28 >> 2])) | 2140081935 == (0 | e3) | 2141891242 == (0 | e3) | (i4 = m3[r5 + 28 >> 2]) == i4 || (i4 = m3[r5 + 32 >> 2], (2139156720 == (0 | (r5 = c4[r5 + 32 >> 2])) | 2140081935 == (0 | r5) | 2141891242 == (0 | r5) || (e3 = a5, i4 == i4)) && (e3 = r5)), e3;
        }
        function Qr2(r5, e3) {
          var a5, i4 = y2(0);
          return r5 = r5 + 152 | 0, a5 = c4[4236 + (e3 << 2) >> 2], r5 = 2 != (-2 & e3) ? Hr2(r5, a5, 2140081935) : _r2(r5, 5, a5, 2140081935), i4 = y2(0), 2139156720 != (0 | r5) && (i4 = y2(0), 2140081935 != (0 | r5) && (2141891242 == (0 | r5) || (b2(2, r5), (i4 = d2()) != i4) ? i4 = y2(NaN) : (b2(2, 536870912 + (-1073741825 & r5) | 0), i4 = d2()))), Re(i4, y2(0));
        }
        function zr2(r5, e3) {
          var a5, i4 = y2(0);
          return r5 = r5 + 152 | 0, a5 = c4[4220 + (e3 << 2) >> 2], r5 = 2 != (-2 & e3) ? Hr2(r5, a5, 2140081935) : _r2(r5, 4, a5, 2140081935), i4 = y2(0), 2139156720 != (0 | r5) && (i4 = y2(0), 2140081935 != (0 | r5) && (2141891242 == (0 | r5) || (b2(2, r5), (i4 = d2()) != i4) ? i4 = y2(NaN) : (b2(2, 536870912 + (-1073741825 & r5) | 0), i4 = d2()))), Re(i4, y2(0));
        }
        function jr2(r5, e3, a5, i4) {
          var n3, t5 = 0, f4 = 0;
          r:
            if ((n3 = (t5 = (t5 = dr2(r5 *= e3)) < 0 ? t5 + 1 : t5) != t5) | !(E3(t5) < 1e-4)) {
              if (t5 == t5) {
                if (r5 -= t5, E3(t5 + -1) < 1e-4) {
                  r5 += 1;
                  break r;
                }
              } else
                r5 -= t5;
              a5 ? r5 += 1 : i4 || (f4 = 0, n3 || (f4 = 1, t5 > 0.5 || (f4 = E3(t5 + -0.5) < 1e-4 ? 1 : 0)), r5 += f4);
            } else
              r5 -= t5;
          return y2(r5 != r5 | e3 != e3 ? NaN : r5 / e3);
        }
        function Dr2(r5) {
          var e3 = y2(0), a5 = 0, i4 = y2(0);
          a5 = 0;
          r:
            if (131072 != (196608 & c4[r5 + 24 >> 2])) {
              if (c4[r5 + 552 >> 2]) {
                if (((e3 = m3[r5 + 32 >> 2]) == e3 || (e3 = m3[r5 + 28 >> 2]) > y2(0)) && (a5 = 1, e3 != y2(0)))
                  break r;
                (e3 = m3[r5 + 36 >> 2]) != e3 && (f3[r5 + 4 | 0] < 0 ? e3 = y2(1) : (e3 = y2(0), (i4 = m3[r5 + 28 >> 2]) < y2(0) && (e3 = y2(-i4))));
              }
              a5 = e3 != y2(0);
            }
          return a5;
        }
        function xr2(r5, e3) {
          var a5 = y2(0);
          r: {
            if (2139156720 != (0 | e3)) {
              if (2140081935 != (0 | e3)) {
                if (2141891242 != (0 | e3))
                  break r;
                return c4[r5 >> 2] = 2143289344, void (c4[r5 + 4 >> 2] = 3);
              }
              return c4[r5 >> 2] = 0, void (c4[r5 + 4 >> 2] = 1);
            }
            return c4[r5 >> 2] = 0, void (c4[r5 + 4 >> 2] = 2);
          }
          if (b2(2, e3), (a5 = d2()) != a5)
            return c4[r5 >> 2] = 2143289344, void (c4[r5 + 4 >> 2] = 0);
          c4[r5 + 4 >> 2] = 1073741824 & e3 ? 2 : 1, c4[r5 >> 2] = 536870912 + (-1073741825 & e3);
        }
        function Jr2(r5) {
          var e3 = 0, a5 = 0, i4 = 0;
          r:
            if (8 & (a5 = c4[r5 + 24 >> 2]) && (e3 = 1, 5120 != (7168 & a5) && (e3 = 0, (0 | (i4 = c4[r5 + 560 >> 2])) != (0 | (a5 = c4[r5 + 556 >> 2])))))
              for (i4 = (r5 = i4 - a5 >> 2) >>> 0 <= 1 ? 1 : r5, r5 = 0; ; ) {
                if (e3 = 131072 != (196608 & (e3 = c4[c4[a5 + (r5 << 2) >> 2] + 24 >> 2])) & 40960 == (57344 & e3))
                  break r;
                if ((0 | i4) == (0 | (r5 = r5 + 1 | 0)))
                  break;
              }
          return e3;
        }
        function Kr2(r5) {
          var e3 = 0, a5 = y2(0);
          return e3 = 2143289344, y2(E3(r5)) == y2(1 / 0) | r5 != r5 || (e3 = 2139156720, r5 < y2(10842021724855044e-35) & r5 > y2(-10842021724855044e-35) | r5 == y2(0) || (b2(2, -2147483648 & (l3(r5), u2(2)) | 1602224127), a5 = d2(), e3 = 1073741824 | (l3(r5 > y2(18446742974197924e3) || r5 < y2(-18446742974197924e3) ? a5 : r5), u2(2) - 536870912))), e3;
        }
        function qr2(r5) {
          var e3 = 0, a5 = y2(0);
          return e3 = 2143289344, y2(E3(r5)) == y2(1 / 0) | r5 != r5 || (e3 = 2140081935, r5 < y2(10842021724855044e-35) & r5 > y2(-10842021724855044e-35) | r5 == y2(0) || (b2(2, -2147483648 & (l3(r5), u2(2)) | 1610612735), a5 = d2(), e3 = 0 | (l3(r5 > y2(36893485948395848e3) || r5 < y2(-36893485948395848e3) ? a5 : r5), u2(2) - 536870912))), e3;
        }
        function $r2(r5, e3) {
          return e3 ? e3 = Te(c4[e3 >> 2]) : (v3[6936] ? e3 = c4[1733] : (e3 = ye(28), o3[e3 + 20 >> 1] = 0, c4[e3 + 16 >> 2] = 1065353216, o3[e3 + 10 >> 1] = 0, o3[e3 + 12 >> 1] = 0, c4[e3 >> 2] = 0, c4[e3 + 24 >> 2] = 0, f3[e3 + 9 | 0] = 0, c4[e3 + 4 >> 2] = 1, f3[e3 + 22 | 0] = 0, c4[1733] = e3, f3[6936] = 1, c4[1732] = c4[1732] + 1), e3 = Te(e3)), c4[r5 + 4 >> 2] = 0, c4[r5 + 8 >> 2] = 0, c4[r5 >> 2] = e3, c4[e3 >> 2] = r5, r5;
        }
        function re2(r5, e3, a5) {
          var i4 = 0, n3 = 0, t5 = 0;
          if (e3)
            for (; r5 = Ae(i4 = hr2(r5, e3, 10), n3 = ir2, 246, 0) + r5 | 0, f3[0 | (a5 = a5 - 1 | 0)] = 48 | r5, t5 = e3 >>> 0 > 9, r5 = i4, e3 = n3, t5; )
              ;
          else
            i4 = r5;
          if (i4)
            for (; r5 = (i4 >>> 0) / 10 | 0, f3[0 | (a5 = a5 - 1 | 0)] = w2(r5, 246) + i4 | 48, e3 = i4 >>> 0 > 9, i4 = r5, e3; )
              ;
          return a5;
        }
        function ee2(r5, e3) {
          var a5 = 0, i4 = 0;
          r: {
            e:
              if ((0 | (a5 = c4[r5 + 556 >> 2])) != (0 | (i4 = c4[r5 + 560 >> 2]))) {
                for (; ; ) {
                  if (c4[a5 >> 2] == (0 | e3))
                    break e;
                  if ((0 | i4) == (0 | (a5 = a5 + 4 | 0)))
                    break;
                }
                break r;
              }
            if ((0 | a5) != (0 | i4))
              return wr2(a5, e3 = a5 + 4 | 0, i4 - e3 | 0), c4[r5 + 560 >> 2] = i4 - 4, 1;
          }
          return 0;
        }
        function ae2(r5, e3) {
          var a5, i4, n3 = 0;
          if (A3(+r5), a5 = 0 | u2(1), i4 = 0 | u2(0), 2047 != (0 | (n3 = a5 >>> 20 & 2047))) {
            if (!n3)
              return 0 == r5 ? n3 = 0 : (r5 = ae2(18446744073709552e3 * r5, e3), n3 = c4[e3 >> 2] + -64 | 0), c4[e3 >> 2] = n3, r5;
            c4[e3 >> 2] = n3 - 1022, b2(0, 0 | i4), b2(1, -2146435073 & a5 | 1071644672), r5 = +s3();
          }
          return r5;
        }
        function ie2(r5, e3, a5) {
          var i4 = 0;
          r:
            if (c4[184 + ((i4 = r5 + 24 | 0) + (e3 << 2) | 0) >> 2] != (0 | a5))
              for (c4[184 + ((e3 << 2) + i4 | 0) >> 2] = a5; ; ) {
                if (4 & (e3 = v3[r5 + 4 | 0]))
                  break r;
                if (f3[r5 + 4 | 0] = 4 | e3, (e3 = c4[r5 + 20 >> 2]) && aa[0 | e3](r5), c4[r5 + 308 >> 2] = 2143289344, !(r5 = c4[r5 + 552 >> 2]))
                  break;
              }
        }
        function ne2(r5, e3, a5) {
          var i4 = 0;
          r:
            if (c4[192 + ((i4 = r5 + 24 | 0) + (e3 << 2) | 0) >> 2] != (0 | a5))
              for (c4[192 + ((e3 << 2) + i4 | 0) >> 2] = a5; ; ) {
                if (4 & (e3 = v3[r5 + 4 | 0]))
                  break r;
                if (f3[r5 + 4 | 0] = 4 | e3, (e3 = c4[r5 + 20 >> 2]) && aa[0 | e3](r5), c4[r5 + 308 >> 2] = 2143289344, !(r5 = c4[r5 + 552 >> 2]))
                  break;
              }
        }
        function te2(r5, e3, a5) {
          var i4 = 0;
          r:
            if (c4[176 + ((i4 = r5 + 24 | 0) + (e3 << 2) | 0) >> 2] != (0 | a5))
              for (c4[176 + ((e3 << 2) + i4 | 0) >> 2] = a5; ; ) {
                if (4 & (e3 = v3[r5 + 4 | 0]))
                  break r;
                if (f3[r5 + 4 | 0] = 4 | e3, (e3 = c4[r5 + 20 >> 2]) && aa[0 | e3](r5), c4[r5 + 308 >> 2] = 2143289344, !(r5 = c4[r5 + 552 >> 2]))
                  break;
              }
        }
        function fe(r5, e3) {
          var a5 = 0, i4 = 0, n3 = 0;
          r:
            if (c4[16 + (a5 = r5 + 24 | 0) >> 2] != (0 | e3))
              for (i4 = 0 | aa[9](a5), n3 = e3, c4[i4 + 16 >> 2] = n3; ; ) {
                if (4 & (e3 = v3[r5 + 4 | 0]))
                  break r;
                if (f3[r5 + 4 | 0] = 4 | e3, (e3 = c4[r5 + 20 >> 2]) && aa[0 | e3](r5), c4[r5 + 308 >> 2] = 2143289344, !(r5 = c4[r5 + 552 >> 2]))
                  break;
              }
        }
        function oe(r5, e3, a5) {
          var i4 = 0;
          r:
            if (c4[56 + ((i4 = r5 + 24 | 0) + (e3 << 2) | 0) >> 2] != (0 | a5))
              for (c4[56 + ((e3 << 2) + i4 | 0) >> 2] = a5; ; ) {
                if (4 & (e3 = v3[r5 + 4 | 0]))
                  break r;
                if (f3[r5 + 4 | 0] = 4 | e3, (e3 = c4[r5 + 20 >> 2]) && aa[0 | e3](r5), c4[r5 + 308 >> 2] = 2143289344, !(r5 = c4[r5 + 552 >> 2]))
                  break;
              }
        }
        function ce(r5, e3, a5) {
          var i4 = 0;
          r:
            if (c4[92 + ((i4 = r5 + 24 | 0) + (e3 << 2) | 0) >> 2] != (0 | a5))
              for (c4[92 + ((e3 << 2) + i4 | 0) >> 2] = a5; ; ) {
                if (4 & (e3 = v3[r5 + 4 | 0]))
                  break r;
                if (f3[r5 + 4 | 0] = 4 | e3, (e3 = c4[r5 + 20 >> 2]) && aa[0 | e3](r5), c4[r5 + 308 >> 2] = 2143289344, !(r5 = c4[r5 + 552 >> 2]))
                  break;
              }
        }
        function ue(r5, e3, a5) {
          var i4 = 0;
          r:
            if (c4[20 + ((i4 = r5 + 24 | 0) + (e3 << 2) | 0) >> 2] != (0 | a5))
              for (c4[20 + ((e3 << 2) + i4 | 0) >> 2] = a5; ; ) {
                if (4 & (e3 = v3[r5 + 4 | 0]))
                  break r;
                if (f3[r5 + 4 | 0] = 4 | e3, (e3 = c4[r5 + 20 >> 2]) && aa[0 | e3](r5), c4[r5 + 308 >> 2] = 2143289344, !(r5 = c4[r5 + 552 >> 2]))
                  break;
              }
        }
        function be(r5, e3) {
          var a5, i4 = y2(0);
          return r5 = r5 + 80 | 0, a5 = c4[4236 + (e3 << 2) >> 2], 2139156720 == (0 | (r5 = 2 != (-2 & e3) ? Hr2(r5, a5, 2143289344) : _r2(r5, 5, a5, 2143289344))) | 2140081935 == (0 | r5) | 2141891242 == (0 | r5) ? r5 = 1 : (b2(2, r5), r5 = (i4 = d2()) == i4), r5;
        }
        function se(r5, e3) {
          var a5, i4 = y2(0);
          return r5 = r5 + 80 | 0, a5 = c4[4220 + (e3 << 2) >> 2], 2139156720 == (0 | (r5 = 2 != (-2 & e3) ? Hr2(r5, a5, 2143289344) : _r2(r5, 4, a5, 2143289344))) | 2140081935 == (0 | r5) | 2141891242 == (0 | r5) ? r5 = 1 : (b2(2, r5), r5 = (i4 = d2()) == i4), r5;
        }
        function Ae(r5, e3, a5, i4) {
          var n3, t5, f4, o4, c5 = 0, u3 = 0;
          return o4 = w2(c5 = a5 >>> 16 | 0, u3 = r5 >>> 16 | 0), c5 = (65535 & (u3 = ((f4 = w2(n3 = 65535 & a5, t5 = 65535 & r5)) >>> 16 | 0) + w2(u3, n3) | 0)) + w2(c5, t5) | 0, ir2 = (w2(e3, a5) + o4 | 0) + w2(r5, i4) + (u3 >>> 16) + (c5 >>> 16) | 0, 65535 & f4 | c5 << 16;
        }
        function ke(r5, e3) {
          var a5, i4, n3 = 0;
          ar3 = a5 = ar3 - 16 | 0, i4 = -17 & (n3 = v3[r5 + 4 | 0]), f3[r5 + 4 | 0] = i4;
          r: {
            if (e3) {
              if (c4[r5 + 560 >> 2] != c4[r5 + 556 >> 2])
                break r;
              n3 = 8 | i4;
            } else
              n3 &= 231;
            return c4[r5 + 8 >> 2] = e3, f3[r5 + 4 | 0] = n3, void (ar3 = a5 + 16 | 0);
          }
          c4[a5 >> 2] = 4059, Xr2(r5, a5), De(), k2();
        }
        function le(r5, e3, a5, i4, n3) {
          var t5;
          if (ar3 = t5 = ar3 - 256 | 0, !(73728 & n3 | (0 | a5) <= (0 | i4))) {
            if (Rr2(t5, 255 & e3, (a5 = (i4 = a5 - i4 | 0) >>> 0 < 256) ? i4 : 256), !a5)
              for (; Pr2(r5, t5, 256), (i4 = i4 - 256 | 0) >>> 0 > 255; )
                ;
            Pr2(r5, t5, i4);
          }
          ar3 = t5 + 256 | 0;
        }
        function de(r5, e3, a5) {
          var i4 = 0, n3 = y2(0);
          2 == (-2 & a5) && (n3 = m3[(i4 = e3 - -64 | 0) >> 2], 2139156720 == (0 | (i4 = c4[i4 >> 2])) | 2140081935 == (0 | i4) | 2141891242 == (0 | i4) | n3 == n3) || (i4 = c4[44 + ((c4[4236 + (a5 << 2) >> 2] << 2) + e3 | 0) >> 2]), xr2(r5, i4);
        }
        function ve(r5, e3, a5) {
          var i4 = 0, n3 = y2(0);
          2 == (-2 & a5) && 2139156720 == (0 | (i4 = c4[e3 + 60 >> 2])) | 2140081935 == (0 | i4) | 2141891242 == (0 | i4) | (n3 = m3[e3 + 60 >> 2]) == n3 || (i4 = c4[44 + ((c4[4220 + (a5 << 2) >> 2] << 2) + e3 | 0) >> 2]), xr2(r5, i4);
        }
        function he(r5) {
          var e3 = 0, a5 = 0, i4 = 0;
          for (i4 = c4[r5 >> 2]; xe(a5 = f3[0 | i4]); )
            i4 = i4 + 1 | 0, c4[r5 >> 2] = i4, e3 = e3 >>> 0 <= 214748364 ? (0 | (a5 = a5 - 48 | 0)) > (2147483647 ^ (e3 = w2(e3, 10))) ? -1 : a5 + e3 | 0 : -1;
          return e3;
        }
        function pe(r5, e3, a5, i4) {
          var n3 = 0;
          c4[r5 + 12 >> 2] = 0, c4[r5 + 16 >> 2] = i4;
          r: {
            if (e3) {
              if (e3 >>> 0 >= 1073741824)
                break r;
              n3 = ye(e3 << 2);
            }
            return c4[r5 >> 2] = n3, a5 = (a5 << 2) + n3 | 0, c4[r5 + 8 >> 2] = a5, c4[r5 + 12 >> 2] = (e3 << 2) + n3, c4[r5 + 4 >> 2] = a5, r5;
          }
          ea(), k2();
        }
        function me(r5) {
          var e3 = 0;
          return e3 = c4[r5 + 72 >> 2], c4[r5 + 72 >> 2] = e3 - 1 | e3, 8 & (e3 = c4[r5 >> 2]) ? (c4[r5 >> 2] = 32 | e3, -1) : (c4[r5 + 4 >> 2] = 0, c4[r5 + 8 >> 2] = 0, e3 = c4[r5 + 44 >> 2], c4[r5 + 28 >> 2] = e3, c4[r5 + 20 >> 2] = e3, c4[r5 + 16 >> 2] = e3 + c4[r5 + 48 >> 2], 0);
        }
        function Ne(r5, e3, a5, i4) {
          e3 |= 0, a5 |= 0, i4 |= 0;
          var n3 = 0;
          n3 = c4[(r5 |= 0) >> 2], e3 = ((r5 = c4[r5 + 4 >> 2]) >> 1) + e3 | 0, 1 & r5 && (n3 = c4[n3 + c4[e3 >> 2] >> 2]), aa[0 | n3](e3, a5, i4);
        }
        function we(r5, e3, a5) {
          e3 |= 0, a5 |= 0;
          var i4 = 0;
          return i4 = c4[(r5 |= 0) >> 2], e3 = ((r5 = c4[r5 + 4 >> 2]) >> 1) + e3 | 0, 1 & r5 && (i4 = c4[i4 + c4[e3 >> 2] >> 2]), 0 | aa[0 | i4](e3, a5);
        }
        function ye(r5) {
          var e3 = 0;
          r5 = r5 || 1;
          r: {
            for (; ; ) {
              if (e3 = cr2(r5))
                break r;
              if (!(e3 = c4[2022]))
                break;
              aa[0 | e3]();
            }
            I2(), k2();
          }
          return e3;
        }
        function Ee(r5, e3, a5) {
          e3 |= 0, a5 |= 0;
          var i4 = 0;
          i4 = c4[(r5 |= 0) >> 2], e3 = ((r5 = c4[r5 + 4 >> 2]) >> 1) + e3 | 0, 1 & r5 && (i4 = c4[i4 + c4[e3 >> 2] >> 2]), aa[0 | i4](e3, a5);
        }
        function Ge(r5, e3) {
          e3 |= 0;
          var a5 = 0;
          return a5 = c4[(r5 |= 0) >> 2], e3 = ((r5 = c4[r5 + 4 >> 2]) >> 1) + e3 | 0, 1 & r5 && (a5 = c4[a5 + c4[e3 >> 2] >> 2]), 0 | aa[0 | a5](e3);
        }
        function Re(r5, e3) {
          return (2147483647 & (l3(r5), u2(2))) >>> 0 <= 2139095040 ? (2147483647 & (l3(e3), u2(2))) >>> 0 > 2139095040 ? r5 : y2(g4(r5, e3)) : e3;
        }
        function ge(r5, e3) {
          return (2147483647 & (l3(r5), u2(2))) >>> 0 <= 2139095040 ? (2147483647 & (l3(e3), u2(2))) >>> 0 > 2139095040 ? r5 : y2(R4(r5, e3)) : e3;
        }
        function Ze(r5, e3) {
          var a5;
          return r5 |= 0, e3 |= 0, ar3 = a5 = ar3 - 16 | 0, c4[a5 + 8 >> 2] = e3, r5 = 0 | aa[0 | r5](a5 + 8 | 0), X2(c4[a5 + 8 >> 2]), ar3 = a5 + 16 | 0, 0 | r5;
        }
        function We(r5, e3) {
          return r5 ? (57216 == (-128 & e3) | e3 >>> 0 <= 127 ? (f3[0 | r5] = e3, r5 = 1) : (c4[1761] = 25, r5 = -1), r5) : 0;
        }
        function Ve(r5, e3) {
          var a5, i4;
          a5 = ye(4), c4[a5 >> 2] = e3, i4 = ye(4), c4[i4 >> 2] = e3, O2(6955, 0 | r5, 7018, 4630, 192, 0 | a5, 7018, 4634, 193, 0 | i4);
        }
        function Be(r5, e3) {
          var a5, i4;
          a5 = ye(4), c4[a5 >> 2] = e3, i4 = ye(4), c4[i4 >> 2] = e3, O2(6985, 0 | r5, 7018, 4630, 190, 0 | a5, 7018, 4634, 191, 0 | i4);
        }
        function Te(r5) {
          var e3, a5;
          return ar3 = e3 = ar3 - 16 | 0, a5 = br2(ye(588), r5), r5 || (c4[e3 >> 2] = 2759, Xr2(0, e3), De(), k2()), ar3 = e3 + 16 | 0, a5;
        }
        function Ie(r5, e3) {
          var a5 = 0;
          1 & f3[6964] ? a5 = c4[1740] : (a5 = 0 | C3(1, 4400), f3[6964] = 1, c4[1740] = a5), z3(0 | a5, 0 | r5, 0 | e3, 0);
        }
        function Xe(r5, e3) {
          e3 |= 0;
          var a5 = 0;
          a5 = c4[(r5 |= 0) >> 2], e3 = ((r5 = c4[r5 + 4 >> 2]) >> 1) + e3 | 0, 1 & r5 && (a5 = c4[a5 + c4[e3 >> 2] >> 2]), aa[0 | a5](e3);
        }
        function Oe(r5) {
          return c4[(r5 |= 0) >> 2] = 4508, v3[r5 + 4 | 0] && Ie(c4[r5 + 8 >> 2], 1758), X2(c4[r5 + 8 >> 2]), 0 | r5;
        }
        function Le(r5) {
          return c4[(r5 |= 0) >> 2] = 4388, v3[r5 + 4 | 0] && Ie(c4[r5 + 8 >> 2], 1758), X2(c4[r5 + 8 >> 2]), 0 | r5;
        }
        function _e(r5, e3, a5) {
          return se(r5, e3) ? Lr2(r5, e3, a5) : ((a5 = Or2(r5, e3, a5)) == a5 && (a5 = y2(-a5)), a5);
        }
        function Fe(r5) {
          var e3 = 0;
          (r5 |= 0) && ((e3 = c4[r5 >> 2]) && gr2(e3), c4[1732] = c4[1732] - 1, gr2(r5));
        }
        function Ce(r5, e3, a5) {
          e3 |= 0, a5 = +a5, N2[c4[(r5 |= 0) >> 2] + e3 >> 3] = a5;
        }
        function Se(r5, e3) {
          return e3 |= 0, +N2[c4[(r5 |= 0) >> 2] + e3 >> 3];
        }
        function Pe(r5) {
          (r5 |= 0) && aa[c4[c4[r5 >> 2] + 4 >> 2]](r5);
        }
        function Ye(r5) {
          return r5 ? (c4[1761] = r5, -1) : 0;
        }
        function Ue(r5, e3, a5) {
          return y2(Mr2(r5, e3, a5) + Ur2(r5, e3, a5));
        }
        function Me(r5, e3, a5, i4) {
          D(0 | r5, 0 | e3, 8, 0, 0 | a5, -1, 0 | i4);
        }
        function He(r5, e3) {
          e3 |= 0, aa[c4[(r5 |= 0) >> 2]](e3);
        }
        function Qe(r5, e3, a5) {
          return Zr2(r5, e3, a5, 2, 3);
        }
        function ze(r5) {
          return 0 | aa[0 | (r5 |= 0)]();
        }
        function je(r5, e3) {
          e3 |= 0, aa[0 | (r5 |= 0)](e3);
        }
        function De() {
          aa[c4[1470]](), ea(), k2();
        }
        function xe(r5) {
          return r5 - 48 >>> 0 < 10;
        }
        function Je(r5) {
          (r5 |= 0) && gr2(r5);
        }
        function Ke(r5) {
          return 0 | r5;
        }
        function qe(r5) {
          f3[4 + (r5 |= 0) | 0] = 1;
        }
        function $e(r5) {
          k2();
        }
        function ra() {
          ea(), k2();
        }
        function ea() {
          I2(), k2();
        }
        n2(e2 = v3, 1024, "T25seSBsZWFmIG5vZGVzIHdpdGggY3VzdG9tIG1lYXN1cmUgZnVuY3Rpb25zc2hvdWxkIG1hbnVhbGx5IG1hcmsgdGhlbXNlbHZlcyBhcyBkaXJ0eQBpc0RpcnR5AG1hcmtEaXJ0eQBkZXN0cm95AHNldERpc3BsYXkAZ2V0RGlzcGxheQBzZXRGbGV4AC0rICAgMFgweAAtMFgrMFggMFgtMHgrMHggMHgAc2V0RmxleEdyb3cAZ2V0RmxleEdyb3cAc2V0T3ZlcmZsb3cAZ2V0T3ZlcmZsb3cAY2FsY3VsYXRlTGF5b3V0AGdldENvbXB1dGVkTGF5b3V0AHVuc2lnbmVkIHNob3J0AGdldENoaWxkQ291bnQAdW5zaWduZWQgaW50AHNldEp1c3RpZnlDb250ZW50AGdldEp1c3RpZnlDb250ZW50AHNldEFsaWduQ29udGVudABnZXRBbGlnbkNvbnRlbnQAZ2V0UGFyZW50AGltcGxlbWVudABzZXRNYXhIZWlnaHRQZXJjZW50AHNldEhlaWdodFBlcmNlbnQAc2V0TWluSGVpZ2h0UGVyY2VudABzZXRGbGV4QmFzaXNQZXJjZW50AHNldFBvc2l0aW9uUGVyY2VudABzZXRNYXJnaW5QZXJjZW50AHNldE1heFdpZHRoUGVyY2VudABzZXRXaWR0aFBlcmNlbnQAc2V0TWluV2lkdGhQZXJjZW50AHNldFBhZGRpbmdQZXJjZW50AGNyZWF0ZURlZmF1bHQAdW5pdAByaWdodABoZWlnaHQAc2V0TWF4SGVpZ2h0AGdldE1heEhlaWdodABzZXRIZWlnaHQAZ2V0SGVpZ2h0AHNldE1pbkhlaWdodABnZXRNaW5IZWlnaHQAZ2V0Q29tcHV0ZWRIZWlnaHQAZ2V0Q29tcHV0ZWRSaWdodABsZWZ0AGdldENvbXB1dGVkTGVmdAByZXNldABfX2Rlc3RydWN0AGZsb2F0AHVpbnQ2NF90AHVzZVdlYkRlZmF1bHRzAHNldFVzZVdlYkRlZmF1bHRzAHNldEFsaWduSXRlbXMAZ2V0QWxpZ25JdGVtcwBzZXRGbGV4QmFzaXMAZ2V0RmxleEJhc2lzAENhbm5vdCBnZXQgbGF5b3V0IHByb3BlcnRpZXMgb2YgbXVsdGktZWRnZSBzaG9ydGhhbmRzAHVzZUxlZ2FjeVN0cmV0Y2hCZWhhdmlvdXIAc2V0VXNlTGVnYWN5U3RyZXRjaEJlaGF2aW91cgBzZXRQb2ludFNjYWxlRmFjdG9yAE1lYXN1cmVDYWxsYmFja1dyYXBwZXIARGlydGllZENhbGxiYWNrV3JhcHBlcgBDYW5ub3QgcmVzZXQgYSBub2RlIHN0aWxsIGF0dGFjaGVkIHRvIGEgb3duZXIAc2V0Qm9yZGVyAGdldEJvcmRlcgBnZXRDb21wdXRlZEJvcmRlcgB1bnNpZ25lZCBjaGFyAHRvcABnZXRDb21wdXRlZFRvcABzZXRGbGV4V3JhcABnZXRGbGV4V3JhcABzZXRHYXAAZ2V0R2FwACVwAHNldEhlaWdodEF1dG8Ac2V0RmxleEJhc2lzQXV0bwBzZXRNYXJnaW5BdXRvAHNldFdpZHRoQXV0bwBTY2FsZSBmYWN0b3Igc2hvdWxkIG5vdCBiZSBsZXNzIHRoYW4gemVybwBzZXRBc3BlY3RSYXRpbwBnZXRBc3BlY3RSYXRpbwBzZXRQb3NpdGlvbgBnZXRQb3NpdGlvbgBub3RpZnlPbkRlc3RydWN0aW9uAHNldEZsZXhEaXJlY3Rpb24AZ2V0RmxleERpcmVjdGlvbgBzZXRNYXJnaW4AZ2V0TWFyZ2luAGdldENvbXB1dGVkTWFyZ2luAG5hbgBib3R0b20AZ2V0Q29tcHV0ZWRCb3R0b20AYm9vbABlbXNjcmlwdGVuOjp2YWwAc2V0RmxleFNocmluawBnZXRGbGV4U2hyaW5rAE1lYXN1cmVDYWxsYmFjawBEaXJ0aWVkQ2FsbGJhY2sAd2lkdGgAc2V0TWF4V2lkdGgAZ2V0TWF4V2lkdGgAc2V0V2lkdGgAZ2V0V2lkdGgAc2V0TWluV2lkdGgAZ2V0TWluV2lkdGgAZ2V0Q29tcHV0ZWRXaWR0aAB1bnNpZ25lZCBsb25nAHN0ZDo6d3N0cmluZwBzdGQ6OnN0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwBzZXRQYWRkaW5nAGdldFBhZGRpbmcAZ2V0Q29tcHV0ZWRQYWRkaW5nAFRyaWVkIHRvIGNvbnN0cnVjdCBZR05vZGUgd2l0aCBudWxsIGNvbmZpZwBjcmVhdGVXaXRoQ29uZmlnAGluZgBzZXRBbGlnblNlbGYAZ2V0QWxpZ25TZWxmAFNpemUAdmFsdWUAVmFsdWUAY3JlYXRlAG1lYXN1cmUAc2V0UG9zaXRpb25UeXBlAGdldFBvc2l0aW9uVHlwZQBpc1JlZmVyZW5jZUJhc2VsaW5lAHNldElzUmVmZXJlbmNlQmFzZWxpbmUAY29weVN0eWxlAGRvdWJsZQBOb2RlAGV4dGVuZABpbnNlcnRDaGlsZABnZXRDaGlsZAByZW1vdmVDaGlsZAB2b2lkAGF2YWlsYWJsZUhlaWdodCBpcyBpbmRlZmluaXRlIHNvIGhlaWdodE1lYXN1cmVNb2RlIG11c3QgYmUgWUdNZWFzdXJlTW9kZVVuZGVmaW5lZABhdmFpbGFibGVXaWR0aCBpcyBpbmRlZmluaXRlIHNvIHdpZHRoTWVhc3VyZU1vZGUgbXVzdCBiZSBZR01lYXN1cmVNb2RlVW5kZWZpbmVkAHNldEV4cGVyaW1lbnRhbEZlYXR1cmVFbmFibGVkAGlzRXhwZXJpbWVudGFsRmVhdHVyZUVuYWJsZWQAZGlydGllZABDYW5ub3QgcmVzZXQgYSBub2RlIHdoaWNoIHN0aWxsIGhhcyBjaGlsZHJlbiBhdHRhY2hlZAB1bnNldE1lYXN1cmVGdW5jAHVuc2V0RGlydGllZEZ1bmMARXhwZWN0IGN1c3RvbSBiYXNlbGluZSBmdW5jdGlvbiB0byBub3QgcmV0dXJuIE5hTgBOQU4ASU5GAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4Ac3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGRvdWJsZT4AQ2hpbGQgYWxyZWFkeSBoYXMgYSBvd25lciwgaXQgbXVzdCBiZSByZW1vdmVkIGZpcnN0LgBDYW5ub3Qgc2V0IG1lYXN1cmUgZnVuY3Rpb246IE5vZGVzIHdpdGggbWVhc3VyZSBmdW5jdGlvbnMgY2Fubm90IGhhdmUgY2hpbGRyZW4uAENhbm5vdCBhZGQgY2hpbGQ6IE5vZGVzIHdpdGggbWVhc3VyZSBmdW5jdGlvbnMgY2Fubm90IGhhdmUgY2hpbGRyZW4uAChudWxsKQAlcwoAAAEAAAADAAAAAAAAAAIAAAADAAAAAQAAAAIAAAAAAAAAAQAAAAE="), n2(e2, 4270, "wH8AAAAAAADAfwMAAABpaQB2AHZp"), n2(e2, 4304, "KxsAACkbAABpGwAAYxsAAGkbAABjGwAAaWlpZmlmaQBcGwAALBsAAHZpaQAtGwAAcBsAAGlpaQ=="), n2(e2, 4368, "wwAAAMQAAADF"), n2(e2, 4388, "wwAAAMYAAADHAAAAXBs="), n2(e2, 4416, "KxsAAGkbAABjGwAAaRsAAGMbAABwGwAAaxsAAHAbAABpaWlpAAAAAFwbAABBGwAAXBsAAEMbAABEGwAAcBs="), n2(e2, 4488, "yAAAAMkAAADK"), n2(e2, 4508, "yAAAAMsAAADHAAAARxsAAFwbAABHGw=="), n2(e2, 4544, "XBsAAEcbAABjGwAAXRsAAHZpaWlpAAAAXBsAAEcbAABpGwAAdmlpZgAAAABcGwAARxsAAF0bAAB2aWlpAAAAAF0bAABIGwAAYxsAAF0bAABHGwAAaQBkaWkAdmlpZAAATBsAAEwbAABHGwAAXBsAAEwbAABcGwAATBsAAEsbAABcGwAATBsAAGMbAAAAAAAAXBsAAEwbAABjGwAAahsAAHZpaWlkAAAAXBsAAEwbAABqGwAAYxsAAE0bAABKGwAATRsAAGMbAABKGwAATRsAAGobAABNGwAAahsAAE0bAABjGwAAZGlpaQAAAABpGwAATBsAAGMbAABmaWlpAAAAAFwbAABMGwAATBsAAGQbAABcGwAATBsAAEwbAABkGwAATRsAAEwbAABMGwAATBsAAEwbAABkGwAAXRsAAEwbAABcGwAATBsAAF0bAABcGwAATBsAACkbAABcGwAATBsAAEEbAABdGwAATRsAAAAAAABcGwAATBsAAGobAABqGwAAYxsAAHZpaWRkaQAASRsAAE0b"), n2(e2, 4960, "GQAKABkZGQAAAAAFAAAAAAAACQAAAAALAAAAAAAAAAAZABEKGRkZAwoHAAEACQsYAAAJBgsAAAsABhkAAAAZGRk="), n2(e2, 5041, "DgAAAAAAAAAAGQAKDRkZGQANAAACAAkOAAAACQAOAAAO"), n2(e2, 5099, "DA=="), n2(e2, 5111, "EwAAAAATAAAAAAkMAAAAAAAMAAAM"), n2(e2, 5157, "EA=="), n2(e2, 5169, "DwAAAAQPAAAAAAkQAAAAAAAQAAAQ"), n2(e2, 5215, "Eg=="), n2(e2, 5227, "EQAAAAARAAAAAAkSAAAAAAASAAASAAAaAAAAGhoa"), n2(e2, 5282, "GgAAABoaGgAAAAAAAAk="), n2(e2, 5331, "FA=="), n2(e2, 5343, "FwAAAAAXAAAAAAkUAAAAAAAUAAAU"), n2(e2, 5389, "Fg=="), n2(e2, 5401, "FQAAAAAVAAAAAAkWAAAAAAAWAAAWAAAwMTIzNDU2Nzg5QUJDREVG"), n2(e2, 5476, "0Q=="), n2(e2, 5516, "//////////8="), n2(e2, 5584, "oB8BAAAAAAAF"), n2(e2, 5604, "zA=="), n2(e2, 5628, "zQAAAM4AAACEGw=="), n2(e2, 5652, "Ag=="), n2(e2, 5668, "//////////8="), n2(e2, 5736, "BQ=="), n2(e2, 5748, "zw=="), n2(e2, 5772, "zQAAANAAAACYGwAAAAQ="), n2(e2, 5796, "AQ=="), n2(e2, 5812, "/////wo="), n2(e2, 5880, "0g==");
        var aa = function(r5) {
          return r5.set = function(r6, e3) {
            this[r6] = e3;
          }, r5.get = function(r6) {
            return this[r6];
          }, r5;
        }([null, function(r5, e3, a5, i4, n3) {
          return i4 |= 0, n3 |= 0, (a5 |= 0) && 5 != (0 | a5) ? 0 | Qe(5736, i4, n3) : 0 | Qe(5592, i4, n3);
        }, function(r5, e3, a5, i4, n3, t5) {
          r5 |= 0, e3 = +e3, a5 |= 0, i4 |= 0, n3 |= 0, t5 |= 0;
          var o4, b3 = 0, s4 = 0, k3 = 0, l4 = 0, d3 = 0, h4 = 0, p3 = 0, m4 = 0, N3 = 0, y3 = 0, G4 = 0, R5 = 0, g5 = 0, Z4 = 0, W3 = 0, V4 = 0, B3 = 0, T4 = 0;
          ar3 = o4 = ar3 - 560 | 0, c4[o4 + 44 >> 2] = 0, A3(+e3), b3 = 0 | u2(1), u2(0), (0 | b3) < 0 ? (R5 = 1, B3 = 1176, A3(+(e3 = -e3)), b3 = 0 | u2(1), u2(0)) : 2048 & n3 ? (R5 = 1, B3 = 1179) : (B3 = (R5 = 1 & n3) ? 1182 : 1177, T4 = !R5);
          r:
            if (2146435072 != (2146435072 & b3)) {
              Z4 = o4 + 16 | 0;
              e: {
                a: {
                  i: {
                    if (e3 = ae2(e3, o4 + 44 | 0), 0 != (e3 += e3)) {
                      if (b3 = c4[o4 + 44 >> 2], c4[o4 + 44 >> 2] = b3 - 1, 97 != (0 | (W3 = 32 | t5)))
                        break i;
                      break e;
                    }
                    if (97 == (0 | (W3 = 32 | t5)))
                      break e;
                    d3 = c4[o4 + 44 >> 2], h4 = (0 | i4) < 0 ? 6 : i4;
                    break a;
                  }
                  d3 = b3 - 29 | 0, c4[o4 + 44 >> 2] = d3, e3 *= 268435456, h4 = (0 | i4) < 0 ? 6 : i4;
                }
                for (s4 = y3 = (o4 + 48 | 0) + ((0 | d3) >= 0 ? 288 : 0) | 0; i4 = e3 < 4294967296 & e3 >= 0 ? ~~e3 >>> 0 : 0, c4[s4 >> 2] = i4, s4 = s4 + 4 | 0, 0 != (e3 = 1e9 * (e3 - +(i4 >>> 0))); )
                  ;
                if ((0 | d3) <= 0)
                  i4 = d3, b3 = s4, k3 = y3;
                else
                  for (k3 = y3, i4 = d3; ; ) {
                    if (m4 = (0 | i4) >= 29 ? 29 : i4, !(k3 >>> 0 > (b3 = s4 - 4 | 0) >>> 0)) {
                      for (i4 = 0; l4 = c4[b3 >> 2], V4 = i4, i4 = 31 & m4, (63 & m4) >>> 0 >= 32 ? (p3 = l4 << i4, i4 = 0) : (p3 = (1 << i4) - 1 & l4 >>> 32 - i4, i4 = l4 << i4), l4 = p3 + N3 | 0, l4 = Ae(i4 = hr2(V4 = V4 + i4 | 0, i4 >>> 0 > V4 >>> 0 ? l4 + 1 | 0 : l4, 1e9), ir2, -1e9, 0) + V4 | 0, c4[b3 >> 2] = l4, k3 >>> 0 <= (b3 = b3 - 4 | 0) >>> 0; )
                        ;
                      i4 && (c4[(k3 = k3 - 4 | 0) >> 2] = i4);
                    }
                    for (; k3 >>> 0 < (b3 = s4) >>> 0 && !c4[(s4 = b3 - 4 | 0) >> 2]; )
                      ;
                    if (i4 = c4[o4 + 44 >> 2] - m4 | 0, c4[o4 + 44 >> 2] = i4, s4 = b3, !((0 | i4) > 0))
                      break;
                  }
                if ((0 | i4) < 0)
                  for (g5 = 1 + ((h4 + 25 >>> 0) / 9 | 0) | 0, N3 = 102 == (0 | W3); ; ) {
                    if (p3 = (0 | (i4 = 0 - i4 | 0)) >= 9 ? 9 : i4, b3 >>> 0 <= k3 >>> 0)
                      s4 = c4[k3 >> 2];
                    else {
                      for (m4 = 1e9 >>> p3 | 0, l4 = -1 << p3 ^ -1, i4 = 0, s4 = k3; V4 = i4, i4 = c4[s4 >> 2], c4[s4 >> 2] = V4 + (i4 >>> p3 | 0), i4 = w2(m4, i4 & l4), (s4 = s4 + 4 | 0) >>> 0 < b3 >>> 0; )
                        ;
                      s4 = c4[k3 >> 2], i4 && (c4[b3 >> 2] = i4, b3 = b3 + 4 | 0);
                    }
                    if (i4 = p3 + c4[o4 + 44 >> 2] | 0, c4[o4 + 44 >> 2] = i4, k3 = (!s4 << 2) + k3 | 0, b3 = b3 - (s4 = N3 ? y3 : k3) >> 2 > (0 | g5) ? s4 + (g5 << 2) | 0 : b3, !((0 | i4) < 0))
                      break;
                  }
                if (i4 = 0, !(b3 >>> 0 <= k3 >>> 0 || (i4 = w2(y3 - k3 >> 2, 9), s4 = 10, (l4 = c4[k3 >> 2]) >>> 0 < 10)))
                  for (; i4 = i4 + 1 | 0, l4 >>> 0 >= (s4 = w2(s4, 10)) >>> 0; )
                    ;
                if ((0 | (s4 = (h4 - (102 != (0 | W3) ? i4 : 0) | 0) - (103 == (0 | W3) & 0 != (0 | h4)) | 0)) < (w2(b3 - y3 >> 2, 9) - 9 | 0)) {
                  if (d3 = ((((0 | d3) < 0 ? 4 : 292) + o4 | 0) + ((l4 = (0 | (m4 = s4 + 9216 | 0)) / 9 | 0) << 2) | 0) - 4048 | 0, s4 = 10, (0 | (p3 = m4 + w2(l4, -9) | 0)) <= 7)
                    for (; s4 = w2(s4, 10), 8 != (0 | (p3 = p3 + 1 | 0)); )
                      ;
                  if (!((0 | (m4 = c4[d3 >> 2])) == (0 | (N3 = w2(g5 = (m4 >>> 0) / (s4 >>> 0) | 0, s4))) & (0 | (l4 = d3 + 4 | 0)) == (0 | b3)) && (m4 = m4 - N3 | 0, !(1 & g5) && (e3 = 9007199254740992, !(1 & f3[d3 - 4 | 0]) | 1e9 != (0 | s4) | k3 >>> 0 >= d3 >>> 0) || (e3 = 9007199254740994), G4 = (0 | b3) == (0 | l4) ? 1 : 1.5, G4 = (l4 = s4 >>> 1 | 0) >>> 0 > m4 >>> 0 ? 0.5 : (0 | l4) == (0 | m4) ? G4 : 1.5, 45 != v3[0 | B3] | T4 || (G4 = -G4, e3 = -e3), c4[d3 >> 2] = N3, e3 + G4 != e3)) {
                    if (i4 = s4 + N3 | 0, c4[d3 >> 2] = i4, i4 >>> 0 >= 1e9)
                      for (; c4[d3 >> 2] = 0, (d3 = d3 - 4 | 0) >>> 0 < k3 >>> 0 && (c4[(k3 = k3 - 4 | 0) >> 2] = 0), i4 = c4[d3 >> 2] + 1 | 0, c4[d3 >> 2] = i4, i4 >>> 0 > 999999999; )
                        ;
                    if (i4 = w2(y3 - k3 >> 2, 9), s4 = 10, !((l4 = c4[k3 >> 2]) >>> 0 < 10))
                      for (; i4 = i4 + 1 | 0, l4 >>> 0 >= (s4 = w2(s4, 10)) >>> 0; )
                        ;
                  }
                  b3 = b3 >>> 0 > (s4 = d3 + 4 | 0) >>> 0 ? s4 : b3;
                }
                for (; l4 = b3, !(m4 = b3 >>> 0 <= k3 >>> 0) && !c4[(b3 = l4 - 4 | 0) >> 2]; )
                  ;
                if (103 == (0 | W3)) {
                  if (h4 = ((b3 = (0 | (s4 = h4 || 1)) > (0 | i4) & (0 | i4) > -5) ? -1 ^ i4 : -1) + s4 | 0, t5 = (b3 ? -1 : -2) + t5 | 0, !(d3 = 8 & n3)) {
                    if (b3 = -9, !m4 && (d3 = c4[l4 - 4 >> 2]) && (p3 = 10, b3 = 0, !((d3 >>> 0) % 10 | 0))) {
                      for (; s4 = b3, b3 = b3 + 1 | 0, !((d3 >>> 0) % ((p3 = w2(p3, 10)) >>> 0) | 0); )
                        ;
                      b3 = -1 ^ s4;
                    }
                    s4 = w2(l4 - y3 >> 2, 9), 70 != (-33 & t5) ? (d3 = 0, h4 = (0 | (b3 = (0 | (b3 = ((i4 + s4 | 0) + b3 | 0) - 9 | 0)) > 0 ? b3 : 0)) > (0 | h4) ? h4 : b3) : (d3 = 0, h4 = (0 | (b3 = (0 | (b3 = (b3 + s4 | 0) - 9 | 0)) > 0 ? b3 : 0)) > (0 | h4) ? h4 : b3);
                  }
                } else
                  d3 = 8 & n3;
                if (p3 = -1, (0 | ((m4 = d3 | h4) ? 2147483645 : 2147483646)) < (0 | h4))
                  break r;
                if (N3 = 1 + ((0 != (0 | m4)) + h4 | 0) | 0, 70 != (0 | (s4 = -33 & t5))) {
                  if ((Z4 - (b3 = re2(((b3 = i4 >> 31) ^ i4) - b3 | 0, 0, Z4)) | 0) <= 1)
                    for (; f3[0 | (b3 = b3 - 1 | 0)] = 48, (Z4 - b3 | 0) < 2; )
                      ;
                  if (f3[0 | (g5 = b3 - 2 | 0)] = t5, f3[b3 - 1 | 0] = (0 | i4) < 0 ? 45 : 43, (0 | (b3 = Z4 - g5 | 0)) > (2147483647 ^ N3))
                    break r;
                } else {
                  if ((2147483647 ^ N3) < (0 | i4))
                    break r;
                  b3 = (0 | i4) > 0 ? i4 : 0;
                }
                if ((0 | (i4 = b3 + N3 | 0)) > (2147483647 ^ R5))
                  break r;
                le(r5, 32, a5, N3 = i4 + R5 | 0, n3), Pr2(r5, B3, R5), le(r5, 48, a5, N3, 65536 ^ n3);
                a: {
                  i: {
                    n: {
                      if (70 == (0 | s4)) {
                        for (i4 = 8 | (t5 = o4 + 16 | 0), d3 = 9 | t5, k3 = s4 = k3 >>> 0 > y3 >>> 0 ? y3 : k3; ; ) {
                          b3 = re2(c4[k3 >> 2], 0, d3);
                          t:
                            if ((0 | s4) == (0 | k3))
                              (0 | b3) == (0 | d3) && (f3[o4 + 24 | 0] = 48, b3 = i4);
                            else {
                              if (o4 + 16 >>> 0 >= b3 >>> 0)
                                break t;
                              for (; f3[0 | (b3 = b3 - 1 | 0)] = 48, o4 + 16 >>> 0 < b3 >>> 0; )
                                ;
                            }
                          if (Pr2(r5, b3, d3 - b3 | 0), !(y3 >>> 0 >= (k3 = k3 + 4 | 0) >>> 0))
                            break;
                        }
                        if (m4 && Pr2(r5, 4206, 1), (0 | h4) <= 0 | k3 >>> 0 >= l4 >>> 0)
                          break n;
                        for (; ; ) {
                          if ((b3 = re2(c4[k3 >> 2], 0, d3)) >>> 0 > o4 + 16 >>> 0)
                            for (; f3[0 | (b3 = b3 - 1 | 0)] = 48, o4 + 16 >>> 0 < b3 >>> 0; )
                              ;
                          if (Pr2(r5, b3, (0 | h4) >= 9 ? 9 : h4), b3 = h4 - 9 | 0, l4 >>> 0 <= (k3 = k3 + 4 | 0) >>> 0)
                            break i;
                          if (i4 = (0 | h4) > 9, h4 = b3, !i4)
                            break;
                        }
                        break i;
                      }
                      t:
                        if (!((0 | h4) < 0))
                          for (y3 = k3 >>> 0 < l4 >>> 0 ? l4 : k3 + 4 | 0, i4 = 8 | (t5 = o4 + 16 | 0), l4 = 9 | t5, s4 = k3; ; ) {
                            (0 | l4) == (0 | (b3 = re2(c4[s4 >> 2], 0, l4))) && (f3[o4 + 24 | 0] = 48, b3 = i4);
                            f:
                              if ((0 | s4) == (0 | k3))
                                Pr2(r5, b3, 1), b3 = b3 + 1 | 0, d3 | h4 && Pr2(r5, 4206, 1);
                              else {
                                if (o4 + 16 >>> 0 >= b3 >>> 0)
                                  break f;
                                for (; f3[0 | (b3 = b3 - 1 | 0)] = 48, o4 + 16 >>> 0 < b3 >>> 0; )
                                  ;
                              }
                            if (Pr2(r5, b3, (0 | (t5 = l4 - b3 | 0)) > (0 | h4) ? h4 : t5), h4 = h4 - t5 | 0, y3 >>> 0 <= (s4 = s4 + 4 | 0) >>> 0)
                              break t;
                            if (!((0 | h4) >= 0))
                              break;
                          }
                      le(r5, 48, h4 + 18 | 0, 18, 0), Pr2(r5, g5, Z4 - g5 | 0);
                      break a;
                    }
                    b3 = h4;
                  }
                  le(r5, 48, b3 + 9 | 0, 9, 0);
                }
                le(r5, 32, a5, N3, 8192 ^ n3), p3 = (0 | a5) < (0 | N3) ? N3 : a5;
                break r;
              }
              if (d3 = (t5 << 26 >> 31 & 9) + B3 | 0, !(i4 >>> 0 > 11)) {
                for (b3 = 12 - i4 | 0, G4 = 16; G4 *= 16, b3 = b3 - 1 | 0; )
                  ;
                e3 = 45 != v3[0 | d3] ? e3 + G4 - G4 : -(G4 + (-e3 - G4));
              }
              for (y3 = 2 | R5, k3 = 32 & t5, (0 | Z4) == (0 | (b3 = re2(((b3 = (s4 = c4[o4 + 44 >> 2]) >> 31) ^ s4) - b3 | 0, 0, Z4))) && (f3[o4 + 15 | 0] = 48, b3 = o4 + 15 | 0), f3[0 | (h4 = b3 - 2 | 0)] = t5 + 15, f3[b3 - 1 | 0] = (0 | s4) < 0 ? 45 : 43, b3 = 8 & n3, s4 = o4 + 16 | 0; t5 = s4, l4 = E3(e3) < 2147483648 ? ~~e3 : -2147483648, f3[0 | s4] = k3 | v3[l4 + 5424 | 0], !(b3 | (0 | i4) > 0) & 0 == (e3 = 16 * (e3 - +(0 | l4))) | 1 != ((s4 = t5 + 1 | 0) - (o4 + 16 | 0) | 0) || (f3[t5 + 1 | 0] = 46, s4 = t5 + 2 | 0), 0 != e3; )
                ;
              p3 = -1, (2147483645 - (t5 = (b3 = Z4 - h4 | 0) + y3 | 0) | 0) < (0 | i4) || (le(r5, 32, a5, t5 = (i4 = !i4 || ((k3 = s4 - (o4 + 16 | 0) | 0) - 2 | 0) >= (0 | i4) ? k3 = s4 - (o4 + 16 | 0) | 0 : i4 + 2 | 0) + t5 | 0, n3), Pr2(r5, d3, y3), le(r5, 48, a5, t5, 65536 ^ n3), Pr2(r5, o4 + 16 | 0, k3), le(r5, 48, i4 - k3 | 0, 0, 0), Pr2(r5, h4, b3), le(r5, 32, a5, t5, 8192 ^ n3), p3 = (0 | a5) < (0 | t5) ? t5 : a5);
            } else
              le(r5, 32, a5, b3 = R5 + 3 | 0, -65537 & n3), Pr2(r5, B3, R5), i4 = 32 & t5, Pr2(r5, e3 != e3 ? i4 ? 2450 : 3390 : i4 ? 2819 : 3394, 3), le(r5, 32, a5, b3, 8192 ^ n3), p3 = (0 | a5) < (0 | b3) ? b3 : a5;
          return ar3 = o4 + 560 | 0, 0 | p3;
        }, function(r5, e3) {
          r5 |= 0;
          var a5, i4, n3, t5, f4, o4 = 0, u3 = 0, A4 = 0, k3 = 0, l4 = 0, d3 = 0, v4 = 0, h4 = 0, p3 = 0, m4 = 0, w3 = 0;
          o4 = e3 |= 0, e3 = c4[e3 >> 2] + 7 & -8, c4[o4 >> 2] = e3 + 16, n3 = r5, d3 = c4[e3 >> 2], u3 = c4[e3 + 4 >> 2], i4 = r5 = c4[e3 + 12 >> 2], ar3 = a5 = ar3 - 32 | 0, l4 = r5 &= 2147483647;
          r:
            if ((0 | (A4 = r5 - 1006698496 | 0)) == (0 | (r5 = r5 - 1140785152 | 0)) & (e3 = o4 = c4[e3 + 8 >> 2]) >>> 0 < e3 >>> 0 | r5 >>> 0 > A4 >>> 0) {
              if (e3 = (r5 = o4) << 4 | u3 >>> 28, r5 = o4 = i4 << 4 | r5 >>> 28, 134217728 == (0 | (u3 &= 268435455)) & 0 != (0 | d3) | u3 >>> 0 > 134217728) {
                r5 = r5 + 1073741824 | 0, r5 = (e3 = e3 + 1 | 0) ? r5 : r5 + 1 | 0;
                break r;
              }
              if (r5 = r5 + 1073741824 | 0, d3 | 134217728 != (0 | u3))
                break r;
              r5 = (e3 = (u3 = 1 & e3) + e3 | 0) >>> 0 < u3 >>> 0 ? r5 + 1 | 0 : r5;
            } else
              (!e3 & 2147418112 == (0 | l4) ? !(u3 | d3) : l4 >>> 0 < 2147418112) ? (e3 = 0, r5 = 2146435072, l4 >>> 0 > 1140785151 || (r5 = 0, (m4 = l4 >>> 16 | 0) >>> 0 < 15249 || (e3 = d3, r5 = u3, l4 = A4 = 65535 & i4 | 65536, p3 = o4, k3 = o4, 64 & (v4 = m4 - 15233 | 0) ? (o4 = e3, e3 = 31 & (A4 = v4 + -64 | 0), (63 & A4) >>> 0 >= 32 ? (r5 = o4 << e3, k3 = 0) : (r5 = (1 << e3) - 1 & o4 >>> 32 - e3 | r5 << e3, k3 = o4 << e3), A4 = r5, e3 = 0, r5 = 0) : v4 && (h4 = k3, k3 = 31 & v4, (63 & v4) >>> 0 >= 32 ? (o4 = h4 << k3, k3 = 0) : (o4 = (1 << k3) - 1 & h4 >>> 32 - k3 | A4 << k3, k3 = h4 << k3), A4 = o4, w3 = k3, h4 = e3, k3 = 31 & (o4 = 64 - v4 | 0), (63 & o4) >>> 0 >= 32 ? (o4 = 0, e3 = r5 >>> k3 | 0) : (o4 = r5 >>> k3 | 0, e3 = ((1 << k3) - 1 & r5) << 32 - k3 | h4 >>> k3), k3 = w3 | e3, A4 |= o4, e3 = 31 & v4, (63 & v4) >>> 0 >= 32 ? (o4 = h4 << e3, e3 = 0) : (o4 = (1 << e3) - 1 & h4 >>> 32 - e3 | r5 << e3, e3 = h4 << e3), r5 = o4), c4[a5 + 16 >> 2] = e3, c4[a5 + 20 >> 2] = r5, c4[a5 + 24 >> 2] = k3, c4[a5 + 28 >> 2] = A4, 64 & (e3 = 15361 - m4 | 0) ? (u3 = p3, r5 = 31 & (e3 = e3 + -64 | 0), (63 & e3) >>> 0 >= 32 ? (o4 = 0, d3 = l4 >>> r5 | 0) : (o4 = l4 >>> r5 | 0, d3 = ((1 << r5) - 1 & l4) << 32 - r5 | u3 >>> r5), u3 = o4, p3 = 0, l4 = 0) : e3 && (A4 = p3, o4 = 31 & (r5 = 64 - e3 | 0), (63 & r5) >>> 0 >= 32 ? (r5 = A4 << o4, k3 = 0) : (r5 = (1 << o4) - 1 & A4 >>> 32 - o4 | l4 << o4, k3 = A4 << o4), A4 = d3, d3 = 31 & e3, (63 & e3) >>> 0 >= 32 ? (o4 = 0, A4 = u3 >>> d3 | 0) : (o4 = u3 >>> d3 | 0, A4 = ((1 << d3) - 1 & u3) << 32 - d3 | A4 >>> d3), d3 = k3 | A4, u3 = r5 | o4, A4 = p3, o4 = 31 & e3, (63 & e3) >>> 0 >= 32 ? (r5 = 0, p3 = l4 >>> o4 | 0) : (r5 = l4 >>> o4 | 0, p3 = ((1 << o4) - 1 & l4) << 32 - o4 | A4 >>> o4), l4 = r5), c4[a5 >> 2] = d3, c4[a5 + 4 >> 2] = u3, c4[a5 + 8 >> 2] = p3, c4[a5 + 12 >> 2] = l4, e3 = c4[a5 + 8 >> 2], r5 = c4[a5 + 12 >> 2] << 4 | e3 >>> 28, e3 <<= 4, o4 = c4[a5 >> 2], e3 |= (l4 = c4[a5 + 4 >> 2]) >>> 28, 134217728 == (0 | (u3 = 268435455 & l4)) & 0 != (0 | (o4 |= 0 != (c4[a5 + 16 >> 2] | c4[a5 + 24 >> 2] | c4[a5 + 20 >> 2] | c4[a5 + 28 >> 2]))) | u3 >>> 0 > 134217728 ? r5 = (e3 = e3 + 1 | 0) ? r5 : r5 + 1 | 0 : o4 | 134217728 != (0 | u3) || (r5 = (o4 = e3) >>> 0 > (e3 = e3 + (1 & e3) | 0) >>> 0 ? r5 + 1 | 0 : r5)))) : (e3 = (r5 = o4) << 4 | u3 >>> 28, r5 = 524287 & (o4 = i4 << 4 | r5 >>> 28) | 2146959360);
          ar3 = a5 + 32 | 0, b2(0, 0 | e3), b2(1, -2147483648 & i4 | r5), t5 = n3, f4 = +s3(), N2[t5 >> 3] = f4;
        }, Ke, function(r5, e3) {
          e3 |= 0, c4[4 + (r5 |= 0) >> 2] = 7, c4[r5 >> 2] = e3;
        }, function(r5, e3) {
          e3 |= 0, c4[4 + (r5 |= 0) >> 2] = 10, c4[r5 >> 2] = e3;
        }, function(r5, e3) {
          e3 |= 0, c4[4 + (r5 |= 0) >> 2] = 13, c4[r5 >> 2] = e3;
        }, Ke, Ke, Ke, Ke, Ke, Ke, function(r5, e3, a5, i4, n3, t5) {
          var f4;
          r5 |= 0, e3 |= 0, a5 = y2(a5), i4 |= 0, n3 = y2(n3), t5 |= 0, ar3 = f4 = ar3 - 16 | 0, e3 = c4[c4[e3 >> 2] + 4 >> 2], aa[c4[c4[e3 >> 2] + 8 >> 2]](f4, e3, a5, i4, n3, t5), m3[r5 >> 2] = N2[f4 >> 3], m3[r5 + 4 >> 2] = N2[f4 + 8 >> 3], ar3 = f4 + 16 | 0;
        }, function(r5) {
          r5 = c4[c4[(r5 |= 0) >> 2] + 8 >> 2], aa[c4[c4[r5 >> 2] + 8 >> 2]](r5);
        }, tr2, function(r5) {
          return 6952;
        }, Pe, function(r5, e3, a5, i4, n3, t5) {
          r5 |= 0, e3 |= 0, a5 = y2(a5), i4 |= 0, n3 = y2(n3), t5 |= 0;
          var f4, o4 = 0;
          return ar3 = f4 = ar3 - 16 | 0, o4 = c4[r5 >> 2], e3 = ((r5 = c4[r5 + 4 >> 2]) >> 1) + e3 | 0, 1 & r5 && (o4 = c4[o4 + c4[e3 >> 2] >> 2]), aa[0 | o4](f4, e3, a5, i4, n3, t5), r5 = ye(16), e3 = c4[f4 + 12 >> 2], c4[r5 + 8 >> 2] = c4[f4 + 8 >> 2], c4[r5 + 12 >> 2] = e3, e3 = c4[f4 + 4 >> 2], c4[r5 >> 2] = c4[f4 >> 2], c4[r5 + 4 >> 2] = e3, ar3 = f4 + 16 | 0, 0 | r5;
        }, function(r5) {
          return 6956;
        }, Ke, Ke, Pe, qe, He, Ze, function(r5) {
          var e3;
          return r5 |= 0, e3 = ye(12), f3[e3 + 4 | 0] = 0, c4[e3 + 8 >> 2] = c4[r5 >> 2], c4[r5 >> 2] = 0, c4[e3 >> 2] = 4368, 0 | e3;
        }, function(r5, e3, a5) {
          r5 |= 0, a5 |= 0;
          var i4, n3, t5 = 0, o4 = 0;
          if (ar3 = i4 = ar3 - 32 | 0, (n3 = c4[(e3 |= 0) >> 2]) >>> 0 < 2147483632) {
            r: {
              if (n3 >>> 0 >= 11)
                o4 = ye(t5 = 1 + (15 | n3) | 0), c4[i4 + 16 >> 2] = -2147483648 | t5, c4[i4 + 8 >> 2] = o4, c4[i4 + 12 >> 2] = n3, t5 = n3 + o4 | 0;
              else if (f3[i4 + 19 | 0] = n3, t5 = (o4 = i4 + 8 | 0) + n3 | 0, !n3)
                break r;
              Ar2(o4, e3 + 4 | 0, n3);
            }
            return f3[0 | t5] = 0, c4[i4 >> 2] = a5, aa[0 | r5](i4 + 24 | 0, i4 + 8 | 0, i4), M3(c4[i4 + 24 >> 2]), r5 = c4[i4 + 24 >> 2], X2(0 | r5), X2(c4[i4 >> 2]), f3[i4 + 19 | 0] < 0 && gr2(c4[i4 + 8 >> 2]), ar3 = i4 + 32 | 0, 0 | r5;
          }
          I2(), k2();
        }, function(r5, e3, a5) {
          var i4, n3;
          a5 |= 0, i4 = r5 |= 0, n3 = 0 | U2(0 | (f3[11 + (e3 |= 0) | 0] < 0 ? c4[e3 >> 2] : e3), 6956, c4[a5 >> 2]), c4[i4 >> 2] = n3;
        }, function(r5) {
          return 6976;
        }, Pe, Xe, function(r5) {
          return 6979;
        }, Ke, Ke, Pe, qe, He, Ze, function(r5) {
          var e3;
          return r5 |= 0, e3 = ye(12), f3[e3 + 4 | 0] = 0, c4[e3 + 8 >> 2] = c4[r5 >> 2], c4[r5 >> 2] = 0, c4[e3 >> 2] = 4488, 0 | e3;
        }, function(r5, e3, a5) {
          var i4, n3;
          a5 |= 0, i4 = r5 |= 0, n3 = 0 | U2(0 | (f3[11 + (e3 |= 0) | 0] < 0 ? c4[e3 >> 2] : e3), 6979, c4[a5 >> 2]), c4[i4 >> 2] = n3;
        }, function(r5) {
          return 6982;
        }, Fe, ze, function() {
          var r5, e3;
          return e3 = ye(4), r5 = ye(28), o3[r5 + 20 >> 1] = 0, c4[r5 + 16 >> 2] = 1065353216, o3[r5 + 10 >> 1] = 0, o3[r5 + 12 >> 1] = 0, c4[r5 >> 2] = 0, c4[r5 + 24 >> 2] = 0, f3[r5 + 9 | 0] = 0, c4[r5 + 4 >> 2] = 1, f3[r5 + 22 | 0] = 0, c4[1732] = c4[1732] + 1, c4[e3 >> 2] = r5, 0 | e3;
        }, je, Fe, function(r5, e3, a5) {
          e3 |= 0, a5 |= 0, f3[20 + (c4[(r5 |= 0) >> 2] + e3 | 0) | 0] = a5;
        }, Ne, function(r5, e3) {
          r5 |= 0, e3 = y2(e3);
          var a5, i4 = 0, n3 = 0;
          ar3 = a5 = ar3 - 16 | 0, r5 = c4[r5 >> 2], e3 >= y2(0) || (c4[a5 >> 2] = 2262, ar3 = i4 = ar3 - 16 | 0, c4[i4 + 12 >> 2] = a5, r5 || (v3[6936] ? r5 = c4[1733] : (r5 = ye(28), o3[r5 + 20 >> 1] = 0, c4[r5 + 16 >> 2] = 1065353216, o3[r5 + 10 >> 1] = 0, o3[r5 + 12 >> 1] = 0, c4[r5 >> 2] = 0, c4[r5 + 24 >> 2] = 0, f3[r5 + 9 | 0] = 0, c4[r5 + 4 >> 2] = 1, f3[r5 + 22 | 0] = 0, c4[1733] = r5, f3[6936] = 1, c4[1732] = c4[1732] + 1)), n3 = c4[r5 + 4 >> 2], v3[r5 + 9 | 0] ? aa[0 | n3](r5, 0, 5, 0, 4215, a5) : aa[0 | n3](r5, 0, 5, 4215, a5), ar3 = i4 + 16 | 0, De(), k2()), m3[r5 + 16 >> 2] = e3 == y2(0) ? y2(0) : e3, ar3 = a5 + 16 | 0;
        }, function(r5, e3, a5) {
          r5 |= 0, e3 |= 0, a5 = y2(a5);
          var i4 = 0;
          i4 = c4[r5 >> 2], e3 = ((r5 = c4[r5 + 4 >> 2]) >> 1) + e3 | 0, 1 & r5 && (i4 = c4[i4 + c4[e3 >> 2] >> 2]), aa[0 | i4](e3, a5);
        }, function(r5, e3) {
          e3 |= 0, f3[c4[(r5 |= 0) >> 2] + 11 | 0] = e3;
        }, Ee, function(r5, e3) {
          e3 |= 0, f3[c4[(r5 |= 0) >> 2] + 10 | 0] = e3;
        }, function(r5, e3) {
          return e3 |= 0, v3[20 + (c4[(r5 |= 0) >> 2] + e3 | 0) | 0];
        }, we, function(r5) {
          return v3[c4[(r5 |= 0) >> 2] + 11 | 0];
        }, Ge, function(r5) {
          return v3[c4[(r5 |= 0) >> 2] + 10 | 0];
        }, function() {
          return 0 | Rr2(ye(48), 0, 48);
        }, Je, function() {
          var r5;
          return r5 = ye(16), c4[r5 >> 2] = 0, c4[r5 + 4 >> 2] = 0, c4[r5 + 8 >> 2] = 0, c4[r5 + 12 >> 2] = 0, 0 | r5;
        }, Je, function() {
          var r5;
          return r5 = ye(16), c4[r5 + 8 >> 2] = 0, c4[r5 + 12 >> 2] = 0, c4[r5 >> 2] = 0, 0 | r5;
        }, Je, Se, Ce, function(r5, e3) {
          return e3 |= 0, c4[c4[(r5 |= 0) >> 2] + e3 >> 2];
        }, function(r5, e3, a5) {
          e3 |= 0, a5 |= 0, c4[c4[(r5 |= 0) >> 2] + e3 >> 2] = a5;
        }, function(r5) {
          return 6987;
        }, Cr2, ze, function() {
          return 0 | $r2(ye(12), 0);
        }, function(r5, e3) {
          return e3 |= 0, 0 | aa[0 | (r5 |= 0)](e3);
        }, function(r5) {
          return r5 |= 0, 0 | $r2(ye(12), r5);
        }, je, Cr2, function(r5) {
          var e3, a5 = 0, i4 = 0, n3 = 0;
          ar3 = e3 = ar3 - 624 | 0, a5 = c4[4 + (r5 |= 0) >> 2], c4[r5 + 4 >> 2] = 0, a5 && aa[c4[c4[a5 >> 2] + 4 >> 2]](a5), a5 = c4[r5 + 8 >> 2], c4[r5 + 8 >> 2] = 0, a5 && aa[c4[c4[a5 >> 2] + 4 >> 2]](a5);
          r: {
            if (r5 = c4[r5 >> 2], c4[r5 + 560 >> 2] == c4[r5 + 556 >> 2]) {
              if (c4[r5 + 552 >> 2])
                break r;
              return Sr2(r5 + 556 | 0), n3 = f3[r5 + 4 | 0], a5 = br2(e3 + 32 | 0, c4[r5 + 568 >> 2]), i4 = c4[a5 + 4 >> 2], c4[r5 >> 2] = c4[a5 >> 2], c4[r5 + 4 >> 2] = i4, i4 = c4[a5 + 20 >> 2], c4[r5 + 16 >> 2] = c4[a5 + 16 >> 2], c4[r5 + 20 >> 2] = i4, i4 = c4[a5 + 12 >> 2], c4[r5 + 8 >> 2] = c4[a5 + 8 >> 2], c4[r5 + 12 >> 2] = i4, Ar2(r5 + 24 | 0, a5 + 24 | 0, 204), Ar2(r5 + 228 | 0, a5 + 228 | 0, 328), (i4 = c4[r5 + 556 >> 2]) && (c4[r5 + 560 >> 2] = i4, gr2(i4)), c4[r5 + 556 >> 2] = c4[a5 + 556 >> 2], c4[r5 + 560 >> 2] = c4[a5 + 560 >> 2], c4[r5 + 564 >> 2] = c4[a5 + 564 >> 2], c4[r5 + 584 >> 2] = c4[a5 + 584 >> 2], i4 = c4[a5 + 580 >> 2], c4[r5 + 576 >> 2] = c4[a5 + 576 >> 2], c4[r5 + 580 >> 2] = i4, i4 = c4[a5 + 572 >> 2], c4[r5 + 568 >> 2] = c4[a5 + 568 >> 2], c4[r5 + 572 >> 2] = i4, (0 | n3) < 0 && (f3[r5 + 4 | 0] = 128 | v3[r5 + 4 | 0], c4[r5 + 24 >> 2] = -909 & c4[r5 + 24 >> 2] | 520), void (ar3 = e3 + 624 | 0);
            }
            c4[e3 + 16 >> 2] = 3252, Xr2(r5, e3 + 16 | 0), De(), k2();
          }
          c4[e3 >> 2] = 2046, Xr2(r5, e3), De(), k2();
        }, Xe, function(r5, e3) {
          r5 |= 0, e3 |= 0;
          var a5 = 0, i4 = y2(0), n3 = 0, t5 = 0, o4 = y2(0), u3 = 0, s4 = 0, A4 = 0, k3 = y2(0);
          r: {
            s4 = c4[e3 >> 2], e3 = c4[r5 >> 2];
            e:
              if (!(8388607 & (c4[s4 + 24 >> 2] ^ c4[e3 + 24 >> 2]))) {
                k3 = m3[s4 + 40 >> 2], n3 = c4[s4 + 40 >> 2], i4 = m3[e3 + 40 >> 2];
                a: {
                  i: {
                    if (2139156720 != (0 | (a5 = c4[e3 + 40 >> 2]))) {
                      if (o4 = y2(NaN), r5 = 3, 2141891242 == (0 | a5))
                        break a;
                      if (2140081935 != (0 | a5))
                        break i;
                      o4 = y2(0), r5 = 1;
                      break a;
                    }
                    r5 = 2;
                    break a;
                  }
                  r5 = 0, i4 == i4 && (b2(2, 536870912 + (-1073741825 & a5) | 0), o4 = d2(), r5 = 1073741824 & a5 ? 2 : 1);
                }
                a: {
                  i: {
                    if (2139156720 != (0 | n3)) {
                      if (i4 = y2(NaN), a5 = 3, 2141891242 == (0 | n3))
                        break a;
                      if (2140081935 != (0 | n3))
                        break i;
                      i4 = y2(0), a5 = 1;
                      break a;
                    }
                    i4 = y2(0), a5 = 2;
                    break a;
                  }
                  a5 = 0, k3 == k3 && (b2(2, 536870912 + (-1073741825 & n3) | 0), i4 = d2(), a5 = 1073741824 & n3 ? 2 : 1);
                }
                if (!((0 | a5) != (0 | r5) | !(!r5 | o4 != o4 & i4 != i4 | y2(E3(y2(o4 - i4))) < y2(9999999747378752e-20))) && (t5 = s4 + 44 | 0, c4[(a5 = e3 + 44 | 0) >> 2] == c4[t5 >> 2])) {
                  r5 = 0;
                  a: {
                    for (; ; ) {
                      if (n3 = r5, 9 == (0 | (r5 = r5 + 1 | 0)))
                        break a;
                      if (c4[(u3 = r5 << 2) + a5 >> 2] != c4[t5 + u3 >> 2])
                        break;
                    }
                    if (n3 >>> 0 < 8)
                      break e;
                  }
                  if (t5 = s4 + 80 | 0, c4[(a5 = e3 + 80 | 0) >> 2] == c4[t5 >> 2]) {
                    r5 = 0;
                    a: {
                      for (; ; ) {
                        if (n3 = r5, 9 == (0 | (r5 = r5 + 1 | 0)))
                          break a;
                        if (c4[(u3 = r5 << 2) + a5 >> 2] != c4[t5 + u3 >> 2])
                          break;
                      }
                      if (n3 >>> 0 < 8)
                        break e;
                    }
                    if (t5 = s4 + 116 | 0, c4[(a5 = e3 + 116 | 0) >> 2] == c4[t5 >> 2]) {
                      r5 = 0;
                      a: {
                        for (; ; ) {
                          if (n3 = r5, 9 == (0 | (r5 = r5 + 1 | 0)))
                            break a;
                          if (c4[(u3 = r5 << 2) + a5 >> 2] != c4[t5 + u3 >> 2])
                            break;
                        }
                        if (n3 >>> 0 < 8)
                          break e;
                      }
                      if (t5 = s4 + 152 | 0, c4[(a5 = e3 + 152 | 0) >> 2] == c4[t5 >> 2]) {
                        r5 = 0;
                        a: {
                          for (; ; ) {
                            if (n3 = r5, 9 == (0 | (r5 = r5 + 1 | 0)))
                              break a;
                            if (c4[(u3 = r5 << 2) + a5 >> 2] != c4[t5 + u3 >> 2])
                              break;
                          }
                          if (n3 >>> 0 < 8)
                            break e;
                        }
                        if (t5 = s4 + 188 | 0, c4[(a5 = e3 + 188 | 0) >> 2] == c4[t5 >> 2]) {
                          r5 = 0;
                          a: {
                            for (; ; ) {
                              if (n3 = r5, 3 == (0 | (r5 = r5 + 1 | 0)))
                                break a;
                              if (c4[(u3 = r5 << 2) + a5 >> 2] != c4[t5 + u3 >> 2])
                                break;
                            }
                            if (n3 >>> 0 < 2)
                              break e;
                          }
                          for (u3 = s4 + 200 | 0, A4 = e3 + 200 | 0, r5 = 0, n3 = 1; a5 = c4[(r5 <<= 2) + u3 >> 2], t5 = c4[r5 + A4 >> 2], n3 && (n3 = 0, r5 = 1, (0 | a5) == (0 | t5)); )
                            ;
                          if ((0 | a5) == (0 | t5)) {
                            for (u3 = s4 + 208 | 0, A4 = e3 + 208 | 0, r5 = 0, n3 = 1; a5 = c4[(r5 <<= 2) + u3 >> 2], t5 = c4[r5 + A4 >> 2], n3 && (n3 = 0, r5 = 1, (0 | a5) == (0 | t5)); )
                              ;
                            if ((0 | a5) == (0 | t5)) {
                              for (u3 = s4 + 216 | 0, A4 = e3 + 216 | 0, r5 = 0, n3 = 1; a5 = c4[(r5 <<= 2) + u3 >> 2], t5 = c4[r5 + A4 >> 2], n3 && (n3 = 0, r5 = 1, (0 | a5) == (0 | t5)); )
                                ;
                              if ((0 | a5) == (0 | t5) && !((0 | (r5 = (o4 = m3[s4 + 28 >> 2]) != o4)) == ((i4 = m3[e3 + 28 >> 2]) == i4 | 0) | !(r5 | i4 != i4) & i4 != o4 || ((i4 = m3[e3 + 32 >> 2]) == i4 | 0) == ((o4 = m3[s4 + 32 >> 2]) != o4 | 0) | i4 == i4 & i4 != o4 || (0 | (r5 = (o4 = m3[s4 + 36 >> 2]) != o4)) == ((i4 = m3[e3 + 36 >> 2]) == i4 | 0) | !r5 & i4 != o4)) {
                                if (r5 = 0, (i4 = m3[e3 + 224 >> 2]) != i4 && (r5 = 1, (o4 = m3[s4 + 224 >> 2]) != o4))
                                  break r;
                                if ((o4 = i4) == (i4 = m3[s4 + 224 >> 2]) | i4 != i4 & r5)
                                  break r;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            for (Ar2(e3 + 24 | 0, s4 + 24 | 0, 204); ; ) {
              if (4 & (r5 = v3[e3 + 4 | 0]))
                break r;
              if (f3[e3 + 4 | 0] = 4 | r5, (r5 = c4[e3 + 20 >> 2]) && aa[0 | r5](e3), c4[e3 + 308 >> 2] = 2143289344, !(e3 = c4[e3 + 552 >> 2]))
                break;
            }
          }
        }, Ee, function(r5, e3) {
          e3 |= 0;
          var a5 = 0;
          r:
            if (r5 = c4[(r5 |= 0) >> 2], ((a5 = c4[r5 + 24 >> 2]) >>> 16 & 3) != (0 | e3))
              for (c4[r5 + 24 >> 2] = -196609 & a5 | e3 << 16 & 196608; ; ) {
                if (4 & (e3 = v3[r5 + 4 | 0]))
                  break r;
                if (f3[r5 + 4 | 0] = 4 | e3, (e3 = c4[r5 + 20 >> 2]) && aa[0 | e3](r5), c4[r5 + 308 >> 2] = 2143289344, !(r5 = c4[r5 + 552 >> 2]))
                  break;
              }
        }, Ee, function(r5, e3, a5) {
          e3 |= 0, a5 = +a5, oe(c4[(r5 |= 0) >> 2], e3, qr2(y2(a5)));
        }, function(r5, e3, a5, i4) {
          e3 |= 0, a5 |= 0, i4 = +i4;
          var n3 = 0;
          n3 = c4[(r5 |= 0) >> 2], e3 = ((r5 = c4[r5 + 4 >> 2]) >> 1) + e3 | 0, 1 & r5 && (n3 = c4[n3 + c4[e3 >> 2] >> 2]), aa[0 | n3](e3, a5, i4);
        }, function(r5, e3, a5) {
          e3 |= 0, a5 = +a5, oe(c4[(r5 |= 0) >> 2], e3, Kr2(y2(a5)));
        }, function(r5, e3) {
          e3 |= 0, Yr2(c4[(r5 |= 0) >> 2], 5, e3);
        }, function(r5, e3) {
          e3 |= 0, Yr2(c4[(r5 |= 0) >> 2], 6, e3);
        }, function(r5, e3) {
          e3 |= 0, Yr2(c4[(r5 |= 0) >> 2], 7, e3);
        }, function(r5, e3) {
          e3 |= 0;
          var a5 = 0;
          r:
            if (r5 = c4[(r5 |= 0) >> 2], ((a5 = c4[r5 + 24 >> 2]) >>> 2 & 3) != (0 | e3))
              for (c4[r5 + 24 >> 2] = -13 & a5 | e3 << 2 & 12; ; ) {
                if (4 & (e3 = v3[r5 + 4 | 0]))
                  break r;
                if (f3[r5 + 4 | 0] = 4 | e3, (e3 = c4[r5 + 20 >> 2]) && aa[0 | e3](r5), c4[r5 + 308 >> 2] = 2143289344, !(r5 = c4[r5 + 552 >> 2]))
                  break;
              }
        }, function(r5, e3) {
          e3 |= 0;
          var a5 = 0;
          r:
            if (r5 = c4[(r5 |= 0) >> 2], ((a5 = c4[r5 + 24 >> 2]) >>> 18 & 3) != (0 | e3))
              for (c4[r5 + 24 >> 2] = -786433 & a5 | e3 << 18 & 786432; ; ) {
                if (4 & (e3 = v3[r5 + 4 | 0]))
                  break r;
                if (f3[r5 + 4 | 0] = 4 | e3, (e3 = c4[r5 + 20 >> 2]) && aa[0 | e3](r5), c4[r5 + 308 >> 2] = 2143289344, !(r5 = c4[r5 + 552 >> 2]))
                  break;
              }
        }, function(r5, e3) {
          e3 |= 0;
          var a5 = 0;
          r:
            if (r5 = c4[(r5 |= 0) >> 2], ((a5 = c4[r5 + 24 >> 2]) >>> 4 & 7) != (0 | e3))
              for (c4[r5 + 24 >> 2] = -113 & a5 | e3 << 4 & 112; ; ) {
                if (4 & (e3 = v3[r5 + 4 | 0]))
                  break r;
                if (f3[r5 + 4 | 0] = 4 | e3, (e3 = c4[r5 + 20 >> 2]) && aa[0 | e3](r5), c4[r5 + 308 >> 2] = 2143289344, !(r5 = c4[r5 + 552 >> 2]))
                  break;
              }
        }, function(r5, e3, a5) {
          e3 |= 0, a5 = +a5, ue(c4[(r5 |= 0) >> 2], e3, qr2(y2(a5)));
        }, function(r5, e3, a5) {
          e3 |= 0, a5 = +a5, ue(c4[(r5 |= 0) >> 2], e3, Kr2(y2(a5)));
        }, function(r5, e3) {
          e3 |= 0, ue(c4[(r5 |= 0) >> 2], e3, 2141891242);
        }, function(r5, e3) {
          e3 |= 0;
          var a5 = 0;
          r:
            if (r5 = c4[(r5 |= 0) >> 2], ((a5 = c4[r5 + 24 >> 2]) >>> 20 & 3) != (0 | e3))
              for (c4[r5 + 24 >> 2] = -3145729 & a5 | e3 << 20 & 3145728; ; ) {
                if (4 & (e3 = v3[r5 + 4 | 0]))
                  break r;
                if (f3[r5 + 4 | 0] = 4 | e3, (e3 = c4[r5 + 20 >> 2]) && aa[0 | e3](r5), c4[r5 + 308 >> 2] = 2143289344, !(r5 = c4[r5 + 552 >> 2]))
                  break;
              }
        }, function(r5, e3) {
          e3 |= 0;
          var a5 = 0;
          r:
            if (r5 = c4[(r5 |= 0) >> 2], ((a5 = c4[r5 + 24 >> 2]) >>> 22 & 1) != (0 | e3))
              for (c4[r5 + 24 >> 2] = -4194305 & a5 | e3 << 22 & 4194304; ; ) {
                if (4 & (e3 = v3[r5 + 4 | 0]))
                  break r;
                if (f3[r5 + 4 | 0] = 4 | e3, (e3 = c4[r5 + 20 >> 2]) && aa[0 | e3](r5), c4[r5 + 308 >> 2] = 2143289344, !(r5 = c4[r5 + 552 >> 2]))
                  break;
              }
        }, function(r5, e3) {
          r5 |= 0, e3 = +e3;
          var a5 = 0, i4 = y2(0), n3 = y2(0);
          r:
            if (i4 = y2(e3), r5 = c4[r5 >> 2], !(i4 == (n3 = m3[r5 + 28 >> 2]) | i4 != i4 & n3 != n3))
              for (m3[r5 + 28 >> 2] = i4; ; ) {
                if (4 & (a5 = v3[r5 + 4 | 0]))
                  break r;
                if (f3[r5 + 4 | 0] = 4 | a5, (a5 = c4[r5 + 20 >> 2]) && aa[0 | a5](r5), c4[r5 + 308 >> 2] = 2143289344, !(r5 = c4[r5 + 552 >> 2]))
                  break;
              }
        }, function(r5, e3, a5) {
          e3 |= 0, a5 = +a5;
          var i4 = 0;
          i4 = c4[(r5 |= 0) >> 2], e3 = ((r5 = c4[r5 + 4 >> 2]) >> 1) + e3 | 0, 1 & r5 && (i4 = c4[i4 + c4[e3 >> 2] >> 2]), aa[0 | i4](e3, a5);
        }, function(r5, e3) {
          e3 = +e3, fe(c4[(r5 |= 0) >> 2], qr2(y2(e3)));
        }, function(r5, e3) {
          e3 = +e3, fe(c4[(r5 |= 0) >> 2], Kr2(y2(e3)));
        }, function(r5) {
          fe(c4[(r5 |= 0) >> 2], 2141891242);
        }, function(r5, e3) {
          r5 |= 0, e3 = +e3;
          var a5 = 0, i4 = y2(0), n3 = y2(0);
          r:
            if (i4 = y2(e3), r5 = c4[r5 >> 2], !(i4 == (n3 = m3[r5 + 32 >> 2]) | i4 != i4 & n3 != n3))
              for (m3[r5 + 32 >> 2] = i4; ; ) {
                if (4 & (a5 = v3[r5 + 4 | 0]))
                  break r;
                if (f3[r5 + 4 | 0] = 4 | a5, (a5 = c4[r5 + 20 >> 2]) && aa[0 | a5](r5), c4[r5 + 308 >> 2] = 2143289344, !(r5 = c4[r5 + 552 >> 2]))
                  break;
              }
        }, function(r5, e3) {
          r5 |= 0, e3 = +e3;
          var a5 = 0, i4 = y2(0), n3 = y2(0);
          r:
            if (i4 = y2(e3), r5 = c4[r5 >> 2], !(i4 == (n3 = m3[r5 + 36 >> 2]) | i4 != i4 & n3 != n3))
              for (m3[r5 + 36 >> 2] = i4; ; ) {
                if (4 & (a5 = v3[r5 + 4 | 0]))
                  break r;
                if (f3[r5 + 4 | 0] = 4 | a5, (a5 = c4[r5 + 20 >> 2]) && aa[0 | a5](r5), c4[r5 + 308 >> 2] = 2143289344, !(r5 = c4[r5 + 552 >> 2]))
                  break;
              }
        }, function(r5, e3) {
          e3 = +e3, te2(c4[(r5 |= 0) >> 2], 0, qr2(y2(e3)));
        }, function(r5, e3) {
          e3 = +e3, te2(c4[(r5 |= 0) >> 2], 0, Kr2(y2(e3)));
        }, function(r5) {
          te2(c4[(r5 |= 0) >> 2], 0, 2141891242);
        }, function(r5, e3) {
          e3 = +e3, te2(c4[(r5 |= 0) >> 2], 1, qr2(y2(e3)));
        }, function(r5, e3) {
          e3 = +e3, te2(c4[(r5 |= 0) >> 2], 1, Kr2(y2(e3)));
        }, function(r5) {
          te2(c4[(r5 |= 0) >> 2], 1, 2141891242);
        }, function(r5, e3) {
          e3 = +e3, ie2(c4[(r5 |= 0) >> 2], 0, qr2(y2(e3)));
        }, function(r5, e3) {
          e3 = +e3, ie2(c4[(r5 |= 0) >> 2], 0, Kr2(y2(e3)));
        }, function(r5, e3) {
          e3 = +e3, ie2(c4[(r5 |= 0) >> 2], 1, qr2(y2(e3)));
        }, function(r5, e3) {
          e3 = +e3, ie2(c4[(r5 |= 0) >> 2], 1, Kr2(y2(e3)));
        }, function(r5, e3) {
          e3 = +e3, ne2(c4[(r5 |= 0) >> 2], 0, qr2(y2(e3)));
        }, function(r5, e3) {
          e3 = +e3, ne2(c4[(r5 |= 0) >> 2], 0, Kr2(y2(e3)));
        }, function(r5, e3) {
          e3 = +e3, ne2(c4[(r5 |= 0) >> 2], 1, qr2(y2(e3)));
        }, function(r5, e3) {
          e3 = +e3, ne2(c4[(r5 |= 0) >> 2], 1, Kr2(y2(e3)));
        }, function(r5, e3) {
          r5 |= 0, e3 = +e3;
          var a5 = 0, i4 = y2(0), n3 = y2(0);
          r:
            if (i4 = y2(e3), r5 = c4[r5 >> 2], !(i4 == (n3 = m3[r5 + 224 >> 2]) | i4 != i4 & n3 != n3))
              for (m3[r5 + 224 >> 2] = i4; ; ) {
                if (4 & (a5 = v3[r5 + 4 | 0]))
                  break r;
                if (f3[r5 + 4 | 0] = 4 | a5, (a5 = c4[r5 + 20 >> 2]) && aa[0 | a5](r5), c4[r5 + 308 >> 2] = 2143289344, !(r5 = c4[r5 + 552 >> 2]))
                  break;
              }
        }, function(r5, e3, a5) {
          e3 |= 0, a5 = +a5;
          var i4 = 0;
          r:
            if (r5 = c4[(r5 |= 0) >> 2], (0 | c4[152 + (e3 = r5 + (e3 << 2) | 0) >> 2]) != (0 | (i4 = qr2(y2(a5)))))
              for (c4[e3 + 152 >> 2] = i4; ; ) {
                if (4 & (e3 = v3[r5 + 4 | 0]))
                  break r;
                if (f3[r5 + 4 | 0] = 4 | e3, (e3 = c4[r5 + 20 >> 2]) && aa[0 | e3](r5), c4[r5 + 308 >> 2] = 2143289344, !(r5 = c4[r5 + 552 >> 2]))
                  break;
              }
        }, function(r5, e3, a5) {
          e3 |= 0, a5 = +a5, ce(c4[(r5 |= 0) >> 2], e3, qr2(y2(a5)));
        }, function(r5, e3, a5) {
          e3 |= 0, a5 = +a5, ce(c4[(r5 |= 0) >> 2], e3, Kr2(y2(a5)));
        }, function(r5, e3, a5) {
          e3 |= 0, a5 = +a5;
          var i4 = 0;
          r:
            if (r5 = c4[(r5 |= 0) >> 2], (0 | c4[188 + (e3 = r5 + (e3 << 2) | 0) >> 2]) != (0 | (i4 = qr2(y2(a5)))))
              for (c4[e3 + 188 >> 2] = i4; ; ) {
                if (4 & (e3 = v3[r5 + 4 | 0]))
                  break r;
                if (f3[r5 + 4 | 0] = 4 | e3, (e3 = c4[r5 + 20 >> 2]) && aa[0 | e3](r5), c4[r5 + 308 >> 2] = 2143289344, !(r5 = c4[r5 + 552 >> 2]))
                  break;
              }
        }, function(r5) {
          return 3 & h3[c4[(r5 |= 0) >> 2] + 26 >> 1];
        }, Ge, function(r5, e3, a5) {
          r5 |= 0, e3 |= 0, a5 |= 0;
          var i4 = 0, n3 = 0, t5 = y2(0);
          i4 = 2, e3 = c4[e3 >> 2] + (a5 << 2) | 0, t5 = m3[e3 + 80 >> 2];
          r: {
            e: {
              if (2139156720 != (0 | (e3 = c4[e3 + 80 >> 2]))) {
                if (n3 = NaN, 2141891242 == (0 | e3)) {
                  i4 = 3;
                  break r;
                }
                if (2140081935 != (0 | e3))
                  break e;
                n3 = 0, i4 = 1;
                break r;
              }
              break r;
            }
            t5 == t5 ? (i4 = 1073741824 & e3 ? 2 : 1, b2(2, 536870912 + (-1073741825 & e3) | 0), n3 = +d2()) : i4 = 0;
          }
          N2[r5 + 8 >> 3] = n3, c4[r5 >> 2] = i4;
        }, function(r5, e3, a5) {
          e3 |= 0, a5 |= 0;
          var i4, n3 = 0;
          return ar3 = i4 = ar3 - 16 | 0, n3 = c4[(r5 |= 0) >> 2], e3 = ((r5 = c4[r5 + 4 >> 2]) >> 1) + e3 | 0, 1 & r5 && (n3 = c4[n3 + c4[e3 >> 2] >> 2]), aa[0 | n3](i4, e3, a5), r5 = ye(16), e3 = c4[i4 + 12 >> 2], c4[r5 + 8 >> 2] = c4[i4 + 8 >> 2], c4[r5 + 12 >> 2] = e3, e3 = c4[i4 + 4 >> 2], c4[r5 >> 2] = c4[i4 >> 2], c4[r5 + 4 >> 2] = e3, ar3 = i4 + 16 | 0, 0 | r5;
        }, function(r5) {
          return c4[c4[(r5 |= 0) >> 2] + 24 >> 2] >>> 7 & 7;
        }, function(r5) {
          return c4[c4[(r5 |= 0) >> 2] + 24 >> 2] >>> 10 & 7;
        }, function(r5) {
          return c4[c4[(r5 |= 0) >> 2] + 24 >> 2] >>> 13 & 7;
        }, function(r5) {
          return c4[c4[(r5 |= 0) >> 2] + 24 >> 2] >>> 2 & 3;
        }, function(r5) {
          return c4[c4[(r5 |= 0) >> 2] + 24 >> 2] >>> 18 & 3;
        }, function(r5) {
          return c4[c4[(r5 |= 0) >> 2] + 24 >> 2] >>> 4 & 7;
        }, function(r5, e3, a5) {
          r5 |= 0, e3 |= 0, a5 |= 0;
          var i4 = 0, n3 = 0, t5 = y2(0);
          i4 = 2, e3 = c4[e3 >> 2] + (a5 << 2) | 0, t5 = m3[e3 + 44 >> 2];
          r: {
            e: {
              if (2139156720 != (0 | (e3 = c4[e3 + 44 >> 2]))) {
                if (n3 = NaN, 2141891242 == (0 | e3)) {
                  i4 = 3;
                  break r;
                }
                if (2140081935 != (0 | e3))
                  break e;
                n3 = 0, i4 = 1;
                break r;
              }
              break r;
            }
            t5 == t5 ? (i4 = 1073741824 & e3 ? 2 : 1, b2(2, 536870912 + (-1073741825 & e3) | 0), n3 = +d2()) : i4 = 0;
          }
          N2[r5 + 8 >> 3] = n3, c4[r5 >> 2] = i4;
        }, function(r5, e3) {
          r5 |= 0, e3 |= 0;
          var a5 = 0, i4 = y2(0), n3 = y2(0);
          i4 = y2(NaN), e3 = c4[e3 >> 2], n3 = m3[e3 + 40 >> 2], a5 = 3, 2141891242 != (0 | (e3 = c4[e3 + 40 >> 2])) && (2140081935 != (0 | e3) ? 2139156720 != (0 | e3) ? (a5 = 0, n3 == n3 && (b2(2, 536870912 + (-1073741825 & e3) | 0), i4 = d2(), a5 = 1073741824 & e3 ? 2 : 1)) : (i4 = y2(0), a5 = 2) : (i4 = y2(0), a5 = 1)), c4[r5 >> 2] = a5, N2[r5 + 8 >> 3] = i4;
        }, function(r5, e3) {
          e3 |= 0;
          var a5, i4 = 0;
          return ar3 = a5 = ar3 - 16 | 0, i4 = c4[(r5 |= 0) >> 2], e3 = ((r5 = c4[r5 + 4 >> 2]) >> 1) + e3 | 0, 1 & r5 && (i4 = c4[i4 + c4[e3 >> 2] >> 2]), aa[0 | i4](a5, e3), r5 = ye(16), e3 = c4[a5 + 12 >> 2], c4[r5 + 8 >> 2] = c4[a5 + 8 >> 2], c4[r5 + 12 >> 2] = e3, e3 = c4[a5 + 4 >> 2], c4[r5 >> 2] = c4[a5 >> 2], c4[r5 + 4 >> 2] = e3, ar3 = a5 + 16 | 0, 0 | r5;
        }, function(r5) {
          r5 |= 0;
          var e3 = y2(0);
          return +((e3 = m3[c4[r5 >> 2] + 32 >> 2]) == e3 ? e3 : y2(0));
        }, function(r5, e3) {
          e3 |= 0;
          var a5 = 0;
          return a5 = c4[(r5 |= 0) >> 2], e3 = ((r5 = c4[r5 + 4 >> 2]) >> 1) + e3 | 0, 1 & r5 && (a5 = c4[a5 + c4[e3 >> 2] >> 2]), +aa[0 | a5](e3);
        }, function(r5) {
          r5 |= 0;
          var e3 = y2(0);
          return r5 = c4[r5 >> 2], (e3 = m3[r5 + 36 >> 2]) != e3 && (e3 = v3[c4[r5 + 568 >> 2] + 10 | 0] ? y2(1) : y2(0)), +e3;
        }, function(r5, e3) {
          r5 |= 0, e3 |= 0;
          var a5 = 0, i4 = 0, n3 = y2(0);
          e3 = c4[e3 >> 2], n3 = m3[e3 + 200 >> 2];
          r: {
            e: {
              if (2139156720 != (0 | (e3 = c4[e3 + 200 >> 2]))) {
                if (i4 = NaN, a5 = 3, 2141891242 == (0 | e3))
                  break r;
                if (2140081935 != (0 | e3))
                  break e;
                i4 = 0, a5 = 1;
                break r;
              }
              a5 = 2;
              break r;
            }
            a5 = 0, n3 == n3 && (b2(2, 536870912 + (-1073741825 & e3) | 0), i4 = +d2(), a5 = 1073741824 & e3 ? 2 : 1);
          }
          e3 = a5, N2[r5 + 8 >> 3] = i4, c4[r5 >> 2] = e3;
        }, function(r5, e3) {
          r5 |= 0, e3 |= 0;
          var a5 = 0, i4 = 0, n3 = y2(0);
          e3 = c4[e3 >> 2], n3 = m3[e3 + 204 >> 2];
          r: {
            e: {
              if (2139156720 != (0 | (e3 = c4[e3 + 204 >> 2]))) {
                if (i4 = NaN, a5 = 3, 2141891242 == (0 | e3))
                  break r;
                if (2140081935 != (0 | e3))
                  break e;
                i4 = 0, a5 = 1;
                break r;
              }
              a5 = 2;
              break r;
            }
            a5 = 0, n3 == n3 && (b2(2, 536870912 + (-1073741825 & e3) | 0), i4 = +d2(), a5 = 1073741824 & e3 ? 2 : 1);
          }
          e3 = a5, N2[r5 + 8 >> 3] = i4, c4[r5 >> 2] = e3;
        }, function(r5, e3) {
          r5 |= 0, e3 |= 0;
          var a5 = 0, i4 = 0, n3 = y2(0);
          e3 = c4[e3 >> 2], n3 = m3[e3 + 208 >> 2];
          r: {
            e: {
              if (2139156720 != (0 | (e3 = c4[e3 + 208 >> 2]))) {
                if (i4 = NaN, a5 = 3, 2141891242 == (0 | e3))
                  break r;
                if (2140081935 != (0 | e3))
                  break e;
                i4 = 0, a5 = 1;
                break r;
              }
              a5 = 2;
              break r;
            }
            a5 = 0, n3 == n3 && (b2(2, 536870912 + (-1073741825 & e3) | 0), i4 = +d2(), a5 = 1073741824 & e3 ? 2 : 1);
          }
          e3 = a5, N2[r5 + 8 >> 3] = i4, c4[r5 >> 2] = e3;
        }, function(r5, e3) {
          r5 |= 0, e3 |= 0;
          var a5 = 0, i4 = 0, n3 = y2(0);
          e3 = c4[e3 >> 2], n3 = m3[e3 + 212 >> 2];
          r: {
            e: {
              if (2139156720 != (0 | (e3 = c4[e3 + 212 >> 2]))) {
                if (i4 = NaN, a5 = 3, 2141891242 == (0 | e3))
                  break r;
                if (2140081935 != (0 | e3))
                  break e;
                i4 = 0, a5 = 1;
                break r;
              }
              a5 = 2;
              break r;
            }
            a5 = 0, n3 == n3 && (b2(2, 536870912 + (-1073741825 & e3) | 0), i4 = +d2(), a5 = 1073741824 & e3 ? 2 : 1);
          }
          e3 = a5, N2[r5 + 8 >> 3] = i4, c4[r5 >> 2] = e3;
        }, function(r5, e3) {
          r5 |= 0, e3 |= 0;
          var a5 = 0, i4 = 0, n3 = y2(0);
          e3 = c4[e3 >> 2], n3 = m3[e3 + 216 >> 2];
          r: {
            e: {
              if (2139156720 != (0 | (e3 = c4[e3 + 216 >> 2]))) {
                if (i4 = NaN, a5 = 3, 2141891242 == (0 | e3))
                  break r;
                if (2140081935 != (0 | e3))
                  break e;
                i4 = 0, a5 = 1;
                break r;
              }
              a5 = 2;
              break r;
            }
            a5 = 0, n3 == n3 && (b2(2, 536870912 + (-1073741825 & e3) | 0), i4 = +d2(), a5 = 1073741824 & e3 ? 2 : 1);
          }
          e3 = a5, N2[r5 + 8 >> 3] = i4, c4[r5 >> 2] = e3;
        }, function(r5, e3) {
          r5 |= 0, e3 |= 0;
          var a5 = 0, i4 = 0, n3 = y2(0);
          e3 = c4[e3 >> 2], n3 = m3[e3 + 220 >> 2];
          r: {
            e: {
              if (2139156720 != (0 | (e3 = c4[e3 + 220 >> 2]))) {
                if (i4 = NaN, a5 = 3, 2141891242 == (0 | e3))
                  break r;
                if (2140081935 != (0 | e3))
                  break e;
                i4 = 0, a5 = 1;
                break r;
              }
              a5 = 2;
              break r;
            }
            a5 = 0, n3 == n3 && (b2(2, 536870912 + (-1073741825 & e3) | 0), i4 = +d2(), a5 = 1073741824 & e3 ? 2 : 1);
          }
          e3 = a5, N2[r5 + 8 >> 3] = i4, c4[r5 >> 2] = e3;
        }, function(r5) {
          r5 |= 0;
          var e3 = y2(0);
          return +((e3 = m3[c4[r5 >> 2] + 224 >> 2]) != e3 ? y2(NaN) : e3);
        }, function(r5, e3) {
          r5 |= 0, e3 |= 0;
          var a5 = 0, i4 = y2(0);
          r5 = c4[r5 >> 2] + (e3 << 2) | 0, i4 = m3[r5 + 152 >> 2];
          r: {
            if (!(2139156720 == (0 | (r5 = c4[r5 + 152 >> 2])) | 2140081935 == (0 | r5))) {
              if (a5 = NaN, 2141891242 == (0 | r5) | i4 != i4)
                break r;
              if (2139156720 != (0 | r5))
                return b2(2, 536870912 + (-1073741825 & r5) | 0), +d2();
            }
            a5 = 0;
          }
          return +a5;
        }, function(r5, e3, a5) {
          e3 |= 0, a5 |= 0;
          var i4 = 0;
          return i4 = c4[(r5 |= 0) >> 2], e3 = ((r5 = c4[r5 + 4 >> 2]) >> 1) + e3 | 0, 1 & r5 && (i4 = c4[i4 + c4[e3 >> 2] >> 2]), +aa[0 | i4](e3, a5);
        }, function(r5) {
          return c4[c4[(r5 |= 0) >> 2] + 24 >> 2] >>> 20 & 3;
        }, function(r5) {
          return c4[c4[(r5 |= 0) >> 2] + 24 >> 2] >>> 22 & 1;
        }, function(r5, e3, a5) {
          r5 |= 0, e3 |= 0, a5 |= 0;
          var i4 = 0, n3 = 0, t5 = y2(0);
          i4 = 2, e3 = c4[e3 >> 2] + (a5 << 2) | 0, t5 = m3[e3 + 116 >> 2];
          r: {
            e: {
              if (2139156720 != (0 | (e3 = c4[e3 + 116 >> 2]))) {
                if (n3 = NaN, 2141891242 == (0 | e3)) {
                  i4 = 3;
                  break r;
                }
                if (2140081935 != (0 | e3))
                  break e;
                n3 = 0, i4 = 1;
                break r;
              }
              break r;
            }
            t5 == t5 ? (i4 = 1073741824 & e3 ? 2 : 1, b2(2, 536870912 + (-1073741825 & e3) | 0), n3 = +d2()) : i4 = 0;
          }
          N2[r5 + 8 >> 3] = n3, c4[r5 >> 2] = i4;
        }, function(r5, e3) {
          r5 |= 0, e3 |= 0;
          var a5 = y2(0), i4 = y2(0);
          r5 = c4[r5 >> 2] + (e3 << 2) | 0, i4 = m3[r5 + 188 >> 2];
          r: {
            if (!(2139156720 == (0 | (r5 = c4[r5 + 188 >> 2])) | 2140081935 == (0 | r5))) {
              if (a5 = y2(NaN), 2141891242 == (0 | r5) | i4 != i4)
                break r;
              if (2139156720 != (0 | r5))
                return y2((b2(2, 536870912 + (-1073741825 & r5) | 0), d2()));
            }
            a5 = y2(0);
          }
          return y2(a5);
        }, function(r5, e3, a5) {
          e3 |= 0, a5 |= 0;
          var i4 = 0;
          return i4 = c4[(r5 |= 0) >> 2], e3 = ((r5 = c4[r5 + 4 >> 2]) >> 1) + e3 | 0, 1 & r5 && (i4 = c4[i4 + c4[e3 >> 2] >> 2]), y2(y2(aa[0 | i4](e3, a5)));
        }, function(r5, e3, a5) {
          e3 |= 0, a5 |= 0;
          var i4, n3 = 0, t5 = 0, o4 = 0, u3 = 0, b3 = 0, s4 = 0, A4 = 0, l4 = 0, d3 = 0;
          ar3 = i4 = ar3 - 80 | 0, r5 = c4[(r5 |= 0) >> 2];
          r: {
            e: {
              if (b3 = c4[e3 >> 2], !c4[b3 + 552 >> 2]) {
                if (c4[r5 + 8 >> 2])
                  break e;
                u3 = (e3 = c4[r5 + 556 >> 2]) + (a5 << 2) | 0;
                a:
                  if ((n3 = c4[r5 + 560 >> 2]) >>> 0 < (o4 = c4[(t5 = r5 + 564 | 0) >> 2]) >>> 0) {
                    if ((0 | n3) == (0 | u3)) {
                      c4[u3 >> 2] = b3, c4[r5 + 560 >> 2] = u3 + 4;
                      break a;
                    }
                    if (a5 = n3, n3 >>> 0 > (e3 = n3 - 4 | 0) >>> 0)
                      for (; c4[a5 >> 2] = c4[e3 >> 2], a5 = a5 + 4 | 0, n3 >>> 0 > (e3 = e3 + 4 | 0) >>> 0; )
                        ;
                    c4[r5 + 560 >> 2] = a5, (0 | (e3 = u3 + 4 | 0)) != (0 | n3) && wr2(n3 - (-4 & (e3 = n3 - e3 | 0)) | 0, u3, e3), c4[u3 >> 2] = b3;
                  } else {
                    if ((n3 = 1 + (n3 - e3 >> 2) | 0) >>> 0 >= 1073741824)
                      break r;
                    if (o4 = (e3 = o4 - e3 | 0) >>> 1 | 0, t5 = pe(i4 + 32 | 0, e3 >>> 0 >= 2147483644 ? 1073741823 : n3 >>> 0 < o4 >>> 0 ? o4 : n3, a5, t5), (0 | (a5 = c4[t5 + 8 >> 2])) == c4[t5 + 12 >> 2])
                      if ((e3 = c4[t5 + 4 >> 2]) >>> 0 > (n3 = c4[t5 >> 2]) >>> 0)
                        a5 = wr2(s4 = (n3 = (1 + (e3 - n3 >> 2) | 0) / -2 << 2) + e3 | 0, o4 = e3, e3 = a5 - e3 | 0) + e3 | 0, c4[t5 + 8 >> 2] = a5, c4[t5 + 4 >> 2] = n3 + c4[t5 + 4 >> 2];
                      else {
                        if (o4 = pe(i4 + 56 | 0, e3 = (0 | a5) == (0 | n3) ? 1 : a5 - n3 >> 1, e3 >>> 2 | 0, c4[t5 + 16 >> 2]), n3 = c4[o4 + 8 >> 2], (0 | (e3 = c4[t5 + 4 >> 2])) != (0 | (a5 = c4[t5 + 8 >> 2]))) {
                          for (a5 = (a5 - e3 | 0) + n3 | 0; c4[n3 >> 2] = c4[e3 >> 2], e3 = e3 + 4 | 0, (0 | (n3 = n3 + 4 | 0)) != (0 | a5); )
                            ;
                          e3 = c4[t5 + 8 >> 2], n3 = c4[t5 + 4 >> 2];
                        } else
                          a5 = n3, n3 = e3;
                        s4 = c4[t5 >> 2], c4[t5 >> 2] = c4[o4 >> 2], c4[o4 >> 2] = s4, c4[t5 + 4 >> 2] = c4[o4 + 4 >> 2], c4[o4 + 4 >> 2] = n3, c4[t5 + 8 >> 2] = a5, c4[o4 + 8 >> 2] = e3, A4 = c4[t5 + 12 >> 2], c4[t5 + 12 >> 2] = c4[o4 + 12 >> 2], c4[o4 + 12 >> 2] = A4, (0 | e3) != (0 | n3) && (c4[o4 + 8 >> 2] = (3 + (n3 - e3 | 0) & -4) + e3), s4 && (gr2(s4), a5 = c4[t5 + 8 >> 2]);
                      }
                    c4[a5 >> 2] = b3, c4[t5 + 8 >> 2] = c4[t5 + 8 >> 2] + 4, a5 = u3 - (e3 = c4[r5 + 556 >> 2]) | 0, l4 = t5, d3 = wr2(c4[t5 + 4 >> 2] - a5 | 0, e3, a5), c4[l4 + 4 >> 2] = d3, n3 = c4[r5 + 560 >> 2] - u3 | 0, u3 = wr2(c4[t5 + 8 >> 2], u3, n3), e3 = c4[r5 + 556 >> 2], c4[r5 + 556 >> 2] = c4[t5 + 4 >> 2], c4[t5 + 4 >> 2] = e3, a5 = c4[r5 + 560 >> 2], c4[r5 + 560 >> 2] = n3 + u3, c4[t5 + 8 >> 2] = a5, n3 = c4[r5 + 564 >> 2], c4[r5 + 564 >> 2] = c4[t5 + 12 >> 2], c4[t5 >> 2] = e3, c4[t5 + 12 >> 2] = n3, (0 | e3) != (0 | a5) && (c4[t5 + 8 >> 2] = a5 + (3 + (e3 - a5 | 0) & -4)), e3 && gr2(e3);
                  }
                for (c4[b3 + 552 >> 2] = r5; !(4 & (e3 = v3[r5 + 4 | 0])) && (f3[r5 + 4 | 0] = 4 | e3, (e3 = c4[r5 + 20 >> 2]) && aa[0 | e3](r5), c4[r5 + 308 >> 2] = 2143289344, r5 = c4[r5 + 552 >> 2]); )
                  ;
                return void (ar3 = i4 + 80 | 0);
              }
              c4[i4 + 16 >> 2] = 4006, Xr2(r5, i4 + 16 | 0), De(), k2();
            }
            c4[i4 >> 2] = 4139, Xr2(r5, i4), De(), k2();
          }
          I2(), k2();
        }, Ne, function(r5, e3) {
          e3 |= 0;
          var a5, i4 = 0, n3 = 0, t5 = 0;
          ar3 = a5 = ar3 - 320 | 0, r5 = c4[(r5 |= 0) >> 2];
          r:
            if (c4[r5 + 560 >> 2] != c4[r5 + 556 >> 2] && (n3 = c4[e3 >> 2], e3 = c4[n3 + 552 >> 2], ee2(r5, n3))) {
              if ((0 | r5) == (0 | e3)) {
                for (i4 = Rr2(a5, 0, 288), c4[(e3 = i4) + 16 >> 2] = 2143289344, c4[e3 + 20 >> 2] = 2143289344, Rr2(e3 + 24 | 0, 0, 49), c4[e3 + 80 >> 2] = 2143289344, t5 = e3 + 288 | 0, e3 = e3 + 96 | 0; c4[e3 + 16 >> 2] = -1082130432, c4[e3 + 20 >> 2] = -1082130432, c4[e3 + 8 >> 2] = 0, c4[e3 + 12 >> 2] = 0, c4[e3 >> 2] = -1082130432, c4[e3 + 4 >> 2] = -1082130432, (0 | t5) != (0 | (e3 = e3 + 24 | 0)); )
                  ;
                c4[i4 + 312 >> 2] = -1082130432, c4[i4 + 316 >> 2] = -1082130432, c4[i4 + 304 >> 2] = 0, c4[i4 + 308 >> 2] = 0, c4[i4 + 296 >> 2] = -1082130432, c4[i4 + 300 >> 2] = -1082130432, c4[i4 + 288 >> 2] = 2143289344, c4[i4 + 292 >> 2] = 2143289344, Ar2(n3 + 228 | 0, i4, 320), c4[n3 + 552 >> 2] = 0;
              }
              for (; ; ) {
                if (4 & (e3 = v3[r5 + 4 | 0]))
                  break r;
                if (f3[r5 + 4 | 0] = 4 | e3, (e3 = c4[r5 + 20 >> 2]) && aa[0 | e3](r5), c4[r5 + 308 >> 2] = 2143289344, !(r5 = c4[r5 + 552 >> 2]))
                  break;
              }
            }
          ar3 = a5 + 320 | 0;
        }, Ee, function(r5) {
          return r5 = c4[(r5 |= 0) >> 2], c4[r5 + 560 >> 2] - c4[r5 + 556 >> 2] >> 2;
        }, Ge, function(r5) {
          return (r5 = c4[c4[(r5 |= 0) >> 2] + 552 >> 2]) ? c4[r5 >> 2] : 0;
        }, Ge, function(r5, e3) {
          e3 |= 0;
          var a5, i4 = 0;
          return a5 = c4[(r5 |= 0) >> 2], r5 = c4[a5 + 556 >> 2], c4[a5 + 560 >> 2] - r5 >> 2 >>> 0 <= e3 >>> 0 || (r5 = c4[r5 + (e3 << 2) >> 2]) && (i4 = c4[r5 >> 2]), 0 | i4;
        }, we, function(r5) {
          return (2 & v3[c4[(r5 |= 0) >> 2] + 4 | 0]) >>> 1 | 0;
        }, Ge, function(r5, e3) {
          e3 |= 0;
          var a5 = 0;
          r:
            if (r5 = c4[(r5 |= 0) >> 2], ((2 & (a5 = v3[r5 + 4 | 0])) >>> 1 | 0) != (0 | e3))
              for (f3[r5 + 4 | 0] = 253 & a5 | (e3 ? 2 : 0); ; ) {
                if (4 & (e3 = v3[r5 + 4 | 0]))
                  break r;
                if (f3[r5 + 4 | 0] = 4 | e3, (e3 = c4[r5 + 20 >> 2]) && aa[0 | e3](r5), c4[r5 + 308 >> 2] = 2143289344, !(r5 = c4[r5 + 552 >> 2]))
                  break;
              }
        }, Ee, function(r5, e3) {
          var a5;
          e3 |= 0, a5 = c4[4 + (r5 |= 0) >> 2], c4[r5 + 4 >> 2] = e3, a5 && aa[c4[c4[a5 >> 2] + 4 >> 2]](a5), ke(c4[r5 >> 2], 14);
        }, Ee, function(r5) {
          var e3;
          e3 = c4[4 + (r5 |= 0) >> 2], c4[r5 + 4 >> 2] = 0, e3 && aa[c4[c4[e3 >> 2] + 4 >> 2]](e3), ke(c4[r5 >> 2], 0);
        }, function(r5, e3) {
          var a5;
          e3 |= 0, a5 = c4[8 + (r5 |= 0) >> 2], c4[r5 + 8 >> 2] = e3, a5 && aa[c4[c4[a5 >> 2] + 4 >> 2]](a5), c4[c4[r5 >> 2] + 20 >> 2] = 15;
        }, Ee, function(r5) {
          var e3;
          e3 = c4[8 + (r5 |= 0) >> 2], c4[r5 + 8 >> 2] = 0, e3 && aa[c4[c4[e3 >> 2] + 4 >> 2]](e3), c4[c4[r5 >> 2] + 20 >> 2] = 0;
        }, function(r5) {
          var e3, a5 = 0;
          if (ar3 = e3 = ar3 - 16 | 0, r5 = c4[(r5 |= 0) >> 2], c4[r5 + 8 >> 2]) {
            for (; !(4 & (a5 = v3[r5 + 4 | 0])) && (f3[r5 + 4 | 0] = 4 | a5, (a5 = c4[r5 + 20 >> 2]) && aa[0 | a5](r5), c4[r5 + 308 >> 2] = 2143289344, r5 = c4[r5 + 552 >> 2]); )
              ;
            ar3 = e3 + 16 | 0;
          } else
            c4[e3 >> 2] = 1024, Xr2(r5, e3), De(), k2();
        }, function(r5) {
          return (4 & v3[c4[(r5 |= 0) >> 2] + 4 | 0]) >>> 2 | 0;
        }, Ge, function(r5, e3, a5, i4) {
          r5 |= 0, e3 = +e3, a5 = +a5, i4 |= 0;
          var n3, t5, f4 = y2(0), o4 = y2(0), u3 = y2(0), s4 = 0, A4 = y2(0), k3 = 0, l4 = y2(0);
          ar3 = t5 = ar3 + -64 | 0, n3 = c4[r5 >> 2], Rr2(t5 + 8 | 0, 0, 56), c4[1735] = c4[1735] + 1, sr2(n3), u3 = y2(e3), o4 = m3[n3 + 572 >> 2];
          r: {
            e: {
              switch (0 | (r5 = c4[n3 + 576 >> 2])) {
                case 0:
                case 3:
                  break e;
              }
              a: {
                if (!(1 != (0 | r5) | (f4 = m3[n3 + 572 >> 2]) != f4)) {
                  if (!((f4 = o4) < y2(0)))
                    break a;
                  break e;
                }
                i: {
                  if (2 != (0 | r5) | f4 != f4) {
                    f4 = y2(NaN);
                    n:
                      switch (r5 - 1 | 0) {
                        case 1:
                          break i;
                        case 0:
                          break n;
                        default:
                          break a;
                      }
                    f4 = o4;
                    break a;
                  }
                  if (u3 != u3 | o4 < y2(0))
                    break e;
                }
                f4 = y2(y2(o4 * u3) * y2(0.009999999776482582));
              }
              l4 = y2(f4 + y2(Mr2(n3, 2, u3) + Ur2(n3, 2, u3))), k3 = 1;
              break r;
            }
            f4 = y2(0), o4 = m3[n3 + 216 >> 2];
            e: {
              a: {
                i: {
                  n:
                    if (2139156720 != (0 | (r5 = c4[n3 + 216 >> 2]))) {
                      if (2140081935 == (0 | r5))
                        break e;
                      k3 = 4276;
                      t: {
                        if (2141891242 != (0 | r5)) {
                          if (o4 == o4)
                            break t;
                          k3 = 4268;
                        }
                        switch (f4 = m3[k3 >> 2], c4[k3 + 4 >> 2] - 1 | 0) {
                          case 0:
                            break i;
                          case 1:
                            break n;
                          default:
                            break a;
                        }
                      }
                      if (b2(2, 536870912 + (-1073741825 & r5) | 0), f4 = d2(), !(1073741824 & r5))
                        break i;
                    }
                  f4 = y2(y2(f4 * u3) * y2(0.009999999776482582));
                }
                if (f4 == f4) {
                  f4 = y2(0);
                  i:
                    if (2139156720 != (0 | r5)) {
                      if (2140081935 == (0 | r5))
                        break e;
                      s4 = 4276;
                      n: {
                        if (2141891242 != (0 | r5)) {
                          if (o4 == o4)
                            break n;
                          s4 = 4268;
                        }
                        switch (f4 = m3[s4 >> 2], l4 = y2(NaN), k3 = 2, c4[s4 + 4 >> 2] - 1 | 0) {
                          case 1:
                            break i;
                          case 0:
                            break e;
                          default:
                            break r;
                        }
                      }
                      if (b2(2, 536870912 + (-1073741825 & r5) | 0), f4 = d2(), !(1073741824 & r5))
                        break e;
                    }
                  l4 = y2(y2(f4 * u3) * y2(0.009999999776482582)), k3 = 2;
                  break r;
                }
              }
              k3 = u3 == u3, l4 = u3;
              break r;
            }
            k3 = 2, l4 = f4;
          }
          A4 = y2(a5), o4 = m3[n3 + 580 >> 2];
          r: {
            e: {
              switch (0 | (r5 = c4[n3 + 584 >> 2])) {
                case 0:
                case 3:
                  break e;
              }
              a: {
                if (!(1 != (0 | r5) | (f4 = m3[n3 + 580 >> 2]) != f4)) {
                  if (!((f4 = o4) < y2(0)))
                    break a;
                  break e;
                }
                i: {
                  if (2 != (0 | r5) | f4 != f4) {
                    f4 = y2(NaN);
                    n:
                      switch (r5 - 1 | 0) {
                        case 1:
                          break i;
                        case 0:
                          break n;
                        default:
                          break a;
                      }
                    f4 = o4;
                    break a;
                  }
                  if (A4 != A4 | o4 < y2(0))
                    break e;
                }
                f4 = y2(y2(o4 * A4) * y2(0.009999999776482582));
              }
              o4 = y2(f4 + y2(Mr2(n3, 0, u3) + Ur2(n3, 0, u3))), r5 = 1;
              break r;
            }
            f4 = y2(0), o4 = m3[n3 + 220 >> 2];
            e: {
              a: {
                i: {
                  n:
                    if (2139156720 != (0 | (r5 = c4[n3 + 220 >> 2]))) {
                      if (2140081935 == (0 | r5))
                        break e;
                      s4 = 4276;
                      t: {
                        if (2141891242 != (0 | r5)) {
                          if (o4 == o4)
                            break t;
                          s4 = 4268;
                        }
                        switch (f4 = m3[s4 >> 2], c4[s4 + 4 >> 2] - 1 | 0) {
                          case 0:
                            break i;
                          case 1:
                            break n;
                          default:
                            break a;
                        }
                      }
                      if (b2(2, 536870912 + (-1073741825 & r5) | 0), f4 = d2(), !(1073741824 & r5))
                        break i;
                    }
                  f4 = y2(y2(f4 * A4) * y2(0.009999999776482582));
                }
                if (f4 == f4) {
                  f4 = y2(0);
                  i:
                    if (2139156720 != (0 | r5)) {
                      if (2140081935 == (0 | r5))
                        break e;
                      s4 = 4276;
                      n: {
                        if (2141891242 != (0 | r5)) {
                          if (o4 == o4)
                            break n;
                          s4 = 4268;
                        }
                        switch (f4 = m3[s4 >> 2], o4 = y2(NaN), r5 = 2, c4[s4 + 4 >> 2] - 1 | 0) {
                          case 0:
                            break e;
                          case 1:
                            break i;
                          default:
                            break r;
                        }
                      }
                      if (b2(2, 536870912 + (-1073741825 & r5) | 0), f4 = d2(), !(1073741824 & r5))
                        break e;
                    }
                  o4 = y2(y2(f4 * A4) * y2(0.009999999776482582)), r5 = 2;
                  break r;
                }
              }
              r5 = A4 == A4, o4 = A4;
              break r;
            }
            r5 = 2, o4 = f4;
          }
          or2(n3, l4, o4, i4, k3, r5, u3, A4, 1, 0, c4[n3 + 568 >> 2], t5 + 8 | 0, 0, c4[1735]) && (Fr2(n3, 3 & v3[n3 + 300 | 0], u3, A4, u3), Er2(n3, +m3[c4[n3 + 568 >> 2] + 16 >> 2], 0, 0)), ar3 = t5 - -64 | 0;
        }, function(r5, e3, a5, i4, n3) {
          e3 |= 0, a5 = +a5, i4 = +i4, n3 |= 0;
          var t5 = 0;
          t5 = c4[(r5 |= 0) >> 2], e3 = ((r5 = c4[r5 + 4 >> 2]) >> 1) + e3 | 0, 1 & r5 && (t5 = c4[t5 + c4[e3 >> 2] >> 2]), aa[0 | t5](e3, a5, i4, n3);
        }, function(r5) {
          return +m3[c4[(r5 |= 0) >> 2] + 228 >> 2];
        }, function(r5) {
          return +m3[c4[(r5 |= 0) >> 2] + 236 >> 2];
        }, function(r5) {
          return +m3[c4[(r5 |= 0) >> 2] + 232 >> 2];
        }, function(r5) {
          return +m3[c4[(r5 |= 0) >> 2] + 240 >> 2];
        }, function(r5) {
          return +m3[c4[(r5 |= 0) >> 2] + 244 >> 2];
        }, function(r5) {
          return +m3[c4[(r5 |= 0) >> 2] + 248 >> 2];
        }, function(r5, e3) {
          r5 |= 0, e3 = c4[(e3 |= 0) >> 2], N2[r5 >> 3] = m3[e3 + 228 >> 2], N2[r5 + 8 >> 3] = m3[e3 + 236 >> 2], N2[r5 + 16 >> 3] = m3[e3 + 232 >> 2], N2[r5 + 24 >> 3] = m3[e3 + 240 >> 2], N2[r5 + 32 >> 3] = m3[e3 + 244 >> 2], N2[r5 + 40 >> 3] = m3[e3 + 248 >> 2];
        }, function(r5, e3) {
          e3 |= 0;
          var a5, i4 = 0;
          return ar3 = a5 = ar3 - 48 | 0, i4 = c4[(r5 |= 0) >> 2], e3 = ((r5 = c4[r5 + 4 >> 2]) >> 1) + e3 | 0, 1 & r5 && (i4 = c4[i4 + c4[e3 >> 2] >> 2]), aa[0 | i4](a5, e3), r5 = Ar2(ye(48), a5, 48), ar3 = a5 + 48 | 0, 0 | r5;
        }, function(r5, e3) {
          var a5;
          if (e3 |= 0, ar3 = a5 = ar3 - 16 | 0, r5 = c4[(r5 |= 0) >> 2], (0 | e3) < 6) {
            ar3 = a5 + 16 | 0;
            r: {
              switch (e3 - 4 | 0) {
                case 0:
                  if (e3 = r5 + 260 | 0, 2 == (3 & v3[r5 + 300 | 0]))
                    break r;
                  e3 = r5 + 252 | 0;
                  break r;
                case 1:
                  if (e3 = r5 + 252 | 0, 2 == (3 & v3[r5 + 300 | 0]))
                    break r;
                  e3 = r5 + 260 | 0;
                  break r;
              }
              e3 = 252 + (r5 + (e3 << 2) | 0) | 0;
            }
            return +m3[e3 >> 2];
          }
          c4[a5 >> 2] = 1871, Xr2(r5, a5), De(), k2();
        }, function(r5, e3) {
          var a5;
          if (e3 |= 0, ar3 = a5 = ar3 - 16 | 0, r5 = c4[(r5 |= 0) >> 2], (0 | e3) < 6) {
            ar3 = a5 + 16 | 0;
            r: {
              switch (e3 - 4 | 0) {
                case 0:
                  if (e3 = r5 + 276 | 0, 2 == (3 & v3[r5 + 300 | 0]))
                    break r;
                  e3 = r5 + 268 | 0;
                  break r;
                case 1:
                  if (e3 = r5 + 268 | 0, 2 == (3 & v3[r5 + 300 | 0]))
                    break r;
                  e3 = r5 + 276 | 0;
                  break r;
              }
              e3 = 268 + (r5 + (e3 << 2) | 0) | 0;
            }
            return +m3[e3 >> 2];
          }
          c4[a5 >> 2] = 1871, Xr2(r5, a5), De(), k2();
        }, function(r5, e3) {
          var a5;
          if (e3 |= 0, ar3 = a5 = ar3 - 16 | 0, r5 = c4[(r5 |= 0) >> 2], (0 | e3) < 6) {
            ar3 = a5 + 16 | 0;
            r: {
              switch (e3 - 4 | 0) {
                case 0:
                  if (e3 = r5 + 292 | 0, 2 == (3 & v3[r5 + 300 | 0]))
                    break r;
                  e3 = r5 + 284 | 0;
                  break r;
                case 1:
                  if (e3 = r5 + 284 | 0, 2 == (3 & v3[r5 + 300 | 0]))
                    break r;
                  e3 = r5 + 292 | 0;
                  break r;
              }
              e3 = 284 + (r5 + (e3 << 2) | 0) | 0;
            }
            return +m3[e3 >> 2];
          }
          c4[a5 >> 2] = 1871, Xr2(r5, a5), De(), k2();
        }, Se, Ce, Se, Ce, Gr2, Le, function(r5) {
          gr2(Le(r5 |= 0));
        }, function(r5, e3, a5, i4, n3, t5) {
          var o4, u3, b3;
          r5 |= 0, e3 |= 0, a5 = y2(a5), i4 |= 0, n3 = y2(n3), t5 |= 0, ar3 = o4 = ar3 - 48 | 0, b3 = c4[e3 + 8 >> 2], 1 & f3[6972] ? e3 = c4[1742] : (e3 = 0 | C3(5, 4416), f3[6972] = 1, c4[1742] = e3), c4[o4 + 40 >> 2] = t5, m3[o4 + 32 >> 2] = n3, c4[o4 + 24 >> 2] = i4, m3[o4 + 16 >> 2] = a5, e3 = (u3 = +Q3(0 | e3, 0 | b3, 2873, o4 + 12 | 0, o4 + 16 | 0)) < 4294967296 & u3 >= 0 ? ~~u3 >>> 0 : 0, i4 = c4[o4 + 12 >> 2], t5 = c4[e3 + 4 >> 2], c4[r5 >> 2] = c4[e3 >> 2], c4[r5 + 4 >> 2] = t5, t5 = c4[e3 + 12 >> 2], c4[r5 + 8 >> 2] = c4[e3 + 8 >> 2], c4[r5 + 12 >> 2] = t5, H3(0 | i4), ar3 = o4 + 48 | 0;
        }, $e, ra, Oe, function(r5) {
          gr2(Oe(r5 |= 0));
        }, function(r5) {
          Ie(c4[8 + (r5 |= 0) >> 2], 3244);
        }, $e, function(r5) {
          return 0 | q2(c4[60 + (r5 |= 0) >> 2]);
        }, function(r5, e3, a5) {
          e3 |= 0, a5 |= 0;
          var i4, n3 = 0, t5 = 0, f4 = 0, o4 = 0, u3 = 0, b3 = 0;
          ar3 = i4 = ar3 - 32 | 0, n3 = c4[28 + (r5 |= 0) >> 2], c4[i4 + 16 >> 2] = n3, t5 = c4[r5 + 20 >> 2], c4[i4 + 28 >> 2] = a5, c4[i4 + 24 >> 2] = e3, e3 = t5 - n3 | 0, c4[i4 + 20 >> 2] = e3, t5 = e3 + a5 | 0, u3 = 2, e3 = i4 + 16 | 0;
          r: {
            for (; ; ) {
              e: {
                a: {
                  i: {
                    if (!Ye(0 | K2(c4[r5 + 60 >> 2], 0 | e3, 0 | u3, i4 + 12 | 0))) {
                      if ((0 | (f4 = c4[i4 + 12 >> 2])) == (0 | t5))
                        break i;
                      if ((0 | f4) >= 0)
                        break a;
                      break e;
                    }
                    if (-1 != (0 | t5))
                      break e;
                  }
                  e3 = c4[r5 + 44 >> 2], c4[r5 + 28 >> 2] = e3, c4[r5 + 20 >> 2] = e3, c4[r5 + 16 >> 2] = e3 + c4[r5 + 48 >> 2], r5 = a5;
                  break r;
                }
                o4 = f4 - ((b3 = (o4 = c4[e3 + 4 >> 2]) >>> 0 < f4 >>> 0) ? o4 : 0) | 0, c4[(n3 = (b3 << 3) + e3 | 0) >> 2] = o4 + c4[n3 >> 2], c4[(e3 = (b3 ? 12 : 4) + e3 | 0) >> 2] = c4[e3 >> 2] - o4, t5 = t5 - f4 | 0, u3 = u3 - b3 | 0, e3 = n3;
                continue;
              }
              break;
            }
            c4[r5 + 28 >> 2] = 0, c4[r5 + 16 >> 2] = 0, c4[r5 + 20 >> 2] = 0, c4[r5 >> 2] = 32 | c4[r5 >> 2], r5 = 0, 2 != (0 | u3) && (r5 = a5 - c4[e3 + 4 >> 2] | 0);
          }
          return ar3 = i4 + 32 | 0, 0 | r5;
        }, function(r5, e3, a5, i4) {
          var n3;
          return e3 |= 0, a5 |= 0, i4 |= 0, ar3 = n3 = ar3 - 16 | 0, r5 = Ye(0 | j2(c4[60 + (r5 |= 0) >> 2], 0 | e3, 0 | a5, 255 & i4, n3 + 8 | 0)), ar3 = n3 + 16 | 0, ir2 = r5 ? -1 : c4[n3 + 12 >> 2], 0 | (r5 ? -1 : c4[n3 + 8 >> 2]);
        }, function(r5) {
          return 0;
        }, function(r5, e3, a5, i4) {
          return ir2 = 0, 0;
        }, function(r5, e3, a5) {
          e3 |= 0, a5 |= 0;
          var i4, n3, t5 = 0, o4 = 0, u3 = 0;
          return i4 = c4[84 + (r5 |= 0) >> 2], o4 = c4[i4 >> 2], t5 = c4[i4 + 4 >> 2], n3 = c4[r5 + 28 >> 2], (u3 = t5 >>> 0 < (u3 = c4[r5 + 20 >> 2] - n3 | 0) >>> 0 ? t5 : u3) && (Ar2(o4, n3, u3), o4 = u3 + c4[i4 >> 2] | 0, c4[i4 >> 2] = o4, t5 = c4[i4 + 4 >> 2] - u3 | 0, c4[i4 + 4 >> 2] = t5), (t5 = a5 >>> 0 > t5 >>> 0 ? t5 : a5) && (Ar2(o4, e3, t5), o4 = t5 + c4[i4 >> 2] | 0, c4[i4 >> 2] = o4, c4[i4 + 4 >> 2] = c4[i4 + 4 >> 2] - t5), f3[0 | o4] = 0, e3 = c4[r5 + 44 >> 2], c4[r5 + 28 >> 2] = e3, c4[r5 + 20 >> 2] = e3, 0 | a5;
        }, ra]);
        function ia() {
          return t4.byteLength / 65536 | 0;
        }
        return {
          E: function E4() {
            for (var r5 = 0, e3 = 0, a5 = 0; a5 = 5888 + (e3 = r5 << 4) | 0, c4[e3 + 5892 >> 2] = a5, c4[e3 + 5896 >> 2] = a5, 64 != (0 | (r5 = r5 + 1 | 0)); )
              ;
            vr2(48), c4[1736] = 16, c4[1737] = 0, tr2(), c4[1737] = c4[1748], c4[1748] = 6944, c4[1749] = 194, c4[1750] = 0, Gr2(), c4[1750] = c4[1748], c4[1748] = 6996;
          },
          F: function F3(r5) {
            r5 |= 0;
            var e3, a5, i4 = 0, n3 = 0, t5 = 0;
            ar3 = e3 = ar3 - 96 | 0, c4[e3 >> 2] = r5, ar3 = n3 = ar3 - 16 | 0, c4[n3 + 12 >> 2] = e3, ar3 = r5 = ar3 - 144 | 0, r5 = Ar2(r5, 5440, 144), i4 = a5 = e3 + 16 | 0, c4[r5 + 44 >> 2] = i4, c4[r5 + 20 >> 2] = i4, t5 = (t5 = -2 - i4 | 0) >>> 0 >= 2147483647 ? 2147483647 : t5, c4[r5 + 48 >> 2] = t5, i4 = i4 + t5 | 0, c4[r5 + 28 >> 2] = i4, c4[r5 + 16 >> 2] = i4, Zr2(r5, 2201, e3, 0, 0), t5 && (i4 = c4[r5 + 20 >> 2], f3[i4 - ((0 | i4) == c4[r5 + 16 >> 2]) | 0] = 0), ar3 = r5 + 144 | 0, ar3 = n3 + 16 | 0;
            r: {
              if (3 & (r5 = a5))
                for (; ; ) {
                  if (!v3[0 | r5])
                    break r;
                  if (!(3 & (r5 = r5 + 1 | 0)))
                    break;
                }
              for (; i4 = r5, r5 = r5 + 4 | 0, !((-1 ^ (n3 = c4[i4 >> 2])) & n3 - 16843009 & -2139062144); )
                ;
              for (; i4 = (r5 = i4) + 1 | 0, v3[0 | r5]; )
                ;
            }
            return r5 = (i4 = cr2(r5 = 1 + (r5 - a5 | 0) | 0)) ? Ar2(i4, a5, r5) : 0, ar3 = e3 + 96 | 0, 0 | r5;
          },
          G: function G4() {
            var r5 = 0;
            if (r5 = c4[1748])
              for (; aa[c4[r5 >> 2]](), r5 = c4[r5 + 4 >> 2]; )
                ;
          },
          H: cr2,
          I: aa,
          J: gr2,
          K: function K3(r5, e3, a5, i4, n3) {
            return e3 |= 0, a5 |= 0, i4 |= 0, n3 |= 0, 0 | aa[0 | (r5 |= 0)](e3, a5, i4, n3);
          }
        };
      }(r3);
    }(r2);
  }
  Object.assign(e, n), n = null, e.wasmBinary && (f = e.wasmBinary), e.noExitRuntime;
  var s2 = Error;
  f = [], "object" != typeof {} && X("no native wasm support detected");
  var A2, k, l2, d, v2, h2, p, m2, N, w = false;
  function y(r2, e2, a3) {
    a3 = e2 + a3;
    for (var i2 = ""; !(e2 >= a3); ) {
      var n2 = r2[e2++];
      if (!n2)
        break;
      if (128 & n2) {
        var t3 = 63 & r2[e2++];
        if (192 == (224 & n2))
          i2 += String.fromCharCode((31 & n2) << 6 | t3);
        else {
          var f2 = 63 & r2[e2++];
          65536 > (n2 = 224 == (240 & n2) ? (15 & n2) << 12 | t3 << 6 | f2 : (7 & n2) << 18 | t3 << 12 | f2 << 6 | 63 & r2[e2++]) ? i2 += String.fromCharCode(n2) : (n2 -= 65536, i2 += String.fromCharCode(55296 | n2 >> 10, 56320 | 1023 & n2));
        }
      } else
        i2 += String.fromCharCode(n2);
    }
    return i2;
  }
  function E2() {
    var r2 = A2.buffer;
    e.HEAP8 = k = new Int8Array(r2), e.HEAP16 = d = new Int16Array(r2), e.HEAP32 = h2 = new Int32Array(r2), e.HEAPU8 = l2 = new Uint8Array(r2), e.HEAPU16 = v2 = new Uint16Array(r2), e.HEAPU32 = p = new Uint32Array(r2), e.HEAPF32 = m2 = new Float32Array(r2), e.HEAPF64 = N = new Float64Array(r2);
  }
  var G2 = e.INITIAL_MEMORY || 16777216;
  65536 <= G2 || X("INITIAL_MEMORY should be larger than STACK_SIZE, was " + G2 + "! (STACK_SIZE=65536)"), A2 = e.wasmMemory ? e.wasmMemory : new function() {
    this.buffer = new ArrayBuffer(G2 / 65536 * 65536);
  }(), E2(), G2 = A2.buffer.byteLength;
  var R3, g3 = [], Z2 = [], W = [];
  function V2() {
    var r2 = e.preRun.shift();
    g3.unshift(r2);
  }
  var B, T2 = 0, I = null;
  function X(r2) {
    throw e.onAbort && e.onAbort(r2), c2(r2 = "Aborted(" + r2 + ")"), w = true, r2 = new s2(r2 + ". Build with -sASSERTIONS for more info."), i(r2), r2;
  }
  function O(r2) {
    return r2.startsWith("data:application/octet-stream;base64,");
  }
  if (!O(B = "yoga-asm.wasm")) {
    var L2 = B;
    B = e.locateFile ? e.locateFile(L2, t2) : t2 + L2;
  }
  function _(r2) {
    for (; 0 < r2.length; )
      r2.shift()(e);
  }
  function F(r2) {
    if (void 0 === r2)
      return "_unknown";
    var e2 = (r2 = r2.replace(/[^a-zA-Z0-9_]/g, "$")).charCodeAt(0);
    return 48 <= e2 && 57 >= e2 ? "_" + r2 : r2;
  }
  function C2(r2, e2) {
    return r2 = F(r2), function() {
      return e2.apply(this, arguments);
    };
  }
  var S2 = [{}, {
    value: void 0
  }, {
    value: null
  }, {
    value: true
  }, {
    value: false
  }], P = [];
  function Y(r2) {
    var e2 = Error, a3 = C2(r2, function(e3) {
      this.name = r2, this.message = e3, void 0 !== (e3 = Error(e3).stack) && (this.stack = this.toString() + "\n" + e3.replace(/^Error(:[^\n]*)?\n/, ""));
    });
    return a3.prototype = Object.create(e2.prototype), a3.prototype.constructor = a3, a3.prototype.toString = function() {
      return void 0 === this.message ? this.name : this.name + ": " + this.message;
    }, a3;
  }
  var U = void 0;
  function M2(r2) {
    throw new U(r2);
  }
  var H2 = function H3(r2) {
    return r2 || M2("Cannot use deleted val. handle = " + r2), S2[r2].value;
  }, Q2 = function Q3(r2) {
    switch (r2) {
      case void 0:
        return 1;
      case null:
        return 2;
      case true:
        return 3;
      case false:
        return 4;
      default:
        var e2 = P.length ? P.pop() : S2.length;
        return S2[e2] = {
          fa: 1,
          value: r2
        }, e2;
    }
  }, z2 = void 0, j = void 0;
  function _D(r2) {
    for (var e2 = ""; l2[r2]; )
      e2 += j[l2[r2++]];
    return e2;
  }
  var x = [];
  function J() {
    for (; x.length; ) {
      var r2 = x.pop();
      r2.L.Z = false, r2.delete();
    }
  }
  var K = void 0, _q = {};
  function $(r2, e2) {
    for (void 0 === e2 && M2("ptr should not be undefined"); r2.P; )
      e2 = r2.aa(e2), r2 = r2.P;
    return e2;
  }
  var er2 = {};
  function ar2(r2) {
    var e2 = _D(r2 = ee(r2));
    return ne(r2), e2;
  }
  function ir(r2, e2) {
    var a3 = er2[r2];
    return void 0 === a3 && M2(e2 + " has unknown type " + ar2(r2)), a3;
  }
  function nr() {
  }
  var tr = false;
  function fr(r2) {
    --r2.count.value, 0 === r2.count.value && (r2.S ? r2.T.V(r2.S) : r2.O.M.V(r2.N));
  }
  function or(r2, e2, a3) {
    return e2 === a3 ? r2 : void 0 === a3.P || null === (r2 = or(r2, e2, a3.P)) ? null : a3.ma(r2);
  }
  var cr = {}, ur = void 0;
  function br(r2) {
    throw new ur(r2);
  }
  function sr(r2, e2) {
    return e2.O && e2.N || br("makeClassHandle requires ptr and ptrType"), !!e2.T != !!e2.S && br("Both smartPtrType and smartPtr must be specified"), e2.count = {
      value: 1
    }, Ar(Object.create(r2, {
      L: {
        value: e2
      }
    }));
  }
  function Ar(r2) {
    return "undefined" == typeof FinalizationRegistry ? (Ar = function Ar2(r3) {
      return r3;
    }, r2) : (tr = new FinalizationRegistry(function(r3) {
      fr(r3.L);
    }), nr = function nr2(r3) {
      tr.unregister(r3);
    }, (Ar = function Ar2(r3) {
      var e2 = r3.L;
      return e2.S && tr.register(r3, {
        L: e2
      }, r3), r3;
    })(r2));
  }
  var kr = {};
  function lr(r2) {
    for (; r2.length; ) {
      var e2 = r2.pop();
      r2.pop()(e2);
    }
  }
  function dr(r2) {
    return this.fromWireType(h2[r2 >> 2]);
  }
  var vr = {}, hr = {};
  function pr(r2, e2, a3) {
    function i2(e3) {
      (e3 = a3(e3)).length !== r2.length && br("Mismatched type converter count");
      for (var i3 = 0; i3 < r2.length; ++i3)
        Nr(r2[i3], e3[i3]);
    }
    r2.forEach(function(r3) {
      hr[r3] = e2;
    });
    var n2 = Array(e2.length), t3 = [], f2 = 0;
    e2.forEach(function(r3, e3) {
      er2.hasOwnProperty(r3) ? n2[e3] = er2[r3] : (t3.push(r3), vr.hasOwnProperty(r3) || (vr[r3] = []), vr[r3].push(function() {
        n2[e3] = er2[r3], ++f2 === t3.length && i2(n2);
      }));
    }), 0 === t3.length && i2(n2);
  }
  function mr(r2) {
    switch (r2) {
      case 1:
        return 0;
      case 2:
        return 1;
      case 4:
        return 2;
      case 8:
        return 3;
      default:
        throw new TypeError("Unknown type size: " + r2);
    }
  }
  function Nr(r2, e2, a3) {
    if (a3 === void 0) {
      a3 = {};
    }
    if (!("argPackAdvance" in e2))
      throw new TypeError("registerType registeredInstance requires argPackAdvance");
    var i2 = e2.name;
    if (r2 || M2('type "' + i2 + '" must have a positive integer typeid pointer'), er2.hasOwnProperty(r2)) {
      if (a3.ta)
        return;
      M2("Cannot register type '" + i2 + "' twice");
    }
    er2[r2] = e2, delete hr[r2], vr.hasOwnProperty(r2) && (e2 = vr[r2], delete vr[r2], e2.forEach(function(r3) {
      return r3();
    }));
  }
  function wr(r2) {
    M2(r2.L.O.M.name + " instance already deleted");
  }
  function yr() {
  }
  function Er(r2, e2, a3) {
    if (void 0 === r2[e2].R) {
      var i2 = r2[e2];
      r2[e2] = function() {
        return r2[e2].R.hasOwnProperty(arguments.length) || M2("Function '" + a3 + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + r2[e2].R + ")!"), r2[e2].R[arguments.length].apply(this, arguments);
      }, r2[e2].R = [], r2[e2].R[i2.Y] = i2;
    }
  }
  function Gr(r2, e2, a3, i2, n2, t3, f2, o2) {
    this.name = r2, this.constructor = e2, this.W = a3, this.V = i2, this.P = n2, this.oa = t3, this.aa = f2, this.ma = o2, this.ia = [];
  }
  function Rr(r2, e2, a3) {
    for (; e2 !== a3; )
      e2.aa || M2("Expected null or instance of " + a3.name + ", got an instance of " + e2.name), r2 = e2.aa(r2), e2 = e2.P;
    return r2;
  }
  function gr(r2, e2) {
    return null === e2 ? (this.da && M2("null is not a valid " + this.name), 0) : (e2.L || M2('Cannot pass "' + _r(e2) + '" as a ' + this.name), e2.L.N || M2("Cannot pass deleted object as a pointer of type " + this.name), Rr(e2.L.N, e2.L.O.M, this.M));
  }
  function Zr(r2, e2) {
    if (null === e2) {
      if (this.da && M2("null is not a valid " + this.name), this.ca) {
        var a3 = this.ea();
        return null !== r2 && r2.push(this.V, a3), a3;
      }
      return 0;
    }
    if (e2.L || M2('Cannot pass "' + _r(e2) + '" as a ' + this.name), e2.L.N || M2("Cannot pass deleted object as a pointer of type " + this.name), !this.ba && e2.L.O.ba && M2("Cannot convert argument of type " + (e2.L.T ? e2.L.T.name : e2.L.O.name) + " to parameter type " + this.name), a3 = Rr(e2.L.N, e2.L.O.M, this.M), this.ca)
      switch (void 0 === e2.L.S && M2("Passing raw pointer to smart pointer is illegal"), this.Aa) {
        case 0:
          e2.L.T === this ? a3 = e2.L.S : M2("Cannot convert argument of type " + (e2.L.T ? e2.L.T.name : e2.L.O.name) + " to parameter type " + this.name);
          break;
        case 1:
          a3 = e2.L.S;
          break;
        case 2:
          if (e2.L.T === this)
            a3 = e2.L.S;
          else {
            var i2 = e2.clone();
            a3 = this.wa(a3, Q2(function() {
              i2.delete();
            })), null !== r2 && r2.push(this.V, a3);
          }
          break;
        default:
          M2("Unsupporting sharing policy");
      }
    return a3;
  }
  function Wr(r2, e2) {
    return null === e2 ? (this.da && M2("null is not a valid " + this.name), 0) : (e2.L || M2('Cannot pass "' + _r(e2) + '" as a ' + this.name), e2.L.N || M2("Cannot pass deleted object as a pointer of type " + this.name), e2.L.O.ba && M2("Cannot convert argument of type " + e2.L.O.name + " to parameter type " + this.name), Rr(e2.L.N, e2.L.O.M, this.M));
  }
  function Vr(r2, e2, a3, i2) {
    this.name = r2, this.M = e2, this.da = a3, this.ba = i2, this.ca = false, this.V = this.wa = this.ea = this.ja = this.Aa = this.va = void 0, void 0 !== e2.P ? this.toWireType = Zr : (this.toWireType = i2 ? gr : Wr, this.U = null);
  }
  function Br(r2, a3) {
    var i2 = (r2 = _D(r2)).includes("j") ? function(r3, a4) {
      var i3 = [];
      return function() {
        if (i3.length = 0, Object.assign(i3, arguments), r3.includes("j")) {
          var n2 = e["dynCall_" + r3];
          n2 = i3 && i3.length ? n2.apply(null, [a4].concat(i3)) : n2.call(null, a4);
        } else
          n2 = R3.get(a4).apply(null, i3);
        return n2;
      };
    }(r2, a3) : R3.get(a3);
    return "function" != typeof i2 && M2("unknown function pointer with signature " + r2 + ": " + a3), i2;
  }
  var Tr = void 0;
  function Ir(r2, e2) {
    var a3 = [], i2 = {};
    throw e2.forEach(function r3(e3) {
      i2[e3] || er2[e3] || (hr[e3] ? hr[e3].forEach(r3) : (a3.push(e3), i2[e3] = true));
    }), new Tr(r2 + ": " + a3.map(ar2).join([", "]));
  }
  function Xr(r2, e2, a3, i2, n2) {
    var t3 = e2.length;
    2 > t3 && M2("argTypes array size mismatch! Must at least get return value and 'this' types!");
    var f2 = null !== e2[1] && null !== a3, o2 = false;
    for (a3 = 1; a3 < e2.length; ++a3)
      if (null !== e2[a3] && void 0 === e2[a3].U) {
        o2 = true;
        break;
      }
    var c3 = "void" !== e2[0].name, u2 = t3 - 2, b2 = Array(u2), s3 = [], A3 = [];
    return function() {
      if (arguments.length !== u2 && M2("function " + r2 + " called with " + arguments.length + " arguments, expected " + u2 + " args!"), A3.length = 0, s3.length = f2 ? 2 : 1, s3[0] = n2, f2) {
        var a4 = e2[1].toWireType(A3, this);
        s3[1] = a4;
      }
      for (var t4 = 0; t4 < u2; ++t4)
        b2[t4] = e2[t4 + 2].toWireType(A3, arguments[t4]), s3.push(b2[t4]);
      if (t4 = i2.apply(null, s3), o2)
        lr(A3);
      else
        for (var k2 = f2 ? 1 : 2; k2 < e2.length; k2++) {
          var l3 = 1 === k2 ? a4 : b2[k2 - 2];
          null !== e2[k2].U && e2[k2].U(l3);
        }
      return c3 ? e2[0].fromWireType(t4) : void 0;
    };
  }
  function Or(r2, e2) {
    for (var a3 = [], i2 = 0; i2 < r2; i2++)
      a3.push(p[e2 + 4 * i2 >> 2]);
    return a3;
  }
  function Lr(r2) {
    4 < r2 && 0 == --S2[r2].fa && (S2[r2] = void 0, P.push(r2));
  }
  function _r(r2) {
    if (null === r2)
      return "null";
    var e2 = typeof r2;
    return "object" === e2 || "array" === e2 || "function" === e2 ? r2.toString() : "" + r2;
  }
  function Fr(r2, e2) {
    switch (e2) {
      case 2:
        return function(r3) {
          return this.fromWireType(m2[r3 >> 2]);
        };
      case 3:
        return function(r3) {
          return this.fromWireType(N[r3 >> 3]);
        };
      default:
        throw new TypeError("Unknown float type: " + r2);
    }
  }
  function Cr(r2, e2, a3) {
    switch (e2) {
      case 0:
        return a3 ? function(r3) {
          return k[r3];
        } : function(r3) {
          return l2[r3];
        };
      case 1:
        return a3 ? function(r3) {
          return d[r3 >> 1];
        } : function(r3) {
          return v2[r3 >> 1];
        };
      case 2:
        return a3 ? function(r3) {
          return h2[r3 >> 2];
        } : function(r3) {
          return p[r3 >> 2];
        };
      default:
        throw new TypeError("Unknown integer type: " + r2);
    }
  }
  function Sr(r2, e2) {
    for (var a3 = "", i2 = 0; !(i2 >= e2 / 2); ++i2) {
      var n2 = d[r2 + 2 * i2 >> 1];
      if (0 == n2)
        break;
      a3 += String.fromCharCode(n2);
    }
    return a3;
  }
  function Pr(r2, e2, a3) {
    if (void 0 === a3 && (a3 = 2147483647), 2 > a3)
      return 0;
    var i2 = e2;
    a3 = (a3 -= 2) < 2 * r2.length ? a3 / 2 : r2.length;
    for (var n2 = 0; n2 < a3; ++n2)
      d[e2 >> 1] = r2.charCodeAt(n2), e2 += 2;
    return d[e2 >> 1] = 0, e2 - i2;
  }
  function Yr(r2) {
    return 2 * r2.length;
  }
  function Ur(r2, e2) {
    for (var a3 = 0, i2 = ""; !(a3 >= e2 / 4); ) {
      var n2 = h2[r2 + 4 * a3 >> 2];
      if (0 == n2)
        break;
      ++a3, 65536 <= n2 ? (n2 -= 65536, i2 += String.fromCharCode(55296 | n2 >> 10, 56320 | 1023 & n2)) : i2 += String.fromCharCode(n2);
    }
    return i2;
  }
  function Mr(r2, e2, a3) {
    if (void 0 === a3 && (a3 = 2147483647), 4 > a3)
      return 0;
    var i2 = e2;
    a3 = i2 + a3 - 4;
    for (var n2 = 0; n2 < r2.length; ++n2) {
      var t3 = r2.charCodeAt(n2);
      if (55296 <= t3 && 57343 >= t3 && (t3 = 65536 + ((1023 & t3) << 10) | 1023 & r2.charCodeAt(++n2)), h2[e2 >> 2] = t3, (e2 += 4) + 4 > a3)
        break;
    }
    return h2[e2 >> 2] = 0, e2 - i2;
  }
  function Hr(r2) {
    for (var e2 = 0, a3 = 0; a3 < r2.length; ++a3) {
      var i2 = r2.charCodeAt(a3);
      55296 <= i2 && 57343 >= i2 && ++a3, e2 += 4;
    }
    return e2;
  }
  var Qr = {};
  function zr(r2) {
    var e2 = Qr[r2];
    return void 0 === e2 ? _D(r2) : e2;
  }
  var jr = [], Dr = [], xr = [null, [], []];
  U = e.BindingError = Y("BindingError"), e.count_emval_handles = function() {
    for (var r2 = 0, e2 = 5; e2 < S2.length; ++e2)
      void 0 !== S2[e2] && ++r2;
    return r2;
  }, e.get_first_emval = function() {
    for (var r2 = 5; r2 < S2.length; ++r2)
      if (void 0 !== S2[r2])
        return S2[r2];
    return null;
  }, z2 = e.PureVirtualError = Y("PureVirtualError");
  for (var Jr = Array(256), Kr = 0; 256 > Kr; ++Kr)
    Jr[Kr] = String.fromCharCode(Kr);
  j = Jr, e.getInheritedInstanceCount = function() {
    return Object.keys(_q).length;
  }, e.getLiveInheritedInstances = function() {
    var r2, e2 = [];
    for (r2 in _q)
      _q.hasOwnProperty(r2) && e2.push(_q[r2]);
    return e2;
  }, e.flushPendingDeletes = J, e.setDelayFunction = function(r2) {
    K = r2, x.length && K && K(J);
  }, ur = e.InternalError = Y("InternalError"), yr.prototype.isAliasOf = function(r2) {
    if (!(this instanceof yr && r2 instanceof yr))
      return false;
    var e2 = this.L.O.M, a3 = this.L.N, i2 = r2.L.O.M;
    for (r2 = r2.L.N; e2.P; )
      a3 = e2.aa(a3), e2 = e2.P;
    for (; i2.P; )
      r2 = i2.aa(r2), i2 = i2.P;
    return e2 === i2 && a3 === r2;
  }, yr.prototype.clone = function() {
    if (this.L.N || wr(this), this.L.$)
      return this.L.count.value += 1, this;
    var r2 = Ar, e2 = Object, a3 = e2.create, i2 = Object.getPrototypeOf(this), n2 = this.L;
    return (r2 = r2(a3.call(e2, i2, {
      L: {
        value: {
          count: n2.count,
          Z: n2.Z,
          $: n2.$,
          N: n2.N,
          O: n2.O,
          S: n2.S,
          T: n2.T
        }
      }
    }))).L.count.value += 1, r2.L.Z = false, r2;
  }, yr.prototype.delete = function() {
    this.L.N || wr(this), this.L.Z && !this.L.$ && M2("Object already scheduled for deletion"), nr(this), fr(this.L), this.L.$ || (this.L.S = void 0, this.L.N = void 0);
  }, yr.prototype.isDeleted = function() {
    return !this.L.N;
  }, yr.prototype.deleteLater = function() {
    return this.L.N || wr(this), this.L.Z && !this.L.$ && M2("Object already scheduled for deletion"), x.push(this), 1 === x.length && K && K(J), this.L.Z = true, this;
  }, Vr.prototype.pa = function(r2) {
    return this.ja && (r2 = this.ja(r2)), r2;
  }, Vr.prototype.ga = function(r2) {
    this.V && this.V(r2);
  }, Vr.prototype.argPackAdvance = 8, Vr.prototype.readValueFromPointer = dr, Vr.prototype.deleteObject = function(r2) {
    null !== r2 && r2.delete();
  }, Vr.prototype.fromWireType = function(r2) {
    function e2() {
      return this.ca ? sr(this.M.W, {
        O: this.va,
        N: a3,
        T: this,
        S: r2
      }) : sr(this.M.W, {
        O: this,
        N: r2
      });
    }
    var a3 = this.pa(r2);
    if (!a3)
      return this.ga(r2), null;
    var i2 = function(r3, e3) {
      return e3 = $(r3, e3), _q[e3];
    }(this.M, a3);
    if (void 0 !== i2)
      return 0 === i2.L.count.value ? (i2.L.N = a3, i2.L.S = r2, i2.clone()) : (i2 = i2.clone(), this.ga(r2), i2);
    if (i2 = this.M.oa(a3), !(i2 = cr[i2]))
      return e2.call(this);
    i2 = this.ba ? i2.ka : i2.pointerType;
    var n2 = or(a3, this.M, i2.M);
    return null === n2 ? e2.call(this) : this.ca ? sr(i2.M.W, {
      O: i2,
      N: n2,
      T: this,
      S: r2
    }) : sr(i2.M.W, {
      O: i2,
      N: n2
    });
  }, Tr = e.UnboundTypeError = Y("UnboundTypeError");
  var qr = "function" == typeof atob ? atob : function(r2) {
    var e2 = "", a3 = 0;
    r2 = r2.replace(/[^A-Za-z0-9\+\/=]/g, "");
    do {
      var i2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(r2.charAt(a3++)), n2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(r2.charAt(a3++)), t3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(r2.charAt(a3++)), f2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(r2.charAt(a3++));
      i2 = i2 << 2 | n2 >> 4, n2 = (15 & n2) << 4 | t3 >> 2;
      var o2 = (3 & t3) << 6 | f2;
      e2 += String.fromCharCode(i2), 64 !== t3 && (e2 += String.fromCharCode(n2)), 64 !== f2 && (e2 += String.fromCharCode(o2));
    } while (a3 < r2.length);
    return e2;
  }, $r = {
    q: function q2(r2, e2, a3) {
      r2 = _D(r2), e2 = ir(e2, "wrapper"), a3 = H2(a3);
      var i2 = [].slice, n2 = e2.M, t3 = n2.W, f2 = n2.P.W, o2 = n2.P.constructor;
      for (var c3 in r2 = C2(r2, function() {
        n2.P.ia.forEach((function(r3) {
          if (this[r3] === f2[r3])
            throw new z2("Pure virtual function " + r3 + " must be implemented in JavaScript");
        }).bind(this)), Object.defineProperty(this, "__parent", {
          value: t3
        }), this.__construct.apply(this, i2.call(arguments));
      }), t3.__construct = function() {
        this === t3 && M2("Pass correct 'this' to __construct");
        var r3 = o2.implement.apply(void 0, [this].concat(i2.call(arguments)));
        nr(r3);
        var e3 = r3.L;
        r3.notifyOnDestruction(), e3.$ = true, Object.defineProperties(this, {
          L: {
            value: e3
          }
        }), Ar(this), r3 = e3.N, r3 = $(n2, r3), _q.hasOwnProperty(r3) ? M2("Tried to register registered instance: " + r3) : _q[r3] = this;
      }, t3.__destruct = function() {
        this === t3 && M2("Pass correct 'this' to __destruct"), nr(this);
        var r3 = this.L.N;
        r3 = $(n2, r3), _q.hasOwnProperty(r3) ? delete _q[r3] : M2("Tried to unregister unregistered instance: " + r3);
      }, r2.prototype = Object.create(t3), a3)
        r2.prototype[c3] = a3[c3];
      return Q2(r2);
    },
    k: function k2(r2) {
      var e2 = kr[r2];
      delete kr[r2];
      var a3 = e2.ea, i2 = e2.V, n2 = e2.ha;
      pr([r2], n2.map(function(r3) {
        return r3.sa;
      }).concat(n2.map(function(r3) {
        return r3.ya;
      })), function(r3) {
        var t3 = {};
        return n2.forEach(function(e3, a4) {
          var i3 = r3[a4], f2 = e3.qa, o2 = e3.ra, c3 = r3[a4 + n2.length], u2 = e3.xa, b2 = e3.za;
          t3[e3.na] = {
            read: function read4(r4) {
              return i3.fromWireType(f2(o2, r4));
            },
            write: function write7(r4, e4) {
              var a5 = [];
              u2(b2, r4, c3.toWireType(a5, e4)), lr(a5);
            }
          };
        }), [{
          name: e2.name,
          fromWireType: function fromWireType(r4) {
            var e3, a4 = {};
            for (e3 in t3)
              a4[e3] = t3[e3].read(r4);
            return i2(r4), a4;
          },
          toWireType: function toWireType(r4, e3) {
            for (var n3 in t3)
              if (!(n3 in e3))
                throw new TypeError('Missing field:  "' + n3 + '"');
            var f2 = a3();
            for (n3 in t3)
              t3[n3].write(f2, e3[n3]);
            return null !== r4 && r4.push(i2, f2), f2;
          },
          argPackAdvance: 8,
          readValueFromPointer: dr,
          U: i2
        }];
      });
    },
    w: function w2() {
    },
    C: function C3(r2, e2, a3, i2, n2) {
      var t3 = mr(a3);
      Nr(r2, {
        name: e2 = _D(e2),
        fromWireType: function fromWireType(r3) {
          return !!r3;
        },
        toWireType: function toWireType(r3, e3) {
          return e3 ? i2 : n2;
        },
        argPackAdvance: 8,
        readValueFromPointer: function readValueFromPointer(r3) {
          if (1 === a3)
            var i3 = k;
          else if (2 === a3)
            i3 = d;
          else {
            if (4 !== a3)
              throw new TypeError("Unknown boolean type size: " + e2);
            i3 = h2;
          }
          return this.fromWireType(i3[r3 >> t3]);
        },
        U: null
      });
    },
    f: function f2(r2, a3, i2, n2, t3, _f, o2, c3, u2, b2, s3, A3, k2) {
      s3 = _D(s3), _f = Br(t3, _f), c3 && (c3 = Br(o2, c3)), b2 && (b2 = Br(u2, b2)), k2 = Br(A3, k2);
      var l3 = F(s3);
      !function(r3, a4) {
        e.hasOwnProperty(r3) ? (M2("Cannot register public name '" + r3 + "' twice"), Er(e, r3, r3), e.hasOwnProperty(void 0) && M2("Cannot register multiple overloads of a function with the same number of arguments (undefined)!"), e[r3].R[void 0] = a4) : e[r3] = a4;
      }(l3, function() {
        Ir("Cannot construct " + s3 + " due to unbound types", [n2]);
      }), pr([r2, a3, i2], n2 ? [n2] : [], function(a4) {
        if (a4 = a4[0], n2)
          var i3 = a4.M, t4 = i3.W;
        else
          t4 = yr.prototype;
        a4 = C2(l3, function() {
          if (Object.getPrototypeOf(this) !== o3)
            throw new U("Use 'new' to construct " + s3);
          if (void 0 === u3.X)
            throw new U(s3 + " has no accessible constructor");
          var r3 = u3.X[arguments.length];
          if (void 0 === r3)
            throw new U("Tried to invoke ctor of " + s3 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(u3.X).toString() + ") parameters instead!");
          return r3.apply(this, arguments);
        });
        var o3 = Object.create(t4, {
          constructor: {
            value: a4
          }
        });
        a4.prototype = o3;
        var u3 = new Gr(s3, a4, o3, k2, i3, _f, c3, b2);
        i3 = new Vr(s3, u3, true, false), t4 = new Vr(s3 + "*", u3, false, false);
        var A4 = new Vr(s3 + " const*", u3, false, true);
        return cr[r2] = {
          pointerType: t4,
          ka: A4
        }, function(r3, a5) {
          e.hasOwnProperty(r3) || br("Replacing nonexistant public symbol"), e[r3] = a5, e[r3].Y = void 0;
        }(l3, a4), [i3, t4, A4];
      });
    },
    d: function d2(r2, e2, a3, i2, n2, t3, f2) {
      var o2 = Or(a3, i2);
      e2 = _D(e2), t3 = Br(n2, t3), pr([], [r2], function(r3) {
        function i3() {
          Ir("Cannot call " + n3 + " due to unbound types", o2);
        }
        var n3 = (r3 = r3[0]).name + "." + e2;
        e2.startsWith("@@") && (e2 = Symbol[e2.substring(2)]);
        var c3 = r3.M.constructor;
        return void 0 === c3[e2] ? (i3.Y = a3 - 1, c3[e2] = i3) : (Er(c3, e2, n3), c3[e2].R[a3 - 1] = i3), pr([], o2, function(r4) {
          return r4 = Xr(n3, [r4[0], null].concat(r4.slice(1)), null, t3, f2), void 0 === c3[e2].R ? (r4.Y = a3 - 1, c3[e2] = r4) : c3[e2].R[a3 - 1] = r4, [];
        }), [];
      });
    },
    p: function p2(r2, e2, a3, i2, n2, t3) {
      0 < e2 || X();
      var f2 = Or(e2, a3);
      n2 = Br(i2, n2), pr([], [r2], function(r3) {
        var a4 = "constructor " + (r3 = r3[0]).name;
        if (void 0 === r3.M.X && (r3.M.X = []), void 0 !== r3.M.X[e2 - 1])
          throw new U("Cannot register multiple constructors with identical number of parameters (" + (e2 - 1) + ") for class '" + r3.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
        return r3.M.X[e2 - 1] = function() {
          Ir("Cannot construct " + r3.name + " due to unbound types", f2);
        }, pr([], f2, function(i3) {
          return i3.splice(1, 0, null), r3.M.X[e2 - 1] = Xr(a4, i3, null, n2, t3), [];
        }), [];
      });
    },
    b: function b2(r2, e2, a3, i2, n2, t3, f2, o2) {
      var c3 = Or(a3, i2);
      e2 = _D(e2), t3 = Br(n2, t3), pr([], [r2], function(r3) {
        function i3() {
          Ir("Cannot call " + n3 + " due to unbound types", c3);
        }
        var n3 = (r3 = r3[0]).name + "." + e2;
        e2.startsWith("@@") && (e2 = Symbol[e2.substring(2)]), o2 && r3.M.ia.push(e2);
        var u2 = r3.M.W, b3 = u2[e2];
        return void 0 === b3 || void 0 === b3.R && b3.className !== r3.name && b3.Y === a3 - 2 ? (i3.Y = a3 - 2, i3.className = r3.name, u2[e2] = i3) : (Er(u2, e2, n3), u2[e2].R[a3 - 2] = i3), pr([], c3, function(i4) {
          return i4 = Xr(n3, i4, r3, t3, f2), void 0 === u2[e2].R ? (i4.Y = a3 - 2, u2[e2] = i4) : u2[e2].R[a3 - 2] = i4, [];
        }), [];
      });
    },
    B: function B2(r2, e2) {
      Nr(r2, {
        name: e2 = _D(e2),
        fromWireType: function fromWireType(r3) {
          var e3 = H2(r3);
          return Lr(r3), e3;
        },
        toWireType: function toWireType(r3, e3) {
          return Q2(e3);
        },
        argPackAdvance: 8,
        readValueFromPointer: dr,
        U: null
      });
    },
    n: function n2(r2, e2, a3) {
      a3 = mr(a3), Nr(r2, {
        name: e2 = _D(e2),
        fromWireType: function fromWireType(r3) {
          return r3;
        },
        toWireType: function toWireType(r3, e3) {
          return e3;
        },
        argPackAdvance: 8,
        readValueFromPointer: Fr(e2, a3),
        U: null
      });
    },
    e: function e2(r2, _e2, a3, i2, n2) {
      _e2 = _D(_e2), -1 === n2 && (n2 = 4294967295), n2 = mr(a3);
      var t3 = function t4(r3) {
        return r3;
      };
      if (0 === i2) {
        var f2 = 32 - 8 * a3;
        t3 = function t4(r3) {
          return r3 << f2 >>> f2;
        };
      }
      a3 = _e2.includes("unsigned") ? function(r3, e3) {
        return e3 >>> 0;
      } : function(r3, e3) {
        return e3;
      }, Nr(r2, {
        name: _e2,
        fromWireType: t3,
        toWireType: a3,
        argPackAdvance: 8,
        readValueFromPointer: Cr(_e2, n2, 0 !== i2),
        U: null
      });
    },
    c: function c3(r2, e2, a3) {
      function i2(r3) {
        r3 >>= 2;
        var e3 = p;
        return new n2(e3.buffer, e3[r3 + 1], e3[r3]);
      }
      var n2 = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][e2];
      Nr(r2, {
        name: a3 = _D(a3),
        fromWireType: i2,
        argPackAdvance: 8,
        readValueFromPointer: i2
      }, {
        ta: true
      });
    },
    o: function o2(r2, e2) {
      var a3 = "std::string" === (e2 = _D(e2));
      Nr(r2, {
        name: e2,
        fromWireType: function fromWireType(r3) {
          var e3 = p[r3 >> 2], i2 = r3 + 4;
          if (a3)
            for (var n2 = i2, t3 = 0; t3 <= e3; ++t3) {
              var f2 = i2 + t3;
              if (t3 == e3 || 0 == l2[f2]) {
                if (n2 = n2 ? y(l2, n2, f2 - n2) : "", void 0 === o3)
                  var o3 = n2;
                else
                  o3 += String.fromCharCode(0), o3 += n2;
                n2 = f2 + 1;
              }
            }
          else {
            for (o3 = Array(e3), t3 = 0; t3 < e3; ++t3)
              o3[t3] = String.fromCharCode(l2[i2 + t3]);
            o3 = o3.join("");
          }
          return ne(r3), o3;
        },
        toWireType: function toWireType(r3, e3) {
          e3 instanceof ArrayBuffer && (e3 = new Uint8Array(e3));
          var i2, n2 = "string" == typeof e3;
          if (n2 || e3 instanceof Uint8Array || e3 instanceof Uint8ClampedArray || e3 instanceof Int8Array || M2("Cannot pass non-string to std::string"), a3 && n2) {
            var t3 = 0;
            for (i2 = 0; i2 < e3.length; ++i2) {
              var f2 = e3.charCodeAt(i2);
              127 >= f2 ? t3++ : 2047 >= f2 ? t3 += 2 : 55296 <= f2 && 57343 >= f2 ? (t3 += 4, ++i2) : t3 += 3;
            }
            i2 = t3;
          } else
            i2 = e3.length;
          if (f2 = (t3 = ie(4 + i2 + 1)) + 4, p[t3 >> 2] = i2, a3 && n2) {
            if (n2 = f2, f2 = i2 + 1, i2 = l2, 0 < f2) {
              f2 = n2 + f2 - 1;
              for (var o3 = 0; o3 < e3.length; ++o3) {
                var c3 = e3.charCodeAt(o3);
                if (55296 <= c3 && 57343 >= c3 && (c3 = 65536 + ((1023 & c3) << 10) | 1023 & e3.charCodeAt(++o3)), 127 >= c3) {
                  if (n2 >= f2)
                    break;
                  i2[n2++] = c3;
                } else {
                  if (2047 >= c3) {
                    if (n2 + 1 >= f2)
                      break;
                    i2[n2++] = 192 | c3 >> 6;
                  } else {
                    if (65535 >= c3) {
                      if (n2 + 2 >= f2)
                        break;
                      i2[n2++] = 224 | c3 >> 12;
                    } else {
                      if (n2 + 3 >= f2)
                        break;
                      i2[n2++] = 240 | c3 >> 18, i2[n2++] = 128 | c3 >> 12 & 63;
                    }
                    i2[n2++] = 128 | c3 >> 6 & 63;
                  }
                  i2[n2++] = 128 | 63 & c3;
                }
              }
              i2[n2] = 0;
            }
          } else if (n2)
            for (n2 = 0; n2 < i2; ++n2)
              255 < (o3 = e3.charCodeAt(n2)) && (ne(f2), M2("String has UTF-16 code units that do not fit in 8 bits")), l2[f2 + n2] = o3;
          else
            for (n2 = 0; n2 < i2; ++n2)
              l2[f2 + n2] = e3[n2];
          return null !== r3 && r3.push(ne, t3), t3;
        },
        argPackAdvance: 8,
        readValueFromPointer: dr,
        U: function U2(r3) {
          ne(r3);
        }
      });
    },
    j: function j2(r2, e2, a3) {
      if (a3 = _D(a3), 2 === e2)
        var i2 = Sr, n2 = Pr, t3 = Yr, f2 = function f3() {
          return v2;
        }, o2 = 1;
      else
        4 === e2 && (i2 = Ur, n2 = Mr, t3 = Hr, f2 = function f3() {
          return p;
        }, o2 = 2);
      Nr(r2, {
        name: a3,
        fromWireType: function fromWireType(r3) {
          for (var a4, n3 = p[r3 >> 2], t4 = f2(), c3 = r3 + 4, u2 = 0; u2 <= n3; ++u2) {
            var b2 = r3 + 4 + u2 * e2;
            u2 != n3 && 0 != t4[b2 >> o2] || (c3 = i2(c3, b2 - c3), void 0 === a4 ? a4 = c3 : (a4 += String.fromCharCode(0), a4 += c3), c3 = b2 + e2);
          }
          return ne(r3), a4;
        },
        toWireType: function toWireType(r3, i3) {
          "string" != typeof i3 && M2("Cannot pass non-string to C++ string type " + a3);
          var f3 = t3(i3), c3 = ie(4 + f3 + e2);
          return p[c3 >> 2] = f3 >> o2, n2(i3, c3 + 4, f3 + e2), null !== r3 && r3.push(ne, c3), c3;
        },
        argPackAdvance: 8,
        readValueFromPointer: dr,
        U: function U2(r3) {
          ne(r3);
        }
      });
    },
    l: function l3(r2, e2, a3, i2, n2, t3) {
      kr[r2] = {
        name: _D(e2),
        ea: Br(a3, i2),
        V: Br(n2, t3),
        ha: []
      };
    },
    i: function i2(r2, e2, a3, _i, n2, t3, f2, o2, c3, u2) {
      kr[r2].ha.push({
        na: _D(e2),
        sa: a3,
        qa: Br(_i, n2),
        ra: t3,
        ya: f2,
        xa: Br(o2, c3),
        za: u2
      });
    },
    D: function D(r2, e2) {
      Nr(r2, {
        ua: true,
        name: e2 = _D(e2),
        argPackAdvance: 0,
        fromWireType: function fromWireType() {
        },
        toWireType: function toWireType() {
        }
      });
    },
    t: function t3(r2, e2, a3, i2, n2) {
      r2 = jr[r2], e2 = H2(e2), a3 = zr(a3);
      var t4 = [];
      return p[i2 >> 2] = Q2(t4), r2(e2, a3, t4, n2);
    },
    u: function u2(r2, e2, a3, i2) {
      (r2 = jr[r2])(e2 = H2(e2), a3 = zr(a3), null, i2);
    },
    h: Lr,
    m: function m3(r2, e2) {
      var a3 = function(r3, e3) {
        for (var a4 = Array(r3), i3 = 0; i3 < r3; ++i3)
          a4[i3] = ir(p[e3 + 4 * i3 >> 2], "parameter " + i3);
        return a4;
      }(r2, e2), i2 = a3[0];
      e2 = i2.name + "_$" + a3.slice(1).map(function(r3) {
        return r3.name;
      }).join("_") + "$";
      var n2 = Dr[e2];
      if (void 0 !== n2)
        return n2;
      var t3 = Array(r2 - 1);
      return n2 = function(r3) {
        var e3 = jr.length;
        return jr.push(r3), e3;
      }(function(e3, n3, f2, o2) {
        for (var c3 = 0, u2 = 0; u2 < r2 - 1; ++u2)
          t3[u2] = a3[u2 + 1].readValueFromPointer(o2 + c3), c3 += a3[u2 + 1].argPackAdvance;
        for (e3 = e3[n3].apply(e3, t3), u2 = 0; u2 < r2 - 1; ++u2)
          a3[u2 + 1].la && a3[u2 + 1].la(t3[u2]);
        if (!i2.ua)
          return i2.toWireType(f2, e3);
      }), Dr[e2] = n2;
    },
    r: function r2(_r2) {
      4 < _r2 && (S2[_r2].fa += 1);
    },
    s: function s3(r2) {
      lr(H2(r2)), Lr(r2);
    },
    g: function g4() {
      X("");
    },
    y: function y2(r2, e2, a3) {
      l2.copyWithin(r2, e2, e2 + a3);
    },
    x: function x2(r2) {
      var e2 = l2.length;
      if (2147483648 < (r2 >>>= 0))
        return false;
      for (var a3 = 1; 4 >= a3; a3 *= 2) {
        var i2 = e2 * (1 + 0.2 / a3);
        i2 = Math.min(i2, r2 + 100663296);
        var n2 = Math, t3 = n2.min;
        i2 = Math.max(r2, i2), i2 += (65536 - i2 % 65536) % 65536;
        r: {
          var f2 = A2.buffer;
          try {
            A2.grow(t3.call(n2, 2147483648, i2) - f2.byteLength + 65535 >>> 16), E2();
            var o2 = 1;
            break r;
          } catch (r3) {
          }
          o2 = void 0;
        }
        if (o2)
          return true;
      }
      return false;
    },
    A: function A3() {
      return 52;
    },
    v: function v3() {
      return 70;
    },
    z: function z3(r2, e2, a3, i2) {
      for (var n2 = 0, t3 = 0; t3 < a3; t3++) {
        var f2 = p[e2 >> 2], u2 = p[e2 + 4 >> 2];
        e2 += 8;
        for (var b2 = 0; b2 < u2; b2++) {
          var s3 = l2[f2 + b2], A3 = xr[r2];
          0 === s3 || 10 === s3 ? ((1 === r2 ? o : c2)(y(A3, 0)), A3.length = 0) : A3.push(s3);
        }
        n2 += u2;
      }
      return p[i2 >> 2] = n2, 0;
    },
    a: A2
  }, re = function() {
    function r2(r3) {
      e.asm = r3.exports, R3 = e.asm.I, Z2.unshift(e.asm.E), T2--, e.monitorRunDependencies && e.monitorRunDependencies(T2), 0 == T2 && I && (r3 = I, I = null, r3());
    }
    var a3 = {
      a: $r
    };
    if (T2++, e.monitorRunDependencies && e.monitorRunDependencies(T2), e.instantiateWasm)
      try {
        return e.instantiateWasm(a3, r2);
      } catch (r3) {
        c2("Module.instantiateWasm callback failed with error: " + r3), i(r3);
      }
    return a3 = function(r3) {
      var e2 = B;
      try {
        try {
          if (e2 == B && f)
            new Uint8Array(f);
          else {
            if (O(e2)) {
              try {
                var a4 = qr(e2.slice(37)), i2 = new Uint8Array(a4.length);
                for (e2 = 0; e2 < a4.length; ++e2)
                  i2[e2] = a4.charCodeAt(e2);
                var n2 = i2;
              } catch (r4) {
                throw Error("Converting base64 string to bytes failed.");
              }
              var t3 = n2;
            } else
              t3 = void 0;
            if (!t3)
              throw "sync fetching of the wasm failed: you can preload it to Module['wasmBinary'] manually, or emcc.py will do that for you when generating HTML (but not JS)";
          }
        } catch (r4) {
          X(r4);
        }
        var o2 = new u(), s3 = new b(r3);
      } catch (e3) {
        throw r3 = e3.toString(), c2("failed to compile wasm module: " + r3), (r3.includes("imported Memory") || r3.includes("memory import")) && c2("Memory size incompatibility issues may be due to changing INITIAL_MEMORY at runtime to something too large. Use ALLOW_MEMORY_GROWTH to allow any size memory (and also make sure not to set INITIAL_MEMORY at runtime to something smaller than it was at compile time)."), e3;
      }
      return [s3, o2];
    }(a3), r2(a3[0]), e.asm;
  }(), ee = e.___getTypeName = re.F;
  e.__embind_initialize_bindings = re.G;
  var ae, ie = re.H, ne = re.J;
  function te() {
    function r2() {
      if (!ae && (ae = true, e.calledRun = true, !w)) {
        if (_(Z2), a2(e), e.onRuntimeInitialized && e.onRuntimeInitialized(), e.postRun)
          for ("function" == typeof e.postRun && (e.postRun = [e.postRun]); e.postRun.length; ) {
            var r3 = e.postRun.shift();
            W.unshift(r3);
          }
        _(W);
      }
    }
    if (!(0 < T2)) {
      if (e.preRun)
        for ("function" == typeof e.preRun && (e.preRun = [e.preRun]); e.preRun.length; )
          V2();
      _(g3), 0 < T2 || (e.setStatus ? (e.setStatus("Running..."), setTimeout(function() {
        setTimeout(function() {
          e.setStatus("");
        }, 1), r2();
      }, 1)) : r2());
    }
  }
  if (e.dynCall_jiji = re.K, I = function r2() {
    ae || te(), ae || (I = r2);
  }, e.preInit)
    for ("function" == typeof e.preInit && (e.preInit = [e.preInit]); 0 < e.preInit.length; )
      e.preInit.pop()();
  return te(), r;
});
function ar() {
  return AE(er());
}
var index = ar();

// ../node_modules/@react-pdf/layout/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose3(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}

// ../node_modules/@react-pdf/layout/lib/index.es.js
var fromFragments3 = function fromFragments4(fragments) {
  var offset3 = 0;
  var string = "";
  var runs = [];
  fragments.forEach(function(fragment) {
    string += fragment.string;
    runs.push({
      start: offset3,
      end: offset3 + fragment.string.length,
      attributes: fragment.attributes || {}
    });
    offset3 += fragment.string.length;
  });
  return {
    string,
    runs
  };
};
var transformText = function transformText2(text2, transformation) {
  switch (transformation) {
    case "uppercase":
      return text2.toUpperCase();
    case "lowercase":
      return text2.toLowerCase();
    case "capitalize":
      return capitalize(text2);
    case "upperfirst":
      return upperFirst(text2);
    default:
      return text2;
  }
};
var StandardFont2 = function() {
  function StandardFont3(src3) {
    this.name = src3;
    this.src = PDFFont.open(null, src3);
  }
  var _proto = StandardFont3.prototype;
  _proto.encode = function encode(str) {
    return this.src.encode(str);
  };
  _proto.layout = function layout2(str) {
    var _this = this;
    var _this$encode = this.encode(str), encoded = _this$encode[0], positions = _this$encode[1];
    return {
      positions,
      stringIndices: positions.map(function(_, i) {
        return i;
      }),
      glyphs: encoded.map(function(g3, i) {
        var glyph = _this.getGlyph(parseInt(g3, 16));
        glyph.advanceWidth = positions[i].advanceWidth;
        return glyph;
      })
    };
  };
  _proto.glyphForCodePoint = function glyphForCodePoint(codePoint) {
    var glyph = this.getGlyph(codePoint);
    glyph.advanceWidth = 400;
    return glyph;
  };
  _proto.getGlyph = function getGlyph(id) {
    return {
      id,
      _font: this.src,
      codePoints: [id],
      isLigature: false,
      name: this.src.font.characterToGlyph(id)
    };
  };
  _proto.hasGlyphForCodePoint = function hasGlyphForCodePoint(codePoint) {
    return this.src.font.characterToGlyph(codePoint) !== ".notdef";
  };
  _createClass4(StandardFont3, [{
    key: "ascent",
    get: function get18() {
      return 900;
    }
    // Based on empirical observation
  }, {
    key: "capHeight",
    get: function get18() {
      switch (this.name) {
        case "Times-Roman":
        case "Times-Bold":
        case "Times-Italic":
        case "Times-BoldItalic":
          return 650;
        case "Courier":
        case "Courier-Bold":
        case "Courier-Oblique":
        case "Courier-BoldOblique":
          return 550;
        default:
          return 690;
      }
    }
    // Based on empirical observation
  }, {
    key: "xHeight",
    get: function get18() {
      switch (this.name) {
        case "Times-Roman":
        case "Times-Bold":
        case "Times-Italic":
        case "Times-BoldItalic":
          return 440;
        case "Courier":
        case "Courier-Bold":
        case "Courier-Oblique":
        case "Courier-BoldOblique":
          return 390;
        default:
          return 490;
      }
    }
    // Based on empirical observation
  }, {
    key: "descent",
    get: function get18() {
      switch (this.name) {
        case "Times-Roman":
        case "Times-Bold":
        case "Times-Italic":
        case "Times-BoldItalic":
          return -220;
        case "Courier":
        case "Courier-Bold":
        case "Courier-Oblique":
        case "Courier-BoldOblique":
          return -230;
        default:
          return -200;
      }
    }
  }, {
    key: "lineGap",
    get: function get18() {
      return 0;
    }
  }, {
    key: "unitsPerEm",
    get: function get18() {
      return 1e3;
    }
  }]);
  return StandardFont3;
}();
var fontCache = {};
var IGNORED_CODE_POINTS = [173];
var getFontSize = function getFontSize2(node) {
  return node.attributes.fontSize || 12;
};
var getOrCreateFont = function getOrCreateFont2(name) {
  if (fontCache[name])
    return fontCache[name];
  var font2 = new StandardFont2(name);
  fontCache[name] = font2;
  return font2;
};
var getFallbackFont = function getFallbackFont2() {
  return getOrCreateFont("Helvetica");
};
var shouldFallbackToFont = function shouldFallbackToFont2(codePoint, font2) {
  return !font2 || !IGNORED_CODE_POINTS.includes(codePoint) && !font2.hasGlyphForCodePoint(codePoint) && getFallbackFont().hasGlyphForCodePoint(codePoint);
};
var fontSubstitution = function fontSubstitution2() {
  return function(_ref) {
    var string = _ref.string, runs = _ref.runs;
    var lastFont = null;
    var lastFontSize = null;
    var lastIndex = 0;
    var index3 = 0;
    var res = [];
    for (var i = 0; i < runs.length; i += 1) {
      var run = runs[i];
      var defaultFont = typeof run.attributes.font === "string" ? getOrCreateFont(run.attributes.font) : run.attributes.font;
      if (string.length === 0) {
        res.push({
          start: 0,
          end: 0,
          attributes: {
            font: defaultFont
          }
        });
        break;
      }
      var chars = string.slice(run.start, run.end);
      for (var j = 0; j < chars.length; j += 1) {
        var char = chars[j];
        var codePoint = char.codePointAt();
        var shouldFallback = shouldFallbackToFont(codePoint, defaultFont);
        var font2 = shouldFallback ? getFallbackFont() : defaultFont;
        var fontSize2 = getFontSize(run);
        if (font2 !== lastFont || fontSize2 !== lastFontSize || font2.unitsPerEm !== lastFont.unitsPerEm) {
          if (lastFont) {
            res.push({
              start: lastIndex,
              end: index3,
              attributes: {
                font: lastFont,
                scale: lastFontSize / lastFont.unitsPerEm
              }
            });
          }
          lastFont = font2;
          lastFontSize = fontSize2;
          lastIndex = index3;
        }
        index3 += char.length;
      }
    }
    if (lastIndex < string.length) {
      var _fontSize = getFontSize(last(runs));
      res.push({
        start: lastIndex,
        end: string.length,
        attributes: {
          font: lastFont,
          scale: _fontSize / lastFont.unitsPerEm
        }
      });
    }
    return {
      string,
      runs: res
    };
  };
};
var isTextInstance$4 = function isTextInstance(node) {
  return node.type === TextInstance;
};
var engines$1 = {
  linebreaker,
  justification,
  textDecoration,
  scriptItemizer,
  wordHyphenation,
  fontSubstitution
};
var engine$1 = layoutEngine(engines$1);
var getFragments$1 = function getFragments(fontStore2, instance) {
  if (!instance)
    return [{
      string: ""
    }];
  var fragments = [];
  var _instance$props = instance.props, _instance$props$fill = _instance$props.fill, fill5 = _instance$props$fill === void 0 ? "black" : _instance$props$fill, _instance$props$fontF = _instance$props.fontFamily, fontFamily = _instance$props$fontF === void 0 ? "Helvetica" : _instance$props$fontF, fontWeight = _instance$props.fontWeight, fontStyle = _instance$props.fontStyle, _instance$props$fontS = _instance$props.fontSize, fontSize2 = _instance$props$fontS === void 0 ? 18 : _instance$props$fontS, textDecorationColor = _instance$props.textDecorationColor, textDecorationStyle = _instance$props.textDecorationStyle, textTransform = _instance$props.textTransform, opacity2 = _instance$props.opacity;
  var _textDecoration = instance.props.textDecoration;
  var obj = fontStore2 ? fontStore2.getFont({
    fontFamily,
    fontWeight,
    fontStyle
  }) : null;
  var font2 = obj ? obj.data : fontFamily;
  var attributes2 = {
    font: font2,
    opacity: opacity2,
    fontSize: fontSize2,
    color: fill5,
    underlineStyle: textDecorationStyle,
    underline: _textDecoration === "underline" || _textDecoration === "underline line-through" || _textDecoration === "line-through underline",
    underlineColor: textDecorationColor || fill5,
    strike: _textDecoration === "line-through" || _textDecoration === "underline line-through" || _textDecoration === "line-through underline",
    strikeStyle: textDecorationStyle,
    strikeColor: textDecorationColor || fill5
  };
  for (var i = 0; i < instance.children.length; i += 1) {
    var child = instance.children[i];
    if (isTextInstance$4(child)) {
      fragments.push({
        string: transformText(child.value, textTransform),
        attributes: attributes2
      });
    } else if (child) {
      fragments.push.apply(fragments, getFragments(child));
    }
  }
  return fragments;
};
var getAttributedString$1 = function getAttributedString(fontStore2, instance) {
  return fromFragments3(getFragments$1(fontStore2, instance));
};
var AlmostInfinity = 999999999999;
var shrinkWhitespaceFactor = {
  before: -0.5,
  after: -0.5
};
var layoutTspan = function layoutTspan2(fontStore2) {
  return function(node) {
    var _node$props, _node$props2;
    var attributedString = getAttributedString$1(fontStore2, node);
    var x = ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.x) || 0;
    var y = ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.y) || 0;
    var container = {
      x,
      y,
      width: AlmostInfinity,
      height: AlmostInfinity
    };
    var hyphenationCallback = node.props.hyphenationCallback || (fontStore2 === null || fontStore2 === void 0 ? void 0 : fontStore2.getHyphenationCallback()) || null;
    var layoutOptions = {
      hyphenationCallback,
      shrinkWhitespaceFactor
    };
    var lines = engine$1(attributedString, container, layoutOptions).flat();
    return Object.assign({}, node, {
      lines
    });
  };
};
var layoutText$1 = function layoutText(fontStore2, node) {
  if (!node.children)
    return node;
  var children = node.children.map(layoutTspan(fontStore2));
  return Object.assign({}, node, {
    children
  });
};
var isDefs = function isDefs2(node) {
  return node.type === Defs;
};
var getDefs = function getDefs2(node) {
  var children = node.children || [];
  var defs = children.find(isDefs) || {};
  var values = defs.children || [];
  return values.reduce(function(acc, value2) {
    var _value$props;
    var id = (_value$props = value2.props) === null || _value$props === void 0 ? void 0 : _value$props.id;
    if (id)
      acc[id] = value2;
    return acc;
  }, {});
};
var isNotDefs = function isNotDefs2(node) {
  return node.type !== Defs;
};
var detachDefs = function detachDefs2(node) {
  if (!node.children)
    return node;
  var children = node.children.filter(isNotDefs);
  return Object.assign({}, node, {
    children
  });
};
var URL_REGEX = /url\(['"]?#([^'"]+)['"]?\)/;
var replaceDef = function replaceDef2(defs, value2) {
  if (!value2)
    return void 0;
  if (!URL_REGEX.test(value2))
    return value2;
  var match = value2.match(URL_REGEX);
  return defs[match[1]];
};
var parseNodeDefs = function parseNodeDefs2(defs) {
  return function(node) {
    var _node$props, _node$props2;
    var fill5 = replaceDef(defs, (_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.fill);
    var clipPath3 = replaceDef(defs, (_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.clipPath);
    var props = Object.assign({}, node.props, {
      fill: fill5,
      clipPath: clipPath3
    });
    var children = node.children ? node.children.map(parseNodeDefs2(defs)) : void 0;
    return Object.assign({}, node, {
      props,
      children
    });
  };
};
var parseDefs = function parseDefs2(root) {
  if (!root.children)
    return root;
  var defs = getDefs(root);
  var children = root.children.map(parseNodeDefs(defs));
  return Object.assign({}, root, {
    children
  });
};
var replaceDefs = function replaceDefs2(node) {
  return detachDefs(parseDefs(node));
};
var parseViewbox = function parseViewbox2(value2) {
  if (!value2)
    return null;
  var values = value2.split(/[,\s]+/).map(parseFloat);
  if (values.length !== 4)
    return null;
  return {
    minX: values[0],
    minY: values[1],
    maxX: values[2],
    maxY: values[3]
  };
};
var getContainer$1 = function getContainer(node) {
  var viewbox = parseViewbox(node.props.viewBox);
  if (viewbox) {
    return {
      width: viewbox.maxX,
      height: viewbox.maxY
    };
  }
  if (node.props.width && node.props.height) {
    return {
      width: parseFloat(node.props.width),
      height: parseFloat(node.props.height)
    };
  }
  return {
    width: 0,
    height: 0
  };
};
var SVG_INHERITED_PROPS = ["x", "y", "clipPath", "clipRule", "opacity", "fill", "fillOpacity", "fillRule", "stroke", "strokeLinecap", "strokeLinejoin", "strokeOpacity", "strokeWidth", "textAnchor", "dominantBaseline", "color", "fontFamily", "fontSize", "fontStyle", "fontWeight", "letterSpacing", "opacity", "textDecoration", "lineHeight", "textAlign", "visibility", "wordSpacing"];
var getInheritProps = function getInheritProps2(node) {
  var props = node.props || {};
  return pick(SVG_INHERITED_PROPS, props);
};
var inheritProps = function inheritProps2(node) {
  if (!node.children)
    return node;
  var inheritedProps = getInheritProps(node);
  var children = node.children.map(function(child) {
    var props = Object.assign({}, inheritedProps, child.props || {});
    var newChild = Object.assign({}, child, {
      props
    });
    return inheritProps2(newChild);
  });
  return Object.assign({}, node, {
    children
  });
};
var parseAspectRatio = function parseAspectRatio2(value2) {
  var match = value2.replace(/[\s\r\t\n]+/gm, " ").replace(/^defer\s/, "").split(" ");
  var align = match[0] || "xMidYMid";
  var meetOrSlice = match[1] || "meet";
  return {
    align,
    meetOrSlice
  };
};
var STYLE_PROPS = ["width", "height", "color", "stroke", "strokeWidth", "opacity", "fillOpacity", "strokeOpacity", "fill", "fillRule", "clipPath", "offset", "transform", "strokeLinejoin", "strokeLinecap", "strokeDasharray"];
var VERTICAL_PROPS = ["y", "y1", "y2", "height", "cy", "ry"];
var HORIZONTAL_PROPS = ["x", "x1", "x2", "width", "cx", "rx"];
var isType$3 = function isType(type) {
  return function(node) {
    return node.type === type;
  };
};
var isSvg$3 = isType$3(Svg);
var isText$4 = isType$3(Text);
var isTextInstance$3 = isType$3(TextInstance);
var transformPercent = function transformPercent2(container) {
  return function(props) {
    return mapValues(props, function(value2, key) {
      var match = matchPercent(value2);
      if (match && VERTICAL_PROPS.includes(key)) {
        return match.percent * container.height;
      }
      if (match && HORIZONTAL_PROPS.includes(key)) {
        return match.percent * container.width;
      }
      return value2;
    });
  };
};
var parsePercent = function parsePercent2(value2) {
  var match = matchPercent(value2);
  return match ? match.percent : parseFloat(value2);
};
var parseProps = function parseProps2(container) {
  return function(node) {
    var props = transformPercent(container)(node.props);
    props = evolve({
      x: parseFloat,
      x1: parseFloat,
      x2: parseFloat,
      y: parseFloat,
      y1: parseFloat,
      y2: parseFloat,
      r: parseFloat,
      rx: parseFloat,
      ry: parseFloat,
      cx: parseFloat,
      cy: parseFloat,
      width: parseFloat,
      height: parseFloat,
      offset: parsePercent,
      fill: transformColor,
      opacity: parsePercent,
      stroke: transformColor,
      stopOpacity: parsePercent,
      stopColor: transformColor,
      transform: processTransform
    }, props);
    return Object.assign({}, node, {
      props
    });
  };
};
var mergeStyles$1 = function mergeStyles3(node) {
  var style = node.style || {};
  var props = Object.assign({}, style, node.props);
  return Object.assign({}, node, {
    props
  });
};
var removeNoneValues = function removeNoneValues2(node) {
  var removeNone = function removeNone2(value2) {
    return value2 === "none" ? null : value2;
  };
  var props = mapValues(node.props, removeNone);
  return Object.assign({}, node, {
    props
  });
};
var pickStyleProps = function pickStyleProps2(node) {
  var props = node.props || {};
  var styleProps = pick(STYLE_PROPS, props);
  var style = Object.assign({}, styleProps, node.style || {});
  return Object.assign({}, node, {
    style
  });
};
var parseSvgProps = function parseSvgProps2(node) {
  var props = evolve({
    width: parseFloat,
    height: parseFloat,
    viewBox: parseViewbox,
    preserveAspectRatio: parseAspectRatio
  }, node.props);
  return Object.assign({}, node, {
    props
  });
};
var wrapBetweenTspan = function wrapBetweenTspan2(node) {
  return {
    type: Tspan,
    props: {},
    children: [node]
  };
};
var addMissingTspan = function addMissingTspan2(node) {
  if (!isText$4(node))
    return node;
  if (!node.children)
    return node;
  var resolveChild = function resolveChild2(child) {
    return isTextInstance$3(child) ? wrapBetweenTspan(child) : child;
  };
  var children = node.children.map(resolveChild);
  return Object.assign({}, node, {
    children
  });
};
var parseText = function parseText2(fontStore2) {
  return function(node) {
    if (isText$4(node))
      return layoutText$1(fontStore2, node);
    if (!node.children)
      return node;
    var children = node.children.map(parseText2(fontStore2));
    return Object.assign({}, node, {
      children
    });
  };
};
var resolveSvgNode = function resolveSvgNode2(container) {
  return compose(parseProps(container), addMissingTspan, removeNoneValues, mergeStyles$1);
};
var resolveChildren = function resolveChildren2(container) {
  return function(node) {
    if (!node.children)
      return node;
    var resolveChild = compose(resolveChildren2(container), resolveSvgNode(container));
    var children = node.children.map(resolveChild);
    return Object.assign({}, node, {
      children
    });
  };
};
var resolveSvgRoot = function resolveSvgRoot2(node, fontStore2) {
  var container = getContainer$1(node);
  return compose(replaceDefs, parseText(fontStore2), parseSvgProps, pickStyleProps, inheritProps, resolveChildren(container))(node);
};
var resolveSvg = function resolveSvg2(node, fontStore2) {
  if (!node.children)
    return node;
  var resolveChild = function resolveChild2(child) {
    return resolveSvg2(child, fontStore2);
  };
  var root = isSvg$3(node) ? resolveSvgRoot(node, fontStore2) : node;
  var children = root.children.map(resolveChild);
  return Object.assign({}, root, {
    children
  });
};
var getZIndex = function getZIndex2(node) {
  return node.style.zIndex;
};
var shouldSort = function shouldSort2(node) {
  return node.type !== Document && node.type !== Svg;
};
var sortZIndex = function sortZIndex2(a2, b) {
  var za = getZIndex(a2);
  var zb = getZIndex(b);
  if (!za && !zb)
    return 0;
  if (!za)
    return 1;
  if (!zb)
    return -1;
  return zb - za;
};
var resolveZIndex = function resolveZIndex2(node) {
  if (!node.children)
    return node;
  var sortedChildren = shouldSort(node) ? node.children.sort(sortZIndex) : node.children;
  var children = sortedChildren.map(resolveZIndex2);
  return Object.assign({}, node, {
    children
  });
};
var emojis = {};
var regex = emoji_regex_default();
var reflect = function reflect2(promise) {
  return function() {
    return promise.apply(void 0, arguments).then(function(v2) {
      return v2;
    }, function(e) {
      return e;
    });
  };
};
var makeFetchEmojiImage = function makeFetchEmojiImage2() {
  return reflect(resolveImage);
};
var _removeNoColor = function _removeNoColor2(x) {
  return x !== "️";
};
var getCodePoints = function getCodePoints2(string) {
  return Array.from(string).filter(_removeNoColor).map(function(char) {
    return char.codePointAt(0).toString(16);
  }).join("-");
};
var buildEmojiUrl = function buildEmojiUrl2(emoji, source) {
  var url = source.url, format = source.format, builder = source.builder;
  if (typeof builder === "function") {
    return builder(getCodePoints(emoji));
  }
  return "" + url + getCodePoints(emoji) + "." + format;
};
var fetchEmojis = function fetchEmojis2(string, source) {
  if (!source || !source.url && !source.builder)
    return [];
  var promises = [];
  Array.from(string.matchAll(regex)).forEach(function(match) {
    var emoji = match[0];
    if (!emojis[emoji] || emojis[emoji].loading) {
      var emojiUrl = buildEmojiUrl(emoji, source);
      emojis[emoji] = {
        loading: true
      };
      var fetchEmojiImage = makeFetchEmojiImage();
      promises.push(fetchEmojiImage({
        uri: emojiUrl
      }).then(function(image2) {
        emojis[emoji].loading = false;
        emojis[emoji].data = image2.data;
      }));
    }
  });
  return promises;
};
var embedEmojis = function embedEmojis2(fragments) {
  var result = [];
  var _loop = function _loop2() {
    var fragment = fragments[i];
    var lastIndex = 0;
    Array.from(fragment.string.matchAll(regex)).forEach(function(match) {
      var index3 = match.index;
      var emoji = match[0];
      var emojiSize = fragment.attributes.fontSize;
      var chunk = fragment.string.slice(lastIndex, index3 + match[0].length);
      if (emojis[emoji] && emojis[emoji].data) {
        result.push({
          string: chunk.replace(match, String.fromCharCode(65532)),
          attributes: _extends7({}, fragment.attributes, {
            attachment: {
              width: emojiSize,
              height: emojiSize,
              yOffset: Math.floor(emojiSize * 0.1),
              image: emojis[emoji].data
            }
          })
        });
      } else {
        result.push({
          string: chunk.replace(match, String.fromCharCode(0)),
          attributes: fragment.attributes
        });
      }
      lastIndex = index3 + emoji.length;
    });
    if (lastIndex < fragment.string.length) {
      result.push({
        string: fragment.string.slice(lastIndex),
        attributes: fragment.attributes
      });
    }
  };
  for (var i = 0; i < fragments.length; i += 1) {
    _loop();
  }
  return result;
};
var getSource = function getSource2(node) {
  var _node$props, _node$props2, _node$props3;
  return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.src) || ((_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.source) || ((_node$props3 = node.props) === null || _node$props3 === void 0 ? void 0 : _node$props3.href);
};
var resolveSource = function() {
  var _ref = _asyncToGenerator4(_regeneratorRuntime4().mark(function _callee(src3) {
    var source;
    return _regeneratorRuntime4().wrap(function _callee$(_context) {
      while (1)
        switch (_context.prev = _context.next) {
          case 0:
            if (!(typeof src3 === "function")) {
              _context.next = 6;
              break;
            }
            _context.next = 3;
            return src3();
          case 3:
            _context.t0 = _context.sent;
            _context.next = 9;
            break;
          case 6:
            _context.next = 8;
            return src3;
          case 8:
            _context.t0 = _context.sent;
          case 9:
            source = _context.t0;
            return _context.abrupt("return", typeof source === "string" ? {
              uri: source
            } : source);
          case 11:
          case "end":
            return _context.stop();
        }
    }, _callee);
  }));
  return function resolveSource2(_x) {
    return _ref.apply(this, arguments);
  };
}();
var fetchImage = function() {
  var _ref = _asyncToGenerator4(_regeneratorRuntime4().mark(function _callee(node) {
    var src3, cache2, source;
    return _regeneratorRuntime4().wrap(function _callee$(_context) {
      while (1)
        switch (_context.prev = _context.next) {
          case 0:
            src3 = getSource(node);
            cache2 = node.props.cache;
            if (src3) {
              _context.next = 5;
              break;
            }
            console.warn(false, 'Image should receive either a "src" or "source" prop');
            return _context.abrupt("return");
          case 5:
            _context.prev = 5;
            _context.next = 8;
            return resolveSource(src3);
          case 8:
            source = _context.sent;
            if (source) {
              _context.next = 11;
              break;
            }
            throw new Error(`Image's "src" or "source" prop returned ` + source);
          case 11:
            _context.next = 13;
            return resolveImage(source, {
              cache: cache2
            });
          case 13:
            node.image = _context.sent;
            node.image.key = source.data ? source.data.toString() : source.uri;
            _context.next = 21;
            break;
          case 17:
            _context.prev = 17;
            _context.t0 = _context["catch"](5);
            node.image = {
              width: 0,
              height: 0,
              key: null
            };
            console.warn(_context.t0.message);
          case 21:
          case "end":
            return _context.stop();
        }
    }, _callee, null, [[5, 17]]);
  }));
  return function fetchImage2(_x) {
    return _ref.apply(this, arguments);
  };
}();
var isImage$2 = function isImage(node) {
  return node.type === Image;
};
var fetchAssets = function fetchAssets2(fontStore2, node) {
  var _node$children;
  var promises = [];
  var listToExplore = ((_node$children = node.children) === null || _node$children === void 0 ? void 0 : _node$children.slice(0)) || [];
  var emojiSource = fontStore2 ? fontStore2.getEmojiSource() : null;
  while (listToExplore.length > 0) {
    var _n$style;
    var n = listToExplore.shift();
    if (isImage$2(n)) {
      promises.push(fetchImage(n));
    }
    if (fontStore2 && (_n$style = n.style) !== null && _n$style !== void 0 && _n$style.fontFamily) {
      promises.push(fontStore2.load(n.style));
    }
    if (typeof n === "string") {
      promises.push.apply(promises, fetchEmojis(n, emojiSource));
    }
    if (typeof n.value === "string") {
      promises.push.apply(promises, fetchEmojis(n.value, emojiSource));
    }
    if (n.children) {
      n.children.forEach(function(childNode) {
        listToExplore.push(childNode);
      });
    }
  }
  return promises;
};
var resolveAssets = function() {
  var _ref = _asyncToGenerator4(_regeneratorRuntime4().mark(function _callee(node, fontStore2) {
    var promises;
    return _regeneratorRuntime4().wrap(function _callee$(_context) {
      while (1)
        switch (_context.prev = _context.next) {
          case 0:
            promises = fetchAssets(fontStore2, node);
            _context.next = 3;
            return Promise.all(promises);
          case 3:
            return _context.abrupt("return", node);
          case 4:
          case "end":
            return _context.stop();
        }
    }, _callee);
  }));
  return function resolveAssets2(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
var isLink$1 = function isLink(node) {
  return node.type === Link;
};
var DEFAULT_LINK_STYLES = {
  color: "blue",
  textDecoration: "underline"
};
var computeStyle = function computeStyle2(container, node) {
  var baseStyle = node.style;
  if (isLink$1(node)) {
    baseStyle = Array.isArray(node.style) ? [DEFAULT_LINK_STYLES].concat(node.style) : [DEFAULT_LINK_STYLES, node.style];
  }
  return resolveStyles(container, baseStyle);
};
var resolveNodeStyles = function resolveNodeStyles2(container) {
  return function(node) {
    var style = computeStyle(container, node);
    if (!node.children)
      return Object.assign({}, node, {
        style
      });
    var children = node.children.map(resolveNodeStyles2(container));
    return Object.assign({}, node, {
      style,
      children
    });
  };
};
var resolvePageStyles = function resolvePageStyles2(page) {
  var _page$props, _page$box, _page$box2, _page$props2;
  var dpi = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.dpi) || 72;
  var width = ((_page$box = page.box) === null || _page$box === void 0 ? void 0 : _page$box.width) || page.style.width;
  var height5 = ((_page$box2 = page.box) === null || _page$box2 === void 0 ? void 0 : _page$box2.height) || page.style.height;
  var orientation = ((_page$props2 = page.props) === null || _page$props2 === void 0 ? void 0 : _page$props2.orientation) || "portrait";
  var container = {
    width,
    height: height5,
    orientation,
    dpi
  };
  return resolveNodeStyles(container)(page);
};
var resolveStyles3 = function resolveStyles4(root) {
  if (!root.children)
    return root;
  var children = root.children.map(resolvePageStyles);
  return Object.assign({}, root, {
    children
  });
};
var getTransformStyle = function getTransformStyle2(s2) {
  return function(node) {
    var _node$style, _node$style2;
    return isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style[s2]) ? "50%" : (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2[s2];
  };
};
var getOrigin = function getOrigin2(node) {
  if (!node.box)
    return {};
  var _node$box = node.box, left = _node$box.left, top = _node$box.top, width = _node$box.width, height5 = _node$box.height;
  var transformOriginX = getTransformStyle("transformOriginX")(node);
  var transformOriginY = getTransformStyle("transformOriginY")(node);
  var percentX = matchPercent(transformOriginX);
  var percentY = matchPercent(transformOriginY);
  var offsetX = percentX ? width * percentX.percent : transformOriginX;
  var offsetY = percentY ? height5 * percentY.percent : transformOriginY;
  return {
    left: left + offsetX,
    top: top + offsetY
  };
};
var resolveNodeOrigin = function resolveNodeOrigin2(node) {
  var origin = getOrigin(node);
  var newNode = Object.assign({}, node, {
    origin
  });
  if (!node.children)
    return newNode;
  var children = node.children.map(resolveNodeOrigin2);
  return Object.assign({}, newNode, {
    children
  });
};
var resolveOrigin = function resolveOrigin2(root) {
  if (!root.children)
    return root;
  var children = root.children.map(resolveNodeOrigin);
  return Object.assign({}, root, {
    children
  });
};
var getBookmarkValue = function getBookmarkValue2(title3) {
  return typeof title3 === "string" ? {
    title: title3,
    fit: false,
    expanded: false
  } : title3;
};
var resolveBookmarks = function resolveBookmarks2(node) {
  var refs = 0;
  var children = (node.children || []).slice(0);
  var listToExplore = children.map(function(value2) {
    return {
      value: value2,
      parent: null
    };
  });
  var _loop = function _loop2() {
    var _child$props;
    var element = listToExplore.shift();
    var child = element.value;
    var parent = element.parent;
    if ((_child$props = child.props) !== null && _child$props !== void 0 && _child$props.bookmark) {
      var _parent;
      var bookmark = getBookmarkValue(child.props.bookmark);
      var ref = refs++;
      var newHierarchy = _extends7({
        ref,
        parent: (_parent = parent) === null || _parent === void 0 ? void 0 : _parent.ref
      }, bookmark);
      child.props.bookmark = newHierarchy;
      parent = newHierarchy;
    }
    if (child.children) {
      child.children.forEach(function(childNode) {
        listToExplore.push({
          value: childNode,
          parent
        });
      });
    }
  };
  while (listToExplore.length > 0) {
    _loop();
  }
  return node;
};
var VALID_ORIENTATIONS = ["portrait", "landscape"];
var getOrientation = function getOrientation2(page) {
  var _page$props;
  var value2 = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.orientation) || "portrait";
  return VALID_ORIENTATIONS.includes(value2) ? value2 : "portrait";
};
var isLandscape = function isLandscape2(page) {
  return getOrientation(page) === "landscape";
};
var PAGE_SIZES = {
  "4A0": [4767.87, 6740.79],
  "2A0": [3370.39, 4767.87],
  A0: [2383.94, 3370.39],
  A1: [1683.78, 2383.94],
  A2: [1190.55, 1683.78],
  A3: [841.89, 1190.55],
  A4: [595.28, 841.89],
  A5: [419.53, 595.28],
  A6: [297.64, 419.53],
  A7: [209.76, 297.64],
  A8: [147.4, 209.76],
  A9: [104.88, 147.4],
  A10: [73.7, 104.88],
  B0: [2834.65, 4008.19],
  B1: [2004.09, 2834.65],
  B2: [1417.32, 2004.09],
  B3: [1000.63, 1417.32],
  B4: [708.66, 1000.63],
  B5: [498.9, 708.66],
  B6: [354.33, 498.9],
  B7: [249.45, 354.33],
  B8: [175.75, 249.45],
  B9: [124.72, 175.75],
  B10: [87.87, 124.72],
  C0: [2599.37, 3676.54],
  C1: [1836.85, 2599.37],
  C2: [1298.27, 1836.85],
  C3: [918.43, 1298.27],
  C4: [649.13, 918.43],
  C5: [459.21, 649.13],
  C6: [323.15, 459.21],
  C7: [229.61, 323.15],
  C8: [161.57, 229.61],
  C9: [113.39, 161.57],
  C10: [79.37, 113.39],
  RA0: [2437.8, 3458.27],
  RA1: [1729.13, 2437.8],
  RA2: [1218.9, 1729.13],
  RA3: [864.57, 1218.9],
  RA4: [609.45, 864.57],
  SRA0: [2551.18, 3628.35],
  SRA1: [1814.17, 2551.18],
  SRA2: [1275.59, 1814.17],
  SRA3: [907.09, 1275.59],
  SRA4: [637.8, 907.09],
  EXECUTIVE: [521.86, 756],
  FOLIO: [612, 936],
  LEGAL: [612, 1008],
  LETTER: [612, 792],
  TABLOID: [792, 1224],
  ID1: [153, 243]
};
var toSizeObject = function toSizeObject2(v2) {
  return {
    width: v2[0],
    height: v2[1]
  };
};
var flipSizeObject = function flipSizeObject2(v2) {
  return {
    width: v2.height,
    height: v2.width
  };
};
var adjustDpi = function adjustDpi2(v2, dpi) {
  return {
    width: v2.width ? v2.width * dpi : v2.width,
    height: v2.height ? v2.height * dpi : v2.height
  };
};
var getStringSize = function getStringSize2(v2) {
  return toSizeObject(PAGE_SIZES[v2.toUpperCase()]);
};
var getNumberSize = function getNumberSize2(n) {
  return toSizeObject([n]);
};
var getSize = function getSize2(page) {
  var _page$props, _page$props2;
  var value2 = ((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.size) || "A4";
  var dpi = parseFloat(((_page$props2 = page.props) === null || _page$props2 === void 0 ? void 0 : _page$props2.dpi) || 72);
  var type = typeof value2;
  var size = value2;
  if (type === "string") {
    size = getStringSize(value2);
  } else if (Array.isArray(value2)) {
    size = toSizeObject(value2);
  } else if (type === "number") {
    size = getNumberSize(value2);
  }
  size = adjustDpi(size, dpi / 72);
  return isLandscape(page) ? flipSizeObject(size) : size;
};
var resolvePageSize = function resolvePageSize2(page) {
  var size = getSize(page);
  var style = flatten(page.style || {});
  return _extends7({}, page, {
    style: _extends7({}, style, size)
  });
};
var resolvePageSizes = function resolvePageSizes2(root) {
  if (!root.children)
    return root;
  var children = root.children.map(resolvePageSize);
  return Object.assign({}, root, {
    children
  });
};
var isFixed = function isFixed2(node) {
  var _node$props;
  return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.fixed) === true;
};
var lineIndexAtHeight = function lineIndexAtHeight2(node, height5) {
  var y = 0;
  if (!node.lines)
    return 0;
  for (var i = 0; i < node.lines.length; i += 1) {
    var line2 = node.lines[i];
    if (y + line2.box.height > height5)
      return i;
    y += line2.box.height;
  }
  return node.lines.length;
};
var heightAtLineIndex = function heightAtLineIndex2(node, index3) {
  var counter = 0;
  if (!node.lines)
    return counter;
  for (var i = 0; i < index3; i += 1) {
    var line2 = node.lines[i];
    if (!line2)
      break;
    counter += line2.box.height;
  }
  return counter;
};
var getLineBreak = function getLineBreak2(node, height5) {
  var top = get(node, ["box", "top"], 0);
  var widows = get(node, ["props", "widows"], 2);
  var orphans = get(node, ["props", "orphans"], 2);
  var linesQuantity = node.lines.length;
  var slicedLine = lineIndexAtHeight(node, height5 - top);
  if (slicedLine === 0) {
    return 0;
  }
  if (linesQuantity < orphans) {
    return linesQuantity;
  }
  if (slicedLine < orphans || linesQuantity < orphans + widows) {
    return 0;
  }
  if (linesQuantity === orphans + widows) {
    return orphans;
  }
  if (linesQuantity - slicedLine < widows) {
    return linesQuantity - widows;
  }
  return slicedLine;
};
var splitText = function splitText2(node, height5) {
  var slicedLineIndex = getLineBreak(node, height5);
  var currentHeight = heightAtLineIndex(node, slicedLineIndex);
  var nextHeight = node.box.height - currentHeight;
  var current = Object.assign({}, node, {
    box: _extends7({}, node.box, {
      height: currentHeight,
      borderBottomWidth: 0
    }),
    style: _extends7({}, node.style, {
      marginBottom: 0,
      paddingBottom: 0,
      borderBottomWidth: 0,
      borderBottomLeftRadius: 0,
      borderBottomRightRadius: 0
    }),
    lines: node.lines.slice(0, slicedLineIndex)
  });
  var next2 = Object.assign({}, node, {
    box: _extends7({}, node.box, {
      top: 0,
      height: nextHeight,
      borderTopWidth: 0
    }),
    style: _extends7({}, node.style, {
      marginTop: 0,
      paddingTop: 0,
      borderTopWidth: 0,
      borderTopLeftRadius: 0,
      borderTopRightRadius: 0
    }),
    lines: node.lines.slice(slicedLineIndex)
  });
  return [current, next2];
};
var getTop$1 = function getTop(node) {
  var _node$box;
  return ((_node$box = node.box) === null || _node$box === void 0 ? void 0 : _node$box.top) || 0;
};
var hasFixedHeight = function hasFixedHeight2(node) {
  var _node$style;
  return !isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.height);
};
var splitNode = function splitNode2(node, height5) {
  if (!node)
    return [null, null];
  var nodeTop = getTop$1(node);
  var current = Object.assign({}, node, {
    box: _extends7({}, node.box, {
      borderBottomWidth: 0
    }),
    style: _extends7({}, node.style, {
      marginBottom: 0,
      paddingBottom: 0,
      borderBottomWidth: 0,
      borderBottomLeftRadius: 0,
      borderBottomRightRadius: 0
    })
  });
  current.style.height = height5 - nodeTop;
  var nextHeight = hasFixedHeight(node) ? node.box.height - (height5 - nodeTop) : null;
  var next2 = Object.assign({}, node, {
    box: _extends7({}, node.box, {
      top: 0,
      borderTopWidth: 0
    }),
    style: _extends7({}, node.style, {
      marginTop: 0,
      paddingTop: 0,
      borderTopWidth: 0,
      borderTopLeftRadius: 0,
      borderTopRightRadius: 0
    })
  });
  if (nextHeight) {
    next2.style.height = nextHeight;
  }
  return [current, next2];
};
var NON_WRAP_TYPES = [Svg, Note, Image, Canvas];
var getWrap = function getWrap2(node) {
  var _node$props;
  if (NON_WRAP_TYPES.includes(node.type))
    return false;
  return isNil((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.wrap) ? true : node.props.wrap;
};
var getComputedPadding = function getComputedPadding2(node, edge) {
  var yogaNode = node.yogaNode;
  return yogaNode ? yogaNode.getComputedPadding(edge) : null;
};
var getPadding = function getPadding2(node) {
  var style = node.style, box = node.box;
  var paddingTop = getComputedPadding(node, index.EDGE_TOP) || (box === null || box === void 0 ? void 0 : box.paddingTop) || (style === null || style === void 0 ? void 0 : style.paddingTop) || (style === null || style === void 0 ? void 0 : style.paddingVertical) || (style === null || style === void 0 ? void 0 : style.padding) || 0;
  var paddingRight = getComputedPadding(node, index.EDGE_RIGHT) || (box === null || box === void 0 ? void 0 : box.paddingRight) || (style === null || style === void 0 ? void 0 : style.paddingRight) || (style === null || style === void 0 ? void 0 : style.paddingHorizontal) || (style === null || style === void 0 ? void 0 : style.padding) || 0;
  var paddingBottom = getComputedPadding(node, index.EDGE_BOTTOM) || (box === null || box === void 0 ? void 0 : box.paddingBottom) || (style === null || style === void 0 ? void 0 : style.paddingBottom) || (style === null || style === void 0 ? void 0 : style.paddingVertical) || (style === null || style === void 0 ? void 0 : style.padding) || 0;
  var paddingLeft = getComputedPadding(node, index.EDGE_LEFT) || (box === null || box === void 0 ? void 0 : box.paddingLeft) || (style === null || style === void 0 ? void 0 : style.paddingLeft) || (style === null || style === void 0 ? void 0 : style.paddingHorizontal) || (style === null || style === void 0 ? void 0 : style.padding) || 0;
  return {
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft
  };
};
var getWrapArea = function getWrapArea2(page) {
  var _page$style;
  var _getPadding = getPadding(page), paddingBottom = _getPadding.paddingBottom;
  var height5 = (_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.height;
  return height5 - paddingBottom;
};
var getContentArea = function getContentArea2(page) {
  var _page$style;
  var height5 = (_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.height;
  var _getPadding = getPadding(page), paddingTop = _getPadding.paddingTop, paddingBottom = _getPadding.paddingBottom;
  return height5 - paddingBottom - paddingTop;
};
var _excluded3 = ["style", "children"];
var isString = function isString2(value2) {
  return typeof value2 === "string";
};
var isNumber3 = function isNumber4(value2) {
  return typeof value2 === "number";
};
var isFragment = function isFragment2(value2) {
  return value2 && value2.type === Symbol.for("react.fragment");
};
var createInstances = function createInstances2(element) {
  if (!element)
    return [];
  if (isString(element) || isNumber3(element)) {
    return [{
      type: TextInstance,
      value: "" + element
    }];
  }
  if (isFragment(element)) {
    return createInstances2(element.props.children);
  }
  if (Array.isArray(element)) {
    return element.reduce(function(acc, el) {
      return acc.concat(createInstances2(el));
    }, []);
  }
  if (!isString(element.type)) {
    return createInstances2(element.type(element.props));
  }
  var type = element.type, _element$props = element.props, _element$props$style = _element$props.style, style = _element$props$style === void 0 ? {} : _element$props$style, _element$props$childr = _element$props.children, children = _element$props$childr === void 0 ? [] : _element$props$childr, props = _objectWithoutPropertiesLoose3(_element$props, _excluded3);
  var nextChildren = castArray(children).reduce(function(acc, child) {
    return acc.concat(createInstances2(child));
  }, []);
  return [{
    type,
    style,
    props,
    box: {},
    children: nextChildren
  }];
};
var getNodesHeight = function getNodesHeight2(nodes) {
  var max3 = 0;
  var min3 = Infinity;
  if (!nodes || nodes.length === 0)
    return 0;
  for (var i = 0; i < nodes.length; i += 1) {
    var node = nodes[i];
    min3 = Math.min(min3, node.box.top);
    max3 = Math.max(max3, node.box.top + node.box.height);
  }
  return max3 - min3;
};
var getBreak = function getBreak2(node) {
  var _node$props;
  return ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.break) || false;
};
var getMinPresenceAhead = function getMinPresenceAhead2(node) {
  var _node$props2;
  return (_node$props2 = node.props) === null || _node$props2 === void 0 ? void 0 : _node$props2.minPresenceAhead;
};
var defaultPresenceAhead = function defaultPresenceAhead2(element) {
  return function(height5) {
    return Math.min(element.box.height, height5);
  };
};
var getPresenceAhead = function getPresenceAhead2(elements, height5) {
  var result = 0;
  for (var i = 0; i < elements.length; i += 1) {
    var element = elements[i];
    if (!element.box)
      continue;
    var isElementInside = height5 > element.box.top;
    var presenceAhead = element.props.presenceAhead || defaultPresenceAhead(element);
    if (element && isElementInside) {
      result += presenceAhead(height5 - element.box.top);
    }
  }
  return result;
};
var shouldBreak = function shouldBreak2(child, futureElements, height5) {
  var minPresenceAhead = getMinPresenceAhead(child);
  var presenceAhead = getPresenceAhead(futureElements, height5);
  var futureHeight = getNodesHeight(futureElements);
  var shouldSplit = height5 < child.box.top + child.box.height;
  var shouldWrap = getWrap(child);
  return getBreak(child) || !shouldWrap && shouldSplit || minPresenceAhead < futureHeight && presenceAhead < minPresenceAhead;
};
var IGNORABLE_CODEPOINTS = [
  8232,
  // LINE_SEPARATOR
  8233
  // PARAGRAPH_SEPARATOR
];
var buildSubsetForFont = function buildSubsetForFont2(font2) {
  return IGNORABLE_CODEPOINTS.reduce(function(acc, codePoint) {
    if (font2 && font2.hasGlyphForCodePoint && font2.hasGlyphForCodePoint(codePoint)) {
      return acc;
    }
    return [].concat(acc, [String.fromCharCode(codePoint)]);
  }, []);
};
var ignoreChars = function ignoreChars2(fragments) {
  return fragments.map(function(fragment) {
    var charSubset = buildSubsetForFont(fragment.attributes.font);
    var subsetRegex = new RegExp(charSubset.join("|"));
    return {
      string: fragment.string.replace(subsetRegex, ""),
      attributes: fragment.attributes
    };
  });
};
var PREPROCESSORS = [ignoreChars, embedEmojis];
var isImage$1 = function isImage2(node) {
  return node.type === Image;
};
var isTextInstance$2 = function isTextInstance2(node) {
  return node.type === TextInstance;
};
var getFragments2 = function getFragments3(fontStore2, instance, parentLink, level) {
  var _instance$props, _instance$props2;
  if (level === void 0) {
    level = 0;
  }
  if (!instance)
    return [{
      string: ""
    }];
  var fragments = [];
  var _instance$style = instance.style, _instance$style$color = _instance$style.color, color = _instance$style$color === void 0 ? "black" : _instance$style$color, _instance$style$fontF = _instance$style.fontFamily, fontFamily = _instance$style$fontF === void 0 ? "Helvetica" : _instance$style$fontF, fontWeight = _instance$style.fontWeight, fontStyle = _instance$style.fontStyle, _instance$style$fontS = _instance$style.fontSize, fontSize2 = _instance$style$fontS === void 0 ? 18 : _instance$style$fontS, _instance$style$textA = _instance$style.textAlign, textAlign = _instance$style$textA === void 0 ? "left" : _instance$style$textA, lineHeight = _instance$style.lineHeight, textDecoration3 = _instance$style.textDecoration, textDecorationColor = _instance$style.textDecorationColor, textDecorationStyle = _instance$style.textDecorationStyle, textTransform = _instance$style.textTransform, letterSpacing = _instance$style.letterSpacing, textIndent = _instance$style.textIndent, opacity2 = _instance$style.opacity, verticalAlign = _instance$style.verticalAlign;
  var opts2 = {
    fontFamily,
    fontWeight,
    fontStyle
  };
  var obj = fontStore2 ? fontStore2.getFont(opts2) : null;
  var font2 = obj ? obj.data : fontFamily;
  var backgroundColor = level === 0 ? null : instance.style.backgroundColor;
  var attributes2 = {
    font: font2,
    color,
    opacity: opacity2,
    fontSize: fontSize2,
    backgroundColor,
    align: textAlign,
    indent: textIndent,
    characterSpacing: letterSpacing,
    strikeStyle: textDecorationStyle,
    underlineStyle: textDecorationStyle,
    underline: textDecoration3 === "underline" || textDecoration3 === "underline line-through" || textDecoration3 === "line-through underline",
    strike: textDecoration3 === "line-through" || textDecoration3 === "underline line-through" || textDecoration3 === "line-through underline",
    strikeColor: textDecorationColor || color,
    underlineColor: textDecorationColor || color,
    link: parentLink || ((_instance$props = instance.props) === null || _instance$props === void 0 ? void 0 : _instance$props.src) || ((_instance$props2 = instance.props) === null || _instance$props2 === void 0 ? void 0 : _instance$props2.href),
    lineHeight: lineHeight ? lineHeight * fontSize2 : null,
    verticalAlign
  };
  for (var i = 0; i < instance.children.length; i += 1) {
    var child = instance.children[i];
    if (isImage$1(child)) {
      fragments.push({
        string: String.fromCharCode(65532),
        attributes: _extends7({}, attributes2, {
          attachment: {
            width: child.style.width || fontSize2,
            height: child.style.height || fontSize2,
            image: child.image.data
          }
        })
      });
    } else if (isTextInstance$2(child)) {
      fragments.push({
        string: transformText(child.value, textTransform),
        attributes: attributes2
      });
    } else if (child) {
      var _fragments;
      (_fragments = fragments).push.apply(_fragments, getFragments3(fontStore2, child, attributes2.link, level + 1));
    }
  }
  for (var _i = 0; _i < PREPROCESSORS.length; _i += 1) {
    var preprocessor = PREPROCESSORS[_i];
    fragments = preprocessor(fragments);
  }
  return fragments;
};
var getAttributedString2 = function getAttributedString3(fontStore2, instance) {
  var fragments = getFragments2(fontStore2, instance);
  return fromFragments3(fragments);
};
var engines = {
  linebreaker,
  justification,
  textDecoration,
  scriptItemizer,
  wordHyphenation,
  fontSubstitution
};
var engine = layoutEngine(engines);
var getMaxLines = function getMaxLines2(node) {
  var _node$style;
  return (_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.maxLines;
};
var getTextOverflow = function getTextOverflow2(node) {
  var _node$style2;
  return (_node$style2 = node.style) === null || _node$style2 === void 0 ? void 0 : _node$style2.textOverflow;
};
var getContainer2 = function getContainer3(width, height5, node) {
  var maxLines = getMaxLines(node);
  var textOverflow = getTextOverflow(node);
  return {
    x: 0,
    y: 0,
    width,
    maxLines,
    height: height5 || Infinity,
    truncateMode: textOverflow
  };
};
var getLayoutOptions = function getLayoutOptions2(fontStore2, node) {
  return {
    hyphenationPenalty: node.props.hyphenationPenalty,
    shrinkWhitespaceFactor: {
      before: -0.5,
      after: -0.5
    },
    hyphenationCallback: node.props.hyphenationCallback || (fontStore2 === null || fontStore2 === void 0 ? void 0 : fontStore2.getHyphenationCallback()) || null
  };
};
var layoutText2 = function layoutText3(node, width, height5, fontStore2) {
  var attributedString = getAttributedString2(fontStore2, node);
  var container = getContainer2(width, height5, node);
  var options = getLayoutOptions(fontStore2, node);
  var lines = engine(attributedString, container, options);
  return lines.reduce(function(acc, line2) {
    return [].concat(acc, line2);
  }, []);
};
var isType$2 = function isType2(type) {
  return function(node) {
    return node.type === type;
  };
};
var isSvg$2 = isType$2(Svg);
var isText$3 = isType$2(Text);
var shouldIterate = function shouldIterate2(node) {
  return !isSvg$2(node) && !isText$3(node);
};
var shouldLayoutText = function shouldLayoutText2(node) {
  return isText$3(node) && !node.lines;
};
var resolveTextLayout = function resolveTextLayout2(node, fontStore2) {
  if (shouldLayoutText(node)) {
    var width = node.box.width - (node.box.paddingRight + node.box.paddingLeft);
    var height5 = node.box.height - (node.box.paddingTop + node.box.paddingBottom);
    node.lines = layoutText2(node, width, height5, fontStore2);
  }
  if (shouldIterate(node)) {
    if (!node.children)
      return node;
    var mapChild = function mapChild2(child) {
      return resolveTextLayout2(child, fontStore2);
    };
    var children = node.children.map(mapChild);
    return Object.assign({}, node, {
      children
    });
  }
  return node;
};
var INHERITED_PROPERTIES = ["color", "fontFamily", "fontSize", "fontStyle", "fontWeight", "letterSpacing", "opacity", "textDecoration", "textTransform", "lineHeight", "textAlign", "visibility", "wordSpacing"];
var isSvg$1 = function isSvg(node) {
  return node.type === Svg;
};
var mergeValues = function mergeValues2(styleName, value2, inheritedValue) {
  switch (styleName) {
    case "textDecoration": {
      return [inheritedValue, value2].filter(function(v2) {
        return v2 && v2 !== "none";
      }).join(" ");
    }
    default:
      return value2;
  }
};
var merge = function merge2(inheritedStyles, style) {
  var mergedStyles = _extends7({}, inheritedStyles);
  Object.entries(style).forEach(function(_ref) {
    var styleName = _ref[0], value2 = _ref[1];
    mergedStyles[styleName] = mergeValues(styleName, value2, inheritedStyles[styleName]);
  });
  return mergedStyles;
};
var mergeStyles4 = function mergeStyles5(inheritedStyles) {
  return function(node) {
    var style = merge(inheritedStyles, node.style || {});
    return Object.assign({}, node, {
      style
    });
  };
};
var resolveInheritance = function resolveInheritance2(node) {
  if (isSvg$1(node))
    return node;
  if (!node.children)
    return node;
  var inheritStyles = pick(INHERITED_PROPERTIES, node.style || {});
  var resolveChild = compose(resolveInheritance2, mergeStyles4(inheritStyles));
  var children = node.children.map(resolveChild);
  return Object.assign({}, node, {
    children
  });
};
var getComputedMargin = function getComputedMargin2(node, edge) {
  var yogaNode = node.yogaNode;
  return yogaNode ? yogaNode.getComputedMargin(edge) : null;
};
var getMargin3 = function getMargin4(node) {
  var style = node.style, box = node.box;
  var marginTop = getComputedMargin(node, index.EDGE_TOP) || (box === null || box === void 0 ? void 0 : box.marginTop) || (style === null || style === void 0 ? void 0 : style.marginTop) || (style === null || style === void 0 ? void 0 : style.marginVertical) || (style === null || style === void 0 ? void 0 : style.margin) || 0;
  var marginRight = getComputedMargin(node, index.EDGE_RIGHT) || (box === null || box === void 0 ? void 0 : box.marginRight) || (style === null || style === void 0 ? void 0 : style.marginRight) || (style === null || style === void 0 ? void 0 : style.marginHorizontal) || (style === null || style === void 0 ? void 0 : style.margin) || 0;
  var marginBottom = getComputedMargin(node, index.EDGE_BOTTOM) || (box === null || box === void 0 ? void 0 : box.marginBottom) || (style === null || style === void 0 ? void 0 : style.marginBottom) || (style === null || style === void 0 ? void 0 : style.marginVertical) || (style === null || style === void 0 ? void 0 : style.margin) || 0;
  var marginLeft = getComputedMargin(node, index.EDGE_LEFT) || (box === null || box === void 0 ? void 0 : box.marginLeft) || (style === null || style === void 0 ? void 0 : style.marginLeft) || (style === null || style === void 0 ? void 0 : style.marginHorizontal) || (style === null || style === void 0 ? void 0 : style.margin) || 0;
  return {
    marginTop,
    marginRight,
    marginBottom,
    marginLeft
  };
};
var getPosition = function getPosition2(node) {
  var yogaNode = node.yogaNode;
  return {
    top: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedTop()) || 0,
    right: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedRight()) || 0,
    bottom: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedBottom()) || 0,
    left: (yogaNode === null || yogaNode === void 0 ? void 0 : yogaNode.getComputedLeft()) || 0
  };
};
var DEFAULT_DIMENSION = {
  width: 0,
  height: 0
};
var getDimension = function getDimension2(node) {
  var yogaNode = node.yogaNode;
  if (!yogaNode)
    return DEFAULT_DIMENSION;
  return {
    width: yogaNode.getComputedWidth(),
    height: yogaNode.getComputedHeight()
  };
};
var getComputedBorder = function getComputedBorder2(yogaNode, edge) {
  return yogaNode ? yogaNode.getComputedBorder(edge) : 0;
};
var getBorderWidth = function getBorderWidth2(node) {
  var yogaNode = node.yogaNode;
  return {
    borderTopWidth: getComputedBorder(yogaNode, index.EDGE_TOP),
    borderRightWidth: getComputedBorder(yogaNode, index.EDGE_RIGHT),
    borderBottomWidth: getComputedBorder(yogaNode, index.EDGE_BOTTOM),
    borderLeftWidth: getComputedBorder(yogaNode, index.EDGE_LEFT)
  };
};
var setDisplay = function setDisplay2(value2) {
  return function(node) {
    var yogaNode = node.yogaNode;
    if (yogaNode) {
      yogaNode.setDisplay(value2 === "none" ? index.DISPLAY_NONE : index.DISPLAY_FLEX);
    }
    return node;
  };
};
var OVERFLOW = {
  hidden: index.OVERFLOW_HIDDEN,
  scroll: index.OVERFLOW_SCROLL
};
var setOverflow = function setOverflow2(value2) {
  return function(node) {
    var yogaNode = node.yogaNode;
    if (!isNil(value2) && yogaNode) {
      var overflow = OVERFLOW[value2] || index.OVERFLOW_VISIBLE;
      yogaNode.setOverflow(overflow);
    }
    return node;
  };
};
var FLEX_WRAP = {
  wrap: index.WRAP_WRAP,
  "wrap-reverse": index.WRAP_WRAP_REVERSE
};
var setFlexWrap = function setFlexWrap2(value2) {
  return function(node) {
    var yogaNode = node.yogaNode;
    if (yogaNode) {
      var flexWrap = FLEX_WRAP[value2] || index.WRAP_NO_WRAP;
      yogaNode.setFlexWrap(flexWrap);
    }
    return node;
  };
};
var setYogaValue = function setYogaValue2(attr, edge) {
  return function(value2) {
    return function(node) {
      var yogaNode = node.yogaNode;
      if (!isNil(value2) && yogaNode) {
        var hasEdge = !isNil(edge);
        var fixedMethod = "set" + upperFirst(attr);
        var autoMethod = fixedMethod + "Auto";
        var percentMethod = fixedMethod + "Percent";
        var percent = matchPercent(value2);
        if (percent && !yogaNode[percentMethod]) {
          throw new Error("You can't pass percentage values to " + attr + " property");
        }
        if (percent) {
          if (hasEdge) {
            var _yogaNode$percentMeth;
            (_yogaNode$percentMeth = yogaNode[percentMethod]) === null || _yogaNode$percentMeth === void 0 ? void 0 : _yogaNode$percentMeth.call(yogaNode, edge, percent.value);
          } else {
            var _yogaNode$percentMeth2;
            (_yogaNode$percentMeth2 = yogaNode[percentMethod]) === null || _yogaNode$percentMeth2 === void 0 ? void 0 : _yogaNode$percentMeth2.call(yogaNode, percent.value);
          }
        } else if (value2 === "auto") {
          if (hasEdge) {
            var _yogaNode$autoMethod;
            (_yogaNode$autoMethod = yogaNode[autoMethod]) === null || _yogaNode$autoMethod === void 0 ? void 0 : _yogaNode$autoMethod.call(yogaNode, edge);
          } else {
            var _yogaNode$autoMethod2;
            (_yogaNode$autoMethod2 = yogaNode[autoMethod]) === null || _yogaNode$autoMethod2 === void 0 ? void 0 : _yogaNode$autoMethod2.call(yogaNode);
          }
        } else if (hasEdge) {
          var _yogaNode$fixedMethod;
          (_yogaNode$fixedMethod = yogaNode[fixedMethod]) === null || _yogaNode$fixedMethod === void 0 ? void 0 : _yogaNode$fixedMethod.call(yogaNode, edge, value2);
        } else {
          var _yogaNode$fixedMethod2;
          (_yogaNode$fixedMethod2 = yogaNode[fixedMethod]) === null || _yogaNode$fixedMethod2 === void 0 ? void 0 : _yogaNode$fixedMethod2.call(yogaNode, value2);
        }
      }
      return node;
    };
  };
};
var setFlexGrow = function setFlexGrow2(value2) {
  return function(node) {
    return setYogaValue("flexGrow")(value2 || 0)(node);
  };
};
var setFlexBasis = setYogaValue("flexBasis");
var ALIGN = {
  "flex-start": index.ALIGN_FLEX_START,
  center: index.ALIGN_CENTER,
  "flex-end": index.ALIGN_FLEX_END,
  stretch: index.ALIGN_STRETCH,
  baseline: index.ALIGN_BASELINE,
  "space-between": index.ALIGN_SPACE_BETWEEN,
  "space-around": index.ALIGN_SPACE_AROUND
};
var setAlign = function setAlign2(attr) {
  return function(value2) {
    return function(node) {
      var yogaNode = node.yogaNode;
      var defaultValue = attr === "items" ? index.ALIGN_STRETCH : index.ALIGN_AUTO;
      if (yogaNode) {
        var align = ALIGN[value2] || defaultValue;
        yogaNode["setAlign" + upperFirst(attr)](align);
      }
      return node;
    };
  };
};
var setAlignSelf = setAlign("self");
var setAlignItems = setAlign("items");
var setFlexShrink = function setFlexShrink2(value2) {
  return function(node) {
    return setYogaValue("flexShrink")(value2 || 1)(node);
  };
};
var setAspectRatio = function setAspectRatio2(value2) {
  return function(node) {
    var yogaNode = node.yogaNode;
    if (!isNil(value2) && yogaNode) {
      yogaNode.setAspectRatio(value2);
    }
    return node;
  };
};
var setAlignContent = setAlign("content");
var setPositionType = function setPositionType2(value2) {
  return function(node) {
    var yogaNode = node.yogaNode;
    if (!isNil(value2) && yogaNode) {
      yogaNode.setPositionType(value2 === "absolute" ? index.POSITION_TYPE_ABSOLUTE : index.POSITION_TYPE_RELATIVE);
    }
    return node;
  };
};
var FLEX_DIRECTIONS = {
  row: index.FLEX_DIRECTION_ROW,
  "row-reverse": index.FLEX_DIRECTION_ROW_REVERSE,
  "column-reverse": index.FLEX_DIRECTION_COLUMN_REVERSE
};
var setFlexDirection = function setFlexDirection2(value2) {
  return function(node) {
    var yogaNode = node.yogaNode;
    if (yogaNode) {
      var flexDirection = FLEX_DIRECTIONS[value2] || index.FLEX_DIRECTION_COLUMN;
      yogaNode.setFlexDirection(flexDirection);
    }
    return node;
  };
};
var JUSTIFY_CONTENT = {
  center: index.JUSTIFY_CENTER,
  "flex-end": index.JUSTIFY_FLEX_END,
  "space-between": index.JUSTIFY_SPACE_BETWEEN,
  "space-around": index.JUSTIFY_SPACE_AROUND,
  "space-evenly": index.JUSTIFY_SPACE_EVENLY
};
var setJustifyContent = function setJustifyContent2(value2) {
  return function(node) {
    var yogaNode = node.yogaNode;
    if (!isNil(value2) && yogaNode) {
      var justifyContent = JUSTIFY_CONTENT[value2] || index.JUSTIFY_FLEX_START;
      yogaNode.setJustifyContent(justifyContent);
    }
    return node;
  };
};
var setMarginTop = setYogaValue("margin", index.EDGE_TOP);
var setMarginRight = setYogaValue("margin", index.EDGE_RIGHT);
var setMarginBottom = setYogaValue("margin", index.EDGE_BOTTOM);
var setMarginLeft = setYogaValue("margin", index.EDGE_LEFT);
var setPaddingTop = setYogaValue("padding", index.EDGE_TOP);
var setPaddingRight = setYogaValue("padding", index.EDGE_RIGHT);
var setPaddingBottom = setYogaValue("padding", index.EDGE_BOTTOM);
var setPaddingLeft = setYogaValue("padding", index.EDGE_LEFT);
var setBorderTop = setYogaValue("border", index.EDGE_TOP);
var setBorderRight = setYogaValue("border", index.EDGE_RIGHT);
var setBorderBottom = setYogaValue("border", index.EDGE_BOTTOM);
var setBorderLeft = setYogaValue("border", index.EDGE_LEFT);
var setPositionTop = setYogaValue("position", index.EDGE_TOP);
var setPositionRight = setYogaValue("position", index.EDGE_RIGHT);
var setPositionBottom = setYogaValue("position", index.EDGE_BOTTOM);
var setPositionLeft = setYogaValue("position", index.EDGE_LEFT);
var setWidth = setYogaValue("width");
var setMinWidth = setYogaValue("minWidth");
var setMaxWidth = setYogaValue("maxWidth");
var setHeight = setYogaValue("height");
var setMinHeight = setYogaValue("minHeight");
var setMaxHeight = setYogaValue("maxHeight");
var checkPercents = function checkPercents2(attr, value2) {
  var percent = matchPercent(value2);
  if (percent) {
    throw new Error("You can't pass percentage values to " + attr + " property");
  }
};
var setRowGap = function setRowGap2(value2) {
  return function(node) {
    var yogaNode = node.yogaNode;
    if (!isNil(value2) && yogaNode) {
      checkPercents("rowGap", value2);
      yogaNode.setGap(index.GUTTER_ROW, value2);
    }
    return node;
  };
};
var setColumnGap = function setColumnGap2(value2) {
  return function(node) {
    var yogaNode = node.yogaNode;
    if (!isNil(value2) && yogaNode) {
      checkPercents("columnGap", value2);
      yogaNode.setGap(index.GUTTER_COLUMN, value2);
    }
    return node;
  };
};
var getAspectRatio = function getAspectRatio2(viewbox) {
  if (!viewbox)
    return null;
  return (viewbox.maxX - viewbox.minX) / (viewbox.maxY - viewbox.minY);
};
var measureCanvas$1 = function measureCanvas(page, node) {
  return function(width, widthMode, height5, heightMode) {
    var aspectRatio = getAspectRatio(node.props.viewBox) || 1;
    if (widthMode === index.MEASURE_MODE_EXACTLY || widthMode === index.MEASURE_MODE_AT_MOST) {
      return {
        width,
        height: width / aspectRatio
      };
    }
    if (heightMode === index.MEASURE_MODE_EXACTLY) {
      return {
        width: height5 * aspectRatio
      };
    }
    return {};
  };
};
var linesWidth = function linesWidth2(node) {
  if (!node.lines)
    return 0;
  return Math.max.apply(Math, [0].concat(node.lines.map(function(line2) {
    return line2.xAdvance;
  })));
};
var linesHeight = function linesHeight2(node) {
  if (!node.lines)
    return -1;
  return node.lines.reduce(function(acc, line2) {
    return acc + line2.box.height;
  }, 0);
};
var ALIGNMENT_FACTORS2 = {
  center: 0.5,
  right: 1
};
var measureText = function measureText2(page, node, fontStore2) {
  return function(width, widthMode, height5) {
    if (widthMode === index.MEASURE_MODE_EXACTLY) {
      if (!node.lines)
        node.lines = layoutText2(node, width, height5, fontStore2);
      return {
        height: linesHeight(node)
      };
    }
    if (widthMode === index.MEASURE_MODE_AT_MOST) {
      var _node$style;
      var alignFactor = ALIGNMENT_FACTORS2[(_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.textAlign] || 0;
      if (!node.lines) {
        node.lines = layoutText2(node, width, height5, fontStore2);
        node.alignOffset = (width - linesWidth(node)) * alignFactor;
      }
      return {
        height: linesHeight(node),
        width: Math.min(width, linesWidth(node))
      };
    }
    return {};
  };
};
var getRatio = function getRatio2(node) {
  var _node$image;
  return (_node$image = node.image) !== null && _node$image !== void 0 && _node$image.data ? node.image.width / node.image.height : 1;
};
var isHeightAuto = function isHeightAuto2(page) {
  var _page$box;
  return isNil((_page$box = page.box) === null || _page$box === void 0 ? void 0 : _page$box.height);
};
var SAFETY_HEIGHT$1 = 10;
var measureImage = function measureImage2(page, node) {
  return function(width, widthMode, height5, heightMode) {
    var imageRatio = getRatio(node);
    var imageMargin = getMargin3(node);
    var pagePadding = getPadding(page);
    var pageArea = isHeightAuto(page) ? Infinity : page.box.height - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT$1;
    if (!node.image)
      return {
        width: 0,
        height: 0
      };
    if (widthMode === index.MEASURE_MODE_EXACTLY && heightMode === index.MEASURE_MODE_UNDEFINED) {
      var scaledHeight = width / imageRatio;
      return {
        height: Math.min(pageArea, scaledHeight)
      };
    }
    if (heightMode === index.MEASURE_MODE_EXACTLY && (widthMode === index.MEASURE_MODE_AT_MOST || widthMode === index.MEASURE_MODE_UNDEFINED)) {
      return {
        width: Math.min(height5 * imageRatio, width)
      };
    }
    if (widthMode === index.MEASURE_MODE_EXACTLY && heightMode === index.MEASURE_MODE_AT_MOST) {
      var _scaledHeight = width / imageRatio;
      return {
        height: Math.min(height5, pageArea, _scaledHeight)
      };
    }
    if (widthMode === index.MEASURE_MODE_AT_MOST && heightMode === index.MEASURE_MODE_AT_MOST) {
      if (imageRatio > 1) {
        return {
          width,
          height: Math.min(width / imageRatio, height5)
        };
      }
      return {
        height: height5,
        width: Math.min(height5 * imageRatio, width)
      };
    }
    return {
      height: height5,
      width
    };
  };
};
var SAFETY_HEIGHT = 10;
var getMax = function getMax2(values) {
  return Math.max.apply(Math, [-Infinity].concat(values));
};
var measureCtx = function measureCtx2() {
  var ctx = {};
  var points = [];
  var nil = function nil2() {
    return ctx;
  };
  var addPoint = function addPoint2(x, y) {
    return points.push([x, y]);
  };
  var moveTo2 = function moveTo3() {
    addPoint.apply(void 0, arguments);
    return ctx;
  };
  var rect2 = function rect3(x, y, w, h2) {
    addPoint(x, y);
    addPoint(x + w, y);
    addPoint(x, y + h2);
    addPoint(x + w, y + h2);
    return ctx;
  };
  var ellipse2 = function ellipse3(x, y, rx, ry) {
    ry = ry || rx;
    addPoint(x - rx, y - ry);
    addPoint(x + rx, y - ry);
    addPoint(x + rx, y + ry);
    addPoint(x - rx, y + ry);
    return ctx;
  };
  var polygon2 = function polygon3() {
    points.push.apply(points, arguments);
    return ctx;
  };
  ctx.rect = rect2;
  ctx.moveTo = moveTo2;
  ctx.lineTo = moveTo2;
  ctx.circle = ellipse2;
  ctx.polygon = polygon2;
  ctx.ellipse = ellipse2;
  ctx.roundedRect = rect2;
  ctx.text = nil;
  ctx.path = nil;
  ctx.lineWidth = nil;
  ctx.bezierCurveTo = nil;
  ctx.quadraticCurveTo = nil;
  ctx.scale = nil;
  ctx.rotate = nil;
  ctx.translate = nil;
  ctx.dash = nil;
  ctx.clip = nil;
  ctx.save = nil;
  ctx.fill = nil;
  ctx.font = nil;
  ctx.stroke = nil;
  ctx.lineCap = nil;
  ctx.opacity = nil;
  ctx.restore = nil;
  ctx.lineJoin = nil;
  ctx.fontSize = nil;
  ctx.fillColor = nil;
  ctx.miterLimit = nil;
  ctx.strokeColor = nil;
  ctx.fillOpacity = nil;
  ctx.strokeOpacity = nil;
  ctx.linearGradient = nil;
  ctx.radialGradient = nil;
  ctx.getWidth = function() {
    return getMax(points.map(function(p) {
      return p[0];
    }));
  };
  ctx.getHeight = function() {
    return getMax(points.map(function(p) {
      return p[1];
    }));
  };
  return ctx;
};
var measureCanvas2 = function measureCanvas3(page, node) {
  return function() {
    var imageMargin = getMargin3(node);
    var pagePadding = getPadding(page);
    var pageArea = isHeightAuto(page) ? Infinity : page.box.height - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT;
    var ctx = measureCtx();
    node.props.paint(ctx);
    var width = ctx.getWidth();
    var height5 = Math.min(pageArea, ctx.getHeight());
    return {
      height: height5,
      width
    };
  };
};
var YOGA_CONFIG = index.Config.create();
YOGA_CONFIG.setPointScaleFactor(0);
var isType$1 = function isType3(type) {
  return function(node) {
    return node.type === type;
  };
};
var isSvg2 = isType$1(Svg);
var isText$2 = isType$1(Text);
var isNote = isType$1(Note);
var isPage = isType$1(Page);
var isImage3 = isType$1(Image);
var isCanvas = isType$1(Canvas);
var isTextInstance$1 = isType$1(TextInstance);
var setNodeHeight = function setNodeHeight2(node) {
  var value2 = isPage(node) ? node.box.height : node.style.height;
  return setHeight(value2);
};
var setYogaValues = function setYogaValues2(node) {
  compose(setNodeHeight(node), setWidth(node.style.width), setMinWidth(node.style.minWidth), setMaxWidth(node.style.maxWidth), setMinHeight(node.style.minHeight), setMaxHeight(node.style.maxHeight), setMarginTop(node.style.marginTop), setMarginRight(node.style.marginRight), setMarginBottom(node.style.marginBottom), setMarginLeft(node.style.marginLeft), setPaddingTop(node.style.paddingTop), setPaddingRight(node.style.paddingRight), setPaddingBottom(node.style.paddingBottom), setPaddingLeft(node.style.paddingLeft), setPositionType(node.style.position), setPositionTop(node.style.top), setPositionRight(node.style.right), setPositionBottom(node.style.bottom), setPositionLeft(node.style.left), setBorderTop(node.style.borderTopWidth), setBorderRight(node.style.borderRightWidth), setBorderBottom(node.style.borderBottomWidth), setBorderLeft(node.style.borderLeftWidth), setDisplay(node.style.display), setFlexDirection(node.style.flexDirection), setAlignSelf(node.style.alignSelf), setAlignContent(node.style.alignContent), setAlignItems(node.style.alignItems), setJustifyContent(node.style.justifyContent), setFlexWrap(node.style.flexWrap), setOverflow(node.style.overflow), setAspectRatio(node.style.aspectRatio), setFlexBasis(node.style.flexBasis), setFlexGrow(node.style.flexGrow), setFlexShrink(node.style.flexShrink), setRowGap(node.style.rowGap), setColumnGap(node.style.columnGap))(node);
};
var insertYogaNodes = function insertYogaNodes2(parent) {
  return function(child) {
    parent.insertChild(child.yogaNode, parent.getChildCount());
    return child;
  };
};
var setMeasureFunc = function setMeasureFunc2(node, page, fontStore2) {
  var yogaNode = node.yogaNode;
  if (isText$2(node)) {
    yogaNode.setMeasureFunc(measureText(page, node, fontStore2));
  }
  if (isImage3(node)) {
    yogaNode.setMeasureFunc(measureImage(page, node));
  }
  if (isCanvas(node)) {
    yogaNode.setMeasureFunc(measureCanvas2(page, node));
  }
  if (isSvg2(node)) {
    yogaNode.setMeasureFunc(measureCanvas$1(page, node));
  }
  return node;
};
var isLayoutElement = function isLayoutElement2(node) {
  return !isText$2(node) && !isNote(node) && !isSvg2(node);
};
var createYogaNodes = function createYogaNodes2(page, fontStore2) {
  return function(node) {
    var yogaNode = index.Node.createWithConfig(YOGA_CONFIG);
    var result = Object.assign({}, node, {
      yogaNode
    });
    setYogaValues(result);
    if (isLayoutElement(node) && node.children) {
      var resolveChild = compose(insertYogaNodes(yogaNode), createYogaNodes2(page, fontStore2));
      result.children = node.children.map(resolveChild);
    }
    setMeasureFunc(result, page, fontStore2);
    return result;
  };
};
var calculateLayout = function calculateLayout2(page) {
  page.yogaNode.calculateLayout();
  return page;
};
var persistDimensions = function persistDimensions2(node) {
  if (isTextInstance$1(node))
    return node;
  var box = Object.assign(getPadding(node), getMargin3(node), getBorderWidth(node), getPosition(node), getDimension(node));
  var newNode = Object.assign({}, node, {
    box
  });
  if (!node.children)
    return newNode;
  var children = node.children.map(persistDimensions2);
  return Object.assign({}, newNode, {
    children
  });
};
var destroyYogaNodes = function destroyYogaNodes2(node) {
  var newNode = Object.assign({}, node);
  delete newNode.yogaNode;
  if (!node.children)
    return newNode;
  var children = node.children.map(destroyYogaNodes2);
  return Object.assign({}, newNode, {
    children
  });
};
var freeYogaNodes = function freeYogaNodes2(node) {
  if (node.yogaNode)
    node.yogaNode.freeRecursive();
  return node;
};
var resolvePageDimensions = function resolvePageDimensions2(page, fontStore2) {
  if (isNil(page))
    return null;
  return compose(destroyYogaNodes, freeYogaNodes, persistDimensions, calculateLayout, createYogaNodes(page, fontStore2))(page);
};
var resolveDimensions = function resolveDimensions2(node, fontStore2) {
  if (!node.children)
    return node;
  var resolveChild = function resolveChild2(child) {
    return resolvePageDimensions(child, fontStore2);
  };
  var children = node.children.map(resolveChild);
  return Object.assign({}, node, {
    children
  });
};
var isText$1 = function isText(node) {
  return node.type === Text;
};
var SAFTY_THRESHOLD = 1e-3;
var assingChildren = function assingChildren2(children, node) {
  return Object.assign({}, node, {
    children
  });
};
var getTop2 = function getTop3(node) {
  var _node$box;
  return ((_node$box = node.box) === null || _node$box === void 0 ? void 0 : _node$box.top) || 0;
};
var allFixed = function allFixed2(nodes) {
  return nodes.every(isFixed);
};
var isDynamic = function isDynamic2(node) {
  var _node$props;
  return !isNil((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.render);
};
var relayoutPage = compose(resolveTextLayout, resolveInheritance, resolvePageDimensions);
var warnUnavailableSpace = function warnUnavailableSpace2(node) {
  console.warn("Node of type " + node.type + " can't wrap between pages and it's bigger than available page height");
};
var splitNodes = function splitNodes2(height5, contentArea, nodes) {
  var currentChildren = [];
  var nextChildren = [];
  for (var i = 0; i < nodes.length; i += 1) {
    var child = nodes[i];
    var futureNodes = nodes.slice(i + 1);
    var futureFixedNodes = futureNodes.filter(isFixed);
    var nodeTop = getTop2(child);
    var nodeHeight = child.box.height;
    var isOutside = height5 <= nodeTop;
    var shouldBreak$1 = shouldBreak(child, futureNodes, height5);
    var shouldSplit = height5 + SAFTY_THRESHOLD < nodeTop + nodeHeight;
    var canWrap = getWrap(child);
    var fitsInsidePage = nodeHeight <= contentArea;
    if (isFixed(child)) {
      nextChildren.push(child);
      currentChildren.push(child);
      continue;
    }
    if (isOutside) {
      var box = Object.assign({}, child.box, {
        top: child.box.top - height5
      });
      var next2 = Object.assign({}, child, {
        box
      });
      nextChildren.push(next2);
      continue;
    }
    if (!fitsInsidePage && !canWrap) {
      currentChildren.push(child);
      nextChildren.push.apply(nextChildren, futureNodes);
      warnUnavailableSpace(child);
      break;
    }
    if (shouldBreak$1) {
      var _box = Object.assign({}, child.box, {
        top: child.box.top - height5
      });
      var props = Object.assign({}, child.props, {
        wrap: true,
        break: false
      });
      var _next = Object.assign({}, child, {
        box: _box,
        props
      });
      currentChildren.push.apply(currentChildren, futureFixedNodes);
      nextChildren.push.apply(nextChildren, [_next].concat(futureNodes));
      break;
    }
    if (shouldSplit) {
      var _split = split(child, height5, contentArea), currentChild = _split[0], nextChild = _split[1];
      if (child.children.length > 0 && currentChild.children.length === 0) {
        var _box2 = Object.assign({}, child.box, {
          top: child.box.top - height5
        });
        var _next2 = Object.assign({}, child, {
          box: _box2
        });
        currentChildren.push.apply(currentChildren, futureFixedNodes);
        nextChildren.push.apply(nextChildren, [_next2].concat(futureNodes));
        break;
      }
      if (currentChild)
        currentChildren.push(currentChild);
      if (nextChild)
        nextChildren.push(nextChild);
      continue;
    }
    currentChildren.push(child);
  }
  return [currentChildren, nextChildren];
};
var splitChildren = function splitChildren2(height5, contentArea, node) {
  var children = node.children || [];
  var availableHeight = height5 - getTop2(node);
  return splitNodes(availableHeight, contentArea, children);
};
var splitView = function splitView2(node, height5, contentArea) {
  var _splitNode = splitNode(node, height5), currentNode = _splitNode[0], nextNode = _splitNode[1];
  var _splitChildren = splitChildren(height5, contentArea, node), currentChilds = _splitChildren[0], nextChildren = _splitChildren[1];
  return [assingChildren(currentChilds, currentNode), assingChildren(nextChildren, nextNode)];
};
var split = function split2(node, height5, contentArea) {
  return isText$1(node) ? splitText(node, height5) : splitView(node, height5, contentArea);
};
var shouldResolveDynamicNodes = function shouldResolveDynamicNodes2(node) {
  var children = node.children || [];
  return isDynamic(node) || children.some(shouldResolveDynamicNodes2);
};
var resolveDynamicNodes = function resolveDynamicNodes2(props, node) {
  var isNodeDynamic = isDynamic(node);
  var resolveChildren3 = function resolveChildren4(children2) {
    if (children2 === void 0) {
      children2 = [];
    }
    if (isNodeDynamic) {
      var res = node.props.render(props);
      return createInstances(res).filter(Boolean).map(function(n) {
        return resolveDynamicNodes2(props, n);
      });
    }
    return children2.map(function(c2) {
      return resolveDynamicNodes2(props, c2);
    });
  };
  var resetHeight = isNodeDynamic && isText$1(node);
  var box = resetHeight ? _extends7({}, node.box, {
    height: 0
  }) : node.box;
  var children = resolveChildren3(node.children);
  var lines = isNodeDynamic ? null : node.lines;
  return Object.assign({}, node, {
    box,
    lines,
    children
  });
};
var resolveDynamicPage = function resolveDynamicPage2(props, page, fontStore2) {
  if (shouldResolveDynamicNodes(page)) {
    var resolvedPage = resolveDynamicNodes(props, page);
    return relayoutPage(resolvedPage, fontStore2);
  }
  return page;
};
var splitPage = function splitPage2(page, pageNumber, fontStore2) {
  var wrapArea = getWrapArea(page);
  var contentArea = getContentArea(page);
  var dynamicPage = resolveDynamicPage({
    pageNumber
  }, page, fontStore2);
  var height5 = page.style.height;
  var _splitNodes = splitNodes(wrapArea, contentArea, dynamicPage.children), currentChilds = _splitNodes[0], nextChilds = _splitNodes[1];
  var relayout = function relayout2(node) {
    return relayoutPage(node, fontStore2);
  };
  var currentBox = _extends7({}, page.box, {
    height: height5
  });
  var currentPage = relayout(Object.assign({}, page, {
    box: currentBox,
    children: currentChilds
  }));
  if (nextChilds.length === 0 || allFixed(nextChilds))
    return [currentPage, null];
  var nextBox = omit("height", page.box);
  var nextProps = omit("bookmark", page.props);
  var nextPage = relayout(Object.assign({}, page, {
    props: nextProps,
    box: nextBox,
    children: nextChilds
  }));
  return [currentPage, nextPage];
};
var resolvePageIndices = function resolvePageIndices2(fontStore2, page, pageNumber, pages) {
  var totalPages = pages.length;
  var props = {
    totalPages,
    pageNumber: pageNumber + 1,
    subPageNumber: page.subPageNumber + 1,
    subPageTotalPages: page.subPageTotalPages
  };
  return resolveDynamicPage(props, page, fontStore2);
};
var assocSubPageData = function assocSubPageData2(subpages) {
  return subpages.map(function(page, i) {
    return _extends7({}, page, {
      subPageNumber: i,
      subPageTotalPages: subpages.length
    });
  });
};
var dissocSubPageData = function dissocSubPageData2(page) {
  return omit(["subPageNumber", "subPageTotalPages"], page);
};
var paginate = function paginate2(page, pageNumber, fontStore2) {
  var _page$props;
  if (!page)
    return [];
  if (((_page$props = page.props) === null || _page$props === void 0 ? void 0 : _page$props.wrap) === false)
    return [page];
  var splittedPage = splitPage(page, pageNumber, fontStore2);
  var pages = [splittedPage[0]];
  var nextPage = splittedPage[1];
  while (nextPage !== null) {
    splittedPage = splitPage(nextPage, pageNumber + pages.length, fontStore2);
    pages.push(splittedPage[0]);
    nextPage = splittedPage[1];
  }
  return pages;
};
var resolvePagination = function resolvePagination2(doc, fontStore2) {
  var pages = [];
  var pageNumber = 1;
  for (var i = 0; i < doc.children.length; i += 1) {
    var page = doc.children[i];
    var subpages = paginate(page, pageNumber, fontStore2);
    subpages = assocSubPageData(subpages);
    pageNumber += subpages.length;
    pages = pages.concat(subpages);
  }
  pages = pages.map(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return dissocSubPageData(resolvePageIndices.apply(void 0, [fontStore2].concat(args)));
  });
  return assingChildren(pages, doc);
};
var resolvePageHorizontalPadding = function resolvePageHorizontalPadding2(container) {
  return function(value2) {
    var match = matchPercent(value2);
    return match ? match.percent * container.width : value2;
  };
};
var resolvePageVerticalPadding = function resolvePageVerticalPadding2(container) {
  return function(value2) {
    var match = matchPercent(value2);
    return match ? match.percent * container.height : value2;
  };
};
var resolvePagePaddings = function resolvePagePaddings2(page) {
  var container = page.style;
  var style = evolve({
    paddingTop: resolvePageVerticalPadding(container),
    paddingLeft: resolvePageHorizontalPadding(container),
    paddingRight: resolvePageHorizontalPadding(container),
    paddingBottom: resolvePageVerticalPadding(container)
  }, page.style);
  return Object.assign({}, page, {
    style
  });
};
var resolvePagesPaddings = function resolvePagesPaddings2(root) {
  if (!root.children)
    return root;
  var children = root.children.map(resolvePagePaddings);
  return Object.assign({}, root, {
    children
  });
};
var resolveRadius = function resolveRadius2(container) {
  return function(value2) {
    if (!value2)
      return void 0;
    var match = matchPercent(value2);
    return match ? match.percent * Math.min(container.width, container.height) : value2;
  };
};
var resolvePercentRadius = function resolvePercentRadius2(node) {
  var style = evolve({
    borderTopLeftRadius: resolveRadius(node.box),
    borderTopRightRadius: resolveRadius(node.box),
    borderBottomRightRadius: resolveRadius(node.box),
    borderBottomLeftRadius: resolveRadius(node.box)
  }, node.style || {});
  var newNode = Object.assign({}, node, {
    style
  });
  if (!node.children)
    return newNode;
  var children = node.children.map(resolvePercentRadius2);
  return Object.assign({}, newNode, {
    children
  });
};
var transformHeight = function transformHeight2(pageArea, height5) {
  var match = matchPercent(height5);
  return match ? match.percent * pageArea : height5;
};
var getPageArea = function getPageArea2(page) {
  var _page$style, _page$style2;
  var pageHeight = page.style.height;
  var pagePaddingTop = ((_page$style = page.style) === null || _page$style === void 0 ? void 0 : _page$style.paddingTop) || 0;
  var pagePaddingBottom = ((_page$style2 = page.style) === null || _page$style2 === void 0 ? void 0 : _page$style2.paddingBottom) || 0;
  return pageHeight - pagePaddingTop - pagePaddingBottom;
};
var resolveNodePercentHeight = function resolveNodePercentHeight2(page, node) {
  var _page$style3, _node$style;
  if (isNil((_page$style3 = page.style) === null || _page$style3 === void 0 ? void 0 : _page$style3.height))
    return node;
  if (isNil((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.height))
    return node;
  var pageArea = getPageArea(page);
  var height5 = transformHeight(pageArea, node.style.height);
  var style = Object.assign({}, node.style, {
    height: height5
  });
  return Object.assign({}, node, {
    style
  });
};
var resolvePagePercentHeight = function resolvePagePercentHeight2(page) {
  if (!page.children)
    return page;
  var resolveChild = function resolveChild2(child) {
    return resolveNodePercentHeight(page, child);
  };
  var children = page.children.map(resolveChild);
  return Object.assign({}, page, {
    children
  });
};
var resolvePercentHeight = function resolvePercentHeight2(root) {
  if (!root.children)
    return root;
  var children = root.children.map(resolvePagePercentHeight);
  return Object.assign({}, root, {
    children
  });
};
var isType4 = function isType5(type) {
  return function(node) {
    return node.type === type;
  };
};
var isLink2 = isType4(Link);
var isText2 = isType4(Text);
var isTextInstance3 = isType4(TextInstance);
var hasRenderProp = function hasRenderProp2(node) {
  var _node$props;
  return !!((_node$props = node.props) !== null && _node$props !== void 0 && _node$props.render);
};
var isTextType = function isTextType2(node) {
  return isText2(node) || isTextInstance3(node);
};
var isTextLink = function isTextLink2(node) {
  var children = node.children || [];
  if (children.every(isTextInstance3))
    return true;
  if (children.every(isText2))
    return false;
  return children.every(isTextType);
};
var wrapText = function wrapText2(node) {
  var textElement = {
    type: Text,
    props: {},
    style: {},
    box: {},
    children: node.children
  };
  return Object.assign({}, node, {
    children: [textElement]
  });
};
var transformLink = function transformLink2(node) {
  if (!isLink2(node))
    return node;
  if (hasRenderProp(node))
    return Object.assign({}, node, {
      type: Text
    });
  if (isTextLink(node))
    return wrapText(node);
  return node;
};
var resolveLinkSubstitution = function resolveLinkSubstitution2(node) {
  if (!node.children)
    return node;
  var resolveChild = compose(transformLink, resolveLinkSubstitution2);
  var children = node.children.map(resolveChild);
  return Object.assign({}, node, {
    children
  });
};
var layout = asyncCompose(resolveZIndex, resolveOrigin, resolvePagination, resolveTextLayout, resolvePercentRadius, resolveDimensions, resolveSvg, resolveAssets, resolveInheritance, resolvePercentHeight, resolvePagesPaddings, resolveStyles3, resolveLinkSubstitution, resolveBookmarks, resolvePageSizes);

// ../node_modules/@react-pdf/renderer/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose4(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}

// ../node_modules/@react-pdf/renderer/lib/react-pdf.browser.es.js
var import_object_assign = __toESM(require_object_assign());
var scheduler = __toESM(require_scheduler());
var import_jsx_runtime = __toESM(require_jsx_runtime());
function getAugmentedNamespace3(n) {
  if (n.__esModule)
    return n;
  var a2 = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a2, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a2;
}
var reactReconciler_production_min = { exports: {} };
var require$$22 = getAugmentedNamespace3(scheduler);
(function(module) {
  module.exports = function $$$reconciler($$$hostConfig) {
    var aa = import_object_assign.default, ba = import_react.default, m2 = require$$22;
    function n(a2) {
      for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
        b += "&args[]=" + encodeURIComponent(arguments[c2]);
      return "Minified React error #" + a2 + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var q2 = ba.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    q2.hasOwnProperty("ReactCurrentDispatcher") || (q2.ReactCurrentDispatcher = {
      current: null
    });
    q2.hasOwnProperty("ReactCurrentBatchConfig") || (q2.ReactCurrentBatchConfig = {
      suspense: null
    });
    var u = "function" === typeof Symbol && Symbol.for, ca = u ? Symbol.for("react.element") : 60103, da = u ? Symbol.for("react.portal") : 60106, ea = u ? Symbol.for("react.fragment") : 60107, fa = u ? Symbol.for("react.strict_mode") : 60108, ha = u ? Symbol.for("react.profiler") : 60114, ia = u ? Symbol.for("react.provider") : 60109, ja = u ? Symbol.for("react.context") : 60110, ka = u ? Symbol.for("react.concurrent_mode") : 60111, la = u ? Symbol.for("react.forward_ref") : 60112, ma = u ? Symbol.for("react.suspense") : 60113, na = u ? Symbol.for("react.suspense_list") : 60120, oa = u ? Symbol.for("react.memo") : 60115, pa = u ? Symbol.for("react.lazy") : 60116;
    var qa = "function" === typeof Symbol && Symbol.iterator;
    function ra(a2) {
      if (null === a2 || "object" !== typeof a2)
        return null;
      a2 = qa && a2[qa] || a2["@@iterator"];
      return "function" === typeof a2 ? a2 : null;
    }
    function sa(a2) {
      if (-1 === a2._status) {
        a2._status = 0;
        var b = a2._ctor;
        b = b();
        a2._result = b;
        b.then(function(b2) {
          0 === a2._status && (b2 = b2.default, a2._status = 1, a2._result = b2);
        }, function(b2) {
          0 === a2._status && (a2._status = 2, a2._result = b2);
        });
      }
    }
    function ta(a2) {
      if (null == a2)
        return null;
      if ("function" === typeof a2)
        return a2.displayName || a2.name || null;
      if ("string" === typeof a2)
        return a2;
      switch (a2) {
        case ea:
          return "Fragment";
        case da:
          return "Portal";
        case ha:
          return "Profiler";
        case fa:
          return "StrictMode";
        case ma:
          return "Suspense";
        case na:
          return "SuspenseList";
      }
      if ("object" === typeof a2)
        switch (a2.$$typeof) {
          case ja:
            return "Context.Consumer";
          case ia:
            return "Context.Provider";
          case la:
            var b = a2.render;
            b = b.displayName || b.name || "";
            return a2.displayName || ("" !== b ? "ForwardRef(" + b + ")" : "ForwardRef");
          case oa:
            return ta(a2.type);
          case pa:
            if (a2 = 1 === a2._status ? a2._result : null)
              return ta(a2);
        }
      return null;
    }
    function ua(a2) {
      var b = a2, c2 = a2;
      if (a2.alternate)
        for (; b.return; )
          b = b.return;
      else {
        a2 = b;
        do
          b = a2, 0 !== (b.effectTag & 1026) && (c2 = b.return), a2 = b.return;
        while (a2);
      }
      return 3 === b.tag ? c2 : null;
    }
    function va(a2) {
      if (ua(a2) !== a2)
        throw Error(n(188));
    }
    function wa(a2) {
      var b = a2.alternate;
      if (!b) {
        b = ua(a2);
        if (null === b)
          throw Error(n(188));
        return b !== a2 ? null : a2;
      }
      for (var c2 = a2, d = b; ; ) {
        var e = c2.return;
        if (null === e)
          break;
        var f = e.alternate;
        if (null === f) {
          d = e.return;
          if (null !== d) {
            c2 = d;
            continue;
          }
          break;
        }
        if (e.child === f.child) {
          for (f = e.child; f; ) {
            if (f === c2)
              return va(e), a2;
            if (f === d)
              return va(e), b;
            f = f.sibling;
          }
          throw Error(n(188));
        }
        if (c2.return !== d.return)
          c2 = e, d = f;
        else {
          for (var g3 = false, l2 = e.child; l2; ) {
            if (l2 === c2) {
              g3 = true;
              c2 = e;
              d = f;
              break;
            }
            if (l2 === d) {
              g3 = true;
              d = e;
              c2 = f;
              break;
            }
            l2 = l2.sibling;
          }
          if (!g3) {
            for (l2 = f.child; l2; ) {
              if (l2 === c2) {
                g3 = true;
                c2 = f;
                d = e;
                break;
              }
              if (l2 === d) {
                g3 = true;
                d = f;
                c2 = e;
                break;
              }
              l2 = l2.sibling;
            }
            if (!g3)
              throw Error(n(189));
          }
        }
        if (c2.alternate !== d)
          throw Error(n(190));
      }
      if (3 !== c2.tag)
        throw Error(n(188));
      return c2.stateNode.current === c2 ? a2 : b;
    }
    function xa(a2) {
      a2 = wa(a2);
      if (!a2)
        return null;
      for (var b = a2; ; ) {
        if (5 === b.tag || 6 === b.tag)
          return b;
        if (b.child)
          b.child.return = b, b = b.child;
        else {
          if (b === a2)
            break;
          for (; !b.sibling; ) {
            if (!b.return || b.return === a2)
              return null;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
      }
      return null;
    }
    function ya(a2) {
      a2 = wa(a2);
      if (!a2)
        return null;
      for (var b = a2; ; ) {
        if (5 === b.tag || 6 === b.tag)
          return b;
        if (b.child && 4 !== b.tag)
          b.child.return = b, b = b.child;
        else {
          if (b === a2)
            break;
          for (; !b.sibling; ) {
            if (!b.return || b.return === a2)
              return null;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
      }
      return null;
    }
    var za = $$$hostConfig.getPublicInstance, Aa = $$$hostConfig.getRootHostContext, Ba = $$$hostConfig.getChildHostContext, Ca = $$$hostConfig.prepareForCommit, Da = $$$hostConfig.resetAfterCommit, Ea = $$$hostConfig.createInstance, Fa = $$$hostConfig.appendInitialChild, Ga = $$$hostConfig.finalizeInitialChildren, Ia = $$$hostConfig.prepareUpdate, Ja = $$$hostConfig.shouldSetTextContent, Ka = $$$hostConfig.shouldDeprioritizeSubtree, La = $$$hostConfig.createTextInstance, Ma = $$$hostConfig.setTimeout, Na = $$$hostConfig.clearTimeout, Oa = $$$hostConfig.noTimeout, Pa = $$$hostConfig.isPrimaryRenderer, Qa = $$$hostConfig.supportsMutation, Ra = $$$hostConfig.supportsPersistence, Sa = $$$hostConfig.supportsHydration, Ta = $$$hostConfig.appendChild, Ua = $$$hostConfig.appendChildToContainer, Va = $$$hostConfig.commitTextUpdate, Wa = $$$hostConfig.commitMount, Xa = $$$hostConfig.commitUpdate, Ya = $$$hostConfig.insertBefore, Za = $$$hostConfig.insertInContainerBefore, $a = $$$hostConfig.removeChild, ab = $$$hostConfig.removeChildFromContainer, bb = $$$hostConfig.resetTextContent, cb = $$$hostConfig.hideInstance, db = $$$hostConfig.hideTextInstance, eb = $$$hostConfig.unhideInstance, fb = $$$hostConfig.unhideTextInstance, gb = $$$hostConfig.cloneInstance, hb = $$$hostConfig.createContainerChildSet, ib = $$$hostConfig.appendChildToContainerChildSet, kb = $$$hostConfig.finalizeContainerChildren, lb = $$$hostConfig.replaceContainerChildren, mb = $$$hostConfig.cloneHiddenInstance, nb = $$$hostConfig.cloneHiddenTextInstance, ob = $$$hostConfig.canHydrateInstance, pb = $$$hostConfig.canHydrateTextInstance, qb = $$$hostConfig.isSuspenseInstancePending, rb = $$$hostConfig.isSuspenseInstanceFallback, sb = $$$hostConfig.getNextHydratableSibling, tb = $$$hostConfig.getFirstHydratableChild, ub = $$$hostConfig.hydrateInstance, vb = $$$hostConfig.hydrateTextInstance, wb = $$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance, xb = $$$hostConfig.commitHydratedContainer, yb = $$$hostConfig.commitHydratedSuspenseInstance, zb = /^(.*)[\\\/]/;
    function Ab(a2) {
      var b = "";
      do {
        a:
          switch (a2.tag) {
            case 3:
            case 4:
            case 6:
            case 7:
            case 10:
            case 9:
              var c2 = "";
              break a;
            default:
              var d = a2._debugOwner, e = a2._debugSource, f = ta(a2.type);
              c2 = null;
              d && (c2 = ta(d.type));
              d = f;
              f = "";
              e ? f = " (at " + e.fileName.replace(zb, "") + ":" + e.lineNumber + ")" : c2 && (f = " (created by " + c2 + ")");
              c2 = "\n    in " + (d || "Unknown") + f;
          }
        b += c2;
        a2 = a2.return;
      } while (a2);
      return b;
    }
    var Bb = [], Cb = -1;
    function y(a2) {
      0 > Cb || (a2.current = Bb[Cb], Bb[Cb] = null, Cb--);
    }
    function z2(a2, b) {
      Cb++;
      Bb[Cb] = a2.current;
      a2.current = b;
    }
    var Db = {}, A2 = {
      current: Db
    }, B = {
      current: false
    }, Eb = Db;
    function Fb(a2, b) {
      var c2 = a2.type.contextTypes;
      if (!c2)
        return Db;
      var d = a2.stateNode;
      if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)
        return d.__reactInternalMemoizedMaskedChildContext;
      var e = {}, f;
      for (f in c2)
        e[f] = b[f];
      d && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b, a2.__reactInternalMemoizedMaskedChildContext = e);
      return e;
    }
    function C2(a2) {
      a2 = a2.childContextTypes;
      return null !== a2 && void 0 !== a2;
    }
    function Gb(a2) {
      y(B);
      y(A2);
    }
    function Hb(a2) {
      y(B);
      y(A2);
    }
    function Ib(a2, b, c2) {
      if (A2.current !== Db)
        throw Error(n(168));
      z2(A2, b);
      z2(B, c2);
    }
    function Jb(a2, b, c2) {
      var d = a2.stateNode;
      a2 = b.childContextTypes;
      if ("function" !== typeof d.getChildContext)
        return c2;
      d = d.getChildContext();
      for (var e in d)
        if (!(e in a2))
          throw Error(n(108, ta(b) || "Unknown", e));
      return aa({}, c2, {}, d);
    }
    function Kb(a2) {
      var b = a2.stateNode;
      b = b && b.__reactInternalMemoizedMergedChildContext || Db;
      Eb = A2.current;
      z2(A2, b);
      z2(B, B.current);
      return true;
    }
    function Lb(a2, b, c2) {
      var d = a2.stateNode;
      if (!d)
        throw Error(n(169));
      c2 ? (b = Jb(a2, b, Eb), d.__reactInternalMemoizedMergedChildContext = b, y(B), y(A2), z2(A2, b)) : y(B);
      z2(B, c2);
    }
    var Mb = m2.unstable_runWithPriority, Nb = m2.unstable_scheduleCallback, Ob = m2.unstable_cancelCallback, Pb = m2.unstable_shouldYield, Qb = m2.unstable_requestPaint, Tb = m2.unstable_now, Ub = m2.unstable_getCurrentPriorityLevel, Vb = m2.unstable_ImmediatePriority, Wb = m2.unstable_UserBlockingPriority, Xb = m2.unstable_NormalPriority, Yb = m2.unstable_LowPriority, Zb = m2.unstable_IdlePriority, $b = {}, ac = void 0 !== Qb ? Qb : function() {
    }, bc = null, cc = null, dc = false, ec = Tb(), E2 = 1e4 > ec ? Tb : function() {
      return Tb() - ec;
    };
    function fc() {
      switch (Ub()) {
        case Vb:
          return 99;
        case Wb:
          return 98;
        case Xb:
          return 97;
        case Yb:
          return 96;
        case Zb:
          return 95;
        default:
          throw Error(n(332));
      }
    }
    function gc(a2) {
      switch (a2) {
        case 99:
          return Vb;
        case 98:
          return Wb;
        case 97:
          return Xb;
        case 96:
          return Yb;
        case 95:
          return Zb;
        default:
          throw Error(n(332));
      }
    }
    function hc(a2, b) {
      a2 = gc(a2);
      return Mb(a2, b);
    }
    function ic(a2, b, c2) {
      a2 = gc(a2);
      return Nb(a2, b, c2);
    }
    function jc(a2) {
      null === bc ? (bc = [a2], cc = Nb(Vb, kc)) : bc.push(a2);
      return $b;
    }
    function F() {
      if (null !== cc) {
        var a2 = cc;
        cc = null;
        Ob(a2);
      }
      kc();
    }
    function kc() {
      if (!dc && null !== bc) {
        dc = true;
        var a2 = 0;
        try {
          var b = bc;
          hc(99, function() {
            for (; a2 < b.length; a2++) {
              var c2 = b[a2];
              do
                c2 = c2(true);
              while (null !== c2);
            }
          });
          bc = null;
        } catch (c2) {
          throw null !== bc && (bc = bc.slice(a2 + 1)), Nb(Vb, F), c2;
        } finally {
          dc = false;
        }
      }
    }
    var lc = 3;
    function mc(a2, b, c2) {
      c2 /= 10;
      return 1073741821 - (((1073741821 - a2 + b / 10) / c2 | 0) + 1) * c2;
    }
    function nc(a2, b) {
      return a2 === b && (0 !== a2 || 1 / a2 === 1 / b) || a2 !== a2 && b !== b;
    }
    var oc = "function" === typeof Object.is ? Object.is : nc, pc = Object.prototype.hasOwnProperty;
    function qc(a2, b) {
      if (oc(a2, b))
        return true;
      if ("object" !== typeof a2 || null === a2 || "object" !== typeof b || null === b)
        return false;
      var c2 = Object.keys(a2), d = Object.keys(b);
      if (c2.length !== d.length)
        return false;
      for (d = 0; d < c2.length; d++)
        if (!pc.call(b, c2[d]) || !oc(a2[c2[d]], b[c2[d]]))
          return false;
      return true;
    }
    function rc(a2, b) {
      if (a2 && a2.defaultProps) {
        b = aa({}, b);
        a2 = a2.defaultProps;
        for (var c2 in a2)
          void 0 === b[c2] && (b[c2] = a2[c2]);
      }
      return b;
    }
    var sc = {
      current: null
    }, tc = null, uc = null, vc = null;
    function wc() {
      vc = uc = tc = null;
    }
    function xc(a2, b) {
      var c2 = a2.type._context;
      Pa ? (z2(sc, c2._currentValue), c2._currentValue = b) : (z2(sc, c2._currentValue2), c2._currentValue2 = b);
    }
    function yc(a2) {
      var b = sc.current;
      y(sc);
      a2 = a2.type._context;
      Pa ? a2._currentValue = b : a2._currentValue2 = b;
    }
    function zc(a2, b) {
      for (; null !== a2; ) {
        var c2 = a2.alternate;
        if (a2.childExpirationTime < b)
          a2.childExpirationTime = b, null !== c2 && c2.childExpirationTime < b && (c2.childExpirationTime = b);
        else if (null !== c2 && c2.childExpirationTime < b)
          c2.childExpirationTime = b;
        else
          break;
        a2 = a2.return;
      }
    }
    function Ac(a2, b) {
      tc = a2;
      vc = uc = null;
      a2 = a2.dependencies;
      null !== a2 && null !== a2.firstContext && (a2.expirationTime >= b && (Bc = true), a2.firstContext = null);
    }
    function Cc(a2, b) {
      if (vc !== a2 && false !== b && 0 !== b) {
        if ("number" !== typeof b || 1073741823 === b)
          vc = a2, b = 1073741823;
        b = {
          context: a2,
          observedBits: b,
          next: null
        };
        if (null === uc) {
          if (null === tc)
            throw Error(n(308));
          uc = b;
          tc.dependencies = {
            expirationTime: 0,
            firstContext: b,
            responders: null
          };
        } else
          uc = uc.next = b;
      }
      return Pa ? a2._currentValue : a2._currentValue2;
    }
    var Dc = false;
    function Ec(a2) {
      return {
        baseState: a2,
        firstUpdate: null,
        lastUpdate: null,
        firstCapturedUpdate: null,
        lastCapturedUpdate: null,
        firstEffect: null,
        lastEffect: null,
        firstCapturedEffect: null,
        lastCapturedEffect: null
      };
    }
    function Fc(a2) {
      return {
        baseState: a2.baseState,
        firstUpdate: a2.firstUpdate,
        lastUpdate: a2.lastUpdate,
        firstCapturedUpdate: null,
        lastCapturedUpdate: null,
        firstEffect: null,
        lastEffect: null,
        firstCapturedEffect: null,
        lastCapturedEffect: null
      };
    }
    function Gc(a2, b) {
      return {
        expirationTime: a2,
        suspenseConfig: b,
        tag: 0,
        payload: null,
        callback: null,
        next: null,
        nextEffect: null
      };
    }
    function Hc(a2, b) {
      null === a2.lastUpdate ? a2.firstUpdate = a2.lastUpdate = b : (a2.lastUpdate.next = b, a2.lastUpdate = b);
    }
    function Ic(a2, b) {
      var c2 = a2.alternate;
      if (null === c2) {
        var d = a2.updateQueue;
        var e = null;
        null === d && (d = a2.updateQueue = Ec(a2.memoizedState));
      } else
        d = a2.updateQueue, e = c2.updateQueue, null === d ? null === e ? (d = a2.updateQueue = Ec(a2.memoizedState), e = c2.updateQueue = Ec(c2.memoizedState)) : d = a2.updateQueue = Fc(e) : null === e && (e = c2.updateQueue = Fc(d));
      null === e || d === e ? Hc(d, b) : null === d.lastUpdate || null === e.lastUpdate ? (Hc(d, b), Hc(e, b)) : (Hc(d, b), e.lastUpdate = b);
    }
    function Jc(a2, b) {
      var c2 = a2.updateQueue;
      c2 = null === c2 ? a2.updateQueue = Ec(a2.memoizedState) : Kc(a2, c2);
      null === c2.lastCapturedUpdate ? c2.firstCapturedUpdate = c2.lastCapturedUpdate = b : (c2.lastCapturedUpdate.next = b, c2.lastCapturedUpdate = b);
    }
    function Kc(a2, b) {
      var c2 = a2.alternate;
      null !== c2 && b === c2.updateQueue && (b = a2.updateQueue = Fc(b));
      return b;
    }
    function Lc(a2, b, c2, d, e, f) {
      switch (c2.tag) {
        case 1:
          return a2 = c2.payload, "function" === typeof a2 ? a2.call(f, d, e) : a2;
        case 3:
          a2.effectTag = a2.effectTag & -4097 | 64;
        case 0:
          a2 = c2.payload;
          e = "function" === typeof a2 ? a2.call(f, d, e) : a2;
          if (null === e || void 0 === e)
            break;
          return aa({}, d, e);
        case 2:
          Dc = true;
      }
      return d;
    }
    function Nc(a2, b, c2, d, e) {
      Dc = false;
      b = Kc(a2, b);
      for (var f = b.baseState, g3 = null, l2 = 0, h2 = b.firstUpdate, k = f; null !== h2; ) {
        var p = h2.expirationTime;
        p < e ? (null === g3 && (g3 = h2, f = k), l2 < p && (l2 = p)) : (Oc(p, h2.suspenseConfig), k = Lc(a2, b, h2, k, c2, d), null !== h2.callback && (a2.effectTag |= 32, h2.nextEffect = null, null === b.lastEffect ? b.firstEffect = b.lastEffect = h2 : (b.lastEffect.nextEffect = h2, b.lastEffect = h2)));
        h2 = h2.next;
      }
      p = null;
      for (h2 = b.firstCapturedUpdate; null !== h2; ) {
        var D = h2.expirationTime;
        D < e ? (null === p && (p = h2, null === g3 && (f = k)), l2 < D && (l2 = D)) : (k = Lc(a2, b, h2, k, c2, d), null !== h2.callback && (a2.effectTag |= 32, h2.nextEffect = null, null === b.lastCapturedEffect ? b.firstCapturedEffect = b.lastCapturedEffect = h2 : (b.lastCapturedEffect.nextEffect = h2, b.lastCapturedEffect = h2)));
        h2 = h2.next;
      }
      null === g3 && (b.lastUpdate = null);
      null === p ? b.lastCapturedUpdate = null : a2.effectTag |= 32;
      null === g3 && null === p && (f = k);
      b.baseState = f;
      b.firstUpdate = g3;
      b.firstCapturedUpdate = p;
      Pc(l2);
      a2.expirationTime = l2;
      a2.memoizedState = k;
    }
    function Qc(a2, b, c2) {
      null !== b.firstCapturedUpdate && (null !== b.lastUpdate && (b.lastUpdate.next = b.firstCapturedUpdate, b.lastUpdate = b.lastCapturedUpdate), b.firstCapturedUpdate = b.lastCapturedUpdate = null);
      Rc(b.firstEffect, c2);
      b.firstEffect = b.lastEffect = null;
      Rc(b.firstCapturedEffect, c2);
      b.firstCapturedEffect = b.lastCapturedEffect = null;
    }
    function Rc(a2, b) {
      for (; null !== a2; ) {
        var c2 = a2.callback;
        if (null !== c2) {
          a2.callback = null;
          var d = b;
          if ("function" !== typeof c2)
            throw Error(n(191, c2));
          c2.call(d);
        }
        a2 = a2.nextEffect;
      }
    }
    var Sc = q2.ReactCurrentBatchConfig, Tc = new ba.Component().refs;
    function Uc(a2, b, c2, d) {
      b = a2.memoizedState;
      c2 = c2(d, b);
      c2 = null === c2 || void 0 === c2 ? b : aa({}, b, c2);
      a2.memoizedState = c2;
      d = a2.updateQueue;
      null !== d && 0 === a2.expirationTime && (d.baseState = c2);
    }
    var Xc = {
      isMounted: function isMounted(a2) {
        return (a2 = a2._reactInternalFiber) ? ua(a2) === a2 : false;
      },
      enqueueSetState: function enqueueSetState(a2, b, c2) {
        a2 = a2._reactInternalFiber;
        var d = G2(), e = Sc.suspense;
        d = Vc(d, a2, e);
        e = Gc(d, e);
        e.payload = b;
        void 0 !== c2 && null !== c2 && (e.callback = c2);
        Ic(a2, e);
        Wc(a2, d);
      },
      enqueueReplaceState: function enqueueReplaceState(a2, b, c2) {
        a2 = a2._reactInternalFiber;
        var d = G2(), e = Sc.suspense;
        d = Vc(d, a2, e);
        e = Gc(d, e);
        e.tag = 1;
        e.payload = b;
        void 0 !== c2 && null !== c2 && (e.callback = c2);
        Ic(a2, e);
        Wc(a2, d);
      },
      enqueueForceUpdate: function enqueueForceUpdate(a2, b) {
        a2 = a2._reactInternalFiber;
        var c2 = G2(), d = Sc.suspense;
        c2 = Vc(c2, a2, d);
        d = Gc(c2, d);
        d.tag = 2;
        void 0 !== b && null !== b && (d.callback = b);
        Ic(a2, d);
        Wc(a2, c2);
      }
    };
    function Yc(a2, b, c2, d, e, f, g3) {
      a2 = a2.stateNode;
      return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d, f, g3) : b.prototype && b.prototype.isPureReactComponent ? !qc(c2, d) || !qc(e, f) : true;
    }
    function Zc(a2, b, c2) {
      var d = false, e = Db;
      var f = b.contextType;
      "object" === typeof f && null !== f ? f = Cc(f) : (e = C2(b) ? Eb : A2.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Fb(a2, e) : Db);
      b = new b(c2, f);
      a2.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
      b.updater = Xc;
      a2.stateNode = b;
      b._reactInternalFiber = a2;
      d && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e, a2.__reactInternalMemoizedMaskedChildContext = f);
      return b;
    }
    function $c(a2, b, c2, d) {
      a2 = b.state;
      "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c2, d);
      "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c2, d);
      b.state !== a2 && Xc.enqueueReplaceState(b, b.state, null);
    }
    function ad(a2, b, c2, d) {
      var e = a2.stateNode;
      e.props = c2;
      e.state = a2.memoizedState;
      e.refs = Tc;
      var f = b.contextType;
      "object" === typeof f && null !== f ? e.context = Cc(f) : (f = C2(b) ? Eb : A2.current, e.context = Fb(a2, f));
      f = a2.updateQueue;
      null !== f && (Nc(a2, f, c2, e, d), e.state = a2.memoizedState);
      f = b.getDerivedStateFromProps;
      "function" === typeof f && (Uc(a2, b, f, c2), e.state = a2.memoizedState);
      "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Xc.enqueueReplaceState(e, e.state, null), f = a2.updateQueue, null !== f && (Nc(a2, f, c2, e, d), e.state = a2.memoizedState));
      "function" === typeof e.componentDidMount && (a2.effectTag |= 4);
    }
    var bd = Array.isArray;
    function cd(a2, b, c2) {
      a2 = c2.ref;
      if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
        if (c2._owner) {
          c2 = c2._owner;
          if (c2) {
            if (1 !== c2.tag)
              throw Error(n(309));
            var d = c2.stateNode;
          }
          if (!d)
            throw Error(n(147, a2));
          var e = "" + a2;
          if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === e)
            return b.ref;
          b = function b2(_b) {
            var a3 = d.refs;
            a3 === Tc && (a3 = d.refs = {});
            null === _b ? delete a3[e] : a3[e] = _b;
          };
          b._stringRef = e;
          return b;
        }
        if ("string" !== typeof a2)
          throw Error(n(284));
        if (!c2._owner)
          throw Error(n(290, a2));
      }
      return a2;
    }
    function dd(a2, b) {
      if ("textarea" !== a2.type)
        throw Error(n(31, "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b, ""));
    }
    function ed(a2) {
      function b(b2, c3) {
        if (a2) {
          var d2 = b2.lastEffect;
          null !== d2 ? (d2.nextEffect = c3, b2.lastEffect = c3) : b2.firstEffect = b2.lastEffect = c3;
          c3.nextEffect = null;
          c3.effectTag = 8;
        }
      }
      function c2(c3, d2) {
        if (!a2)
          return null;
        for (; null !== d2; )
          b(c3, d2), d2 = d2.sibling;
        return null;
      }
      function d(b2, a3) {
        for (b2 = /* @__PURE__ */ new Map(); null !== a3; )
          null !== a3.key ? b2.set(a3.key, a3) : b2.set(a3.index, a3), a3 = a3.sibling;
        return b2;
      }
      function e(b2, a3, c3) {
        b2 = fd(b2, a3);
        b2.index = 0;
        b2.sibling = null;
        return b2;
      }
      function f(b2, c3, d2) {
        b2.index = d2;
        if (!a2)
          return c3;
        d2 = b2.alternate;
        if (null !== d2)
          return d2 = d2.index, d2 < c3 ? (b2.effectTag = 2, c3) : d2;
        b2.effectTag = 2;
        return c3;
      }
      function g3(b2) {
        a2 && null === b2.alternate && (b2.effectTag = 2);
        return b2;
      }
      function l2(b2, a3, c3, d2) {
        if (null === a3 || 6 !== a3.tag)
          return a3 = gd(c3, b2.mode, d2), a3.return = b2, a3;
        a3 = e(a3, c3);
        a3.return = b2;
        return a3;
      }
      function h2(b2, a3, c3, d2) {
        if (null !== a3 && a3.elementType === c3.type)
          return d2 = e(a3, c3.props), d2.ref = cd(b2, a3, c3), d2.return = b2, d2;
        d2 = hd(c3.type, c3.key, c3.props, null, b2.mode, d2);
        d2.ref = cd(b2, a3, c3);
        d2.return = b2;
        return d2;
      }
      function k(b2, a3, c3, d2) {
        if (null === a3 || 4 !== a3.tag || a3.stateNode.containerInfo !== c3.containerInfo || a3.stateNode.implementation !== c3.implementation)
          return a3 = id(c3, b2.mode, d2), a3.return = b2, a3;
        a3 = e(a3, c3.children || []);
        a3.return = b2;
        return a3;
      }
      function p(b2, a3, c3, d2, f2) {
        if (null === a3 || 7 !== a3.tag)
          return a3 = jd(c3, b2.mode, d2, f2), a3.return = b2, a3;
        a3 = e(a3, c3);
        a3.return = b2;
        return a3;
      }
      function D(b2, a3, c3) {
        if ("string" === typeof a3 || "number" === typeof a3)
          return a3 = gd("" + a3, b2.mode, c3), a3.return = b2, a3;
        if ("object" === typeof a3 && null !== a3) {
          switch (a3.$$typeof) {
            case ca:
              return c3 = hd(a3.type, a3.key, a3.props, null, b2.mode, c3), c3.ref = cd(b2, null, a3), c3.return = b2, c3;
            case da:
              return a3 = id(a3, b2.mode, c3), a3.return = b2, a3;
          }
          if (bd(a3) || ra(a3))
            return a3 = jd(a3, b2.mode, c3, null), a3.return = b2, a3;
          dd(b2, a3);
        }
        return null;
      }
      function x(b2, a3, c3, d2) {
        var e2 = null !== a3 ? a3.key : null;
        if ("string" === typeof c3 || "number" === typeof c3)
          return null !== e2 ? null : l2(b2, a3, "" + c3, d2);
        if ("object" === typeof c3 && null !== c3) {
          switch (c3.$$typeof) {
            case ca:
              return c3.key === e2 ? c3.type === ea ? p(b2, a3, c3.props.children, d2, e2) : h2(b2, a3, c3, d2) : null;
            case da:
              return c3.key === e2 ? k(b2, a3, c3, d2) : null;
          }
          if (bd(c3) || ra(c3))
            return null !== e2 ? null : p(b2, a3, c3, d2, null);
          dd(b2, c3);
        }
        return null;
      }
      function K(b2, a3, c3, d2, e2) {
        if ("string" === typeof d2 || "number" === typeof d2)
          return b2 = b2.get(c3) || null, l2(a3, b2, "" + d2, e2);
        if ("object" === typeof d2 && null !== d2) {
          switch (d2.$$typeof) {
            case ca:
              return b2 = b2.get(null === d2.key ? c3 : d2.key) || null, d2.type === ea ? p(a3, b2, d2.props.children, e2, d2.key) : h2(a3, b2, d2, e2);
            case da:
              return b2 = b2.get(null === d2.key ? c3 : d2.key) || null, k(a3, b2, d2, e2);
          }
          if (bd(d2) || ra(d2))
            return b2 = b2.get(c3) || null, p(a3, b2, d2, e2, null);
          dd(a3, d2);
        }
        return null;
      }
      function Ha(e2, g4, h3, l3) {
        for (var k2 = null, w = null, t2 = g4, r = g4 = 0, p2 = null; null !== t2 && r < h3.length; r++) {
          t2.index > r ? (p2 = t2, t2 = null) : p2 = t2.sibling;
          var v2 = x(e2, t2, h3[r], l3);
          if (null === v2) {
            null === t2 && (t2 = p2);
            break;
          }
          a2 && t2 && null === v2.alternate && b(e2, t2);
          g4 = f(v2, g4, r);
          null === w ? k2 = v2 : w.sibling = v2;
          w = v2;
          t2 = p2;
        }
        if (r === h3.length)
          return c2(e2, t2), k2;
        if (null === t2) {
          for (; r < h3.length; r++)
            t2 = D(e2, h3[r], l3), null !== t2 && (g4 = f(t2, g4, r), null === w ? k2 = t2 : w.sibling = t2, w = t2);
          return k2;
        }
        for (t2 = d(e2, t2); r < h3.length; r++)
          p2 = K(t2, e2, r, h3[r], l3), null !== p2 && (a2 && null !== p2.alternate && t2.delete(null === p2.key ? r : p2.key), g4 = f(p2, g4, r), null === w ? k2 = p2 : w.sibling = p2, w = p2);
        a2 && t2.forEach(function(a3) {
          return b(e2, a3);
        });
        return k2;
      }
      function O(e2, g4, h3, l3) {
        var k2 = ra(h3);
        if ("function" !== typeof k2)
          throw Error(n(150));
        h3 = k2.call(h3);
        if (null == h3)
          throw Error(n(151));
        for (var t2 = k2 = null, r = g4, w = g4 = 0, p2 = null, v2 = h3.next(); null !== r && !v2.done; w++, v2 = h3.next()) {
          r.index > w ? (p2 = r, r = null) : p2 = r.sibling;
          var N = x(e2, r, v2.value, l3);
          if (null === N) {
            null === r && (r = p2);
            break;
          }
          a2 && r && null === N.alternate && b(e2, r);
          g4 = f(N, g4, w);
          null === t2 ? k2 = N : t2.sibling = N;
          t2 = N;
          r = p2;
        }
        if (v2.done)
          return c2(e2, r), k2;
        if (null === r) {
          for (; !v2.done; w++, v2 = h3.next())
            v2 = D(e2, v2.value, l3), null !== v2 && (g4 = f(v2, g4, w), null === t2 ? k2 = v2 : t2.sibling = v2, t2 = v2);
          return k2;
        }
        for (r = d(e2, r); !v2.done; w++, v2 = h3.next())
          v2 = K(r, e2, w, v2.value, l3), null !== v2 && (a2 && null !== v2.alternate && r.delete(null === v2.key ? w : v2.key), g4 = f(v2, g4, w), null === t2 ? k2 = v2 : t2.sibling = v2, t2 = v2);
        a2 && r.forEach(function(a3) {
          return b(e2, a3);
        });
        return k2;
      }
      return function(a3, d2, f2, h3) {
        var k2 = "object" === typeof f2 && null !== f2 && f2.type === ea && null === f2.key;
        k2 && (f2 = f2.props.children);
        var l3 = "object" === typeof f2 && null !== f2;
        if (l3)
          switch (f2.$$typeof) {
            case ca:
              a: {
                l3 = f2.key;
                for (k2 = d2; null !== k2; ) {
                  if (k2.key === l3) {
                    if (7 === k2.tag ? f2.type === ea : k2.elementType === f2.type) {
                      c2(a3, k2.sibling);
                      d2 = e(k2, f2.type === ea ? f2.props.children : f2.props);
                      d2.ref = cd(a3, k2, f2);
                      d2.return = a3;
                      a3 = d2;
                      break a;
                    } else {
                      c2(a3, k2);
                      break;
                    }
                  } else
                    b(a3, k2);
                  k2 = k2.sibling;
                }
                f2.type === ea ? (d2 = jd(f2.props.children, a3.mode, h3, f2.key), d2.return = a3, a3 = d2) : (h3 = hd(f2.type, f2.key, f2.props, null, a3.mode, h3), h3.ref = cd(a3, d2, f2), h3.return = a3, a3 = h3);
              }
              return g3(a3);
            case da:
              a: {
                for (k2 = f2.key; null !== d2; ) {
                  if (d2.key === k2) {
                    if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                      c2(a3, d2.sibling);
                      d2 = e(d2, f2.children || []);
                      d2.return = a3;
                      a3 = d2;
                      break a;
                    } else {
                      c2(a3, d2);
                      break;
                    }
                  } else
                    b(a3, d2);
                  d2 = d2.sibling;
                }
                d2 = id(f2, a3.mode, h3);
                d2.return = a3;
                a3 = d2;
              }
              return g3(a3);
          }
        if ("string" === typeof f2 || "number" === typeof f2)
          return f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c2(a3, d2.sibling), d2 = e(d2, f2), d2.return = a3, a3 = d2) : (c2(a3, d2), d2 = gd(f2, a3.mode, h3), d2.return = a3, a3 = d2), g3(a3);
        if (bd(f2))
          return Ha(a3, d2, f2, h3);
        if (ra(f2))
          return O(a3, d2, f2, h3);
        l3 && dd(a3, f2);
        if ("undefined" === typeof f2 && !k2)
          switch (a3.tag) {
            case 1:
            case 0:
              throw a3 = a3.type, Error(n(152, a3.displayName || a3.name || "Component"));
          }
        return c2(a3, d2);
      };
    }
    var kd = ed(true), ld = ed(false), md = {}, H2 = {
      current: md
    }, nd = {
      current: md
    }, od = {
      current: md
    };
    function pd(a2) {
      if (a2 === md)
        throw Error(n(174));
      return a2;
    }
    function qd(a2, b) {
      z2(od, b);
      z2(nd, a2);
      z2(H2, md);
      b = Aa(b);
      y(H2);
      z2(H2, b);
    }
    function rd(a2) {
      y(H2);
      y(nd);
      y(od);
    }
    function sd(a2) {
      var b = pd(od.current), c2 = pd(H2.current);
      b = Ba(c2, a2.type, b);
      c2 !== b && (z2(nd, a2), z2(H2, b));
    }
    function td(a2) {
      nd.current === a2 && (y(H2), y(nd));
    }
    var I = {
      current: 0
    };
    function ud(a2) {
      for (var b = a2; null !== b; ) {
        if (13 === b.tag) {
          var c2 = b.memoizedState;
          if (null !== c2 && (c2 = c2.dehydrated, null === c2 || qb(c2) || rb(c2)))
            return b;
        } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
          if (0 !== (b.effectTag & 64))
            return b;
        } else if (null !== b.child) {
          b.child.return = b;
          b = b.child;
          continue;
        }
        if (b === a2)
          break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a2)
            return null;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
      return null;
    }
    function vd(a2, b) {
      return {
        responder: a2,
        props: b
      };
    }
    var wd = q2.ReactCurrentDispatcher, J = q2.ReactCurrentBatchConfig, xd = 0, yd = null, L2 = null, zd = null, Ad = null, M2 = null, Bd = null, Cd = 0, Dd = null, Ed = 0, Fd = false, Gd = null, Hd = 0;
    function P() {
      throw Error(n(321));
    }
    function Id(a2, b) {
      if (null === b)
        return false;
      for (var c2 = 0; c2 < b.length && c2 < a2.length; c2++)
        if (!oc(a2[c2], b[c2]))
          return false;
      return true;
    }
    function Jd(a2, b, c2, d, e, f) {
      xd = f;
      yd = b;
      zd = null !== a2 ? a2.memoizedState : null;
      wd.current = null === zd ? Kd : Ld;
      b = c2(d, e);
      if (Fd) {
        do
          Fd = false, Hd += 1, zd = null !== a2 ? a2.memoizedState : null, Bd = Ad, Dd = M2 = L2 = null, wd.current = Ld, b = c2(d, e);
        while (Fd);
        Gd = null;
        Hd = 0;
      }
      wd.current = Md;
      a2 = yd;
      a2.memoizedState = Ad;
      a2.expirationTime = Cd;
      a2.updateQueue = Dd;
      a2.effectTag |= Ed;
      a2 = null !== L2 && null !== L2.next;
      xd = 0;
      Bd = M2 = Ad = zd = L2 = yd = null;
      Cd = 0;
      Dd = null;
      Ed = 0;
      if (a2)
        throw Error(n(300));
      return b;
    }
    function Nd() {
      wd.current = Md;
      xd = 0;
      Bd = M2 = Ad = zd = L2 = yd = null;
      Cd = 0;
      Dd = null;
      Ed = 0;
      Fd = false;
      Gd = null;
      Hd = 0;
    }
    function Od() {
      var a2 = {
        memoizedState: null,
        baseState: null,
        queue: null,
        baseUpdate: null,
        next: null
      };
      null === M2 ? Ad = M2 = a2 : M2 = M2.next = a2;
      return M2;
    }
    function Pd() {
      if (null !== Bd)
        M2 = Bd, Bd = M2.next, L2 = zd, zd = null !== L2 ? L2.next : null;
      else {
        if (null === zd)
          throw Error(n(310));
        L2 = zd;
        var a2 = {
          memoizedState: L2.memoizedState,
          baseState: L2.baseState,
          queue: L2.queue,
          baseUpdate: L2.baseUpdate,
          next: null
        };
        M2 = null === M2 ? Ad = a2 : M2.next = a2;
        zd = L2.next;
      }
      return M2;
    }
    function Qd(a2, b) {
      return "function" === typeof b ? b(a2) : b;
    }
    function Rd(a2) {
      var b = Pd(), c2 = b.queue;
      if (null === c2)
        throw Error(n(311));
      c2.lastRenderedReducer = a2;
      if (0 < Hd) {
        var d = c2.dispatch;
        if (null !== Gd) {
          var e = Gd.get(c2);
          if (void 0 !== e) {
            Gd.delete(c2);
            var f = b.memoizedState;
            do
              f = a2(f, e.action), e = e.next;
            while (null !== e);
            oc(f, b.memoizedState) || (Bc = true);
            b.memoizedState = f;
            b.baseUpdate === c2.last && (b.baseState = f);
            c2.lastRenderedState = f;
            return [f, d];
          }
        }
        return [b.memoizedState, d];
      }
      d = c2.last;
      var g3 = b.baseUpdate;
      f = b.baseState;
      null !== g3 ? (null !== d && (d.next = null), d = g3.next) : d = null !== d ? d.next : null;
      if (null !== d) {
        var l2 = e = null, h2 = d, k = false;
        do {
          var p = h2.expirationTime;
          p < xd ? (k || (k = true, l2 = g3, e = f), p > Cd && (Cd = p, Pc(Cd))) : (Oc(p, h2.suspenseConfig), f = h2.eagerReducer === a2 ? h2.eagerState : a2(f, h2.action));
          g3 = h2;
          h2 = h2.next;
        } while (null !== h2 && h2 !== d);
        k || (l2 = g3, e = f);
        oc(f, b.memoizedState) || (Bc = true);
        b.memoizedState = f;
        b.baseUpdate = l2;
        b.baseState = e;
        c2.lastRenderedState = f;
      }
      return [b.memoizedState, c2.dispatch];
    }
    function Sd(a2) {
      var b = Od();
      "function" === typeof a2 && (a2 = a2());
      b.memoizedState = b.baseState = a2;
      a2 = b.queue = {
        last: null,
        dispatch: null,
        lastRenderedReducer: Qd,
        lastRenderedState: a2
      };
      a2 = a2.dispatch = Td.bind(null, yd, a2);
      return [b.memoizedState, a2];
    }
    function Ud(a2) {
      return Rd(Qd);
    }
    function Vd(a2, b, c2, d) {
      a2 = {
        tag: a2,
        create: b,
        destroy: c2,
        deps: d,
        next: null
      };
      null === Dd ? (Dd = {
        lastEffect: null
      }, Dd.lastEffect = a2.next = a2) : (b = Dd.lastEffect, null === b ? Dd.lastEffect = a2.next = a2 : (c2 = b.next, b.next = a2, a2.next = c2, Dd.lastEffect = a2));
      return a2;
    }
    function Wd(a2, b, c2, d) {
      var e = Od();
      Ed |= a2;
      e.memoizedState = Vd(b, c2, void 0, void 0 === d ? null : d);
    }
    function Xd(a2, b, c2, d) {
      var e = Pd();
      d = void 0 === d ? null : d;
      var f = void 0;
      if (null !== L2) {
        var g3 = L2.memoizedState;
        f = g3.destroy;
        if (null !== d && Id(d, g3.deps)) {
          Vd(0, c2, f, d);
          return;
        }
      }
      Ed |= a2;
      e.memoizedState = Vd(b, c2, f, d);
    }
    function Yd(a2, b) {
      return Wd(516, 192, a2, b);
    }
    function Zd(a2, b) {
      return Xd(516, 192, a2, b);
    }
    function $d(a2, b) {
      if ("function" === typeof b)
        return a2 = a2(), b(a2), function() {
          b(null);
        };
      if (null !== b && void 0 !== b)
        return a2 = a2(), b.current = a2, function() {
          b.current = null;
        };
    }
    function ae() {
    }
    function be(a2, b) {
      Od().memoizedState = [a2, void 0 === b ? null : b];
      return a2;
    }
    function ce(a2, b) {
      var c2 = Pd();
      b = void 0 === b ? null : b;
      var d = c2.memoizedState;
      if (null !== d && null !== b && Id(b, d[1]))
        return d[0];
      c2.memoizedState = [a2, b];
      return a2;
    }
    function Td(a2, b, c2) {
      if (!(25 > Hd))
        throw Error(n(301));
      var d = a2.alternate;
      if (a2 === yd || null !== d && d === yd) {
        if (Fd = true, a2 = {
          expirationTime: xd,
          suspenseConfig: null,
          action: c2,
          eagerReducer: null,
          eagerState: null,
          next: null
        }, null === Gd && (Gd = /* @__PURE__ */ new Map()), c2 = Gd.get(b), void 0 === c2)
          Gd.set(b, a2);
        else {
          for (b = c2; null !== b.next; )
            b = b.next;
          b.next = a2;
        }
      } else {
        var e = G2(), f = Sc.suspense;
        e = Vc(e, a2, f);
        f = {
          expirationTime: e,
          suspenseConfig: f,
          action: c2,
          eagerReducer: null,
          eagerState: null,
          next: null
        };
        var g3 = b.last;
        if (null === g3)
          f.next = f;
        else {
          var l2 = g3.next;
          null !== l2 && (f.next = l2);
          g3.next = f;
        }
        b.last = f;
        if (0 === a2.expirationTime && (null === d || 0 === d.expirationTime) && (d = b.lastRenderedReducer, null !== d))
          try {
            var h2 = b.lastRenderedState, k = d(h2, c2);
            f.eagerReducer = d;
            f.eagerState = k;
            if (oc(k, h2))
              return;
          } catch (p) {
          } finally {
          }
        Wc(a2, e);
      }
    }
    var Md = {
      readContext: Cc,
      useCallback: P,
      useContext: P,
      useEffect: P,
      useImperativeHandle: P,
      useLayoutEffect: P,
      useMemo: P,
      useReducer: P,
      useRef: P,
      useState: P,
      useDebugValue: P,
      useResponder: P,
      useDeferredValue: P,
      useTransition: P
    }, Kd = {
      readContext: Cc,
      useCallback: be,
      useContext: Cc,
      useEffect: Yd,
      useImperativeHandle: function useImperativeHandle(a2, b, c2) {
        c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
        return Wd(4, 36, $d.bind(null, b, a2), c2);
      },
      useLayoutEffect: function useLayoutEffect(a2, b) {
        return Wd(4, 36, a2, b);
      },
      useMemo: function useMemo(a2, b) {
        var c2 = Od();
        b = void 0 === b ? null : b;
        a2 = a2();
        c2.memoizedState = [a2, b];
        return a2;
      },
      useReducer: function useReducer(a2, b, c2) {
        var d = Od();
        b = void 0 !== c2 ? c2(b) : b;
        d.memoizedState = d.baseState = b;
        a2 = d.queue = {
          last: null,
          dispatch: null,
          lastRenderedReducer: a2,
          lastRenderedState: b
        };
        a2 = a2.dispatch = Td.bind(null, yd, a2);
        return [d.memoizedState, a2];
      },
      useRef: function useRef2(a2) {
        var b = Od();
        a2 = {
          current: a2
        };
        return b.memoizedState = a2;
      },
      useState: Sd,
      useDebugValue: ae,
      useResponder: vd,
      useDeferredValue: function useDeferredValue(a2, b) {
        var c2 = Sd(a2), d = c2[0], e = c2[1];
        Yd(function() {
          m2.unstable_next(function() {
            var c3 = J.suspense;
            J.suspense = void 0 === b ? null : b;
            try {
              e(a2);
            } finally {
              J.suspense = c3;
            }
          });
        }, [a2, b]);
        return d;
      },
      useTransition: function useTransition(a2) {
        var b = Sd(false), c2 = b[0], d = b[1];
        return [be(function(b2) {
          d(true);
          m2.unstable_next(function() {
            var c3 = J.suspense;
            J.suspense = void 0 === a2 ? null : a2;
            try {
              d(false), b2();
            } finally {
              J.suspense = c3;
            }
          });
        }, [a2, c2]), c2];
      }
    }, Ld = {
      readContext: Cc,
      useCallback: ce,
      useContext: Cc,
      useEffect: Zd,
      useImperativeHandle: function useImperativeHandle(a2, b, c2) {
        c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
        return Xd(4, 36, $d.bind(null, b, a2), c2);
      },
      useLayoutEffect: function useLayoutEffect(a2, b) {
        return Xd(4, 36, a2, b);
      },
      useMemo: function useMemo(a2, b) {
        var c2 = Pd();
        b = void 0 === b ? null : b;
        var d = c2.memoizedState;
        if (null !== d && null !== b && Id(b, d[1]))
          return d[0];
        a2 = a2();
        c2.memoizedState = [a2, b];
        return a2;
      },
      useReducer: Rd,
      useRef: function useRef2() {
        return Pd().memoizedState;
      },
      useState: Ud,
      useDebugValue: ae,
      useResponder: vd,
      useDeferredValue: function useDeferredValue(a2, b) {
        var c2 = Ud(), d = c2[0], e = c2[1];
        Zd(function() {
          m2.unstable_next(function() {
            var c3 = J.suspense;
            J.suspense = void 0 === b ? null : b;
            try {
              e(a2);
            } finally {
              J.suspense = c3;
            }
          });
        }, [a2, b]);
        return d;
      },
      useTransition: function useTransition(a2) {
        var b = Ud(), c2 = b[0], d = b[1];
        return [ce(function(b2) {
          d(true);
          m2.unstable_next(function() {
            var c3 = J.suspense;
            J.suspense = void 0 === a2 ? null : a2;
            try {
              d(false), b2();
            } finally {
              J.suspense = c3;
            }
          });
        }, [a2, c2]), c2];
      }
    }, de = null, ee = null, fe = false;
    function ge(a2, b) {
      var c2 = he(5, null, null, 0);
      c2.elementType = "DELETED";
      c2.type = "DELETED";
      c2.stateNode = b;
      c2.return = a2;
      c2.effectTag = 8;
      null !== a2.lastEffect ? (a2.lastEffect.nextEffect = c2, a2.lastEffect = c2) : a2.firstEffect = a2.lastEffect = c2;
    }
    function ie(a2, b) {
      switch (a2.tag) {
        case 5:
          return b = ob(b, a2.type, a2.pendingProps), null !== b ? (a2.stateNode = b, true) : false;
        case 6:
          return b = pb(b, a2.pendingProps), null !== b ? (a2.stateNode = b, true) : false;
        case 13:
          return false;
        default:
          return false;
      }
    }
    function je(a2) {
      if (fe) {
        var b = ee;
        if (b) {
          var c2 = b;
          if (!ie(a2, b)) {
            b = sb(c2);
            if (!b || !ie(a2, b)) {
              a2.effectTag = a2.effectTag & -1025 | 2;
              fe = false;
              de = a2;
              return;
            }
            ge(de, c2);
          }
          de = a2;
          ee = tb(b);
        } else
          a2.effectTag = a2.effectTag & -1025 | 2, fe = false, de = a2;
      }
    }
    function ke(a2) {
      for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
        a2 = a2.return;
      de = a2;
    }
    function ne(a2) {
      if (!Sa || a2 !== de)
        return false;
      if (!fe)
        return ke(a2), fe = true, false;
      var b = a2.type;
      if (5 !== a2.tag || "head" !== b && "body" !== b && !Ja(b, a2.memoizedProps))
        for (b = ee; b; )
          ge(a2, b), b = sb(b);
      ke(a2);
      if (13 === a2.tag) {
        if (!Sa)
          throw Error(n(316));
        a2 = a2.memoizedState;
        a2 = null !== a2 ? a2.dehydrated : null;
        if (!a2)
          throw Error(n(317));
        ee = wb(a2);
      } else
        ee = de ? sb(a2.stateNode) : null;
      return true;
    }
    function oe() {
      Sa && (ee = de = null, fe = false);
    }
    var pe = q2.ReactCurrentOwner, Bc = false;
    function Q2(a2, b, c2, d) {
      b.child = null === a2 ? ld(b, null, c2, d) : kd(b, a2.child, c2, d);
    }
    function qe(a2, b, c2, d, e) {
      c2 = c2.render;
      var f = b.ref;
      Ac(b, e);
      d = Jd(a2, b, c2, d, f, e);
      if (null !== a2 && !Bc)
        return b.updateQueue = a2.updateQueue, b.effectTag &= -517, a2.expirationTime <= e && (a2.expirationTime = 0), re(a2, b, e);
      b.effectTag |= 1;
      Q2(a2, b, d, e);
      return b.child;
    }
    function se(a2, b, c2, d, e, f) {
      if (null === a2) {
        var g3 = c2.type;
        if ("function" === typeof g3 && !te(g3) && void 0 === g3.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
          return b.tag = 15, b.type = g3, ue(a2, b, g3, d, e, f);
        a2 = hd(c2.type, null, d, null, b.mode, f);
        a2.ref = b.ref;
        a2.return = b;
        return b.child = a2;
      }
      g3 = a2.child;
      if (e < f && (e = g3.memoizedProps, c2 = c2.compare, c2 = null !== c2 ? c2 : qc, c2(e, d) && a2.ref === b.ref))
        return re(a2, b, f);
      b.effectTag |= 1;
      a2 = fd(g3, d);
      a2.ref = b.ref;
      a2.return = b;
      return b.child = a2;
    }
    function ue(a2, b, c2, d, e, f) {
      return null !== a2 && qc(a2.memoizedProps, d) && a2.ref === b.ref && (Bc = false, e < f) ? re(a2, b, f) : ve(a2, b, c2, d, f);
    }
    function we(a2, b) {
      var c2 = b.ref;
      if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
        b.effectTag |= 128;
    }
    function ve(a2, b, c2, d, e) {
      var f = C2(c2) ? Eb : A2.current;
      f = Fb(b, f);
      Ac(b, e);
      c2 = Jd(a2, b, c2, d, f, e);
      if (null !== a2 && !Bc)
        return b.updateQueue = a2.updateQueue, b.effectTag &= -517, a2.expirationTime <= e && (a2.expirationTime = 0), re(a2, b, e);
      b.effectTag |= 1;
      Q2(a2, b, c2, e);
      return b.child;
    }
    function xe(a2, b, c2, d, e) {
      if (C2(c2)) {
        var f = true;
        Kb(b);
      } else
        f = false;
      Ac(b, e);
      if (null === b.stateNode)
        null !== a2 && (a2.alternate = null, b.alternate = null, b.effectTag |= 2), Zc(b, c2, d), ad(b, c2, d, e), d = true;
      else if (null === a2) {
        var g3 = b.stateNode, l2 = b.memoizedProps;
        g3.props = l2;
        var h2 = g3.context, k = c2.contextType;
        "object" === typeof k && null !== k ? k = Cc(k) : (k = C2(c2) ? Eb : A2.current, k = Fb(b, k));
        var p = c2.getDerivedStateFromProps, D = "function" === typeof p || "function" === typeof g3.getSnapshotBeforeUpdate;
        D || "function" !== typeof g3.UNSAFE_componentWillReceiveProps && "function" !== typeof g3.componentWillReceiveProps || (l2 !== d || h2 !== k) && $c(b, g3, d, k);
        Dc = false;
        var x = b.memoizedState;
        h2 = g3.state = x;
        var K = b.updateQueue;
        null !== K && (Nc(b, K, d, g3, e), h2 = b.memoizedState);
        l2 !== d || x !== h2 || B.current || Dc ? ("function" === typeof p && (Uc(b, c2, p, d), h2 = b.memoizedState), (l2 = Dc || Yc(b, c2, l2, d, x, h2, k)) ? (D || "function" !== typeof g3.UNSAFE_componentWillMount && "function" !== typeof g3.componentWillMount || ("function" === typeof g3.componentWillMount && g3.componentWillMount(), "function" === typeof g3.UNSAFE_componentWillMount && g3.UNSAFE_componentWillMount()), "function" === typeof g3.componentDidMount && (b.effectTag |= 4)) : ("function" === typeof g3.componentDidMount && (b.effectTag |= 4), b.memoizedProps = d, b.memoizedState = h2), g3.props = d, g3.state = h2, g3.context = k, d = l2) : ("function" === typeof g3.componentDidMount && (b.effectTag |= 4), d = false);
      } else
        g3 = b.stateNode, l2 = b.memoizedProps, g3.props = b.type === b.elementType ? l2 : rc(b.type, l2), h2 = g3.context, k = c2.contextType, "object" === typeof k && null !== k ? k = Cc(k) : (k = C2(c2) ? Eb : A2.current, k = Fb(b, k)), p = c2.getDerivedStateFromProps, (D = "function" === typeof p || "function" === typeof g3.getSnapshotBeforeUpdate) || "function" !== typeof g3.UNSAFE_componentWillReceiveProps && "function" !== typeof g3.componentWillReceiveProps || (l2 !== d || h2 !== k) && $c(b, g3, d, k), Dc = false, h2 = b.memoizedState, x = g3.state = h2, K = b.updateQueue, null !== K && (Nc(b, K, d, g3, e), x = b.memoizedState), l2 !== d || h2 !== x || B.current || Dc ? ("function" === typeof p && (Uc(b, c2, p, d), x = b.memoizedState), (p = Dc || Yc(b, c2, l2, d, h2, x, k)) ? (D || "function" !== typeof g3.UNSAFE_componentWillUpdate && "function" !== typeof g3.componentWillUpdate || ("function" === typeof g3.componentWillUpdate && g3.componentWillUpdate(d, x, k), "function" === typeof g3.UNSAFE_componentWillUpdate && g3.UNSAFE_componentWillUpdate(d, x, k)), "function" === typeof g3.componentDidUpdate && (b.effectTag |= 4), "function" === typeof g3.getSnapshotBeforeUpdate && (b.effectTag |= 256)) : ("function" !== typeof g3.componentDidUpdate || l2 === a2.memoizedProps && h2 === a2.memoizedState || (b.effectTag |= 4), "function" !== typeof g3.getSnapshotBeforeUpdate || l2 === a2.memoizedProps && h2 === a2.memoizedState || (b.effectTag |= 256), b.memoizedProps = d, b.memoizedState = x), g3.props = d, g3.state = x, g3.context = k, d = p) : ("function" !== typeof g3.componentDidUpdate || l2 === a2.memoizedProps && h2 === a2.memoizedState || (b.effectTag |= 4), "function" !== typeof g3.getSnapshotBeforeUpdate || l2 === a2.memoizedProps && h2 === a2.memoizedState || (b.effectTag |= 256), d = false);
      return ye(a2, b, c2, d, f, e);
    }
    function ye(a2, b, c2, d, e, f) {
      we(a2, b);
      var g3 = 0 !== (b.effectTag & 64);
      if (!d && !g3)
        return e && Lb(b, c2, false), re(a2, b, f);
      d = b.stateNode;
      pe.current = b;
      var l2 = g3 && "function" !== typeof c2.getDerivedStateFromError ? null : d.render();
      b.effectTag |= 1;
      null !== a2 && g3 ? (b.child = kd(b, a2.child, null, f), b.child = kd(b, null, l2, f)) : Q2(a2, b, l2, f);
      b.memoizedState = d.state;
      e && Lb(b, c2, true);
      return b.child;
    }
    function ze(a2) {
      var b = a2.stateNode;
      b.pendingContext ? Ib(a2, b.pendingContext, b.pendingContext !== b.context) : b.context && Ib(a2, b.context, false);
      qd(a2, b.containerInfo);
    }
    var Ae = {
      dehydrated: null,
      retryTime: 0
    };
    function Be(a2, b, c2) {
      var d = b.mode, e = b.pendingProps, f = I.current, g3 = false, l2;
      (l2 = 0 !== (b.effectTag & 64)) || (l2 = 0 !== (f & 2) && (null === a2 || null !== a2.memoizedState));
      l2 ? (g3 = true, b.effectTag &= -65) : null !== a2 && null === a2.memoizedState || void 0 === e.fallback || true === e.unstable_avoidThisFallback || (f |= 1);
      z2(I, f & 1);
      if (null === a2) {
        void 0 !== e.fallback && je(b);
        if (g3) {
          g3 = e.fallback;
          e = jd(null, d, 0, null);
          e.return = b;
          if (0 === (b.mode & 2))
            for (a2 = null !== b.memoizedState ? b.child.child : b.child, e.child = a2; null !== a2; )
              a2.return = e, a2 = a2.sibling;
          c2 = jd(g3, d, c2, null);
          c2.return = b;
          e.sibling = c2;
          b.memoizedState = Ae;
          b.child = e;
          return c2;
        }
        d = e.children;
        b.memoizedState = null;
        return b.child = ld(b, null, d, c2);
      }
      if (null !== a2.memoizedState) {
        a2 = a2.child;
        d = a2.sibling;
        if (g3) {
          e = e.fallback;
          c2 = fd(a2, a2.pendingProps);
          c2.return = b;
          if (0 === (b.mode & 2) && (g3 = null !== b.memoizedState ? b.child.child : b.child, g3 !== a2.child))
            for (c2.child = g3; null !== g3; )
              g3.return = c2, g3 = g3.sibling;
          d = fd(d, e, d.expirationTime);
          d.return = b;
          c2.sibling = d;
          c2.childExpirationTime = 0;
          b.memoizedState = Ae;
          b.child = c2;
          return d;
        }
        c2 = kd(b, a2.child, e.children, c2);
        b.memoizedState = null;
        return b.child = c2;
      }
      a2 = a2.child;
      if (g3) {
        g3 = e.fallback;
        e = jd(null, d, 0, null);
        e.return = b;
        e.child = a2;
        null !== a2 && (a2.return = e);
        if (0 === (b.mode & 2))
          for (a2 = null !== b.memoizedState ? b.child.child : b.child, e.child = a2; null !== a2; )
            a2.return = e, a2 = a2.sibling;
        c2 = jd(g3, d, c2, null);
        c2.return = b;
        e.sibling = c2;
        c2.effectTag |= 2;
        e.childExpirationTime = 0;
        b.memoizedState = Ae;
        b.child = e;
        return c2;
      }
      b.memoizedState = null;
      return b.child = kd(b, a2, e.children, c2);
    }
    function Ce(a2, b) {
      a2.expirationTime < b && (a2.expirationTime = b);
      var c2 = a2.alternate;
      null !== c2 && c2.expirationTime < b && (c2.expirationTime = b);
      zc(a2.return, b);
    }
    function De(a2, b, c2, d, e, f) {
      var g3 = a2.memoizedState;
      null === g3 ? a2.memoizedState = {
        isBackwards: b,
        rendering: null,
        last: d,
        tail: c2,
        tailExpiration: 0,
        tailMode: e,
        lastEffect: f
      } : (g3.isBackwards = b, g3.rendering = null, g3.last = d, g3.tail = c2, g3.tailExpiration = 0, g3.tailMode = e, g3.lastEffect = f);
    }
    function Ee(a2, b, c2) {
      var d = b.pendingProps, e = d.revealOrder, f = d.tail;
      Q2(a2, b, d.children, c2);
      d = I.current;
      if (0 !== (d & 2))
        d = d & 1 | 2, b.effectTag |= 64;
      else {
        if (null !== a2 && 0 !== (a2.effectTag & 64))
          a:
            for (a2 = b.child; null !== a2; ) {
              if (13 === a2.tag)
                null !== a2.memoizedState && Ce(a2, c2);
              else if (19 === a2.tag)
                Ce(a2, c2);
              else if (null !== a2.child) {
                a2.child.return = a2;
                a2 = a2.child;
                continue;
              }
              if (a2 === b)
                break a;
              for (; null === a2.sibling; ) {
                if (null === a2.return || a2.return === b)
                  break a;
                a2 = a2.return;
              }
              a2.sibling.return = a2.return;
              a2 = a2.sibling;
            }
        d &= 1;
      }
      z2(I, d);
      if (0 === (b.mode & 2))
        b.memoizedState = null;
      else
        switch (e) {
          case "forwards":
            c2 = b.child;
            for (e = null; null !== c2; )
              a2 = c2.alternate, null !== a2 && null === ud(a2) && (e = c2), c2 = c2.sibling;
            c2 = e;
            null === c2 ? (e = b.child, b.child = null) : (e = c2.sibling, c2.sibling = null);
            De(b, false, e, c2, f, b.lastEffect);
            break;
          case "backwards":
            c2 = null;
            e = b.child;
            for (b.child = null; null !== e; ) {
              a2 = e.alternate;
              if (null !== a2 && null === ud(a2)) {
                b.child = e;
                break;
              }
              a2 = e.sibling;
              e.sibling = c2;
              c2 = e;
              e = a2;
            }
            De(b, true, c2, null, f, b.lastEffect);
            break;
          case "together":
            De(b, false, null, null, void 0, b.lastEffect);
            break;
          default:
            b.memoizedState = null;
        }
      return b.child;
    }
    function re(a2, b, c2) {
      null !== a2 && (b.dependencies = a2.dependencies);
      var d = b.expirationTime;
      0 !== d && Pc(d);
      if (b.childExpirationTime < c2)
        return null;
      if (null !== a2 && b.child !== a2.child)
        throw Error(n(153));
      if (null !== b.child) {
        a2 = b.child;
        c2 = fd(a2, a2.pendingProps, a2.expirationTime);
        b.child = c2;
        for (c2.return = b; null !== a2.sibling; )
          a2 = a2.sibling, c2 = c2.sibling = fd(a2, a2.pendingProps, a2.expirationTime), c2.return = b;
        c2.sibling = null;
      }
      return b.child;
    }
    function Fe(a2) {
      a2.effectTag |= 4;
    }
    var _Ge, He, Ie, Je;
    if (Qa)
      _Ge = function Ge(a2, b) {
        for (var c2 = b.child; null !== c2; ) {
          if (5 === c2.tag || 6 === c2.tag)
            Fa(a2, c2.stateNode);
          else if (4 !== c2.tag && null !== c2.child) {
            c2.child.return = c2;
            c2 = c2.child;
            continue;
          }
          if (c2 === b)
            break;
          for (; null === c2.sibling; ) {
            if (null === c2.return || c2.return === b)
              return;
            c2 = c2.return;
          }
          c2.sibling.return = c2.return;
          c2 = c2.sibling;
        }
      }, He = function He2() {
      }, Ie = function Ie2(a2, b, c2, d, e) {
        a2 = a2.memoizedProps;
        if (a2 !== d) {
          var f = b.stateNode, g3 = pd(H2.current);
          c2 = Ia(f, c2, a2, d, e, g3);
          (b.updateQueue = c2) && Fe(b);
        }
      }, Je = function Je2(a2, b, c2, d) {
        c2 !== d && Fe(b);
      };
    else if (Ra) {
      _Ge = function Ge(a2, b, c2, d) {
        for (var e = b.child; null !== e; ) {
          if (5 === e.tag) {
            var f = e.stateNode;
            c2 && d && (f = mb(f, e.type, e.memoizedProps, e));
            Fa(a2, f);
          } else if (6 === e.tag)
            f = e.stateNode, c2 && d && (f = nb(f, e.memoizedProps, e)), Fa(a2, f);
          else if (4 !== e.tag) {
            if (13 === e.tag && 0 !== (e.effectTag & 4) && (f = null !== e.memoizedState)) {
              var g3 = e.child;
              if (null !== g3 && (null !== g3.child && (g3.child.return = g3, _Ge(a2, g3, true, f)), f = g3.sibling, null !== f)) {
                f.return = e;
                e = f;
                continue;
              }
            }
            if (null !== e.child) {
              e.child.return = e;
              e = e.child;
              continue;
            }
          }
          if (e === b)
            break;
          for (; null === e.sibling; ) {
            if (null === e.return || e.return === b)
              return;
            e = e.return;
          }
          e.sibling.return = e.return;
          e = e.sibling;
        }
      };
      var Ke = function Ke2(a2, b, c2, d) {
        for (var e = b.child; null !== e; ) {
          if (5 === e.tag) {
            var f = e.stateNode;
            c2 && d && (f = mb(f, e.type, e.memoizedProps, e));
            ib(a2, f);
          } else if (6 === e.tag)
            f = e.stateNode, c2 && d && (f = nb(f, e.memoizedProps, e)), ib(a2, f);
          else if (4 !== e.tag) {
            if (13 === e.tag && 0 !== (e.effectTag & 4) && (f = null !== e.memoizedState)) {
              var g3 = e.child;
              if (null !== g3 && (null !== g3.child && (g3.child.return = g3, Ke2(a2, g3, true, f)), f = g3.sibling, null !== f)) {
                f.return = e;
                e = f;
                continue;
              }
            }
            if (null !== e.child) {
              e.child.return = e;
              e = e.child;
              continue;
            }
          }
          if (e === b)
            break;
          for (; null === e.sibling; ) {
            if (null === e.return || e.return === b)
              return;
            e = e.return;
          }
          e.sibling.return = e.return;
          e = e.sibling;
        }
      };
      He = function He2(a2) {
        var b = a2.stateNode;
        if (null !== a2.firstEffect) {
          var c2 = b.containerInfo, d = hb(c2);
          Ke(d, a2, false, false);
          b.pendingChildren = d;
          Fe(a2);
          kb(c2, d);
        }
      };
      Ie = function Ie2(a2, b, c2, d, e) {
        var f = a2.stateNode, g3 = a2.memoizedProps;
        if ((a2 = null === b.firstEffect) && g3 === d)
          b.stateNode = f;
        else {
          var l2 = b.stateNode, h2 = pd(H2.current), k = null;
          g3 !== d && (k = Ia(l2, c2, g3, d, e, h2));
          a2 && null === k ? b.stateNode = f : (f = gb(f, k, c2, g3, d, b, a2, l2), Ga(f, c2, d, e, h2) && Fe(b), b.stateNode = f, a2 ? Fe(b) : _Ge(f, b, false, false));
        }
      };
      Je = function Je2(a2, b, c2, d) {
        c2 !== d && (a2 = pd(od.current), c2 = pd(H2.current), b.stateNode = La(d, a2, c2, b), Fe(b));
      };
    } else
      He = function He2() {
      }, Ie = function Ie2() {
      }, Je = function Je2() {
      };
    function Le(a2, b) {
      switch (a2.tailMode) {
        case "hidden":
          b = a2.tail;
          for (var c2 = null; null !== b; )
            null !== b.alternate && (c2 = b), b = b.sibling;
          null === c2 ? a2.tail = null : c2.sibling = null;
          break;
        case "collapsed":
          c2 = a2.tail;
          for (var d = null; null !== c2; )
            null !== c2.alternate && (d = c2), c2 = c2.sibling;
          null === d ? b || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d.sibling = null;
      }
    }
    function Me(a2) {
      switch (a2.tag) {
        case 1:
          C2(a2.type) && Gb();
          var b = a2.effectTag;
          return b & 4096 ? (a2.effectTag = b & -4097 | 64, a2) : null;
        case 3:
          rd();
          Hb();
          b = a2.effectTag;
          if (0 !== (b & 64))
            throw Error(n(285));
          a2.effectTag = b & -4097 | 64;
          return a2;
        case 5:
          return td(a2), null;
        case 13:
          return y(I), b = a2.effectTag, b & 4096 ? (a2.effectTag = b & -4097 | 64, a2) : null;
        case 19:
          return y(I), null;
        case 4:
          return rd(), null;
        case 10:
          return yc(a2), null;
        default:
          return null;
      }
    }
    function Ne(a2, b) {
      return {
        value: a2,
        source: b,
        stack: Ab(b)
      };
    }
    var Oe = "function" === typeof WeakSet ? WeakSet : Set;
    function Pe(a2, b) {
      var c2 = b.source, d = b.stack;
      null === d && null !== c2 && (d = Ab(c2));
      null !== c2 && ta(c2.type);
      b = b.value;
      null !== a2 && 1 === a2.tag && ta(a2.type);
      try {
        console.error(b);
      } catch (e) {
        setTimeout(function() {
          throw e;
        });
      }
    }
    function Qe(a2, b) {
      try {
        b.props = a2.memoizedProps, b.state = a2.memoizedState, b.componentWillUnmount();
      } catch (c2) {
        Re(a2, c2);
      }
    }
    function Se(a2) {
      var b = a2.ref;
      if (null !== b)
        if ("function" === typeof b)
          try {
            b(null);
          } catch (c2) {
            Re(a2, c2);
          }
        else
          b.current = null;
    }
    function Te(a2, b) {
      switch (b.tag) {
        case 0:
        case 11:
        case 15:
          Ue(2, 0, b);
          break;
        case 1:
          if (b.effectTag & 256 && null !== a2) {
            var c2 = a2.memoizedProps, d = a2.memoizedState;
            a2 = b.stateNode;
            b = a2.getSnapshotBeforeUpdate(b.elementType === b.type ? c2 : rc(b.type, c2), d);
            a2.__reactInternalSnapshotBeforeUpdate = b;
          }
          break;
        case 3:
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(n(163));
      }
    }
    function Ue(a2, b, c2) {
      c2 = c2.updateQueue;
      c2 = null !== c2 ? c2.lastEffect : null;
      if (null !== c2) {
        var d = c2 = c2.next;
        do {
          if (0 !== (d.tag & a2)) {
            var e = d.destroy;
            d.destroy = void 0;
            void 0 !== e && e();
          }
          0 !== (d.tag & b) && (e = d.create, d.destroy = e());
          d = d.next;
        } while (d !== c2);
      }
    }
    function Ve(a2, b, c2) {
      "function" === typeof We && We(b);
      switch (b.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          a2 = b.updateQueue;
          if (null !== a2 && (a2 = a2.lastEffect, null !== a2)) {
            var d = a2.next;
            hc(97 < c2 ? 97 : c2, function() {
              var a3 = d;
              do {
                var c3 = a3.destroy;
                if (void 0 !== c3) {
                  var g3 = b;
                  try {
                    c3();
                  } catch (l2) {
                    Re(g3, l2);
                  }
                }
                a3 = a3.next;
              } while (a3 !== d);
            });
          }
          break;
        case 1:
          Se(b);
          c2 = b.stateNode;
          "function" === typeof c2.componentWillUnmount && Qe(b, c2);
          break;
        case 5:
          Se(b);
          break;
        case 4:
          Qa ? Xe(a2, b, c2) : Ra && Ye(b);
      }
    }
    function Ze(a2, b, c2) {
      for (var d = b; ; )
        if (Ve(a2, d, c2), null === d.child || Qa && 4 === d.tag) {
          if (d === b)
            break;
          for (; null === d.sibling; ) {
            if (null === d.return || d.return === b)
              return;
            d = d.return;
          }
          d.sibling.return = d.return;
          d = d.sibling;
        } else
          d.child.return = d, d = d.child;
    }
    function $e(a2) {
      var b = a2.alternate;
      a2.return = null;
      a2.child = null;
      a2.memoizedState = null;
      a2.updateQueue = null;
      a2.dependencies = null;
      a2.alternate = null;
      a2.firstEffect = null;
      a2.lastEffect = null;
      a2.pendingProps = null;
      a2.memoizedProps = null;
      null !== b && $e(b);
    }
    function Ye(a2) {
      if (Ra) {
        a2 = a2.stateNode.containerInfo;
        var b = hb(a2);
        lb(a2, b);
      }
    }
    function af(a2) {
      return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
    }
    function bf(a2) {
      if (Qa) {
        a: {
          for (var b = a2.return; null !== b; ) {
            if (af(b)) {
              var c2 = b;
              break a;
            }
            b = b.return;
          }
          throw Error(n(160));
        }
        b = c2.stateNode;
        switch (c2.tag) {
          case 5:
            var d = false;
            break;
          case 3:
            b = b.containerInfo;
            d = true;
            break;
          case 4:
            b = b.containerInfo;
            d = true;
            break;
          default:
            throw Error(n(161));
        }
        c2.effectTag & 16 && (bb(b), c2.effectTag &= -17);
        a:
          b:
            for (c2 = a2; ; ) {
              for (; null === c2.sibling; ) {
                if (null === c2.return || af(c2.return)) {
                  c2 = null;
                  break a;
                }
                c2 = c2.return;
              }
              c2.sibling.return = c2.return;
              for (c2 = c2.sibling; 5 !== c2.tag && 6 !== c2.tag && 18 !== c2.tag; ) {
                if (c2.effectTag & 2)
                  continue b;
                if (null === c2.child || 4 === c2.tag)
                  continue b;
                else
                  c2.child.return = c2, c2 = c2.child;
              }
              if (!(c2.effectTag & 2)) {
                c2 = c2.stateNode;
                break a;
              }
            }
        for (var e = a2; ; ) {
          var f = 5 === e.tag || 6 === e.tag;
          if (f)
            f = f ? e.stateNode : e.stateNode.instance, c2 ? d ? Za(b, f, c2) : Ya(b, f, c2) : d ? Ua(b, f) : Ta(b, f);
          else if (4 !== e.tag && null !== e.child) {
            e.child.return = e;
            e = e.child;
            continue;
          }
          if (e === a2)
            break;
          for (; null === e.sibling; ) {
            if (null === e.return || e.return === a2)
              return;
            e = e.return;
          }
          e.sibling.return = e.return;
          e = e.sibling;
        }
      }
    }
    function Xe(a2, b, c2) {
      for (var d = b, e = false, f, g3; ; ) {
        if (!e) {
          e = d.return;
          a:
            for (; ; ) {
              if (null === e)
                throw Error(n(160));
              f = e.stateNode;
              switch (e.tag) {
                case 5:
                  g3 = false;
                  break a;
                case 3:
                  f = f.containerInfo;
                  g3 = true;
                  break a;
                case 4:
                  f = f.containerInfo;
                  g3 = true;
                  break a;
              }
              e = e.return;
            }
          e = true;
        }
        if (5 === d.tag || 6 === d.tag)
          Ze(a2, d, c2), g3 ? ab(f, d.stateNode) : $a(f, d.stateNode);
        else if (4 === d.tag) {
          if (null !== d.child) {
            f = d.stateNode.containerInfo;
            g3 = true;
            d.child.return = d;
            d = d.child;
            continue;
          }
        } else if (Ve(a2, d, c2), null !== d.child) {
          d.child.return = d;
          d = d.child;
          continue;
        }
        if (d === b)
          break;
        for (; null === d.sibling; ) {
          if (null === d.return || d.return === b)
            return;
          d = d.return;
          4 === d.tag && (e = false);
        }
        d.sibling.return = d.return;
        d = d.sibling;
      }
    }
    function cf(a2, b) {
      if (Qa)
        switch (b.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            Ue(4, 8, b);
            break;
          case 1:
            break;
          case 5:
            var c2 = b.stateNode;
            if (null != c2) {
              var d = b.memoizedProps;
              a2 = null !== a2 ? a2.memoizedProps : d;
              var e = b.type, f = b.updateQueue;
              b.updateQueue = null;
              null !== f && Xa(c2, f, e, a2, d, b);
            }
            break;
          case 6:
            if (null === b.stateNode)
              throw Error(n(162));
            c2 = b.memoizedProps;
            Va(b.stateNode, null !== a2 ? a2.memoizedProps : c2, c2);
            break;
          case 3:
            Sa && (b = b.stateNode, b.hydrate && (b.hydrate = false, xb(b.containerInfo)));
            break;
          case 12:
            break;
          case 13:
            df(b);
            ef(b);
            break;
          case 19:
            ef(b);
            break;
          case 17:
            break;
          case 20:
            break;
          case 21:
            break;
          default:
            throw Error(n(163));
        }
      else {
        switch (b.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            Ue(4, 8, b);
            return;
          case 12:
            return;
          case 13:
            df(b);
            ef(b);
            return;
          case 19:
            ef(b);
            return;
          case 3:
            Sa && (c2 = b.stateNode, c2.hydrate && (c2.hydrate = false, xb(c2.containerInfo)));
        }
        a:
          if (Ra)
            switch (b.tag) {
              case 1:
              case 5:
              case 6:
              case 20:
                break a;
              case 3:
              case 4:
                b = b.stateNode;
                lb(b.containerInfo, b.pendingChildren);
                break a;
              default:
                throw Error(n(163));
            }
      }
    }
    function df(a2) {
      var b = a2;
      if (null === a2.memoizedState)
        var c2 = false;
      else
        c2 = true, b = a2.child, ff = E2();
      if (Qa && null !== b) {
        a:
          if (a2 = b, Qa)
            for (b = a2; ; ) {
              if (5 === b.tag) {
                var d = b.stateNode;
                c2 ? cb(d) : eb(b.stateNode, b.memoizedProps);
              } else if (6 === b.tag)
                d = b.stateNode, c2 ? db(d) : fb(d, b.memoizedProps);
              else if (13 === b.tag && null !== b.memoizedState && null === b.memoizedState.dehydrated) {
                d = b.child.sibling;
                d.return = b;
                b = d;
                continue;
              } else if (null !== b.child) {
                b.child.return = b;
                b = b.child;
                continue;
              }
              if (b === a2)
                break a;
              for (; null === b.sibling; ) {
                if (null === b.return || b.return === a2)
                  break a;
                b = b.return;
              }
              b.sibling.return = b.return;
              b = b.sibling;
            }
      }
    }
    function ef(a2) {
      var b = a2.updateQueue;
      if (null !== b) {
        a2.updateQueue = null;
        var c2 = a2.stateNode;
        null === c2 && (c2 = a2.stateNode = new Oe());
        b.forEach(function(b2) {
          var d = gf.bind(null, a2, b2);
          c2.has(b2) || (c2.add(b2), b2.then(d, d));
        });
      }
    }
    var hf = "function" === typeof WeakMap ? WeakMap : Map;
    function jf(a2, b, c2) {
      c2 = Gc(c2, null);
      c2.tag = 3;
      c2.payload = {
        element: null
      };
      var d = b.value;
      c2.callback = function() {
        kf || (kf = true, lf = d);
        Pe(a2, b);
      };
      return c2;
    }
    function mf(a2, b, c2) {
      c2 = Gc(c2, null);
      c2.tag = 3;
      var d = a2.type.getDerivedStateFromError;
      if ("function" === typeof d) {
        var e = b.value;
        c2.payload = function() {
          Pe(a2, b);
          return d(e);
        };
      }
      var f = a2.stateNode;
      null !== f && "function" === typeof f.componentDidCatch && (c2.callback = function() {
        "function" !== typeof d && (null === nf ? nf = /* @__PURE__ */ new Set([this]) : nf.add(this), Pe(a2, b));
        var c3 = b.stack;
        this.componentDidCatch(b.value, {
          componentStack: null !== c3 ? c3 : ""
        });
      });
      return c2;
    }
    var of = Math.ceil, pf = q2.ReactCurrentDispatcher, qf = q2.ReactCurrentOwner, R3 = 0, rf = 8, S2 = 16, sf = 32, tf = 0, uf = 1, vf = 2, wf = 3, xf = 4, yf = 5, T2 = R3, U = null, V2 = null, W = 0, X = tf, zf = null, Af = 1073741823, Bf = 1073741823, Cf = null, Df = 0, Ef = false, ff = 0, Ff = 500, Y = null, kf = false, lf = null, nf = null, Gf = false, Hf = null, If = 90, Jf = null, Kf = 0, Lf = null, Mf = 0;
    function G2() {
      return (T2 & (S2 | sf)) !== R3 ? 1073741821 - (E2() / 10 | 0) : 0 !== Mf ? Mf : Mf = 1073741821 - (E2() / 10 | 0);
    }
    function Vc(a2, b, c2) {
      b = b.mode;
      if (0 === (b & 2))
        return 1073741823;
      var d = fc();
      if (0 === (b & 4))
        return 99 === d ? 1073741823 : 1073741822;
      if ((T2 & S2) !== R3)
        return W;
      if (null !== c2)
        a2 = mc(a2, c2.timeoutMs | 0 || 5e3, 250);
      else
        switch (d) {
          case 99:
            a2 = 1073741823;
            break;
          case 98:
            a2 = mc(a2, 150, 100);
            break;
          case 97:
          case 96:
            a2 = mc(a2, 5e3, 250);
            break;
          case 95:
            a2 = 2;
            break;
          default:
            throw Error(n(326));
        }
      null !== U && a2 === W && --a2;
      return a2;
    }
    function Wc(a2, b) {
      if (50 < Kf)
        throw Kf = 0, Lf = null, Error(n(185));
      a2 = Nf(a2, b);
      if (null !== a2) {
        var c2 = fc();
        1073741823 === b ? (T2 & rf) !== R3 && (T2 & (S2 | sf)) === R3 ? Of(a2) : (Z2(a2), T2 === R3 && F()) : Z2(a2);
        (T2 & 4) === R3 || 98 !== c2 && 99 !== c2 || (null === Jf ? Jf = /* @__PURE__ */ new Map([[a2, b]]) : (c2 = Jf.get(a2), (void 0 === c2 || c2 > b) && Jf.set(a2, b)));
      }
    }
    function Nf(a2, b) {
      a2.expirationTime < b && (a2.expirationTime = b);
      var c2 = a2.alternate;
      null !== c2 && c2.expirationTime < b && (c2.expirationTime = b);
      var d = a2.return, e = null;
      if (null === d && 3 === a2.tag)
        e = a2.stateNode;
      else
        for (; null !== d; ) {
          c2 = d.alternate;
          d.childExpirationTime < b && (d.childExpirationTime = b);
          null !== c2 && c2.childExpirationTime < b && (c2.childExpirationTime = b);
          if (null === d.return && 3 === d.tag) {
            e = d.stateNode;
            break;
          }
          d = d.return;
        }
      null !== e && (U === e && (Pc(b), X === xf && Pf(e, W)), Qf(e, b));
      return e;
    }
    function Rf(a2) {
      var b = a2.lastExpiredTime;
      if (0 !== b)
        return b;
      b = a2.firstPendingTime;
      if (!Sf(a2, b))
        return b;
      b = a2.lastPingedTime;
      a2 = a2.nextKnownPendingLevel;
      return b > a2 ? b : a2;
    }
    function Z2(a2) {
      if (0 !== a2.lastExpiredTime)
        a2.callbackExpirationTime = 1073741823, a2.callbackPriority = 99, a2.callbackNode = jc(Of.bind(null, a2));
      else {
        var b = Rf(a2), c2 = a2.callbackNode;
        if (0 === b)
          null !== c2 && (a2.callbackNode = null, a2.callbackExpirationTime = 0, a2.callbackPriority = 90);
        else {
          var d = G2();
          1073741823 === b ? d = 99 : 1 === b || 2 === b ? d = 95 : (d = 10 * (1073741821 - b) - 10 * (1073741821 - d), d = 0 >= d ? 99 : 250 >= d ? 98 : 5250 >= d ? 97 : 95);
          if (null !== c2) {
            var e = a2.callbackPriority;
            if (a2.callbackExpirationTime === b && e >= d)
              return;
            c2 !== $b && Ob(c2);
          }
          a2.callbackExpirationTime = b;
          a2.callbackPriority = d;
          b = 1073741823 === b ? jc(Of.bind(null, a2)) : ic(d, Tf.bind(null, a2), {
            timeout: 10 * (1073741821 - b) - E2()
          });
          a2.callbackNode = b;
        }
      }
    }
    function Tf(a2, b) {
      Mf = 0;
      if (b)
        return b = G2(), Uf(a2, b), Z2(a2), null;
      var c2 = Rf(a2);
      if (0 !== c2) {
        b = a2.callbackNode;
        if ((T2 & (S2 | sf)) !== R3)
          throw Error(n(327));
        Vf();
        a2 === U && c2 === W || Wf(a2, c2);
        if (null !== V2) {
          var d = T2;
          T2 |= S2;
          var e = Xf();
          do
            try {
              Yf();
              break;
            } catch (l2) {
              Zf(a2, l2);
            }
          while (1);
          wc();
          T2 = d;
          pf.current = e;
          if (X === uf)
            throw b = zf, Wf(a2, c2), Pf(a2, c2), Z2(a2), b;
          if (null === V2)
            switch (e = a2.finishedWork = a2.current.alternate, a2.finishedExpirationTime = c2, d = X, U = null, d) {
              case tf:
              case uf:
                throw Error(n(345));
              case vf:
                Uf(a2, 2 < c2 ? 2 : c2);
                break;
              case wf:
                Pf(a2, c2);
                d = a2.lastSuspendedTime;
                c2 === d && (a2.nextKnownPendingLevel = $f(e));
                if (1073741823 === Af && (e = ff + Ff - E2(), 10 < e)) {
                  if (Ef) {
                    var f = a2.lastPingedTime;
                    if (0 === f || f >= c2) {
                      a2.lastPingedTime = c2;
                      Wf(a2, c2);
                      break;
                    }
                  }
                  f = Rf(a2);
                  if (0 !== f && f !== c2)
                    break;
                  if (0 !== d && d !== c2) {
                    a2.lastPingedTime = d;
                    break;
                  }
                  a2.timeoutHandle = Ma(ag.bind(null, a2), e);
                  break;
                }
                ag(a2);
                break;
              case xf:
                Pf(a2, c2);
                d = a2.lastSuspendedTime;
                c2 === d && (a2.nextKnownPendingLevel = $f(e));
                if (Ef && (e = a2.lastPingedTime, 0 === e || e >= c2)) {
                  a2.lastPingedTime = c2;
                  Wf(a2, c2);
                  break;
                }
                e = Rf(a2);
                if (0 !== e && e !== c2)
                  break;
                if (0 !== d && d !== c2) {
                  a2.lastPingedTime = d;
                  break;
                }
                1073741823 !== Bf ? d = 10 * (1073741821 - Bf) - E2() : 1073741823 === Af ? d = 0 : (d = 10 * (1073741821 - Af) - 5e3, e = E2(), c2 = 10 * (1073741821 - c2) - e, d = e - d, 0 > d && (d = 0), d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * of(d / 1960)) - d, c2 < d && (d = c2));
                if (10 < d) {
                  a2.timeoutHandle = Ma(ag.bind(null, a2), d);
                  break;
                }
                ag(a2);
                break;
              case yf:
                if (1073741823 !== Af && null !== Cf) {
                  f = Af;
                  var g3 = Cf;
                  d = g3.busyMinDurationMs | 0;
                  0 >= d ? d = 0 : (e = g3.busyDelayMs | 0, f = E2() - (10 * (1073741821 - f) - (g3.timeoutMs | 0 || 5e3)), d = f <= e ? 0 : e + d - f);
                  if (10 < d) {
                    Pf(a2, c2);
                    a2.timeoutHandle = Ma(ag.bind(null, a2), d);
                    break;
                  }
                }
                ag(a2);
                break;
              default:
                throw Error(n(329));
            }
          Z2(a2);
          if (a2.callbackNode === b)
            return Tf.bind(null, a2);
        }
      }
      return null;
    }
    function Of(a2) {
      var b = a2.lastExpiredTime;
      b = 0 !== b ? b : 1073741823;
      if (a2.finishedExpirationTime === b)
        ag(a2);
      else {
        if ((T2 & (S2 | sf)) !== R3)
          throw Error(n(327));
        Vf();
        a2 === U && b === W || Wf(a2, b);
        if (null !== V2) {
          var c2 = T2;
          T2 |= S2;
          var d = Xf();
          do
            try {
              bg();
              break;
            } catch (e) {
              Zf(a2, e);
            }
          while (1);
          wc();
          T2 = c2;
          pf.current = d;
          if (X === uf)
            throw c2 = zf, Wf(a2, b), Pf(a2, b), Z2(a2), c2;
          if (null !== V2)
            throw Error(n(261));
          a2.finishedWork = a2.current.alternate;
          a2.finishedExpirationTime = b;
          U = null;
          ag(a2);
          Z2(a2);
        }
      }
      return null;
    }
    function cg(a2, b) {
      Uf(a2, b);
      Z2(a2);
      (T2 & (S2 | sf)) === R3 && F();
    }
    function dg() {
      if (null !== Jf) {
        var a2 = Jf;
        Jf = null;
        a2.forEach(function(a3, c2) {
          Uf(c2, a3);
          Z2(c2);
        });
        F();
      }
    }
    function eg(a2, b) {
      if ((T2 & (S2 | sf)) !== R3)
        throw Error(n(187));
      var c2 = T2;
      T2 |= 1;
      try {
        return hc(99, a2.bind(null, b));
      } finally {
        T2 = c2, F();
      }
    }
    function Wf(a2, b) {
      a2.finishedWork = null;
      a2.finishedExpirationTime = 0;
      var c2 = a2.timeoutHandle;
      c2 !== Oa && (a2.timeoutHandle = Oa, Na(c2));
      if (null !== V2)
        for (c2 = V2.return; null !== c2; ) {
          var d = c2;
          switch (d.tag) {
            case 1:
              var e = d.type.childContextTypes;
              null !== e && void 0 !== e && Gb();
              break;
            case 3:
              rd();
              Hb();
              break;
            case 5:
              td(d);
              break;
            case 4:
              rd();
              break;
            case 13:
              y(I);
              break;
            case 19:
              y(I);
              break;
            case 10:
              yc(d);
          }
          c2 = c2.return;
        }
      U = a2;
      V2 = fd(a2.current, null);
      W = b;
      X = tf;
      zf = null;
      Bf = Af = 1073741823;
      Cf = null;
      Df = 0;
      Ef = false;
    }
    function Zf(a2, b) {
      do {
        try {
          wc();
          Nd();
          if (null === V2 || null === V2.return)
            return X = uf, zf = b, null;
          a: {
            var c2 = a2, d = V2.return, e = V2, f = b;
            b = W;
            e.effectTag |= 2048;
            e.firstEffect = e.lastEffect = null;
            if (null !== f && "object" === typeof f && "function" === typeof f.then) {
              var g3 = f, l2 = 0 !== (I.current & 1), h2 = d;
              do {
                var k;
                if (k = 13 === h2.tag) {
                  var p = h2.memoizedState;
                  if (null !== p)
                    k = null !== p.dehydrated ? true : false;
                  else {
                    var D = h2.memoizedProps;
                    k = void 0 === D.fallback ? false : true !== D.unstable_avoidThisFallback ? true : l2 ? false : true;
                  }
                }
                if (k) {
                  var x = h2.updateQueue;
                  if (null === x) {
                    var K = /* @__PURE__ */ new Set();
                    K.add(g3);
                    h2.updateQueue = K;
                  } else
                    x.add(g3);
                  if (0 === (h2.mode & 2)) {
                    h2.effectTag |= 64;
                    e.effectTag &= -2981;
                    if (1 === e.tag)
                      if (null === e.alternate)
                        e.tag = 17;
                      else {
                        var Ha = Gc(1073741823, null);
                        Ha.tag = 2;
                        Ic(e, Ha);
                      }
                    e.expirationTime = 1073741823;
                    break a;
                  }
                  f = void 0;
                  e = b;
                  var O = c2.pingCache;
                  null === O ? (O = c2.pingCache = new hf(), f = /* @__PURE__ */ new Set(), O.set(g3, f)) : (f = O.get(g3), void 0 === f && (f = /* @__PURE__ */ new Set(), O.set(g3, f)));
                  if (!f.has(e)) {
                    f.add(e);
                    var w = fg.bind(null, c2, g3, e);
                    g3.then(w, w);
                  }
                  h2.effectTag |= 4096;
                  h2.expirationTime = b;
                  break a;
                }
                h2 = h2.return;
              } while (null !== h2);
              f = Error((ta(e.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." + Ab(e));
            }
            X !== yf && (X = vf);
            f = Ne(f, e);
            h2 = d;
            do {
              switch (h2.tag) {
                case 3:
                  g3 = f;
                  h2.effectTag |= 4096;
                  h2.expirationTime = b;
                  var r = jf(h2, g3, b);
                  Jc(h2, r);
                  break a;
                case 1:
                  g3 = f;
                  var t2 = h2.type, N = h2.stateNode;
                  if (0 === (h2.effectTag & 64) && ("function" === typeof t2.getDerivedStateFromError || null !== N && "function" === typeof N.componentDidCatch && (null === nf || !nf.has(N)))) {
                    h2.effectTag |= 4096;
                    h2.expirationTime = b;
                    var Mc = mf(h2, g3, b);
                    Jc(h2, Mc);
                    break a;
                  }
              }
              h2 = h2.return;
            } while (null !== h2);
          }
          V2 = gg(V2);
        } catch (Rb) {
          b = Rb;
          continue;
        }
        break;
      } while (1);
    }
    function Xf() {
      var a2 = pf.current;
      pf.current = Md;
      return null === a2 ? Md : a2;
    }
    function Oc(a2, b) {
      a2 < Af && 2 < a2 && (Af = a2);
      null !== b && a2 < Bf && 2 < a2 && (Bf = a2, Cf = b);
    }
    function Pc(a2) {
      a2 > Df && (Df = a2);
    }
    function bg() {
      for (; null !== V2; )
        V2 = hg(V2);
    }
    function Yf() {
      for (; null !== V2 && !Pb(); )
        V2 = hg(V2);
    }
    function hg(a2) {
      var b = ig(a2.alternate, a2, W);
      a2.memoizedProps = a2.pendingProps;
      null === b && (b = gg(a2));
      qf.current = null;
      return b;
    }
    function gg(a2) {
      V2 = a2;
      do {
        var b = V2.alternate;
        a2 = V2.return;
        if (0 === (V2.effectTag & 2048)) {
          a: {
            var c2 = b;
            b = V2;
            var d = W, e = b.pendingProps;
            switch (b.tag) {
              case 2:
                break;
              case 16:
                break;
              case 15:
              case 0:
                break;
              case 1:
                C2(b.type) && Gb();
                break;
              case 3:
                rd();
                Hb();
                e = b.stateNode;
                e.pendingContext && (e.context = e.pendingContext, e.pendingContext = null);
                (null === c2 || null === c2.child) && ne(b) && Fe(b);
                He(b);
                break;
              case 5:
                td(b);
                var f = pd(od.current);
                d = b.type;
                if (null !== c2 && null != b.stateNode)
                  Ie(c2, b, d, e, f), c2.ref !== b.ref && (b.effectTag |= 128);
                else if (e) {
                  c2 = pd(H2.current);
                  if (ne(b)) {
                    e = b;
                    if (!Sa)
                      throw Error(n(175));
                    c2 = ub(e.stateNode, e.type, e.memoizedProps, f, c2, e);
                    e.updateQueue = c2;
                    c2 = null !== c2 ? true : false;
                    c2 && Fe(b);
                  } else {
                    var g3 = Ea(d, e, f, c2, b);
                    _Ge(g3, b, false, false);
                    b.stateNode = g3;
                    Ga(g3, d, e, f, c2) && Fe(b);
                  }
                  null !== b.ref && (b.effectTag |= 128);
                } else if (null === b.stateNode)
                  throw Error(n(166));
                break;
              case 6:
                if (c2 && null != b.stateNode)
                  Je(c2, b, c2.memoizedProps, e);
                else {
                  if ("string" !== typeof e && null === b.stateNode)
                    throw Error(n(166));
                  c2 = pd(od.current);
                  f = pd(H2.current);
                  if (ne(b)) {
                    c2 = b;
                    if (!Sa)
                      throw Error(n(176));
                    (c2 = vb(c2.stateNode, c2.memoizedProps, c2)) && Fe(b);
                  } else
                    b.stateNode = La(e, c2, f, b);
                }
                break;
              case 11:
                break;
              case 13:
                y(I);
                e = b.memoizedState;
                if (0 !== (b.effectTag & 64)) {
                  b.expirationTime = d;
                  break a;
                }
                e = null !== e;
                f = false;
                null === c2 ? void 0 !== b.memoizedProps.fallback && ne(b) : (d = c2.memoizedState, f = null !== d, e || null === d || (d = c2.child.sibling, null !== d && (g3 = b.firstEffect, null !== g3 ? (b.firstEffect = d, d.nextEffect = g3) : (b.firstEffect = b.lastEffect = d, d.nextEffect = null), d.effectTag = 8)));
                if (e && !f && 0 !== (b.mode & 2))
                  if (null === c2 && true !== b.memoizedProps.unstable_avoidThisFallback || 0 !== (I.current & 1))
                    X === tf && (X = wf);
                  else {
                    if (X === tf || X === wf)
                      X = xf;
                    0 !== Df && null !== U && (Pf(U, W), Qf(U, Df));
                  }
                Ra && e && (b.effectTag |= 4);
                Qa && (e || f) && (b.effectTag |= 4);
                break;
              case 7:
                break;
              case 8:
                break;
              case 12:
                break;
              case 4:
                rd();
                He(b);
                break;
              case 10:
                yc(b);
                break;
              case 9:
                break;
              case 14:
                break;
              case 17:
                C2(b.type) && Gb();
                break;
              case 19:
                y(I);
                e = b.memoizedState;
                if (null === e)
                  break;
                f = 0 !== (b.effectTag & 64);
                g3 = e.rendering;
                if (null === g3) {
                  if (f)
                    Le(e, false);
                  else {
                    if (X !== tf || null !== c2 && 0 !== (c2.effectTag & 64))
                      for (c2 = b.child; null !== c2; ) {
                        g3 = ud(c2);
                        if (null !== g3) {
                          b.effectTag |= 64;
                          Le(e, false);
                          c2 = g3.updateQueue;
                          null !== c2 && (b.updateQueue = c2, b.effectTag |= 4);
                          null === e.lastEffect && (b.firstEffect = null);
                          b.lastEffect = e.lastEffect;
                          c2 = d;
                          for (e = b.child; null !== e; )
                            f = e, d = c2, f.effectTag &= 2, f.nextEffect = null, f.firstEffect = null, f.lastEffect = null, g3 = f.alternate, null === g3 ? (f.childExpirationTime = 0, f.expirationTime = d, f.child = null, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null) : (f.childExpirationTime = g3.childExpirationTime, f.expirationTime = g3.expirationTime, f.child = g3.child, f.memoizedProps = g3.memoizedProps, f.memoizedState = g3.memoizedState, f.updateQueue = g3.updateQueue, d = g3.dependencies, f.dependencies = null === d ? null : {
                              expirationTime: d.expirationTime,
                              firstContext: d.firstContext,
                              responders: d.responders
                            }), e = e.sibling;
                          z2(I, I.current & 1 | 2);
                          b = b.child;
                          break a;
                        }
                        c2 = c2.sibling;
                      }
                  }
                } else {
                  if (!f)
                    if (c2 = ud(g3), null !== c2) {
                      if (b.effectTag |= 64, f = true, c2 = c2.updateQueue, null !== c2 && (b.updateQueue = c2, b.effectTag |= 4), Le(e, true), null === e.tail && "hidden" === e.tailMode) {
                        b = b.lastEffect = e.lastEffect;
                        null !== b && (b.nextEffect = null);
                        break;
                      }
                    } else
                      E2() > e.tailExpiration && 1 < d && (b.effectTag |= 64, f = true, Le(e, false), b.expirationTime = b.childExpirationTime = d - 1);
                  e.isBackwards ? (g3.sibling = b.child, b.child = g3) : (c2 = e.last, null !== c2 ? c2.sibling = g3 : b.child = g3, e.last = g3);
                }
                if (null !== e.tail) {
                  0 === e.tailExpiration && (e.tailExpiration = E2() + 500);
                  c2 = e.tail;
                  e.rendering = c2;
                  e.tail = c2.sibling;
                  e.lastEffect = b.lastEffect;
                  c2.sibling = null;
                  e = I.current;
                  e = f ? e & 1 | 2 : e & 1;
                  z2(I, e);
                  b = c2;
                  break a;
                }
                break;
              case 20:
                break;
              case 21:
                break;
              default:
                throw Error(n(156, b.tag));
            }
            b = null;
          }
          c2 = V2;
          if (1 === W || 1 !== c2.childExpirationTime) {
            e = 0;
            for (f = c2.child; null !== f; )
              d = f.expirationTime, g3 = f.childExpirationTime, d > e && (e = d), g3 > e && (e = g3), f = f.sibling;
            c2.childExpirationTime = e;
          }
          if (null !== b)
            return b;
          null !== a2 && 0 === (a2.effectTag & 2048) && (null === a2.firstEffect && (a2.firstEffect = V2.firstEffect), null !== V2.lastEffect && (null !== a2.lastEffect && (a2.lastEffect.nextEffect = V2.firstEffect), a2.lastEffect = V2.lastEffect), 1 < V2.effectTag && (null !== a2.lastEffect ? a2.lastEffect.nextEffect = V2 : a2.firstEffect = V2, a2.lastEffect = V2));
        } else {
          b = Me(V2);
          if (null !== b)
            return b.effectTag &= 2047, b;
          null !== a2 && (a2.firstEffect = a2.lastEffect = null, a2.effectTag |= 2048);
        }
        b = V2.sibling;
        if (null !== b)
          return b;
        V2 = a2;
      } while (null !== V2);
      X === tf && (X = yf);
      return null;
    }
    function $f(a2) {
      var b = a2.expirationTime;
      a2 = a2.childExpirationTime;
      return b > a2 ? b : a2;
    }
    function ag(a2) {
      var b = fc();
      hc(99, jg.bind(null, a2, b));
      return null;
    }
    function jg(a2, b) {
      Vf();
      if ((T2 & (S2 | sf)) !== R3)
        throw Error(n(327));
      var c2 = a2.finishedWork, d = a2.finishedExpirationTime;
      if (null === c2)
        return null;
      a2.finishedWork = null;
      a2.finishedExpirationTime = 0;
      if (c2 === a2.current)
        throw Error(n(177));
      a2.callbackNode = null;
      a2.callbackExpirationTime = 0;
      a2.callbackPriority = 90;
      a2.nextKnownPendingLevel = 0;
      var e = $f(c2);
      a2.firstPendingTime = e;
      d <= a2.lastSuspendedTime ? a2.firstSuspendedTime = a2.lastSuspendedTime = a2.nextKnownPendingLevel = 0 : d <= a2.firstSuspendedTime && (a2.firstSuspendedTime = d - 1);
      d <= a2.lastPingedTime && (a2.lastPingedTime = 0);
      d <= a2.lastExpiredTime && (a2.lastExpiredTime = 0);
      a2 === U && (V2 = U = null, W = 0);
      1 < c2.effectTag ? null !== c2.lastEffect ? (c2.lastEffect.nextEffect = c2, e = c2.firstEffect) : e = c2 : e = c2.firstEffect;
      if (null !== e) {
        var f = T2;
        T2 |= sf;
        qf.current = null;
        Ca(a2.containerInfo);
        Y = e;
        do
          try {
            kg();
          } catch (jb) {
            if (null === Y)
              throw Error(n(330));
            Re(Y, jb);
            Y = Y.nextEffect;
          }
        while (null !== Y);
        Y = e;
        do
          try {
            for (var g3 = a2, l2 = b; null !== Y; ) {
              var h2 = Y.effectTag;
              h2 & 16 && Qa && bb(Y.stateNode);
              if (h2 & 128) {
                var k = Y.alternate;
                if (null !== k) {
                  var p = k.ref;
                  null !== p && ("function" === typeof p ? p(null) : p.current = null);
                }
              }
              switch (h2 & 1038) {
                case 2:
                  bf(Y);
                  Y.effectTag &= -3;
                  break;
                case 6:
                  bf(Y);
                  Y.effectTag &= -3;
                  cf(Y.alternate, Y);
                  break;
                case 1024:
                  Y.effectTag &= -1025;
                  break;
                case 1028:
                  Y.effectTag &= -1025;
                  cf(Y.alternate, Y);
                  break;
                case 4:
                  cf(Y.alternate, Y);
                  break;
                case 8:
                  var D = g3, x = Y, K = l2;
                  Qa ? Xe(D, x, K) : Ze(D, x, K);
                  $e(x);
              }
              Y = Y.nextEffect;
            }
          } catch (jb) {
            if (null === Y)
              throw Error(n(330));
            Re(Y, jb);
            Y = Y.nextEffect;
          }
        while (null !== Y);
        Da(a2.containerInfo);
        a2.current = c2;
        Y = e;
        do
          try {
            for (h2 = d; null !== Y; ) {
              var Ha = Y.effectTag;
              if (Ha & 36) {
                var O = Y.alternate;
                k = Y;
                p = h2;
                switch (k.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Ue(16, 32, k);
                    break;
                  case 1:
                    var w = k.stateNode;
                    if (k.effectTag & 4)
                      if (null === O)
                        w.componentDidMount();
                      else {
                        var r = k.elementType === k.type ? O.memoizedProps : rc(k.type, O.memoizedProps);
                        w.componentDidUpdate(r, O.memoizedState, w.__reactInternalSnapshotBeforeUpdate);
                      }
                    var t2 = k.updateQueue;
                    null !== t2 && Qc(k, t2, w, p);
                    break;
                  case 3:
                    var N = k.updateQueue;
                    if (null !== N) {
                      g3 = null;
                      if (null !== k.child)
                        switch (k.child.tag) {
                          case 5:
                            g3 = za(k.child.stateNode);
                            break;
                          case 1:
                            g3 = k.child.stateNode;
                        }
                      Qc(k, N, g3, p);
                    }
                    break;
                  case 5:
                    var Mc = k.stateNode;
                    null === O && k.effectTag & 4 && Wa(Mc, k.type, k.memoizedProps, k);
                    break;
                  case 6:
                    break;
                  case 4:
                    break;
                  case 12:
                    break;
                  case 13:
                    if (Sa && null === k.memoizedState) {
                      var Rb = k.alternate;
                      if (null !== Rb) {
                        var le = Rb.memoizedState;
                        if (null !== le) {
                          var me = le.dehydrated;
                          null !== me && yb(me);
                        }
                      }
                    }
                    break;
                  case 19:
                  case 17:
                  case 20:
                  case 21:
                    break;
                  default:
                    throw Error(n(163));
                }
              }
              if (Ha & 128) {
                k = void 0;
                var Sb = Y.ref;
                if (null !== Sb) {
                  var v2 = Y.stateNode;
                  switch (Y.tag) {
                    case 5:
                      k = za(v2);
                      break;
                    default:
                      k = v2;
                  }
                  "function" === typeof Sb ? Sb(k) : Sb.current = k;
                }
              }
              Y = Y.nextEffect;
            }
          } catch (jb) {
            if (null === Y)
              throw Error(n(330));
            Re(Y, jb);
            Y = Y.nextEffect;
          }
        while (null !== Y);
        Y = null;
        ac();
        T2 = f;
      } else
        a2.current = c2;
      if (Gf)
        Gf = false, Hf = a2, If = b;
      else
        for (Y = e; null !== Y; )
          b = Y.nextEffect, Y.nextEffect = null, Y = b;
      b = a2.firstPendingTime;
      0 === b && (nf = null);
      1073741823 === b ? a2 === Lf ? Kf++ : (Kf = 0, Lf = a2) : Kf = 0;
      "function" === typeof lg && lg(c2.stateNode, d);
      Z2(a2);
      if (kf)
        throw kf = false, a2 = lf, lf = null, a2;
      if ((T2 & rf) !== R3)
        return null;
      F();
      return null;
    }
    function kg() {
      for (; null !== Y; ) {
        var a2 = Y.effectTag;
        0 !== (a2 & 256) && Te(Y.alternate, Y);
        0 === (a2 & 512) || Gf || (Gf = true, ic(97, function() {
          Vf();
          return null;
        }));
        Y = Y.nextEffect;
      }
    }
    function Vf() {
      if (90 !== If) {
        var a2 = 97 < If ? 97 : If;
        If = 90;
        return hc(a2, mg);
      }
    }
    function mg() {
      if (null === Hf)
        return false;
      var a2 = Hf;
      Hf = null;
      if ((T2 & (S2 | sf)) !== R3)
        throw Error(n(331));
      var b = T2;
      T2 |= sf;
      for (a2 = a2.current.firstEffect; null !== a2; ) {
        try {
          var c2 = a2;
          if (0 !== (c2.effectTag & 512))
            switch (c2.tag) {
              case 0:
              case 11:
              case 15:
                Ue(128, 0, c2), Ue(0, 64, c2);
            }
        } catch (d) {
          if (null === a2)
            throw Error(n(330));
          Re(a2, d);
        }
        c2 = a2.nextEffect;
        a2.nextEffect = null;
        a2 = c2;
      }
      T2 = b;
      F();
      return true;
    }
    function ng(a2, b, c2) {
      b = Ne(c2, b);
      b = jf(a2, b, 1073741823);
      Ic(a2, b);
      a2 = Nf(a2, 1073741823);
      null !== a2 && Z2(a2);
    }
    function Re(a2, b) {
      if (3 === a2.tag)
        ng(a2, a2, b);
      else
        for (var c2 = a2.return; null !== c2; ) {
          if (3 === c2.tag) {
            ng(c2, a2, b);
            break;
          } else if (1 === c2.tag) {
            var d = c2.stateNode;
            if ("function" === typeof c2.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === nf || !nf.has(d))) {
              a2 = Ne(b, a2);
              a2 = mf(c2, a2, 1073741823);
              Ic(c2, a2);
              c2 = Nf(c2, 1073741823);
              null !== c2 && Z2(c2);
              break;
            }
          }
          c2 = c2.return;
        }
    }
    function fg(a2, b, c2) {
      var d = a2.pingCache;
      null !== d && d.delete(b);
      U === a2 && W === c2 ? X === xf || X === wf && 1073741823 === Af && E2() - ff < Ff ? Wf(a2, W) : Ef = true : Sf(a2, c2) && (b = a2.lastPingedTime, 0 !== b && b < c2 || (a2.lastPingedTime = c2, a2.finishedExpirationTime === c2 && (a2.finishedExpirationTime = 0, a2.finishedWork = null), Z2(a2)));
    }
    function gf(a2, b) {
      var c2 = a2.stateNode;
      null !== c2 && c2.delete(b);
      b = 0;
      0 === b && (b = G2(), b = Vc(b, a2, null));
      a2 = Nf(a2, b);
      null !== a2 && Z2(a2);
    }
    var ig;
    ig = function ig2(a2, b, c2) {
      var d = b.expirationTime;
      if (null !== a2) {
        var e = b.pendingProps;
        if (a2.memoizedProps !== e || B.current)
          Bc = true;
        else {
          if (d < c2) {
            Bc = false;
            switch (b.tag) {
              case 3:
                ze(b);
                oe();
                break;
              case 5:
                sd(b);
                if (b.mode & 4 && 1 !== c2 && Ka(b.type, e))
                  return b.expirationTime = b.childExpirationTime = 1, null;
                break;
              case 1:
                C2(b.type) && Kb(b);
                break;
              case 4:
                qd(b, b.stateNode.containerInfo);
                break;
              case 10:
                xc(b, b.memoizedProps.value);
                break;
              case 13:
                if (null !== b.memoizedState) {
                  d = b.child.childExpirationTime;
                  if (0 !== d && d >= c2)
                    return Be(a2, b, c2);
                  z2(I, I.current & 1);
                  b = re(a2, b, c2);
                  return null !== b ? b.sibling : null;
                }
                z2(I, I.current & 1);
                break;
              case 19:
                d = b.childExpirationTime >= c2;
                if (0 !== (a2.effectTag & 64)) {
                  if (d)
                    return Ee(a2, b, c2);
                  b.effectTag |= 64;
                }
                e = b.memoizedState;
                null !== e && (e.rendering = null, e.tail = null);
                z2(I, I.current);
                if (!d)
                  return null;
            }
            return re(a2, b, c2);
          }
          Bc = false;
        }
      } else
        Bc = false;
      b.expirationTime = 0;
      switch (b.tag) {
        case 2:
          d = b.type;
          null !== a2 && (a2.alternate = null, b.alternate = null, b.effectTag |= 2);
          a2 = b.pendingProps;
          e = Fb(b, A2.current);
          Ac(b, c2);
          e = Jd(null, b, d, a2, e, c2);
          b.effectTag |= 1;
          if ("object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof) {
            b.tag = 1;
            Nd();
            if (C2(d)) {
              var f = true;
              Kb(b);
            } else
              f = false;
            b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null;
            var g3 = d.getDerivedStateFromProps;
            "function" === typeof g3 && Uc(b, d, g3, a2);
            e.updater = Xc;
            b.stateNode = e;
            e._reactInternalFiber = b;
            ad(b, d, a2, c2);
            b = ye(null, b, d, true, f, c2);
          } else
            b.tag = 0, Q2(null, b, e, c2), b = b.child;
          return b;
        case 16:
          e = b.elementType;
          null !== a2 && (a2.alternate = null, b.alternate = null, b.effectTag |= 2);
          a2 = b.pendingProps;
          sa(e);
          if (1 !== e._status)
            throw e._result;
          e = e._result;
          b.type = e;
          f = b.tag = og(e);
          a2 = rc(e, a2);
          switch (f) {
            case 0:
              b = ve(null, b, e, a2, c2);
              break;
            case 1:
              b = xe(null, b, e, a2, c2);
              break;
            case 11:
              b = qe(null, b, e, a2, c2);
              break;
            case 14:
              b = se(null, b, e, rc(e.type, a2), d, c2);
              break;
            default:
              throw Error(n(306, e, ""));
          }
          return b;
        case 0:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : rc(d, e), ve(a2, b, d, e, c2);
        case 1:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : rc(d, e), xe(a2, b, d, e, c2);
        case 3:
          ze(b);
          d = b.updateQueue;
          if (null === d)
            throw Error(n(282));
          e = b.memoizedState;
          e = null !== e ? e.element : null;
          Nc(b, d, b.pendingProps, null, c2);
          d = b.memoizedState.element;
          if (d === e)
            oe(), b = re(a2, b, c2);
          else {
            if (e = b.stateNode.hydrate)
              Sa ? (ee = tb(b.stateNode.containerInfo), de = b, e = fe = true) : e = false;
            if (e)
              for (c2 = ld(b, null, d, c2), b.child = c2; c2; )
                c2.effectTag = c2.effectTag & -3 | 1024, c2 = c2.sibling;
            else
              Q2(a2, b, d, c2), oe();
            b = b.child;
          }
          return b;
        case 5:
          return sd(b), null === a2 && je(b), d = b.type, e = b.pendingProps, f = null !== a2 ? a2.memoizedProps : null, g3 = e.children, Ja(d, e) ? g3 = null : null !== f && Ja(d, f) && (b.effectTag |= 16), we(a2, b), b.mode & 4 && 1 !== c2 && Ka(d, e) ? (b.expirationTime = b.childExpirationTime = 1, b = null) : (Q2(a2, b, g3, c2), b = b.child), b;
        case 6:
          return null === a2 && je(b), null;
        case 13:
          return Be(a2, b, c2);
        case 4:
          return qd(b, b.stateNode.containerInfo), d = b.pendingProps, null === a2 ? b.child = kd(b, null, d, c2) : Q2(a2, b, d, c2), b.child;
        case 11:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : rc(d, e), qe(a2, b, d, e, c2);
        case 7:
          return Q2(a2, b, b.pendingProps, c2), b.child;
        case 8:
          return Q2(a2, b, b.pendingProps.children, c2), b.child;
        case 12:
          return Q2(a2, b, b.pendingProps.children, c2), b.child;
        case 10:
          a: {
            d = b.type._context;
            e = b.pendingProps;
            g3 = b.memoizedProps;
            f = e.value;
            xc(b, f);
            if (null !== g3) {
              var l2 = g3.value;
              f = oc(l2, f) ? 0 : ("function" === typeof d._calculateChangedBits ? d._calculateChangedBits(l2, f) : 1073741823) | 0;
              if (0 === f) {
                if (g3.children === e.children && !B.current) {
                  b = re(a2, b, c2);
                  break a;
                }
              } else
                for (l2 = b.child, null !== l2 && (l2.return = b); null !== l2; ) {
                  var h2 = l2.dependencies;
                  if (null !== h2) {
                    g3 = l2.child;
                    for (var k = h2.firstContext; null !== k; ) {
                      if (k.context === d && 0 !== (k.observedBits & f)) {
                        1 === l2.tag && (k = Gc(c2, null), k.tag = 2, Ic(l2, k));
                        l2.expirationTime < c2 && (l2.expirationTime = c2);
                        k = l2.alternate;
                        null !== k && k.expirationTime < c2 && (k.expirationTime = c2);
                        zc(l2.return, c2);
                        h2.expirationTime < c2 && (h2.expirationTime = c2);
                        break;
                      }
                      k = k.next;
                    }
                  } else
                    g3 = 10 === l2.tag ? l2.type === b.type ? null : l2.child : l2.child;
                  if (null !== g3)
                    g3.return = l2;
                  else
                    for (g3 = l2; null !== g3; ) {
                      if (g3 === b) {
                        g3 = null;
                        break;
                      }
                      l2 = g3.sibling;
                      if (null !== l2) {
                        l2.return = g3.return;
                        g3 = l2;
                        break;
                      }
                      g3 = g3.return;
                    }
                  l2 = g3;
                }
            }
            Q2(a2, b, e.children, c2);
            b = b.child;
          }
          return b;
        case 9:
          return e = b.type, f = b.pendingProps, d = f.children, Ac(b, c2), e = Cc(e, f.unstable_observedBits), d = d(e), b.effectTag |= 1, Q2(a2, b, d, c2), b.child;
        case 14:
          return e = b.type, f = rc(e, b.pendingProps), f = rc(e.type, f), se(a2, b, e, f, d, c2);
        case 15:
          return ue(a2, b, b.type, b.pendingProps, d, c2);
        case 17:
          return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : rc(d, e), null !== a2 && (a2.alternate = null, b.alternate = null, b.effectTag |= 2), b.tag = 1, C2(d) ? (a2 = true, Kb(b)) : a2 = false, Ac(b, c2), Zc(b, d, e), ad(b, d, e, c2), ye(null, b, d, true, a2, c2);
        case 19:
          return Ee(a2, b, c2);
      }
      throw Error(n(156, b.tag));
    };
    var lg = null, We = null;
    function pg(a2) {
      if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)
        return false;
      var b = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (b.isDisabled || !b.supportsFiber)
        return true;
      try {
        var c2 = b.inject(a2);
        lg = function lg2(a3) {
          try {
            b.onCommitFiberRoot(c2, a3, void 0, 64 === (a3.current.effectTag & 64));
          } catch (e) {
          }
        };
        We = function We2(a3) {
          try {
            b.onCommitFiberUnmount(c2, a3);
          } catch (e) {
          }
        };
      } catch (d) {
      }
      return true;
    }
    function qg(a2, b, c2, d) {
      this.tag = a2;
      this.key = c2;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d;
      this.effectTag = 0;
      this.lastEffect = this.firstEffect = this.nextEffect = null;
      this.childExpirationTime = this.expirationTime = 0;
      this.alternate = null;
    }
    function he(a2, b, c2, d) {
      return new qg(a2, b, c2, d);
    }
    function te(a2) {
      a2 = a2.prototype;
      return !(!a2 || !a2.isReactComponent);
    }
    function og(a2) {
      if ("function" === typeof a2)
        return te(a2) ? 1 : 0;
      if (void 0 !== a2 && null !== a2) {
        a2 = a2.$$typeof;
        if (a2 === la)
          return 11;
        if (a2 === oa)
          return 14;
      }
      return 2;
    }
    function fd(a2, b) {
      var c2 = a2.alternate;
      null === c2 ? (c2 = he(a2.tag, b, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b, c2.effectTag = 0, c2.nextEffect = null, c2.firstEffect = null, c2.lastEffect = null);
      c2.childExpirationTime = a2.childExpirationTime;
      c2.expirationTime = a2.expirationTime;
      c2.child = a2.child;
      c2.memoizedProps = a2.memoizedProps;
      c2.memoizedState = a2.memoizedState;
      c2.updateQueue = a2.updateQueue;
      b = a2.dependencies;
      c2.dependencies = null === b ? null : {
        expirationTime: b.expirationTime,
        firstContext: b.firstContext,
        responders: b.responders
      };
      c2.sibling = a2.sibling;
      c2.index = a2.index;
      c2.ref = a2.ref;
      return c2;
    }
    function hd(a2, b, c2, d, e, f) {
      var g3 = 2;
      d = a2;
      if ("function" === typeof a2)
        te(a2) && (g3 = 1);
      else if ("string" === typeof a2)
        g3 = 5;
      else
        a:
          switch (a2) {
            case ea:
              return jd(c2.children, e, f, b);
            case ka:
              g3 = 8;
              e |= 7;
              break;
            case fa:
              g3 = 8;
              e |= 1;
              break;
            case ha:
              return a2 = he(12, c2, b, e | 8), a2.elementType = ha, a2.type = ha, a2.expirationTime = f, a2;
            case ma:
              return a2 = he(13, c2, b, e), a2.type = ma, a2.elementType = ma, a2.expirationTime = f, a2;
            case na:
              return a2 = he(19, c2, b, e), a2.elementType = na, a2.expirationTime = f, a2;
            default:
              if ("object" === typeof a2 && null !== a2)
                switch (a2.$$typeof) {
                  case ia:
                    g3 = 10;
                    break a;
                  case ja:
                    g3 = 9;
                    break a;
                  case la:
                    g3 = 11;
                    break a;
                  case oa:
                    g3 = 14;
                    break a;
                  case pa:
                    g3 = 16;
                    d = null;
                    break a;
                }
              throw Error(n(130, null == a2 ? a2 : typeof a2, ""));
          }
      b = he(g3, c2, b, e);
      b.elementType = a2;
      b.type = d;
      b.expirationTime = f;
      return b;
    }
    function jd(a2, b, c2, d) {
      a2 = he(7, a2, d, b);
      a2.expirationTime = c2;
      return a2;
    }
    function gd(a2, b, c2) {
      a2 = he(6, a2, null, b);
      a2.expirationTime = c2;
      return a2;
    }
    function id(a2, b, c2) {
      b = he(4, null !== a2.children ? a2.children : [], a2.key, b);
      b.expirationTime = c2;
      b.stateNode = {
        containerInfo: a2.containerInfo,
        pendingChildren: null,
        implementation: a2.implementation
      };
      return b;
    }
    function rg(a2, b, c2) {
      this.tag = b;
      this.current = null;
      this.containerInfo = a2;
      this.pingCache = this.pendingChildren = null;
      this.finishedExpirationTime = 0;
      this.finishedWork = null;
      this.timeoutHandle = Oa;
      this.pendingContext = this.context = null;
      this.hydrate = c2;
      this.callbackNode = null;
      this.callbackPriority = 90;
      this.lastExpiredTime = this.lastPingedTime = this.nextKnownPendingLevel = this.lastSuspendedTime = this.firstSuspendedTime = this.firstPendingTime = 0;
    }
    function Sf(a2, b) {
      var c2 = a2.firstSuspendedTime;
      a2 = a2.lastSuspendedTime;
      return 0 !== c2 && c2 >= b && a2 <= b;
    }
    function Pf(a2, b) {
      var c2 = a2.firstSuspendedTime, d = a2.lastSuspendedTime;
      c2 < b && (a2.firstSuspendedTime = b);
      if (d > b || 0 === c2)
        a2.lastSuspendedTime = b;
      b <= a2.lastPingedTime && (a2.lastPingedTime = 0);
      b <= a2.lastExpiredTime && (a2.lastExpiredTime = 0);
    }
    function Qf(a2, b) {
      b > a2.firstPendingTime && (a2.firstPendingTime = b);
      var c2 = a2.firstSuspendedTime;
      0 !== c2 && (b >= c2 ? a2.firstSuspendedTime = a2.lastSuspendedTime = a2.nextKnownPendingLevel = 0 : b >= a2.lastSuspendedTime && (a2.lastSuspendedTime = b + 1), b > a2.nextKnownPendingLevel && (a2.nextKnownPendingLevel = b));
    }
    function Uf(a2, b) {
      var c2 = a2.lastExpiredTime;
      if (0 === c2 || c2 > b)
        a2.lastExpiredTime = b;
    }
    function sg(a2) {
      var b = a2._reactInternalFiber;
      if (void 0 === b) {
        if ("function" === typeof a2.render)
          throw Error(n(188));
        throw Error(n(268, Object.keys(a2)));
      }
      a2 = xa(b);
      return null === a2 ? null : a2.stateNode;
    }
    function tg(a2, b) {
      a2 = a2.memoizedState;
      null !== a2 && null !== a2.dehydrated && a2.retryTime < b && (a2.retryTime = b);
    }
    function ug(a2, b) {
      tg(a2, b);
      (a2 = a2.alternate) && tg(a2, b);
    }
    var vg = {
      createContainer: function createContainer(a2, b, c2) {
        a2 = new rg(a2, b, c2);
        b = he(3, null, null, 2 === b ? 7 : 1 === b ? 3 : 0);
        a2.current = b;
        return b.stateNode = a2;
      },
      updateContainer: function updateContainer(a2, b, c2, d) {
        var e = b.current, f = G2(), g3 = Sc.suspense;
        f = Vc(f, e, g3);
        a:
          if (c2) {
            c2 = c2._reactInternalFiber;
            b: {
              if (ua(c2) !== c2 || 1 !== c2.tag)
                throw Error(n(170));
              var l2 = c2;
              do {
                switch (l2.tag) {
                  case 3:
                    l2 = l2.stateNode.context;
                    break b;
                  case 1:
                    if (C2(l2.type)) {
                      l2 = l2.stateNode.__reactInternalMemoizedMergedChildContext;
                      break b;
                    }
                }
                l2 = l2.return;
              } while (null !== l2);
              throw Error(n(171));
            }
            if (1 === c2.tag) {
              var h2 = c2.type;
              if (C2(h2)) {
                c2 = Jb(c2, h2, l2);
                break a;
              }
            }
            c2 = l2;
          } else
            c2 = Db;
        null === b.context ? b.context = c2 : b.pendingContext = c2;
        b = Gc(f, g3);
        b.payload = {
          element: a2
        };
        d = void 0 === d ? null : d;
        null !== d && (b.callback = d);
        Ic(e, b);
        Wc(e, f);
        return f;
      },
      batchedEventUpdates: function batchedEventUpdates(a2, b) {
        var c2 = T2;
        T2 |= 2;
        try {
          return a2(b);
        } finally {
          T2 = c2, T2 === R3 && F();
        }
      },
      batchedUpdates: function batchedUpdates(a2, b) {
        var c2 = T2;
        T2 |= 1;
        try {
          return a2(b);
        } finally {
          T2 = c2, T2 === R3 && F();
        }
      },
      unbatchedUpdates: function unbatchedUpdates(a2, b) {
        var c2 = T2;
        T2 &= -2;
        T2 |= rf;
        try {
          return a2(b);
        } finally {
          T2 = c2, T2 === R3 && F();
        }
      },
      deferredUpdates: function deferredUpdates(a2) {
        return hc(97, a2);
      },
      syncUpdates: function syncUpdates(a2, b, c2, d) {
        return hc(99, a2.bind(null, b, c2, d));
      },
      discreteUpdates: function discreteUpdates(a2, b, c2, d) {
        var e = T2;
        T2 |= 4;
        try {
          return hc(98, a2.bind(null, b, c2, d));
        } finally {
          T2 = e, T2 === R3 && F();
        }
      },
      flushDiscreteUpdates: function flushDiscreteUpdates() {
        (T2 & (1 | S2 | sf)) === R3 && (dg(), Vf());
      },
      flushControlled: function flushControlled(a2) {
        var b = T2;
        T2 |= 1;
        try {
          hc(99, a2);
        } finally {
          T2 = b, T2 === R3 && F();
        }
      },
      flushSync: eg,
      flushPassiveEffects: Vf,
      IsThisRendererActing: {
        current: false
      },
      getPublicRootInstance: function getPublicRootInstance(a2) {
        a2 = a2.current;
        if (!a2.child)
          return null;
        switch (a2.child.tag) {
          case 5:
            return za(a2.child.stateNode);
          default:
            return a2.child.stateNode;
        }
      },
      attemptSynchronousHydration: function attemptSynchronousHydration(a2) {
        switch (a2.tag) {
          case 3:
            var b = a2.stateNode;
            b.hydrate && cg(b, b.firstPendingTime);
            break;
          case 13:
            eg(function() {
              return Wc(a2, 1073741823);
            }), b = mc(G2(), 150, 100), ug(a2, b);
        }
      },
      attemptUserBlockingHydration: function attemptUserBlockingHydration(a2) {
        if (13 === a2.tag) {
          var b = mc(G2(), 150, 100);
          Wc(a2, b);
          ug(a2, b);
        }
      },
      attemptContinuousHydration: function attemptContinuousHydration(a2) {
        if (13 === a2.tag) {
          G2();
          var b = lc++;
          Wc(a2, b);
          ug(a2, b);
        }
      },
      attemptHydrationAtCurrentPriority: function attemptHydrationAtCurrentPriority(a2) {
        if (13 === a2.tag) {
          var b = G2();
          b = Vc(b, a2, null);
          Wc(a2, b);
          ug(a2, b);
        }
      },
      findHostInstance: sg,
      findHostInstanceWithWarning: function findHostInstanceWithWarning(a2) {
        return sg(a2);
      },
      findHostInstanceWithNoPortals: function findHostInstanceWithNoPortals(a2) {
        a2 = ya(a2);
        return null === a2 ? null : 20 === a2.tag ? a2.stateNode.instance : a2.stateNode;
      },
      shouldSuspend: function shouldSuspend() {
        return false;
      },
      injectIntoDevTools: function injectIntoDevTools(a2) {
        var b = a2.findFiberByHostInstance;
        return pg(aa({}, a2, {
          overrideHookState: null,
          overrideProps: null,
          setSuspenseHandler: null,
          scheduleUpdate: null,
          currentDispatcherRef: q2.ReactCurrentDispatcher,
          findHostInstanceByFiber: function findHostInstanceByFiber(a3) {
            a3 = xa(a3);
            return null === a3 ? null : a3.stateNode;
          },
          findFiberByHostInstance: function findFiberByHostInstance(a3) {
            return b ? b(a3) : null;
          },
          findHostInstancesForRefresh: null,
          scheduleRefresh: null,
          scheduleRoot: null,
          setRefreshHandler: null,
          getCurrentFiber: null
        }));
      }
    };
    module.exports = vg.default || vg;
    var $$$renderer = module.exports;
    module.exports = $$$reconciler;
    return $$$renderer;
  };
})(reactReconciler_production_min);
var ReactFiberReconciler = reactReconciler_production_min.exports;
var propsEqual = function propsEqual2(a2, b) {
  var oldPropsKeys = Object.keys(a2);
  var newPropsKeys = Object.keys(b);
  if (oldPropsKeys.length !== newPropsKeys.length) {
    return false;
  }
  for (var i = 0; i < oldPropsKeys.length; i += 1) {
    var propName = oldPropsKeys[i];
    if (propName === "render" && !a2[propName] !== !b[propName]) {
      return false;
    }
    if (propName !== "children" && a2[propName] !== b[propName]) {
      if (typeof a2[propName] === "object" && typeof b[propName] === "object" && propsEqual2(a2[propName], b[propName])) {
        continue;
      }
      return false;
    }
    if (propName === "children" && (typeof a2[propName] === "string" || typeof b[propName] === "string")) {
      return a2[propName] === b[propName];
    }
  }
  return true;
};
var _excluded$1 = ["style", "children"];
var _excluded22 = ["style"];
var emptyObject = {};
var appendChild = function appendChild2(parentInstance, child) {
  var isParentText = parentInstance.type === "TEXT" || parentInstance.type === "LINK" || parentInstance.type === "TSPAN";
  var isChildTextInstance = child.type === "TEXT_INSTANCE";
  var isOrphanTextInstance = isChildTextInstance && !isParentText;
  if (isOrphanTextInstance) {
    console.warn("Invalid '" + child.value + "' string child outside <Text> component");
    return;
  }
  parentInstance.children.push(child);
};
var createRenderer = function createRenderer2(_ref) {
  var _ref$onChange = _ref.onChange, onChange = _ref$onChange === void 0 ? function() {
  } : _ref$onChange;
  return ReactFiberReconciler({
    schedulePassiveEffects: scheduler.unstable_scheduleCallback,
    cancelPassiveEffects: scheduler.unstable_cancelCallback,
    supportsMutation: true,
    isPrimaryRenderer: false,
    warnsIfNotActing: false,
    appendInitialChild: appendChild,
    createInstance: function createInstance(type, _ref2) {
      var style = _ref2.style;
      _ref2.children;
      var props = _objectWithoutPropertiesLoose4(_ref2, _excluded$1);
      return {
        type,
        box: {},
        style: style || {},
        props: props || {},
        children: []
      };
    },
    createTextInstance: function createTextInstance(text2, rootContainerInstance) {
      return {
        type: "TEXT_INSTANCE",
        value: text2
      };
    },
    finalizeInitialChildren: function finalizeInitialChildren(element, type, props) {
      return false;
    },
    getPublicInstance: function getPublicInstance(instance) {
      return instance;
    },
    prepareForCommit: function prepareForCommit() {
    },
    clearContainer: function clearContainer() {
    },
    prepareUpdate: function prepareUpdate(element, type, oldProps, newProps) {
      return !propsEqual(oldProps, newProps);
    },
    resetAfterCommit: onChange,
    resetTextContent: function resetTextContent(element) {
    },
    getRootHostContext: function getRootHostContext() {
      return emptyObject;
    },
    getChildHostContext: function getChildHostContext() {
      return emptyObject;
    },
    shouldSetTextContent: function shouldSetTextContent(type, props) {
      return false;
    },
    now: Date.now,
    useSyncScheduling: true,
    appendChild,
    appendChildToContainer: function appendChildToContainer(parentInstance, child) {
      if (parentInstance.type === "ROOT") {
        parentInstance.document = child;
      } else {
        appendChild(parentInstance, child);
      }
    },
    insertBefore: function insertBefore(parentInstance, child, beforeChild) {
      var _parentInstance$child;
      var index3 = (_parentInstance$child = parentInstance.children) === null || _parentInstance$child === void 0 ? void 0 : _parentInstance$child.indexOf(beforeChild);
      if (index3 === void 0)
        return;
      if (index3 !== -1 && child)
        parentInstance.children.splice(index3, 0, child);
    },
    removeChild: function removeChild(parentInstance, child) {
      var _parentInstance$child2;
      var index3 = (_parentInstance$child2 = parentInstance.children) === null || _parentInstance$child2 === void 0 ? void 0 : _parentInstance$child2.indexOf(child);
      if (index3 === void 0)
        return;
      if (index3 !== -1)
        parentInstance.children.splice(index3, 1);
    },
    removeChildFromContainer: function removeChildFromContainer(parentInstance, child) {
      var _parentInstance$child3;
      var index3 = (_parentInstance$child3 = parentInstance.children) === null || _parentInstance$child3 === void 0 ? void 0 : _parentInstance$child3.indexOf(child);
      if (index3 === void 0)
        return;
      if (index3 !== -1)
        parentInstance.children.splice(index3, 1);
    },
    commitTextUpdate: function commitTextUpdate(textInstance, oldText, newText) {
      textInstance.value = newText;
    },
    commitUpdate: function commitUpdate(instance, updatePayload, type, oldProps, newProps) {
      var style = newProps.style, props = _objectWithoutPropertiesLoose4(newProps, _excluded22);
      instance.props = props;
      instance.style = style;
    }
  });
};
var version3 = "3.1.12";
var fontStore = new FontStore();
var renderer;
var events3 = {};
var pdf = function pdf2(initialValue) {
  var onChange = function onChange2() {
    var _events$change;
    var listeners3 = ((_events$change = events3.change) === null || _events$change === void 0 ? void 0 : _events$change.slice()) || [];
    for (var i = 0; i < listeners3.length; i += 1)
      listeners3[i]();
  };
  var container = {
    type: "ROOT",
    document: null
  };
  renderer = renderer || createRenderer({
    onChange
  });
  var mountNode = renderer.createContainer(container);
  var updateContainer = function updateContainer2(doc) {
    renderer.updateContainer(doc, mountNode, null);
  };
  if (initialValue)
    updateContainer(initialValue);
  var render5 = function() {
    var _ref = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(compress) {
      var props, pdfVersion, language, pageLayout, pageMode, ctx, layout2, fileStream;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              if (compress === void 0) {
                compress = true;
              }
              props = container.document.props || {};
              pdfVersion = props.pdfVersion, language = props.language, pageLayout = props.pageLayout, pageMode = props.pageMode;
              ctx = new PDFDocument({
                compress,
                pdfVersion,
                lang: language,
                displayTitle: true,
                autoFirstPage: false,
                pageLayout,
                pageMode
              });
              _context.next = 6;
              return layout(container.document, fontStore);
            case 6:
              layout2 = _context.sent;
              fileStream = render(ctx, layout2);
              return _context.abrupt("return", {
                layout: layout2,
                fileStream
              });
            case 9:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return function render6(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  var callOnRender = function callOnRender2(params) {
    if (params === void 0) {
      params = {};
    }
    if (container.document.props.onRender) {
      container.document.props.onRender(params);
    }
  };
  var toBlob = function() {
    var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2() {
      var chunks, _yield$render, _INTERNAL__LAYOUT__DATA_, instance;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              chunks = [];
              _context2.next = 3;
              return render5();
            case 3:
              _yield$render = _context2.sent;
              _INTERNAL__LAYOUT__DATA_ = _yield$render.layout;
              instance = _yield$render.fileStream;
              return _context2.abrupt("return", new Promise(function(resolve3, reject) {
                instance.on("data", function(chunk) {
                  chunks.push(chunk instanceof Uint8Array ? chunk : new Uint8Array(chunk));
                });
                instance.on("end", function() {
                  try {
                    var blob = new Blob(chunks, {
                      type: "application/pdf"
                    });
                    callOnRender({
                      blob,
                      _INTERNAL__LAYOUT__DATA_
                    });
                    resolve3(blob);
                  } catch (error) {
                    reject(error);
                  }
                });
              }));
            case 7:
            case "end":
              return _context2.stop();
          }
      }, _callee2);
    }));
    return function toBlob2() {
      return _ref2.apply(this, arguments);
    };
  }();
  var toBuffer = function() {
    var _ref3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3() {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1)
          switch (_context3.prev = _context3.next) {
            case 0:
              callOnRender();
              _context3.next = 3;
              return render5();
            case 3:
              return _context3.abrupt("return", _context3.sent.fileStream);
            case 4:
            case "end":
              return _context3.stop();
          }
      }, _callee3);
    }));
    return function toBuffer2() {
      return _ref3.apply(this, arguments);
    };
  }();
  var toString7 = function() {
    var _ref4 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee4() {
      var result, _yield$render2, instance;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1)
          switch (_context4.prev = _context4.next) {
            case 0:
              if (true) {
                console.warn("`toString` is deprecated and will be removed in next major release");
              }
              result = "";
              _context4.next = 4;
              return render5(false);
            case 4:
              _yield$render2 = _context4.sent;
              instance = _yield$render2.fileStream;
              return _context4.abrupt("return", new Promise(function(resolve3, reject) {
                try {
                  instance.on("data", function(buffer3) {
                    result += buffer3;
                  });
                  instance.on("end", function() {
                    callOnRender();
                    resolve3(result);
                  });
                } catch (error) {
                  reject(error);
                }
              }));
            case 7:
            case "end":
              return _context4.stop();
          }
      }, _callee4);
    }));
    return function toString8() {
      return _ref4.apply(this, arguments);
    };
  }();
  var on3 = function on4(event, listener) {
    if (!events3[event])
      events3[event] = [];
    events3[event].push(listener);
  };
  var removeListener5 = function removeListener6(event, listener) {
    if (!events3[event])
      return;
    var idx = events3[event].indexOf(listener);
    if (idx > -1)
      events3[event].splice(idx, 1);
  };
  return {
    on: on3,
    container,
    toBlob,
    toBuffer,
    toString: toString7,
    removeListener: removeListener5,
    updateContainer
  };
};
var Font2 = fontStore;
var StyleSheet = {
  create: function create(s2) {
    return s2;
  }
};
var usePDF = function usePDF2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, document2 = _ref.document;
  var pdfInstance = (0, import_react.useRef)(null);
  var _useState = (0, import_react.useState)({
    url: null,
    blob: null,
    error: null,
    loading: !!document2
  }), state2 = _useState[0], setState = _useState[1];
  (0, import_react.useEffect)(function() {
    var renderQueue = (0, import_queue.default)({
      autostart: true,
      concurrency: 1
    });
    var queueDocumentRender = function queueDocumentRender2() {
      setState(function(prev) {
        return _extends({}, prev, {
          loading: true
        });
      });
      renderQueue.splice(0, renderQueue.length, function() {
        return state2.error ? Promise.resolve() : pdfInstance.current.toBlob();
      });
    };
    var onRenderFailed = function onRenderFailed2(error) {
      console.error(error);
      setState(function(prev) {
        return _extends({}, prev, {
          loading: false,
          error
        });
      });
    };
    var onRenderSuccessful = function onRenderSuccessful2(blob) {
      setState({
        blob,
        error: null,
        loading: false,
        url: URL.createObjectURL(blob)
      });
    };
    pdfInstance.current = pdf();
    pdfInstance.current.on("change", queueDocumentRender);
    if (document2) {
      pdfInstance.current.updateContainer(document2);
    }
    renderQueue.on("error", onRenderFailed);
    renderQueue.on("success", onRenderSuccessful);
    return function() {
      renderQueue.end();
      pdfInstance.current.removeListener("change", queueDocumentRender);
    };
  }, []);
  (0, import_react.useEffect)(function() {
    return function() {
      if (state2.url) {
        URL.revokeObjectURL(state2.url);
      }
    };
  }, [state2.url]);
  var update = (0, import_react.useCallback)(function(newDoc) {
    pdfInstance.current.updateContainer(newDoc);
  }, []);
  return [state2, update];
};
var _excluded4 = ["title", "style", "className", "children", "innerRef", "showToolbar"];
var PDFViewer = function PDFViewer2(_ref) {
  var title3 = _ref.title, style = _ref.style, className = _ref.className, children = _ref.children, innerRef = _ref.innerRef, _ref$showToolbar = _ref.showToolbar, showToolbar = _ref$showToolbar === void 0 ? true : _ref$showToolbar, props = _objectWithoutPropertiesLoose4(_ref, _excluded4);
  var _usePDF = usePDF(), instance = _usePDF[0], updateInstance = _usePDF[1];
  (0, import_react.useEffect)(function() {
    return updateInstance(children);
  }, [children]);
  var src3 = instance.url ? instance.url + "#toolbar=" + (showToolbar ? 1 : 0) : null;
  return (0, import_jsx_runtime.jsx)("iframe", _extends({
    src: src3,
    title: title3,
    ref: innerRef,
    style,
    className
  }, props));
};
var BlobProvider = function BlobProvider2(_ref) {
  var doc = _ref.document, children = _ref.children;
  var _usePDF = usePDF(), instance = _usePDF[0], updateInstance = _usePDF[1];
  (0, import_react.useEffect)(function() {
    return updateInstance(doc);
  }, [doc]);
  if (!doc) {
    console.warn("You should pass a valid document to BlobProvider");
    return null;
  }
  return children(instance);
};
var PDFDownloadLink = function PDFDownloadLink2(_ref) {
  var style = _ref.style, children = _ref.children, className = _ref.className, doc = _ref.document, _ref$fileName = _ref.fileName, fileName = _ref$fileName === void 0 ? "document.pdf" : _ref$fileName, onClick = _ref.onClick;
  var _usePDF = usePDF(), instance = _usePDF[0], updateInstance = _usePDF[1];
  (0, import_react.useEffect)(function() {
    return updateInstance(doc);
  }, [doc]);
  if (!doc) {
    console.warn("You should pass a valid document to PDFDownloadLink");
    return null;
  }
  var handleDownloadIE = function handleDownloadIE2() {
    if (window.navigator.msSaveBlob) {
      window.navigator.msSaveBlob(instance.blob, fileName);
    }
  };
  var handleClick = function handleClick2(event) {
    handleDownloadIE();
    if (typeof onClick === "function")
      onClick(event, instance);
  };
  return (0, import_jsx_runtime.jsx)("a", {
    style,
    href: instance.url,
    download: fileName,
    className,
    onClick: handleClick,
    children: typeof children === "function" ? children(instance) : children
  });
};
var throwEnvironmentError = function throwEnvironmentError2(name) {
  throw new Error(name + " is a Node specific API. You're either using this method in a browser, or your bundler is not loading react-pdf from the appropriate web build.");
};
var renderToStream = function renderToStream2() {
  throwEnvironmentError("renderToStream");
};
var renderToBuffer = function renderToBuffer2() {
  throwEnvironmentError("renderToBuffer");
};
var renderToString = function renderToString2() {
  throwEnvironmentError("renderToString");
};
var renderToFile = function renderToFile2() {
  throwEnvironmentError("renderToFile");
};
var render3 = function render4() {
  throwEnvironmentError("render");
};
var index2 = _extends({
  pdf,
  usePDF,
  Font: Font2,
  version: version3,
  StyleSheet,
  PDFViewer,
  BlobProvider,
  PDFDownloadLink,
  renderToStream,
  renderToString,
  renderToFile,
  render: render3
}, src_exports);
export {
  BlobProvider,
  Canvas,
  Circle,
  ClipPath,
  Defs,
  Document,
  Ellipse,
  Font2 as Font,
  G,
  Image,
  Line,
  LinearGradient,
  Link,
  Note,
  PDFDownloadLink,
  PDFViewer,
  Page,
  Path,
  Polygon,
  Polyline,
  RadialGradient,
  Rect,
  Stop,
  StyleSheet,
  Svg,
  Text,
  TextInstance,
  Tspan,
  View,
  createRenderer,
  index2 as default,
  pdf,
  render3 as render,
  renderToBuffer,
  renderToFile,
  renderToStream,
  renderToString,
  usePDF,
  version3 as version
};
/*! Bundled license information:

scheduler/cjs/scheduler.development.js:
  (** @license React v0.17.0
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@babel/runtime/helpers/esm/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

@babel/runtime/helpers/esm/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

@babel/runtime/helpers/esm/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

@react-pdf/png-js/lib/png-js.browser.es.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@react-pdf/pdfkit/lib/pdfkit.browser.es.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@react-pdf/textkit/lib/textkit.es.js:
  (**
   * @preserve Knuth and Plass line breaking algorithm in JavaScript
   *
   * Licensed under the new BSD License.
   * Copyright 2009-2010, Bram Stein
   * All rights reserved.
   *)

@babel/runtime/helpers/esm/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

@babel/runtime/helpers/esm/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

@react-pdf/image/lib/index.browser.es.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

@react-pdf/renderer/lib/react-pdf.browser.es.js:
  (** @license React v0.23.0
   * react-reconciler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@react-pdf_renderer.js.map
