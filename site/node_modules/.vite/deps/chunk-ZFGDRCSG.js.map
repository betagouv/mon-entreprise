{
  "version": 3,
  "sources": ["../../../../node_modules/effect/src/Array.ts", "../../../../node_modules/effect/src/Iterable.ts", "../../../../node_modules/effect/src/Tuple.ts"],
  "sourcesContent": ["/**\n * This module provides utility functions for working with arrays in TypeScript.\n *\n * @since 2.0.0\n */\n\nimport type { Either } from \"./Either.js\"\nimport * as E from \"./Either.js\"\nimport * as Equal from \"./Equal.js\"\nimport * as Equivalence from \"./Equivalence.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport { dual, identity } from \"./Function.js\"\nimport type { TypeLambda } from \"./HKT.js\"\nimport * as readonlyArray from \"./internal/array.js\"\nimport * as EffectIterable from \"./Iterable.js\"\nimport type { Option } from \"./Option.js\"\nimport * as O from \"./Option.js\"\nimport * as Order from \"./Order.js\"\nimport type { Predicate, Refinement } from \"./Predicate.js\"\nimport { isBoolean } from \"./Predicate.js\"\nimport * as Record from \"./Record.js\"\nimport * as Tuple from \"./Tuple.js\"\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface ReadonlyArrayTypeLambda extends TypeLambda {\n  readonly type: ReadonlyArray<this[\"Target\"]>\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport type NonEmptyReadonlyArray<A> = readonly [A, ...Array<A>]\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport type NonEmptyArray<A> = [A, ...Array<A>]\n\n/**\n * Builds a `NonEmptyArray` from an non-empty collection of elements.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const make = <Elements extends NonEmptyArray<any>>(\n  ...elements: Elements\n): NonEmptyArray<Elements[number]> => elements\n\n/**\n * Creates a new `Array` of the specified length.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const allocate = <A = never>(n: number): Array<A | undefined> => new Array(n)\n\n/**\n * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * @example\n * import { makeBy } from 'effect/Array'\n *\n * assert.deepStrictEqual(makeBy(5, n => n * 2), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const makeBy = <A>(n: number, f: (i: number) => A): NonEmptyArray<A> => {\n  const max = Math.max(1, Math.floor(n))\n  const out = new Array(max)\n  for (let i = 0; i < max; i++) {\n    out[i] = f(i)\n  }\n  return out as NonEmptyArray<A>\n}\n\n/**\n * Return a `NonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @example\n * import { range } from 'effect/Array'\n *\n * assert.deepStrictEqual(range(1, 3), [1, 2, 3])\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const range = (start: number, end: number): NonEmptyArray<number> =>\n  start <= end ? makeBy(end - start + 1, (i) => start + i) : [start]\n\n/**\n * Return a `NonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * @example\n * import { replicate } from 'effect/Array'\n *\n * assert.deepStrictEqual(replicate(\"a\", 3), [\"a\", \"a\", \"a\"])\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const replicate: {\n  (n: number): <A>(a: A) => NonEmptyArray<A>\n  <A>(a: A, n: number): NonEmptyArray<A>\n} = dual(2, <A>(a: A, n: number): NonEmptyArray<A> => makeBy(n, () => a))\n\n/**\n * Creates a new `Array` from an iterable collection of values.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const fromIterable = <A>(collection: Iterable<A>): Array<A> =>\n  Array.isArray(collection) ? collection : Array.from(collection)\n\n/**\n * Takes a record and returns an array of tuples containing its keys and values.\n *\n * @param self - The record to transform.\n *\n * @example\n * import { fromRecord } from \"effect/Array\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * assert.deepStrictEqual(fromRecord(x), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const fromRecord: <K extends string, A>(self: Readonly<Record<K, A>>) => Array<[K, A]> = Record.toEntries\n\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport const fromOption: <A>(self: Option<A>) => Array<A> = O.toArray\n\n/**\n * @category pattern matching\n * @since 2.0.0\n */\nexport const match: {\n  <B, A, C = B>(\n    options: {\n      readonly onEmpty: LazyArg<B>\n      readonly onNonEmpty: (self: NonEmptyReadonlyArray<A>) => C\n    }\n  ): (self: ReadonlyArray<A>) => B | C\n  <A, B, C = B>(\n    self: ReadonlyArray<A>,\n    options: {\n      readonly onEmpty: LazyArg<B>\n      readonly onNonEmpty: (self: NonEmptyReadonlyArray<A>) => C\n    }\n  ): B | C\n} = dual(2, <A, B, C = B>(\n  self: ReadonlyArray<A>,\n  { onEmpty, onNonEmpty }: {\n    readonly onEmpty: LazyArg<B>\n    readonly onNonEmpty: (self: NonEmptyReadonlyArray<A>) => C\n  }\n): B | C => isNonEmptyReadonlyArray(self) ? onNonEmpty(self) : onEmpty())\n\n/**\n * @category pattern matching\n * @since 2.0.0\n */\nexport const matchLeft: {\n  <B, A, C = B>(\n    options: {\n      readonly onEmpty: LazyArg<B>\n      readonly onNonEmpty: (head: A, tail: Array<A>) => C\n    }\n  ): (self: ReadonlyArray<A>) => B | C\n  <A, B, C = B>(\n    self: ReadonlyArray<A>,\n    options: {\n      readonly onEmpty: LazyArg<B>\n      readonly onNonEmpty: (head: A, tail: Array<A>) => C\n    }\n  ): B | C\n} = dual(2, <A, B, C = B>(\n  self: ReadonlyArray<A>,\n  { onEmpty, onNonEmpty }: {\n    readonly onEmpty: LazyArg<B>\n    readonly onNonEmpty: (head: A, tail: Array<A>) => C\n  }\n): B | C => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty(self), tailNonEmpty(self)) : onEmpty())\n\n/**\n * @category pattern matching\n * @since 2.0.0\n */\nexport const matchRight: {\n  <B, A, C = B>(\n    options: {\n      readonly onEmpty: LazyArg<B>\n      readonly onNonEmpty: (init: Array<A>, last: A) => C\n    }\n  ): (self: ReadonlyArray<A>) => B | C\n  <A, B, C = B>(\n    self: ReadonlyArray<A>,\n    options: {\n      readonly onEmpty: LazyArg<B>\n      readonly onNonEmpty: (init: Array<A>, last: A) => C\n    }\n  ): B | C\n} = dual(2, <A, B, C = B>(\n  self: ReadonlyArray<A>,\n  { onEmpty, onNonEmpty }: {\n    readonly onEmpty: LazyArg<B>\n    readonly onNonEmpty: (init: Array<A>, last: A) => C\n  }\n): B | C =>\n  isNonEmptyReadonlyArray(self) ?\n    onNonEmpty(initNonEmpty(self), lastNonEmpty(self)) :\n    onEmpty())\n\n/**\n * Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prepend: {\n  <B>(head: B): <A>(self: Iterable<A>) => NonEmptyArray<A | B>\n  <A, B>(self: Iterable<A>, head: B): NonEmptyArray<A | B>\n} = dual(2, <A, B>(self: Iterable<A>, head: B): NonEmptyArray<A | B> => [head, ...self])\n\n/**\n * Prepends the specified prefix array (or iterable) to the beginning of the specified array (or iterable).\n * If either array is non-empty, the result is also a non-empty array.\n *\n * @example\n * import * as Array from \"effect/Array\"\n *\n * assert.deepStrictEqual(\n *   Array.prependAll([1, 2], [\"a\", \"b\"]),\n *   [\"a\", \"b\", 1, 2]\n * )\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prependAll: {\n  <S extends ReadonlyArray<any> | Iterable<any>, T extends ReadonlyArray<any> | Iterable<any>>(\n    that: T\n  ): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>\n  <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>\n  <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>): NonEmptyArray<A | B>\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>\n} = dual(\n  2,\n  <A>(self: Iterable<A>, that: Iterable<A>): Array<A> => fromIterable(that).concat(fromIterable(self))\n)\n\n/**\n * Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const append: {\n  <B>(last: B): <A>(self: Iterable<A>) => NonEmptyArray<A | B>\n  <A, B>(self: Iterable<A>, last: B): NonEmptyArray<A | B>\n} = dual(2, <A, B>(self: Iterable<A>, last: B): Array<A | B> => [...self, last])\n\n/**\n * Concatenates two arrays (or iterables), combining their elements.\n * If either array is non-empty, the result is also a non-empty array.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const appendAll: {\n  <S extends ReadonlyArray<any> | Iterable<any>, T extends ReadonlyArray<any> | Iterable<any>>(\n    that: T\n  ): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>\n  <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>\n  <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>): NonEmptyArray<A | B>\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>\n} = dual(\n  2,\n  <A>(self: Iterable<A>, that: Iterable<A>): Array<A> => fromIterable(self).concat(fromIterable(that))\n)\n\n/**\n * Reduce an `Iterable` from the left, keeping all intermediate results instead of only the final result.\n *\n * @category folding\n * @since 2.0.0\n */\nexport const scan: {\n  <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => NonEmptyArray<B>\n  <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B>\n} = dual(3, <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B> => {\n  const out: NonEmptyArray<B> = [b]\n  let i = 0\n  for (const a of self) {\n    out[i + 1] = f(out[i], a)\n    i++\n  }\n  return out\n})\n\n/**\n * Reduce an `Iterable` from the right, keeping all intermediate results instead of only the final result.\n *\n * @category folding\n * @since 2.0.0\n */\nexport const scanRight: {\n  <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => NonEmptyArray<B>\n  <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B>\n} = dual(3, <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B> => {\n  const input = fromIterable(self)\n  const out: NonEmptyArray<B> = new Array(input.length + 1) as any\n  out[input.length] = b\n  for (let i = input.length - 1; i >= 0; i--) {\n    out[i] = f(out[i + 1], input[i])\n  }\n  return out\n})\n\n/**\n * Determine if `unknown` is an Array.\n *\n * @param self - The value to check.\n *\n * @example\n * import { isArray } from \"effect/Array\"\n *\n * assert.deepStrictEqual(isArray(null), false);\n * assert.deepStrictEqual(isArray([1, 2, 3]), true);\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isArray: {\n  (self: unknown): self is Array<unknown>\n  <T>(self: T): self is Extract<T, ReadonlyArray<any>>\n} = Array.isArray\n\n/**\n * Determine if an `Array` is empty narrowing down the type to `[]`.\n *\n * @param self - The `Array` to check.\n *\n * @example\n * import { isEmptyArray } from \"effect/Array\"\n *\n * assert.deepStrictEqual(isEmptyArray([]), true);\n * assert.deepStrictEqual(isEmptyArray([1, 2, 3]), false);\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isEmptyArray = <A>(self: Array<A>): self is [] => self.length === 0\n\n/**\n * Determine if a `ReadonlyArray` is empty narrowing down the type to `readonly []`.\n *\n * @param self - The `ReadonlyArray` to check.\n *\n * @example\n * import { isEmptyReadonlyArray } from \"effect/Array\"\n *\n * assert.deepStrictEqual(isEmptyReadonlyArray([]), true);\n * assert.deepStrictEqual(isEmptyReadonlyArray([1, 2, 3]), false);\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isEmptyReadonlyArray: <A>(self: ReadonlyArray<A>) => self is readonly [] = isEmptyArray as any\n\n/**\n * Determine if an `Array` is non empty narrowing down the type to `NonEmptyArray`.\n *\n * An `Array` is considered to be a `NonEmptyArray` if it contains at least one element.\n *\n * @param self - The `Array` to check.\n *\n * @example\n * import { isNonEmptyArray } from \"effect/Array\"\n *\n * assert.deepStrictEqual(isNonEmptyArray([]), false);\n * assert.deepStrictEqual(isNonEmptyArray([1, 2, 3]), true);\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNonEmptyArray: <A>(self: Array<A>) => self is NonEmptyArray<A> = readonlyArray.isNonEmptyArray\n\n/**\n * Determine if a `ReadonlyArray` is non empty narrowing down the type to `NonEmptyReadonlyArray`.\n *\n * A `ReadonlyArray` is considered to be a `NonEmptyReadonlyArray` if it contains at least one element.\n *\n * @param self - The `ReadonlyArray` to check.\n *\n * @example\n * import { isNonEmptyReadonlyArray } from \"effect/Array\"\n *\n * assert.deepStrictEqual(isNonEmptyReadonlyArray([]), false);\n * assert.deepStrictEqual(isNonEmptyReadonlyArray([1, 2, 3]), true);\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isNonEmptyReadonlyArray: <A>(self: ReadonlyArray<A>) => self is NonEmptyReadonlyArray<A> =\n  readonlyArray.isNonEmptyArray\n\n/**\n * Return the number of elements in a `ReadonlyArray`.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const length = <A>(self: ReadonlyArray<A>): number => self.length\n\nconst isOutOfBound = <A>(i: number, as: ReadonlyArray<A>): boolean => i < 0 || i >= as.length\n\nconst clamp = <A>(i: number, as: ReadonlyArray<A>): number => Math.floor(Math.min(Math.max(0, i), as.length))\n\n/**\n * This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const get: {\n  (index: number): <A>(self: ReadonlyArray<A>) => Option<A>\n  <A>(self: ReadonlyArray<A>, index: number): Option<A>\n} = dual(2, <A>(self: ReadonlyArray<A>, index: number): Option<A> => {\n  const i = Math.floor(index)\n  return isOutOfBound(i, self) ? O.none() : O.some(self[i])\n})\n\n/**\n * Gets an element unsafely, will throw on out of bounds.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeGet: {\n  (index: number): <A>(self: ReadonlyArray<A>) => A\n  <A>(self: ReadonlyArray<A>, index: number): A\n} = dual(2, <A>(self: ReadonlyArray<A>, index: number): A => {\n  const i = Math.floor(index)\n  if (isOutOfBound(i, self)) {\n    throw new Error(`Index ${i} out of bounds`)\n  }\n  return self[i]\n})\n\n/**\n * Return a tuple containing the first element, and a new `Array` of the remaining elements, if any.\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const unprepend = <A>(\n  self: NonEmptyReadonlyArray<A>\n): [firstElement: A, remainingElements: Array<A>] => [headNonEmpty(self), tailNonEmpty(self)]\n\n/**\n * Return a tuple containing a copy of the `NonEmptyReadonlyArray` without its last element, and that last element.\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const unappend = <A>(\n  self: NonEmptyReadonlyArray<A>\n): [arrayWithoutLastElement: Array<A>, lastElement: A] => [initNonEmpty(self), lastNonEmpty(self)]\n\n/**\n * Get the first element of a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const head: <A>(self: ReadonlyArray<A>) => Option<A> = get(0)\n\n/**\n * @category getters\n * @since 2.0.0\n */\nexport const headNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => A = unsafeGet(0)\n\n/**\n * Get the last element in a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const last = <A>(self: ReadonlyArray<A>): Option<A> =>\n  isNonEmptyReadonlyArray(self) ? O.some(lastNonEmpty(self)) : O.none()\n\n/**\n * @category getters\n * @since 2.0.0\n */\nexport const lastNonEmpty = <A>(self: NonEmptyReadonlyArray<A>): A => self[self.length - 1]\n\n/**\n * Get all but the first element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const tail = <A>(self: Iterable<A>): Option<Array<A>> => {\n  const input = fromIterable(self)\n  return isNonEmptyReadonlyArray(input) ? O.some(tailNonEmpty(input)) : O.none()\n}\n\n/**\n * @category getters\n * @since 2.0.0\n */\nexport const tailNonEmpty = <A>(self: NonEmptyReadonlyArray<A>): Array<A> => self.slice(1)\n\n/**\n * Get all but the last element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const init = <A>(self: Iterable<A>): Option<Array<A>> => {\n  const input = fromIterable(self)\n  return isNonEmptyReadonlyArray(input) ? O.some(initNonEmpty(input)) : O.none()\n}\n\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const initNonEmpty = <A>(self: NonEmptyReadonlyArray<A>): Array<A> => self.slice(0, -1)\n\n/**\n * Keep only a max number of elements from the start of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const take: {\n  (n: number): <A>(self: Iterable<A>) => Array<A>\n  <A>(self: Iterable<A>, n: number): Array<A>\n} = dual(2, <A>(self: Iterable<A>, n: number): Array<A> => {\n  const input = fromIterable(self)\n  return input.slice(0, clamp(n, input))\n})\n\n/**\n * Keep only a max number of elements from the end of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const takeRight: {\n  (n: number): <A>(self: Iterable<A>) => Array<A>\n  <A>(self: Iterable<A>, n: number): Array<A>\n} = dual(2, <A>(self: Iterable<A>, n: number): Array<A> => {\n  const input = fromIterable(self)\n  const i = clamp(n, input)\n  return i === 0 ? [] : input.slice(-i)\n})\n\n/**\n * Calculate the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const takeWhile: {\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Array<B>\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Array<B>\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>\n} = dual(2, <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A> => {\n  let i = 0\n  const out: Array<A> = []\n  for (const a of self) {\n    if (!predicate(a, i)) {\n      break\n    }\n    out.push(a)\n    i++\n  }\n  return out\n})\n\nconst spanIndex = <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): number => {\n  let i = 0\n  for (const a of self) {\n    if (!predicate(a, i)) {\n      break\n    }\n    i++\n  }\n  return i\n}\n\n/**\n * Split an `Iterable` into two parts:\n *\n * 1. the longest initial subarray for which all elements satisfy the specified predicate\n * 2. the remaining elements\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const span: {\n  <A, B extends A>(\n    refinement: (a: NoInfer<A>, i: number) => a is B\n  ): (self: Iterable<A>) => [init: Array<B>, rest: Array<Exclude<A, B>>]\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [init: Array<A>, rest: Array<A>]\n  <A, B extends A>(\n    self: Iterable<A>,\n    refinement: (a: A, i: number) => a is B\n  ): [init: Array<B>, rest: Array<Exclude<A, B>>]\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [init: Array<A>, rest: Array<A>]\n} = dual(\n  2,\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [init: Array<A>, rest: Array<A>] =>\n    splitAt(self, spanIndex(self, predicate))\n)\n\n/**\n * Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const drop: {\n  (n: number): <A>(self: Iterable<A>) => Array<A>\n  <A>(self: Iterable<A>, n: number): Array<A>\n} = dual(2, <A>(self: Iterable<A>, n: number): Array<A> => {\n  const input = fromIterable(self)\n  return input.slice(clamp(n, input), input.length)\n})\n\n/**\n * Drop a max number of elements from the end of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const dropRight: {\n  (n: number): <A>(self: Iterable<A>) => Array<A>\n  <A>(self: Iterable<A>, n: number): Array<A>\n} = dual(2, <A>(self: Iterable<A>, n: number): Array<A> => {\n  const input = fromIterable(self)\n  return input.slice(0, input.length - clamp(n, input))\n})\n\n/**\n * Remove the longest initial subarray for which all element satisfy the specified predicate, creating a new `Array`.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const dropWhile: {\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>\n} = dual(\n  2,\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A> =>\n    fromIterable(self).slice(spanIndex(self, predicate))\n)\n\n/**\n * Return the first index for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirstIndex: {\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<number>\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<number>\n} = dual(2, <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<number> => {\n  let i = 0\n  for (const a of self) {\n    if (predicate(a, i)) {\n      return O.some(i)\n    }\n    i++\n  }\n  return O.none()\n})\n\n/**\n * Return the last index for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findLastIndex: {\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<number>\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<number>\n} = dual(2, <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<number> => {\n  const input = fromIterable(self)\n  for (let i = input.length - 1; i >= 0; i--) {\n    if (predicate(input[i], i)) {\n      return O.some(i)\n    }\n  }\n  return O.none()\n})\n\n/**\n * Returns the first element that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirst: {\n  <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>\n} = EffectIterable.findFirst\n\n/**\n * Find the last element for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findLast: {\n  <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>\n} = dual(\n  2,\n  <A>(self: Iterable<A>, f: ((a: A, i: number) => boolean) | ((a: A, i: number) => Option<A>)): Option<A> => {\n    const input = fromIterable(self)\n    for (let i = input.length - 1; i >= 0; i--) {\n      const a = input[i]\n      const o = f(a, i)\n      if (isBoolean(o)) {\n        if (o) {\n          return O.some(a)\n        }\n      } else {\n        if (O.isSome(o)) {\n          return o\n        }\n      }\n    }\n    return O.none()\n  }\n)\n\n/**\n * Insert an element at the specified index, creating a new `NonEmptyArray`,\n * or return `None` if the index is out of bounds.\n *\n * @since 2.0.0\n */\nexport const insertAt: {\n  <B>(i: number, b: B): <A>(self: Iterable<A>) => Option<NonEmptyArray<A | B>>\n  <A, B>(self: Iterable<A>, i: number, b: B): Option<NonEmptyArray<A | B>>\n} = dual(3, <A, B>(self: Iterable<A>, i: number, b: B): Option<NonEmptyArray<A | B>> => {\n  const out: Array<A | B> = Array.from(self)\n  //             v--- `= self.length` is ok, it means inserting in last position\n  if (i < 0 || i > out.length) {\n    return O.none()\n  }\n  out.splice(i, 0, b)\n  return O.some(out) as any\n})\n\n/**\n * Change the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * @since 2.0.0\n */\nexport const replace: {\n  <B>(i: number, b: B): <A>(self: Iterable<A>) => Array<A | B>\n  <A, B>(self: Iterable<A>, i: number, b: B): Array<A | B>\n} = dual(3, <A, B>(self: Iterable<A>, i: number, b: B): Array<A | B> => modify(self, i, () => b))\n\n/**\n * @since 2.0.0\n */\nexport const replaceOption: {\n  <B>(i: number, b: B): <A>(self: Iterable<A>) => Option<Array<A | B>>\n  <A, B>(self: Iterable<A>, i: number, b: B): Option<Array<A | B>>\n} = dual(\n  3,\n  <A, B>(self: Iterable<A>, i: number, b: B): Option<Array<A | B>> => modifyOption(self, i, () => b)\n)\n\n/**\n * Apply a function to the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * @since 2.0.0\n */\nexport const modify: {\n  <A, B>(i: number, f: (a: A) => B): (self: Iterable<A>) => Array<A | B>\n  <A, B>(self: Iterable<A>, i: number, f: (a: A) => B): Array<A | B>\n} = dual(\n  3,\n  <A, B>(self: Iterable<A>, i: number, f: (a: A) => B): Array<A | B> =>\n    O.getOrElse(modifyOption(self, i, f), () => Array.from(self))\n)\n\n/**\n * Apply a function to the element at the specified index, creating a new `Array`,\n * or return `None` if the index is out of bounds.\n *\n * @since 2.0.0\n */\nexport const modifyOption: {\n  <A, B>(i: number, f: (a: A) => B): (self: Iterable<A>) => Option<Array<A | B>>\n  <A, B>(self: Iterable<A>, i: number, f: (a: A) => B): Option<Array<A | B>>\n} = dual(3, <A, B>(self: Iterable<A>, i: number, f: (a: A) => B): Option<Array<A | B>> => {\n  const out = Array.from(self)\n  if (isOutOfBound(i, out)) {\n    return O.none()\n  }\n  const next = f(out[i])\n  // @ts-expect-error\n  out[i] = next\n  return O.some(out)\n})\n\n/**\n * Delete the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * @since 2.0.0\n */\nexport const remove: {\n  (i: number): <A>(self: Iterable<A>) => Array<A>\n  <A>(self: Iterable<A>, i: number): Array<A>\n} = dual(2, <A>(self: Iterable<A>, i: number): Array<A> => {\n  const out = Array.from(self)\n  if (isOutOfBound(i, out)) {\n    return out\n  }\n  out.splice(i, 1)\n  return out\n})\n\n/**\n * Reverse an `Iterable`, creating a new `Array`.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const reverse = <S extends Iterable<any> | NonEmptyReadonlyArray<any>>(\n  self: S\n): S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never =>\n  Array.from(self).reverse() as any\n\n/**\n * Create a new array with elements sorted in increasing order based on the specified comparator.\n * If the input is a `NonEmptyReadonlyArray`, the output will also be a `NonEmptyReadonlyArray`.\n *\n * @category sorting\n * @since 2.0.0\n */\nexport const sort: {\n  <B>(\n    O: Order.Order<B>\n  ): <A extends B, S extends ReadonlyArray<A> | Iterable<A>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>\n  <A extends B, B>(self: NonEmptyReadonlyArray<A>, O: Order.Order<B>): NonEmptyArray<A>\n  <A extends B, B>(self: Iterable<A>, O: Order.Order<B>): Array<A>\n} = dual(2, <A extends B, B>(self: Iterable<A>, O: Order.Order<B>): Array<A> => {\n  const out = Array.from(self)\n  out.sort(O)\n  return out\n})\n\n/**\n * @since 2.0.0\n * @category elements\n */\nexport const sortWith: {\n  <S extends Iterable<any> | NonEmptyReadonlyArray<any>, B>(\n    f: (a: ReadonlyArray.Infer<S>) => B,\n    order: Order.Order<B>\n  ): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>\n  <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B, O: Order.Order<B>): NonEmptyArray<A>\n  <A, B>(self: Iterable<A>, f: (a: A) => B, order: Order.Order<B>): Array<A>\n} = dual(\n  3,\n  <A, B>(self: Iterable<A>, f: (a: A) => B, order: Order.Order<B>): Array<A> => sort(self, Order.mapInput(order, f))\n)\n\n/**\n * Sort the elements of an `Iterable` in increasing order, where elements are compared\n * using first `orders[0]`, then `orders[1]`, etc...\n *\n * @category sorting\n * @since 2.0.0\n */\nexport const sortBy = <S extends Iterable<any> | NonEmptyReadonlyArray<any>>(\n  ...orders: ReadonlyArray<Order.Order<ReadonlyArray.Infer<S>>>\n) => {\n  const sortByAll = sort(Order.combineAll(orders))\n  return (\n    self: S\n  ): S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never => {\n    const input = fromIterable(self)\n    if (isNonEmptyReadonlyArray(input)) {\n      return sortByAll(input) as any\n    }\n    return [] as any\n  }\n}\n\n/**\n * Takes two `Iterable`s and returns an `Array` of corresponding pairs.\n * If one input `Iterable` is short, excess elements of the\n * longer `Iterable` are discarded.\n *\n * @category zipping\n * @since 2.0.0\n */\nexport const zip: {\n  <B>(that: NonEmptyReadonlyArray<B>): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<[A, B]>\n  <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Array<[A, B]>\n  <A, B>(self: NonEmptyReadonlyArray<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<[A, B]>\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<[A, B]>\n} = dual(\n  2,\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<[A, B]> => zipWith(self, that, Tuple.make)\n)\n\n/**\n * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one\n * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.\n *\n * @category zipping\n * @since 2.0.0\n */\nexport const zipWith: {\n  <B, A, C>(that: NonEmptyReadonlyArray<B>, f: (a: A, b: B) => C): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<C>\n  <B, A, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Array<C>\n  <A, B, C>(self: NonEmptyReadonlyArray<A>, that: NonEmptyReadonlyArray<B>, f: (a: A, b: B) => C): NonEmptyArray<C>\n  <B, A, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Array<C>\n} = dual(3, <B, A, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Array<C> => {\n  const as = fromIterable(self)\n  const bs = fromIterable(that)\n  if (isNonEmptyReadonlyArray(as) && isNonEmptyReadonlyArray(bs)) {\n    const out: NonEmptyArray<C> = [f(headNonEmpty(as), headNonEmpty(bs))]\n    const len = Math.min(as.length, bs.length)\n    for (let i = 1; i < len; i++) {\n      out[i] = f(as[i], bs[i])\n    }\n    return out\n  }\n  return []\n})\n\n/**\n * This function is the inverse of `zip`. Takes an `Iterable` of pairs and return two corresponding `Array`s.\n *\n * @since 2.0.0\n */\nexport const unzip: <S extends Iterable<readonly [any, any]> | NonEmptyReadonlyArray<readonly [any, any]>>(\n  self: S\n) => S extends NonEmptyReadonlyArray<readonly [infer A, infer B]> ? [NonEmptyArray<A>, NonEmptyArray<B>]\n  : S extends Iterable<readonly [infer A, infer B]> ? [Array<A>, Array<B>]\n  : never = (<A, B>(self: Iterable<readonly [A, B]>): [Array<A>, Array<B>] => {\n    const input = fromIterable(self)\n    if (isNonEmptyReadonlyArray(input)) {\n      const fa: NonEmptyArray<A> = [input[0][0]]\n      const fb: NonEmptyArray<B> = [input[0][1]]\n      for (let i = 1; i < input.length; i++) {\n        fa[i] = input[i][0]\n        fb[i] = input[i][1]\n      }\n      return [fa, fb]\n    }\n    return [[], []]\n  }) as any\n\n/**\n * Places an element in between members of an `Iterable`.\n * If the input is a non-empty array, the result is also a non-empty array.\n *\n * @since 2.0.0\n */\nexport const intersperse: {\n  <B>(\n    middle: B\n  ): <S extends ReadonlyArray<any> | Iterable<any>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>\n  <A, B>(self: NonEmptyReadonlyArray<A>, middle: B): NonEmptyArray<A | B>\n  <A, B>(self: Iterable<A>, middle: B): Array<A | B>\n} = dual(2, <A, B>(self: Iterable<A>, middle: B): Array<A | B> => {\n  const input = fromIterable(self)\n  if (isNonEmptyReadonlyArray(input)) {\n    const out: NonEmptyArray<A | B> = [headNonEmpty(input)]\n    const tail = tailNonEmpty(input)\n    for (let i = 0; i < tail.length; i++) {\n      if (i < tail.length) {\n        out.push(middle)\n      }\n      out.push(tail[i])\n    }\n    return out\n  }\n  return []\n})\n\n/**\n * Apply a function to the head, creating a new `NonEmptyReadonlyArray`.\n *\n * @since 2.0.0\n */\nexport const modifyNonEmptyHead: {\n  <A, B>(f: (a: A) => B): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>\n  <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B): NonEmptyArray<A | B>\n} = dual(\n  2,\n  <A, B>(\n    self: NonEmptyReadonlyArray<A>,\n    f: (a: A) => B\n  ): NonEmptyArray<A | B> => [f(headNonEmpty(self)), ...tailNonEmpty(self)]\n)\n\n/**\n * Change the head, creating a new `NonEmptyReadonlyArray`.\n *\n * @since 2.0.0\n */\nexport const setNonEmptyHead: {\n  <B>(b: B): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>\n  <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B>\n} = dual(\n  2,\n  <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B> => modifyNonEmptyHead(self, () => b)\n)\n\n/**\n * Apply a function to the last element, creating a new `NonEmptyReadonlyArray`.\n *\n * @since 2.0.0\n */\nexport const modifyNonEmptyLast: {\n  <A, B>(f: (a: A) => B): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>\n  <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B): NonEmptyArray<A | B>\n} = dual(\n  2,\n  <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B): NonEmptyArray<A | B> =>\n    append(initNonEmpty(self), f(lastNonEmpty(self)))\n)\n\n/**\n * Change the last element, creating a new `NonEmptyReadonlyArray`.\n *\n * @since 2.0.0\n */\nexport const setNonEmptyLast: {\n  <B>(b: B): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>\n  <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B>\n} = dual(\n  2,\n  <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B> => modifyNonEmptyLast(self, () => b)\n)\n\n/**\n * Rotate an `Iterable` by `n` steps.\n * If the input is a non-empty array, the result is also a non-empty array.\n *\n * @since 2.0.0\n */\nexport const rotate: {\n  (n: number): <S extends ReadonlyArray<any> | Iterable<any>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>\n  <A>(self: NonEmptyReadonlyArray<A>, n: number): NonEmptyArray<A>\n  <A>(self: Iterable<A>, n: number): Array<A>\n} = dual(2, <A>(self: Iterable<A>, n: number): Array<A> => {\n  const input = fromIterable(self)\n  if (isNonEmptyReadonlyArray(input)) {\n    const len = input.length\n    const m = Math.round(n) % len\n    if (isOutOfBound(Math.abs(m), input) || m === 0) {\n      return copy(input)\n    }\n    if (m < 0) {\n      const [f, s] = splitNonEmptyAt(input, -m)\n      return appendAll(s, f)\n    } else {\n      return rotate(self, m - len)\n    }\n  }\n  return []\n})\n\n/**\n * Returns a function that checks if a `ReadonlyArray` contains a given value using a provided `isEquivalent` function.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const containsWith = <A>(isEquivalent: (self: A, that: A) => boolean): {\n  (a: A): (self: Iterable<A>) => boolean\n  (self: Iterable<A>, a: A): boolean\n} =>\n  dual(2, (self: Iterable<A>, a: A): boolean => {\n    for (const i of self) {\n      if (isEquivalent(a, i)) {\n        return true\n      }\n    }\n    return false\n  })\n\nconst _equivalence = Equal.equivalence()\n\n/**\n * Returns a function that checks if a `ReadonlyArray` contains a given value using the default `Equivalence`.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const contains: {\n  <A>(a: A): (self: Iterable<A>) => boolean\n  <A>(self: Iterable<A>, a: A): boolean\n} = containsWith(_equivalence)\n\n/**\n * A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for \"chopping\" up the input\n * `Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a\n * value and the rest of the `Array`.\n *\n * @since 2.0.0\n */\nexport const chop: {\n  <S extends ReadonlyArray<any> | Iterable<any>, B>(\n    f: (as: NonEmptyReadonlyArray<ReadonlyArray.Infer<S>>) => readonly [B, ReadonlyArray<ReadonlyArray.Infer<S>>]\n  ): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>\n  <A, B>(\n    self: NonEmptyReadonlyArray<A>,\n    f: (as: NonEmptyReadonlyArray<A>) => readonly [B, ReadonlyArray<A>]\n  ): NonEmptyArray<B>\n  <A, B>(\n    self: Iterable<A>,\n    f: (as: NonEmptyReadonlyArray<A>) => readonly [B, ReadonlyArray<A>]\n  ): Array<B>\n} = dual(2, <A, B>(\n  self: Iterable<A>,\n  f: (as: NonEmptyReadonlyArray<A>) => readonly [B, ReadonlyArray<A>]\n): Array<B> => {\n  const input = fromIterable(self)\n  if (isNonEmptyReadonlyArray(input)) {\n    const [b, rest] = f(input)\n    const out: NonEmptyArray<B> = [b]\n    let next: ReadonlyArray<A> = rest\n    while (readonlyArray.isNonEmptyArray(next)) {\n      const [b, rest] = f(next)\n      out.push(b)\n      next = rest\n    }\n    return out\n  }\n  return []\n})\n\n/**\n * Splits an `Iterable` into two segments, with the first segment containing a maximum of `n` elements.\n * The value of `n` can be `0`.\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const splitAt: {\n  (n: number): <A>(self: Iterable<A>) => [beforeIndex: Array<A>, fromIndex: Array<A>]\n  <A>(self: Iterable<A>, n: number): [beforeIndex: Array<A>, fromIndex: Array<A>]\n} = dual(2, <A>(self: Iterable<A>, n: number): [Array<A>, Array<A>] => {\n  const input = Array.from(self)\n  const _n = Math.floor(n)\n  if (isNonEmptyReadonlyArray(input)) {\n    if (_n >= 1) {\n      return splitNonEmptyAt(input, _n)\n    }\n    return [[], input]\n  }\n  return [input, []]\n})\n\n/**\n * Splits a `NonEmptyReadonlyArray` into two segments, with the first segment containing a maximum of `n` elements.\n * The value of `n` must be `>= 1`.\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const splitNonEmptyAt: {\n  (n: number): <A>(self: NonEmptyReadonlyArray<A>) => [beforeIndex: NonEmptyArray<A>, fromIndex: Array<A>]\n  <A>(self: NonEmptyReadonlyArray<A>, n: number): [beforeIndex: NonEmptyArray<A>, fromIndex: Array<A>]\n} = dual(2, <A>(self: NonEmptyReadonlyArray<A>, n: number): [NonEmptyArray<A>, Array<A>] => {\n  const _n = Math.max(1, Math.floor(n))\n  return _n >= self.length ?\n    [copy(self), []] :\n    [prepend(self.slice(1, _n), headNonEmpty(self)), self.slice(_n)]\n})\n\n/**\n * Splits this iterable into `n` equally sized arrays.\n *\n * @since 2.0.0\n * @category splitting\n */\nexport const split: {\n  (n: number): <A>(self: Iterable<A>) => Array<Array<A>>\n  <A>(self: Iterable<A>, n: number): Array<Array<A>>\n} = dual(2, <A>(self: Iterable<A>, n: number) => {\n  const input = fromIterable(self)\n  return chunksOf(input, Math.ceil(input.length / Math.floor(n)))\n})\n\n/**\n * Splits this iterable on the first element that matches this predicate.\n * Returns a tuple containing two arrays: the first one is before the match, and the second one is from the match onward.\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const splitWhere: {\n  <A>(\n    predicate: (a: NoInfer<A>, i: number) => boolean\n  ): (self: Iterable<A>) => [beforeMatch: Array<A>, fromMatch: Array<A>]\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [beforeMatch: Array<A>, fromMatch: Array<A>]\n} = dual(\n  2,\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [beforeMatch: Array<A>, fromMatch: Array<A>] =>\n    span(self, (a: A, i: number) => !predicate(a, i))\n)\n\n/**\n * @since 2.0.0\n */\nexport const copy: {\n  <A>(self: NonEmptyReadonlyArray<A>): NonEmptyArray<A>\n  <A>(self: ReadonlyArray<A>): Array<A>\n} = (<A>(self: ReadonlyArray<A>): Array<A> => self.slice()) as any\n\n/**\n * Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `self`.\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const chunksOf: {\n  (\n    n: number\n  ): <S extends ReadonlyArray<any> | Iterable<any>>(\n    self: S\n  ) => ReadonlyArray.With<S, NonEmptyArray<ReadonlyArray.Infer<S>>>\n  <A>(self: NonEmptyReadonlyArray<A>, n: number): NonEmptyArray<NonEmptyArray<A>>\n  <A>(self: Iterable<A>, n: number): Array<NonEmptyArray<A>>\n} = dual(2, <A>(self: Iterable<A>, n: number): Array<NonEmptyArray<A>> => {\n  const input = fromIterable(self)\n  if (isNonEmptyReadonlyArray(input)) {\n    return chop(input, splitNonEmptyAt(n))\n  }\n  return []\n})\n\n/**\n * Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s using the provided `isEquivalent` function.\n *\n * @category grouping\n * @since 2.0.0\n */\nexport const groupWith: {\n  <A>(isEquivalent: (self: A, that: A) => boolean): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<NonEmptyArray<A>>\n  <A>(self: NonEmptyReadonlyArray<A>, isEquivalent: (self: A, that: A) => boolean): NonEmptyArray<NonEmptyArray<A>>\n} = dual(\n  2,\n  <A>(self: NonEmptyReadonlyArray<A>, isEquivalent: (self: A, that: A) => boolean): NonEmptyArray<NonEmptyArray<A>> =>\n    chop(self, (as) => {\n      const h = headNonEmpty(as)\n      const out: NonEmptyArray<A> = [h]\n      let i = 1\n      for (; i < as.length; i++) {\n        const a = as[i]\n        if (isEquivalent(a, h)) {\n          out.push(a)\n        } else {\n          break\n        }\n      }\n      return [out, as.slice(i)]\n    })\n)\n\n/**\n * Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s.\n *\n * @category grouping\n * @since 2.0.0\n */\nexport const group: <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<NonEmptyArray<A>> = groupWith(\n  Equal.equivalence()\n)\n\n/**\n * Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @category grouping\n * @since 2.0.0\n */\nexport const groupBy: {\n  <A, K extends string | symbol>(\n    f: (a: A) => K\n  ): (self: Iterable<A>) => Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>\n  <A, K extends string | symbol>(\n    self: Iterable<A>,\n    f: (a: A) => K\n  ): Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>\n} = dual(2, <A, K extends string | symbol>(\n  self: Iterable<A>,\n  f: (a: A) => K\n): Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>> => {\n  const out: Record<string | symbol, NonEmptyArray<A>> = {}\n  for (const a of self) {\n    const k = f(a)\n    if (Object.prototype.hasOwnProperty.call(out, k)) {\n      out[k].push(a)\n    } else {\n      out[k] = [a]\n    }\n  }\n  return out\n})\n\n/**\n * @since 2.0.0\n */\nexport const unionWith: {\n  <S extends ReadonlyArray<any> | Iterable<any>, T extends ReadonlyArray<any> | Iterable<any>>(\n    that: T,\n    isEquivalent: (self: ReadonlyArray.Infer<S>, that: ReadonlyArray.Infer<T>) => boolean\n  ): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>\n  <A, B>(\n    self: NonEmptyReadonlyArray<A>,\n    that: Iterable<B>,\n    isEquivalent: (self: A, that: B) => boolean\n  ): NonEmptyArray<A | B>\n  <A, B>(\n    self: Iterable<A>,\n    that: NonEmptyReadonlyArray<B>,\n    isEquivalent: (self: A, that: B) => boolean\n  ): NonEmptyArray<A | B>\n  <A, B>(self: Iterable<A>, that: Iterable<B>, isEquivalent: (self: A, that: B) => boolean): Array<A | B>\n} = dual(3, <A>(self: Iterable<A>, that: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A> => {\n  const a = fromIterable(self)\n  const b = fromIterable(that)\n  if (isNonEmptyReadonlyArray(a)) {\n    if (isNonEmptyReadonlyArray(b)) {\n      const dedupe = dedupeWith(isEquivalent)\n      return dedupe(appendAll(a, b))\n    }\n    return a\n  }\n  return b\n})\n\n/**\n * @since 2.0.0\n */\nexport const union: {\n  <T extends ReadonlyArray<any> | Iterable<any>>(\n    that: T\n  ): <S extends ReadonlyArray<any> | Iterable<any>>(\n    self: S\n  ) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>\n  <A, B>(self: NonEmptyReadonlyArray<A>, that: ReadonlyArray<B>): NonEmptyArray<A | B>\n  <A, B>(self: ReadonlyArray<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>\n} = dual(2, <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B> => unionWith(self, that, _equivalence))\n\n/**\n * Creates an `Array` of unique values that are included in all given `Iterable`s using the provided `isEquivalent` function.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * @since 2.0.0\n */\nexport const intersectionWith = <A>(isEquivalent: (self: A, that: A) => boolean): {\n  (that: Iterable<A>): (self: Iterable<A>) => Array<A>\n  (self: Iterable<A>, that: Iterable<A>): Array<A>\n} => {\n  const has = containsWith(isEquivalent)\n  return dual(\n    2,\n    (self: Iterable<A>, that: Iterable<A>): Array<A> => fromIterable(self).filter((a) => has(that, a))\n  )\n}\n\n/**\n * Creates an `Array` of unique values that are included in all given `Iterable`s.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * @since 2.0.0\n */\nexport const intersection: {\n  <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Array<A & B>\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A & B>\n} = intersectionWith(_equivalence)\n\n/**\n * Creates a `Array` of values not included in the other given `Iterable` using the provided `isEquivalent` function.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * @since 2.0.0\n */\nexport const differenceWith = <A>(isEquivalent: (self: A, that: A) => boolean): {\n  (that: Iterable<A>): (self: Iterable<A>) => Array<A>\n  (self: Iterable<A>, that: Iterable<A>): Array<A>\n} => {\n  const has = containsWith(isEquivalent)\n  return dual(\n    2,\n    (self: Iterable<A>, that: Iterable<A>): Array<A> => fromIterable(self).filter((a) => !has(that, a))\n  )\n}\n\n/**\n * Creates a `Array` of values not included in the other given `Iterable`.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * @since 2.0.0\n */\nexport const difference: {\n  <A>(that: Iterable<A>): (self: Iterable<A>) => Array<A>\n  <A>(self: Iterable<A>, that: Iterable<A>): Array<A>\n} = differenceWith(_equivalence)\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const empty: <A = never>() => Array<A> = () => []\n\n/**\n * Constructs a new `NonEmptyArray<A>` from the specified value.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const of = <A>(a: A): NonEmptyArray<A> => [a]\n\n/**\n * @since 2.0.0\n */\nexport declare namespace ReadonlyArray {\n  /**\n   * @since 2.0.0\n   */\n  export type Infer<S extends ReadonlyArray<any> | Iterable<any>> = S extends ReadonlyArray<infer A> ? A\n    : S extends Iterable<infer A> ? A\n    : never\n\n  /**\n   * @since 2.0.0\n   */\n  export type With<S extends ReadonlyArray<any> | Iterable<any>, A> = S extends NonEmptyReadonlyArray<any> ?\n    NonEmptyArray<A>\n    : Array<A>\n\n  /**\n   * @since 2.0.0\n   */\n  export type OrNonEmpty<\n    S extends ReadonlyArray<any> | Iterable<any>,\n    T extends ReadonlyArray<any> | Iterable<any>,\n    A\n  > = S extends NonEmptyReadonlyArray<any> ? NonEmptyArray<A>\n    : T extends NonEmptyReadonlyArray<any> ? NonEmptyArray<A>\n    : Array<A>\n\n  /**\n   * @since 2.0.0\n   */\n  export type AndNonEmpty<\n    S extends ReadonlyArray<any> | Iterable<any>,\n    T extends ReadonlyArray<any> | Iterable<any>,\n    A\n  > = S extends NonEmptyReadonlyArray<any> ? T extends NonEmptyReadonlyArray<any> ? NonEmptyArray<A>\n    : Array<A>\n    : Array<A>\n\n  /**\n   * @since 2.0.0\n   */\n  export type Flatten<T extends ReadonlyArray<ReadonlyArray<any>>> = T extends\n    NonEmptyReadonlyArray<NonEmptyReadonlyArray<infer A>> ? NonEmptyArray<A>\n    : T extends ReadonlyArray<ReadonlyArray<infer A>> ? Array<A>\n    : never\n}\n\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport const map: {\n  <S extends ReadonlyArray<any>, B>(\n    f: (a: ReadonlyArray.Infer<S>, i: number) => B\n  ): (self: S) => ReadonlyArray.With<S, B>\n  <S extends ReadonlyArray<any>, B>(self: S, f: (a: ReadonlyArray.Infer<S>, i: number) => B): ReadonlyArray.With<S, B>\n} = dual(2, <A, B>(self: ReadonlyArray<A>, f: (a: A, i: number) => B): Array<B> => self.map(f))\n\n/**\n * Applies a function to each element in an array and returns a new array containing the concatenated mapped elements.\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport const flatMap: {\n  <S extends ReadonlyArray<any>, T extends ReadonlyArray<any>>(\n    f: (a: ReadonlyArray.Infer<S>, i: number) => T\n  ): (self: S) => ReadonlyArray.AndNonEmpty<S, T, ReadonlyArray.Infer<T>>\n  <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A, i: number) => NonEmptyReadonlyArray<B>): NonEmptyArray<B>\n  <A, B>(self: ReadonlyArray<A>, f: (a: A, i: number) => ReadonlyArray<B>): Array<B>\n} = dual(\n  2,\n  <A, B>(self: ReadonlyArray<A>, f: (a: A, i: number) => ReadonlyArray<B>): Array<B> => {\n    if (isEmptyReadonlyArray(self)) {\n      return []\n    }\n    const out: Array<B> = []\n    for (let i = 0; i < self.length; i++) {\n      const inner = f(self[i], i)\n      for (let j = 0; j < inner.length; j++) {\n        out.push(inner[j])\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Flattens an array of arrays into a single array by concatenating all arrays.\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport const flatten: <S extends ReadonlyArray<ReadonlyArray<any>>>(self: S) => ReadonlyArray.Flatten<S> = flatMap(\n  identity\n) as any\n\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport const filterMap: {\n  <A, B>(f: (a: A, i: number) => Option<B>): (self: Iterable<A>) => Array<B>\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Array<B>\n} = dual(\n  2,\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Array<B> => {\n    const as = fromIterable(self)\n    const out: Array<B> = []\n    for (let i = 0; i < as.length; i++) {\n      const o = f(as[i], i)\n      if (O.isSome(o)) {\n        out.push(o.value)\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Transforms all elements of the `readonlyArray` for as long as the specified function returns some value\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const filterMapWhile: {\n  <A, B>(f: (a: A, i: number) => Option<B>): (self: Iterable<A>) => Array<B>\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Array<B>\n} = dual(2, <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>) => {\n  let i = 0\n  const out: Array<B> = []\n  for (const a of self) {\n    const b = f(a, i)\n    if (O.isSome(b)) {\n      out.push(b.value)\n    } else {\n      break\n    }\n    i++\n  }\n  return out\n})\n\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport const partitionMap: {\n  <A, B, C>(f: (a: A, i: number) => Either<C, B>): (self: Iterable<A>) => [left: Array<B>, right: Array<C>]\n  <A, B, C>(self: Iterable<A>, f: (a: A, i: number) => Either<C, B>): [left: Array<B>, right: Array<C>]\n} = dual(\n  2,\n  <A, B, C>(self: Iterable<A>, f: (a: A, i: number) => Either<C, B>): [left: Array<B>, right: Array<C>] => {\n    const left: Array<B> = []\n    const right: Array<C> = []\n    const as = fromIterable(self)\n    for (let i = 0; i < as.length; i++) {\n      const e = f(as[i], i)\n      if (E.isLeft(e)) {\n        left.push(e.left)\n      } else {\n        right.push(e.right)\n      }\n    }\n    return [left, right]\n  }\n)\n\n/**\n * Retrieves the `Some` values from an `Iterable` of `Option`s, collecting them into an array.\n *\n * @example\n * import { getSomes } from \"effect/Array\"\n * import { some, none } from \"effect/Option\"\n *\n * assert.deepStrictEqual(\n *   getSomes([some(1), none(), some(2)]),\n *   [1, 2]\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const getSomes: <A>(self: Iterable<Option<A>>) => Array<A> = filterMap(identity)\n\n/**\n * Retrieves the `Left` values from an `Iterable` of `Either`s, collecting them into an array.\n *\n * @example\n * import { getLefts } from \"effect/Array\"\n * import { right, left } from \"effect/Either\"\n *\n * assert.deepStrictEqual(\n *   getLefts([right(1), left(\"err\"), right(2)]),\n *   [\"err\"]\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const getLefts = <R, L>(self: Iterable<Either<R, L>>): Array<L> => {\n  const out: Array<L> = []\n  for (const a of self) {\n    if (E.isLeft(a)) {\n      out.push(a.left)\n    }\n  }\n\n  return out\n}\n\n/**\n * Retrieves the `Right` values from an `Iterable` of `Either`s, collecting them into an array.\n *\n * @example\n * import { getRights } from \"effect/Array\"\n * import { right, left } from \"effect/Either\"\n *\n * assert.deepStrictEqual(\n *   getRights([right(1), left(\"err\"), right(2)]),\n *   [1, 2]\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const getRights = <R, L>(self: Iterable<Either<R, L>>): Array<R> => {\n  const out: Array<R> = []\n  for (const a of self) {\n    if (E.isRight(a)) {\n      out.push(a.right)\n    }\n  }\n\n  return out\n}\n\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport const filter: {\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Array<B>\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Array<B>\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>\n} = dual(\n  2,\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A> => {\n    const as = fromIterable(self)\n    const out: Array<A> = []\n    for (let i = 0; i < as.length; i++) {\n      if (predicate(as[i], i)) {\n        out.push(as[i])\n      }\n    }\n    return out\n  }\n)\n\n/**\n * Separate elements based on a predicate that also exposes the index of the element.\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const partition: {\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (\n    self: Iterable<A>\n  ) => [excluded: Array<Exclude<A, B>>, satisfying: Array<B>]\n  <A>(\n    predicate: (a: NoInfer<A>, i: number) => boolean\n  ): (self: Iterable<A>) => [excluded: Array<A>, satisfying: Array<A>]\n  <A, B extends A>(\n    self: Iterable<A>,\n    refinement: (a: A, i: number) => a is B\n  ): [excluded: Array<Exclude<A, B>>, satisfying: Array<B>]\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [excluded: Array<A>, satisfying: Array<A>]\n} = dual(\n  2,\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [excluded: Array<A>, satisfying: Array<A>] => {\n    const left: Array<A> = []\n    const right: Array<A> = []\n    const as = fromIterable(self)\n    for (let i = 0; i < as.length; i++) {\n      if (predicate(as[i], i)) {\n        right.push(as[i])\n      } else {\n        left.push(as[i])\n      }\n    }\n    return [left, right]\n  }\n)\n\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport const separate: <R, L>(self: Iterable<Either<R, L>>) => [Array<L>, Array<R>] = partitionMap(\n  identity\n)\n\n/**\n * @category folding\n * @since 2.0.0\n */\nexport const reduce: {\n  <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B\n  <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B\n} = dual(\n  3,\n  <B, A>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B =>\n    fromIterable(self).reduce((b, a, i) => f(b, a, i), b)\n)\n\n/**\n * @category folding\n * @since 2.0.0\n */\nexport const reduceRight: {\n  <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B\n  <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B\n} = dual(\n  3,\n  <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B =>\n    fromIterable(self).reduceRight((b, a, i) => f(b, a, i), b)\n)\n\n/**\n * @category lifting\n * @since 2.0.0\n */\nexport const liftPredicate: { // Note: I intentionally avoid using the NoInfer pattern here.\n  <A, B extends A>(refinement: Refinement<A, B>): (a: A) => Array<B>\n  <A>(predicate: Predicate<A>): <B extends A>(b: B) => Array<B>\n} = <A>(predicate: Predicate<A>) => <B extends A>(b: B): Array<B> => predicate(b) ? [b] : []\n\n/**\n * @category lifting\n * @since 2.0.0\n */\nexport const liftOption = <A extends Array<unknown>, B>(\n  f: (...a: A) => Option<B>\n) =>\n(...a: A): Array<B> => fromOption(f(...a))\n\n/**\n * @category conversions\n * @since 2.0.0\n */\nexport const fromNullable = <A>(a: A): Array<NonNullable<A>> => a == null ? empty() : [a as NonNullable<A>]\n\n/**\n * @category lifting\n * @since 2.0.0\n */\nexport const liftNullable = <A extends Array<unknown>, B>(\n  f: (...a: A) => B | null | undefined\n): (...a: A) => Array<NonNullable<B>> =>\n(...a) => fromNullable(f(...a))\n\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport const flatMapNullable: {\n  <A, B>(f: (a: A) => B | null | undefined): (self: ReadonlyArray<A>) => Array<NonNullable<B>>\n  <A, B>(self: ReadonlyArray<A>, f: (a: A) => B | null | undefined): Array<NonNullable<B>>\n} = dual(\n  2,\n  <A, B>(self: ReadonlyArray<A>, f: (a: A) => B | null | undefined): Array<NonNullable<B>> =>\n    isNonEmptyReadonlyArray(self) ? fromNullable(f(headNonEmpty(self))) : empty()\n)\n\n/**\n * @category lifting\n * @since 2.0.0\n */\nexport const liftEither = <A extends Array<unknown>, E, B>(\n  f: (...a: A) => Either<B, E>\n) =>\n(...a: A): Array<B> => {\n  const e = f(...a)\n  return E.isLeft(e) ? [] : [e.right]\n}\n\n/**\n * Check if a predicate holds true for every `ReadonlyArray` element.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const every: {\n  <A, B extends A>(\n    refinement: (a: NoInfer<A>, i: number) => a is B\n  ): (self: ReadonlyArray<A>) => self is ReadonlyArray<B>\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: ReadonlyArray<A>) => boolean\n  <A, B extends A>(self: ReadonlyArray<A>, refinement: (a: A, i: number) => a is B): self is ReadonlyArray<B>\n  <A>(self: ReadonlyArray<A>, predicate: (a: A, i: number) => boolean): boolean\n} = dual(\n  2,\n  <A, B extends A>(self: ReadonlyArray<A>, refinement: (a: A, i: number) => a is B): self is ReadonlyArray<B> =>\n    self.every(refinement)\n)\n\n/**\n * Check if a predicate holds true for some `ReadonlyArray` element.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const some: {\n  <A>(\n    predicate: (a: NoInfer<A>, i: number) => boolean\n  ): (self: ReadonlyArray<A>) => self is NonEmptyReadonlyArray<A>\n  <A>(self: ReadonlyArray<A>, predicate: (a: A, i: number) => boolean): self is NonEmptyReadonlyArray<A>\n} = dual(\n  2,\n  <A>(self: ReadonlyArray<A>, predicate: (a: A, i: number) => boolean): self is NonEmptyReadonlyArray<A> =>\n    self.some(predicate)\n)\n\n/**\n * @since 2.0.0\n */\nexport const extend: {\n  <A, B>(f: (as: ReadonlyArray<A>) => B): (self: ReadonlyArray<A>) => Array<B>\n  <A, B>(self: ReadonlyArray<A>, f: (as: ReadonlyArray<A>) => B): Array<B>\n} = dual(\n  2,\n  <A, B>(self: ReadonlyArray<A>, f: (as: ReadonlyArray<A>) => B): Array<B> => self.map((_, i, as) => f(as.slice(i)))\n)\n\n/**\n * @since 2.0.0\n */\nexport const min: {\n  <A>(O: Order.Order<A>): (self: NonEmptyReadonlyArray<A>) => A\n  <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A\n} = dual(2, <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A => self.reduce(Order.min(O)))\n\n/**\n * @since 2.0.0\n */\nexport const max: {\n  <A>(O: Order.Order<A>): (self: NonEmptyReadonlyArray<A>) => A\n  <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A\n} = dual(2, <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A => self.reduce(Order.max(O)))\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const unfold = <B, A>(b: B, f: (b: B) => Option<readonly [A, B]>): Array<A> => {\n  const out: Array<A> = []\n  let next: B = b\n  let o: Option<readonly [A, B]>\n  while (O.isSome(o = f(next))) {\n    const [a, b] = o.value\n    out.push(a)\n    next = b\n  }\n  return out\n}\n\n/**\n * This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\n * The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\n * If all elements are equal, the arrays are then compared based on their length.\n * It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.\n *\n * @category instances\n * @since 2.0.0\n */\nexport const getOrder: <A>(O: Order.Order<A>) => Order.Order<ReadonlyArray<A>> = Order.array\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const getEquivalence: <A>(\n  isEquivalent: Equivalence.Equivalence<A>\n) => Equivalence.Equivalence<ReadonlyArray<A>> = Equivalence.array\n\n/**\n * Iterate over the `Iterable` applying `f`.\n *\n * @since 2.0.0\n */\nexport const forEach: {\n  <A>(f: (a: A, i: number) => void): (self: Iterable<A>) => void\n  <A>(self: Iterable<A>, f: (a: A, i: number) => void): void\n} = dual(2, <A>(self: Iterable<A>, f: (a: A, i: number) => void): void => fromIterable(self).forEach((a, i) => f(a, i)))\n\n/**\n * Remove duplicates from an `Iterable` using the provided `isEquivalent` function,\n * preserving the order of the first occurrence of each element.\n *\n * @since 2.0.0\n */\nexport const dedupeWith: {\n  <S extends ReadonlyArray<any> | Iterable<any>>(\n    isEquivalent: (self: ReadonlyArray.Infer<S>, that: ReadonlyArray.Infer<S>) => boolean\n  ): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>\n  <A>(self: NonEmptyReadonlyArray<A>, isEquivalent: (self: A, that: A) => boolean): NonEmptyArray<A>\n  <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A>\n} = dual(\n  2,\n  <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A> => {\n    const input = fromIterable(self)\n    if (isNonEmptyReadonlyArray(input)) {\n      const out: NonEmptyArray<A> = [headNonEmpty(input)]\n      const rest = tailNonEmpty(input)\n      for (const r of rest) {\n        if (out.every((a) => !isEquivalent(r, a))) {\n          out.push(r)\n        }\n      }\n      return out\n    }\n    return []\n  }\n)\n\n/**\n * Remove duplicates from an `Iterable`, preserving the order of the first occurrence of each element.\n * The equivalence used to compare elements is provided by `Equal.equivalence()` from the `Equal` module.\n *\n * @since 2.0.0\n */\nexport const dedupe = <S extends Iterable<any> | NonEmptyReadonlyArray<any>>(\n  self: S\n): S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never =>\n  dedupeWith(self, Equal.equivalence()) as any\n\n/**\n * Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.\n *\n * @since 2.0.0\n */\nexport const dedupeAdjacentWith: {\n  <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Array<A>\n  <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A>\n} = dual(2, <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A> => {\n  const out: Array<A> = []\n  let lastA: O.Option<A> = O.none()\n  for (const a of self) {\n    if (O.isNone(lastA) || !isEquivalent(a, lastA.value)) {\n      out.push(a)\n      lastA = O.some(a)\n    }\n  }\n  return out\n})\n\n/**\n * Deduplicates adjacent elements that are identical.\n *\n * @since 2.0.0\n */\nexport const dedupeAdjacent: <A>(self: Iterable<A>) => Array<A> = dedupeAdjacentWith(Equal.equivalence())\n\n/**\n * Joins the elements together with \"sep\" in the middle.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const join: {\n  (sep: string): (self: Iterable<string>) => string\n  (self: Iterable<string>, sep: string): string\n} = dual(2, (self: Iterable<string>, sep: string): string => fromIterable(self).join(sep))\n\n/**\n * Statefully maps over the chunk, producing new elements of type `B`.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const mapAccum: {\n  <S, A, B>(\n    s: S,\n    f: (s: S, a: A, i: number) => readonly [S, B]\n  ): (self: Iterable<A>) => [state: S, mappedArray: Array<B>]\n  <S, A, B>(self: Iterable<A>, s: S, f: (s: S, a: A, i: number) => readonly [S, B]): [state: S, mappedArray: Array<B>]\n} = dual(\n  3,\n  <S, A, B>(self: Iterable<A>, s: S, f: (s: S, a: A, i: number) => [S, B]): [state: S, mappedArray: Array<B>] => {\n    let i = 0\n    let s1 = s\n    const out: Array<B> = []\n    for (const a of self) {\n      const r = f(s1, a, i)\n      s1 = r[0]\n      out.push(r[1])\n      i++\n    }\n    return [s1, out]\n  }\n)\n\n/**\n * Zips this chunk crosswise with the specified chunk using the specified combiner.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const cartesianWith: {\n  <A, B, C>(that: ReadonlyArray<B>, f: (a: A, b: B) => C): (self: ReadonlyArray<A>) => Array<C>\n  <A, B, C>(self: ReadonlyArray<A>, that: ReadonlyArray<B>, f: (a: A, b: B) => C): Array<C>\n} = dual(\n  3,\n  <A, B, C>(self: ReadonlyArray<A>, that: ReadonlyArray<B>, f: (a: A, b: B) => C): Array<C> =>\n    flatMap(self, (a) => map(that, (b) => f(a, b)))\n)\n\n/**\n * Zips this chunk crosswise with the specified chunk.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const cartesian: {\n  <B>(that: ReadonlyArray<B>): <A>(self: ReadonlyArray<A>) => Array<[A, B]>\n  <A, B>(self: ReadonlyArray<A>, that: ReadonlyArray<B>): Array<[A, B]>\n} = dual(\n  2,\n  <A, B>(self: ReadonlyArray<A>, that: ReadonlyArray<B>): Array<[A, B]> => cartesianWith(self, that, (a, b) => [a, b])\n)\n", "/**\n * This module provides utility functions for working with Iterables in TypeScript.\n *\n * @since 2.0.0\n */\n\nimport type { NonEmptyArray } from \"./Array.js\"\nimport type { Either } from \"./Either.js\"\nimport * as E from \"./Either.js\"\nimport * as Equal from \"./Equal.js\"\nimport { dual, identity } from \"./Function.js\"\nimport type { Option } from \"./Option.js\"\nimport * as O from \"./Option.js\"\nimport { isBoolean } from \"./Predicate.js\"\nimport type * as Record from \"./Record.js\"\nimport * as Tuple from \"./Tuple.js\"\n\n/**\n * Return a `Iterable` with element `i` initialized with `f(i)`.\n *\n * If the `length` is not specified, the `Iterable` will be infinite.\n *\n * **Note**. `length` is normalized to an integer >= 1.\n *\n * @example\n * import { makeBy } from 'effect/Iterable'\n *\n * assert.deepStrictEqual(Array.from(makeBy(n => n * 2, { length: 5 })), [0, 2, 4, 6, 8])\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const makeBy = <A>(f: (i: number) => A, options?: {\n  readonly length?: number\n}): Iterable<A> => {\n  const max = options?.length !== undefined ? Math.max(1, Math.floor(options.length)) : Infinity\n  return {\n    [Symbol.iterator]() {\n      let i = 0\n      return {\n        next(): IteratorResult<A> {\n          if (i < max) {\n            return { value: f(i++), done: false }\n          }\n          return { done: true, value: undefined }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Return a `Iterable` containing a range of integers, including both endpoints.\n *\n * If `end` is omitted, the range will not have an upper bound.\n *\n * @example\n * import { range } from 'effect/Iterable'\n *\n * assert.deepStrictEqual(Array.from(range(1, 3)), [1, 2, 3])\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const range = (start: number, end?: number): Iterable<number> => {\n  if (end === undefined) {\n    return makeBy((i) => start + i)\n  }\n  return makeBy((i) => start + i, {\n    length: start <= end ? end - start + 1 : 1\n  })\n}\n\n/**\n * Return a `Iterable` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * @example\n * import { replicate } from 'effect/Iterable'\n *\n * assert.deepStrictEqual(Array.from(replicate(\"a\", 3)), [\"a\", \"a\", \"a\"])\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const replicate: {\n  (n: number): <A>(a: A) => Iterable<A>\n  <A>(a: A, n: number): Iterable<A>\n} = dual(2, <A>(a: A, n: number): Iterable<A> => makeBy(() => a, { length: n }))\n\n/**\n * Takes a record and returns an Iterable of tuples containing its keys and values.\n *\n * @param self - The record to transform.\n *\n * @example\n * import { fromRecord } from \"effect/Iterable\"\n *\n * const x = { a: 1, b: 2, c: 3 }\n * assert.deepStrictEqual(Array.from(fromRecord(x)), [[\"a\", 1], [\"b\", 2], [\"c\", 3]])\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const fromRecord = <K extends string, A>(self: Readonly<Record<K, A>>): Iterable<[K, A]> => ({\n  *[Symbol.iterator]() {\n    for (const key in self) {\n      if (Object.prototype.hasOwnProperty.call(self, key)) {\n        yield [key, self[key]]\n      }\n    }\n  }\n})\n\n/**\n * Prepend an element to the front of an `Iterable`, creating a new `Iterable`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prepend: {\n  <B>(head: B): <A>(self: Iterable<A>) => Iterable<A | B>\n  <A, B>(self: Iterable<A>, head: B): Iterable<A | B>\n} = dual(2, <A, B>(self: Iterable<A>, head: B): Iterable<A | B> => prependAll(self, [head]))\n\n/**\n * Prepends the specified prefix iterable to the beginning of the specified iterable.\n *\n * @example\n * import * as Iterable from \"effect/Iterable\"\n *\n * assert.deepStrictEqual(\n *   Array.from(Iterable.prependAll([1, 2], [\"a\", \"b\"])),\n *   [\"a\", \"b\", 1, 2]\n * )\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const prependAll: {\n  <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<A | B>\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<A | B>\n} = dual(\n  2,\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<A | B> => appendAll(that, self)\n)\n\n/**\n * Append an element to the end of an `Iterable`, creating a new `Iterable`.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const append: {\n  <B>(last: B): <A>(self: Iterable<A>) => Iterable<A | B>\n  <A, B>(self: Iterable<A>, last: B): Iterable<A | B>\n} = dual(2, <A, B>(self: Iterable<A>, last: B): Iterable<A | B> => appendAll(self, [last]))\n\n/**\n * Concatenates two iterables, combining their elements.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const appendAll: {\n  <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<A | B>\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<A | B>\n} = dual(\n  2,\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<A | B> => ({\n    [Symbol.iterator]() {\n      const iterA = self[Symbol.iterator]()\n      let doneA = false\n      let iterB: Iterator<B>\n      return {\n        next() {\n          if (!doneA) {\n            const r = iterA.next()\n            if (r.done) {\n              doneA = true\n              iterB = that[Symbol.iterator]()\n              return iterB.next()\n            }\n            return r\n          }\n          return iterB.next()\n        }\n      }\n    }\n  })\n)\n\n/**\n * Reduce an `Iterable` from the left, keeping all intermediate results instead of only the final result.\n *\n * @category folding\n * @since 2.0.0\n */\nexport const scan: {\n  <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => Iterable<B>\n  <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): Iterable<B>\n} = dual(3, <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): Iterable<B> => ({\n  [Symbol.iterator]() {\n    let acc = b\n    let iterator: Iterator<A> | undefined\n    function next() {\n      if (iterator === undefined) {\n        iterator = self[Symbol.iterator]()\n        return { done: false, value: acc }\n      }\n      const result = iterator.next()\n      if (result.done) {\n        return result\n      }\n      acc = f(acc, result.value)\n      return { done: false, value: acc }\n    }\n    return { next }\n  }\n}))\n\n/**\n * Determine if an `Iterable` is empty\n *\n * @example\n * import { isEmpty } from \"effect/Iterable\"\n *\n * assert.deepStrictEqual(isEmpty([]), true);\n * assert.deepStrictEqual(isEmpty([1, 2, 3]), false);\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isEmpty = <A>(self: Iterable<A>): self is Iterable<never> => {\n  const iterator = self[Symbol.iterator]()\n  return iterator.next().done === true\n}\n\n/**\n * Return the number of elements in a `Iterable`.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const size = <A>(self: Iterable<A>): number => {\n  const iterator = self[Symbol.iterator]()\n  let count = 0\n  while (!iterator.next().done) {\n    count++\n  }\n  return count\n}\n\n/**\n * Get the first element of a `Iterable`, or `None` if the `Iterable` is empty.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const head = <A>(self: Iterable<A>): Option<A> => {\n  const iterator = self[Symbol.iterator]()\n  const result = iterator.next()\n  return result.done ? O.none() : O.some(result.value)\n}\n\n/**\n * Keep only a max number of elements from the start of an `Iterable`, creating a new `Iterable`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const take: {\n  (n: number): <A>(self: Iterable<A>) => Iterable<A>\n  <A>(self: Iterable<A>, n: number): Iterable<A>\n} = dual(2, <A>(self: Iterable<A>, n: number): Iterable<A> => ({\n  [Symbol.iterator]() {\n    let i = 0\n    const iterator = self[Symbol.iterator]()\n    return {\n      next() {\n        if (i < n) {\n          i++\n          return iterator.next()\n        }\n        return { done: true, value: undefined }\n      }\n    }\n  }\n}))\n\n/**\n * Calculate the longest initial Iterable for which all element satisfy the specified predicate, creating a new `Iterable`.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const takeWhile: {\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Iterable<B>\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Iterable<A>\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Iterable<B>\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Iterable<A>\n} = dual(2, <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Iterable<A> => ({\n  [Symbol.iterator]() {\n    const iterator = self[Symbol.iterator]()\n    let i = 0\n    return {\n      next() {\n        const result = iterator.next()\n        if (result.done || !predicate(result.value, i++)) {\n          return { done: true, value: undefined }\n        }\n        return result\n      }\n    }\n  }\n}))\n\n/**\n * Drop a max number of elements from the start of an `Iterable`\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 2.0.0\n */\nexport const drop: {\n  (n: number): <A>(self: Iterable<A>) => Iterable<A>\n  <A>(self: Iterable<A>, n: number): Iterable<A>\n} = dual(2, <A>(self: Iterable<A>, n: number): Iterable<A> => ({\n  [Symbol.iterator]() {\n    const iterator = self[Symbol.iterator]()\n    let i = 0\n    return {\n      next() {\n        while (i < n) {\n          const result = iterator.next()\n          if (result.done) {\n            return { done: true, value: undefined }\n          }\n          i++\n        }\n        return iterator.next()\n      }\n    }\n  }\n}))\n\n/**\n * Returns the first element that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findFirst: {\n  <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>\n} = dual(\n  2,\n  <A>(self: Iterable<A>, f: ((a: A, i: number) => boolean) | ((a: A, i: number) => Option<A>)): Option<A> => {\n    let i = 0\n    for (const a of self) {\n      const o = f(a, i)\n      if (isBoolean(o)) {\n        if (o) {\n          return O.some(a)\n        }\n      } else {\n        if (O.isSome(o)) {\n          return o\n        }\n      }\n      i++\n    }\n    return O.none()\n  }\n)\n\n/**\n * Find the last element for which a predicate holds.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const findLast: {\n  <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>\n} = dual(\n  2,\n  <A>(self: Iterable<A>, f: ((a: A, i: number) => boolean) | ((a: A, i: number) => Option<A>)): Option<A> => {\n    let i = 0\n    let last: Option<A> = O.none()\n    for (const a of self) {\n      const o = f(a, i)\n      if (isBoolean(o)) {\n        if (o) {\n          last = O.some(a)\n        }\n      } else {\n        if (O.isSome(o)) {\n          last = o\n        }\n      }\n      i++\n    }\n    return last\n  }\n)\n\n/**\n * Takes two `Iterable`s and returns an `Iterable` of corresponding pairs.\n *\n * @category zipping\n * @since 2.0.0\n */\nexport const zip: {\n  <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<[A, B]>\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<[A, B]>\n} = dual(\n  2,\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<[A, B]> => zipWith(self, that, Tuple.make)\n)\n\n/**\n * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results. If one\n * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.\n *\n * @category zipping\n * @since 2.0.0\n */\nexport const zipWith: {\n  <B, A, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Iterable<C>\n  <A, B, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Iterable<C>\n} = dual(3, <B, A, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Iterable<C> => ({\n  [Symbol.iterator]() {\n    const selfIterator = self[Symbol.iterator]()\n    const thatIterator = that[Symbol.iterator]()\n    return {\n      next() {\n        const selfResult = selfIterator.next()\n        const thatResult = thatIterator.next()\n        if (selfResult.done || thatResult.done) {\n          return { done: true, value: undefined }\n        }\n        return { done: false, value: f(selfResult.value, thatResult.value) }\n      }\n    }\n  }\n}))\n\n/**\n * Places an element in between members of an `Iterable`.\n * If the input is a non-empty array, the result is also a non-empty array.\n *\n * @since 2.0.0\n */\nexport const intersperse: {\n  <B>(middle: B): <A>(self: Iterable<A>) => Iterable<A | B>\n  <A, B>(self: Iterable<A>, middle: B): Iterable<A | B>\n} = dual(2, <A, B>(self: Iterable<A>, middle: B): Iterable<A | B> => ({\n  [Symbol.iterator]() {\n    const iterator = self[Symbol.iterator]()\n    let next = iterator.next()\n    let emitted = false\n    return {\n      next() {\n        if (next.done) {\n          return next\n        } else if (emitted) {\n          emitted = false\n          return { done: false, value: middle }\n        }\n        emitted = true\n        const result = next\n        next = iterator.next()\n        return result\n      }\n    }\n  }\n}))\n\n/**\n * Returns a function that checks if an `Iterable` contains a given value using a provided `isEquivalent` function.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const containsWith = <A>(isEquivalent: (self: A, that: A) => boolean): {\n  (a: A): (self: Iterable<A>) => boolean\n  (self: Iterable<A>, a: A): boolean\n} =>\n  dual(2, (self: Iterable<A>, a: A): boolean => {\n    for (const i of self) {\n      if (isEquivalent(a, i)) {\n        return true\n      }\n    }\n    return false\n  })\n\nconst _equivalence = Equal.equivalence()\n\n/**\n * Returns a function that checks if a `Iterable` contains a given value using the default `Equivalence`.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const contains: {\n  <A>(a: A): (self: Iterable<A>) => boolean\n  <A>(self: Iterable<A>, a: A): boolean\n} = containsWith(_equivalence)\n\n/**\n * Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `Iterable`.\n *\n * @category splitting\n * @since 2.0.0\n */\nexport const chunksOf: {\n  (n: number): <A>(self: Iterable<A>) => Iterable<Array<A>>\n  <A>(self: Iterable<A>, n: number): Iterable<Array<A>>\n} = dual(2, <A>(self: Iterable<A>, n: number): Iterable<Array<A>> => {\n  const safeN = Math.max(1, Math.floor(n))\n  return ({\n    [Symbol.iterator]() {\n      let iterator: Iterator<A> | undefined = self[Symbol.iterator]()\n      return {\n        next() {\n          if (iterator === undefined) {\n            return { done: true, value: undefined }\n          }\n\n          const chunk: Array<A> = []\n          for (let i = 0; i < safeN; i++) {\n            const result = iterator.next()\n            if (result.done) {\n              iterator = undefined\n              return chunk.length === 0 ? { done: true, value: undefined } : { done: false, value: chunk }\n            }\n            chunk.push(result.value)\n          }\n\n          return { done: false, value: chunk }\n        }\n      }\n    }\n  })\n})\n\n/**\n * Group equal, consecutive elements of an `Iterable` into `NonEmptyArray`s using the provided `isEquivalent` function.\n *\n * @category grouping\n * @since 2.0.0\n */\nexport const groupWith: {\n  <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Iterable<NonEmptyArray<A>>\n  <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Iterable<NonEmptyArray<A>>\n} = dual(\n  2,\n  <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Iterable<NonEmptyArray<A>> => ({\n    [Symbol.iterator]() {\n      const iterator = self[Symbol.iterator]()\n      let nextResult: IteratorResult<A> | undefined\n      return {\n        next() {\n          let result: IteratorResult<A>\n          if (nextResult !== undefined) {\n            if (nextResult.done) {\n              return { done: true, value: undefined }\n            }\n            result = nextResult\n            nextResult = undefined\n          } else {\n            result = iterator.next()\n            if (result.done) {\n              return { done: true, value: undefined }\n            }\n          }\n          const chunk: NonEmptyArray<A> = [result.value]\n          // eslint-disable-next-line no-constant-condition\n          while (true) {\n            const next = iterator.next()\n            if (next.done || !isEquivalent(result.value, next.value)) {\n              nextResult = next\n              return { done: false, value: chunk }\n            }\n            chunk.push(next.value)\n          }\n        }\n      }\n    }\n  })\n)\n\n/**\n * Group equal, consecutive elements of an `Iterable` into `NonEmptyArray`s.\n *\n * @category grouping\n * @since 2.0.0\n */\nexport const group: <A>(self: Iterable<A>) => Iterable<NonEmptyArray<A>> = groupWith(\n  Equal.equivalence()\n)\n\n/**\n * Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @category grouping\n * @since 2.0.0\n */\nexport const groupBy: {\n  <A, K extends string | symbol>(\n    f: (a: A) => K\n  ): (self: Iterable<A>) => Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>\n  <A, K extends string | symbol>(\n    self: Iterable<A>,\n    f: (a: A) => K\n  ): Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>\n} = dual(2, <A, K extends string | symbol>(\n  self: Iterable<A>,\n  f: (a: A) => K\n): Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>> => {\n  const out: Record<string | symbol, NonEmptyArray<A>> = {}\n  for (const a of self) {\n    const k = f(a)\n    if (Object.prototype.hasOwnProperty.call(out, k)) {\n      out[k].push(a)\n    } else {\n      out[k] = [a]\n    }\n  }\n  return out\n})\n\nconst constEmpty: Iterable<never> = {\n  [Symbol.iterator]() {\n    return constEmptyIterator\n  }\n}\nconst constEmptyIterator: Iterator<never> = {\n  next() {\n    return { done: true, value: undefined }\n  }\n}\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const empty = <A = never>(): Iterable<A> => constEmpty\n\n/**\n * Constructs a new `Iterable<A>` from the specified value.\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const of = <A>(a: A): Iterable<A> => [a]\n\n/**\n * @category mapping\n * @since 2.0.0\n */\nexport const map: {\n  <A, B>(\n    f: (a: NoInfer<A>, i: number) => B\n  ): (self: Iterable<A>) => Iterable<B>\n  <A, B>(self: Iterable<A>, f: (a: NoInfer<A>, i: number) => B): Iterable<B>\n} = dual(2, <A, B>(self: Iterable<A>, f: (a: A, i: number) => B): Iterable<B> => ({\n  [Symbol.iterator]() {\n    const iterator = self[Symbol.iterator]()\n    let i = 0\n    return {\n      next() {\n        const result = iterator.next()\n        if (result.done) {\n          return { done: true, value: undefined }\n        }\n        return { done: false, value: f(result.value, i++) }\n      }\n    }\n  }\n}))\n\n/**\n * Applies a function to each element in an Iterable and returns a new Iterable containing the concatenated mapped elements.\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport const flatMap: {\n  <A, B>(\n    f: (a: NoInfer<A>, i: number) => Iterable<B>\n  ): (self: Iterable<A>) => Iterable<B>\n  <A, B>(self: Iterable<A>, f: (a: NoInfer<A>, i: number) => Iterable<B>): Iterable<B>\n} = dual(\n  2,\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Iterable<B>): Iterable<B> => flatten(map(self, f))\n)\n\n/**\n * Flattens an Iterable of Iterables into a single Iterable\n *\n * @category sequencing\n * @since 2.0.0\n */\nexport const flatten = <A>(self: Iterable<Iterable<A>>): Iterable<A> => ({\n  [Symbol.iterator]() {\n    const outerIterator = self[Symbol.iterator]()\n    let innerIterator: Iterator<A> | undefined\n    function next() {\n      if (innerIterator === undefined) {\n        const next = outerIterator.next()\n        if (next.done) {\n          return next\n        }\n        innerIterator = next.value[Symbol.iterator]()\n      }\n      const result = innerIterator.next()\n      if (result.done) {\n        innerIterator = undefined\n        return next()\n      }\n      return result\n    }\n    return { next }\n  }\n})\n\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport const filterMap: {\n  <A, B>(f: (a: A, i: number) => Option<B>): (self: Iterable<A>) => Iterable<B>\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Iterable<B>\n} = dual(\n  2,\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Iterable<B> => ({\n    [Symbol.iterator]() {\n      const iterator = self[Symbol.iterator]()\n      let i = 0\n      return {\n        next() {\n          let result = iterator.next()\n          while (!result.done) {\n            const b = f(result.value, i++)\n            if (O.isSome(b)) {\n              return { done: false, value: b.value }\n            }\n            result = iterator.next()\n          }\n          return { done: true, value: undefined }\n        }\n      }\n    }\n  })\n)\n\n/**\n * Transforms all elements of the `Iterable` for as long as the specified function returns some value\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const filterMapWhile: {\n  <A, B>(f: (a: A, i: number) => Option<B>): (self: Iterable<A>) => Iterable<B>\n  <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Iterable<B>\n} = dual(2, <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>) => ({\n  [Symbol.iterator]() {\n    const iterator = self[Symbol.iterator]()\n    let i = 0\n    return {\n      next() {\n        const result = iterator.next()\n        if (result.done) {\n          return { done: true, value: undefined }\n        }\n        const b = f(result.value, i++)\n        if (O.isSome(b)) {\n          return { done: false, value: b.value }\n        }\n        return { done: true, value: undefined }\n      }\n    }\n  }\n}))\n\n/**\n * Retrieves the `Some` values from an `Iterable` of `Option`s.\n *\n * @example\n * import { getSomes } from \"effect/Iterable\"\n * import { some, none } from \"effect/Option\"\n *\n * assert.deepStrictEqual(\n *   Array.from(getSomes([some(1), none(), some(2)])),\n *   [1, 2]\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const getSomes: <A>(self: Iterable<Option<A>>) => Iterable<A> = filterMap(identity)\n\n/**\n * Retrieves the `Left` values from an `Iterable` of `Either`s.\n *\n * @example\n * import { getLefts } from \"effect/Iterable\"\n * import { right, left } from \"effect/Either\"\n *\n * assert.deepStrictEqual(\n *   Array.from(getLefts([right(1), left(\"err\"), right(2)])),\n *   [\"err\"]\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const getLefts = <R, L>(self: Iterable<Either<R, L>>): Iterable<L> => filterMap(self, E.getLeft)\n\n/**\n * Retrieves the `Right` values from an `Iterable` of `Either`s.\n *\n * @example\n * import { getRights } from \"effect/Iterable\"\n * import { right, left } from \"effect/Either\"\n *\n * assert.deepStrictEqual(\n *   Array.from(getRights([right(1), left(\"err\"), right(2)])),\n *   [1, 2]\n * )\n *\n * @category filtering\n * @since 2.0.0\n */\nexport const getRights = <R, L>(self: Iterable<Either<R, L>>): Iterable<R> => filterMap(self, E.getRight)\n\n/**\n * @category filtering\n * @since 2.0.0\n */\nexport const filter: {\n  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Iterable<B>\n  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Iterable<A>\n  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Iterable<B>\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Iterable<A>\n} = dual(\n  2,\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Iterable<A> => ({\n    [Symbol.iterator]() {\n      const iterator = self[Symbol.iterator]()\n      let i = 0\n      return {\n        next() {\n          let result = iterator.next()\n          while (!result.done) {\n            if (predicate(result.value, i++)) {\n              return { done: false, value: result.value }\n            }\n            result = iterator.next()\n          }\n          return { done: true, value: undefined }\n        }\n      }\n    }\n  })\n)\n\n/**\n * @category sequencing\n * @since 2.0.0\n */\nexport const flatMapNullable: {\n  <A, B>(f: (a: A) => B | null | undefined): (self: Iterable<A>) => Iterable<NonNullable<B>>\n  <A, B>(self: Iterable<A>, f: (a: A) => B | null | undefined): Iterable<NonNullable<B>>\n} = dual(\n  2,\n  <A, B>(self: Iterable<A>, f: (a: A) => B | null | undefined): Iterable<NonNullable<B>> =>\n    filterMap(self, (a) => {\n      const b = f(a)\n      return b == null ? O.none() : O.some(b)\n    })\n)\n\n/**\n * Check if a predicate holds true for some `Iterable` element.\n *\n * @category elements\n * @since 2.0.0\n */\nexport const some: {\n  <A>(predicate: (a: A, i: number) => boolean): (self: Iterable<A>) => boolean\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): boolean\n} = dual(\n  2,\n  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): boolean => {\n    let i = 0\n    for (const a of self) {\n      if (predicate(a, i++)) {\n        return true\n      }\n    }\n    return false\n  }\n)\n\n/**\n * @category constructors\n * @since 2.0.0\n */\nexport const unfold = <B, A>(b: B, f: (b: B) => Option<readonly [A, B]>): Iterable<A> => ({\n  [Symbol.iterator]() {\n    let next = b\n    return {\n      next() {\n        const o = f(next)\n        if (O.isNone(o)) {\n          return { done: true, value: undefined }\n        }\n        const [a, b] = o.value\n        next = b\n        return { done: false, value: a }\n      }\n    }\n  }\n})\n\n/**\n * Iterate over the `Iterable` applying `f`.\n *\n * @since 2.0.0\n */\nexport const forEach: {\n  <A>(f: (a: A, i: number) => void): (self: Iterable<A>) => void\n  <A>(self: Iterable<A>, f: (a: A, i: number) => void): void\n} = dual(2, <A>(self: Iterable<A>, f: (a: A, i: number) => void): void => {\n  let i = 0\n  for (const a of self) {\n    f(a, i++)\n  }\n})\n\n/**\n * @category folding\n * @since 2.0.0\n */\nexport const reduce: {\n  <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B\n  <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B\n} = dual(3, <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B => {\n  if (Array.isArray(self)) {\n    return self.reduce(f, b)\n  }\n  let i = 0\n  let result = b\n  for (const n of self) {\n    result = f(result, n, i++)\n  }\n  return result\n})\n\n/**\n * Deduplicates adjacent elements that are identical using the provided `isEquivalent` function.\n *\n * @since 2.0.0\n */\nexport const dedupeAdjacentWith: {\n  <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Iterable<A>\n  <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Iterable<A>\n} = dual(2, <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Iterable<A> => ({\n  [Symbol.iterator]() {\n    const iterator = self[Symbol.iterator]()\n    let first = true\n    let last: A\n    function next(): IteratorResult<A> {\n      const result = iterator.next()\n      if (result.done) {\n        return { done: true, value: undefined }\n      }\n      if (first) {\n        first = false\n        last = result.value\n        return result\n      }\n      const current = result.value\n      if (isEquivalent(last, current)) {\n        return next()\n      }\n      last = current\n      return result\n    }\n    return { next }\n  }\n}))\n\n/**\n * Deduplicates adjacent elements that are identical.\n *\n * @since 2.0.0\n */\nexport const dedupeAdjacent: <A>(self: Iterable<A>) => Iterable<A> = dedupeAdjacentWith(Equal.equivalence())\n\n/**\n * Zips this Iterable crosswise with the specified Iterable using the specified combiner.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const cartesianWith: {\n  <A, B, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Iterable<C>\n  <A, B, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Iterable<C>\n} = dual(\n  3,\n  <A, B, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Iterable<C> =>\n    flatMap(self, (a) => map(that, (b) => f(a, b)))\n)\n\n/**\n * Zips this Iterable crosswise with the specified Iterable.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const cartesian: {\n  <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<[A, B]>\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<[A, B]>\n} = dual(\n  2,\n  <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<[A, B]> => cartesianWith(self, that, (a, b) => [a, b])\n)\n", "/**\n * This module provides utility functions for working with tuples in TypeScript.\n *\n * @since 2.0.0\n */\nimport * as Equivalence from \"./Equivalence.js\"\nimport { dual } from \"./Function.js\"\nimport type { TypeLambda } from \"./HKT.js\"\nimport * as order from \"./Order.js\"\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface TupleTypeLambda extends TypeLambda {\n  readonly type: [this[\"Out1\"], this[\"Target\"]]\n}\n\n/**\n * Constructs a new tuple from the provided values.\n *\n * @param elements - The list of elements to create the tuple from.\n *\n * @example\n * import { make } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(make(1, 'hello', true), [1, 'hello', true])\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const make = <A extends ReadonlyArray<any>>(...elements: A): A => elements\n\n/**\n * Return the first element of a tuple.\n *\n * @param self - A tuple of length `2`.\n *\n * @example\n * import { getFirst } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(getFirst([\"hello\", 42]), \"hello\")\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getFirst = <L, R>(self: readonly [L, R]): L => self[0]\n\n/**\n * Return the second element of a tuple.\n *\n * @param self - A tuple of length `2`.\n *\n * @example\n * import { getSecond } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(getSecond([\"hello\", 42]), 42)\n *\n * @category getters\n * @since 2.0.0\n */\nexport const getSecond = <L, R>(self: readonly [L, R]): R => self[1]\n\n/**\n * Transforms both elements of a tuple using the given functions.\n *\n * @param self - A tuple of length `2`.\n * @param f - The function to transform the first element of the tuple.\n * @param g - The function to transform the second element of the tuple.\n *\n * @example\n * import { mapBoth } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(\n *   mapBoth([\"hello\", 42], { onFirst: s => s.toUpperCase(), onSecond: n => n.toString() }),\n *   [\"HELLO\", \"42\"]\n * )\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const mapBoth: {\n  <L1, L2, R1, R2>(options: {\n    readonly onFirst: (e: L1) => L2\n    readonly onSecond: (a: R1) => R2\n  }): (self: readonly [L1, R1]) => [L2, R2]\n  <L1, R1, L2, R2>(self: readonly [L1, R1], options: {\n    readonly onFirst: (e: L1) => L2\n    readonly onSecond: (a: R1) => R2\n  }): [L2, R2]\n} = dual(\n  2,\n  <L1, R1, L2, R2>(\n    self: readonly [L1, R1],\n    { onFirst, onSecond }: {\n      readonly onFirst: (e: L1) => L2\n      readonly onSecond: (a: R1) => R2\n    }\n  ): [L2, R2] => [onFirst(self[0]), onSecond(self[1])]\n)\n\n/**\n * Transforms the first component of a tuple using a given function.\n *\n * @param self - A tuple of length `2`.\n * @param f - The function to transform the first element of the tuple.\n *\n * @example\n * import { mapFirst } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(\n *   mapFirst([\"hello\", 42], s => s.toUpperCase()),\n *   [\"HELLO\", 42]\n * )\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const mapFirst: {\n  <L1, L2>(f: (left: L1) => L2): <R>(self: readonly [L1, R]) => [L2, R]\n  <L1, R, L2>(self: readonly [L1, R], f: (left: L1) => L2): [L2, R]\n} = dual(2, <L1, R, L2>(self: readonly [L1, R], f: (left: L1) => L2): [L2, R] => [f(self[0]), self[1]])\n\n/**\n * Transforms the second component of a tuple using a given function.\n *\n * @param self - A tuple of length `2`.\n * @param f - The function to transform the second element of the tuple.\n *\n * @example\n * import { mapSecond } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(\n *   mapSecond([\"hello\", 42], n => n.toString()),\n *   [\"hello\", \"42\"]\n * )\n *\n * @category mapping\n * @since 2.0.0\n */\nexport const mapSecond: {\n  <R1, R2>(f: (right: R1) => R2): <L>(self: readonly [L, R1]) => [L, R2]\n  <L, R1, R2>(self: readonly [L, R1], f: (right: R1) => R2): [L, R2]\n} = dual(2, <L, R1, R2>(self: readonly [L, R1], f: (right: R1) => R2): [L, R2] => [self[0], f(self[1])])\n\n/**\n * Swaps the two elements of a tuple.\n *\n * @param self - A tuple of length `2`.\n *\n * @example\n * import { swap } from \"effect/Tuple\"\n *\n * assert.deepStrictEqual(swap([\"hello\", 42]), [42, \"hello\"])\n *\n * @since 2.0.0\n */\nexport const swap = <L, R>(self: readonly [L, R]): [R, L] => [self[1], self[0]]\n\n/**\n * Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple\n * by applying each `Equivalence` to the corresponding element of the tuple.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const getEquivalence: <T extends ReadonlyArray<Equivalence.Equivalence<any>>>(\n  ...isEquivalents: T\n) => Equivalence.Equivalence<\n  Readonly<{ [I in keyof T]: [T[I]] extends [Equivalence.Equivalence<infer A>] ? A : never }>\n> = Equivalence.tuple\n\n/**\n * This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.\n * The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.\n * It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element\n * of the tuple.\n *\n * @category combinators\n * @since 2.0.0\n */\nexport const getOrder: <T extends ReadonlyArray<order.Order<any>>>(\n  ...elements: T\n) => order.Order<{ [I in keyof T]: [T[I]] extends [order.Order<infer A>] ? A : never }> = order.tuple\n\n/**\n * Appends an element to the end of a tuple.\n *\n * @category concatenating\n * @since 2.0.0\n */\nexport const appendElement: {\n  <B>(that: B): <A extends ReadonlyArray<unknown>>(self: A) => [...A, B]\n  <A extends ReadonlyArray<unknown>, B>(self: A, that: B): [...A, B]\n} = dual(2, <A extends ReadonlyArray<unknown>, B>(self: A, that: B): [...A, B] => [...self, that])\n\n/*\n\n  TODO:\n\n  - at\n  - swap\n\n*/\n"],
  "mappings": "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",
  "names": ["append", "appendAll", "cartesian", "cartesianWith", "chunksOf", "contains", "containsWith", "dedupeAdjacent", "dedupeAdjacentWith", "drop", "empty", "filter", "filterMap", "filterMapWhile", "findFirst", "findLast", "flatMap", "flatMapNullable", "flatten", "forEach", "fromRecord", "getEquivalence", "getLefts", "getOrder", "getRights", "getSomes", "group", "groupBy", "groupWith", "head", "intersperse", "isNonEmptyArray", "make", "makeBy", "map", "max", "min", "of", "prepend", "prependAll", "range", "reduce", "replicate", "scan", "some", "take", "takeWhile", "unfold", "zip", "zipWith", "some", "make", "elements", "getFirst", "self", "getSecond", "mapBoth", "dual", "onFirst", "onSecond", "mapFirst", "f", "mapSecond", "swap", "getEquivalence", "tuple", "getOrder", "appendElement", "that", "makeBy", "f", "options", "max", "length", "undefined", "Math", "floor", "Infinity", "Symbol", "iterator", "i", "next", "value", "done", "range", "start", "end", "replicate", "dual", "a", "n", "fromRecord", "self", "key", "Object", "prototype", "hasOwnProperty", "call", "prepend", "head", "prependAll", "that", "appendAll", "append", "last", "iterA", "doneA", "iterB", "r", "scan", "b", "acc", "result", "isEmpty", "size", "count", "none", "some", "take", "takeWhile", "predicate", "drop", "findFirst", "o", "isBoolean", "isSome", "findLast", "zip", "zipWith", "make", "selfIterator", "thatIterator", "selfResult", "thatResult", "intersperse", "middle", "emitted", "containsWith", "isEquivalent", "_equivalence", "equivalence", "contains", "chunksOf", "safeN", "chunk", "push", "groupWith", "nextResult", "group", "groupBy", "out", "k", "constEmpty", "constEmptyIterator", "empty", "of", "map", "flatMap", "flatten", "outerIterator", "innerIterator", "filterMap", "filterMapWhile", "getSomes", "identity", "getLefts", "getLeft", "getRights", "getRight", "filter", "flatMapNullable", "unfold", "isNone", "forEach", "reduce", "Array", "isArray", "dedupeAdjacentWith", "first", "current", "dedupeAdjacent", "cartesianWith", "cartesian", "make", "elements", "allocate", "n", "Array", "makeBy", "f", "max", "Math", "floor", "out", "i", "range", "start", "end", "replicate", "dual", "a", "fromIterable", "collection", "isArray", "from", "fromRecord", "toEntries", "fromOption", "toArray", "match", "self", "onEmpty", "onNonEmpty", "isNonEmptyReadonlyArray", "matchLeft", "headNonEmpty", "tailNonEmpty", "matchRight", "initNonEmpty", "lastNonEmpty", "prepend", "head", "prependAll", "that", "concat", "append", "last", "appendAll", "scan", "b", "scanRight", "input", "length", "isEmptyArray", "isEmptyReadonlyArray", "isNonEmptyArray", "isOutOfBound", "as", "clamp", "min", "get", "index", "none", "some", "unsafeGet", "Error", "unprepend", "unappend", "tail", "slice", "init", "take", "takeRight", "takeWhile", "predicate", "push", "spanIndex", "span", "splitAt", "drop", "dropRight", "dropWhile", "findFirstIndex", "findLastIndex", "findFirst", "findLast", "o", "isBoolean", "isSome", "insertAt", "splice", "replace", "modify", "replaceOption", "modifyOption", "getOrElse", "next", "remove", "reverse", "sort", "O", "sortWith", "order", "mapInput", "sortBy", "orders", "sortByAll", "combineAll", "zip", "zipWith", "bs", "len", "unzip", "fa", "fb", "intersperse", "middle", "modifyNonEmptyHead", "setNonEmptyHead", "modifyNonEmptyLast", "setNonEmptyLast", "rotate", "m", "round", "abs", "copy", "s", "splitNonEmptyAt", "containsWith", "isEquivalent", "_equivalence", "equivalence", "contains", "chop", "rest", "_n", "split", "chunksOf", "ceil", "splitWhere", "groupWith", "h", "group", "groupBy", "k", "Object", "prototype", "hasOwnProperty", "call", "unionWith", "dedupe", "dedupeWith", "union", "intersectionWith", "has", "filter", "intersection", "differenceWith", "difference", "empty", "of", "map", "flatMap", "inner", "j", "flatten", "identity", "filterMap", "value", "filterMapWhile", "partitionMap", "left", "right", "e", "isLeft", "getSomes", "getLefts", "getRights", "isRight", "partition", "separate", "reduce", "reduceRight", "liftPredicate", "liftOption", "fromNullable", "liftNullable", "flatMapNullable", "liftEither", "every", "refinement", "extend", "_", "unfold", "getOrder", "array", "getEquivalence", "forEach", "r", "dedupeAdjacentWith", "lastA", "isNone", "dedupeAdjacent", "join", "sep", "mapAccum", "s1", "cartesianWith", "cartesian"]
}
