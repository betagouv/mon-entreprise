import {
  $7af3f5b51489e0b5$export$253fe78d46329472,
  $d496c0a20b6e58ec$export$6c8a5aaad13c9852
} from "./chunk-VMLMBK3V.js";
import {
  $fc909762b330b746$export$61c6a8c84e605fb6
} from "./chunk-76RKRRQY.js";
import {
  $7613b1592d41b092$export$6cd28814d92fa9c9
} from "./chunk-DASZ6W3H.js";
import {
  $458b0a5536c1a7cf$export$40bfa8c7b0832715
} from "./chunk-SSXGWH7G.js";
import {
  _defineProperty
} from "./chunk-5SQXUMIX.js";
import {
  require_react
} from "./chunk-4BTUQGSU.js";
import {
  __toESM
} from "./chunk-2LSFTFF7.js";

// ../node_modules/@react-stately/menu/dist/import.mjs
var import_react = __toESM(require_react(), 1);
function $a28c903ee9ad8dc5$export$79fefeb1c2091ac3(props) {
  let overlayTriggerState = (0, $fc909762b330b746$export$61c6a8c84e605fb6)(props);
  let [focusStrategy, setFocusStrategy] = (0, import_react.useState)(null);
  return {
    focusStrategy,
    ...overlayTriggerState,
    open(focusStrategy2 = null) {
      setFocusStrategy(focusStrategy2);
      overlayTriggerState.open();
    },
    toggle(focusStrategy2 = null) {
      setFocusStrategy(focusStrategy2);
      overlayTriggerState.toggle();
    }
  };
}

// ../node_modules/@react-stately/list/dist/import.mjs
var import_react2 = __toESM(require_react(), 1);
var $a02d57049d202695$var$_Symbol_iterator = Symbol.iterator;
var $a02d57049d202695$export$d085fb9e920b5ca7 = class {
  *[$a02d57049d202695$var$_Symbol_iterator]() {
    yield* this.iterable;
  }
  get size() {
    return this.keyMap.size;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  getKeyBefore(key) {
    let node = this.keyMap.get(key);
    return node ? node.prevKey : null;
  }
  getKeyAfter(key) {
    let node = this.keyMap.get(key);
    return node ? node.nextKey : null;
  }
  getFirstKey() {
    return this.firstKey;
  }
  getLastKey() {
    return this.lastKey;
  }
  getItem(key) {
    return this.keyMap.get(key);
  }
  at(idx) {
    const keys = [
      ...this.getKeys()
    ];
    return this.getItem(keys[idx]);
  }
  getChildren(key) {
    let node = this.keyMap.get(key);
    return (node === null || node === void 0 ? void 0 : node.childNodes) || [];
  }
  constructor(nodes) {
    (0, _defineProperty)(this, "keyMap", /* @__PURE__ */ new Map());
    this.iterable = nodes;
    let visit = (node) => {
      this.keyMap.set(node.key, node);
      if (node.childNodes && node.type === "section")
        for (let child of node.childNodes)
          visit(child);
    };
    for (let node of nodes)
      visit(node);
    let last;
    let index = 0;
    for (let [key, node1] of this.keyMap) {
      if (last) {
        last.nextKey = key;
        node1.prevKey = last.key;
      } else {
        this.firstKey = key;
        node1.prevKey = void 0;
      }
      if (node1.type === "item")
        node1.index = index++;
      last = node1;
      last.nextKey = void 0;
    }
    this.lastKey = last === null || last === void 0 ? void 0 : last.key;
  }
};
function $e72dd72e1c76a225$export$2f645645f7bca764(props) {
  let { filter } = props;
  let selectionState = (0, $7af3f5b51489e0b5$export$253fe78d46329472)(props);
  let disabledKeys = (0, import_react2.useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : /* @__PURE__ */ new Set(), [
    props.disabledKeys
  ]);
  let factory = (nodes) => filter ? new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(filter(nodes)) : new (0, $a02d57049d202695$export$d085fb9e920b5ca7)(nodes);
  let context = (0, import_react2.useMemo)(() => ({
    suppressTextValueWarning: props.suppressTextValueWarning
  }), [
    props.suppressTextValueWarning
  ]);
  let collection = (0, $7613b1592d41b092$export$6cd28814d92fa9c9)(props, factory, context, [
    filter
  ]);
  let selectionManager = (0, import_react2.useMemo)(() => new (0, $d496c0a20b6e58ec$export$6c8a5aaad13c9852)(collection, selectionState), [
    collection,
    selectionState
  ]);
  const cachedCollection = (0, import_react2.useRef)(null);
  (0, import_react2.useEffect)(() => {
    if (selectionState.focusedKey != null && !collection.getItem(selectionState.focusedKey)) {
      const startItem = cachedCollection.current.getItem(selectionState.focusedKey);
      const cachedItemNodes = [
        ...cachedCollection.current.getKeys()
      ].map((key) => {
        const itemNode = cachedCollection.current.getItem(key);
        return itemNode.type === "item" ? itemNode : null;
      }).filter((node) => node !== null);
      const itemNodes = [
        ...collection.getKeys()
      ].map((key) => {
        const itemNode = collection.getItem(key);
        return itemNode.type === "item" ? itemNode : null;
      }).filter((node) => node !== null);
      const diff = cachedItemNodes.length - itemNodes.length;
      let index = Math.min(diff > 1 ? Math.max(startItem.index - diff + 1, 0) : startItem.index, itemNodes.length - 1);
      let newNode;
      while (index >= 0) {
        if (!selectionManager.isDisabled(itemNodes[index].key)) {
          newNode = itemNodes[index];
          break;
        }
        if (index < itemNodes.length - 1)
          index++;
        else {
          if (index > startItem.index)
            index = startItem.index;
          index--;
        }
      }
      selectionState.setFocusedKey(newNode ? newNode.key : null);
    }
    cachedCollection.current = collection;
  }, [
    collection,
    selectionManager,
    selectionState,
    selectionState.focusedKey
  ]);
  return {
    collection,
    disabledKeys,
    selectionManager
  };
}
function $a0d645289fe9b86b$export$e7f05e985daf4b5f(props) {
  var _props_defaultSelectedKey;
  let [selectedKey, setSelectedKey] = (0, $458b0a5536c1a7cf$export$40bfa8c7b0832715)(props.selectedKey, (_props_defaultSelectedKey = props.defaultSelectedKey) !== null && _props_defaultSelectedKey !== void 0 ? _props_defaultSelectedKey : null, props.onSelectionChange);
  let selectedKeys = (0, import_react2.useMemo)(() => selectedKey != null ? [
    selectedKey
  ] : [], [
    selectedKey
  ]);
  let { collection, disabledKeys, selectionManager } = (0, $e72dd72e1c76a225$export$2f645645f7bca764)({
    ...props,
    selectionMode: "single",
    disallowEmptySelection: true,
    allowDuplicateSelectionEvents: true,
    selectedKeys,
    onSelectionChange: (keys) => {
      let key = keys.values().next().value;
      if (key === selectedKey && props.onSelectionChange)
        props.onSelectionChange(key);
      setSelectedKey(key);
    }
  });
  let selectedItem = selectedKey != null ? collection.getItem(selectedKey) : null;
  return {
    collection,
    disabledKeys,
    selectionManager,
    selectedKey,
    setSelectedKey,
    selectedItem
  };
}

// ../node_modules/@react-stately/select/dist/import.mjs
var import_react3 = __toESM(require_react(), 1);
function $2bc3a590c5373a4e$export$5159ec8b34d4ec12(props) {
  let triggerState = (0, $a28c903ee9ad8dc5$export$79fefeb1c2091ac3)(props);
  let listState = (0, $a0d645289fe9b86b$export$e7f05e985daf4b5f)({
    ...props,
    onSelectionChange: (key) => {
      if (props.onSelectionChange != null)
        props.onSelectionChange(key);
      triggerState.close();
    }
  });
  let [isFocused, setFocused] = (0, import_react3.useState)(false);
  return {
    ...listState,
    ...triggerState,
    open() {
      if (listState.collection.size !== 0)
        triggerState.open();
    },
    toggle(focusStrategy) {
      if (listState.collection.size !== 0)
        triggerState.toggle(focusStrategy);
    },
    isFocused,
    setFocused
  };
}
export {
  $2bc3a590c5373a4e$export$5159ec8b34d4ec12 as useSelectState
};
//# sourceMappingURL=@react-stately_select.js.map
