import {
  isNonEmptyArray
} from "./chunk-5OEZIP3U.js";
import {
  getLeft,
  getRight,
  isLeft,
  isRight,
  toEntries
} from "./chunk-PWOXME4P.js";
import {
  getOrElse,
  isNone,
  isSome,
  none,
  some,
  toArray
} from "./chunk-GMICS55Q.js";
import {
  array,
  array3 as array2,
  combineAll,
  equivalence,
  mapInput2 as mapInput,
  max,
  min,
  tuple,
  tuple2
} from "./chunk-PMMD7ZWW.js";
import {
  dual,
  identity,
  isBoolean
} from "./chunk-KURLOJT7.js";
import {
  __export
} from "./chunk-2LSFTFF7.js";

// ../node_modules/effect/dist/esm/Array.js
var Array_exports = {};
__export(Array_exports, {
  allocate: () => allocate,
  append: () => append2,
  appendAll: () => appendAll2,
  cartesian: () => cartesian2,
  cartesianWith: () => cartesianWith2,
  chop: () => chop,
  chunksOf: () => chunksOf2,
  contains: () => contains2,
  containsWith: () => containsWith2,
  copy: () => copy,
  dedupe: () => dedupe,
  dedupeAdjacent: () => dedupeAdjacent2,
  dedupeAdjacentWith: () => dedupeAdjacentWith2,
  dedupeWith: () => dedupeWith,
  difference: () => difference,
  differenceWith: () => differenceWith,
  drop: () => drop2,
  dropRight: () => dropRight,
  dropWhile: () => dropWhile,
  empty: () => empty2,
  every: () => every,
  extend: () => extend,
  filter: () => filter2,
  filterMap: () => filterMap2,
  filterMapWhile: () => filterMapWhile2,
  findFirst: () => findFirst2,
  findFirstIndex: () => findFirstIndex,
  findLast: () => findLast2,
  findLastIndex: () => findLastIndex,
  flatMap: () => flatMap2,
  flatMapNullable: () => flatMapNullable2,
  flatten: () => flatten2,
  forEach: () => forEach2,
  fromIterable: () => fromIterable,
  fromNullable: () => fromNullable,
  fromOption: () => fromOption,
  fromRecord: () => fromRecord2,
  get: () => get,
  getEquivalence: () => getEquivalence2,
  getLefts: () => getLefts2,
  getOrder: () => getOrder2,
  getRights: () => getRights2,
  getSomes: () => getSomes2,
  group: () => group2,
  groupBy: () => groupBy2,
  groupWith: () => groupWith2,
  head: () => head2,
  headNonEmpty: () => headNonEmpty,
  init: () => init,
  initNonEmpty: () => initNonEmpty,
  insertAt: () => insertAt,
  intersection: () => intersection,
  intersectionWith: () => intersectionWith,
  intersperse: () => intersperse2,
  isArray: () => isArray,
  isEmptyArray: () => isEmptyArray,
  isEmptyReadonlyArray: () => isEmptyReadonlyArray,
  isNonEmptyArray: () => isNonEmptyArray2,
  isNonEmptyReadonlyArray: () => isNonEmptyReadonlyArray,
  join: () => join,
  last: () => last,
  lastNonEmpty: () => lastNonEmpty,
  length: () => length,
  liftEither: () => liftEither,
  liftNullable: () => liftNullable,
  liftOption: () => liftOption,
  liftPredicate: () => liftPredicate,
  make: () => make2,
  makeBy: () => makeBy2,
  map: () => map2,
  mapAccum: () => mapAccum,
  match: () => match,
  matchLeft: () => matchLeft,
  matchRight: () => matchRight,
  max: () => max2,
  min: () => min2,
  modify: () => modify,
  modifyNonEmptyHead: () => modifyNonEmptyHead,
  modifyNonEmptyLast: () => modifyNonEmptyLast,
  modifyOption: () => modifyOption,
  of: () => of2,
  partition: () => partition,
  partitionMap: () => partitionMap,
  prepend: () => prepend2,
  prependAll: () => prependAll2,
  range: () => range2,
  reduce: () => reduce2,
  reduceRight: () => reduceRight,
  remove: () => remove,
  replace: () => replace,
  replaceOption: () => replaceOption,
  replicate: () => replicate2,
  reverse: () => reverse,
  rotate: () => rotate,
  scan: () => scan2,
  scanRight: () => scanRight,
  separate: () => separate,
  setNonEmptyHead: () => setNonEmptyHead,
  setNonEmptyLast: () => setNonEmptyLast,
  some: () => some3,
  sort: () => sort,
  sortBy: () => sortBy,
  sortWith: () => sortWith,
  span: () => span,
  split: () => split,
  splitAt: () => splitAt,
  splitNonEmptyAt: () => splitNonEmptyAt,
  splitWhere: () => splitWhere,
  tail: () => tail,
  tailNonEmpty: () => tailNonEmpty,
  take: () => take2,
  takeRight: () => takeRight,
  takeWhile: () => takeWhile2,
  unappend: () => unappend,
  unfold: () => unfold2,
  union: () => union,
  unionWith: () => unionWith,
  unprepend: () => unprepend,
  unsafeGet: () => unsafeGet,
  unzip: () => unzip,
  zip: () => zip2,
  zipWith: () => zipWith2
});

// ../node_modules/effect/dist/esm/Iterable.js
var Iterable_exports = {};
__export(Iterable_exports, {
  append: () => append,
  appendAll: () => appendAll,
  cartesian: () => cartesian,
  cartesianWith: () => cartesianWith,
  chunksOf: () => chunksOf,
  contains: () => contains,
  containsWith: () => containsWith,
  dedupeAdjacent: () => dedupeAdjacent,
  dedupeAdjacentWith: () => dedupeAdjacentWith,
  drop: () => drop,
  empty: () => empty,
  filter: () => filter,
  filterMap: () => filterMap,
  filterMapWhile: () => filterMapWhile,
  findFirst: () => findFirst,
  findLast: () => findLast,
  flatMap: () => flatMap,
  flatMapNullable: () => flatMapNullable,
  flatten: () => flatten,
  forEach: () => forEach,
  fromRecord: () => fromRecord,
  getLefts: () => getLefts,
  getRights: () => getRights,
  getSomes: () => getSomes,
  group: () => group,
  groupBy: () => groupBy,
  groupWith: () => groupWith,
  head: () => head,
  intersperse: () => intersperse,
  isEmpty: () => isEmpty,
  makeBy: () => makeBy,
  map: () => map,
  of: () => of,
  prepend: () => prepend,
  prependAll: () => prependAll,
  range: () => range,
  reduce: () => reduce,
  replicate: () => replicate,
  scan: () => scan,
  size: () => size,
  some: () => some2,
  take: () => take,
  takeWhile: () => takeWhile,
  unfold: () => unfold,
  zip: () => zip,
  zipWith: () => zipWith
});

// ../node_modules/effect/dist/esm/Tuple.js
var Tuple_exports = {};
__export(Tuple_exports, {
  appendElement: () => appendElement,
  getEquivalence: () => getEquivalence,
  getFirst: () => getFirst,
  getOrder: () => getOrder,
  getSecond: () => getSecond,
  make: () => make,
  mapBoth: () => mapBoth,
  mapFirst: () => mapFirst,
  mapSecond: () => mapSecond,
  swap: () => swap
});
var make = (...elements) => elements;
var getFirst = (self) => self[0];
var getSecond = (self) => self[1];
var mapBoth = dual(2, (self, {
  onFirst,
  onSecond
}) => [onFirst(self[0]), onSecond(self[1])]);
var mapFirst = dual(2, (self, f) => [f(self[0]), self[1]]);
var mapSecond = dual(2, (self, f) => [self[0], f(self[1])]);
var swap = (self) => [self[1], self[0]];
var getEquivalence = tuple;
var getOrder = tuple2;
var appendElement = dual(2, (self, that) => [...self, that]);

// ../node_modules/effect/dist/esm/Iterable.js
var makeBy = (f, options) => {
  const max3 = (options == null ? void 0 : options.length) !== void 0 ? Math.max(1, Math.floor(options.length)) : Infinity;
  return {
    [Symbol.iterator]() {
      let i = 0;
      return {
        next() {
          if (i < max3) {
            return {
              value: f(i++),
              done: false
            };
          }
          return {
            done: true,
            value: void 0
          };
        }
      };
    }
  };
};
var range = (start, end) => {
  if (end === void 0) {
    return makeBy((i) => start + i);
  }
  return makeBy((i) => start + i, {
    length: start <= end ? end - start + 1 : 1
  });
};
var replicate = dual(2, (a, n) => makeBy(() => a, {
  length: n
}));
var fromRecord = (self) => ({
  *[Symbol.iterator]() {
    for (const key in self) {
      if (Object.prototype.hasOwnProperty.call(self, key)) {
        yield [key, self[key]];
      }
    }
  }
});
var prepend = dual(2, (self, head3) => prependAll(self, [head3]));
var prependAll = dual(2, (self, that) => appendAll(that, self));
var append = dual(2, (self, last2) => appendAll(self, [last2]));
var appendAll = dual(2, (self, that) => ({
  [Symbol.iterator]() {
    const iterA = self[Symbol.iterator]();
    let doneA = false;
    let iterB;
    return {
      next() {
        if (!doneA) {
          const r = iterA.next();
          if (r.done) {
            doneA = true;
            iterB = that[Symbol.iterator]();
            return iterB.next();
          }
          return r;
        }
        return iterB.next();
      }
    };
  }
}));
var scan = dual(3, (self, b, f) => ({
  [Symbol.iterator]() {
    let acc = b;
    let iterator;
    function next() {
      if (iterator === void 0) {
        iterator = self[Symbol.iterator]();
        return {
          done: false,
          value: acc
        };
      }
      const result = iterator.next();
      if (result.done) {
        return result;
      }
      acc = f(acc, result.value);
      return {
        done: false,
        value: acc
      };
    }
    return {
      next
    };
  }
}));
var isEmpty = (self) => {
  const iterator = self[Symbol.iterator]();
  return iterator.next().done === true;
};
var size = (self) => {
  const iterator = self[Symbol.iterator]();
  let count = 0;
  while (!iterator.next().done) {
    count++;
  }
  return count;
};
var head = (self) => {
  const iterator = self[Symbol.iterator]();
  const result = iterator.next();
  return result.done ? none() : some(result.value);
};
var take = dual(2, (self, n) => ({
  [Symbol.iterator]() {
    let i = 0;
    const iterator = self[Symbol.iterator]();
    return {
      next() {
        if (i < n) {
          i++;
          return iterator.next();
        }
        return {
          done: true,
          value: void 0
        };
      }
    };
  }
}));
var takeWhile = dual(2, (self, predicate) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        const result = iterator.next();
        if (result.done || !predicate(result.value, i++)) {
          return {
            done: true,
            value: void 0
          };
        }
        return result;
      }
    };
  }
}));
var drop = dual(2, (self, n) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        while (i < n) {
          const result = iterator.next();
          if (result.done) {
            return {
              done: true,
              value: void 0
            };
          }
          i++;
        }
        return iterator.next();
      }
    };
  }
}));
var findFirst = dual(2, (self, f) => {
  let i = 0;
  for (const a of self) {
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some(a);
      }
    } else {
      if (isSome(o)) {
        return o;
      }
    }
    i++;
  }
  return none();
});
var findLast = dual(2, (self, f) => {
  let i = 0;
  let last2 = none();
  for (const a of self) {
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        last2 = some(a);
      }
    } else {
      if (isSome(o)) {
        last2 = o;
      }
    }
    i++;
  }
  return last2;
});
var zip = dual(2, (self, that) => zipWith(self, that, make));
var zipWith = dual(3, (self, that, f) => ({
  [Symbol.iterator]() {
    const selfIterator = self[Symbol.iterator]();
    const thatIterator = that[Symbol.iterator]();
    return {
      next() {
        const selfResult = selfIterator.next();
        const thatResult = thatIterator.next();
        if (selfResult.done || thatResult.done) {
          return {
            done: true,
            value: void 0
          };
        }
        return {
          done: false,
          value: f(selfResult.value, thatResult.value)
        };
      }
    };
  }
}));
var intersperse = dual(2, (self, middle) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let next = iterator.next();
    let emitted = false;
    return {
      next() {
        if (next.done) {
          return next;
        } else if (emitted) {
          emitted = false;
          return {
            done: false,
            value: middle
          };
        }
        emitted = true;
        const result = next;
        next = iterator.next();
        return result;
      }
    };
  }
}));
var containsWith = (isEquivalent) => dual(2, (self, a) => {
  for (const i of self) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
});
var _equivalence = equivalence();
var contains = containsWith(_equivalence);
var chunksOf = dual(2, (self, n) => {
  const safeN = Math.max(1, Math.floor(n));
  return {
    [Symbol.iterator]() {
      let iterator = self[Symbol.iterator]();
      return {
        next() {
          if (iterator === void 0) {
            return {
              done: true,
              value: void 0
            };
          }
          const chunk = [];
          for (let i = 0; i < safeN; i++) {
            const result = iterator.next();
            if (result.done) {
              iterator = void 0;
              return chunk.length === 0 ? {
                done: true,
                value: void 0
              } : {
                done: false,
                value: chunk
              };
            }
            chunk.push(result.value);
          }
          return {
            done: false,
            value: chunk
          };
        }
      };
    }
  };
});
var groupWith = dual(2, (self, isEquivalent) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let nextResult;
    return {
      next() {
        let result;
        if (nextResult !== void 0) {
          if (nextResult.done) {
            return {
              done: true,
              value: void 0
            };
          }
          result = nextResult;
          nextResult = void 0;
        } else {
          result = iterator.next();
          if (result.done) {
            return {
              done: true,
              value: void 0
            };
          }
        }
        const chunk = [result.value];
        while (true) {
          const next = iterator.next();
          if (next.done || !isEquivalent(result.value, next.value)) {
            nextResult = next;
            return {
              done: false,
              value: chunk
            };
          }
          chunk.push(next.value);
        }
      }
    };
  }
}));
var group = groupWith(equivalence());
var groupBy = dual(2, (self, f) => {
  const out = {};
  for (const a of self) {
    const k = f(a);
    if (Object.prototype.hasOwnProperty.call(out, k)) {
      out[k].push(a);
    } else {
      out[k] = [a];
    }
  }
  return out;
});
var constEmpty = {
  [Symbol.iterator]() {
    return constEmptyIterator;
  }
};
var constEmptyIterator = {
  next() {
    return {
      done: true,
      value: void 0
    };
  }
};
var empty = () => constEmpty;
var of = (a) => [a];
var map = dual(2, (self, f) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        const result = iterator.next();
        if (result.done) {
          return {
            done: true,
            value: void 0
          };
        }
        return {
          done: false,
          value: f(result.value, i++)
        };
      }
    };
  }
}));
var flatMap = dual(2, (self, f) => flatten(map(self, f)));
var flatten = (self) => ({
  [Symbol.iterator]() {
    const outerIterator = self[Symbol.iterator]();
    let innerIterator;
    function next() {
      if (innerIterator === void 0) {
        const next2 = outerIterator.next();
        if (next2.done) {
          return next2;
        }
        innerIterator = next2.value[Symbol.iterator]();
      }
      const result = innerIterator.next();
      if (result.done) {
        innerIterator = void 0;
        return next();
      }
      return result;
    }
    return {
      next
    };
  }
});
var filterMap = dual(2, (self, f) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        let result = iterator.next();
        while (!result.done) {
          const b = f(result.value, i++);
          if (isSome(b)) {
            return {
              done: false,
              value: b.value
            };
          }
          result = iterator.next();
        }
        return {
          done: true,
          value: void 0
        };
      }
    };
  }
}));
var filterMapWhile = dual(2, (self, f) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        const result = iterator.next();
        if (result.done) {
          return {
            done: true,
            value: void 0
          };
        }
        const b = f(result.value, i++);
        if (isSome(b)) {
          return {
            done: false,
            value: b.value
          };
        }
        return {
          done: true,
          value: void 0
        };
      }
    };
  }
}));
var getSomes = filterMap(identity);
var getLefts = (self) => filterMap(self, getLeft);
var getRights = (self) => filterMap(self, getRight);
var filter = dual(2, (self, predicate) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        let result = iterator.next();
        while (!result.done) {
          if (predicate(result.value, i++)) {
            return {
              done: false,
              value: result.value
            };
          }
          result = iterator.next();
        }
        return {
          done: true,
          value: void 0
        };
      }
    };
  }
}));
var flatMapNullable = dual(2, (self, f) => filterMap(self, (a) => {
  const b = f(a);
  return b == null ? none() : some(b);
}));
var some2 = dual(2, (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (predicate(a, i++)) {
      return true;
    }
  }
  return false;
});
var unfold = (b, f) => ({
  [Symbol.iterator]() {
    let next = b;
    return {
      next() {
        const o = f(next);
        if (isNone(o)) {
          return {
            done: true,
            value: void 0
          };
        }
        const [a, b2] = o.value;
        next = b2;
        return {
          done: false,
          value: a
        };
      }
    };
  }
});
var forEach = dual(2, (self, f) => {
  let i = 0;
  for (const a of self) {
    f(a, i++);
  }
});
var reduce = dual(3, (self, b, f) => {
  if (Array.isArray(self)) {
    return self.reduce(f, b);
  }
  let i = 0;
  let result = b;
  for (const n of self) {
    result = f(result, n, i++);
  }
  return result;
});
var dedupeAdjacentWith = dual(2, (self, isEquivalent) => ({
  [Symbol.iterator]() {
    const iterator = self[Symbol.iterator]();
    let first = true;
    let last2;
    function next() {
      const result = iterator.next();
      if (result.done) {
        return {
          done: true,
          value: void 0
        };
      }
      if (first) {
        first = false;
        last2 = result.value;
        return result;
      }
      const current = result.value;
      if (isEquivalent(last2, current)) {
        return next();
      }
      last2 = current;
      return result;
    }
    return {
      next
    };
  }
}));
var dedupeAdjacent = dedupeAdjacentWith(equivalence());
var cartesianWith = dual(3, (self, that, f) => flatMap(self, (a) => map(that, (b) => f(a, b))));
var cartesian = dual(2, (self, that) => cartesianWith(self, that, (a, b) => [a, b]));

// ../node_modules/effect/dist/esm/Array.js
var make2 = (...elements) => elements;
var allocate = (n) => new Array(n);
var makeBy2 = (n, f) => {
  const max3 = Math.max(1, Math.floor(n));
  const out = new Array(max3);
  for (let i = 0; i < max3; i++) {
    out[i] = f(i);
  }
  return out;
};
var range2 = (start, end) => start <= end ? makeBy2(end - start + 1, (i) => start + i) : [start];
var replicate2 = dual(2, (a, n) => makeBy2(n, () => a));
var fromIterable = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
var fromRecord2 = toEntries;
var fromOption = toArray;
var match = dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(self) : onEmpty());
var matchLeft = dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty(self), tailNonEmpty(self)) : onEmpty());
var matchRight = dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(initNonEmpty(self), lastNonEmpty(self)) : onEmpty());
var prepend2 = dual(2, (self, head3) => [head3, ...self]);
var prependAll2 = dual(2, (self, that) => fromIterable(that).concat(fromIterable(self)));
var append2 = dual(2, (self, last2) => [...self, last2]);
var appendAll2 = dual(2, (self, that) => fromIterable(self).concat(fromIterable(that)));
var scan2 = dual(3, (self, b, f) => {
  const out = [b];
  let i = 0;
  for (const a of self) {
    out[i + 1] = f(out[i], a);
    i++;
  }
  return out;
});
var scanRight = dual(3, (self, b, f) => {
  const input = fromIterable(self);
  const out = new Array(input.length + 1);
  out[input.length] = b;
  for (let i = input.length - 1; i >= 0; i--) {
    out[i] = f(out[i + 1], input[i]);
  }
  return out;
});
var isArray = Array.isArray;
var isEmptyArray = (self) => self.length === 0;
var isEmptyReadonlyArray = isEmptyArray;
var isNonEmptyArray2 = isNonEmptyArray;
var isNonEmptyReadonlyArray = isNonEmptyArray;
var length = (self) => self.length;
var isOutOfBound = (i, as) => i < 0 || i >= as.length;
var clamp = (i, as) => Math.floor(Math.min(Math.max(0, i), as.length));
var get = dual(2, (self, index) => {
  const i = Math.floor(index);
  return isOutOfBound(i, self) ? none() : some(self[i]);
});
var unsafeGet = dual(2, (self, index) => {
  const i = Math.floor(index);
  if (isOutOfBound(i, self)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self[i];
});
var unprepend = (self) => [headNonEmpty(self), tailNonEmpty(self)];
var unappend = (self) => [initNonEmpty(self), lastNonEmpty(self)];
var head2 = get(0);
var headNonEmpty = unsafeGet(0);
var last = (self) => isNonEmptyReadonlyArray(self) ? some(lastNonEmpty(self)) : none();
var lastNonEmpty = (self) => self[self.length - 1];
var tail = (self) => {
  const input = fromIterable(self);
  return isNonEmptyReadonlyArray(input) ? some(tailNonEmpty(input)) : none();
};
var tailNonEmpty = (self) => self.slice(1);
var init = (self) => {
  const input = fromIterable(self);
  return isNonEmptyReadonlyArray(input) ? some(initNonEmpty(input)) : none();
};
var initNonEmpty = (self) => self.slice(0, -1);
var take2 = dual(2, (self, n) => {
  const input = fromIterable(self);
  return input.slice(0, clamp(n, input));
});
var takeRight = dual(2, (self, n) => {
  const input = fromIterable(self);
  const i = clamp(n, input);
  return i === 0 ? [] : input.slice(-i);
});
var takeWhile2 = dual(2, (self, predicate) => {
  let i = 0;
  const out = [];
  for (const a of self) {
    if (!predicate(a, i)) {
      break;
    }
    out.push(a);
    i++;
  }
  return out;
});
var spanIndex = (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (!predicate(a, i)) {
      break;
    }
    i++;
  }
  return i;
};
var span = dual(2, (self, predicate) => splitAt(self, spanIndex(self, predicate)));
var drop2 = dual(2, (self, n) => {
  const input = fromIterable(self);
  return input.slice(clamp(n, input), input.length);
});
var dropRight = dual(2, (self, n) => {
  const input = fromIterable(self);
  return input.slice(0, input.length - clamp(n, input));
});
var dropWhile = dual(2, (self, predicate) => fromIterable(self).slice(spanIndex(self, predicate)));
var findFirstIndex = dual(2, (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (predicate(a, i)) {
      return some(i);
    }
    i++;
  }
  return none();
});
var findLastIndex = dual(2, (self, predicate) => {
  const input = fromIterable(self);
  for (let i = input.length - 1; i >= 0; i--) {
    if (predicate(input[i], i)) {
      return some(i);
    }
  }
  return none();
});
var findFirst2 = findFirst;
var findLast2 = dual(2, (self, f) => {
  const input = fromIterable(self);
  for (let i = input.length - 1; i >= 0; i--) {
    const a = input[i];
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some(a);
      }
    } else {
      if (isSome(o)) {
        return o;
      }
    }
  }
  return none();
});
var insertAt = dual(3, (self, i, b) => {
  const out = Array.from(self);
  if (i < 0 || i > out.length) {
    return none();
  }
  out.splice(i, 0, b);
  return some(out);
});
var replace = dual(3, (self, i, b) => modify(self, i, () => b));
var replaceOption = dual(3, (self, i, b) => modifyOption(self, i, () => b));
var modify = dual(3, (self, i, f) => getOrElse(modifyOption(self, i, f), () => Array.from(self)));
var modifyOption = dual(3, (self, i, f) => {
  const out = Array.from(self);
  if (isOutOfBound(i, out)) {
    return none();
  }
  const next = f(out[i]);
  out[i] = next;
  return some(out);
});
var remove = dual(2, (self, i) => {
  const out = Array.from(self);
  if (isOutOfBound(i, out)) {
    return out;
  }
  out.splice(i, 1);
  return out;
});
var reverse = (self) => Array.from(self).reverse();
var sort = dual(2, (self, O) => {
  const out = Array.from(self);
  out.sort(O);
  return out;
});
var sortWith = dual(3, (self, f, order) => sort(self, mapInput(order, f)));
var sortBy = (...orders) => {
  const sortByAll = sort(combineAll(orders));
  return (self) => {
    const input = fromIterable(self);
    if (isNonEmptyReadonlyArray(input)) {
      return sortByAll(input);
    }
    return [];
  };
};
var zip2 = dual(2, (self, that) => zipWith2(self, that, make));
var zipWith2 = dual(3, (self, that, f) => {
  const as = fromIterable(self);
  const bs = fromIterable(that);
  if (isNonEmptyReadonlyArray(as) && isNonEmptyReadonlyArray(bs)) {
    const out = [f(headNonEmpty(as), headNonEmpty(bs))];
    const len = Math.min(as.length, bs.length);
    for (let i = 1; i < len; i++) {
      out[i] = f(as[i], bs[i]);
    }
    return out;
  }
  return [];
});
var unzip = (self) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const fa = [input[0][0]];
    const fb = [input[0][1]];
    for (let i = 1; i < input.length; i++) {
      fa[i] = input[i][0];
      fb[i] = input[i][1];
    }
    return [fa, fb];
  }
  return [[], []];
};
var intersperse2 = dual(2, (self, middle) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const tail2 = tailNonEmpty(input);
    for (let i = 0; i < tail2.length; i++) {
      if (i < tail2.length) {
        out.push(middle);
      }
      out.push(tail2[i]);
    }
    return out;
  }
  return [];
});
var modifyNonEmptyHead = dual(2, (self, f) => [f(headNonEmpty(self)), ...tailNonEmpty(self)]);
var setNonEmptyHead = dual(2, (self, b) => modifyNonEmptyHead(self, () => b));
var modifyNonEmptyLast = dual(2, (self, f) => append2(initNonEmpty(self), f(lastNonEmpty(self))));
var setNonEmptyLast = dual(2, (self, b) => modifyNonEmptyLast(self, () => b));
var rotate = dual(2, (self, n) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const len = input.length;
    const m = Math.round(n) % len;
    if (isOutOfBound(Math.abs(m), input) || m === 0) {
      return copy(input);
    }
    if (m < 0) {
      const [f, s] = splitNonEmptyAt(input, -m);
      return appendAll2(s, f);
    } else {
      return rotate(self, m - len);
    }
  }
  return [];
});
var containsWith2 = (isEquivalent) => dual(2, (self, a) => {
  for (const i of self) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
});
var _equivalence2 = equivalence();
var contains2 = containsWith2(_equivalence2);
var chop = dual(2, (self, f) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const [b, rest] = f(input);
    const out = [b];
    let next = rest;
    while (isNonEmptyArray(next)) {
      const [b2, rest2] = f(next);
      out.push(b2);
      next = rest2;
    }
    return out;
  }
  return [];
});
var splitAt = dual(2, (self, n) => {
  const input = Array.from(self);
  const _n = Math.floor(n);
  if (isNonEmptyReadonlyArray(input)) {
    if (_n >= 1) {
      return splitNonEmptyAt(input, _n);
    }
    return [[], input];
  }
  return [input, []];
});
var splitNonEmptyAt = dual(2, (self, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self.length ? [copy(self), []] : [prepend2(self.slice(1, _n), headNonEmpty(self)), self.slice(_n)];
});
var split = dual(2, (self, n) => {
  const input = fromIterable(self);
  return chunksOf2(input, Math.ceil(input.length / Math.floor(n)));
});
var splitWhere = dual(2, (self, predicate) => span(self, (a, i) => !predicate(a, i)));
var copy = (self) => self.slice();
var chunksOf2 = dual(2, (self, n) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    return chop(input, splitNonEmptyAt(n));
  }
  return [];
});
var groupWith2 = dual(2, (self, isEquivalent) => chop(self, (as) => {
  const h = headNonEmpty(as);
  const out = [h];
  let i = 1;
  for (; i < as.length; i++) {
    const a = as[i];
    if (isEquivalent(a, h)) {
      out.push(a);
    } else {
      break;
    }
  }
  return [out, as.slice(i)];
}));
var group2 = groupWith2(equivalence());
var groupBy2 = dual(2, (self, f) => {
  const out = {};
  for (const a of self) {
    const k = f(a);
    if (Object.prototype.hasOwnProperty.call(out, k)) {
      out[k].push(a);
    } else {
      out[k] = [a];
    }
  }
  return out;
});
var unionWith = dual(3, (self, that, isEquivalent) => {
  const a = fromIterable(self);
  const b = fromIterable(that);
  if (isNonEmptyReadonlyArray(a)) {
    if (isNonEmptyReadonlyArray(b)) {
      const dedupe2 = dedupeWith(isEquivalent);
      return dedupe2(appendAll2(a, b));
    }
    return a;
  }
  return b;
});
var union = dual(2, (self, that) => unionWith(self, that, _equivalence2));
var intersectionWith = (isEquivalent) => {
  const has = containsWith2(isEquivalent);
  return dual(2, (self, that) => fromIterable(self).filter((a) => has(that, a)));
};
var intersection = intersectionWith(_equivalence2);
var differenceWith = (isEquivalent) => {
  const has = containsWith2(isEquivalent);
  return dual(2, (self, that) => fromIterable(self).filter((a) => !has(that, a)));
};
var difference = differenceWith(_equivalence2);
var empty2 = () => [];
var of2 = (a) => [a];
var map2 = dual(2, (self, f) => self.map(f));
var flatMap2 = dual(2, (self, f) => {
  if (isEmptyReadonlyArray(self)) {
    return [];
  }
  const out = [];
  for (let i = 0; i < self.length; i++) {
    const inner = f(self[i], i);
    for (let j = 0; j < inner.length; j++) {
      out.push(inner[j]);
    }
  }
  return out;
});
var flatten2 = flatMap2(identity);
var filterMap2 = dual(2, (self, f) => {
  const as = fromIterable(self);
  const out = [];
  for (let i = 0; i < as.length; i++) {
    const o = f(as[i], i);
    if (isSome(o)) {
      out.push(o.value);
    }
  }
  return out;
});
var filterMapWhile2 = dual(2, (self, f) => {
  let i = 0;
  const out = [];
  for (const a of self) {
    const b = f(a, i);
    if (isSome(b)) {
      out.push(b.value);
    } else {
      break;
    }
    i++;
  }
  return out;
});
var partitionMap = dual(2, (self, f) => {
  const left = [];
  const right = [];
  const as = fromIterable(self);
  for (let i = 0; i < as.length; i++) {
    const e = f(as[i], i);
    if (isLeft(e)) {
      left.push(e.left);
    } else {
      right.push(e.right);
    }
  }
  return [left, right];
});
var getSomes2 = filterMap2(identity);
var getLefts2 = (self) => {
  const out = [];
  for (const a of self) {
    if (isLeft(a)) {
      out.push(a.left);
    }
  }
  return out;
};
var getRights2 = (self) => {
  const out = [];
  for (const a of self) {
    if (isRight(a)) {
      out.push(a.right);
    }
  }
  return out;
};
var filter2 = dual(2, (self, predicate) => {
  const as = fromIterable(self);
  const out = [];
  for (let i = 0; i < as.length; i++) {
    if (predicate(as[i], i)) {
      out.push(as[i]);
    }
  }
  return out;
});
var partition = dual(2, (self, predicate) => {
  const left = [];
  const right = [];
  const as = fromIterable(self);
  for (let i = 0; i < as.length; i++) {
    if (predicate(as[i], i)) {
      right.push(as[i]);
    } else {
      left.push(as[i]);
    }
  }
  return [left, right];
});
var separate = partitionMap(identity);
var reduce2 = dual(3, (self, b, f) => fromIterable(self).reduce((b2, a, i) => f(b2, a, i), b));
var reduceRight = dual(3, (self, b, f) => fromIterable(self).reduceRight((b2, a, i) => f(b2, a, i), b));
var liftPredicate = (predicate) => (b) => predicate(b) ? [b] : [];
var liftOption = (f) => (...a) => fromOption(f(...a));
var fromNullable = (a) => a == null ? empty2() : [a];
var liftNullable = (f) => (...a) => fromNullable(f(...a));
var flatMapNullable2 = dual(2, (self, f) => isNonEmptyReadonlyArray(self) ? fromNullable(f(headNonEmpty(self))) : empty2());
var liftEither = (f) => (...a) => {
  const e = f(...a);
  return isLeft(e) ? [] : [e.right];
};
var every = dual(2, (self, refinement) => self.every(refinement));
var some3 = dual(2, (self, predicate) => self.some(predicate));
var extend = dual(2, (self, f) => self.map((_, i, as) => f(as.slice(i))));
var min2 = dual(2, (self, O) => self.reduce(min(O)));
var max2 = dual(2, (self, O) => self.reduce(max(O)));
var unfold2 = (b, f) => {
  const out = [];
  let next = b;
  let o;
  while (isSome(o = f(next))) {
    const [a, b2] = o.value;
    out.push(a);
    next = b2;
  }
  return out;
};
var getOrder2 = array2;
var getEquivalence2 = array;
var forEach2 = dual(2, (self, f) => fromIterable(self).forEach((a, i) => f(a, i)));
var dedupeWith = dual(2, (self, isEquivalent) => {
  const input = fromIterable(self);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const rest = tailNonEmpty(input);
    for (const r of rest) {
      if (out.every((a) => !isEquivalent(r, a))) {
        out.push(r);
      }
    }
    return out;
  }
  return [];
});
var dedupe = (self) => dedupeWith(self, equivalence());
var dedupeAdjacentWith2 = dual(2, (self, isEquivalent) => {
  const out = [];
  let lastA = none();
  for (const a of self) {
    if (isNone(lastA) || !isEquivalent(a, lastA.value)) {
      out.push(a);
      lastA = some(a);
    }
  }
  return out;
});
var dedupeAdjacent2 = dedupeAdjacentWith2(equivalence());
var join = dual(2, (self, sep) => fromIterable(self).join(sep));
var mapAccum = dual(3, (self, s, f) => {
  let i = 0;
  let s1 = s;
  const out = [];
  for (const a of self) {
    const r = f(s1, a, i);
    s1 = r[0];
    out.push(r[1]);
    i++;
  }
  return [s1, out];
});
var cartesianWith2 = dual(3, (self, that, f) => flatMap2(self, (a) => map2(that, (b) => f(a, b))));
var cartesian2 = dual(2, (self, that) => cartesianWith2(self, that, (a, b) => [a, b]));

export {
  make,
  Tuple_exports,
  empty,
  Iterable_exports,
  make2,
  allocate,
  makeBy2 as makeBy,
  range2 as range,
  replicate2 as replicate,
  fromIterable,
  fromRecord2 as fromRecord,
  fromOption,
  match,
  matchLeft,
  matchRight,
  prepend2 as prepend,
  prependAll2 as prependAll,
  append2 as append,
  appendAll2 as appendAll,
  scan2 as scan,
  scanRight,
  isArray,
  isEmptyArray,
  isEmptyReadonlyArray,
  isNonEmptyArray2 as isNonEmptyArray,
  isNonEmptyReadonlyArray,
  length,
  get,
  unsafeGet,
  unprepend,
  unappend,
  head2 as head,
  headNonEmpty,
  last,
  lastNonEmpty,
  tail,
  tailNonEmpty,
  init,
  initNonEmpty,
  take2 as take,
  takeRight,
  takeWhile2 as takeWhile,
  span,
  drop2 as drop,
  dropRight,
  dropWhile,
  findFirstIndex,
  findLastIndex,
  findFirst2 as findFirst,
  findLast2 as findLast,
  insertAt,
  replace,
  replaceOption,
  modify,
  modifyOption,
  remove,
  reverse,
  sort,
  sortWith,
  sortBy,
  zip2 as zip,
  zipWith2 as zipWith,
  unzip,
  intersperse2 as intersperse,
  modifyNonEmptyHead,
  setNonEmptyHead,
  modifyNonEmptyLast,
  setNonEmptyLast,
  rotate,
  containsWith2 as containsWith,
  contains2 as contains,
  chop,
  splitAt,
  splitNonEmptyAt,
  split,
  splitWhere,
  copy,
  chunksOf2 as chunksOf,
  groupWith2 as groupWith,
  group2 as group,
  groupBy2 as groupBy,
  unionWith,
  union,
  intersectionWith,
  intersection,
  differenceWith,
  difference,
  empty2,
  of2 as of,
  map2 as map,
  flatMap2 as flatMap,
  flatten2 as flatten,
  filterMap2 as filterMap,
  filterMapWhile2 as filterMapWhile,
  partitionMap,
  getSomes2 as getSomes,
  getLefts2 as getLefts,
  getRights2 as getRights,
  filter2 as filter,
  partition,
  separate,
  reduce2 as reduce,
  reduceRight,
  liftPredicate,
  liftOption,
  fromNullable,
  liftNullable,
  flatMapNullable2 as flatMapNullable,
  liftEither,
  every,
  some3 as some,
  extend,
  min2 as min,
  max2 as max,
  unfold2 as unfold,
  getOrder2 as getOrder,
  getEquivalence2 as getEquivalence,
  forEach2 as forEach,
  dedupeWith,
  dedupe,
  dedupeAdjacentWith2 as dedupeAdjacentWith,
  dedupeAdjacent2 as dedupeAdjacent,
  join,
  mapAccum,
  cartesianWith2 as cartesianWith,
  cartesian2 as cartesian,
  Array_exports
};
//# sourceMappingURL=chunk-ZFGDRCSG.js.map
